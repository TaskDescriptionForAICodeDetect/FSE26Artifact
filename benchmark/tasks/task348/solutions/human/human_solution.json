[
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <ctime>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nint N;\nvector<P> vc;\nD eps=1e-9;\nbool comp(const P& l,const P& r){\n\tif(l.real()!=r.real()) return l.real()<r.real();\n\treturn l.imag()<r.imag();\n}\ninline D dot(P a, P b) { return real(conj(a)*b);};\ninline D cro(P a, P b) { return imag(conj(a)*b);};\ninline P perp(L l, P p){\t\t//垂線の足\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline P refl(L l, P p){\n\treturn p+2.0*(perp(l,p)-p);\n}\nint exist(P p){\n\tint x=ceil(p.real()-eps),y=ceil(p.imag()-eps);\n\tif(abs(p-P(x,y))>eps) return N;\n\treturn lower_bound(all(vc),P(x,y),comp)-vc.begin();\n}\nint main(){\n\tsrand((unsigned int)time(NULL));\n\tcin>>N;\n\trep(i,N){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tvc.pb(P(x,y));\n\t}\n\tsort(all(vc),comp);\n\tbool safe=false;\n\tfor(int i=2;i<N;i++){\n\t\tif(abs(cro(vc[1]-vc[2],vc[0]-vc[2]))>eps) safe=true;\n\t}\n\tif(!safe){\n\t\tcout<<\"No\\n\";\n\t\treturn 0;\n\t}\n//\trep(i,N) show(vc[i]);\n//\tcout<<endl;\n\trep(tt,N*20){\n\t\tbool can=true;\n\t\tint x=rand()%N,y=rand()%N;\n\t\tif(x==y) continue;\n\t\tP p=vc[x],q=vc[y],m=(p+q)/2.0;\n\t\tL l=L((p-m)*P(0,1)+m,(p-m)*P(0,-1)+m);\n/*\t\tif(x==0&&y==3){\n\t\t\tshow(l.fs);\n\t\t\tshow(l.sc);\n\t\t}*/\n\t\tint cnt=0;\n\t\trep(i,N){\n\t\t\tP ref=refl(l,vc[i]);\n\t\t\tint id=exist(ref);\n/*\t\t\tif(x==0&&y==3){\n\t\t\t\tshow(i);\n\t\t\t\tshow(id);\n\t\t\t}*/\n\t\t\tif(id==N||abs(vc[id]-ref)>eps){\n\t\t\t\tcan=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(id==i) cnt++;\n\t\t}\n//\t\tif(cnt>=3) can=false;\n\t\tif(can){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\nconst Point rot(cos(0.1357L), sin(0.1357L));\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q):a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2):a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b):p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2,0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nbool solve(Polygon g, Line l)\n{\n\tint cnt = 0;\n\tPolygon r;\n\tREP(i, g.size())\n\t{\n\t\tif (isis_lp(l, g[i])) cnt++;\n\t\tr.push_back(mirror(l, g[i]));\n\t}\n\tif (cnt > 2) return false;\n\tsort(ALL(g));\n\tsort(ALL(r));\n\tREP(i, g.size())\n\t{\n\t\tif (abs(g[i] - r[i]) < EPS) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tPolygon p;\n\tREP(i, n)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(Point(x, y)*rot);\n\t}\n\tsort(ALL(p));\n\tPolygon g = convex_hull(p);\n\tint v = g.size();\n\tif (v < 3)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tREP(i, v)\n\t{\n\t\tLine l(g[i], g[(i + 1) % v]);\n\t\tPoint vec = l.b - l.a;\n\t\tPoint m = (l.a + l.b) / Point(2,0);\n\t\tLine s(m, m + Point(-vec.imag(), vec.real()));\n\t\tif (solve(p, s)) ans = true;\n\t}\n\tif (v % 2 == 0)\n\t{\n\t\tREP(i, v/2)\n\t\t{\n\t\t\tLine l(g[i], g[i + v / 2]);\n\t\t\tif (solve(p, l)) ans = true;\n\t\t}\n\t}\n\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef vector<P> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            cnt[l] += 1;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n\n        set<P> s;\n        REP(i, N) s.insert(ps[i]);\n        \n        assert(s.size() == N);\n\n        bool ans = false;\n        for(auto cp : cnt) {\n            //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!s.count(rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                for(int i = 0; i < N; i++) {\n                    P rp = refl(cp.first, ps[i]);\n                    cout << ps[i] << \"<->\" << rp << endl;\n                }\n                break;\n            }\n            */\n        }\n\n        if(N <= 2) {\n            ans = false;\n        } else if(N == 3) {\n            L l = {ps[0], ps[1]};\n            L m = {ps[1], ps[2]};\n            if(l == m) ans = false;\n        }\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef vector<P> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            cnt[l] += 1;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n\n        set<P> s;\n        REP(i, N) s.insert(ps[i]);\n        \n        assert(s.size() == N);\n\n        bool ans = false;\n        for(auto cp : cnt) {\n            //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!s.count(rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                for(int i = 0; i < N; i++) {\n                    P rp = refl(cp.first, ps[i]);\n                    cout << ps[i] << \"<->\" << rp << endl;\n                }\n                break;\n            }\n            */\n        }\n\n        if(N <= 2) {\n            ans = false;\n        } else if(N == 3) {\n            L l = {ps[0], ps[1]};\n            L m = {ps[1], ps[2]};\n            if(l == m) ans = false;\n        }\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst double eps=1e-7;\n\nint sgn(double a){\n    if (fabs(a)<eps) return 0;\n    if (a<0) return -1;\n    return 1;\n}\n\nint cmp(double a,double b){\n    return sgn(a-b);\n}\n\ndouble sqr(double a) {return a*a;}\n\nstruct Point{\n    Point(double _x=0,double _y=0):x(_x),y(_y){}\n    \n    void Read() {scanf(\"%lf%lf\",&x,&y);}\n    \n    Point operator - () const {return Point(-x,-y);}\n    Point operator + (Point p) const {return Point(x+p.x,y+p.y);}\n    Point operator - (Point p) const {return Point(x-p.x,y-p.y);}\n    Point operator * (double d) const {return Point(x*d,y*d);}\n    Point operator / (double d) const {return Point(x/d,y/d);}\n    \n    double Length() const {return sqrt(x*x+y*y);}\n    double SqrLength() const {return x*x+y*y;}\n    \n    bool operator == (const Point p) const {return cmp(x,p.x)==0 && cmp(y,p.y)==0;}\n    bool operator < (const Point p) const {return cmp(x,p.x)<0 || (cmp(x,p.x)==0 && cmp(y,p.y)<0);}\n    \n    double x,y;\n    \n    friend double Distance(Point p1,Point p2) {return (p1-p2).Length();}\n    friend Point Rotate90(Point p) {return Point(-p.y,p.x);}\n    friend Point Normalize(Point p) {return p/p.Length();}\n    friend double Cross(Point p1,Point p2) {return p1.x*p2.y-p1.y*p2.x;}\n    friend int CrossOp(Point p1,Point p2) {return sgn(Cross(p1,p2));}\n    friend int CrossOp(Point p1,Point p2,Point p3) {return sgn(Cross(p2-p1,p3-p1));}\n    friend double Dot(Point p1,Point p2) {return p1.x*p2.x+p1.y*p2.y;}\n};\n\nstruct Line{\n    Line(){}\n    Line(Point _s,Point _t):s(_s),t(_t){}\n    Point s,t;\n    \n    friend bool PointOnLine(Line l,Point p){\n        return CrossOp(p-l.s,l.t-l.s)==0;\n    }\n    friend Point GetLineProjectPoint(Line l,Point p){\n        Point dir=l.t-l.s;\n        return l.s+dir*(Dot(dir,p-l.s)/dir.SqrLength());\n    }\n    friend Point GetLineReflectPoint(Line l,Point p){\n        Point q=GetLineProjectPoint(l,p);\n        Point ret=q*2-p;\n        return ret;\n    }\n};\n\nbool SameLine(vector<Point> f){\n    for(int i=2;i<f.size();i++){\n        if (CrossOp(f[0]-f[i],f[1]-f[i])!=0){\n            return false;\n        }\n    }\n    return true;\n}\n\nint n;\nvector<Point> f;\nset<Point> s;\n\nbool CheckSymmetry(Line l){    \n    int cnt=0;\n    for(int i=0;i<n;i++){\n        if (PointOnLine(l,f[i])){\n            cnt++;\n        } else{\n            Point p=f[i];\n            Point q=GetLineReflectPoint(l,p);\n            if (!s.count(q)) return false;\n        }\n    }\n    if (cnt>2) return false;\n    return true;\n}\n\nint main(){\n    scanf(\"%d\",&n);\n    f.resize(n);\n    for(int i=0;i<n;i++){\n        f[i].Read();\n        s.insert(f[i]);\n    }\n        \n    if (SameLine(f)){\n        puts(\"No\");\n        return 0;\n    }\n    \n    bool ans=false;\n    for(int i=1;i<n;i++){\n        Point dir=Rotate90(f[i]-f[0]);\n        Point midP=(f[i]+f[0])*0.5;\n        Line l(midP,midP+dir);\n        bool state=CheckSymmetry(l);\n        ans = ans || state;\n    }\n    for(int i=2;i<n;i++){\n        Point dir=Rotate90(f[i]-f[1]);\n        Point midP=(f[i]+f[1])*0.5;\n        Line l(midP,midP+dir);\n        bool state=CheckSymmetry(l);\n        ans = ans || state;\n    }\n    ans = ans || CheckSymmetry(Line(f[0],f[1]));    \n    puts(ans?\"Yes\":\"No\");\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <utility>\n#include <cmath>\n#include <set>\n#define eps 1e-8\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nstruct vec2d{\n\tdouble x, y;\n\tvec2d(){}\n\tvec2d(double x, double y){\n\t\tthis->x = x, this->y = y;\n\t}\n\tdouble add(double a, double b){\n\t\tif(fabs(a+b) < eps * (fabs(a) + fabs(b))) return 0.0;\n\t\treturn a+b;\n\t}\n\tvec2d operator+(vec2d ope){\n\t\treturn vec2d(add(x, ope.x), add(y, ope.y));\n\t}\n\tvec2d operator-(vec2d ope){\n\t\treturn vec2d(add(x, -ope.x), add(y, -ope.y));\n\t}\n\tvec2d operator*(double t){\n\t\treturn vec2d(x*t, y*t);\n\t}\n\tvec2d operator/(double t){\n\t\treturn vec2d(x/t, y/t);\n\t}\n\tdouble dot(vec2d ope){\n\t\treturn add(x*ope.x, y*ope.y);\n\t}\n\tdouble cross(vec2d ope){\n\t\treturn add(x*ope.y, -y*ope.x);\n\t}\n\tdouble norm(){\n\t\tdouble d2 = dot(*this);\n\t\tif(d2 > 0) return sqrt(d2);\n\t\treturn 0.0;\n\t}\n\tP near(){\n\t\tP ret;\n\t\tint cx = ceil(x), fx = floor(x);\n\t\tif(fabs(cx-x) < eps) ret.first = cx;\n\t\telse if(fabs(fx-x) < eps) ret.first = fx;\n\t\telse return make_pair(-inf, -inf);\n\t\t\n\t\tint cy = ceil(y), fy = floor(y);\n\t\tif(fabs(cy-y) < eps) ret.second = cy;\n\t\telse if(fabs(fy-y) < eps) ret.second = fy;\n\t\telse return make_pair(-inf, -inf);\n\t\t\n\t\treturn ret;\n\t}\n};\n\nint n;\nint x[1005], y[1005];\nvec2d p[1005];\nset<P> S;\n\nint main(void)\n{\n\tcin >> n;\n\tfor(int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n\tfor(int i = 1; i <= n; i++) p[i] = vec2d(x[i], y[i]);\n\tfor(int i = 1; i <= n; i++) S.insert(make_pair(x[i], y[i]));\n\t\n\tbool flag = false;\n\tfor(int i = 2; i <= n; i++){\n\t\tif(fabs( (p[2]-p[1]).cross(p[i]-p[1]) ) > eps){\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(!flag){\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\t\n\tfor(int k = 1; k <= 3; k++){\n\t\tfor(int i = 1; i <= n; i++){\n\t\t\tif(i == k) continue;\n\t\t\tvec2d v = p[i] - p[k];\n\t\t\tbool flag = true; int cnt = 0;\n\t\t\tfor(int j = 1; j <= n; j++){\n\t\t\t\tvec2d u = p[k] - p[j];\n\t\t\t\tvec2d q = p[j] + v + (v/v.norm())*(2*u.dot(v/v.norm()));\n\t\t\t\tif(!S.count(q.near())){\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(p[j].near() == q.near()) cnt++;\n\t\t\t}\n\t\t\tif(flag && cnt <= 2){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<complex>\n#include<ctime>\n#include<utility>\n#include<set>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nconst double eps=1e-9;\n\ntemplate<class T> bool eq(T a,T b){\n\treturn abs(a-b)<eps;\n}\n\ntypedef complex<double> Point;\ntypedef complex<double> Vector;\ntypedef pair<Point,Point> Line;\n\ntypedef pair<int,int> P;\n\nvector<Line> cands;\nset<P> se;\n\nPoint points[1010];\n\ndouble doP(Vector v1,Vector v2){\n\treturn (conj(v1)*v2).real();\n}\n\ndouble dis(Point p1,Point p2){\n\treturn abs(p1-p2);\n}\t\n\nLine midPerp(Point p1,Point p2){\n\tPoint mid=(p1+p2)*0.5;\n\tVector vec=p2-p1;\n\tVector tmp=Vector(vec.imag(),vec.real());\n\treturn Line(mid+tmp,mid-tmp);\n}\n\nPoint proj(Point p,Point b){\n\treturn b*doP(p,b)/norm(b);\n}\n\nPoint proj(Point a,Point b,Point p){\n\treturn a+proj(p-a,b-a);\n}\n\nPoint refl(Point a,Point b,Point p){\n\tPoint h=proj(a,b,p);\n\treturn h*2.0-p;\n}\n\nPoint refl(Line l,Point p){\n\treturn refl(l.first,l.second,p);\n}\n\nbool onSeg(Point p1,Point p2,Point q){\n\treturn eq(dis(p1,p2),dis(p1,q)+dis(q,p2));\n}\n\nbool onLine(Point p1,Point p2,Point p3){\n\treturn onSeg(p1,p2,p3)||onSeg(p2,p3,p1)||onSeg(p3,p1,p2);\n}\n\nint toInt(double x){\n\tint i=x;\n\tif(eq(x-i,0.0)) return i;\n\tif(eq(x-i,1.0)) return i+1;\n\treturn 1e9;\n}\n\nint main(){\n\tdouble start=clock();\n\tint N;\n\tscanf(\"%d\",&N);\n\tfor(int i=0;i<N;i++){\n\t\tint x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tse.insert(P(x,y));\n\t\tpoints[i]=Point(x,y);\n\t}\n\tbool flg=true;\n\tfor(int i=2;i<N;i++){\n\t\tif(onLine(points[0],points[1],points[i])==false) flg=false;\n\t}\n\tif(flg){\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t}\n\tfor(int i=0;i<N;i++) for(int j=i+1;j<N;j++){\n\t\tcands.push_back(Line(points[i],points[j]));\n\t\tLine l=midPerp(points[i],points[j]);\n\t\tcands.push_back(l);\n\t}\n\tsrand(time(NULL));\n\twhile(true){\n//\tfor(int stage=0;stage<10;stage++){\n\t\tdouble cur=clock();\n\t\tif(cur-start>7000){\n\t\t\tprintf(\"No\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tint id=rand()%cands.size();\n\t\tLine l=cands[id];\n//\t\tprintf(\"(%f,%f)-(%f,%f)\\n\",l.first.real(),l.first.imag(),l.second.real(),l.second.imag());\n//\t\tif(eq(l.first,Point(0,2))&&eq(l.second,Point(0,0))) printf(\"here!!!\\n\");\n\t\tint cnt=0;\n\t\tbool ok=true;\n\t\tfor(int i=0;i<N;i++){\n\t\t\tif(onLine(l.first,l.second,points[i])) cnt++;\n\t\t\telse{\n\t\t\t\tPoint q=refl(l,points[i]);\n\t\t\t\tint x=toInt(q.real());\n\t\t\t\tint y=toInt(q.imag());\n//\t\t\t\tprintf(\"(%f,%f)->(%f,%f)\\n\",points[i].real(),points[i].imag(),q.real(),q.imag());\n\t\t\t\tP pp=P(x,y);\n\t\t\t\tif(se.find(pp)==se.end()) ok=false;\n\t\t\t}\n\t\t}\n\t\tif(ok==false) continue;\n\t\tif(cnt>2) continue;\n\t\tprintf(\"Yes\\n\");\n\t//\tprintf(\"(%f,%f)-(%f,%f)\\n\",l.first.real(),l.first.imag(),l.second.real(),l.second.imag());\n\t\treturn 0;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-6;\ntypedef complex<double> P;\ntypedef vector<P> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            cnt[l] += 1;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n\n        set<P> s;\n        REP(i, N) s.insert(ps[i]);\n        \n        assert(s.size() == N);\n\n        bool ans = false;\n        // for(auto cp : cnt) {\n        //     //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        // }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!s.count(rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                for(int i = 0; i < N; i++) {\n                    P rp = refl(cp.first, ps[i]);\n                    cout << ps[i] << \"<->\" << rp << endl;\n                }\n                break;\n            }\n            */\n        }\n\n        if(N <= 2) {\n            ans = false;\n        } else if(N == 3) {\n            L l = {ps[0], ps[1]};\n            L m = {ps[1], ps[2]};\n            if(l == m) ans = false;\n        }\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\tif (lhs.imag() < rhs.imag() - eps) return true;\n\t\tif (lhs.imag() > rhs.imag() + eps) return false;\n\t\treturn false;\n\t}\n\tbool operator==(const Point &lhs, const Point &rhs) {\n\t\treturn eq(lhs.imag() , rhs.imag())&&eq(lhs.real(),rhs.real());\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n//\n//6\n//0 0\n//3 4\n//-3 -4\n//6 8\n//4 -3\n//7 1\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint main() {\n\tint N; cin >> N;\n\tvector<Point>ps;\n\tld sumx=0, sumy=0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.push_back(Point(x, y));\n\t\tsumx += x; sumy += y;\n\t}\n\tPoint centerp(sumx / N, sumy / N);\n\t{\n\t\tLine l(ps[0], ps[1]);\n\t\tif (all_of(ps.begin(), ps.end(), [=](const Point &p) {return isis_lp(l, p); })) {\n\t\t\tcout << \"No\" << endl; \n\t\t\treturn 0;\n\t\t}\n\t}\n\tint isc = -1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (centerp == ps[i]) {\n\t\t\tisc = i;\n\t\t}\n\t}\n\tif (isc != -1) {\n\t\tps.erase(ps.begin() + isc);\n\t\tN--;\n\t}\n\n\tsort(ps.begin(), ps.end(), [=](const Point &l, const Point &r) {\n\t\tPoint aap(atan(l - centerp));\n\t\tPoint ap(atan(r - centerp));\n\t\tld l_val = (l - centerp).imag()/ (l - centerp).real();\n\t\tld r_val = (r - centerp).imag() / (r - centerp).real();\n\t\tif (l.real() < centerp.real() && centerp.real() < r.real())return true;\n\t\tif (r.real() < centerp.real() && centerp.real() < l.real())return false;\n\t\treturn l_val < r_val;\n\t});\n\t{\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tLine s_line = Line(centerp, ps[i]);\n\t\t\tvector<set<Point>>ismirrors(3);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tint aa = i==j?0:ccw(ps[i], centerp, ps[j]);\n\t\t\t\tif (aa == 2 || aa == -2)aa = 0;\n\t\t\t\taa++;\n\t\t\t\tismirrors[aa].emplace(ps[j]);\n\t\t\t}\n\t\t\tint left_num = ismirrors[0].size();\n\t\t\tint right_num = ismirrors[2].size();\n\t\t\tint center_num = N - left_num - right_num+(isc!=-1);\n\t\t\tif ((left_num != right_num) || (center_num>left_num + right_num) || (center_num>2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (auto lp : ismirrors[0]) {\n\t\t\t\t\tPoint cp = proj(s_line, lp);\n\t\t\t\t\tPoint revp = cp * 2.l - lp;\n\t\t\t\t\tauto it = ismirrors[2].find(revp);\n\t\t\t\t\tif (it != ismirrors[2].end()) {\n\t\t\t\t\t\tismirrors[2].erase(it);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tLine s_line = Line(centerp, (ps[i]+ps[(i+1)%N])/2.l);\n\t\t\tvector<set<Point>>ismirrors(3);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tint aa = ccw((ps[i] + ps[(i + 1) % N]) / 2.l, centerp, ps[j]);\n\t\t\t\tif (aa == 2 || aa == -2)aa = 0;\n\t\t\t\taa++;\n\t\t\t\tismirrors[aa].emplace(ps[j]);\n\t\t\t}\n\t\t\tint left_num = ismirrors[0].size();\n\t\t\tint right_num = ismirrors[2].size();\n\t\t\tint center_num = N - left_num - right_num+(isc != -1);\n\t\t\tif ((left_num != right_num) || (center_num>left_num + right_num) || (center_num>2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (auto lp : ismirrors[0]) {\n\t\t\t\t\tPoint cp = proj(s_line, lp);\n\t\t\t\t\tPoint revp = cp * 2.l - lp;\n\t\t\t\t\tauto it = ismirrors[2].find(revp);\n\t\t\t\t\tif (it != ismirrors[2].end()) {\n\t\t\t\t\t\tismirrors[2].erase(it);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\n// geometry library from hos\n\nconst double PI = acos(-1);\n\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\n\nstruct Pt{\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble abs() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n\tbool operator<(const Pt &a) const { return x < a.x || x == a.x && y < a.y; }\n\tbool operator==(const Pt &a) const { return x == a.x && y == a.y; }\n\tbool operator!=(const Pt &a) const { return x != a.x || y != a.y; }\n};\n\nostream &operator<<(ostream &os, const Pt &a) { os << \"(\" << a.x << \", \" << a.y << \")\"; return os; }\n\n// end of library from hos\n\nPt proj(Pt l0, Pt l1, Pt p){\n\tdouble t = (p - l0).dot(l1 - l0) / (l1 - l0).abs2();\n\treturn l0 + (l1 - l0) * t;\n}\n\nPt refl(Pt l0, Pt l1, Pt p){\n\treturn p + (proj(l0, l1, p) - p) * 2;\n}\n\nint N;\nPt p[1010];\nset<pi> S;\n\nint check(int ai){\n\tPt a = p[ai];\n\trep(bi,N)if(bi!=ai){\n\t\tPt b = p[bi];\n\t\tPt l0 = (a+b)/2;\n\t\tPt l1 = l0 + (b-l0)*Pt(0,1);\n\t\tint ok=1,c=0;\n\t\trep(i,N){\n\t\t\tPt Q = refl(l0,l1,p[i]);\n\t\t\tint x = floor(Q.x+EPS), y = floor(Q.y+EPS);\n\t\t\tif(sig(x-Q.x) || sig(y-Q.y) || !S.count(mp(x,y))){\n\t\t\t\tok=0;break;\n\t\t\t}\n\t\t\tif(sig((p[i]-Q).abs2())==0){\n\t\t\t\tc++;\n\t\t\t\tif(c>2){\n\t\t\t\t\tok=0;break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(ok)return 1;\n\t}\n\treturn 0;\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>N;\n\trep(i,N){\n\t\tcin>>p[i].x>>p[i].y;\n\t\tS.insert(mp(p[i].x,p[i].y));\n\t}\n\tint ok=0;\n\trep2(i,1,N){\n\t\tif(sig((p[i]-p[0]).det(p[1]-p[0])))ok=1;\n\t}\n\tif(!ok)return cout<<\"No\"<<endl,0;\n\trep(i,3){\n\t\tif(check(i))return cout<<\"Yes\"<<endl,0;\n\t}\n\tcout<<\"No\"<<endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nD dot(P a,P b){ return (conj(a)*b).X; }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nvector<P> convex_hull(vector<P>& ps){\n  sort(ps.begin(),ps.end(),[](const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; });\n  int n=ps.size();\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool intersectLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\n\nint N;\nvector<P> ps;\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  vector<P> cs=convex_hull(ps);\n  if(cs.size()!=ps.size()){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  ps.clear();\n  rep(i,N){\n    ps.push_back(cs[i]);\n    ps.push_back((cs[i]+cs[(i+1)%N])*0.5);\n  }\n\n  bool is_sym=false;\n  rep(i,N){\n    bool ok=true;\n    P p1=ps[i],p2=ps[i+N];\n    for(int l=(i-1+2*N)%(2*N),r=i+1;l!=r;l=(l-1+2*N)%(2*N),r=(r+1)%(2*N)){\n      P m=(ps[l]+ps[r])*0.5;\n      if(!intersectLP(L(p1,p2),m)||abs(dot(ps[l]-ps[r],p1-p2))>eps)ok=false;\n    }\n    if(ok){\n      is_sym=true;\n    }\n  }\n\n  if(is_sym)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <ctime>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nint N;\nvector<P> vc;\nD eps=1e-9;\nbool comp(const P& l,const P& r){\n\tif(l.real()!=r.real()) return l.real()<r.real();\n\treturn l.imag()<r.imag();\n}\ninline D dot(P a, P b) { return real(conj(a)*b);};\ninline D cro(P a, P b) { return imag(conj(a)*b);};\ninline P perp(L l, P p){\t\t//垂線の足\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline P refl(L l, P p){\n\treturn p+2.0*(perp(l,p)-p);\n}\nint exist(P p){\n\tint x=ceil(p.real()-eps),y=ceil(p.imag()-eps);\n\tif(abs(p-P(x,y))>eps) return N;\n\treturn lower_bound(all(vc),P(x,y),comp)-vc.begin();\n}\nint main(){\n\tsrand((unsigned int)time(NULL));\n\tcin>>N;\n\trep(i,N){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tvc.pb(P(x,y));\n\t}\n\tsort(all(vc),comp);\n\tbool safe=false;\n\tfor(int i=2;i<N;i++){\n\t\tif(abs(cro(vc[1]-vc[i],vc[0]-vc[i]))>eps) safe=true;\n\t}\n\tif(!safe){\n\t\tcout<<\"No\\n\";\n\t\treturn 0;\n\t}\n//\trep(i,N) show(vc[i]);\n//\tcout<<endl;\n\trep(tt,20*N){\n\t\tbool can=true;\n\t\tint x=rand()%N,y=rand()%N;\n\t\tif(x==y) continue;\n\t\tP p=vc[x],q=vc[y],m=(p+q)/2.0;\n\t\tL l=L((p-m)*P(0,1)+m,(p-m)*P(0,-1)+m);\n/*\t\tif(x==0&&y==3){\n\t\t\tshow(l.fs);\n\t\t\tshow(l.sc);\n\t\t}*/\n\t\tint cnt=0;\n\t\trep(i,N){\n\t\t\tP ref=refl(l,vc[i]);\n\t\t\tint id=exist(ref);\n/*\t\t\tif(x==0&&y==3){\n\t\t\t\tshow(i);\n\t\t\t\tshow(id);\n\t\t\t}*/\n\t\t\tif(id==N||abs(vc[id]-ref)>eps){\n\t\t\t\tcan=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(id==i) cnt++;\n\t\t}\n//\t\tif(cnt>=3) can=false;\n\t\tif(can){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\n\nPt hLP(Pt a,Pt b,Pt c){\n\treturn pLL(a,b,c,c+(b-a)*Pt(0,1));\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).ABS();\n}\ndouble x[1100];\ndouble y[1100];\nPt p[1100];\nset<pair<int,int> > S;\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\tfor(int i=0;i<a;i++)p[i]=Pt(x[i],y[i]);\n\tfor(int i=0;i<a;i++)S.insert(make_pair(round(x[i]),round(y[i])));\n\tbool dame=true;\n\tfor(int i=2;i<a;i++){\n\t\tif(dLP(p[0],p[1],p[i])>EPS)dame=false;\n\t}\n\tif(dame){\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t}\n\tbool ok=false;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tPt L=(p[i]+p[j])/2;\n\t\t\tPt v=(p[j]-p[i])*Pt(0,1);\n\t\t\tPt R=L+v;\n\t\t\tbool OK=true;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(i==k||j==k)continue;\n\t\t\t\tif(dLP(L,R,p[k])<EPS)cnt++;\n\t\t\t\telse{\n\t\t\t\t\tPt tmp=hLP(L,R,p[k]);\n\t\t\t\t\tPt to=tmp+tmp-p[k];\n\t\t\t\t\tint X=round(to.x);\n\t\t\t\t\tint Y=round(to.y);\n\t//\t\t\t\tif(i==0&&j==3)printf(\"%d: %f %f %d %d\\n\",k,to.x,to.y,X,Y);\n\t\t\t\t\tif((Pt((double)X,(double)Y)-to).ABS()>EPS)OK=false;\n\t\t\t\t\telse if(!S.count(make_pair(X,Y)))OK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printf(\"%d %d: %d\\n\",i,j,cnt);\n\t\t\tif(!OK)continue;\n\t\t\t\n\t\t\tif(cnt>2){\n\t\t\t\tprintf(\"No\\n\");return 0;\n\t\t\t}else ok=true;\n\t\t}\n\t}\n\tif(ok)printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nLine getPerpendicularBisector(Point a,Point b){\n  Point m=b+((a-b)/2.0);\n  Vector v1=(m-a),v2=(m-b);\n  swap(v1.x,v1.y);\n  v1.y=(-1.0)*v1.y;\n  swap(v2.x,v2.y);\n  v2.y=(-1.0)*v2.y;\n  return Line(m+v1,m+v2);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2 && ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2 && ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint n;\nvector<Point> vp;\nPolygon p;\nset<Point> s;\n\nbool check(Line L){\n  int count=0;\n  vector<Point> vpp;\n  for(int i=0;i<vp.size();i++){\n    int c=ccw(L.p1,L.p2,vp[i]);\n    if(c==2 || c==-2 || c==0){\n      count++;\n    }\n    //else if(s.find(reflect(L,vp[i]))==s.end())return false;\n    vpp.push_back(reflect(L,vp[i]));\n  }\n  sort(vpp.begin(),vpp.end());\n  if(vpp!=vp)return false;\n  if(count==3)return false;\n  return true;\n}\n\nint main()\n{\n  int x,y;\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    vp.push_back(Point(x,y));\n    s.insert(Point(x,y));\n  }\n  sort(vp.begin(),vp.end());\n  p=convex_hull(vp);\n\n  string ans=\"No\";\n  int s=p.size();\n  if(s<=vp.size()){\n    for(int i=0;i<s;i++){\n      Line L = getPerpendicularBisector(p[i],p[(i+1)%s]);\n      if(check(L))ans=\"Yes\";\n      if(s%2==0){\n\tL=Line(p[i],p[(i+s/2)%s]);\n\tif(check(L))ans=\"Yes\";\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef array<P, 2> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n        if(cnt.size() == 1) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            if(i == 0 || cnt.count(l)) {\n                cnt[l] += 1;\n            }\n        }\n\n        //set<P> s;\n        //REP(i, N) s.insert(ps[i]);\n        sort(ps.begin(), ps.end());\n        bool ans = false;\n        // for(auto cp : cnt) {\n        //     //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        // }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!binary_search(ps.begin(), ps.end(), rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                DrawLine(cp.first);\n                for(int i = 0; i < N; i++) {\n                    DrawPoint(ps[i]);\n                    P rp = refl(cp.first, ps[i]);\n                    assert(s.count(rp));\n                    cout << ps[i] << \"<->\" << rp << \"(\" << s[rp] << \")\" << endl;\n                    assert(s[ refl(cp.first, rp) ] == i);\n                }\n                break;\n            }\n            */\n        }\n\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-9;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\nconst Point rot(cos(0.575L), sin(0.575L));\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q):a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2):a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b):p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2,0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nbool solve(Polygon g, Line l)\n{\n\tint cnt = 0;\n\tPolygon r;\n\tREP(i, g.size())\n\t{\n\t\tif (isis_lp(l, g[i])) cnt++;\n\t\tr.push_back(mirror(l, g[i]));\n\t}\n\tif (cnt > 2) return false;\n\tsort(ALL(g));\n\tsort(ALL(r));\n\tREP(i, g.size())\n\t{\n\t\tif (abs(g[i] - r[i]) < EPS) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tPolygon p;\n\tREP(i, n)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(Point(x, y)*rot);\n\t}\n\tsort(ALL(p));\n\tPolygon g = convex_hull(p);\n\tint v = g.size();\n\tif (v < 3)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tREP(i, v)\n\t{\n\t\tLine l(g[i], g[(i + 1) % v]);\n\t\tPoint vec = l.b - l.a;\n\t\tPoint m = (l.a + l.b) / Point(2,0);\n\t\tLine s(m, m + Point(-vec.imag(), vec.real()));\n\t\tif (solve(p, s)) ans = true;\n\t}\n\tif (v % 2 == 0)\n\t{\n\t\tREP(i, v/2)\n\t\t{\n\t\t\tLine l(g[i], g[i + v / 2]);\n\t\t\tif (solve(p, l)) ans = true;\n\t\t}\n\t}\n\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef vector<P> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble zoom = 1/20.0;\nconst int OFFSET = 1000;\nvoid ChangeColor(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\nvoid DrawPoint(const P &p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\",\n      (int)(OFFSET+zoom*p.real()), 1980-OFFSET-(int)(zoom*p.imag()), 2);\n}\nvoid DrawLine(const L &l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\",\n      (int)(OFFSET+zoom*l[0].real()), 1980-OFFSET-(int)(zoom*l[0].imag()),\n      (int)(OFFSET+zoom*l[1].real()), 1980-OFFSET-(int)(zoom*l[1].imag()));\n}\n\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n        if(cnt.size() == 1) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            cnt[l] += 1;\n        }\n\n        //set<P> s;\n        //REP(i, N) s.insert(ps[i]);\n        sort(ps.begin(), ps.end());\n\n        bool ans = false;\n        // for(auto cp : cnt) {\n        //     //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        // }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!binary_search(ps.begin(), ps.end(), rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                DrawLine(cp.first);\n                for(int i = 0; i < N; i++) {\n                    DrawPoint(ps[i]);\n                    P rp = refl(cp.first, ps[i]);\n                    assert(s.count(rp));\n                    cout << ps[i] << \"<->\" << rp << \"(\" << s[rp] << \")\" << endl;\n                    assert(s[ refl(cp.first, rp) ] == i);\n                }\n                break;\n            }\n            */\n        }\n\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\n#define EPS (1e-1)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nPolygon tangent(Circle c1,Circle c2){\n  Polygon p;\n  return p;\n}\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  set<Point> sp;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=andrewScan(p);\n  if(equals(area(q),0)){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  for(int i=0;i<n;i++) sp.insert(p[i]);\n  for(int k=0;k<min(10LL,n);k++){\n    for(int i=0;i<n;i++){\n      if(i==k) continue;\n      {\n\tbool flg=1;\n\tLine l(p[k],p[i]);\n\tfor(int j=0;j<n;j++)\n\t  flg&=equals(getDistanceLP(l,p[j]),0)||sp.count(reflect(l,p[j]));\n\tif(flg){\n\t  int cnt=0;\n\t  for(int j=0;j<n;j++)\n\t    cnt+=equals(getDistanceLP(l,p[j]),0);\n\t  if(cnt<3){\n\t    cout<<\"Yes\"<<endl;\n\t    exit(0);\n\t  }\n\t}\n      }\n      {\n\tbool flg=1;\n\tLine l=bisector(p[k],p[i]);\n\tfor(int j=0;j<n;j++)\n\t  flg&=equals(getDistanceLP(l,p[j]),0)||sp.count(reflect(l,p[j]));\n\tif(flg){\n\t  int cnt=0;\n\t  for(int j=0;j<n;j++)\n\t    cnt+=equals(getDistanceLP(l,p[j]),0);\n\t  if(cnt<3){\n\t    cout<<\"Yes\"<<endl;\n\t    exit(0);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct Point {\n\tlong long x, y;\n\n\tPoint (long long x = 0, long long y = 0) : x(x), y(y) {}\n\n\tvoid in() {\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\tx *= 2, y *= 2;\n\t}\n\n\tPoint operator + (const Point &a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\n\tPoint operator - (const Point &a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n\n\tPoint operator * (const long long &k) const {\n\t\treturn Point(x * k, y * k);\n\t}\n\n\tPoint operator / (const long long &k) const {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tbool operator < (const Point &a) const {\n\t\treturn x < a.x || (x == a.x && y < a.y);\n\t}\n\n\tlong long len2() const {\n\t\treturn x * x + y * y;\n\t}\n\n\tPoint turn90() const {\n\t\treturn Point(-y, x);\n\t}\n};\n\nlong long dot(const Point &a, const Point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nlong long det(const Point &a, const Point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct Line {\n\tPoint a, b;\n\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nbool project(const Point &p, const Line &l, Point &q) {\n\tlong long dt = dot(p - l.a, l.b - l.a);\n\tPoint pp = (l.b - l.a) * dt;\n\tlong long d = (l.b - l.a).len2();\n\tif (pp.x % d != 0 || pp.y % d != 0) {\n\t\treturn false;\n\t}\n\tq = l.a + pp / d;\n\treturn true;\n}\n\nbool reflect(const Line &l, const Point &p, Point &q) {\n\tif (!project(p, l, q)) {\n\t\treturn false;\n\t}\n\tq = q + q - p;\n\treturn true;\n}\n\nbool onLine(const Line &l, const Point &p) {\n\treturn det(p - l.a, l.b - l.a) == 0;\n}\n\nconst int N = 1005;\n\nint n;\n\nset<Point> tr;\n\nPoint p[N];\n\nbool sameLine() {\n\tfor (int i = 2; i < n; ++i) {\n\t\tif (det(p[i] - p[0], p[1] - p[0]) != 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nbool check(const Line &l) {\n\tint cnt = 0;\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (onLine(l, p[i])) {\n\t\t\t++cnt;\n\t\t} else {\n\t\t\tPoint q;\n\t\t\tif (!reflect(l, p[i], q)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!tr.count(q)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn cnt <= 2;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tp[i].in();\n\t\ttr.insert(p[i]);\n\t}\n\tif (sameLine()) {\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tfor (int i = 1; i < n; ++i) {\n\t\tPoint m = (p[0] + p[i]) / 2,\n\t\t\t  mm = m + (p[i] - p[0]).turn90();\n\t\tans = ans || check(Line(m, mm));\n\t}\n\tfor (int i = 2; i < n; ++i) {\n\t\tPoint m = (p[1] + p[i]) / 2,\n\t\t\t  mm = m + (p[i] - p[1]).turn90();\n\t\tans = ans || check(Line(m, mm));\n\t}\n\tans = ans || check(Line(p[0], p[1]));\n\tputs(ans ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-8;\nbool eq(double a,double b){\n  double EPS=max( abs(a) , abs(b) ) * eps ;\n  EPS=max(EPS,eps);\n  return (-EPS<a-b&&a-b<EPS);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){\n      cnt++;\n      continue;\n    }\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt%2==1)res=false;\n  return res;\n}\n\nbool solve(){\n  \n  //  for(int i=0;i<N;i++)\n  //    for(int j=0;j<i;j++)\n  //      assert(t[i]!=t[j]);\n\n  bool flag=false;\n  for(int i=1;i<N;i++){\n    P a=t[0];\n    P b=t[i];\n    if(check(a,b))flag=true;\n    P c=(a+b)*0.5;\n    P d=c+(b-a)*P(0,1);\n    if(check(c,d))flag=true;\n  }\n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-7;\nbool eq(double a,double b){\n  double EPS = max( abs(a) , abs(b) ) * eps;\n  EPS=max(EPS,eps);\n  return (-EPS<a-b&&a-b<EPS);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){cnt++;continue;}\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt>1 && cnt%2==1 )res=false;\n  return res;\n}\n\nbool solve(){\n  P b=t[0];\n  int cnt=0;\n  for(int i=1;i<N;i++){\n    b+=t[i];\n    double v=cross(t[1]-t[0],t[i]-t[0]);\n    if(eq(v,0))cnt++;\n  }\n  if(cnt==N-1)return false;\n\n  b/=(double)N;\n  \n  bool flag=false;\n  for(int i=0;i<N;i++){\n    P a=t[i];\n    if( eq(0, abs(a-b) ) )continue;\n    if(check(a,b))flag=true;\n  }\n\n  for(int i=1;i<N;i++){\n    P c=t[0];\n    P d=t[i];\n    P nc=(c+d)*0.5;\n    P nd=nc+(d-c)*P(0,1);\n    if(check(nc,nd))flag=true;\n  }  \n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n    for(int j=0;j<i;j++)assert(t[i]!=t[j]);\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<complex>\n#include<set>\n#include<utility>\n\nusing namespace std;\n\ntypedef complex<double> P;\n\nint x[1234],y[1234];\nP p[1234];\nset<pair<int,int> > ps;\nint N;\ndouble eps=1e-9;\n\ndouble cross(P a,P b){\n  return a.real()*b.imag()-a.imag()*b.real();\n}\n\nint nol(P a,P b){\n  int n=0;\n  for(int i=0;i<N;i++){\n    n+=fabs(cross(p[i]-a,b-a))<eps;\n  }\n  return n;\n}\n\nbool check(P a,P b){\n  if(nol(a,b)>2)return false;\n  for(int i=0;i<N;i++){\n    P vp=p[i]-a;\n    P r=vp*polar(1.,(arg(b-a)-arg(vp))*2)+a;\n    int y=r.imag()+.5-(r.imag()<0);\n    int x=r.real()+.5-(r.real()<0);\n    if(abs(r-P(x,y))>eps||!ps.count(make_pair(y,x)))return false;\n  }\n  return true;\n}\n\nint main(){\n  cin>>N;\n  for(int i=0;i<N;i++){\n    cin>>x[i]>>y[i];\n    ps.insert(make_pair(y[i],x[i]));\n    p[i]=P(x[i],y[i]);\n  }\n  bool sym=false;\n  if(nol(p[0],p[1])!=N){\n    for(int i=0;i<2;i++){\n      for(int j=i+1;j<N;j++){\n\tauto m=(p[i]+p[j])/2.;\n\tsym|=check(m,(p[i]-m)*P(0,-1)+m);\n      }\n    }\n    sym|=check(p[0],p[1]);\n  }\n  cout<<(sym?\"Yes\":\"No\")<<endl;\n}\n\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> PI;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nvector<P> convex_hull(vector<P>& ps){\n  sort(ps.begin(),ps.end(),[](const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; });\n  int n=ps.size();\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<=0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool intersectLP(L l,P p){\n  //dbg(abs(cross(l[1]-p,l[0]-p)));\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nP reflection(L l,P p) {\n  return p+2.0*(projection(l,p)-p);\n}\n\nint N;\nvector<P> ps;\nset<PI> st;\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n    st.insert(PI(x,y));\n  }\n  vector<P> cs=convex_hull(ps);\n  int M=cs.size();\n  vector<P> ds;\n  rep(i,M){\n    ds.push_back(cs[i]);\n    ds.push_back((cs[i]+cs[(i+1)%M])*0.5);\n  }\n  vector<L> cand;\n  rep(i,M){\n    bool ok=true;\n    P p1=ds[i],p2=ds[i+M];\n    for(int l=(i-1+2*M)%(2*M),r=i+1;l!=r;l=(l-1+2*M)%(2*M),r=(r+1)%(2*M)){\n      P m=(ds[l]+ds[r])*0.5;\n      if(!intersectLP(L(p1,p2),m)||abs(dot(ds[l]-ds[r],p1-p2))>eps)ok=false;\n    }\n    if(ok){\n      cand.push_back(L(p1,p2));\n    }\n  }\n\n  bool is_sym=false;\n  rep(i,cand.size()){\n    bool ok=true;\n    int cnt=0;\n    rep(j,N){\n      if(intersectLP(cand[i],ps[j])){cnt++;continue;}\n      P r=reflection(cand[i],ps[j]);\n      int px=round(r.X);\n      int py=round(r.Y);\n      if(abs((double)px-r.X)>eps)ok=false;\n      if(abs((double)py-r.Y)>eps)ok=false;\n      if(st.count(PI(round(r.X),round(r.Y)))==0)ok=false;\n    }\n    if(ok&&cnt<3)is_sym=true;\n  }\n\n  if(is_sym)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-8;\nbool eq(double a,double b){\n  double EPS = max( abs(a) , abs(b) ) * eps;\n  EPS=max(EPS,eps);\n  return (-EPS<a-b&&a-b<EPS);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){cnt++;continue;}\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt%2==1)res=false;\n  return res;\n}\n\nbool solve(){\n  int cnt=0;\n  for(int i=1;i<N;i++){\n    double v=cross(t[1]-t[0],t[i]-t[0]);\n    if(eq(v,0))cnt++;\n  }\n  if(cnt==N-1)return false;\n  \n  bool flag=false;\n  for(int i=1;i<N;i++){\n    P a=t[0], b=t[i];\n    if(check(a,b))flag=true;\n    P c=(a+b)*0.5;\n    P d=c+(b-a)*P(0,1);\n    if(check(c,d))flag=true;\n  }\n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n    \n    for(int j=0;j<i;j++)assert(t[i]!=t[j]);\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<vector>\n#include<iomanip>\n#include<math.h>\n#include<complex>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<map>\n#include<set>\n#include<bitset>\n#include<functional>\n#include<assert.h>\n#include<numeric>\nusing namespace std;\n#define REP(i,m,n) for(int i=(int)(m) ; i < (int) (n) ; ++i )\n#define rep(i,n) REP(i,0,n)\nusing ll = long long;\nconst int inf=1e9+7;\nconst ll longinf=1LL<<60 ;\nconst ll mod=1e9+7 ;\n\nusing ld = double;\nusing Point =  complex<ld>;\nconst ld eps = 1e-7;\nconst ld pi = acos(-1.0);\n\nbool eq(ld a, ld b) {\n\treturn (abs(a - b) < eps);\n}\n//内積\nld dot(Point a, Point b) {\n\treturn real(conj(a)*b);\n}\n//外積\nld cross(Point a, Point b) {\n\treturn imag(conj(a)*b);\n}\n//線分\n//直線にするなら十分通い２点を端点とすればよい\nclass Line {\npublic:\n\tPoint a, b;\n};\n//円\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n};\n//3点の位置関係\nint ccw(Point a, Point b, Point c) {\n\tb -= a; c -= a;\n\tif (cross(b, c) > eps)return 1;//a,b,cが反時計回り\n\tif (cross(b, c) < -eps)return -1;//a,b,cが時計回り\n\tif (dot(b, c) < 0)return 2;//c,a,bの順に一直線\n\tif (norm(b) < norm(c))return -2;//a,b,cの順に一直線\n\treturn 0;//a,c,bの順に一直線\n}\n//2直線の交差判定\nbool isis_ll(Line l, Line m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n//直線と線分の交差判定\nbool isis_ls(Line l, Line s) {\n\treturn (cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < eps);\n}\n//点が直線上に存在するか\nbool isis_lp(Line l, Point p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n//点が線分上に存在するか\nbool isis_sp(Line s, Point p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n//線分と線分の交差判定\nbool isis_ss(Line s, Line t) {\n\tif (isis_sp(s, t.a) || isis_sp(s, t.b) || isis_sp(t, s.a) || isis_sp(t, s.b))return true;\n\treturn(cross(s.b - s.a, t.a - s.a)*cross(s.b - s.a, t.b - s.a) < -eps && cross(t.b - t.a, s.a - t.a)*cross(t.b - t.a, s.b - t.a) < -eps);\n}\n//点から直線への垂線の足\nPoint proj(Line l, Point p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n//直線と直線の交点\n//平行な２直線に対しては使うな！！！！\nPoint is_ll(Line s, Line t) {\n\tPoint sv = s.b - s.a; Point tv = t.b - t.a;\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n//直線と点の距離\nld dist_lp(Line l, Point p) {\n\treturn abs(p - proj(l, p));\n}\n//直線と直線の距離\nld dist_ll(Line l, Line m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n//線分と直線の距離\nld dist_ls(Line l, Line s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n//線分と点の距離\nld dist_sp(Line s, Point p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(p - r) : min(abs(p - s.a), abs(p - s.b));\n}\n//線分と線分の距離\nld dist_ss(Line s, Line t) {\n\tif (isis_ss(s, t))return 0;\n\treturn min({ dist_sp(s,t.a),dist_sp(s,t.b),dist_sp(t,s.a),dist_sp(t,s.b) });\n}\nint main(){\n    int n;\n    cin>>n;\n    int x[n],y[n];\n    map<pair<int,int>,int> mp;\n    Point a[n];\n    rep(i,n){\n        cin>>x[i]>>y[i];\n        x[i]*=2;y[i]*=2;\n        mp[{x[i],y[i]}]++;\n        a[i]=Point(x[i],y[i]);\n    }\n    bool one_line = true;\n    rep(i,n){\n        if(!isis_lp(Line{a[0],a[1]},a[i]))one_line=false;\n    } \n    if(one_line){\n        cout<<\"No\"<<endl;\n        return 0;\n    }\n    rep(k,3){\n        rep(i,n){\n            if(i==k)continue;\n            Point d((a[i]-a[k]).imag(),-(a[i]-a[k]).real());\n            Point mid =(a[i]+a[k])/(ld)2.0;\n            Point l = mid + d, r = mid - d ;\n            Line lr={l, r};\n            int cnt=0;\n            bool ok=true;\n            rep(j,n){\n                if(j==k||j==i)continue;\n                if(isis_lp(lr,a[j]))++cnt;\n                else {\n                    Point h = proj(lr,a[j]);\n                    Point cont = (ld)2.0 * h - a[j];\n                    int X = round(cont.real());\n                    int Y = round(cont.imag());\n                    if(abs(X-cont.real())>eps||abs(Y-cont.imag())>eps)ok=false;\n                    else if(!mp[{X,Y}])ok=false;\n                }\n                if(!ok)break;\n            }\n            if(cnt>2)ok=false;\n            if(ok){\n                cout<<\"Yes\"<<endl;\n                return 0;\n            }\n        }\n    }\n    cout<<\"No\"<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<ll> vll;\ntypedef pair<int,int> pint;\n\n#define DE 1\n#define FI first\n#define SE second\n#define PB push_back\n#define MP make_pair\n#define ALL(s) (s).begin(),(s).end()\n#define REP(i,n) for (int i = 0; i < (int)(n); ++i)\n#define EACH(i,s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<<endl\n\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, pair<T1,T2> P){return s<<'<'<<P.first<<\", \"<<P.second<<'>';}\ntemplate<class T> ostream& operator<<(ostream &s, vector<T> P) {s<<\"{ \";for(int i=0;i<P.size();++i){if(i>0)s<<\", \";s<<P[i];}return s<<\" }\"<<endl;}\ntemplate<class T1, class T2> ostream& operator<<(ostream &s, map<T1,T2> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<'<'<<it->first<<\"->\"<<it->second<<'>';}return s<<\" }\"<<endl;}\ntemplate<class T> ostream& operator<<(ostream &s, set<T> P) {s<<\"{ \";for(__typeof__(P.begin()) it=P.begin();it!=P.end();++it){if(it!=P.begin())s<<\", \";s<<*it;}return s<<\" }\"<<endl;}\n\n\n\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ndouble torad(int deg) {return (double)(deg) * PI / 180;}\ndouble todeg(double ang) {return ang * 180 / PI;}\nint cast(double num) {\n    if (num >= 0) return (int)(num + EPS);\n    else return -(int)(-num + EPS);\n}\n\nstruct Point {\n    double x, y;\n    Point(double x = 0.0, double y = 0.0) : x(x), y(y) {}\n    friend ostream& operator << (ostream &s, const Point &p) {return s << '(' << p.x << \", \" << p.y << ')';}\n};\n\nPoint operator + (Point p, Point q) {return Point(p.x + q.x, p.y + q.y);}\nPoint operator - (Point p, Point q) {return Point(p.x - q.x, p.y - q.y);}\nPoint operator * (Point p, double a) {return Point(p.x * a, p.y * a);}\nPoint operator * (double a, Point p) {return Point(a * p.x, a * p.y);}\nPoint operator * (Point p, Point q) {return Point(p.x * q.x - p.y * q.y, p.x * q.y + p.y * q.x);}\nPoint operator / (Point p, double a) {return Point(p.x / a, p.y / a);}\nPoint conj(Point p) {return Point(p.x, -p.y);}\nPoint rot(Point p, double ang) {return Point(cos(ang) * p.x - sin(ang) * p.y, sin(ang) * p.x + cos(ang) * p.y);}\nPoint rot90(Point p) {return Point(-p.y, p.x);}\ndouble cross(Point p, Point q) {return p.x * q.y - p.y * q.x;}\ndouble dot(Point p, Point q) {return p.x * q.x + p.y * q.y;}\ndouble norm(Point p) {return dot(p, p);}\ndouble abs(Point p) {return sqrt(dot(p, p));}\nbool eq(Point p, Point q) {return abs(p - q) < EPS;}\ndouble amp(Point p) {double res = atan2(p.y, p.x); if (res < 0) res += PI*2; return res;}\nbool operator < (Point p, Point q) {return (abs(p.x - q.x) > EPS ? p.x < q.x : p.y < q.y);}\nbool operator > (Point p, Point q) {return (abs(p.x - q.x) > EPS ? p.x > q.x : p.y > q.y);}\nPoint operator / (Point p, Point q) {return p * conj(q) / norm(q);}\n\n\nstruct Line : vector<Point> {\n    Line(Point a = Point(0.0, 0.0), Point b = Point(0.0, 0.0)) {\n        this->push_back(a);\n        this->push_back(b);\n    }\n};\n\n\nvector<Point> convexhull_All(vector<Point> ps) {\n    int n = ps.size();\n    vector<Point> res(2*n);\n    sort(ps.begin(), ps.end());\n    int k = 0;\n    for (int i = 0; i < n; ++i) {\n        if (k >= 2) {\n            while (cross(res[k-1] - res[k-2], ps[i] - res[k-2]) < -EPS) {\n                --k;\n                if (k < 2) break;\n            }\n        }\n        res[k] = ps[i]; ++k;\n    }\n    int t = k+1;\n    for (int i = n-2; i >= 0; --i) {\n        if (k >= t) {\n            while (cross(res[k-1] - res[k-2], ps[i] - res[k-2]) < -EPS) {\n                --k;\n                if (k < t) break;\n            }\n        }\n        res[k] = ps[i]; ++k;\n    }\n    res.resize(k-1);\n    return res;\n}\n\n\nPoint proj(Point p, Line l) {\n    double t = dot(p - l[0], l[1] - l[0]) / norm(l[1] - l[0]);\n    return l[0] + (l[1] - l[0]) * t;\n}\nPoint refl(Point p, Line l) {\n    return p + (proj(p, l) - p) * 2;\n}\n\ndouble distancePL(Point p, Line l) {\n    return abs(p - proj(p, l));\n}\n\n\n\nint N;\ndouble x, y;\n\nint main() {\n    while (cin >> N) {\n        set<pint> se;\n        vector<Point> ps(N);\n        for (int i = 0; i < N; ++i) {\n            cin >> x >> y;\n            se.insert(MP(x, y));\n            ps[i] = Point(x, y);\n        }\n        bool res = false;\n        \n        vector<Point> ch = convexhull_All(ps);\n        int n = ch.size();\n        vector<Point> mid(n), mch;\n        for (int i = 0; i < n; ++i) mid[i] = (ch[i] + ch[(i+1)%n]) / 2;\n        for (int i = 0; i < n; ++i) {mch.PB(ch[i]); mch.PB(mid[i]);}\n        \n        for (int i = 0; i < n; ++i) {\n            Line l(mch[i], mch[i+n]);\n            if (eq(l[0], l[1])) continue;\n            int con = 0;\n            EACH(it, se) {\n                pint ip = *it;\n                Point p(ip.FI, ip.SE);\n                if (distancePL(p, l) < EPS) ++con;\n            }\n            if (con >= 3) continue;\n            \n            bool ok = true;\n            EACH(it, se) {\n                pint ip = *it;\n                Point p(ip.FI, ip.SE);\n                Point q = refl(p, l);\n                pint iq(cast(q.x), cast(q.y));\n                if (abs(iq.FI - q.x) > EPS || abs(iq.SE - q.y) > EPS) {ok = false; break;}\n                if (!se.count(iq)) {ok = false; break;}\n            }\n\n            if (ok) {res = true; break;}\n        }\n        \n        if (res) cout << \"Yes\" << endl;\n        else cout << \"No\" << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point {\npublic:\n  double x,y;\n\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (const Point& p) { return Point(x+p.x,y+p.y); }\n  Point operator - (const Point& p) { return Point(x-p.x,y-p.y); }\n  Point operator * (const double& p) { return Point(x*p,y*p); }\n  Point operator / (const double& p) { return Point(x/p,y/p); }\n  \n  bool operator < ( const Point & p ) const { return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y);}\n  bool operator == ( const Point & p ) const { return equals(x,p.x) && equals(y,p.y); }\n  \n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\nostream& operator << (ostream& os,const Point&a ) { os << \"(\" << a.x << \",\" << a.y << \")\"; }\nostream& operator << (ostream& os,const Segment& a) { os << \"(\" << a.p1 << \",\" << a.p2 << \")\"; }\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble toRad(double a){ return a * M_PI / 180.0; }\nPoint rotate(Point a,double rad) { return Point(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) <-EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLP(Line l,Point p){\n  return abs(cross(l.p2-p,l.p1-p)) < EPS;\n}\n\nPoint projection(Line l,Point p) {\n  double  t = dot(p-l.p1,l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + ( l.p1 - l.p2 ) * t;\n}\n\nPoint reflection(Line l,Point p){\n  return p + (projection(l,p)-p) * 2;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y-q.y) - (r.y-q.y) * (p.x-q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool onSegment(Point p,Point q,Point r) {\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2))+sqrt(pow(r.x-q.x,2)+pow(r.y-q.y,2)),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)));\n}\n\nconst string YES = \"Yes\";\nconst string NO  = \"No\";\nint n;\n\nPolygon answerScan(Polygon s){\n  Polygon u,l;\n  if( s.size() < 3 ) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  REP(i,2,s.size()){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n\n}\n\nbool isValid(vector<Point> &vec) {\n  Line line = Line(vec[0],vec[1]);\n  bool ok = false;\n  rep(i,vec.size()) {\n    if( !intersectLP(line,vec[i]) ) { ok = true; break; }\n  }\n  if( !ok ) return false;\n  return true;\n}\n\n\nvoid compute(vector<Point> &vec){\n  if( !isValid(vec) ) {\n    cout << NO << endl;\n    return;\n  }\n\n  Polygon poly = answerScan(vec);\n  //rep(i,poly.size()) cout << poly[i] << endl;\n  rep(i,poly.size()){\n    Vector v = poly[(i+1)%poly.size()] - poly[i];\n    v = rotate(v,toRad(90));\n    Vector e = v / abs(v);\n    Point mid_p = (poly[i]+poly[(i+1)%poly.size()])/2;\n    Line line = Line(mid_p,mid_p+e*100);\n    vector<Point> vec_CW,vec_CCW;\n    int on_line = 0;\n    rep(j,n){\n      if( intersectLP(line,vec[j]) ) { ++on_line; continue; }\n      int res = ccw(line.p1,line.p2,vec[j]);\n      assert( res == COUNTER_CLOCKWISE || res == CLOCKWISE );\n      if( res == CLOCKWISE ) vec_CW.push_back(vec[j]);\n      else                   vec_CCW.push_back(vec[j]);\n    }\n    if( vec_CW.size() != vec_CCW.size() ) continue;\n    if( !( on_line <= 2 ) ) continue;\n\n    map<Point,bool> mp;\n    rep(j,vec_CCW.size()) mp[vec_CCW[j]] = true;\n    bool success = true;\n    rep(j,vec_CW.size()){\n      Point rp = reflection(line,vec_CW[j]);\n      if( !mp.count(rp) ) { success = false; break; }\n    }\n    if( success ) { \n      //cout << line << endl;\n      cout << YES << endl; return; }\n  }\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> n;\n  vector<Point> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y;\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-4)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point {\npublic:\n  double x,y;\n\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (const Point& p) { return Point(x+p.x,y+p.y); }\n  Point operator - (const Point& p) { return Point(x-p.x,y-p.y); }\n  Point operator * (const double& p) { return Point(x*p,y*p); }\n  Point operator / (const double& p) { return Point(x/p,y/p); }\n  \n  bool operator < ( const Point & p ) const { return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y);}\n  bool operator == ( const Point & p ) const { return equals(x,p.x) && equals(y,p.y); }\n  \n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\nostream& operator << (ostream& os,const Point&a ) { os << \"(\" << a.x << \",\" << a.y << \")\"; }\nostream& operator << (ostream& os,const Segment& a) { os << \"(\" << a.p1 << \",\" << a.p2 << \")\"; }\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble toRad(double a){ return a * M_PI / 180.0; }\nPoint rotate(Point a,double rad) { return Point(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) <-EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLP(Line l,Point p){\n  return abs(cross(l.p2-p,l.p1-p)) < EPS;\n}\n\nPoint projection(Line l,Point p) {\n  double  t = dot(p-l.p1,l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + ( l.p1 - l.p2 ) * t;\n}\n\nPoint reflection(Line l,Point p){\n  return p + (projection(l,p)-p) * 2;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y-q.y) - (r.y-q.y) * (p.x-q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool onSegment(Point p,Point q,Point r) {\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2))+sqrt(pow(r.x-q.x,2)+pow(r.y-q.y,2)),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)));\n}\n\nconst string YES = \"Yes\";\nconst string NO  = \"No\";\nint n;\n\nPolygon answerScan(Polygon s){\n  Polygon u,l;\n  if( s.size() < 3 ) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  REP(i,2,s.size()){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n\n}\n\n//// --additional\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n//// --additional\n\nbool isValid(vector<Point> &vec) {\n  Line line = Line(vec[0],vec[1]);\n  bool ok = false;\n  rep(i,vec.size()) {\n    if( !intersectLP(line,vec[i]) ) { ok = true; break; }\n  }\n  if( !ok ) return false;\n  return true;\n}\n\nbool isAnswer(Line line,vector<Point> &vec){\n  vector<Point> vec_CW,vec_CCW;\n  int on_line = 0;\n  rep(j,n){\n    if( intersectLP(line,vec[j]) ) { ++on_line; continue; }\n    int res = ccw(line.p1,line.p2,vec[j]);\n    assert( res == COUNTER_CLOCKWISE || res == CLOCKWISE );\n    if( res == CLOCKWISE ) vec_CW.push_back(vec[j]);\n    else                   vec_CCW.push_back(vec[j]);\n  }\n  if( vec_CW.size() != vec_CCW.size() ) return false;\n  if( !( on_line <= 2 ) ) return false;\n\n  map<Point,bool> mp;\n  rep(j,vec_CCW.size()) mp[vec_CCW[j]] = true;\n  bool success = true;\n  rep(j,vec_CW.size()){\n    Point rp = reflection(line,vec_CW[j]);\n    if( !mp.count(rp) ) { success = false; break; }\n  }\n  return success;\n}\n\nvoid compute(vector<Point> &vec){\n  if( !isValid(vec) ) {\n    cout << NO << endl;\n    return;\n  }\n\n  Polygon poly = answerScan(vec);\n  //rep(i,poly.size()) cout << poly[i] << endl;\n  Point centroid = getCentroidOfConvex(poly);\n\n  rep(i,poly.size()){\n    Vector v = poly[(i+1)%poly.size()] - poly[i];\n    v = rotate(v,toRad(90));\n    Vector e = v / abs(v);\n    Point mid_p = (poly[i]+poly[(i+1)%poly.size()])/2;\n    Line line = Line(mid_p,mid_p+e*100);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n\n    // --additional\n    line = Line(centroid,poly[i]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n  /*\n  rep(i,n) REP(j,i+1,n) {\n    Line line = Line(vec[i],vec[j]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n  */\n\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> n;\n  vector<Point> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y;\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\n#define EPS (1e-5)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nPolygon tangent(Circle c1,Circle c2){\n  Polygon p;\n  return p;\n}\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  set<Point> sp;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=andrewScan(p);\n  if(equals(area(q),0)){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  for(int i=0;i<n;i++) sp.insert(p[i]);\n  for(int k=0;k<min(10LL,n);k++){\n    for(int i=0;i<n;i++){\n      if(i==k) continue;\n      {\n\tbool flg=1;\n\tLine l(p[k],p[i]);\n\tfor(int j=0;j<n;j++)\n\t  flg&=equals(getDistanceLP(l,p[j]),0)||sp.count(reflect(l,p[j]));\n\tif(flg){\n\t  int cnt=0;\n\t  for(int j=0;j<n;j++)\n\t    cnt+=equals(getDistanceLP(l,p[j]),0);\n\t  if(cnt<3){\n\t    cout<<\"Yes\"<<endl;\n\t    exit(0);\n\t  }\n\t}\n      }\n      {\n\tbool flg=1;\n\tLine l=bisector(p[k],p[i]);\n\tfor(int j=0;j<n;j++)\n\t  flg&=equals(getDistanceLP(l,p[j]),0)||sp.count(reflect(l,p[j]));\n\tif(flg){\n\t  int cnt=0;\n\t  for(int j=0;j<n;j++)\n\t    cnt+=equals(getDistanceLP(l,p[j]),0);\n\t  if(cnt<3){\n\t    cout<<\"Yes\"<<endl;\n\t    exit(0);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q):a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2):a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b):p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2,0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nbool solve(Polygon g, Line l)\n{\n\tint cnt = 0;\n\tPolygon r;\n\tREP(i, g.size())\n\t{\n\t\tif (isis_lp(l, g[i])) cnt++;\n\t\tr.push_back(mirror(l, g[i]));\n\t}\n\tif (cnt > 2) return false;\n\tsort(ALL(g));\n\tsort(ALL(r));\n\tREP(i, g.size())\n\t{\n\t\tif (abs(g[i] - r[i]) < EPS) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tPolygon p;\n\tREP(i, n)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(Point(x, y));\n\t}\n\tsort(ALL(p));\n\tPolygon g = convex_hull(p);\n\tint v = g.size();\n\tif (v < 3)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tREP(i, v)\n\t{\n\t\tLine l(g[i], g[(i + 1) % v]);\n\t\tPoint vec = l.b - l.a;\n\t\tPoint m = (l.a + l.b) / Point(2,0);\n\t\tLine s(m, m + Point(-vec.imag(), vec.real()));\n\t\tif (solve(p, s)) ans = true;\n\t}\n\tif (v % 2 == 0)\n\t{\n\t\tREP(i, v/2)\n\t\t{\n\t\t\tLine l(g[i], g[i + v / 2]);\n\t\t\tif (solve(p, l)) ans = true;\n\t\t}\n\t}\n\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\nint n;\npt p[1005];\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\npt project(pt po,pair<pt,pt> L){\n\tpt base = L.sc-L.fi;\n\tif(abs(base) <= EPS) return L.fi;\n\tdouble r = dot(po-L.fi,base) / norm(base);\n\treturn L.fi+base*r;\n}\npt reflect(pt po,pair<pt,pt> L){\n    if(abs(L.fi-L.sc) <= EPS) return 2.*L.fi-po;\n\treturn po + (project(po,L)-po)*2.;\n}\nbool eq(double a,double b){\n  return (-EPS < a-b && a-b < EPS);\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nset<P>S;\nint main(){\n\tcin >> n ; if(!n) return 0;\n\trep(i,n){\n\t\tdouble X,Y;\n\t\tscanf(\"%lf%lf\",&X,&Y);\n\t\tp[i] = pt(X,Y);\n\t\tint x2 = floor(X+EPS),y2 = floor(Y+EPS);\n\t\tS.insert(mp(x2,y2));\n\t}\n\tfor(int i=2;i<n;i++) if(ccw(p[0],p[1],p[i])%2 == 1) goto ok;\n\tputs(\"No\"); return 0; ok:;\n\tfor(int i=1;i<n;i++){\n\t\t//0 and i\n\t\tfor(int j=1;j<n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tpt R = reflect(p[j],mp(p[0],p[i]));\n\t\t\tint X = floor(R.x),Y = floor(R.y);\n\t\t\tbool ok = 0;\n\t\t\tfor(int xx=X-1;xx<=X+1;xx++){\n\t\t\t\tfor(int yy=Y-1;yy<=Y+1;yy++){\n\t\t\t\t\tdouble X2 = (double)xx,Y2 = (double)yy;\n\t\t\t\t\tif(abs(R-pt(X2,Y2)) <= EPS){\n\t\t\t\t\t\tif(S.find(mp(xx,yy)) == S.end() || abs(p[j]-pt(X2,Y2))<=EPS) goto bad;\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) goto bad;\n\t\t}\n\t\tputs(\"Yes\"); return 0; bad:;\n\t}\n\tfor(int i=2;i<n;i++){\n\t\t//pass 0 and tangent to 1 and i\n\t\tpt B = p[0]+(p[1]-p[i])*pt(0.0,1.0);\n\t\tfor(int j=1;j<n;j++){\n\t\t\tpt R = reflect(p[j],mp(p[0],B));\n\t\t\tint X = floor(R.x),Y = floor(R.y);\n\t\t\tbool ok = 0;\n\t\t\tfor(int xx=X-1;xx<=X+1;xx++){\n\t\t\t\tfor(int yy=Y-1;yy<=Y+1;yy++){\n\t\t\t\t\tdouble X2 = (double)xx,Y2 = (double)yy;\n\t\t\t\t\tif(abs(R-pt(X2,Y2)) <= EPS){\n\t\t\t\t\t\tif(S.find(mp(xx,yy)) == S.end() || abs(p[j]-pt(X2,Y2))<=EPS) goto bad2;\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) goto bad2;\n\t\t}\n\t\tputs(\"Yes\"); return 0; bad2:;\n\t}\n\tputs(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\nint n;\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\npt project(pt po,pair<pt,pt> L){\n\tpt base = L.sc-L.fi;\n\tif(abs(base) <= EPS) return L.fi;\n\tdouble r = dot(po-L.fi,base) / norm(base);\n\treturn L.fi+base*r;\n}\npt reflect(pt po,pair<pt,pt> L){\n    if(abs(L.fi-L.sc) <= EPS) return 2.0*L.fi-po;\n\treturn po + (project(po,L)-po)*2.0;\n}\nbool eq(double a,double b){\n  return (-EPS < a-b && a-b < EPS);\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nset<P>S;\nvector<pt>p;\nint main(){\n\tcin >> n ; \n\trep(i,n){\n\t\tdouble X,Y;\n\t\tscanf(\"%lf%lf\",&X,&Y);\n\t\tint x2 = floor(X+EPS),y2 = floor(Y+EPS);\n\t\tif(S.find(mp(x2,y2)) != S.end()) continue;\n\t\tS.insert(mp(x2,y2));\n\t\tp.pb(pt(X,Y));\n\t}\n\tn = p.size();\n\tfor(int i=2;i<n;i++) if(ccw(p[0],p[1],p[i])%2 != 0) goto ok;\n\tputs(\"No\"); return 0; ok:;\n\tfor(int i=1;i<n;i++){\n\t\t//0 and i\n\t\tfor(int j=1;j<n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tpt R = reflect(p[j],mp(p[0],p[i]));\n\t\t\tint X = floor(R.x),Y = floor(R.y);\n\t\t\tbool ok = 0;\n\t\t\tfor(int xx=X-1;xx<=X+1;xx++){\n\t\t\t\tfor(int yy=Y-1;yy<=Y+1;yy++){\n\t\t\t\t\tdouble X2 = (double)xx,Y2 = (double)yy;\n\t\t\t\t\tif(abs(R-pt(X2,Y2)) <= EPS){\n\t\t\t\t\t\tif(S.find(mp(xx,yy)) == S.end() || abs(p[j]-pt(X2,Y2))<=EPS) goto bad;\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) goto bad;\n\t\t}\n\t\tputs(\"Yes\"); return 0; bad:;\n\t}\n\tfor(int i=2;i<n;i++){\n\t\t//pass 0 and tangent to 1 and i\n\t\tpt B = p[0]+(p[1]-p[i])*pt(0.0,1.0);\n\t\tint cnt = 0;\n\t\tfor(int j=1;j<n;j++){\n\t\t\tpt R = reflect(p[j],mp(p[0],B));\n\t\t\tint X = floor(R.x),Y = floor(R.y);\n\t\t\tbool ok = 0;\n\t\t\tfor(int xx=X-1;xx<=X+1;xx++){\n\t\t\t\tfor(int yy=Y-1;yy<=Y+1;yy++){\n\t\t\t\t\tdouble X2 = (double)xx,Y2 = (double)yy;\n\t\t\t\t\tif(abs(R-pt(X2,Y2)) <= EPS){\n\t\t\t\t\t\tif(S.find(mp(xx,yy)) == S.end()) goto bad2;\n\t\t\t\t\t\tif(abs(p[j]-pt(X2,Y2))<=EPS) cnt++;\n\t\t\t\t\t\tif(cnt>=2) goto bad2;\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) goto bad2;\n\t\t}\n\t\tputs(\"Yes\"); return 0; bad2:;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\t//0 and i (midpoint)\n\t\tpt RR = (p[0]+p[i])/2.0;\n\t\tpt SS = RR+(p[0]-p[i])*pt(0.0,1.0);\n\t\tint cnt = 0;\n\t\tfor(int j=1;j<n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tpt R = reflect(p[j],mp(RR,SS));\n\t\t\tint X = floor(R.x),Y = floor(R.y);\n\t\t\tbool ok = 0;\n\t\t\tfor(int xx=X-1;xx<=X+1;xx++){\n\t\t\t\tfor(int yy=Y-1;yy<=Y+1;yy++){\n\t\t\t\t\tdouble X2 = (double)xx,Y2 = (double)yy;\n\t\t\t\t\tif(abs(R-pt(X2,Y2)) <= EPS){\n\t\t\t\t\t\tif(S.find(mp(xx,yy)) == S.end()) goto bad3;\n\t\t\t\t\t\tif(abs(p[j]-pt(X2,Y2))<=EPS) cnt++;\n\t\t\t\t\t\tif(cnt>=3) goto bad3;\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) goto bad3;\n\t\t}\n\t\tputs(\"Yes\"); return 0; bad3:;\n\t}\n\tputs(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n/* 基本要素 */\ntypedef complex<double> Point;\ntypedef pair<Point, Point> Line;\ntypedef vector<Point> VP;\nconst double PI = acos(-1);\nconst double EPS = 1e-7; // 許容誤差^2\nconst double INF = 1e9;\n#define X real()\n#define Y imag()\n// #define LE(n,m) ((n) < (m) + EPS)\n#define LE(n,m) ((n) - (m) < EPS)\n// #define GE(n,m) ((n) + EPS > (m))\n#define GE(n,m) (EPS > (m) - (n))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\n// 内積　dot(a,b) = |a||b|cosθ\ndouble dot(Point a, Point b) {\n  return a.X*b.X + a.Y*b.Y;\n}\n\n// 外積　cross(a,b) = |a||b|sinθ\ndouble cross(Point a, Point b) {\n  return a.X*b.Y - a.Y*b.X;\n}\n\n// 点の進行方向\n// !!! 誤差に注意 !!! (掛け算したものとかなり小さいものを比べているので)\nint ccw(Point a, Point b, Point c) {\n  b -= a;  c -= a;\n  if (cross(b,c) >  EPS) return +1;  // counter clockwise\n  if (cross(b,c) < -EPS) return -1;  // clockwise\n  if (dot(b,c)   < -EPS) return +2;  // c--a--b on line\n  if (norm(b) < norm(c)) return -2;  // a--b--c on line or a==b\n  return 0;                          // a--c--b on line or a==c or b==c\n}\n\n// 点pの直線aへの射影点を返す\nPoint proj(Point a1, Point a2, Point p) {\n  return a1 + dot(a2-a1, p-a1)/norm(a2-a1) * (a2-a1);\n}\n\n// 点pの直線aへの反射点を返す\nPoint reflection(Point a1, Point a2, Point p) {\n  return 2.0*proj(a1, a2, p) - p;\n}\n\n// 頂点の順序（sortやmax_elementに必要）\nnamespace std {\n  bool operator<(const Point a, const Point b) {\n    return a.X != b.X ? a.X < b.X : a.Y < b.Y;\n  }\n}\n\n//多角形PSのi番目の辺\n#define ps_edge(PS,i) PS[i],PS[(i+1)%PS.size()]\n\n// 凸包\n// 入力1個 -> 空\n// 2個以上の全て同じ点 -> 同じもの2つ\nVP convexHull(VP ps) {  // 元の点集合がソートされていいならVP&に\n  int n = ps.size(), k = 0;\n  sort(ps.begin(), ps.end());\n  VP ch(2*n);\n  for (int i = 0; i < n; ch[k++] = ps[i++]) // lower-hull\n    while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;  // 余計な点も含むなら == -1 とする\n  for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--]) // upper-hull\n    while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n  ch.resize(k-1);\n  return ch;\n}\n\n\nbool solve(){\n    int n;\n    cin >>n;\n    VP p(n);\n    rep(i,n){\n        int x,y;\n        cin >>x >>y;\n        p[i] = Point(x,y);\n    }\n\n    VP ch = convexHull(p);\n    int C = ch.size();\n\n    vector<Line> cand;\n    if(C%2==1){\n        rep(i,C){\n            Point a = ch[i];\n            Point b = (ch[(i+C/2)%C] + ch[(i+1+C/2)%C])*0.5;\n            cand.pb({a,b});\n        }\n    }\n    else{\n        rep(i,C){\n            Point a = ch[i];\n            Point b = ch[(i+C/2)%C];\n            cand.pb({a,b});\n        }\n        rep(i,C){\n            Point a = (ch[i] + ch[(i+1)%C])*0.5;\n            Point b = (ch[(i+C/2)%C] + ch[(i+1+C/2)%C])*0.5;\n            cand.pb({a,b});\n        }\n    }\n\n    for(const auto &l:cand){\n        Point a = l.fi, b = l.se;\n\n        vector<bool> used(n);\n        int on_line = 0;\n        rep(i,n)if(!used[i]){\n            if(abs(ccw(a,b,p[i])) != 1){\n                used[i] = true;\n                ++on_line;\n                continue;\n            }\n\n            Point pp = reflection(a,b,p[i]);\n            rep(j,n)if(i!=j && !used[j]){\n                double dist = abs(pp-p[j]);\n                if(EQ(dist, 0)){\n                    used[i] = true;\n                    used[j] = true;\n                    break;\n                }\n            }\n        }\n\n        bool valid = true;\n        rep(i,n)if(!used[i]) valid = false;\n\n        if(n%2==1){\n            if(on_line != 1) valid = false;\n        }\n        else{\n            if( !(on_line == 0 || on_line == 2) ) valid = false;\n        }\n\n        if(valid) return true;\n    }\n\n    return false;\n}\n\nint main(){\n    cout << (solve()?\"Yes\":\"No\") << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return x!=p.x?x<p.x:y!=p.y?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nPolygon tangent(Circle c1,Circle c2){\n  Polygon p;\n  return p;\n}\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  set<Point> sp;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=andrewScan(p);\n  if(equals(area(q),0)){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  for(int i=0;i<n;i++) sp.insert(p[i]);\n  for(int k=0;k<min(10LL,n);k++){\n    for(int i=0;i<n;i++){\n      if(i==k) continue;\n      {\n\tbool flg=1;\n\tLine l(p[k],p[i]);\n\tfor(int j=0;j<n;j++)\n\t  flg&=equals(getDistanceLP(l,p[j]),0)||sp.count(reflect(l,p[j]));\n\tif(flg){\n\t  int cnt=0;\n\t  for(int j=0;j<n;j++)\n\t    cnt+=equals(getDistanceLP(l,p[j]),0);\n\t  if(cnt<3){\n\t    cout<<\"Yes\"<<endl;\n\t    exit(0);\n\t  }\n\t}\n      }\n      {\n\tbool flg=1;\n\tLine l=bisector(p[k],p[i]);\n\tfor(int j=0;j<n;j++)\n\t  flg&=equals(getDistanceLP(l,p[j]),0)||sp.count(reflect(l,p[j]));\n\tif(flg){\n\t  int cnt=0;\n\t  for(int j=0;j<n;j++)\n\t    cnt+=equals(getDistanceLP(l,p[j]),0);\n\t  if(cnt<3){\n\t    cout<<\"Yes\"<<endl;\n\t    exit(0);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\ntemplate<class T = int>\nstruct rational{\n\tT gcd(T a,T b){ return b ? gcd(b,a % b) : a; }\n\tT numer,denom;\n\n\trational() : numer(0),denom(1){}\n\trational(T n,T d = 1) : numer(n),denom(d){\n\t\tnormalize();\n\t}\n\n\tvoid normalize(){\n\t\tif(denom == 0){\n\t\t\tnumer = 1;\n\t\t\treturn;\n\t\t}\n\t\tif(denom < 0) numer *= -1,denom *= -1;\n\t\tT g = gcd(numer < 0 ? -numer : numer,denom);\n\t\tif(g == 0) numer = 0,denom = 1;\n\t\telse numer /= g,denom /= g;\n\t}\n\n\toperator long long() const{ return (long long)(numer / denom); }\n\n\trational operator-() const{ return rational(*this) *= -1; }\n\n\trational operator+(const rational &x) const{ return rational(*this) += x; }\n\trational operator-(const rational &x) const{ return rational(*this) -= x; }\n\trational operator*(const rational &x) const{ return rational(*this) *= x; }\n\trational operator/(const rational &x) const{ return rational(*this) /= x; }\n\n\trational &operator+=(const rational &x){\n\t\tnumer = numer * x.denom + x.numer * denom;\n\t\tdenom *= x.denom;\n\t\tnormalize();\n\t\treturn *this;\n\t}\n\trational &operator-=(const rational &x){\n\t\tnumer = numer * x.denom - x.numer * denom;\n\t\tdenom *= x.denom;\n\t\tnormalize();\n\t\treturn *this;\n\t}\n\trational &operator*=(const rational &x){\n\t\tnumer *= x.numer;\n\t\tdenom *= x.denom;\n\t\tnormalize();\n\t\treturn *this;\n\t}\n\trational &operator/=(const rational &x){\n\t\tnumer *= x.denom;\n\t\tdenom *= x.numer;\n\t\tnormalize();\n\t\treturn *this;\n\t}\n\n\tfriend ostream &operator<<(ostream &os,const rational &x){\n\t\treturn os << x.numer << '/' << x.denom;\n\t}\n\n\tbool operator<(const rational &x) const{ return numer * x.denom < x.numer * denom; };\n\tbool operator>(const rational &x) const{ return numer * x.denom > x.numer * denom; };\n\tbool operator<=(const rational &x) const{ return numer * x.denom <= x.numer * denom; };\n\tbool operator>=(const rational &x) const{ return numer * x.denom >= x.numer * denom; };\n\tbool operator==(const rational &x) const{ return numer * x.denom == x.numer * denom; };\n\tbool operator!=(const rational &x) const{ return numer * x.denom != x.numer * denom; };\n};\n\ntemplate<class T>\nstruct Complex{\n\tT x,y;\n\n\tComplex() : x(T(0)),y(T(0)){}\n\tComplex(T x,T y) : x(x),y(y){}\n\n\tT real() const{ return x; }\n\tT imag() const{ return y; }\n\n\tComplex operator-() const{ return Complex(*this) *= -1; }\n\n\tComplex operator+(const Complex &x) const{ return Complex(*this) += x; }\n\tComplex operator-(const Complex &x) const{ return Complex(*this) -= x; }\n\tComplex operator*(const T &x) const{ return Complex(*this) *= x; }\n\tComplex operator/(const T &x) const{ return Complex(*this) /= x; }\n\n\tComplex &operator+=(const Complex &p){\n\t\tx += p.x; y += p.y;\n\t\treturn *this;\n\t}\n\tComplex &operator-=(const Complex &p){\n\t\tx -= p.x; y -= p.y;\n\t\treturn *this;\n\t}\n\tComplex &operator*=(const T &a){\n\t\tx *= a; y *= a;\n\t\treturn *this;\n\t}\n\tComplex &operator/=(const T &a){\n\t\tx /= a; y /= a;\n\t\treturn *this;\n\t}\n\n\tfriend ostream &operator<<(ostream &os,const Complex &p){\n\t\treturn os << '(' << p.x << ',' << p.y << ')';\n\t}\n\n\tbool operator<(const Complex &p) const{ return x == p.x ? y < p.y : x < p.x; };\n\tbool operator==(const Complex &p) const{ return x == p.x && y == p.y; };\n};\n\nusing Float = rational<int>;\nusing Point = Complex<Float>;\nstruct Line{\n\tPoint a,b;\n\tLine(Point a,Point b) : a(a),b(b){}\n};\n\nLine bisector(Point p1,Point p2){\n\tPoint mid = (p1 + p2) / Float(2),d = p2 - p1;\n\treturn Line(mid,mid + Point(d.imag(),-d.real()));\n}\n\ntuple<Float,Float,Float> linear_form(const Line &l){\n\tif(l.a.real() == l.b.real()) return make_tuple(1,0,-l.a.real());\n\tFloat a = (l.b.imag() - l.a.imag()) / (l.b.real() - l.a.real());\n\tFloat b = l.a.imag() - a * l.a.real();\n\treturn make_tuple(a,-1,b);\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os,const vector<T> &v){\n\tfor(int i = 0;i < v.size();i++) os << (i ? \",\" : \"[\") << v[i];\n\tos << \"]\";\n\treturn os;\n}\n\ntemplate<class T>\nostream &operator<<(ostream &os,const tuple<T,T,T> &v){\n\tos << '(' << get<0>(v) << ',' << get<1>(v) << ',' << get<2>(v) << ')';\n\treturn os;\n}\n\nsigned main(){\n\tint n;\n\tPoint ps[1010];\n\tcin >> n;\n\tfor(int i = 0;i < n;i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tps[i] = Point(Float(a),Float(b));\n\t}\n\tbool oneline = true;\n\tauto l = linear_form(Line(ps[0],ps[1]));\n\tfor(int i = 0;i < n;i++){\n\t\tFloat a,b,c;\n\t\ttie(a,b,c) = l;\n\t\tif(a * ps[i].real() + b * ps[i].imag() != -c) oneline = false;\n\t}\n\tif(oneline){\n\t\tcout << \"No\" << endl;\n\t\treturn 0;\n\t}\n\tmap<tuple<Float,Float,Float>,vector<int>> cnt;\n\tfor(int i = 0;i < n;i++){\n\t\tfor(int j = i + 1;j < n;j++){\n\t\t\tauto t = linear_form(bisector(ps[i],ps[j]));\n\t\t\tcnt[t].push_back(i);\n\t\t\tcnt[t].push_back(j);\n\t\t}\n\t}\n\tfor(auto p : cnt){\n\t\t//cout << p.first << \" \" << p.second << endl;\n\t\tif(n - p.second.size() <= 2){\n\t\t\tFloat a,b,c;\n\t\t\ttie(a,b,c) = p.first;\n\t\t\tbool flag = true;\n\t\t\tset<int> st;\n\t\t\tfor(int i = 0;i < n;i++) st.insert(i);\n\t\t\tfor(int v : p.second) st.erase(v);\n\t\t\tfor(int v : st){\n\t\t\t\tif(a * ps[v].real() + b * ps[v].imag() != -c) flag = false; \n\t\t\t}\n\t\t\tif(flag){\n\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\n\ntypedef vector<edge> Edges;\ntypedef vector<Edges> Graph;\n//int dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\ntypedef long double ld;\nconst double PI = acos(-1.0);\nbool eq(double a, double b) { return fabs(a - b) < EPS; }\ntypedef complex<double> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q) :a(p), b(q) {};\n\tLine(double x1, double y1, double x2, double y2) :a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; double r;\n\tCircle(Point a, double b) :p(a), r(b) {};\n};\n\ndouble dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\ndouble cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tdouble r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn 2.0*projection(l, p) - p;\n}\n\ndouble dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\ndouble dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\ndouble dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\ndouble dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\ndouble dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tdouble a = cross(s.b - s.a, t.b - t.a);\n\tdouble b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tdouble d = abs(c1.p - c2.p);\n\tdouble rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tdouble dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tdouble rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tdouble d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r>EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tdouble d = abs(v);\n\tdouble l = sqrt(norm(v) - c.r * c.r);\n\tif (l<EPS) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) == 1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) == 1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nint main()\n{\n\tint n;\n\tcin >> n;\n\tPolygon ps(n);\n\tset<pii> st;\n\tREP(i, n)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tps[i] = Point(x, y);\n\t\tst.insert(pii(x, y));\n\t}\n\tsort(ALL(ps));\n\tPolygon g = convex_hull(ps);\n\tif (ps.size() < 3 || (n - g.size()) % 2)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tREP(i, g.size())REP(j, i)\n\t{\n\t\tPoint p = (g[i] + g[j]) / 2.0;\n\t\tPoint p2(g[i] - g[j]);\n\t\tPoint q(-p2.imag(), p2.real());\n\t\tLine l(p, p + q);\n\t\tbool f = true;\n\t\tREP(k, n)\n\t\t{\n\t\t\tPoint mir = mirror(l, ps[k]);\n\t\t\tdouble x = mir.real() + EPS, y = mir.imag() + EPS;\n\t\t\tif (st.find(pii(x, y)) == st.end())\n\t\t\t{\n\t\t\t\tf = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (f)\n\t\t{\n\t\t\tputs(\"Yes\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\tputs(\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n  テ」ツ?ャテ」ツ?」テ」ツ?ステ」ツ??\n */\n#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-4)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point {\npublic:\n  double x,y;\n\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (const Point& p) { return Point(x+p.x,y+p.y); }\n  Point operator - (const Point& p) { return Point(x-p.x,y-p.y); }\n  Point operator * (const double& p) { return Point(x*p,y*p); }\n  Point operator / (const double& p) { return Point(x/p,y/p); }\n  \n  bool operator < ( const Point & p ) const { return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y);}\n  bool operator == ( const Point & p ) const { return equals(x,p.x) && equals(y,p.y); }\n  \n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\nostream& operator << (ostream& os,const Point&a ) { os << \"(\" << a.x << \",\" << a.y << \")\"; }\nostream& operator << (ostream& os,const Segment& a) { os << \"(\" << a.p1 << \",\" << a.p2 << \")\"; }\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble toRad(double a){ return a * M_PI / 180.0; }\nPoint rotate(Point a,double rad) { return Point(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) <-EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLP(Line l,Point p){\n  return abs(cross(l.p2-p,l.p1-p)) < EPS;\n}\n\nPoint projection(Line l,Point p) {\n  double  t = dot(p-l.p1,l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + ( l.p1 - l.p2 ) * t;\n}\n\nPoint reflection(Line l,Point p){\n  return p + (projection(l,p)-p) * 2;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y-q.y) - (r.y-q.y) * (p.x-q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool onSegment(Point p,Point q,Point r) {\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2))+sqrt(pow(r.x-q.x,2)+pow(r.y-q.y,2)),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)));\n}\n\nconst string YES = \"Yes\";\nconst string NO  = \"No\";\nint n;\n\nPolygon answerScan(Polygon s){\n  Polygon u,l;\n  if( s.size() < 3 ) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  REP(i,2,s.size()){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n\n}\n\n//// --additional\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n//// --additional\n\nbool isValid(vector<Point> &vec) {\n  Line line = Line(vec[0],vec[1]);\n  bool ok = false;\n  rep(i,vec.size()) {\n    if( !intersectLP(line,vec[i]) ) { ok = true; break; }\n  }\n  if( !ok ) return false;\n  return true;\n}\n\nbool isAnswer(Line line,vector<Point> &vec){\n  vector<Point> vec_CW,vec_CCW;\n  int on_line = 0;\n  rep(j,n){\n    if( intersectLP(line,vec[j]) ) { ++on_line; continue; }\n    int res = ccw(line.p1,line.p2,vec[j]);\n    assert( res == COUNTER_CLOCKWISE || res == CLOCKWISE );\n    if( res == CLOCKWISE ) vec_CW.push_back(vec[j]);\n    else                   vec_CCW.push_back(vec[j]);\n  }\n  if( vec_CW.size() != vec_CCW.size() ) return false;\n  if( !( on_line <= 2 ) ) return false;\n\n  map<Point,bool> mp;\n  rep(j,vec_CCW.size()) mp[vec_CCW[j]] = true;\n  bool success = true;\n  rep(j,vec_CW.size()){\n    Point rp = reflection(line,vec_CW[j]);\n    if( !mp.count(rp) ) { success = false; break; }\n  }\n  return success;\n}\n\nvoid compute(vector<Point> &vec){\n  if( !isValid(vec) ) {\n    cout << NO << endl;\n    return;\n  }\n\n  Polygon poly = answerScan(vec);\n  //rep(i,poly.size()) cout << poly[i] << endl;\n  Point centroid = getCentroidOfConvex(poly);\n\n  rep(i,poly.size()){\n    Vector v = poly[(i+1)%poly.size()] - poly[i];\n    v = rotate(v,toRad(90));\n    Vector e = v / abs(v);\n    Point mid_p = (poly[i]+poly[(i+1)%poly.size()])/2;\n    Line line = Line(mid_p,mid_p+e*100);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n\n    // --additional\n    line = Line(centroid,poly[i]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n  /*\n  rep(i,n) REP(j,i+1,n) {\n    Line line = Line(vec[i],vec[j]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n  */\n\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> n;\n  vector<Point> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y;\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<map>\n#include<set>\n#include<string>\n#include<stack>\n#include<cstdio>\n#include<cmath>\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\n\n#define fr first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define rep(i,x) for(int i=0;i<x;i++)\n#define rep1(i,x) for(int i=1;i<=x;i++)\n#define rrep(i,x) for(int i=x-1;i>=0;i--)\n#define rrep1(i,x) for(int i=x;i>0;i--)\n#define sor(v) sort(v.begin(),v.end())\n#define rev(s) reverse(s.begin(),s.end())\n#define lb(vec,a) lower_bound(vec.begin(),vec.end(),a)\n#define ub(vec,a) upper_bound(vec.begin(),vec.end(),a)\n#define uniq(vec) vec.erase(unique(vec.begin(),vec.end()),vec.end())\n#define mp1(a,b,c) P1(a,P(b,c))\n\nconst int INF=1000000000;\nconst int dir_4[4][2]={{1,0},{0,1},{-1,0},{0,-1}};\nconst int dir_8[8][2]={{1,0},{1,1},{0,1},{-1,1},{-1,0},{-1,-1},{0,-1},{1,-1}};\n\nstruct Point{\n\tint x;\n\tint y;\n};\nstruct Line{\n\tint a;\n\tint b;\n\tint c;\n\tbool operator <(Line y) const {\n\t\treturn mp1(this->a,this->b,this->c) < mp1(y.a,y.b,y.c);\n\t}\n};\n\nint gcd(int x,int y){\n\tif(y == 0)return x;\n\treturn gcd(y,x%y);\n}\n\nLine f(Point A,Point B){\n\tLine ret;\n\tret.a = A.x-B.x;\n\tret.b = A.y-B.y;\n\tint g = gcd(abs(ret.a),abs(ret.b));\n\tif(ret.a < 0)g *= -1;\n\tif(ret.a == 0 && ret.b < 0)g *= -1;\n\tret.a /= g;\n\tret.b /= g;\n\tret.c = -(ret.a*(A.x+B.x)+ret.b*(A.y+B.y));\n\treturn ret;\n}\nbool g(Line l,Point A){\n\treturn l.a*A.x+l.b*A.y+l.c == 0;\n}\n\nint main(){\n\tint n;\n\tint x[1002],y[1002];\n\tscanf(\"%d\",&n);\n\trep(i,n){\n\t\tscanf(\"%d%d\",&x[i],&y[i]);\n\t}\n\t\n\tint a = y[0]-y[1];\n\tint b = x[1]-x[0];\n\tint c = -(a*x[0]+b*y[0]);\n\tbool t = true;\n\trep(i,n){\n\t\tif(a*x[i]+b*y[i]+c != 0){\n\t\t\tt = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif(t){\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\t\n\tPoint p[1002];\n\trep(i,n){\n\t\tp[i].x = x[i];\n\t\tp[i].y = y[i];\n\t}\n\t\n\tmap<Line,int> cnt;\n\trep(i,n)rep(j,n){\n\t\tif(i == j)continue;\n\t\tcnt[f(p[i],p[j])] ++;\n\t}\n\tfor(map<Line,int>::iterator itr = cnt.begin() ; itr != cnt.end() ; ++itr){\n\t\t//printf(\"%d %d %d %d\\n\",itr->fr.a,itr->fr.b,itr->fr.c,itr->sc);\n\t\tif(itr->sc == n){\n\t\t\tputs(\"Yes\");\n\t\t\treturn 0;\n\t\t}\n\t\tif(itr->sc == n-1){\n\t\t\tint CNT = 0;\n\t\t\trep(i,n){\n\t\t\t\tp[i].x *= 2; p[i].y *= 2;\n\t\t\t\tif(g(itr->fr,p[i]))CNT ++;\n\t\t\t\tp[i].x /= 2; p[i].y /= 2;\n\t\t\t}\n\t\t\tif(CNT == 1){\n\t\t\t\tputs(\"Yes\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\tif(itr->sc == n-2){\n\t\t\tint CNT = 0;\n\t\t\trep(i,n){\n\t\t\t\tp[i].x *= 2; p[i].y *= 2;\n\t\t\t\tif(g(itr->fr,p[i]))CNT ++;\n\t\t\t\tp[i].x /= 2; p[i].y /= 2;\n\t\t\t}\n\t\t\tif(CNT == 2){\n\t\t\t\tputs(\"Yes\");\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tputs(\"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ld = long double;\n\nconstexpr ld eps = 1e-8;\nconstexpr ld pi = std::acos(-1.0);\n\nusing pii = pair<int, int>;\n\nnamespace geometry2d {\n\n\nusing point = std::complex<long double>;\nusing polygon = std::vector<point>;\n\n\nbool eq(long double a, long double b) {\n    return (std::abs(a-b) < eps);\n}\n\nlong double dot(point a, point b) {\n    return std::real(std::conj(a) * b);\n}\n\nlong double cross(point a, point b) {\n    return std::imag(std::conj(a) * b);\n}\n\n\nclass segment {\npublic:\n    segment()\n        : a(point(0, 0)),\n          b(point(0, 0))\n    {}\n    segment(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n\n    point a, b;\n};\n\nclass line {\npublic:\n    line()\n        : a(point(0, 0)), b(point(0, 0))\n    {}\n    line(point a_, point b_)\n        : a(a_), b(b_)\n    {}\n    line(segment s)\n        : a(s.a), b(s.b)\n    {}\n\n    point a, b;\n};\n\nint ccw(point a, point b, point c) {\n    b -= a; c -= a;\n    if(cross(b, c) > eps)           return 1;  // a -> b -> c : counterclockwise\n    if(cross(b, c) < -eps)          return -1; // a -> b -> c : clockwise\n    if(dot(b, c) < 0)               return 2;  // c -> a -> b : line\n    if(std::norm(b) < std::norm(c)) return -2; // a -> b -> c : line\n    return 0;                                  // a -> c -> b : line\n}\n\n\nbool isis_ll(line l, line m) {\n    return !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\nbool isis_ls(line l, segment s) {\n    return (cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\nbool isis_lp(line l, point p) {\n    return (std::abs(cross(l.b - p, l.a - p)) < eps);\n}\n\nbool isis_sp(segment s, point p) {\n    return (std::abs(s.a - p) + std::abs(s.b - p) - std::abs(s.b - s.a) < eps);\n}\n\nbool isis_ss(segment s, segment t) {\n    return ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0\n        && ccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n\npoint proj(line l, point p) {\n    long double t = dot(p - l.a, l.a - l.b) / std::norm(l.a - l.b);\n    return l.a + t * (l.a - l.b);\n}\n\npoint is_ll(line s, line t) {\n    point sv = s.b - s.a, tv = t.b - t.a;\n    assert(cross(sv, tv) != 0);\n    return s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n\nlong double dist_lp(line l, point p) {\n    return std::abs(p - proj(l, p));\n}\n\nlong double dist_ll(line l, line m) {\n    return isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nlong double dist_ls(line l, segment s) {\n    return isis_ls(l, s) ? 0 : std::min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nlong double dist_sp(segment s, point p) {\n    point r = proj(line(s), p);\n    return isis_sp(s, r) ? std::abs(r - p) : std::min(std::abs(s.a - p), std::abs(s.b - p));\n}\n\nlong double dist_ss(segment s, segment t) {\n    if(isis_ss(s, t)) return 0;\n    long double d1 = std::min(dist_sp(s, t.a), dist_sp(s, t.b));\n    long double d2 = std::min(dist_sp(t, s.a), dist_sp(t, s.b));\n    return std::min(d1, d2);\n}\n\n// 0 -> on, 1 -> in, 2 -> out\nint is_in_polygon(polygon const& poly, point p) {\n    int N = poly.size();\n    ld sum = 0;\n    for(int i=0; i<N; ++i) {\n        point p1 = poly[i], p2 = poly[(i+1)%N];\n        if(isis_sp(segment(p1, p2), p)) {\n            return 0;\n        }\n        sum += arg((p2 - p) / (p1 - p));\n    }\n    return std::abs(sum) < pi / 2 ? 2 : 1;\n}\n\npoint reflection(line const& l, point p) {\n    auto pro = proj(l, p);\n    return p + (pro - p) + (pro - p);\n}\n\npolygon convex_hull(vector<point> ps) {\n    sort(ps.begin(), ps.end(), [&](point const& p1, point const& p2) {\n        if(real(p1) == real(p2)) {\n            return imag(p1) < imag(p2);\n        }\n        return real(p1) < real(p2);\n    });\n    const int n = ps.size();\n    int k = 0;\n    polygon qs(2*n);\n    for(int i=0; i<n; ++i) {\n        while(k > 1 && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    for(int i=n-2, t = k; i>=0; --i) {\n        while(k > t && ccw(qs[k-2], qs[k-1], ps[i]) <= 0) {\n            k--;\n        }\n        qs[k++] = ps[i];\n    }\n    qs.resize(k-1);\n    return qs;\n}\n\n\nline separate(point const& p1, point const& p2) {\n    assert(p1 != p2);\n    auto m = (p1 + p2) * point(0.5, 0);\n    line res;\n    res.a = m + (m - p1) * point(0, 1);\n    res.b = m + (m - p1) * point(0, -1);\n    return res;\n}\n\n\n} // namespace geometry2d\n\nusing namespace geometry2d;\n\n\nint main() {\n    int N;\n    cin >> N;\n    set<pii> ps;\n    polygon poly;\n    double gx = 0, gy = 0;\n    for(int i = 0; i < N; ++i) {\n        int x, y;\n        cin >> x >> y;\n        gx += x;\n        gy += y;\n        ps.insert(make_pair(x, y));\n        poly.emplace_back(x, y);\n    }\n\n    bool ok = false;\n    for(int i = 2; i < N; ++i) {\n        if(abs(cross(poly[1] - poly[i], poly[0] - poly[i])) > eps) {\n            ok = true;\n        }\n    }\n    if(!ok) {\n        cout << \"No\" << endl;\n        return 0;\n    }\n\n    sort(poly.begin(), poly.end(), [gx, gy](auto const& p1, auto const& p2) {\n        return arg(p1 - point(gx, gy)) < arg(p2 - point(gx, gy));\n    });\n    poly = convex_hull(poly);\n    vector<line> ls;\n    int const m = poly.size();\n    for(int i = 0; i < (int)poly.size(); ++i) {\n        ls.emplace_back(poly[i], poly[i + m / 2]);\n        ls.emplace_back(separate(poly[i], poly[(i + 1) % m]));\n    }\n\n\n    for(auto& l : ls) {\n        ok = true;\n        int on_line = 0;\n        for(auto& p : ps) {\n            auto ref = reflection(l, point(p.first, p.second));\n            auto x = real(ref), y = imag(ref);\n            if(abs(x - round(x)) > eps || abs(y - round(y)) > eps) {\n                ok = false;\n                break;\n            }\n            int ix = round(x), iy = round(y);\n            if(ps.count(make_pair(ix, iy)) == 0) {\n                ok = false;\n                break;\n            }\n            on_line += make_pair(ix, iy) == p;\n        }\n        if(ok && on_line <= 2) {\n            cout << \"Yes\" << endl;\n            return 0;\n        }\n    }\n\n    cout << \"No\" << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-5;\nbool eq(double a,double b){\n  double EPS = max( abs(a) , abs(b) ) * eps;\n  EPS=max(EPS,eps);\n  return (-EPS<a-b&&a-b<EPS);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){cnt++;continue;}\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt>1 && cnt%2==1 )res=false;\n  return res;\n}\n\nbool solve(){\n  P b=t[0];\n  int cnt=0;\n  for(int i=1;i<N;i++){\n    b+=t[i];\n    double v=cross(t[1]-t[0],t[i]-t[0]);\n    if(eq(v,0))cnt++;\n  }\n  if(cnt==N-1)return false;\n\n  b/=(double)N;\n  \n  bool flag=false;\n  for(int i=0;i<N;i++){\n    P a=t[i];\n    if(check(a,b))flag=true;\n  }\n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n    for(int j=0;j<i;j++)assert(t[i]!=t[j]);\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <cmath>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nnamespace libcomp {\nnamespace geometry {\n\nconst double EPS = 1e-9;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\n\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\ndouble norm(const Point &p){ return p.x * p.x + p.y * p.y; }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Line {\n\tPoint a;\n\tPoint b;\n\n\texplicit Line(const Point &a = Point(), const Point &b = Point()) :\n\t\ta(a), b(b)\n\t{ }\n\n\tstatic Line invalid(){\n\t\tPoint inv = Point::invalid();\n\t\treturn Line(inv, inv);\n\t}\n\tbool is_valid() const { return a.is_valid() && b.is_valid(); }\n\n\tbool operator<(const Line &l) const {\n\t\treturn (a == l.a) ? (b < l.b) : (a < l.a);\n\t}\n};\n\nbool tolerant_eq(const Line &a, const Line &b){\n\treturn ::std::abs(cross(a.b - a.a, b.a - a.a)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p - l.a, l.b - l.a) / norm(l.b - l.a);\n\treturn l.a + t * (l.b - l.a);\n}\n\nPoint reflection(const Line &l, const Point &p){\n\treturn p + 2.0 * (projection(l, p) - p);\n}\n\n}\n}\n\nusing namespace libcomp::geometry;\ntypedef pair<int, int> pii;\n\ninline ll pow2(ll x){ return x * x; }\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<Point> p(n);\n\tset<pii> ps;\n\tint xsum = 0, ysum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t\tps.insert(pii(x, y));\n\t\txsum += x;\n\t\tysum += y;\n\t}\n\tconst Point c(\n\t\tstatic_cast<double>(xsum) / n, static_cast<double>(ysum) / n);\n\tbool answer = false;\n\tif(n % 2 == 0){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(tolerant_eq(p[i], c)){ continue; }\n\t\t\tconst Line l(p[i], c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; accept && j < n; ++j){\n\t\t\t\tconst Point a = p[j];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; !answer && i < 3; ++i){\n\t\tfor(int j = i + 1; !answer && j < n; ++j){\n\t\t\tconst Point q = projection(Line(p[i], p[j]), c);\n\t\t\tif(tolerant_eq(q, c)){ continue; }\n\t\t\tconst Line l((p[i] + p[j]) / 2, c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int k = 0; accept && k < n; ++k){\n\t\t\t\tconst Point a = p[k];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > n % 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (answer ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef array<P, 2> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\nbool check(L l, const vector<P>& ps) {\n    int N = ps.size();\n    bool ok = true;\n    int online = 0;\n    for(int i = 0; i < N; i++) {\n        P rp = refl(l, ps[i]);\n        if(ps[i] == rp) online ++;\n        if(!binary_search(ps.begin(), ps.end(), rp)) {\n            ok = false;\n            break;\n        }\n        if(online > 2) {\n            ok = false;\n            break;\n        }\n    }\n    return ok;\n}\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        sort(ps.begin(), ps.end());\n\n        set<L> ls;\n        for(int i = 0; i + 1 < N; i++) {\n            L l = {ps[i], ps[i+1]};\n            ls.insert(l);\n        }\n\n        if(ls.size() == 1) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        bool ans = false;\n        for(int i = 0; i < 3; i++) {\n            for(int j = 0; j < N; j++) if(i != j) {\n                P mp = (ps[j] + ps[i]) / 2.0;\n                P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n                L l = {mp, mp + vp};\n                if(check(l, ps)) ans = true;\n            }\n        }\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-5;\nbool eq(double a,double b){\n  double EPS = max( abs(a) , abs(b) ) * eps;\n  EPS=max(EPS,eps);\n  return (-EPS<a-b&&a-b<EPS);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){cnt++;continue;}\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n\n  return res;\n}\n\nbool solve(){\n  int cnt=0;\n  for(int i=1;i<N;i++){\n    double v=cross(t[1]-t[0],t[i]-t[0]);\n    if(eq(v,0))cnt++;\n  }\n  if(cnt==N-1)return false;\n  \n  bool flag=false;\n  for(int i=1;i<N;i++){\n    P a=t[0], b=t[i];\n    if(check(a,b))flag=true;\n    P c=(a+b)*0.5;\n    P d=c+(b-a)*P(0,1);\n    if(check(c,d))flag=true;\n  }\n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n    \n    for(int j=0;j<i;j++)assert(t[i]!=t[j]);\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 1000000000\n#define fi first\n#define sc second\n#define rep(i,x) for(int i=0;i<x;i++)\n#define SORT(x) sort(x.begin(),x.end())\n#define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end())\n#define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin())\n#define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin())\ntypedef complex<double> pt;\ntypedef pair<pt,pt> L;\ntypedef vector<P> poly;\nconst double EPS = 1e-9;\n#define x real()\n#define y imag()\nint n;\npt p[1005];\ndouble dot(pt a,pt b){\n\treturn (conj(a)*b).x;\n}\ndouble cross(pt a,pt b){\n\treturn (conj(a)*b).y;\n}\npt project(pt po,pair<pt,pt> L){\n\tpt base = L.sc-L.fi;\n\tif(abs(base) <= EPS) return L.fi;\n\tdouble r = dot(po-L.fi,base) / norm(base);\n\treturn L.fi+base*r;\n}\npt reflect(pt po,pair<pt,pt> L){\n    if(abs(L.fi-L.sc) <= EPS) return 2.*L.fi-po;\n\treturn po + (project(po,L)-po)*2.;\n}\nbool eq(double a,double b){\n  return (-EPS < a-b && a-b < EPS);\n}\nint ccw(pt a,pt b,pt c){\n\tb -= a; c -= a;\n\tif(cross(b,c) > EPS) return 1; // counter clockwise\n\tif(cross(b,c) < -EPS) return -1; // clockwise\n\tif(dot(b,c) < -EPS) return 2; //c-a-b\n\tif(norm(b) < norm(c)) return -2; //a-b-c\n\treturn 0; //a-c-b\n}\nset<P>S;\nint main(){\n\tcin >> n ; if(!n) return 0;\n\trep(i,n){\n\t\tdouble X,Y;\n\t\tscanf(\"%lf%lf\",&X,&Y);\n\t\tp[i] = pt(X,Y);\n\t\tint x2 = floor(X+EPS),y2 = floor(Y+EPS);\n\t\tS.insert(mp(x2,y2));\n\t}\n\tfor(int i=2;i<n;i++) if(ccw(p[0],p[1],p[i])%2 == 1) goto ok;\n\tputs(\"No\"); return 0; ok:;\n\tfor(int i=1;i<n;i++){\n\t\t//0 and i\n\t\tfor(int j=1;j<n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tpt R = reflect(p[j],mp(p[0],p[i]));\n\t\t\tint X = floor(R.x),Y = floor(R.y);\n\t\t\tbool ok = 0;\n\t\t\tfor(int xx=X-1;xx<=X+1;xx++){\n\t\t\t\tfor(int yy=Y-1;yy<=Y+1;yy++){\n\t\t\t\t\tdouble X2 = (double)xx,Y2 = (double)yy;\n\t\t\t\t\tif(abs(R-pt(X2,Y2)) <= EPS){\n\t\t\t\t\t\tif(S.find(mp(xx,yy)) == S.end() || abs(p[j]-pt(X2,Y2))<=EPS) goto bad;\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) goto bad;\n\t\t}\n\t\tputs(\"Yes\"); return 0; bad:;\n\t}\n\tfor(int i=2;i<n;i++){\n\t\t//pass 0 and tangent to 1 and i\n\t\tpt B = p[0]+(p[1]-p[i])*pt(0.0,1.0);\n\t\tfor(int j=1;j<n;j++){\n\t\t\tpt R = reflect(p[j],mp(p[0],B));\n\t\t\tint X = floor(R.x),Y = floor(R.y);\n\t\t\tbool ok = 0;\n\t\t\tfor(int xx=X-1;xx<=X+1;xx++){\n\t\t\t\tfor(int yy=Y-1;yy<=Y+1;yy++){\n\t\t\t\t\tdouble X2 = (double)xx,Y2 = (double)yy;\n\t\t\t\t\tif(abs(R-pt(X2,Y2)) <= EPS){\n\t\t\t\t\t\tif(S.find(mp(xx,yy)) == S.end() || abs(p[j]-pt(X2,Y2))<=EPS) goto bad2;\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) goto bad2;\n\t\t}\n\t\tputs(\"Yes\"); return 0; bad2:;\n\t}\n\tfor(int i=1;i<n;i++){\n\t\t//0 and i (midpoint)\n\t\tpt RR = (p[0]+p[i])/2.0;\n\t\tpt SS = RR+(p[0]-p[i])*pt(0.0,1.0);\n\t\tint cnt = 0;\n\t\tfor(int j=1;j<n;j++){\n\t\t\tif(i==j) continue;\n\t\t\tpt R = reflect(p[j],mp(RR,SS));\n\t\t\tint X = floor(R.x),Y = floor(R.y);\n\t\t\tbool ok = 0;\n\t\t\tfor(int xx=X-1;xx<=X+1;xx++){\n\t\t\t\tfor(int yy=Y-1;yy<=Y+1;yy++){\n\t\t\t\t\tdouble X2 = (double)xx,Y2 = (double)yy;\n\t\t\t\t\tif(abs(R-pt(X2,Y2)) <= EPS){\n\t\t\t\t\t\tif(S.find(mp(xx,yy)) == S.end()) goto bad3;\n\t\t\t\t\t\tif(abs(p[j]-pt(X2,Y2))<=EPS){\n\t\t\t\t\t\t    cnt++; if(cnt>=3) goto bad3;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tok = 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!ok) goto bad3;\n\t\t}\n\t\tputs(\"Yes\"); return 0; bad3:;\n\t}\n\tputs(\"No\");\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <random>\nusing namespace std;\nusing ll = long long;\nstruct P {\n    ll x;\n    ll y;\n    bool operator<(const P& p) const\n    {\n        return (x != p.x) ? x < p.x : y < p.y;\n    }\n};\nvector<P> pos;\nint N;\n\nbool ok(const int i, const int j)\n{\n    const ll x = (pos[i].x + pos[j].x) / 2;\n    const ll y = (pos[i].y + pos[j].y) / 2;\n    const ll dx = pos[j].x - x;\n    const ll dy = pos[j].y - y;\n    set<P> p;\n    int cnt = 0;\n    ll h = 0;\n    for (int k = 0; k < N; k++) {\n        if (k == i or k == j) {\n            continue;\n        }\n        const ll X = pos[k].x - x;\n        const ll Y = pos[k].y - y;\n        const ll S = X * dx + Y * dy;\n        const ll T = -X * dy + Y * dx;\n        h = max(h, abs(T));\n        if (S == 0) {\n            cnt++;\n        }\n        p.insert(P{S, T});\n    }\n    if (cnt >= 3 or h == 0) {\n        return false;\n    }\n    for (const auto& pp : p) {\n        if (p.find(P{-pp.x, pp.y}) == p.end()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        ll x, y;\n        cin >> x >> y;\n        pos.push_back(P{2 * x, 2 * y});\n    }\n    mt19937 mt{random_device{}()};\n    uniform_int_distribution<int> dist{0, N - 1};\n    for (int i = 0; i < 30 * N; i++) {\n        int u = 0;\n        int v = 0;\n        while (u == v) {\n            u = dist(mt);\n            v = dist(mt);\n        }\n        if (ok(u, v)) {\n            cout << \"Yes\" << endl;\n            return 0;\n        }\n    }\n    cout << \"No\" << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <ctime>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nint N;\nvector<P> vc;\nD eps=1e-9;\nbool comp(const P& l,const P& r){\n\tif(l.real()!=r.real()) return l.real()<r.real();\n\treturn l.imag()<r.imag();\n}\ninline D dot(P a, P b) { return real(conj(a)*b);};\ninline D cro(P a, P b) { return imag(conj(a)*b);};\ninline P perp(L l, P p){\t\t//垂線の足\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline P refl(L l, P p){\n\treturn p+2.0*(perp(l,p)-p);\n}\nint exist(P p){\n\tint x=ceil(p.real()-eps),y=ceil(p.imag()-eps);\n\tif(abs(p-P(x,y))>eps) return N;\n\treturn lower_bound(all(vc),P(x,y),comp)-vc.begin();\n}\nint main(){\n\tsrand((unsigned int)time(NULL));\n\tcin>>N;\n\trep(i,N){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tvc.pb(P(x,y));\n\t}\n\tsort(all(vc),comp);\n\tbool safe=false;\n\tfor(int i=2;i<N;i++){\n\t\tif(abs(cro(vc[1]-vc[i],vc[0]-vc[i]))>eps) safe=true;\n\t}\n\tif(!safe){\n\t\tcout<<\"No\\n\";\n\t\treturn 0;\n\t}\n//\trep(i,N) show(vc[i]);\n//\tcout<<endl;\n\trep(tt,20*N){\n\t\tbool can=true;\n\t\tint x=rand()%N,y=rand()%N;\n\t\tif(x==y) continue;\n\t\tP p=vc[x],q=vc[y],m=(p+q)/2.0;\n\t\tL l=L((p-m)*P(0,1)+m,(p-m)*P(0,-1)+m);\n/*\t\tif(x==0&&y==3){\n\t\t\tshow(l.fs);\n\t\t\tshow(l.sc);\n\t\t}*/\n\t\tint cnt=0;\n\t\trep(i,N){\n\t\t\tP ref=refl(l,vc[i]);\n\t\t\tint id=exist(ref);\n/*\t\t\tif(x==0&&y==3){\n\t\t\t\tshow(i);\n\t\t\t\tshow(id);\n\t\t\t}*/\n\t\t\tif(id==N||abs(vc[id]-ref)>eps){\n\t\t\t\tcan=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(id==i) cnt++;\n\t\t}\n\t\tif(cnt>=3) can=false;\n\t\tif(can){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-8)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point {\npublic:\n  double x,y;\n\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (const Point& p) { return Point(x+p.x,y+p.y); }\n  Point operator - (const Point& p) { return Point(x-p.x,y-p.y); }\n  Point operator * (const double& p) { return Point(x*p,y*p); }\n  Point operator / (const double& p) { return Point(x/p,y/p); }\n  \n  bool operator < ( const Point & p ) const { return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y);}\n  bool operator == ( const Point & p ) const { return equals(x,p.x) && equals(y,p.y); }\n  \n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\nostream& operator << (ostream& os,const Point&a ) { os << \"(\" << a.x << \",\" << a.y << \")\"; }\nostream& operator << (ostream& os,const Segment& a) { os << \"(\" << a.p1 << \",\" << a.p2 << \")\"; }\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble toRad(double a){ return a * M_PI / 180.0; }\nPoint rotate(Point a,double rad) { return Point(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) <-EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLP(Line l,Point p){\n  return abs(cross(l.p2-p,l.p1-p)) < EPS;\n}\n\nPoint projection(Line l,Point p) {\n  double  t = dot(p-l.p1,l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + ( l.p1 - l.p2 ) * t;\n}\n\nPoint reflection(Line l,Point p){\n  return p + (projection(l,p)-p) * 2;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y-q.y) - (r.y-q.y) * (p.x-q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool onSegment(Point p,Point q,Point r) {\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2))+sqrt(pow(r.x-q.x,2)+pow(r.y-q.y,2)),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)));\n}\n\nconst string YES = \"Yes\";\nconst string NO  = \"No\";\nint n;\n\nPolygon answerScan(Polygon s){\n  Polygon u,l;\n  if( s.size() < 3 ) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  REP(i,2,s.size()){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n\n}\n\nbool isValid(vector<Point> &vec) {\n  Line line = Line(vec[0],vec[1]);\n  bool ok = false;\n  rep(i,vec.size()) {\n    if( !intersectLP(line,vec[i]) ) { ok = true; break; }\n  }\n  if( !ok ) return false;\n  return true;\n}\n\nbool isAnswer(Line line,vector<Point> &vec){\n  vector<Point> vec_CW,vec_CCW;\n  int on_line = 0;\n  rep(j,n){\n    if( intersectLP(line,vec[j]) ) { ++on_line; continue; }\n    int res = ccw(line.p1,line.p2,vec[j]);\n    assert( res == COUNTER_CLOCKWISE || res == CLOCKWISE );\n    if( res == CLOCKWISE ) vec_CW.push_back(vec[j]);\n    else                   vec_CCW.push_back(vec[j]);\n  }\n  if( vec_CW.size() != vec_CCW.size() ) return false;\n  if( !( on_line <= 2 ) ) return false;\n\n  map<Point,bool> mp;\n  rep(j,vec_CCW.size()) mp[vec_CCW[j]] = true;\n  bool success = true;\n  rep(j,vec_CW.size()){\n    Point rp = reflection(line,vec_CW[j]);\n    if( !mp.count(rp) ) { success = false; break; }\n  }\n  return success;\n}\n\nvoid compute(vector<Point> &vec){\n  if( !isValid(vec) ) {\n    cout << NO << endl;\n    return;\n  }\n\n  Polygon poly = answerScan(vec);\n  //rep(i,poly.size()) cout << poly[i] << endl;\n\n  rep(i,poly.size()){\n    Vector v = poly[(i+1)%poly.size()] - poly[i];\n    v = rotate(v,toRad(90));\n    Vector e = v / abs(v);\n    Point mid_p = (poly[i]+poly[(i+1)%poly.size()])/2;\n    Line line = Line(mid_p,mid_p+e*100);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n\n  rep(i,n) REP(j,i+1,n) {\n    Line line = Line(vec[i],vec[j]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n    /*\n  }\n    */\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> n;\n  vector<Point> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y;\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nLine getPerpendicularBisector(Point a,Point b){\n  Point m=b+((a-b)/2.0);\n  Vector v1=(m-a),v2=(m-b);\n  swap(v1.x,v1.y);\n  v1.y=(-1.0)*v1.y;\n  swap(v2.x,v2.y);\n  v2.y=(-1.0)*v2.y;\n  return Line(m+v1,m+v2);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2 && ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2 && ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint n;\nvector<Point> vp;\nPolygon p;\n\nbool check(Line L){\n  int count=0;\n  vector<Point> vpp;\n  for(int i=0;i<vp.size();i++){\n    int c=ccw(L.p1,L.p2,vp[i]);\n    if(c==2 || c==-2 || c==0)count++;\n    if(count==3)return false;\n    vpp.push_back(reflect(L,vp[i]));\n  }\n  sort(vpp.begin(),vpp.end());\n  if(vpp!=vp)return false;\n  return true;\n}\n\nint main()\n{\n  int x,y;\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    vp.push_back(Point(x,y));\n  }\n  sort(vp.begin(),vp.end());\n  p=convex_hull(vp);\n\n  string ans=\"No\";\n  int s=p.size();\n  if(s<=vp.size()){\n    for(int i=0;i<s;i++){\n      Line L = getPerpendicularBisector(p[i],p[(i+1)%s]);\n      if(check(L))ans=\"Yes\";\n      if(s%2==0){\n\tL=Line(p[i],p[(i+s/2)%s]);\n\tif(check(L))ans=\"Yes\";\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> PI;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nvector<P> convex_hull(vector<P>& ps){\n  sort(ps.begin(),ps.end(),[](const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; });\n  int n=ps.size();\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool intersectLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nP reflection(L l,P p) {\n  return p+2.0*(projection(l,p)-p);\n}\n\nint N;\nvector<P> ps;\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  vector<P> cs=convex_hull(ps);\n  int M=cs.size();\n  vector<P> ds;\n  rep(i,M){\n    ds.push_back(cs[i]);\n    ds.push_back((cs[i]+cs[(i+1)%M])*0.5);\n  }\n  vector<L> cand;\n  rep(i,M){\n    bool ok=true;\n    P p1=ds[i],p2=ds[i+M];\n    for(int l=(i-1+2*M)%(2*M),r=i+1;l!=r;l=(l-1+2*M)%(2*M),r=(r+1)%(2*M)){\n      P m=(ds[l]+ds[r])*0.5;\n      if(!intersectLP(L(p1,p2),m)||abs(dot(ds[l]-ds[r],p1-p2))>eps)ok=false;\n    }\n    if(ok){\n      cand.push_back(L(p1,p2));\n    }\n  }\n\n  bool is_sym=false;\n  sort(all(ps),cmp_x);\n  vector<PI> ssps;\n  rep(i,N)ssps.push_back(PI(ps[i].X,ps[i].Y));\n  sort(all(ssps));\n  rep(i,cand.size()){\n    vector<PI> sps;\n    rep(j,N){\n      P r=reflection(cand[i],ps[j]);\n      sps.push_back(PI((int)r.X,(int)r.Y));\n    }\n    sort(all(sps));\n    bool ok=true;\n    int cnt=0;\n    rep(j,N){\n      if(sps[i]!=ssps[i])ok=false;\n      if(intersectLP(cand[i],ps[j]))cnt++;\n    }\n    if(ok&&cnt<3)is_sym=true;\n  }\n\n  if(is_sym)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <cmath>\n#include <algorithm>\n#include <functional>\n#include <cstdlib>\n#include <ctime>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\ntypedef double D;\ntypedef complex<D> P;\ntypedef pair<P,P> L;\nint N;\nvector<P> vc;\nD eps=1e-9;\nbool comp(const P& l,const P& r){\n\tif(l.real()!=r.real()) return l.real()<r.real();\n\treturn l.imag()<r.imag();\n}\ninline D dot(P a, P b) { return real(conj(a)*b);};\ninline D cro(P a, P b) { return imag(conj(a)*b);};\ninline P perp(L l, P p){\t\t//垂線の足\n\tD t=dot(p-l.fs,l.fs-l.sc)/norm(l.fs-l.sc);\n\treturn l.fs+t*(l.fs-l.sc);\n}\ninline P refl(L l, P p){\n\treturn p+2.0*(perp(l,p)-p);\n}\nint exist(P p){\n\tint x=ceil(p.real()-eps),y=ceil(p.imag()-eps);\n\tif(abs(p-P(x,y))>eps) return N;\n\treturn lower_bound(all(vc),P(x,y),comp)-vc.begin();\n}\nint main(){\n\tsrand((unsigned int)time(NULL));\n\tcin>>N;\n\trep(i,N){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tvc.pb(P(x,y));\n\t}\n\tsort(all(vc),comp);\n\tbool safe=false;\n\tfor(int i=2;i<N;i++){\n\t\tif(abs(cro(vc[1]-vc[2],vc[0]-vc[2]))>eps) safe=true;\n\t}\n\tif(!safe){\n\t\tcout<<\"No\\n\";\n\t\treturn 0;\n\t}\n//\trep(i,N) show(vc[i]);\n//\tcout<<endl;\n\trep(tt,N*200){\n\t\tbool can=true;\n\t\tint x=rand()%N,y=rand()%N;\n\t\tif(x==y) continue;\n\t\tP p=vc[x],q=vc[y],m=(p+q)/2.0;\n\t\tL l=L((p-m)*P(0,1)+m,(p-m)*P(0,-1)+m);\n/*\t\tif(x==0&&y==3){\n\t\t\tshow(l.fs);\n\t\t\tshow(l.sc);\n\t\t}*/\n\t\tint cnt=0;\n\t\trep(i,N){\n\t\t\tP ref=refl(l,vc[i]);\n\t\t\tint id=exist(ref);\n/*\t\t\tif(x==0&&y==3){\n\t\t\t\tshow(i);\n\t\t\t\tshow(id);\n\t\t\t}*/\n\t\t\tif(id==N||abs(vc[id]-ref)>eps){\n\t\t\t\tcan=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(id==i) cnt++;\n\t\t}\n//\t\tif(cnt>=3) can=false;\n\t\tif(can){\n\t\t\tcout<<\"Yes\\n\";\n\t\t\treturn 0;\n\t\t}\n\t}\n\tcout<<\"No\\n\";\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-8;\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){\n      cnt++;\n      continue;\n    }\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n\n    //    printf(\"%.2f %.2f\\n\",target.real(),target.imag());\n    //    cout<< px <<' '<<py<<endl;\n\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt%2==1)res=false;\n  return res;\n}\n\nbool solve(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<i;j++)\n      if( t[i]==t[j] )return false;\n\n  bool flag=false;\n  for(int i=1;i<N;i++){\n    P a=t[0];\n    P b=t[i];\n    if(check(a,b))flag=true;\n    P c=(a+b)*0.5;\n    P d=c+(b-a)*P(0,1);\n    if(check(c,d))flag=true;\n  }\n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\tif (lhs.imag() < rhs.imag() - eps) return true;\n\t\tif (lhs.imag() > rhs.imag() + eps) return false;\n\t\treturn false;\n\t}\n\tbool operator==(const Point &lhs, const Point &rhs) {\n\t\treturn eq(lhs.imag() , rhs.imag())&&eq(lhs.real(),rhs.real());\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n//\n//6\n//0 0\n//3 4\n//-3 -4\n//6 8\n//4 -3\n//7 1\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint main() {\n\tint N; cin >> N;\n\tvector<Point>ps;\n\tld sumx=0, sumy=0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.push_back(Point(x, y));\n\t\tsumx += x; sumy += y;\n\t}\n\tPoint centerp(sumx / N, sumy / N);\n\t{\n\t\tLine l(ps[0], ps[1]);\n\t\tif (all_of(ps.begin(), ps.end(), [=](const Point &p) {return isis_lp(l, p); })) {\n\t\t\tcout << \"No\" << endl; \n\t\t\treturn 0;\n\t\t}\n\t}\n\tint isc = -1;\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (centerp == ps[i]) {\n\t\t\tisc = i;\n\t\t}\n\t}\n\tif (isc != -1) {\n\t\tps.erase(ps.begin() + isc);\n\t\tN--;\n\t}\n\n\tsort(ps.begin(), ps.end(), [=](const Point &l, const Point &r) {\n\t\tPoint aap(atan(l - centerp));\n\t\tPoint ap(atan(r - centerp));\n\t\tld l_val = (l - centerp).imag()/ (l - centerp).real();\n\t\tld r_val = (r - centerp).imag() / (r - centerp).real();\n\t\tif (l.real() < centerp.real() && centerp.real() < r.real())return true;\n\t\tif (r.real() < centerp.real() && centerp.real() < l.real())return false;\n\t\treturn l_val < r_val;\n\t});\n\t{\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tLine s_line = Line(centerp, ps[i]);\n\t\t\tvector<set<Point>>ismirrors(3);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tint aa = i==j?0:ccw(ps[i], centerp, ps[j]);\n\t\t\t\tif (aa == 2 || aa == -2)aa = 0;\n\t\t\t\taa++;\n\t\t\t\tismirrors[aa].emplace(ps[j]);\n\t\t\t}\n\t\t\tint left_num = ismirrors[0].size();\n\t\t\tint right_num = ismirrors[2].size();\n\t\t\tint center_num = N - left_num - right_num;\n\t\t\tif ((left_num != right_num) || (center_num>left_num + right_num) || (center_num>2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (auto lp : ismirrors[0]) {\n\t\t\t\t\tPoint cp = proj(s_line, lp);\n\t\t\t\t\tPoint revp = cp * 2.l - lp;\n\t\t\t\t\tauto it = ismirrors[2].find(revp);\n\t\t\t\t\tif (it != ismirrors[2].end()) {\n\t\t\t\t\t\tismirrors[2].erase(it);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tLine s_line = Line(centerp, (ps[i]+ps[(i+1)%N])/2.l);\n\t\t\tvector<set<Point>>ismirrors(3);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tint aa = ccw((ps[i] + ps[(i + 1) % N]) / 2.l, centerp, ps[j]);\n\t\t\t\tif (aa == 2 || aa == -2)aa = 0;\n\t\t\t\taa++;\n\t\t\t\tismirrors[aa].emplace(ps[j]);\n\t\t\t}\n\t\t\tint left_num = ismirrors[0].size();\n\t\t\tint right_num = ismirrors[2].size();\n\t\t\tint center_num = N - left_num - right_num;\n\t\t\tif ((left_num != right_num) || (center_num>left_num + right_num) || (center_num>2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (auto lp : ismirrors[0]) {\n\t\t\t\t\tPoint cp = proj(s_line, lp);\n\t\t\t\t\tPoint revp = cp * 2.l - lp;\n\t\t\t\t\tauto it = ismirrors[2].find(revp);\n\t\t\t\t\tif (it != ismirrors[2].end()) {\n\t\t\t\t\t\tismirrors[2].erase(it);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-8;\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){\n      cnt++;\n      continue;\n    }\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt%2==1)res=false;\n  return res;\n}\n\nbool solve(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<i;j++)\n      if( t[i]==t[j] )return false;\n\n  bool flag=false;\n  for(int i=1;i<N;i++){\n    P a=t[0];\n    P b=t[i];\n    if(check(a,b))flag=true;\n    P c=(a+b)*0.5;\n    P d=c+(b-a)*P(0,1);\n    if(check(c,d))flag=true;\n  }\n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <cmath>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nnamespace libcomp {\nnamespace geometry {\n\nconst double EPS = 1e-9;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\n\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\ndouble norm(const Point &p){ return p.x * p.x + p.y * p.y; }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Line {\n\tPoint a;\n\tPoint b;\n\n\texplicit Line(const Point &a = Point(), const Point &b = Point()) :\n\t\ta(a), b(b)\n\t{ }\n\n\tstatic Line invalid(){\n\t\tPoint inv = Point::invalid();\n\t\treturn Line(inv, inv);\n\t}\n\tbool is_valid() const { return a.is_valid() && b.is_valid(); }\n\n\tbool operator<(const Line &l) const {\n\t\treturn (a == l.a) ? (b < l.b) : (a < l.a);\n\t}\n};\n\nbool tolerant_eq(const Line &a, const Line &b){\n\treturn ::std::abs(cross(a.b - a.a, b.a - a.a)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p - l.a, l.b - l.a) / norm(l.b - l.a);\n\treturn l.a + t * (l.b - l.a);\n}\n\nPoint reflection(const Line &l, const Point &p){\n\treturn p + 2.0 * (projection(l, p) - p);\n}\n\n}\n}\n\nusing namespace libcomp::geometry;\ntypedef pair<int, int> pii;\n\ninline ll pow2(ll x){ return x * x; }\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<Point> p(n);\n\tset<pii> ps;\n\tint xsum = 0, ysum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t\tps.insert(pii(x, y));\n\t\txsum += x;\n\t\tysum += y;\n\t}\n\tconst Point c(\n\t\tstatic_cast<double>(xsum) / n, static_cast<double>(ysum) / n);\n\tbool answer = false;\n\tif(n % 2 == 0){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(tolerant_eq(p[i], c)){ continue; }\n\t\t\tconst Line l(p[i], c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; accept && j < n; ++j){\n\t\t\t\tconst Point a = p[j];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; !answer && i < n; ++i){\n\t\tfor(int j = i + 1; !answer && j < n; ++j){\n\t\t\tconst Point q = projection(Line(p[i], p[j]), c);\n\t\t\tif(tolerant_eq(q, c)){ continue; }\n\t\t\tconst Line l((p[i] + p[j]) / 2, c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int k = 0; accept && k < n; ++k){\n\t\t\t\tconst Point a = p[k];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > n % 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (answer ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef array<P, 2> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n        if(cnt.size() == 1) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            if(i == 0 || N * N <= 10000 || cnt.count(l)) {\n                cnt[l] += 1;\n            }\n        }\n\n        //set<P> s;\n        //REP(i, N) s.insert(ps[i]);\n        sort(ps.begin(), ps.end());\n        bool ans = false;\n        // for(auto cp : cnt) {\n        //     //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        // }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!binary_search(ps.begin(), ps.end(), rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                DrawLine(cp.first);\n                for(int i = 0; i < N; i++) {\n                    DrawPoint(ps[i]);\n                    P rp = refl(cp.first, ps[i]);\n                    assert(s.count(rp));\n                    cout << ps[i] << \"<->\" << rp << \"(\" << s[rp] << \")\" << endl;\n                    assert(s[ refl(cp.first, rp) ] == i);\n                }\n                break;\n            }\n            */\n        }\n\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <cmath>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nnamespace libcomp {\nnamespace geometry {\n\nconst double EPS = 1e-9;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\n\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\ndouble norm(const Point &p){ return p.x * p.x + p.y * p.y; }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Line {\n\tPoint a;\n\tPoint b;\n\n\texplicit Line(const Point &a = Point(), const Point &b = Point()) :\n\t\ta(a), b(b)\n\t{ }\n\n\tstatic Line invalid(){\n\t\tPoint inv = Point::invalid();\n\t\treturn Line(inv, inv);\n\t}\n\tbool is_valid() const { return a.is_valid() && b.is_valid(); }\n\n\tbool operator<(const Line &l) const {\n\t\treturn (a == l.a) ? (b < l.b) : (a < l.a);\n\t}\n};\n\nbool tolerant_eq(const Line &a, const Line &b){\n\treturn ::std::abs(cross(a.b - a.a, b.a - a.a)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p - l.a, l.b - l.a) / norm(l.b - l.a);\n\treturn l.a + t * (l.b - l.a);\n}\n\nPoint reflection(const Line &l, const Point &p){\n\treturn p + 2.0 * (projection(l, p) - p);\n}\n\n}\n}\n\nusing namespace libcomp::geometry;\ntypedef pair<int, int> pii;\n\ninline ll pow2(ll x){ return x * x; }\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<Point> p(n);\n\tset<pii> ps;\n\tint xsum = 0, ysum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t\tps.insert(pii(x, y));\n\t\txsum += x;\n\t\tysum += y;\n\t}\n\tconst Point c(\n\t\tstatic_cast<double>(xsum) / n, static_cast<double>(ysum) / n);\n\tbool answer = false;\n\tif(n % 2 == 0){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(tolerant_eq(p[i], c)){ continue; }\n\t\t\tconst Line l(p[i], c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; accept && j < n; ++j){\n\t\t\t\tconst Point a = p[j];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; !answer && i < 4; ++i){\n\t\tfor(int j = i + 1; !answer && j < n; ++j){\n\t\t\tconst Point q = projection(Line(p[i], p[j]), c);\n\t\t\tif(tolerant_eq(q, c)){ continue; }\n\t\t\tconst Line l((p[i] + p[j]) / 2, c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int k = 0; accept && k < n; ++k){\n\t\t\t\tconst Point a = p[k];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > n % 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (answer ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-4)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point {\npublic:\n  double x,y;\n\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (const Point& p) { return Point(x+p.x,y+p.y); }\n  Point operator - (const Point& p) { return Point(x-p.x,y-p.y); }\n  Point operator * (const double& p) { return Point(x*p,y*p); }\n  Point operator / (const double& p) { return Point(x/p,y/p); }\n  \n  bool operator < ( const Point & p ) const { return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y);}\n  bool operator == ( const Point & p ) const { return equals(x,p.x) && equals(y,p.y); }\n  \n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\nostream& operator << (ostream& os,const Point&a ) { os << \"(\" << a.x << \",\" << a.y << \")\"; }\nostream& operator << (ostream& os,const Segment& a) { os << \"(\" << a.p1 << \",\" << a.p2 << \")\"; }\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble toRad(double a){ return a * M_PI / 180.0; }\nPoint rotate(Point a,double rad) { return Point(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) <-EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLP(Line l,Point p){\n  return abs(cross(l.p2-p,l.p1-p)) < EPS;\n}\n\nPoint projection(Line l,Point p) {\n  double  t = dot(p-l.p1,l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + ( l.p1 - l.p2 ) * t;\n}\n\nPoint reflection(Line l,Point p){\n  return p + (projection(l,p)-p) * 2;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y-q.y) - (r.y-q.y) * (p.x-q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool onSegment(Point p,Point q,Point r) {\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2))+sqrt(pow(r.x-q.x,2)+pow(r.y-q.y,2)),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)));\n}\n\nconst string YES = \"Yes\";\nconst string NO  = \"No\";\nint n;\n\nPolygon answerScan(Polygon s){\n  Polygon u,l;\n  if( s.size() < 3 ) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  REP(i,2,s.size()){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n\n}\n\nbool isValid(vector<Point> &vec) {\n  Line line = Line(vec[0],vec[1]);\n  bool ok = false;\n  rep(i,vec.size()) {\n    if( !intersectLP(line,vec[i]) ) { ok = true; break; }\n  }\n  if( !ok ) return false;\n  return true;\n}\n\nbool isAnswer(Line line,vector<Point> &vec){\n  vector<Point> vec_CW,vec_CCW;\n  int on_line = 0;\n  rep(j,n){\n    if( intersectLP(line,vec[j]) ) { ++on_line; continue; }\n    int res = ccw(line.p1,line.p2,vec[j]);\n    assert( res == COUNTER_CLOCKWISE || res == CLOCKWISE );\n    if( res == CLOCKWISE ) vec_CW.push_back(vec[j]);\n    else                   vec_CCW.push_back(vec[j]);\n  }\n  if( vec_CW.size() != vec_CCW.size() ) return false;\n  if( !( on_line <= 2 ) ) return false;\n\n  map<Point,bool> mp;\n  rep(j,vec_CCW.size()) mp[vec_CCW[j]] = true;\n  bool success = true;\n  rep(j,vec_CW.size()){\n    Point rp = reflection(line,vec_CW[j]);\n    if( !mp.count(rp) ) { success = false; break; }\n  }\n  return success;\n}\n\nvoid compute(vector<Point> &vec){\n  if( !isValid(vec) ) {\n    cout << NO << endl;\n    return;\n  }\n\n  Polygon poly = answerScan(vec);\n  //rep(i,poly.size()) cout << poly[i] << endl;\n\n  rep(i,poly.size()){\n    Vector v = poly[(i+1)%poly.size()] - poly[i];\n    v = rotate(v,toRad(90));\n    Vector e = v / abs(v);\n    Point mid_p = (poly[i]+poly[(i+1)%poly.size()])/2;\n    Line line = Line(mid_p,mid_p+e*100);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n  /*\n  rep(i,n) REP(j,i+1,n) {\n    Line line = Line(vec[i],vec[j]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n  */\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> n;\n  vector<Point> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y;\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-4)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point {\npublic:\n  double x,y;\n\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (const Point& p) { return Point(x+p.x,y+p.y); }\n  Point operator - (const Point& p) { return Point(x-p.x,y-p.y); }\n  Point operator * (const double& p) { return Point(x*p,y*p); }\n  Point operator / (const double& p) { return Point(x/p,y/p); }\n  \n  bool operator < ( const Point & p ) const { return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y);}\n  bool operator == ( const Point & p ) const { return equals(x,p.x) && equals(y,p.y); }\n  \n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\nostream& operator << (ostream& os,const Point&a ) { os << \"(\" << a.x << \",\" << a.y << \")\"; }\nostream& operator << (ostream& os,const Segment& a) { os << \"(\" << a.p1 << \",\" << a.p2 << \")\"; }\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble toRad(double a){ return a * M_PI / 180.0; }\nPoint rotate(Point a,double rad) { return Point(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) <-EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLP(Line l,Point p){\n  return abs(cross(l.p2-p,l.p1-p)) < EPS;\n}\n\nPoint projection(Line l,Point p) {\n  double  t = dot(p-l.p1,l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + ( l.p1 - l.p2 ) * t;\n}\n\nPoint reflection(Line l,Point p){\n  return p + (projection(l,p)-p) * 2;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y-q.y) - (r.y-q.y) * (p.x-q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool onSegment(Point p,Point q,Point r) {\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2))+sqrt(pow(r.x-q.x,2)+pow(r.y-q.y,2)),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)));\n}\n\nconst string YES = \"Yes\";\nconst string NO  = \"No\";\nint n;\n\nPolygon answerScan(Polygon s){\n  Polygon u,l;\n  if( s.size() < 3 ) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  REP(i,2,s.size()){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n\n}\n\nbool isValid(vector<Point> &vec) {\n  Line line = Line(vec[0],vec[1]);\n  bool ok = false;\n  rep(i,vec.size()) {\n    if( !intersectLP(line,vec[i]) ) { ok = true; break; }\n  }\n  if( !ok ) return false;\n  return true;\n}\n\nbool isAnswer(Line line,vector<Point> &vec){\n  vector<Point> vec_CW,vec_CCW;\n  int on_line = 0;\n  rep(j,n){\n    if( intersectLP(line,vec[j]) ) { ++on_line; continue; }\n    int res = ccw(line.p1,line.p2,vec[j]);\n    assert( res == COUNTER_CLOCKWISE || res == CLOCKWISE );\n    if( res == CLOCKWISE ) vec_CW.push_back(vec[j]);\n    else                   vec_CCW.push_back(vec[j]);\n  }\n  if( vec_CW.size() != vec_CCW.size() ) return false;\n  if( !( on_line <= 2 ) ) return false;\n\n  map<Point,bool> mp;\n  rep(j,vec_CCW.size()) mp[vec_CCW[j]] = true;\n  bool success = true;\n  rep(j,vec_CW.size()){\n    Point rp = reflection(line,vec_CW[j]);\n    if( !mp.count(rp) ) { success = false; break; }\n  }\n  return success;\n}\n\nvoid compute(vector<Point> &vec){\n  if( !isValid(vec) ) {\n    cout << NO << endl;\n    return;\n  }\n\n  Polygon poly = answerScan(vec);\n  //rep(i,poly.size()) cout << poly[i] << endl;\n\n  rep(i,poly.size()){\n    Vector v = poly[(i+1)%poly.size()] - poly[i];\n    v = rotate(v,toRad(90));\n    Vector e = v / abs(v);\n    Point mid_p = (poly[i]+poly[(i+1)%poly.size()])/2;\n    Line line = Line(mid_p,mid_p+e*100);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n\n  rep(i,n) REP(j,i+1,n) {\n    Line line = Line(vec[i],vec[j]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> n;\n  vector<Point> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y;\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <cmath>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nnamespace libcomp {\nnamespace geometry {\n\nconst double EPS = 1e-5;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\n\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\ndouble norm(const Point &p){ return p.x * p.x + p.y * p.y; }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Line {\n\tPoint a;\n\tPoint b;\n\n\texplicit Line(const Point &a = Point(), const Point &b = Point()) :\n\t\ta(a), b(b)\n\t{ }\n\n\tstatic Line invalid(){\n\t\tPoint inv = Point::invalid();\n\t\treturn Line(inv, inv);\n\t}\n\tbool is_valid() const { return a.is_valid() && b.is_valid(); }\n\n\tbool operator<(const Line &l) const {\n\t\treturn (a == l.a) ? (b < l.b) : (a < l.a);\n\t}\n};\n\nbool tolerant_eq(const Line &a, const Line &b){\n\treturn ::std::abs(cross(a.b - a.a, b.a - a.a)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p - l.a, l.b - l.a) / norm(l.b - l.a);\n\treturn l.a + t * (l.b - l.a);\n}\n\nPoint reflection(const Line &l, const Point &p){\n\treturn p + 2.0 * (projection(l, p) - p);\n}\n\n}\n}\n\nusing namespace libcomp::geometry;\ntypedef pair<int, int> pii;\n\ninline ll pow2(ll x){ return x * x; }\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<Point> p(n);\n\tset<pii> ps;\n\tint xsum = 0, ysum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t\tps.insert(pii(x, y));\n\t\txsum += x;\n\t\tysum += y;\n\t}\n\tconst Point c(\n\t\tstatic_cast<double>(xsum) / n, static_cast<double>(ysum) / n);\n\tbool answer = false;\n\tif(n % 2 == 0){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(tolerant_eq(p[i], c)){ continue; }\n\t\t\tconst Line l(p[i], c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int j = 0; accept && j < n; ++j){\n\t\t\t\tconst Point a = p[j];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; !answer && i < 3; ++i){\n\t\tfor(int j = i + 1; !answer && j < n; ++j){\n\t\t\tconst Point q = projection(Line(p[i], p[j]), c);\n\t\t\tif(tolerant_eq(q, c)){ continue; }\n\t\t\tconst Line l((p[i] + p[j]) / 2, c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int k = 0; accept && k < n; ++k){\n\t\t\t\tconst Point a = p[k];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > n % 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (answer ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-8;\ntypedef complex<double> P;\ntypedef vector<P> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            cnt[l] += 1;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n        set<P> s;\n        REP(i, N) s.insert(ps[i]);\n        \n        assert(s.size() == N);\n\n        bool ans = false;\n        for(auto cp : cnt) {\n            //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        }\n        for(auto cp : cnt) if(cp.second >= N) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!s.count(rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                for(int i = 0; i < N; i++) {\n                    P rp = refl(cp.first, ps[i]);\n                    cout << ps[i] << \"<->\" << rp << endl;\n                }\n                break;\n            }\n            */\n        }\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <random>\nusing namespace std;\nusing ll = long long;\nstruct P {\n    ll x;\n    ll y;\n    bool operator<(const P& p) const\n    {\n        return (x != p.x) ? x < p.x : y < p.y;\n    }\n};\nvector<P> pos;\nint N;\n\nbool ok(const int i, const int j)\n{\n    const ll x = (pos[i].x + pos[j].x) / 2;\n    const ll y = (pos[i].y + pos[j].y) / 2;\n    const ll dx = pos[j].x - x;\n    const ll dy = pos[j].y - y;\n    set<P> p;\n    int cnt = 0;\n    ll h = 0;\n    for (int k = 0; k < N; k++) {\n        if (k == i or k == j) {\n            continue;\n        }\n        const ll X = pos[k].x - x;\n        const ll Y = pos[k].y - y;\n        const ll S = X * dx + Y * dy;\n        const ll T = -X * dy + Y * dx;\n        h = max(h, abs(T));\n        if (S == 0) {\n            cnt++;\n        }\n        p.insert(P{S, T});\n    }\n    if (cnt >= 3 or h == 0) {\n        return false;\n    }\n    for (const auto& pp : p) {\n        if (p.find(P{-pp.x, pp.y}) == p.end()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        ll x, y;\n        cin >> x >> y;\n        pos.push_back(P{2 * x, 2 * y});\n    }\n    mt19937 mt{random_device{}()};\n    uniform_int_distribution<int> dist{0, N - 1};\n    for (int i = 0; i < 100 * N; i++) {\n        int u = 0;\n        int v = 0;\n        while (u == v) {\n            u = dist(mt);\n            v = dist(mt);\n        }\n        if (ok(u, v)) {\n            cout << \"Yes\" << endl;\n            return 0;\n        }\n    }\n    cout << \"No\" << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-7;\nbool eq(double a,double b){\n  double EPS = max( abs(a) , abs(b) ) * eps;\n  EPS=max(EPS,eps);\n  return (-EPS<a-b&&a-b<EPS);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){cnt++;continue;}\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt>1 && cnt%2==1 )res=false;\n  return res;\n}\n\nbool solve(){\n  P b=t[0];\n  int cnt=0;\n  for(int i=1;i<N;i++){\n    b+=t[i];\n    double v=cross(t[1]-t[0],t[i]-t[0]);\n    if(eq(v,0))cnt++;\n  }\n  if(cnt==N-1)return false;\n\n  b/=(double)N;\n  \n  bool flag=false;\n  for(int i=0;i<N;i++){\n    P a=t[i];\n    if( eq(0, abs(a-b) ) )continue;\n    if(check(a,b))flag=true;\n  }\n\n  for(int i=0;i<2;i++){\n    P c=t[i];\n    for(int j=i+1;j<N;j++){\n      P d=t[j];\n      if(check(c,d))flag=true;\n      P nc=(c+d)*0.5;\n      P nd=nc+(d-c)*P(0,1);\n      if(check(nc,nd))flag=true;\n    }\n  }\n  \n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n    for(int j=0;j<i;j++)assert(t[i]!=t[j]);\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-8;\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){\n      cnt++;\n      continue;\n    }\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt%2==1)res=false;\n  if(cnt==N)res=false;\n  return res;\n}\n\nbool solve(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<i;j++)\n      if( t[i]==t[j] )return false;\n\n  bool flag=false;\n  for(int i=1;i<N;i++){\n    P a=t[0];\n    P b=t[i];\n    if(check(a,b))flag=true;\n    P c=(a+b)*0.5;\n    P d=c+(b-a)*P(0,1);\n    if(check(c,d))flag=true;\n  }\n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <complex>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <array>\n#include <set>\nusing namespace std;\n\nconst double EPS = 1e-8;\nconst double INF = 1e12;\nconst double PI = acos(-1);\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n#define X real()\n#define Y imag()\n\ntypedef complex<double> P;\ntypedef vector<P> VP;\nstruct L : array<P, 2>{\n    L(const P& a, const P& b){ at(0)=a; at(1)=b; }\n    L(){}\n};\n\nnamespace std{\n    bool operator < (const P& a, const P& b){\n        return !EQ(a.X,b.X) ? a.X<b.X : a.Y+EPS<b.Y;\n    }\n    bool operator == (const P& a, const P& b){\n        return abs(a-b) < EPS;\n    }\n}\n\ndouble dot(P a, P b){\n    return (conj(a)*b).X;\n}\ndouble cross(P a, P b){\n    return (conj(a)*b).Y;\n}\n\nbool intersectLP(const L& l, const P& p){\n    return abs(cross(l[1]-p, l[0]-p)) < EPS;\n}\n\nP projection(const L& l, const P& p) {\n    double t = dot(p-l[0], l[0]-l[1]) / norm(l[0]-l[1]);\n    return l[0] + t*(l[0]-l[1]);\n}\nP reflection(const L& l, const P& p) {\n    return p + 2.0*(projection(l, p) -p);\n}\n\nint main(){\n    int n;\n    cin >> n;\n    set<P> poly;\n    for(int i=0; i<n; i++){\n        int x,y;\n        cin >> x >> y;\n        poly.insert(P(x, y));\n    }\n\n    P g(0, 0);\n    for(auto p: poly){\n        g += p;\n    }\n    g /= (double)n;\n\n    vector<L> cand;\n    for(auto p: poly){\n        if(g != p){\n            cand.emplace_back(g, p);\n        }\n        for(auto q: poly){\n            if(p == q) continue;\n            P mid = (p+q) /2.0;\n            if(g == mid) continue;\n            if(reflection(L(g, mid), p) == q){\n                cand.emplace_back(g, mid);\n            }\n        }\n    }\n    bool ok = false;\n    for(auto l: cand){\n        int on_line = 0;\n        bool symmetry = true;\n        for(auto p: poly){\n            if(intersectLP(l, p)){\n                on_line++;\n            }\n            if(poly.find(reflection(l, p)) == poly.end()){\n                symmetry = false;\n                break;\n            }\n        }\n        if(symmetry and on_line <= 2){\n            ok = true;\n            break;\n        }\n    }\n    if(ok){\n        cout << \"Yes\" << endl;\n    }else{\n        cout << \"No\" << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\n#define EPS (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nPolygon tangent(Circle c1,Circle c2){\n  Polygon p;\n  return p;\n}\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  set<Point> sp;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  Polygon q=andrewScan(p);\n  if(equals(area(q),0)){\n    cout<<\"No\"<<endl;\n    return 0;\n  }\n  for(int i=0;i<n;i++) sp.insert(p[i]);\n  for(int k=0;k<min(10LL,n);k++){\n    for(int i=0;i<n;i++){\n      if(i==k) continue;\n      {\n\tbool flg=1;\n\tLine l(p[k],p[i]);\n\tfor(int j=0;j<n;j++)\n\t  flg&=equals(getDistanceLP(l,p[j]),0)||sp.count(reflect(l,p[j]));\n\tif(flg){\n\t  int cnt=0;\n\t  for(int j=0;j<n;j++)\n\t    cnt+=equals(getDistanceLP(l,p[j]),0);\n\t  if(cnt<3){\n\t    cout<<\"Yes\"<<endl;\n\t    exit(0);\n\t  }\n\t}\n      }\n      {\n\tbool flg=1;\n\tLine l=bisector(p[k],p[i]);\n\tfor(int j=0;j<n;j++)\n\t  flg&=equals(getDistanceLP(l,p[j]),0)||sp.count(reflect(l,p[j]));\n\tif(flg){\n\t  int cnt=0;\n\t  for(int j=0;j<n;j++)\n\t    cnt+=equals(getDistanceLP(l,p[j]),0);\n\t  if(cnt<3){\n\t    cout<<\"Yes\"<<endl;\n\t    exit(0);\n\t  }\n\t}\n      }\n    }\n  }\n  cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-8;\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){\n      cnt++;\n      continue;\n    }\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(mp.count(px)==0)return false;\n    if(mp[px].count(py)==0)return false;\n  }\n  if(cnt%2==1)return false;\n  return true;\n}\n\nbool solve(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<i;j++)\n      if( t[i]==t[j] )return false;\n\n  for(int i=1;i<N;i++){\n    P a=t[0];\n    P b=t[1];\n    if(check(a,b))return true;\n    P c=(a+b)*0.5;\n    P d=(b-a)*P(0,1);\n    if(check(c,d))return true;\n  }\n  return false;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<set>\n#include<math.h>\nusing namespace std;\nconst double EPS = 1e-10;\nconst double INF = 1e+10;\nconst double PI = acos(-1);\nint sig(double r) { return (r < -EPS) ? -1 : (r > +EPS) ? +1 : 0; }\ninline double ABS(double a){return max(a,-a);}\nstruct Pt {\n\tdouble x, y;\n\tPt() {}\n\tPt(double x, double y) : x(x), y(y) {}\n\tPt operator+(const Pt &a) const { return Pt(x + a.x, y + a.y); }\n\tPt operator-(const Pt &a) const { return Pt(x - a.x, y - a.y); }\n\tPt operator*(const Pt &a) const { return Pt(x * a.x - y * a.y, x * a.y + y * a.x); }\n\tPt operator-() const { return Pt(-x, -y); }\n\tPt operator*(const double &k) const { return Pt(x * k, y * k); }\n\tPt operator/(const double &k) const { return Pt(x / k, y / k); }\n\tdouble ABS() const { return sqrt(x * x + y * y); }\n\tdouble abs2() const { return x * x + y * y; }\n\tdouble arg() const { return atan2(y, x); }\n\tdouble dot(const Pt &a) const { return x * a.x + y * a.y; }\n\tdouble det(const Pt &a) const { return x * a.y - y * a.x; }\n};\ndouble tri(const Pt &a, const Pt &b, const Pt &c) { return (b - a).det(c - a); }\nPt pLL(Pt a, Pt b, Pt c, Pt d) {\n\tb = b - a; d = d - c; return a + b * (c - a).det(d) / b.det(d);\n}\n\nPt hLP(Pt a,Pt b,Pt c){\n\treturn pLL(a,b,c,c+(b-a)*Pt(0,1));\n}\ndouble dLP(Pt a, Pt b, Pt c) {\n\treturn ABS(tri(a, b, c)) / (b - a).ABS();\n}\ndouble x[1100];\ndouble y[1100];\nPt p[1100];\nset<pair<int,int> > S;\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++)scanf(\"%lf%lf\",x+i,y+i);\n\tfor(int i=0;i<a;i++)p[i]=Pt(x[i],y[i]);\n\tfor(int i=0;i<a;i++)S.insert(make_pair((int)(x[i]+0.5),(int)(y[i]+0.5)));\n\tbool dame=true;\n\tfor(int i=2;i<a;i++){\n\t\tif(dLP(p[0],p[1],p[i])>EPS)dame=false;\n\t}\n\tif(dame){\n\t\tprintf(\"No\\n\");\n\t\treturn 0;\n\t}\n\tbool ok=false;\n\tfor(int i=0;i<3;i++){\n\t\tfor(int j=i+1;j<a;j++){\n\t\t\tPt L=(p[i]+p[j])/2;\n\t\t\tPt v=(p[j]-p[i])*Pt(0,1);\n\t\t\tPt R=L+v;\n\t\t\tbool OK=true;\n\t\t\tint cnt=0;\n\t\t\tfor(int k=0;k<a;k++){\n\t\t\t\tif(i==k||j==k)continue;\n\t\t\t\tif(dLP(L,R,p[k])<EPS)cnt++;\n\t\t\t\telse{\n\t\t\t\t\tPt tmp=hLP(L,R,p[k]);\n\t\t\t\t\tPt to=tmp+tmp-p[k];\n\t\t\t\t\tint X=(int)(to.x+0.5);\n\t\t\t\t\tint Y=(int)(to.y+0.5);\n\t\t\t\t\tif((Pt((double)X,(double)Y)-to).ABS()>EPS)OK=false;\n\t\t\t\t\telse if(!S.count(make_pair(X,Y)))OK=false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!OK)continue;\n\t\t\tif(cnt>2){\n\t\t\t\tprintf(\"No\\n\");return 0;\n\t\t\t}else ok=true;\n\t\t}\n\t}\n\tif(ok)printf(\"Yes\\n\");\n\telse printf(\"No\\n\");\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\n\n\n#define EPS (1e-1)\n#define equals(a,b) (fabs((a)-(b)) < EPS)\n#define PI 3.141592653589793238\n \n// COUNTER CLOCKWISE\nstatic const int CCW_COUNTER_CLOCKWISE = 1;\nstatic const int CCW_CLOCKWISE = -1;\nstatic const int CCW_ONLINE_BACK = 2;\nstatic const int CCW_ONLINE_FRONT = -2;\nstatic const int CCW_ON_SEGMENT = 0;\n\n//Intercsect Circle & Circle\nstatic const int ICC_SEPERATE = 4;\nstatic const int ICC_CIRCUMSCRIBE = 3;\nstatic const int ICC_INTERSECT = 2;\nstatic const int ICC_INSCRIBE = 1;\nstatic const int ICC_CONTAIN = 0;\n\nstruct Point{\n  double x,y;\n  Point(){}\n  Point(double x,double y) :x(x),y(y){}\n  Point operator+(Point p) {return Point(x+p.x,y+p.y);}\n  Point operator-(Point p) {return Point(x-p.x,y-p.y);}\n  Point operator*(double k){return Point(x*k,y*k);}\n  Point operator/(double k){return Point(x/k,y/k);}\n  double norm(){return x*x+y*y;}\n  double abs(){return sqrt(norm());}\n\n  bool operator < (const Point &p) const{\n    return !equals(x,p.x)?x<p.x:!equals(y,p.y)?y<p.y:0;\n  }\n\n  bool operator == (const Point &p) const{\n    return fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n  }\n};\n\nistream &operator >> (istream &is,Point &p){\n  is>>p.x>>p.y;\n  return is;\n}\n\nostream &operator << (ostream &os,Point p){\n  os<<fixed<<setprecision(12)<<p.x<<\" \"<<p.y;\n  return os;\n}\n\nbool sort_x(Point a,Point b){\n  return a.x!=b.x?a.x<b.x:a.y<b.y;\n}\n\nbool sort_y(Point a,Point b){\n  return a.y!=b.y?a.y<b.y:a.x<b.x;\n}\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Segment{\n  Point p1,p2;\n  Segment(){}\n  Segment(Point p1, Point p2):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\nistream &operator >> (istream &is,Segment &s){\n  is>>s.p1>>s.p2;\n  return is;\n}\n\nstruct Circle{\n  Point c;\n  double r;\n  Circle(){}\n  Circle(Point c,double r):c(c),r(r){}\n};\n\nistream &operator >> (istream &is,Circle &c){\n  is>>c.c>>c.r;\n  return is;\n}\n\ndouble norm(Vector a){\n  return a.x*a.x+a.y*a.y;\n}\ndouble abs(Vector a){\n  return sqrt(norm(a));\n}\ndouble dot(Vector a,Vector b){\n  return a.x*b.x+a.y*b.y;\n}\ndouble cross(Vector a,Vector b){\n  return a.x*b.y-a.y*b.x;\n}\n\nbool isOrthogonal(Vector a,Vector b){\n  return equals(dot(a,b),0.0);\n}\n\nbool isOrthogonal(Point a1,Point a2,Point b1,Point b2){\n  return isOrthogonal(a1-a2,b1-b2);\n}\n\nbool isOrthogonal(Segment s1,Segment s2){\n  return equals(dot(s1.p2-s1.p1,s2.p2-s2.p1),0.0);\n}\n\nbool isParallel(Vector a,Vector b){\n  return equals(cross(a,b),0.0);\n}\n\nbool isParallel(Point a1,Point a2,Point b1,Point b2){\n  return isParallel(a1-a2,b1-b2);\n}\n\nbool isParallel(Segment s1,Segment s2){\n  return equals(cross(s1.p2-s1.p1,s2.p2-s2.p1),0.0); \n}\n\nPoint project(Segment s,Point p){\n  Vector base=s.p2-s.p1;\n  double r=dot(p-s.p1,base)/norm(base);\n  return s.p1+base*r;\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2.0;\n}\n\ndouble arg(Vector p){\n  return atan2(p.y,p.x);\n}\n\nVector polar(double a,double r){\n  return Point(cos(r)*a,sin(r)*a);\n}\n\nint ccw(Point p0,Point p1,Point p2);\nbool intersectSS(Point p1,Point p2,Point p3,Point p4);\nbool intersectSS(Segment s1,Segment s2);\nint intersectCC(Circle c1,Circle c2);\nbool intersectSC(Segment s,Circle c);\ndouble getDistanceLP(Line l,Point p);\ndouble getDistanceSP(Segment s,Point p);\ndouble getDistanceSS(Segment s1,Segment s2);\nPoint getCrossPointSS(Segment s1,Segment s2);\nPoint getCrossPointLL(Line l1,Line l2);\nPolygon getCrossPointCL(Circle c,Line l);\nPolygon getCrossPointCC(Circle c1,Circle c2);\nint contains(Polygon g,Point p);\nPolygon andrewScan(Polygon s);\nPolygon convex_hull(Polygon ps);\ndouble diameter(Polygon s);\nbool isConvex(Polygon p);\ndouble area(Polygon s);\nPolygon convexCut(Polygon p,Line l);\nLine bisector(Point p1,Point p2);\nVector translate(Vector v,double theta);\nvector<Line> corner(Line l1,Line l2);\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a = p1-p0;\n  Vector b = p2-p0;\n  if(cross(a,b) > EPS) return CCW_COUNTER_CLOCKWISE;\n  if(cross(a,b) < -EPS) return CCW_CLOCKWISE;\n  if(dot(a,b) < -EPS) return CCW_ONLINE_BACK;\n  if(a.norm()<b.norm()) return CCW_ONLINE_FRONT;\n  return CCW_ON_SEGMENT;\n}\n\nbool intersectSS(Point p1,Point p2,Point p3,Point p4){\n  return (ccw(p1,p2,p3)*ccw(p1,p2,p4) <= 0 &&\n\t  ccw(p3,p4,p1)*ccw(p3,p4,p2) <= 0 );\n}\n\nbool intersectSS(Segment s1,Segment s2){\n  return intersectSS(s1.p1,s1.p2,s2.p1,s2.p2);\n}\n\nint intersectCC(Circle c1,Circle c2){\n  if(c1.r<c2.r) swap(c1,c2);\n  double d=abs(c1.c-c2.c);\n  double r=c1.r+c2.r;\n  if(equals(d,r)) return ICC_CIRCUMSCRIBE;\n  if(d>r) return ICC_SEPERATE;\n  if(equals(d+c2.r,c1.r)) return ICC_INSCRIBE;\n  if(d+c2.r<c1.r) return ICC_CONTAIN;\n  return ICC_INTERSECT;\n}\n\nbool intersectSC(Segment s,Circle c){\n  double d=getDistanceSP(s,c.c);\n  return d<=c.r;\n}\n\ndouble getDistanceLP(Line l,Point p){\n  return abs(cross(l.p2-l.p1,p-l.p1)/abs(l.p2-l.p1));\n}\n\ndouble getDistanceSP(Segment s,Point p){\n  if(dot(s.p2-s.p1,p-s.p1) < 0.0 ) return abs(p-s.p1);\n  if(dot(s.p1-s.p2,p-s.p2) < 0.0 ) return abs(p-s.p2);\n  return getDistanceLP(s,p);\n}\n\ndouble getDistanceSS(Segment s1,Segment s2){\n  if(intersectSS(s1,s2)) return 0.0;\n  return min(min(getDistanceSP(s1,s2.p1),getDistanceSP(s1,s2.p2)),\n\t     min(getDistanceSP(s2,s1.p1),getDistanceSP(s2,s1.p2)));\n}\n\nPoint getCrossPointSS(Segment s1,Segment s2){\n  Vector base=s2.p2-s2.p1;\n  double d1=abs(cross(base,s1.p1-s2.p1));\n  double d2=abs(cross(base,s1.p2-s2.p1));\n  double t=d1/(d1+d2);\n  return s1.p1+(s1.p2-s1.p1)*t;\n}\n\nPoint getCrossPointLL(Line l1,Line l2){\n  double a=cross(l1.p2-l1.p1,l2.p2-l2.p1);\n  double b=cross(l1.p2-l1.p1,l1.p2-l2.p1);\n  if(abs(a)<EPS&&abs(b)<EPS) return l2.p1;\n  return l2.p1+(l2.p2-l2.p1)*(b/a);\n}\n\nPolygon getCrossPointCL(Circle c,Line l){\n  Polygon p(2);\n  Vector pr=project(l,c.c);\n  Vector e=(l.p2-l.p1)/abs(l.p2-l.p1);\n  double base=sqrt(c.r*c.r-norm(pr-c.c));\n  p[0]=pr+e*base;\n  p[1]=pr-e*base;\n  return p;\n}\n\nPolygon getCrossPointCC(Circle c1,Circle c2){\n  Polygon p(2);\n  double d=abs(c1.c-c2.c);\n  double a=acos((c1.r*c1.r+d*d-c2.r*c2.r)/(2*c1.r*d));\n  double t=arg(c2.c-c1.c);\n  p[0]=c1.c+polar(c1.r,t+a);\n  p[1]=c1.c+polar(c1.r,t-a);\n  return p;\n}\n\n// IN:2 ON:1 OUT:0\nint contains(Polygon g,Point p){\n  int n=g.size();\n  bool x=false;\n  for(int i=0;i<n;i++){\n    Point a=g[i]-p,b=g[(i+1)%n]-p;\n    if(fabs(cross(a,b)) < EPS && dot(a,b) < EPS) return 1;\n    if(a.y>b.y) swap(a,b);\n    if(a.y < EPS && EPS < b.y && cross(a,b) > EPS ) x = !x;\n  }\n  return (x?2:0);\n}\n\nPolygon andrewScan(Polygon s){\n  Polygon u,l;\n  if(s.size()<3) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  for(int i=2;i<(int)s.size();i++){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      u.pop_back();\n    }\n    u.push_back(s[i]);\n  } \n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CCW_CLOCKWISE;n--){\n      l.pop_back();\n    }\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n} \n\nPolygon convex_hull(Polygon ps){\n  int n=ps.size();\n  sort(ps.begin(),ps.end(),sort_y);\n  int k=0;\n  Polygon qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0) k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\ndouble diameter(Polygon s){\n  Polygon p=s;\n  int n=p.size();\n  if(n==2) return abs(p[0]-p[1]);\n  int i=0,j=0;\n  for(int k=0;k<n;k++){\n    if(p[i]<p[k]) i=k;\n    if(!(p[j]<p[k])) j=k;\n  }\n  double res=0;\n  int si=i,sj=j;\n  while(i!=sj||j!=si){\n    res=max(res,abs(p[i]-p[j]));\n    if(cross(p[(i+1)%n]-p[i],p[(j+1)%n]-p[j])<0.0){\n      i=(i+1)%n;\n    }else{\n      j=(j+1)%n;\n    }\n  }\n  return res;\n}\n\nbool isConvex(Polygon p){\n  bool f=1;\n  int n=p.size();\n  for(int i=0;i<n;i++){\n    int t=ccw(p[(i+n-1)%n],p[i],p[(i+1)%n]);\n    f&=t!=CCW_CLOCKWISE;\n  }\n  return f;\n}\n\ndouble area(Polygon s){\n  double res=0;\n  for(int i=0;i<(int)s.size();i++){\n    res+=cross(s[i],s[(i+1)%s.size()])/2.0;\n  }\n  return abs(res);\n}\n\nPolygon convexCut(Polygon p,Line l){\n  Polygon q;\n  for(int i=0;i<(int)p.size();i++){\n    Point a=p[i],b=p[(i+1)%p.size()];\n    if(ccw(l.p1,l.p2,a)!=-1) q.push_back(a);\n    if(ccw(l.p1,l.p2,a)*ccw(l.p1,l.p2,b)<0)\n      q.push_back(getCrossPointLL(Line(a,b),l));\n  }\n  return q;\n}\n\nLine bisector(Point p1,Point p2){\n  Circle c1=Circle(p1,abs(p1-p2)),c2=Circle(p2,abs(p1-p2));\n  Polygon p=getCrossPointCC(c1,c2);\n  if(cross(p2-p1,p[0]-p1)>0) swap(p[0],p[1]);\n  return Line(p[0],p[1]);\n}\n\nVector translate(Vector v,double theta){\n  Vector res;\n  res.x=cos(theta)*v.x-sin(theta)*v.y;\n  res.y=sin(theta)*v.x+cos(theta)*v.y;\n  return res;\n}\n\nvector<Line> corner(Line l1,Line l2){\n  vector<Line> res;\n  if(isParallel(l1,l2)){\n    double d=getDistanceLP(l1,l2.p1)/2.0;\n    Vector v1=l1.p2-l1.p1;\n    v1=v1/v1.abs()*d;\n    Point p=l2.p1+translate(v1,90.0*(PI/180.0));\n    double d1=getDistanceLP(l1,p);\n    double d2=getDistanceLP(l2,p);\n    if(abs(d1-d2)>d){\n      p=l2.p1+translate(v1,-90.0*(PI/180.0));\n    }\n    res.push_back(Line(p,p+v1));\n  }else{\n    Point p=getCrossPointLL(l1,l2);\n    Vector v1=l1.p2-l1.p1,v2=l2.p2-l2.p1;\n    v1=v1/v1.abs();\n    v2=v2/v2.abs();\n    res.push_back(Line(p,p+(v1+v2)));\n    res.push_back(Line(p,p+translate(v1+v2,90.0*(PI/180.0))));\n  }\n  return res;\n}\n\nPolygon tangent(Circle c1,Point p2){\n  Circle c2=Circle(p2,sqrt(norm(c1.c-p2)-c1.r*c1.r));\n  Polygon p=getCrossPointCC(c1,c2);\n  sort(p.begin(),p.end());\n  return p;\n}\n\nPolygon tangent(Circle c1,Circle c2){\n  Polygon p;\n  return p;\n}\n\n\nsigned main(){\n  int n;\n  cin>>n;\n  set<Point> sp;\n  Polygon p(n);\n  for(int i=0;i<n;i++) cin>>p[i];\n  for(int i=0;i<n;i++) sp.insert(p[i]);\n  for(int i=1;i<n;i++){\n    {\n      bool flg=1;\n      Line l(p[0],p[i]);\n      for(int j=0;j<n;j++)\n\tflg&=sp.count(reflect(l,p[j]));\n      if(flg){\n\tint cnt=0;\n\tfor(int j=0;j<n;j++)\n\t  cnt+=equals(getDistanceLP(l,p[j]),0);\n\tif(cnt>2) continue;\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n      }\n    }\n    {\n      bool flg=1;\n      Line l=bisector(p[0],p[i]);\n      for(int j=0;j<n;j++)\n\tflg&=sp.count(reflect(l,p[j]));\n      if(flg){\n\tint cnt=0;\n\tfor(int j=0;j<n;j++)\n\t  cnt+=equals(getDistanceLP(l,p[j]),0);\n\tif(cnt>2) continue;\n\tcout<<\"Yes\"<<endl;\n\texit(0);\n      }\n    }\n  }\n  cout<<\"No\"<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cmath>\n#include <vector>\n#include <tuple>\n#include <algorithm>\nusing namespace std;\n\nconst long double PI = 3.14159265358979;\nconst long double EPS = 1e-8;\n\nstruct Point {\n\tlong double px, py;\n};\nstruct Line {\n\tlong double pa, pb;\n};\nbool operator< (const Line &a1, const Line &a2) {\n\tif (a2.pa - a1.pa > EPS) return true;\n\telse if (a1.pa - a2.pa > EPS) return false;\n\telse if (a2.pb - a1.pb > EPS) return true;\n\treturn false;\n}\nbool operator== (const Line &a1, const Line &a2) {\n\tif (fabs(a1.pa - a2.pa) < EPS && fabs(a1.pb - a2.pb) < EPS) return true;\n\treturn false;\n}\nbool operator== (const Point &a1, const Point &a2) {\n\tif (fabs(a1.px - a2.px) < EPS && fabs(a1.py - a2.py) < EPS) return true;\n\treturn false;\n}\nbool operator< (const Point &a1, const Point &a2) {\n\tif (a2.px - a1.px > EPS) return true;\n\telse if (a1.px - a2.px > EPS) return false;\n\telse if (a2.py - a1.py > EPS) return true;\n\treturn false;\n}\n\nPoint rotate(Point a1) {\n\tPoint A;\n\tA.px = a1.px * cos(30.0L * PI / 360.0L) - a1.py * sin(30.0L * PI / 360.0L);\n\tA.py = a1.px * sin(30.0L * PI / 360.0L) + a1.py * cos(30.0L * PI / 360.0L);\n\treturn A;\n}\n\nLine makes(Point p1, Point p2) {\n\tPoint p3 = Point{ (p1.px + p2.px) / 2.0L, (p1.py + p2.py) / 2.0L };\n\n\tlong double a = -(p2.px - p1.px) / (p2.py - p1.py);\n\tlong double b = p3.py - p3.px * a;\n\treturn Line{ a, b };\n}\n\nint N; Point V[1009];\nvector<tuple<Line, int, int>>vec;\nbool used[1009];\n\nbool check2(Line V1, Point V2) {\n\tlong double E = V1.pb + V1.pa * V2.px;\n\tif (fabs(E - V2.py) < EPS) return true;\n\treturn false;\n}\n\nbool check(Line BASE, vector<pair<int, int>>T) {\n\tfor (int i = 0; i < N; i++) used[i] = false;\n\tfor (int i = 0; i < T.size(); i++) { used[T[i].first] = true; used[T[i].second] = true; }\n\n\tvector<int>U; for (int i = 0; i < N; i++) { if (used[i] == false) U.push_back(i); }\n\tif (U.size() >= 3) return false;\n\n\tvector<Point> I;\n\tfor (int i = 0; i < T.size(); i++) {\n\t\tI.push_back(Point{ (V[T[i].first].px + V[T[i].second].px) / 2.0L, (V[T[i].first].py + V[T[i].second].py) / 2.0L });\n\t}\n\tfor (int i = 0; i < U.size(); i++) I.push_back(V[U[i]]);\n\tsort(I.begin(), I.end());\n\tI.erase(unique(I.begin(), I.end()), I.end());\n\n\tif (I.size() == 1) return false;\n\n\tfor (int i = 0; i < U.size(); i++) {\n\t\tbool G = check2(BASE, V[U[i]]);\n\t\tif (G == false) return false;\n\t}\n\treturn true;\n}\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> V[i].px >> V[i].py;\n\t\tV[i] = rotate(V[i]);\n\t}\n\tfor (int i = 0; i < N; i++) {\n\t\tfor (int j = i + 1; j < N; j++) {\n\t\t\tvec.push_back(make_tuple(makes(V[i], V[j]), i, j));\n\t\t}\n\t}\n\tsort(vec.begin(), vec.end());\n\n\tvector<pair<int, int>>V; Line BASE = get<0>(vec[0]); V.push_back(make_pair(get<1>(vec[0]), get<2>(vec[0])));\n\tbool flag = false;\n\tfor (int i = 1; i <= vec.size(); i++) {\n\t\tif (i == vec.size() || !(BASE == get<0>(vec[i]))) {\n\t\t\tbool t = check(BASE, V);\n\t\t\tif (t == true) {\n\t\t\t\tflag = true;\n\t\t\t}\n\t\t\tif (i < vec.size()) BASE = get<0>(vec[i]);\n\t\t\tV.clear();\n\t\t}\n\t\tif (i < vec.size()) V.push_back(make_pair(get<1>(vec[i]), get<2>(vec[i])));\n\t}\n\n\tif (flag == true) cout << \"Yes\" << endl;\n\telse cout << \"No\" << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q):a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2):a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b):p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2,0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nbool solve(Polygon g, Line l)\n{\n\tint cnt = 0;\n\tPolygon r;\n\tREP(i, g.size())\n\t{\n\t\tif (isis_lp(l, g[i])) cnt++;\n\t\tr.push_back(mirror(l, g[i]));\n\t}\n\tif (cnt > 2) return false;\n\tsort(ALL(g));\n\tsort(ALL(r));\n\tREP(i, g.size())\n\t{\n\t\tif (abs(g[i] - r[i]) < EPS) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tPolygon p;\n\tREP(i, n)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(Point(x, y));\n\t}\n\tsort(ALL(p));\n\tPolygon g = convex_hull(p);\n\tint v = g.size();\n\tif (v < 3)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tREP(i, v)\n\t{\n\t\tLine l(g[i], g[(i + 1) % v]);\n\t\tPoint vec = l.b - l.a;\n\t\tPoint m = (l.a + l.b) / Point(2,0);\n\t\tLine s(m, m + Point(-vec.imag(), vec.real()));\n\t\tif (solve(p, s)) ans = true;\n\t}\n\tif (v % 2 == 0)\n\t{\n\t\tREP(i, v/2)\n\t\t{\n\t\t\tLine l(g[i], g[i + v / 2]);\n\t\t\tif (solve(p, l)) ans = true;\n\t\t}\n\t}\n\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\nconst Point rot(cos(0.575L), sin(0.575L));\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q):a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2):a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b):p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2,0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nbool solve(Polygon g, Line l)\n{\n\tint cnt = 0;\n\tPolygon r;\n\tREP(i, g.size())\n\t{\n\t\tif (isis_lp(l, g[i])) cnt++;\n\t\tr.push_back(mirror(l, g[i]));\n\t}\n\tif (cnt > 2) return false;\n\tsort(ALL(g));\n\tsort(ALL(r));\n\tREP(i, g.size())\n\t{\n\t\tif (abs(g[i] - r[i]) < EPS) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tPolygon p;\n\tREP(i, n)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(Point(x, y)*rot);\n\t}\n\tsort(ALL(p));\n\tPolygon g = convex_hull(p);\n\tint v = g.size();\n\tif (v < 3)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tREP(i, v)\n\t{\n\t\tLine l(g[i], g[(i + 1) % v]);\n\t\tPoint vec = l.b - l.a;\n\t\tPoint m = (l.a + l.b) / Point(2,0);\n\t\tLine s(m, m + Point(-vec.imag(), vec.real()));\n\t\tif (solve(p, s)) ans = true;\n\t}\n\tif (v % 2 == 0)\n\t{\n\t\tREP(i, v/2)\n\t\t{\n\t\t\tLine l(g[i], g[i + v / 2]);\n\t\t\tif (solve(p, l)) ans = true;\n\t\t\tl = Line((g[i] + g[i + 1]) / Point(2, 0), (g[i + v / 2] + g[(i + v / 2 + 1) % v]) / Point(2, 0));\n\t\t\tif (solve(p, l)) ans = true;\n\t\t}\n\t}\n\telse\n\t{\n\t\tREP(i, v)\n\t\t{\n\t\t\tLine l(g[i], (g[(i + v / 2) % v] + g[(i + v / 2 + 1) % v]) / Point(2, 0));\n\t\t\tif (solve(p, l)) ans = true;\n\t\t}\n\t}\n\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cctype>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <iomanip>\n\nusing namespace std;\n\ntypedef long long LL;\n\n#define REP(i, n) for (int i(0); i < (int) (n); i++)\n\nconst int N = 1000 + 10;\n\nstruct Line\n{\n\tint a, b, c;\n\tLine() {}\n\tLine(int, int);\n\n\tint operator < (const Line &that) const {\n\t\treturn (a < that.a) || (a == that.a && b < that.b) || (a == that.a && b == that.b && c < that.c);\n\t}\n\n\tint operator == (const Line &that) const {\n\t\treturn a == that.a && b == that.b && c == that.c;\n\t}\n\n\tint on(int x, int y) {\n\t\treturn x * a + y * b + c == 0;\n\t}\n};\n\nint n;\nint x[N], y[N];\nvector<pair<Line, pair<int, int> > > vec;\n\nLine::Line(int i, int j)\n{\n\ta = 2 * x[j] - 2 * x[i];\n\tb = 2 * y[j] - 2 * y[i];\n\tc = x[i] * x[i] + y[i] * y[i] - x[j] * x[j] - y[j] * y[j];\n\tint gcd = __gcd(__gcd(abs(a), abs(b)), abs(c));\n\ta /= gcd; b /= gcd; c /= gcd;\n\tif (a == 0 && b == 0) {\n\t\tfor( ; ; );\n\t}\n\tif (a < 0) {\n\t\ta *= -1; b *= -1; c *= -1;\n\t} else if (a == 0 && b < 0) {\n\t\ta *= -1; b *= -1; c *= -1;\n\t}\n}\n\nint check(Line line, vector<int> &ids)\n{\n\tint cnt = 0;\n\tfor(int i = 0; i < n; ++ i) {\n\t\tif (line.on(x[i], y[i])) {\n\t\t\tids.push_back(i);\n\t\t\t++ cnt;\n\t\t}\n\t}\n\t/*\n\t   cout << line.a << ' ' << line.b << ' ' << line.c << endl;\n\t   cout << ids.size() << endl;\n\t   cout << cnt << endl;\n\t */\n\tif (cnt > 2 || (int)ids.size() != n) \n\t\treturn false;\n\n\treturn true;\n}\n\nvoid solve() {\n\tvec.clear();\n\tfor(int i = 0; i < n; ++ i) {\n\t\tscanf(\"%d%d\", x + i, y + i);\n\t\tx[i] *= 2; y[i] *= 2;\n\t\tfor(int j = 0; j < i; ++ j) {\n\t\t\tif (x[i] == x[j] && y[i] == y[j]) {\n\t\t\t\tcout << \"No\" << endl;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvec.push_back(make_pair(Line(i, j), make_pair(i, j)));\n\t\t}\n\t}\n\tint flag = false;\n\tfor(int i = 2; i < n; ++ i) {\n\t\tif ((x[i] - x[0]) * (y[1] - y[0]) - (y[i] - y[0]) * (x[1] - x[0])) {\n\t\t\tflag = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (! flag) {\n\t\tcout << \"No\" << endl;\n\t\treturn;\n\t}\n\n\tsort(vec.begin(), vec.end());\n\tfor(int i = 0, j; i < (int)vec.size(); i = j) {\n\t\tfor(j = i; j < (int)vec.size() && vec[j].first == vec[i].first; ++ j);\n\t\tif (j - i < n / 2 - 10) continue;\n\n\t\tvector<int> ids;\n\t\tfor(int k = i; k < j; ++ k) {\n\t\t\tids.push_back(vec[k].second.first);\n\t\t\tids.push_back(vec[k].second.second);\n\t\t}\n\t\tif (check(vec[i].first, ids)) {\n\t\t\tcout << \"Yes\" << endl;\n\t\t\treturn;\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n}\n\nint main() {\n\tfor( ; cin >> n && n; ) {\n\t\tsolve();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-4)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point {\npublic:\n  double x,y;\n\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (const Point& p) { return Point(x+p.x,y+p.y); }\n  Point operator - (const Point& p) { return Point(x-p.x,y-p.y); }\n  Point operator * (const double& p) { return Point(x*p,y*p); }\n  Point operator / (const double& p) { return Point(x/p,y/p); }\n  \n  bool operator < ( const Point & p ) const { return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y);}\n  bool operator == ( const Point & p ) const { return equals(x,p.x) && equals(y,p.y); }\n  \n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\nostream& operator << (ostream& os,const Point&a ) { os << \"(\" << a.x << \",\" << a.y << \")\"; }\nostream& operator << (ostream& os,const Segment& a) { os << \"(\" << a.p1 << \",\" << a.p2 << \")\"; }\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble toRad(double a){ return a * M_PI / 180.0; }\nPoint rotate(Point a,double rad) { return Point(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) <-EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLP(Line l,Point p){\n  return abs(cross(l.p2-p,l.p1-p)) < EPS;\n}\n\nPoint projection(Line l,Point p) {\n  double  t = dot(p-l.p1,l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + ( l.p1 - l.p2 ) * t;\n}\n\nPoint reflection(Line l,Point p){\n  return p + (projection(l,p)-p) * 2;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y-q.y) - (r.y-q.y) * (p.x-q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool onSegment(Point p,Point q,Point r) {\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2))+sqrt(pow(r.x-q.x,2)+pow(r.y-q.y,2)),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)));\n}\n\nconst string YES = \"Yes\";\nconst string NO  = \"No\";\nint n;\n\nPolygon answerScan(Polygon s){\n  Polygon u,l;\n  if( s.size() < 3 ) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  REP(i,2,s.size()){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n\n}\n\nbool isValid(vector<Point> &vec) {\n  Line line = Line(vec[0],vec[1]);\n  bool ok = false;\n  rep(i,vec.size()) {\n    if( !intersectLP(line,vec[i]) ) { ok = true; break; }\n  }\n  if( !ok ) return false;\n  return true;\n}\n\nbool isAnswer(Line line,vector<Point> &vec){\n  vector<Point> vec_CW,vec_CCW;\n  int on_line = 0;\n  rep(j,n){\n    if( intersectLP(line,vec[j]) ) { ++on_line; continue; }\n    int res = ccw(line.p1,line.p2,vec[j]);\n    assert( res == COUNTER_CLOCKWISE || res == CLOCKWISE );\n    if( res == CLOCKWISE ) vec_CW.push_back(vec[j]);\n    else                   vec_CCW.push_back(vec[j]);\n  }\n  if( vec_CW.size() != vec_CCW.size() ) return false;\n  if( !( on_line <= 2 ) ) return false;\n\n  map<Point,bool> mp;\n  rep(j,vec_CCW.size()) mp[vec_CCW[j]] = true;\n  bool success = true;\n  rep(j,vec_CW.size()){\n    Point rp = reflection(line,vec_CW[j]);\n    if( !mp.count(rp) ) { success = false; break; }\n  }\n  return success;\n}\n\nvoid compute(vector<Point> &vec){\n  if( !isValid(vec) ) {\n    cout << NO << endl;\n    return;\n  }\n\n  Polygon poly = answerScan(vec);\n  //rep(i,poly.size()) cout << poly[i] << endl;\n\n  rep(i,poly.size()){\n    Vector v = poly[(i+1)%poly.size()] - poly[i];\n    v = rotate(v,toRad(90));\n    Vector e = v / abs(v);\n    Point mid_p = (poly[i]+poly[(i+1)%poly.size()])/2;\n    Line line = Line(mid_p,mid_p+e*100);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n\n  rep(i,n) REP(j,i+1,n) {\n    Line line = Line(vec[i],vec[j]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> n;\n  vector<Point> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y;\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-8;\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){\n      cnt++;\n      continue;\n    }\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(mp.count(px)==0)return false;\n    if(mp[px].count(py)==0)return false;\n  }\n  if(cnt%2==1)return false;\n  return true;\n}\n\nbool solve(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<i;j++)\n      if( t[i]==t[j] )return false;\n\n  for(int i=1;i<N;i++){\n    P a=t[0];\n    P b=t[i];\n    if(check(a,b))return true;\n    P c=(a+b)*0.5;\n    P d=(b-a)*P(0,1);\n    if(check(c,d))return true;\n  }\n  return false;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef complex<double> P;\n\ndouble eps=1e-8;\nbool eq(double a,double b){\n  return (-eps<a-b&&a-b<eps);\n}\n\ndouble cross(P a,P b){\n  return imag(b*conj(a));\n}\n\ndouble dist(P a,P b,P c){\n  b-=a;c-=a;\n  return cross(b,c)/abs(b);\n}\n\nP reflect(P a,P b,P c){\n  b-=a;c-=a;\n  return a+conj(c/b)*b;\n}\n\nint N;\nP t[1000];\nmap<int, map<int,bool> > mp;\n\nbool check(P a,P b){\n  bool res=true;\n  int cnt=0;\n  for(int i=0;i<N;i++){\n    if( eq( 0, dist(a,b,t[i])) ){\n      cnt++;\n      continue;\n    }\n    P target=reflect(a,b,t[i]);\n    int px=round(target.real());\n    int py=round(target.imag());\n    if(!eq(px,target.real()))res=false;\n    if(!eq(py,target.imag()))res=false;\n\n    if(mp.count(px)==0)res=false;\n    if(mp[px].count(py)==0)res=false;\n  }\n  if(cnt%2==1)res=false;\n  if(cnt==N)res=false;\n  return res;\n}\n\nbool solve(){\n  for(int i=0;i<N;i++)\n    for(int j=0;j<i;j++)\n      if( t[i]==t[j] )return false;\n\n  int cnt=0;\n  bool flag=false;\n  for(int i=1;i<N;i++){\n    double v=cross(t[1]-t[0],t[i]-t[0]);\n    if(eq(v,0))cnt++;\n    \n    P a=t[0];\n    P b=t[i];\n    if(check(a,b))flag=true;\n    P c=(a+b)*0.5;\n    P d=c+(b-a)*P(0,1);\n    if(check(c,d))flag=true;\n  }\n\n  if(cnt==N-1)flag=false;\n  return flag;\n}\n\nint main(){\n  scanf(\"%d\",&N);\n  for(int i=0;i<N;i++){\n    int x,y;\n    scanf(\"%d %d\",&x,&y);\n    t[i]=P(x,y);\n    mp[x][y]=true;\n  }\n  printf( solve() ? \"Yes\\n\" : \"No\\n\" );\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef array<P, 2> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, short> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n        if(cnt.size() == 1) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            cnt[l] += 1;\n        }\n\n        //set<P> s;\n        //REP(i, N) s.insert(ps[i]);\n        sort(ps.begin(), ps.end());\n        bool ans = false;\n        // for(auto cp : cnt) {\n        //     //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        // }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!binary_search(ps.begin(), ps.end(), rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                DrawLine(cp.first);\n                for(int i = 0; i < N; i++) {\n                    DrawPoint(ps[i]);\n                    P rp = refl(cp.first, ps[i]);\n                    assert(s.count(rp));\n                    cout << ps[i] << \"<->\" << rp << \"(\" << s[rp] << \")\" << endl;\n                    assert(s[ refl(cp.first, rp) ] == i);\n                }\n                break;\n            }\n            */\n        }\n\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <cmath>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nnamespace libcomp {\nnamespace geometry {\n\nconst double EPS = 1e-9;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\n\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\ndouble norm(const Point &p){ return p.x * p.x + p.y * p.y; }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Line {\n\tPoint a;\n\tPoint b;\n\n\texplicit Line(const Point &a = Point(), const Point &b = Point()) :\n\t\ta(a), b(b)\n\t{ }\n\n\tstatic Line invalid(){\n\t\tPoint inv = Point::invalid();\n\t\treturn Line(inv, inv);\n\t}\n\tbool is_valid() const { return a.is_valid() && b.is_valid(); }\n\n\tbool operator<(const Line &l) const {\n\t\treturn (a == l.a) ? (b < l.b) : (a < l.a);\n\t}\n};\n\nbool tolerant_eq(const Line &a, const Line &b){\n\treturn ::std::abs(cross(a.b - a.a, b.a - a.a)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p - l.a, l.b - l.a) / norm(l.b - l.a);\n\treturn l.a + t * (l.b - l.a);\n}\n\nPoint reflection(const Line &l, const Point &p){\n\treturn p + 2.0 * (projection(l, p) - p);\n}\n\n}\n}\n\nusing namespace libcomp::geometry;\ntypedef pair<int, int> pii;\n\ninline ll pow2(ll x){ return x * x; }\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<Point> p(n);\n\tset<pii> ps;\n\tint xsum = 0, ysum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t\tps.insert(pii(x, y));\n\t\txsum += x;\n\t\tysum += y;\n\t}\n\tconst Point c(\n\t\tstatic_cast<double>(xsum) / n, static_cast<double>(ysum) / n);\n\tbool answer = false;\n\tif(n % 2 == 0){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(tolerant_eq(p[i], c)){ continue; }\n\t\t\tconst Line l(p[i], c);\n\t\t\tbool accept = true;\n\t\t\tfor(int j = 0; accept && j < n; ++j){\n\t\t\t\tconst Point a = p[j];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; !answer && i < 3; ++i){\n\t\tfor(int j = i + 1; !answer && j < n; ++j){\n\t\t\tconst Point q = projection(Line(p[i], p[j]), c);\n\t\t\tif(tolerant_eq(q, c)){ continue; }\n\t\t\tconst Line l((p[i] + p[j]) / 2, c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int k = 0; accept && k < n; ++k){\n\t\t\t\tconst Point a = p[k];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count > n % 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (answer ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\n//AOJ2159\nint n;\nint x[1000], y[1000];\nset<PII> spii;\n\nint gcd(int m, int n){\n\tif(m==0||n==0)return 0;\n\tint t;\n\twhile(m){\n\t\tt = m;\n\t\tm = n % m;\n\t\tn = t;\n\t}\n\treturn n;\n}\n\nbool mirror(LL a, LL b, LL c, LL xa, LL ya, LL &xb, LL &yb){\n\tLL xx=-2*a*c-(a*a-b*b)*xa-2*a*b*ya;\n\tLL yy=-2*b*c+(a*a-b*b)*ya-2*a*b*xa;\n\tLL rr=a*a+b*b;\n\tif(xx%rr != 0 || yy%rr!= 0)return false;\n\txb = xx/rr;\n\tyb = yy/rr;\n\treturn true;\n}\n\nint solve1(int p, int q){\n\tint ret = 0;\n\tint ret2 = 0;\n\tLL a=2*(x[q]-x[p]);\n\tLL b=2*(y[q]-y[p]);\n\tLL c=x[p]*x[p]-x[q]*x[q]+y[p]*y[p]-y[q]*y[q];\n\tLL tx, ty;\n\tREP(i,n){\n\t\tif(i==p||i==q)continue;\n\t\tif(mirror(a,b,c,x[i],y[i],tx,ty)==false)return 100;\n\t\tif(!EXIST(spii, MP(tx,ty)))return 100;\n\t\tif(tx==x[i] && ty==y[i])ret++;\n\t\tif(x[p]+x[q] == 2*tx && y[p]+y[q] == 2*ty)ret2++;\n\t}\n\tif(ret2 == n/2)return 100;\n\treturn ret;\n}\n\nint solve2(int p, int q){\n\tint ret = 0;\n\tLL a=(y[q]-y[p]);\n\tLL b=-(x[q]-x[p]);\n\tLL c=y[p]*x[q]-y[q]*x[p];\n\tLL tx, ty;\n\tREP(i,n){\n\t\tif(i==p||i==q)continue;\n\t\tif(mirror(a,b,c,x[i],y[i],tx,ty)==false)return 100;\n\t\tif(!EXIST(spii, MP(tx,ty)))return 100;\n\t\tif(tx==x[i] && ty==y[i])return 100;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n;\n\tREP(i,n){\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tspii.insert(MP(x[i], y[i]));\n\t}\n\n\tREP(i,n){\n\t\tFOR(j,i+1,n){\n\t\t\tif(solve1(i,j)==n%2){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(solve2(i,j)==0){\n\t\t\t\tcout << \"YES\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NO\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2;\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nLine getPerpendicularBisector(Point a,Point b){\n  Point m=a+(b-a)/2;\n  Vector v1=(a-m),v2=(b-m);\n  swap(v1.x,v1.y);\n  v1.y=-1*v1.y;\n  swap(v2.x,v2.y);\n  v2.y=-1*v2.y;\n  return Line(m+v1,m+v2);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint n;\nvector<Point> vp;\nPolygon p;\nset<Point> s;\n\nbool check(Line L){\n  int count=0;\n  for(int i=0;i<vp.size();i++){\n    int c=ccw(L.p1,L.p2,vp[i]);\n    if(c==2 || c==-2 || c==0){\n      count++;\n      if(count==3)return false;\n    }\n    else if(s.find(reflect(L,vp[i]))==s.end())return false;\n  }\n  return true;\n}\n\nint main()\n{\n  int x,y;\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    vp.push_back(Point(x,y));\n    s.insert(Point(x,y));\n  }\n  p=convex_hull(vp);\n\n  string ans=\"No\";\n  int s=p.size();\n\n  if(p.size()<=vp.size()){\n    for(int i=0;i<s;i++){\n      Line L = getPerpendicularBisector(p[i],p[(i+1)%s]);\n      if(check(L))ans=\"Yes\";\n      if(s%2==0){\n\tL=Line(p[i],p[(i+s/2)%s]);\n\tif(check(L))ans=\"Yes\";\n      }\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\n\n/* ??????????????¬ */\n\n#include <complex>\n\ntypedef long double ld;\ntypedef complex<ld> Point;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n#define ALL(x) (x).begin(),(x).end()\n\nconst ld eps = 1e-9, pi = acos(-1.0);\nconst ld dtop = pi / 180.;\nconst ld ptod = 1. / dtop;\n\n// ????????????????????????\nbool eq(const ld a, const ld b) {\n\treturn (abs(a - b) < eps);\n}\nnamespace std {\n\tbool operator<(const Point &lhs, const Point &rhs) {\n\t\tif (lhs.real() < rhs.real() - eps) return true;\n\t\tif (lhs.real() > rhs.real() + eps) return false;\n\t\tif (lhs.imag() < rhs.imag() - eps) return true;\n\t\tif (lhs.imag() > rhs.imag() + eps) return false;\n\t\treturn false;\n\t}\n\tbool operator==(const Point &lhs, const Point &rhs) {\n\t\treturn eq(lhs.imag() , rhs.imag())&&eq(lhs.real(),rhs.real());\n\t}\n}\n\n// ????????\\???\nPoint input_point() {\n\tld x, y;\n\tcin >> x >> y;\n\treturn Point(x, y);\n}\n\n\n// ??????\nld dot(const Point& a, const Point& b) {\n\treturn real(conj(a) * b);\n}\n\n// ??????\nld cross(const Point& a, const Point& b) {\n\treturn imag(conj(a) * b);\n}\n\n// ??´????????????\nclass Line {\npublic:\n\tPoint a, b;\n\tLine() : a(Point(0, 0)), b(Point(0, 0)) {}\n\tLine(Point a, Point b) : a(a), b(b) {}\n\tPoint operator[](const int _num)const {\n\t\tif (_num == 0)return a;\n\t\telse if (_num == 1)return b;\n\t\telse {\n\t\t\tassert(false);\n\t\t\treturn Point();\n\t\t}\n\t}\n};\n\n// ????????????\nclass Circle {\npublic:\n\tPoint p;\n\tld r;\n\tCircle() : p(Point(0, 0)), r(0) {}\n\tCircle(Point p, ld r) : p(p), r(r) {}\n};\n\n// CCW\nint ccw(const Point& a, const Point &b, const Point &c) {\n\tconst Point nb(b - a);\n\tconst Point nc(c - a);\n\tif (cross(nb, nc) > eps) return 1;   // a,b,c??????????¨???¨?????????????????¶\n\tif (cross(nb, nc) < -eps) return -1; // a,b,c???????¨???¨?????????????????¶\n\tif (dot(nb, nc) < 0) return 2;       // c,a,b???????????´???????????¶\n\tif (norm(nb) < norm(nc)) return -2;  // a,b,c???????????´???????????¶\n\treturn 0;                          // a,c,b???????????´???????????¶\n}\n\n\n/* ???????????? */\n\n// ??´?????¨??´??????????????????\nbool isis_ll(const Line& l, const Line& m) {\n\treturn !eq(cross(l.b - l.a, m.b - m.a), 0);\n}\n\n// ??´?????¨?????????????????????\nbool isis_ls(const Line& l, const Line& s) {\n\treturn isis_ll(l, s) &&\n\t\t(cross(l.b - l.a, s.a - l.a) * cross(l.b - l.a, s.b - l.a) < eps);\n}\n\n// ????????¨?????????????????????\nbool isis_ss(const Line& s, const Line& t) {\n\treturn ccw(s.a, s.b, t.a) * ccw(s.a, s.b, t.b) <= 0 &&\n\t\tccw(t.a, t.b, s.a) * ccw(t.a, t.b, s.b) <= 0;\n}\n\n// ????????´????????????\nbool isis_lp(const Line& l, const Point& p) {\n\treturn (abs(cross(l.b - p, l.a - p)) < eps);\n}\n\n// ?????????????????????\nbool isis_sp(const Line& s, const Point& p) {\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a) < eps);\n}\n\n// ??????????¶?\nPoint proj(const Line &l, const Point& p) {\n\tld t = dot(p - l.a, l.a - l.b) / norm(l.a - l.b);\n\treturn l.a + t * (l.a - l.b);\n}\n\n// ??´?????¨??´????????????\nPoint is_ll(const Line &s, const Line& t) {\n\tPoint sv = s.b - s.a, tv = t.b - t.a;\n\tassert(cross(sv, tv) != 0);\n\treturn s.a + sv * cross(tv, t.a - s.a) / cross(tv, sv);\n}\n// ????????¨???????????????\n//???????????£????????¨???????????¨assert(false)\nPoint is_ss(const Line &s, const Line& t) {\n\tif (isis_ss(s, t)) {\n\t\tfor (int k = 0; k < 2; ++k) {\n\t\t\tfor (int l = 0; l < 2; ++l) {\n\t\t\t\tif (s[k] == t[l])return s[k];\n\t\t\t}\n\t\t}\n\t\treturn is_ll(s, t);\n\t}\n\telse {\n\t\treturn Point(0, 0);\n\t}\n}\n// ??´?????¨???????????¢\nld dist_lp(const Line& l, const Point& p) {\n\treturn abs(p - proj(l, p));\n}\n\n// ??´?????¨??´???????????¢\nld dist_ll(const Line& l, const Line& m) {\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\n// ??´?????¨??????????????¢\nld dist_ls(const Line& l, const Line& s) {\n\treturn isis_ls(l, s) ? 0 : min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\n// ????????¨???????????¢\nld dist_sp(const Line& s, const Point& p) {\n\tPoint r = proj(s, p);\n\treturn isis_sp(s, r) ? abs(r - p) : min(abs(s.a - p), abs(s.b - p));\n}\n\n// ????????¨??????????????¢\nld dist_ss(const Line& s, const Line& t) {\n\tif (isis_ss(s, t)) return 0;\n\treturn min({ dist_sp(s, t.a), dist_sp(s, t.b), dist_sp(t, s.a), dist_sp(t, s.b) });\n}\n\n\n//??´?????¨??´?????????????????????????????????\nLine bisection(const Line &s, const Line &t) {\n\tconst Point laglanju(is_ll(s, t));\n\tconst Point avec = !(abs(laglanju - s[0])<eps) ? s[0] - laglanju : s[1] - laglanju;\n\tconst Point bvec = !(abs(laglanju - t[0])<eps) ? t[0] - laglanju : t[1] - laglanju;\n\n\treturn Line(laglanju, laglanju + (abs(bvec)*avec + abs(avec)*bvec) / (abs(avec) + abs(bvec)));\n}\n\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nPoint  inner_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i <static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (vertics[0] == vertics[1] || vertics[1] == vertics[2] || vertics[2] == vertics[0])return vertics[0];\n\tLine bi1(bisection(Line(vertics[0], vertics[1]), Line(vertics[0], vertics[2])));\n\tLine bi2(bisection(Line(vertics[1], vertics[2]), Line(vertics[1], vertics[0])));\n\tif (bi1[0] == bi2[0])return bi1[0];\n\telse {\n\t\treturn is_ll(bi1, bi2);\n\t}\n}\n\n//???????????´?????????????????????\n//???????????´??????????????§???????????¨????¢?????????¨?????????\nvector<Point>  ex_center(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tfor (int i = 0; i < static_cast<int>(ls.size()); ++i) {\n\t\tvertics.push_back(is_ll(ls[i], ls[(i + 1) % 3]));\n\t}\n\tif (abs(vertics[0] - vertics[1])<eps || abs(vertics[1] - vertics[2])<eps || (abs(vertics[2] - vertics[0])<eps))return vector<Point>();\n\tvector<Point>ecs;\n\tfor (int i = 0; i < 3; ++i) {\n\t\tLine bi1(bisection(Line(vertics[i], vertics[i] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[i], vertics[(i + 1) % 3])));\n\t\tLine bi2(bisection(Line(vertics[(i + 1) % 3], vertics[(i + 1) % 3] * 2.0l - vertics[(i + 2) % 3]), Line(vertics[(i + 1) % 3], vertics[i])));\n\t\tecs.push_back(is_ll(bi1, bi2));\n\t}\n\treturn ecs;\n}\n\n\n//a,b:??????\n//c:????????§??????\n//???????????´?????????????????¢?????????????±??????????\nvector<Point>  same_dis(const vector<Line>&ls) {\n\tvector<Point>vertics;\n\tvertics.push_back(is_ll(ls[0], ls[2]));\n\tvertics.push_back(is_ll(ls[1], ls[2]));\n\n\tif (abs(vertics[0] - vertics[1]) < eps)return vector<Point>{vertics[0]};\n\tLine bis(bisection(ls[0], ls[1]));\n\tvector<Point>ecs;\n\n\tLine abi(bisection(Line(vertics[0], vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, abi));\n\n\n\tLine bbi(bisection(Line(vertics[0], 2.l*vertics[0] - vertics[1]), ls[0]));\n\tecs.push_back(is_ll(bis, bbi));\n\n\treturn ecs;\n}\n/* ??? */\n\n// ?????¨????????????\nvector<Point> is_cc(const Circle& c1, const Circle& c2) {\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d * d + c1.r * c1.r - c2.r * c2.r) / (2 * d);\n\tld dfr = c1.r * c1.r - rc * rc;\n\tif (abs(dfr) < eps) dfr = 0.0;\n\telse if (dfr < 0.0) return res; // no intersection\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff * Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff * Point(rc, -rs));\n\treturn res;\n}\n\n// ?????¨??´????????????\nvector<Point> is_lc(const Circle& c, const Line& l) {\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d < c.r + eps) {\n\t\tld len = (d > c.r) ? 0.0 : sqrt(c.r * c.r - d * d); //safety;\n\t\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\t\tres.push_back(proj(l, c.p) + len * nor);\n\t\tres.push_back(proj(l, c.p) - len * nor);\n\t}\n\treturn res;\n}\n\n// ?????¨??????????????¢\nvector<Point> is_sc(const Circle& c, const Line& l) {\n\tvector<Point> v = is_lc(c, l), res;\n\tfor (Point p : v)\n\t\tif (isis_sp(l, p)) res.push_back(p);\n\treturn res;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cp(const Circle& c, const Point& p) {\n\tvector<Line> ret;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return ret; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tret.push_back(Line(p, p + v1));\n\tif (l < eps) return ret;\n\tret.push_back(Line(p, p + v2));\n\treturn ret;\n}\n\n// ?????¨????????\\???\nvector<Line> tangent_cc(const Circle& c1, const Circle& c2) {\n\tvector<Line> ret;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -eps) {\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tret = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > eps) {\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nret = tangent_cp(c1, out);\n\t\tret.insert(ret.end(), ALL(nret));\n\t}\n\telse {\n\t\tPoint v = c2.p - c1.p;\n\t\tv /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tret.push_back(Line(q1, q1 + v));\n\t\tret.push_back(Line(q2, q2 + v));\n\t}\n\treturn ret;\n}\n\n\n/* ????§???¢ */\n\ntypedef vector<Point> Polygon;\n\n// ??¢???\nld area(const Polygon &p) {\n\tld res = 0;\n\tint n = p.size();\n\tREP(j, n) res += cross(p[j], p[(j + 1) % n]);\n\treturn res / 2;\n}\n\n// ????§???¢????????¢??????\nbool is_counter_clockwise(const Polygon &poly) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n], c = poly[(i + 2) % n];\n\t\tangle += arg((c - b) / (b - a));\n\t}\n\treturn angle > eps;\n}\n\n// ??????????????????\n//  0 => out\n//  1 => on\n//  2 => in\nint is_in_polygon(const Polygon &poly, const  Point& p) {\n\tld angle = 0;\n\tint n = poly.size();\n\tREP(i, n) {\n\t\tPoint a = poly[i], b = poly[(i + 1) % n];\n\t\tif (isis_sp(Line(a, b), p)) return 1;\n\t\tangle += arg((b - p) / (a - p));\n\t}\n\treturn eq(angle, 0) ? 0 : 2;\n}\n//??????????????????2?????????\nenum { OUT, ON, IN };\nint convex_contains(const Polygon &P, const Point &p) {\n\tconst int n = P.size();\n\tPoint g = (P[0] + P[n / 3] + P[2 * n / 3]) / 3.0l; // inner-point\n\tint a = 0, b = n;\n\twhile (a + 1 < b) { // invariant: c is in fan g-P[a]-P[b]\n\t\tint c = (a + b) / 2;\n\t\tif (cross(P[a] - g, P[c] - g) > 0) { // angle < 180 deg\n\t\t\tif (cross(P[a] - g, p - g) > 0 && cross(P[c] - g, p - g) < 0) b = c;\n\t\t\telse                                                  a = c;\n\t\t}\n\t\telse {\n\t\t\tif (cross(P[a] - g, p - g) < 0 && cross(P[c] - g, p - g) > 0) a = c;\n\t\t\telse                                                  b = c;\n\t\t}\n\t}\n\tb %= n;\n\tif (cross(P[a] - p, P[b] - p) < 0) return 0;\n\tif (cross(P[a] - p, P[b] - p) > 0) return 2;\n\treturn 1;\n}\n\n// ??????\n// ???????????????????????¨????????????????????§??¨???\nPolygon convex_hull(vector<Point> ps) {\n\tint n = ps.size();\n\tint k = 0;\n\tsort(ps.begin(), ps.end());\n\tPolygon ch(2 * n);\n\tfor (int i = 0; i < n; ch[k++] = ps[i++])\n\t\twhile (k >= 2 && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tfor (int i = n - 2, t = k + 1; i >= 0; ch[k++] = ps[i--])\n\t\twhile (k >= t && ccw(ch[k - 2], ch[k - 1], ps[i]) <= 0) --k;\n\tch.resize(k - 1);\n\treturn ch;\n}\n\n\n\n// ????????????\nvector<Polygon> convex_cut(const Polygon &ps, const Line& l) {\n\tint n = ps.size();\n\tPolygon Q;\n\tPolygon R;\n\tREP(i, n) {\n\t\tPoint A = ps[i], B = ps[(i + 1) % n];\n\t\tLine m = Line(A, B);\n\t\tif (ccw(l.a, l.b, A) != -1) Q.push_back(A);\n\t\tif (ccw(l.a, l.b, A) != 1) R.push_back(A);\n\t\tif (ccw(l.a, l.b, A) * ccw(l.a, l.b, B) < 0 && isis_ll(l, m)) {\n\t\t\tQ.push_back(is_ll(l, m));\n\t\t\tR.push_back(is_ll(l, m));\n\t\t}\n\t}\n\tconst vector<Polygon>polys{ Q,R };\n\treturn polys;\n}\n\n\n/* ??¢??¬??????????????? */\nvoid add_point(vector<Point> &ps, const Point p) {\n\tfor (Point q : ps) if (abs(q - p) < eps) return;\n\tps.push_back(p);\n}\n\ntypedef int Weight;\n\nstruct Edge { int from, to; Weight weight; };\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid add_edge(Graph &g, const int from, const int to, const Weight weight) {\n\tg[from].push_back(Edge{ from, to, weight });\n}\n\nGraph segment_arrangement(const vector<Line> &s, const vector<Point> &p) {\n\tint n = p.size(), m = s.size();\n\tGraph g(n);\n\tREP(i, m) {\n\t\tvector<pair<ld, int>> vec;\n\t\tREP(j, n) if (isis_sp(s[i], p[j]))\n\t\t\tvec.emplace_back(abs(s[i].a - p[j]), j);\n\t\tsort(ALL(vec));\n\t\tREP(j, vec.size() - 1) {\n\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n\t\t\tadd_edge(g, from, to, static_cast<Weight>(abs(p[from] - p[to])));\n\t\t}\n\t}\n\treturn g;\n}\nGraph sennbunn_arrangement(const vector<Line>&s) {\n\tvector<Point>crss;\n\tfor (int i = 0; i < static_cast<int>(s.size()); ++i) {\n\t\tfor (int j = i + 1; j < static_cast<int>(s.size()); ++j) {\n\t\t\tif (isis_ss(s[i], s[j])) {\n\t\t\t\tcrss.push_back(is_ll(s[i], s[j]));\n\t\t\t}\n\t\t}\n\t}\n\tfor (int i = 0; i <static_cast<int>(s.size()); ++i) {\n\t\tcrss.push_back(s[i][0]);\n\t\tcrss.push_back(s[i][1]);\n\t}\n\treturn segment_arrangement(s, crss);\n}\n\n//Graph circle_arrangement(const vector<Circle> &c, const vector<Point> &p) {\n//\tint n = p.size(), m = c.size();\n//\tGraph g(n);\n//\tREP(i, m) {\n//\t\tvector<pair<ld, int>> vec;\n//\t\tREP(j, n) if (abs(abs(c[i].p - p[j]) - c[i].r) < eps)\n//\t\t\tvec.emplace_back(arg(c[i].p - p[j]), j);\n//\t\tsort(ALL(vec));\n//\t\tREP(j, vec.size() - 1) {\n//\t\t\tint from = vec[j].second, to = vec[j + 1].second;\n//\t\t\tld angle = vec[j + 1].first - vec[j].first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t\tif (vec.size() >= 2) {\n//\t\t\tint from = vec.back().second, to = vec.front().first;\n//\t\t\tld angle = vec.front().first - vec.back().first;\n//\t\t\tadd_edge(g, from, to, static_cast<Weight>(angle * c[i].r));\n//\t\t}\n//\t}\n//\treturn g;\n//}\n\n\n/* ????????°?????? */\n\n// ?????????????????¢?????¢??¬??????????????????????????????????????°???????????????\n// ?????´?????????????¨?????????§????????´????????????????¨?????????§???????????????\n// ?????° polygon ??????vector<int> ??§??¨?????????????§???¢???????????§?????????\n// vector<int> ??§??¨????????? ????§???¢???i???????????????????????????????????????p????????????????????§?????????\nvector<vector<int>> polygon;\nvector<int> seg2p[1024][1024];\n\n//Graph dual_graph(const vector<Line> &s, const vector<Point> &p) {\n//\tint N = p.size();\n//\tpolygon.clear();\n//\tREP(i, 1024) REP(j, 1024) seg2p[i][j].clear();\n//\tvector<vector<tuple<ld, int, bool>>> tup(N);\n//\tREP(i, s.size()) {\n//\t\tint a = -1, b = -1;\n//\t\tREP(j, N) if (abs(s[i].a - p[j]) < eps) a = j;\n//\t\tREP(j, N) if (abs(s[i].b - p[j]) < eps) b = j;\n//\t\tassert(a >= 0 && b >= 0);\n//\t\ttup[a].emplace_back(arg(s[i].b - s[i].a), b, false);\n//\t\ttup[b].emplace_back(arg(s[i].a - s[i].b), a, false);\n//\t}\n//\tREP(i, N) sort(ALL(tup[i]));\n//\tREP(i, N) {\n//\t\tREP(j, tup[i].size()) {\n//\t\t\tld angle; int pos = j, from = i, to; bool flag;\n//\t\t\ttie(angle, to, flag) = tup[i][j];\n//\t\t\tif (flag) continue;\n//\t\t\tvector<int> ps;\n//\t\t\twhile (!flag) {\n//\t\t\t\tps.push_back(from);\n//\t\t\t\tget<2>(tup[from][pos]) = true;\n//\t\t\t\tseg2p[from][to].push_back(polygon.size());\n//\t\t\t\tseg2p[to][from].push_back(polygon.size());\n//\t\t\t\tangle += pi + eps;\n//\t\t\t\tif (angle > pi) angle -= 2 * pi;\n//\t\t\t\tauto it = lower_bound(ALL(tup[to]), make_tuple(angle, 0, false));\n//\t\t\t\tif (it == tup[to].end()) it = tup[to].begin();\n//\t\t\t\tfrom = to; tie(angle, to, flag) = *it;\n//\t\t\t\tpos = it - tup[from].begin();\n//\t\t\t}\n//\t\t\tpolygon.push_back(ps);\n//\t\t}\n//\t}\n//\tGraph g(polygon.size());\n//\tREP(i, N) REP(j, i) {\n//\t\tif (seg2p[i][j].size() == 2) {\n//\t\t\tint from = seg2p[i][j][0], to = seg2p[i][j][1];\n//\t\t\tg[from].push_back(Edge{ from, to });\n//\t\t\tg[to].push_back(Edge{ to, from });\n//\t\t}\n//\t}\n//\treturn g;\n//}\n//\n//6\n//0 0\n//3 4\n//-3 -4\n//6 8\n//4 -3\n//7 1\n\n/* ????????\\??¢????????¶ */\nconst ld zoom = 25;\nconst ld centerX = 6;\nconst ld centerY = 5;\n\nvoid change_color(const int r, const int g, const int b) {\n\tfprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\n\n\nint cordx(Point p) { return 400 + static_cast<int>(zoom * (p.real() - centerX)); }\nint cordy(Point p) { return 400 - static_cast<int>(zoom * (p.imag() - centerY)); }\n\n#define cord(p) cordx(p),cordy(p)\n\nvoid draw_point(const Point& p) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(p), 2);\n}\n\nvoid draw_segment(const Line& l) {\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(l.a), cord(l.b));\n}\n\nvoid draw_line(const Line& l) {\n\tPoint v = l.b - l.a;\n\tLine m(l.a - v * Point(1e4, 0), l.b + v * Point(1e4, 0));\n\tfprintf(stderr, \"line(%d, %d, %d, %d)\\n\", cord(m.a), cord(m.b));\n}\n\nvoid draw_polygon(const Polygon &p) {\n\tint n = p.size();\n\tREP(i, n) draw_segment(Line(p[i], p[(i + 1) % n]));\n}\n\nvoid draw_circle(const Circle c) {\n\tfprintf(stderr, \"circle(%d, %d, %d)\\n\", cord(c.p), (int)(zoom * c.r));\n}\nint main() {\n\tint N; cin >> N;\n\tvector<Point>ps;\n\tld sumx=0, sumy=0;\n\tfor (int i = 0; i < N; ++i) {\n\t\tld x, y; cin >> x >> y;\n\t\tps.push_back(Point(x, y));\n\t\tsumx += x; sumy += y;\n\t}\n\tPoint centerp(sumx / N, sumy / N);\n\tfor (int i = 0; i < N; ++i) {\n\t\tif (centerp == ps[i]) {\n\t\t\tcout << \"No\" << endl;\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tsort(ps.begin(), ps.end(), [=](const Point &l, const Point &r) {\n\t\tPoint aap(atan(l - centerp));\n\t\tPoint ap(atan(r - centerp));\n\t\tld l_val = (l - centerp).imag()/ (l - centerp).real();\n\t\tld r_val = (r - centerp).imag() / (r - centerp).real();\n\t\tif (l.real() < centerp.real() && centerp.real() < r.real())return true;\n\t\tif (r.real() < centerp.real() && centerp.real() < l.real())return false;\n\t\treturn l_val < r_val;\n\t});\n\t{\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tLine s_line = Line(centerp, ps[i]);\n\t\t\tvector<set<Point>>ismirrors(3);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tint aa = i==j?0:ccw(ps[i], centerp, ps[j]);\n\t\t\t\tif (aa == 2 || aa == -2)aa = 0;\n\t\t\t\taa++;\n\t\t\t\tismirrors[aa].emplace(ps[j]);\n\t\t\t}\n\t\t\tint left_num = ismirrors[0].size();\n\t\t\tint right_num = ismirrors[2].size();\n\t\t\tint center_num = N - left_num - right_num;\n\t\t\tif ((left_num != right_num) || (center_num>left_num + right_num) || (center_num>2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (auto lp : ismirrors[0]) {\n\t\t\t\t\tPoint cp = proj(s_line, lp);\n\t\t\t\t\tPoint revp = cp * 2.l - lp;\n\t\t\t\t\tauto it = ismirrors[2].find(revp);\n\t\t\t\t\tif (it != ismirrors[2].end()) {\n\t\t\t\t\t\tismirrors[2].erase(it);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tLine s_line = Line(centerp, (ps[i]+ps[(i+1)%N])/2.l);\n\t\t\tvector<set<Point>>ismirrors(3);\n\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\tint aa = ccw((ps[i] + ps[(i + 1) % N]) / 2.l, centerp, ps[j]);\n\t\t\t\tif (aa == 2 || aa == -2)aa = 0;\n\t\t\t\taa++;\n\t\t\t\tismirrors[aa].emplace(ps[j]);\n\t\t\t}\n\t\t\tint left_num = ismirrors[0].size();\n\t\t\tint right_num = ismirrors[2].size();\n\t\t\tint center_num = N - left_num - right_num;\n\t\t\tif ((left_num != right_num) || (center_num>left_num + right_num) || (center_num>2)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbool ok = true;\n\t\t\t\tfor (auto lp : ismirrors[0]) {\n\t\t\t\t\tPoint cp = proj(s_line, lp);\n\t\t\t\t\tPoint revp = cp * 2.l - lp;\n\t\t\t\t\tauto it = ismirrors[2].find(revp);\n\t\t\t\t\tif (it != ismirrors[2].end()) {\n\t\t\t\t\t\tismirrors[2].erase(it);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tok = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (ok) {\n\t\t\t\t\tcout << \"Yes\" << endl;\n\t\t\t\t\treturn 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"No\" << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <random>\nusing namespace std;\nusing ll = long long;\nstruct P {\n    ll x;\n    ll y;\n    bool operator<(const P& p) const\n    {\n        return (x != p.x) ? x < p.x : y < p.y;\n    }\n};\nvector<P> pos;\nint N;\n\nbool ok(const int i, const int j)\n{\n    const ll x = (pos[i].x + pos[j].x) / 2;\n    const ll y = (pos[i].y + pos[j].y) / 2;\n    const ll dx = pos[j].x - x;\n    const ll dy = pos[j].y - y;\n    set<P> p;\n    int cnt = 0;\n    ll h = 0;\n    for (int k = 0; k < N; k++) {\n        if (k == i or k == j) {\n            continue;\n        }\n        const ll X = pos[k].x - x;\n        const ll Y = pos[k].y - y;\n        const ll S = X * dx + Y * dy;\n        const ll T = -X * dy + Y * dx;\n        h = max(h, abs(T));\n        if (S == 0) {\n            cnt++;\n        }\n        p.insert(P{S, T});\n    }\n    if (cnt >= 3 or h == 0) {\n        return false;\n    }\n    for (const auto& pp : p) {\n        if (p.find(P{-pp.x, pp.y}) == p.end()) {\n            return false;\n        }\n    }\n    return true;\n}\n\nint main()\n{\n    cin >> N;\n    for (int i = 0; i < N; i++) {\n        ll x, y;\n        cin >> x >> y;\n        pos.push_back(P{2 * x, 2 * y});\n    }\n    mt19937 mt{random_device{}()};\n    uniform_int_distribution<int> dist{0, N - 1};\n    for (int i = 0; i < 2 * N; i++) {\n        int u = 0;\n        int v = 0;\n        while (u == v) {\n            u = dist(mt);\n            v = dist(mt);\n        }\n        if (ok(u, v)) {\n            cout << \"Yes\" << endl;\n            return 0;\n        }\n    }\n    cout << \"No\" << endl;\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<set>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nstruct Point {\n\tlong long x, y;\n\n\tPoint (long long x = 0, long long y = 0) : x(x), y(y) {}\n\n\tvoid in() {\n\t\tscanf(\"%lld%lld\", &x, &y);\n\t\tx *= 2, y *= 2;\n\t}\n\n\tPoint operator + (const Point &a) const {\n\t\treturn Point(x + a.x, y + a.y);\n\t}\n\n\tPoint operator - (const Point &a) const {\n\t\treturn Point(x - a.x, y - a.y);\n\t}\n\n\tPoint operator * (const long long &k) const {\n\t\treturn Point(x * k, y * k);\n\t}\n\n\tPoint operator / (const long long &k) const {\n\t\treturn Point(x / k, y / k);\n\t}\n\n\tbool operator < (const Point &a) const {\n\t\treturn x < a.x || (x == a.x && y < a.y);\n\t}\n\n\tlong long len2() const {\n\t\treturn x * x + y * y;\n\t}\n\n\tPoint turn90() const {\n\t\treturn Point(-y, x);\n\t}\n};\n\nlong long dot(const Point &a, const Point &b) {\n\treturn a.x * b.x + a.y * b.y;\n}\n\nlong long det(const Point &a, const Point &b) {\n\treturn a.x * b.y - a.y * b.x;\n}\n\nstruct Line {\n\tPoint a, b;\n\n\tLine(Point a, Point b) : a(a), b(b) {}\n};\n\nbool project(const Point &p, const Line &l, Point &q) {\n\tlong long dt = dot(p - l.a, l.b - l.a);\n\tPoint pp = (l.b - l.a) * dt;\n\tlong long d = (l.b - l.a).len2();\n\tif (pp.x % d != 0 || pp.y % d != 0) {\n\t\treturn false;\n\t}\n\tq = l.a + pp / d;\n\treturn true;\n}\n\nbool reflect(const Line &l, const Point &p, Point &q) {\n\tif (!project(p, l, q)) {\n\t\treturn false;\n\t}\n\tq = q + q - p;\n\treturn true;\n}\n\nbool onLine(const Line &l, const Point &p) {\n\treturn det(p - l.a, l.b - l.a) == 0;\n}\n\nconst int N = 1005;\n\nint n;\n\nset<Point> tr;\n\nPoint p[N];\n\nbool sameLine() {\n\tfor (int i = 2; i < n; ++i) {\n\t\tif (det(p[i] - p[0], p[1] - p[0]) != 0) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\nconst long long INF = 1ll << 60;\n\nbool check(const Line &l) {\n\tlong long mind = INF, maxd = -INF;\n\tfor (int i = 0; i < n; ++i) {\n\t\tlong long dt = dot(p[i] - l.a, l.b - l.a);\n\t\tmind = min(mind, dt);\n\t\tmaxd = max(maxd, dt);\n\t}\n\tfor (int i = 0; i < n; ++i) {\n\t\tif (onLine(l, p[i])) {\n\t\t\tlong long dt = dot(p[i] - l.a, l.b - l.a);\n\t\t\tif (dt != mind && dt != maxd) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else {\n\t\t\tPoint q;\n\t\t\tif (!reflect(l, p[i], q)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (!tr.count(q)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\treturn true;\n}\n\nint main() {\n\tscanf(\"%d\", &n);\n\tfor (int i = 0; i < n; ++i) {\n\t\tp[i].in();\n\t\ttr.insert(p[i]);\n\t}\n\tif (sameLine()) {\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tfor (int i = 1; i < n; ++i) {\n\t\tPoint m = (p[0] + p[i]) / 2,\n\t\t\t  mm = m + (p[i] - p[0]).turn90();\n\t\tans = ans || check(Line(m, mm));\n\t}\n\tfor (int i = 2; i < n; ++i) {\n\t\tPoint m = (p[1] + p[i]) / 2,\n\t\t\t  mm = m + (p[i] - p[1]).turn90();\n\t\tans = ans || check(Line(m, mm));\n\t}\n\tans = ans || check(Line(p[0], p[1]));\n\tputs(ans ? \"Yes\" : \"No\");\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define f first\n#define s second\n#define mp make_pair\n#define pi M_PI\n#define inf 1<<30\n#define eps (1e-11)\n#define equals(a,b) (fabs((a)-(b))<eps)\nusing namespace std;\n\nclass Point{\npublic:\n  double x,y;\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator+(Point p){ return Point(x+p.x,y+p.y);}\n  Point operator-(Point p){ return Point(x-p.x,y-p.y);}\n  Point operator*(double k){ return Point(x*k,y*k);}\n  Point operator/(double k){ return Point(x/k,y/k);}\n  bool operator<(Point p)const{ return (x!=p.x ? x<p.x : y<p.y);}\n  bool operator==(Point p)const{ return fabs(x-p.x)<eps && fabs(y-p.y)<eps;}\n\n  double abs(){ return sqrt(norm());}\n  double norm(){ return (x*x+y*y);}\n};\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nclass Segment{\npublic:\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()):p1(p1),p2(p2){}\n};\ntypedef Segment Line;\n\ndouble norm(Vector a){ return (a.x*a.x+a.y*a.y);}\ndouble abs(Vector a){ return sqrt(norm(a));}\ndouble dot(Vector a,Vector b){ return (a.x*b.x+a.y*b.y);}\ndouble cross(Vector a,Vector b){ return (a.x*b.y-a.y*b.x);}\n\nPoint project(Segment s,Point p){\n  Vector base=(s.p2-s.p1);\n  double r=(dot(p-s.p1,base)/base.norm());\n  return (s.p1+base*r);\n}\n\nPoint reflect(Segment s,Point p){\n  return p+(project(s,p)-p)*2;\n}\n\nstatic const int COUNTER_CLOCKWISE=1;\nstatic const int CLOCKWISE=-1;\nstatic const int ONLINE_BACK=2;\nstatic const int ONLINE_FRONT=-2;\nstatic const int ON_SEGMENT=0;\n\nint ccw(Point p0,Point p1,Point p2){\n  Vector a=p1-p0;\n  Vector b=p2-p0;\n  if(cross(a,b)>eps)return COUNTER_CLOCKWISE;\n  if(cross(a,b)<-eps)return CLOCKWISE;\n  if(dot(a,b)<-eps)return ONLINE_BACK;\n  if(a.norm()<b.norm())return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nLine getPerpendicularBisector(Point a,Point b){\n  Point m=a+(b-a)/2;\n  Vector v1=(a-m),v2=(b-m);\n  swap(v1.x,v1.y);\n  v1.y=-1*v1.y;\n  swap(v2.x,v2.y);\n  v2.y=-1*v2.y;\n  return Line(m+v1,m+v2);\n}\n\nPolygon convex_hull(Polygon s){\n  Polygon g;\n  int n=s.size();\n  if(n<3)return s;\n\n  sort(s.begin(),s.end());\n\n  for(int i=0;i<n;i++){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  for(int i=n-2;i>=0;i--){\n    for(int n=g.size();n>=2&&ccw(g[n-2],g[n-1],s[i])==1;n--){\n      g.pop_back();\n    }\n    g.push_back(s[i]);\n  }\n  reverse(g.begin(),g.end());\n  g.pop_back();\n  return g;\n}\n\nint n;\nvector<Point> vp;\nPolygon p;\nset<Point> s;\n\nbool check(Line L){\n  int count=0;\n  for(int i=0;i<vp.size();i++){\n    if(ccw(L.p1,L.p2,vp[i])==0){\n      count++;\n      if(count==3)return false;\n    }\n    else if(s.find(reflect(L,vp[i]))==s.end())return false;\n  }\n  return true;\n}\n\nint main()\n{\n  int x,y;\n\n  cin>>n;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    vp.push_back(Point(x,y));\n    s.insert(Point(x,y));\n  }\n  p=convex_hull(vp);\n\n  string ans=\"No\";\n  int s=p.size();\n\n  for(int i=0;i<s;i++){\n    Line L = getPerpendicularBisector(p[i],p[(i+1)%s]);\n    if(check(L))ans=\"Yes\";\n    if(s%2==0){\n      L=Line(p[i],p[(i+s/2)%s]);\n      if(L.p1==L.p2)continue;\n      if(check(L))ans=\"Yes\";\n    }\n  }\n  cout<<ans<<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\ntypedef pair<int,int> P;\n\nstruct Point{\n    Point(double arg_x,double arg_y){\n        x = arg_x;\n        y = arg_y;\n    }\n\n    Point(){\n        x = y = 0.0;\n    }\n\n    Point operator + (Point p){ return Point(x+p.x,y+p.y); }\n    Point operator - (Point p){ return Point(x-p.x,y-p.y);}\n    Point operator * (double a){ return Point(a*x,a*y); }\n    Point operator / (double a){ return Point(x/a,y/a); }\n\n    double abs(){ return sqrt(norm()); }\n    double norm(){ return x*x + y*y; }\n\n    bool operator<(const Point &p) const{\n        return x != p.x? x < p.x: y < p.y;\n    }\n\n    bool operator == (const Point &p) const{\n        return fabs(x-p.x) < EPS && fabs(y-p.y) < EPS;\n    }\n\n    double x,y;\n};\n\ntypedef Point Vector;\ntypedef vector<Point> Polygon;\n\nstruct Line{\n    Line(){\n\n    }\n    Line(Point a,Point b){\n        p[0] = a;\n        p[1] = b;\n    }\n    Point p[2];\n};\n\nset<P> SET;\nvector<Point> points;\n\ndouble calc_slope(Line A){\n\n    if(fabs(A.p[0].x-A.p[1].x) < EPS){\n\n        return DBL_MAX;\n\n    }else if(fabs(A.p[0].y-A.p[1].y) < EPS){\n\n        return 0;\n\n    }else{\n\n        return (A.p[0].y-A.p[1].y)/(A.p[0].x-A.p[1].x);\n    }\n}\n\ndouble norm(Vector a){\n    return a.x*a.x+a.y*a.y;\n}\n\ndouble abs(Vector a){\n    return sqrt(norm(a));\n}\n\ndouble cross(Vector a,Vector b){\n    return a.x*b.y-a.y*b.x;\n}\n\ndouble dot(Vector a,Vector b){\n    return a.x*b.x + a.y*b.y;\n}\n\nstatic const int COUNTER_CLOCKWISE = 1;\nstatic const int CLOCKWISE = -1;\nstatic const int ONLINE_BACK = 2;\nstatic const int ONLINE_FRONT = -1;\nstatic const int ON_SEGMENT = 0;\n\nint ccw(Point p0,Point p1,Point p2){\n\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n\n    if(cross(a,b) > EPS)return COUNTER_CLOCKWISE;\n    if(cross(a,b) < -EPS)return CLOCKWISE;\n    if(dot(a,b) < -EPS)return ONLINE_BACK;\n    if(a.norm() < b.norm())return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nPoint calc_Reflection_Point(double x1,double y1,double x2,double y2,double xp,double yp){\n\n    Point ret;\n\n    bool X_FLG = false,Y_FLG = false;\n    double slope;\n\n    if(y1 == y2){\n        X_FLG = true;\n    }else if(x1 == x2){\n        Y_FLG = true;\n    }else{\n        slope = (y2-y1)/(x2-x1);\n    }\n\n    if(X_FLG){\n        ret.x = xp,ret.y=y1;\n    }else if(Y_FLG){\n        ret.x = x1,ret.y = yp;\n    }else{\n        ret.x = (yp*(x2-x1)*(y2-y1)+xp*(x2-x1)*(x2-x1)-y1*(y2-y1)*(x2-x1)+x1*(y2-y1)*(y2-y1))/((y2-y1)*(y2-y1)+(x2-x1)*(x2-x1));\n        ret.y = ((x1-x2)*ret.x+yp*(y2-y1)+xp*(x2-x1))/(y2-y1);\n    }\n    ret.x = 2*ret.x-xp;\n    ret.y = 2*ret.y-yp;\n\n    return ret;\n}\n\nPoint calc_minus(Point a,Point b){\n    Point ret;\n\n    ret.x = a.x-b.x;\n    ret.y = a.y-b.y;\n\n    return ret;\n}\n\ndouble calc_len(Vector a){\n    return sqrt(a.x*a.x+a.y*a.y);\n}\n\n//★★線分ではなく直線と点の距離★★\ndouble getDistanceLP(Line l,Point p){\n    return fabs(cross(calc_minus(l.p[1],l.p[0]),calc_minus(p,l.p[0]))/calc_len(calc_minus(l.p[1],l.p[0])));\n}\n\nPoint calc_Reflection_Point(Line line,Point point){\n\n    if(getDistanceLP(line,point) < EPS){\n\n        return point;\n    }\n\n    return calc_Reflection_Point(line.p[0].x,line.p[0].y,line.p[1].x,line.p[1].y,point.x,point.y);\n}\n\nPolygon ConvexHull_ALL(Polygon polygon) {\n\n    int N = polygon.size();\n\n    Polygon ret(2*N);\n    sort(polygon.begin(),polygon.end());\n\n    int a = 0;\n    for (int i = 0; i < N; ++i) {\n        if (a >= 2) {\n            while (cross(ret[a-1]-ret[a-2],polygon[i]-ret[a-2]) < -EPS){\n                a--;\n                if(a < 2){\n                    break;\n                }\n            }\n        }\n        ret[a] = polygon[i];\n        a++;\n    }\n\n    int b = a+1;\n    for (int i = N-2; i >= 0; --i) {\n        if (a >= b) {\n            while (cross(ret[a-1]-ret[a-2],polygon[i]-ret[a-2]) < -EPS) {\n                a--;\n                if(a < b){\n                    break;\n                }\n            }\n        }\n        ret[a] = polygon[i];\n        a++;\n    }\n\n    ret.resize(a-1);\n\n    return ret;\n}\n\nint main(){\n\n    int N;\n    scanf(\"%d\",&N);\n\n    Polygon polygon;\n\n    int X,Y;\n\n    for(int i = 0; i < N; i++){\n\n        scanf(\"%d %d\",&X,&Y);\n\n        SET.insert(make_pair(X,Y));\n        polygon.push_back(Point(X,Y));\n    }\n\n    bool FLG = false;\n\n    for(int i = 2; i < N; i++){\n        if(abs(cross(polygon[0]-polygon[i],polygon[1]-polygon[i])) > EPS){\n\n            FLG = true;\n            break;\n        }\n    }\n\n    if(!FLG){\n\n        printf(\"No\\n\");\n        return 0;\n    }\n\n    polygon = ConvexHull_ALL(polygon);\n    int num_points = polygon.size();\n\n    for(int i = 0; i < num_points; i++){\n\n        points.push_back(polygon[i]);\n        points.push_back(Point((polygon[i].x+polygon[(i+1)%num_points].x)/2,(polygon[i].y+polygon[(i+1)%num_points].y)/2));\n    }\n\n    for(int i = 0; i < num_points; i++){\n\n        Line tmp_line = Line(points[i],points[i+num_points]);\n\n        FLG = true;\n        int num_on_line = 0;\n\n        for(auto p: SET){\n\n            Point tmp = calc_Reflection_Point(tmp_line,Point(p.first,p.second));\n\n            X = round(tmp.x);\n            Y = round(tmp.y);\n\n            if(fabs(tmp.x-X) > EPS || fabs(tmp.y-Y) > EPS){\n\n            \tFLG = false;\n            \tbreak;\n            }\n\n            if(SET.count(make_pair(X,Y)) == 0){\n\n                FLG = false;\n                break;\n            }\n\n            if(make_pair(X,Y) == p){\n\n                num_on_line++;\n            }\n        }\n\n        if(FLG == true && num_on_line <= 2){\n\n            printf(\"Yes\\n\");\n            return 0;\n        }\n    }\n\n    printf(\"No\\n\");\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef array<P, 2> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n        }\n\n        if(cnt.size() == 1) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            cnt[l] += 1;\n        }\n\n        //set<P> s;\n        //REP(i, N) s.insert(ps[i]);\n        sort(ps.begin(), ps.end());\n\n        bool ans = false;\n        // for(auto cp : cnt) {\n        //     //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        // }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!binary_search(ps.begin(), ps.end(), rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                DrawLine(cp.first);\n                for(int i = 0; i < N; i++) {\n                    DrawPoint(ps[i]);\n                    P rp = refl(cp.first, ps[i]);\n                    assert(s.count(rp));\n                    cout << ps[i] << \"<->\" << rp << \"(\" << s[rp] << \")\" << endl;\n                    assert(s[ refl(cp.first, rp) ] == i);\n                }\n                break;\n            }\n            */\n        }\n\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\nconst double EPS = 1e-9;\ntypedef complex<double> P;\ntypedef vector<P> L;\nP vec(L l){return l[1] - l[0];}\nint sign(double x){ return x > EPS ? 1 : x < -EPS ? -1 : 0; }\ndouble dot(P a, P b) {\n    return real(conj(a) * b);\n}\ndouble cross(P a, P b) {\n    return imag(conj(a) * b);\n}\n\ndouble zoom = 1/20.0;\nconst int OFFSET = 1000;\nvoid ChangeColor(int r, int g, int b) {\n  fprintf(stderr, \"c.strokeStyle = 'rgb(%d, %d, %d)';\\n\", r, g, b);\n}\nvoid DrawPoint(const P &p) {\n  fprintf(stderr, \"circle(%d, %d, %d)\\n\",\n      (int)(OFFSET+zoom*p.real()), 1980-OFFSET-(int)(zoom*p.imag()), 2);\n}\nvoid DrawLine(const L &l) {\n  fprintf(stderr, \"line(%d, %d, %d, %d)\\n\",\n      (int)(OFFSET+zoom*l[0].real()), 1980-OFFSET-(int)(zoom*l[0].imag()),\n      (int)(OFFSET+zoom*l[1].real()), 1980-OFFSET-(int)(zoom*l[1].imag()));\n}\n\nnamespace std{\n    bool operator < (const L& l, const L& m) {\n        double a1 = arg(vec(l));\n        double a2 = arg(vec(m));\n\n        if(sign(a1) < 0) a1 += M_PI;\n        if(sign(a2) < 0) a2 += M_PI;\n        if(a1 > M_PI - EPS) a1 -= M_PI;\n        if(a2 > M_PI - EPS) a2 -= M_PI;\n\n        if(sign(a1 - a2) != 0) return sign(a1 - a2) < 0;\n\n        double th = (a1 + a2) / 2.0;\n\n        P p1 = l[0] * polar(1.0, -th);\n        P p2 = m[0] * polar(1.0, -th);\n        double b1 = p1.imag();\n        double b2 = p2.imag();\n\n        return sign(b1 - b2) < 0;\n    }\n    bool operator == (const L& l, const L& m) {\n        return !(l < m) && !(m < l);\n    }\n    bool operator < (const P& a, const P& b) {\n        if(sign(a.real() - b.real()) != 0) return sign(a.real() - b.real()) < 0;\n        return sign(a.imag() - b.imag()) < 0;\n    }\n    bool operator ==  (const P& a, const P& b) {\n        return sign(a.real() - b.real()) == 0 && sign(a.imag() - b.imag()) == 0;\n    }\n}\n\nP proj(L l, P p){\n    double t = dot(p - l[0], vec(l)) / norm(vec(l));\n    return l[0] + t * vec(l);\n}\n\n// 点pの直線lに関する反射\nP refl(L l, P p){return 2.0 * proj(l, p) - p;}\n\n\n\nint main(){\n    int N;\n    while(cin >> N && N > 0){\n        vector<P> ps(N);\n        REP(i, N) {\n            double x, y;\n            cin >> x >> y;\n            ps[i] = {x, y};\n        }\n\n        map<L, int> cnt;\n        REP(i, N) REP(j, N) if(i != j) {\n            P mp = (ps[i] + ps[j]) / 2.0;\n            P vp = (ps[j] - ps[i]) * polar(1.0, M_PI / 2.0);\n            L l = {mp, mp + vp};\n            cnt[l] += 1;\n        }\n\n        set<L> line_set;\n        REP(i, N) REP(j, N) if(i != j) {\n            L l = {ps[i], ps[j]};\n            cnt[l] += 1;\n            line_set.insert(l);\n        }\n\n        if(line_set.size() == 1) {\n            cout << \"No\" << endl;\n            continue;\n        }\n\n        //set<P> s;\n        //REP(i, N) s.insert(ps[i]);\n        map<P, int> s;\n        REP(i, N) {\n            assert(!s.count(ps[i]));\n            s[ps[i]] = i;\n        }\n        \n        assert(s.size() == N);\n\n        bool ans = false;\n        // for(auto cp : cnt) {\n        //     //cout << cp.first[0] << \" \" << cp.first[1] << \" \" << cp.second << endl;\n        // }\n        for(auto cp : cnt) if(cp.second >= N - 2) {\n            bool ok = true;\n            int online = 0;\n            for(int i = 0; i < N; i++) {\n                P rp = refl(cp.first, ps[i]);\n                if(ps[i] == rp) online ++;\n                if(!s.count(rp)) {\n                    ok = false;\n                    break;\n                }\n                if(online > 2) {\n                    ok = false;\n                    break;\n                }\n            }\n            if(ok) ans = true;\n            /*\n            if(ok) {\n                cout << cp.first[0] << \" \" << cp.first[1] << endl;\n                DrawLine(cp.first);\n                for(int i = 0; i < N; i++) {\n                    DrawPoint(ps[i]);\n                    P rp = refl(cp.first, ps[i]);\n                    assert(s.count(rp));\n                    cout << ps[i] << \"<->\" << rp << \"(\" << s[rp] << \")\" << endl;\n                    assert(s[ refl(cp.first, rp) ] == i);\n                }\n                break;\n            }\n            */\n        }\n\n\n        cout << (ans ? \"Yes\" : \"No\") << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <iostream>\n#include <limits>\n#include <vector>\n#include <cmath>\n#include <utility>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nnamespace libcomp {\nnamespace geometry {\n\nconst double EPS = 1e-9;\n\nbool tolerant_eq(double a, double b){ return abs(a - b) < EPS; }\n\nstruct Point {\n\tdouble x;\n\tdouble y;\n\n\texplicit Point(const double &x = 0.0, const double &y = 0.0) :\n\t\tx(x), y(y)\n\t{ }\n\n\tstatic Point invalid(){\n\t\tdouble qnan = numeric_limits<double>::quiet_NaN();\n\t\treturn Point(qnan, qnan);\n\t}\n\tbool is_valid() const { return !(isnan(x) || isnan(y)); }\n\n\tPoint operator+(const Point &p) const { return Point(x + p.x, y + p.y); }\n\tPoint &operator+=(const Point &p){ return *this = *this + p; }\n\tPoint operator-(const Point &p) const { return Point(x - p.x, y - p.y); }\n\tPoint &operator-=(const Point &p){ return *this = *this - p; }\n\tPoint operator*(double s) const { return Point(x * s, y * s); }\n\tPoint &operator*=(double s){ return *this = *this * s; }\n\tPoint operator/(double s) const { return Point(x / s, y / s); }\n\tPoint &operator/=(double s){ return *this = *this / s; }\n\n\tbool operator==(const Point &p) const { return x == p.x && y == p.y; }\n\tbool operator!=(const Point &p) const { return x != p.x || y != p.y; }\n\tbool operator<(const Point &p) const {\n\t\treturn (x == p.x) ? (y < p.y) : (x < p.x);\n\t}\n};\n\nPoint operator*(double s, const Point &p){ return p * s; }\n\nbool tolerant_eq(const Point &a, const Point &b){\n\treturn tolerant_eq(a.x, b.x) && tolerant_eq(a.y, b.y);\n}\n\ndouble abs(const Point &p){ return sqrt(p.x * p.x + p.y * p.y); }\ndouble norm(const Point &p){ return p.x * p.x + p.y * p.y; }\nPoint unit(const Point &p){ return p / abs(p); }\nPoint ortho(const Point &p){ return Point(-p.y, p.x); }\ndouble cross(const Point &a, const Point &b){ return a.x * b.y - a.y * b.x; }\ndouble dot(const Point &a, const Point &b){ return a.x * b.x + a.y * b.y; }\nint ccw(const Point &a, const Point &b, const Point &c){\n\tPoint d = b - a, e = c - a;\n\tif(cross(d, e) > 0.0){ return 1; }\n\tif(cross(d, e) < 0.0){ return -1; }\n\tif(dot(d, e) < 0.0){ return 2; }\n\tif(abs(d) < abs(e)){ return -2; }\n\treturn 0;\n}\n\nstruct Line {\n\tPoint a;\n\tPoint b;\n\n\texplicit Line(const Point &a = Point(), const Point &b = Point()) :\n\t\ta(a), b(b)\n\t{ }\n\n\tstatic Line invalid(){\n\t\tPoint inv = Point::invalid();\n\t\treturn Line(inv, inv);\n\t}\n\tbool is_valid() const { return a.is_valid() && b.is_valid(); }\n\n\tbool operator<(const Line &l) const {\n\t\treturn (a == l.a) ? (b < l.b) : (a < l.a);\n\t}\n};\n\nbool tolerant_eq(const Line &a, const Line &b){\n\treturn ::std::abs(cross(a.b - a.a, b.a - a.a)) < EPS;\n}\n\nPoint projection(const Line &l, const Point &p){\n\tdouble t = dot(p - l.a, l.b - l.a) / norm(l.b - l.a);\n\treturn l.a + t * (l.b - l.a);\n}\n\nPoint reflection(const Line &l, const Point &p){\n\treturn p + 2.0 * (projection(l, p) - p);\n}\n\n}\n}\n\nusing namespace libcomp::geometry;\ntypedef pair<int, int> pii;\n\ninline ll pow2(ll x){ return x * x; }\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n;\n\tcin >> n;\n\tvector<Point> p(n);\n\tset<pii> ps;\n\tint xsum = 0, ysum = 0;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tp[i] = Point(x, y);\n\t\tps.insert(pii(x, y));\n\t\txsum += x;\n\t\tysum += y;\n\t}\n\tconst Point c(\n\t\tstatic_cast<double>(xsum) / n, static_cast<double>(ysum) / n);\n\tbool answer = false;\n\tif(n % 2 == 0){\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tif(tolerant_eq(p[i], c)){ continue; }\n\t\t\tconst Line l(p[i], c);\n\t\t\tbool accept = true;\n\t\t\tfor(int j = 0; accept && j < n; ++j){\n\t\t\t\tconst Point a = p[j];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i = 0; !answer && i < 3; ++i){\n\t\tfor(int j = i + 1; !answer && j < n; ++j){\n\t\t\tconst Point q = projection(Line(p[i], p[j]), c);\n\t\t\tif(tolerant_eq(q, c)){ continue; }\n\t\t\tconst Line l((p[i] + p[j]) / 2, c);\n\t\t\tbool accept = true;\n\t\t\tint count = 0;\n\t\t\tfor(int k = 0; accept && k < n; ++k){\n\t\t\t\tconst Point a = p[k];\n\t\t\t\tconst Point b = reflection(l, a);\n\t\t\t\tif(tolerant_eq(a, b) && ++count >= n % 2){ accept = false; }\n\t\t\t\tconst int ibx = static_cast<int>(floor(b.x + 0.5));\n\t\t\t\tconst int iby = static_cast<int>(floor(b.y + 0.5));\n\t\t\t\tconst Point d(ibx, iby);\n\t\t\t\tif(!tolerant_eq(b, d)){ accept = false; }\n\t\t\t\tif(ps.find(pii(ibx, iby)) == ps.end()){ accept = false; }\n\t\t\t}\n\t\t\tif(accept){\n\t\t\t\tanswer = true;\n\t\t\t}\n\t\t}\n\t}\n\tcout << (answer ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> PI;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nvector<P> convex_hull(vector<P>& ps){\n  sort(ps.begin(),ps.end(),[](const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; });\n  int n=ps.size();\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool intersectLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nP reflection(L l,P p) {\n  return p+2.0*(projection(l,p)-p);\n}\n\nint N;\nvector<P> ps;\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  vector<P> cs=convex_hull(ps);\n  int M=cs.size();\n  vector<P> ds;\n  rep(i,M){\n    ds.push_back(cs[i]);\n    ds.push_back((cs[i]+cs[(i+1)%M])*0.5);\n  }\n  vector<L> cand;\n  rep(i,M){\n    bool ok=true;\n    P p1=ds[i],p2=ds[i+M];\n    for(int l=(i-1+2*M)%(2*M),r=i+1;l!=r;l=(l-1+2*M)%(2*M),r=(r+1)%(2*M)){\n      P m=(ds[l]+ds[r])*0.5;\n      if(!intersectLP(L(p1,p2),m)||abs(dot(ds[l]-ds[r],p1-p2))>eps)ok=false;\n    }\n    if(ok){\n      cand.push_back(L(p1,p2));\n    }\n  }\n\n  bool is_sym=false;\n  sort(all(ps),cmp_x);\n  rep(i,cand.size()){\n    vector<P> sps;\n    rep(j,N){\n      sps.push_back(reflection(cand[i],ps[j]));\n    }\n    sort(all(sps),cmp_x);\n    bool ok=true;\n    int cnt=0;\n    rep(j,N){\n      if(abs(sps[j]-ps[j])>eps)ok=false;\n      if(intersectLP(cand[i],ps[j]))cnt++;\n    }\n    if(ok&&cnt<3)is_sym=true;\n  }\n\n  if(is_sym)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define EPS (1e-4)\n#define equals(a,b) (fabs((a)-(b))<EPS)\n#define COUNTER_CLOCKWISE 1\n#define CLOCKWISE -1\n#define ONLINE_BACK 2\n#define ONLINE_FRONT -2\n#define ON_SEGMENT 0\n\nusing namespace std;\n\nbool LT(double a,double b) { return !equals(a,b) && a < b; }\nbool LTE(double a,double b) { return equals(a,b) || a < b; }\n\nclass Point {\npublic:\n  double x,y;\n\n  Point(double x=0,double y=0):x(x),y(y){}\n\n  Point operator + (const Point& p) { return Point(x+p.x,y+p.y); }\n  Point operator - (const Point& p) { return Point(x-p.x,y-p.y); }\n  Point operator * (const double& p) { return Point(x*p,y*p); }\n  Point operator / (const double& p) { return Point(x/p,y/p); }\n  \n  bool operator < ( const Point & p ) const { return !equals(x,p.x)?x<p.x:(!equals(y,p.y)&&y<p.y);}\n  bool operator == ( const Point & p ) const { return equals(x,p.x) && equals(y,p.y); }\n  \n};\n\nstruct Segment {\n  Point p1,p2;\n  Segment(Point p1=Point(),Point p2=Point()) : p1(p1), p2(p2) {}\n};\n\ntypedef Point Vector;\ntypedef Segment Line;\ntypedef vector<Point> Polygon;\n\n\nostream& operator << (ostream& os,const Point&a ) { os << \"(\" << a.x << \",\" << a.y << \")\"; }\nostream& operator << (ostream& os,const Segment& a) { os << \"(\" << a.p1 << \",\" << a.p2 << \")\"; }\n\ndouble dot(Point a,Point b) { return a.x*b.x + a.y*b.y; }\ndouble cross(Point a,Point b) { return a.x*b.y-a.y*b.x; }\ndouble norm(Point a) { return a.x*a.x + a.y*a.y; }\ndouble abs(Point a) { return sqrt(norm(a)); }\ndouble toRad(double a){ return a * M_PI / 180.0; }\nPoint rotate(Point a,double rad) { return Point(cos(rad)*a.x-sin(rad)*a.y,sin(rad)*a.x+cos(rad)*a.y); }\n\nint ccw(Point p0,Point p1,Point p2){\n  Point a = p1-p0;\n  Point b = p2-p0;\n  if( cross(a,b) > EPS ) return COUNTER_CLOCKWISE;\n  if( cross(a,b) <-EPS ) return CLOCKWISE;\n  if( dot(a,b) < -EPS ) return ONLINE_BACK;\n  if( norm(a) < norm(b) ) return ONLINE_FRONT;\n  return ON_SEGMENT;\n}\n\nbool intersectLP(Line l,Point p){\n  return abs(cross(l.p2-p,l.p1-p)) < EPS;\n}\n\nPoint projection(Line l,Point p) {\n  double  t = dot(p-l.p1,l.p1-l.p2) / norm(l.p1-l.p2);\n  return l.p1 + ( l.p1 - l.p2 ) * t;\n}\n\nPoint reflection(Line l,Point p){\n  return p + (projection(l,p)-p) * 2;\n}\n\ndouble cross3p(Point p,Point q,Point r) { return (r.x-q.x) * (p.y-q.y) - (r.y-q.y) * (p.x-q.x); }\nbool collinear(Point p,Point q,Point r) { return fabs(cross3p(p,q,r)) < EPS; }\nbool onSegment(Point p,Point q,Point r) {\n  return collinear(p,q,r) && equals(sqrt(pow(p.x-r.x,2)+pow(p.y-r.y,2))+sqrt(pow(r.x-q.x,2)+pow(r.y-q.y,2)),sqrt(pow(p.x-q.x,2)+pow(p.y-q.y,2)));\n}\n\nconst string YES = \"Yes\";\nconst string NO  = \"No\";\nint n;\n\nPolygon answerScan(Polygon s){\n  Polygon u,l;\n  if( s.size() < 3 ) return s;\n  sort(s.begin(),s.end());\n  u.push_back(s[0]);\n  u.push_back(s[1]);\n  l.push_back(s[s.size()-1]);\n  l.push_back(s[s.size()-2]);\n  REP(i,2,s.size()){\n    for(int n=u.size();n>=2&&ccw(u[n-2],u[n-1],s[i])!=CLOCKWISE;n--)\n      u.pop_back();\n    u.push_back(s[i]);\n  }\n  for(int i=s.size()-3;i>=0;i--){\n    for(int n=l.size();n>=2&&ccw(l[n-2],l[n-1],s[i])!=CLOCKWISE;n--)\n      l.pop_back();\n    l.push_back(s[i]);\n  }\n  reverse(l.begin(),l.end());\n  for(int i=u.size()-2;i>=1;i--) l.push_back(u[i]);\n  return l;\n\n}\n\n//// --additional\n\ndouble getArea(vector<Point>& vec) {\n  double sum = 0;\n  for(int i=0;i<vec.size();i++)\n    sum += cross(vec[i],vec[(i+1)%vec.size()]);\n  return fabs(sum)/2.0;\n}\n\nPoint getCentroidOfConvex(Polygon& poly){\n  double area = getArea(poly);\n  int V = poly.size();\n  assert( !equals(area,0.0) );\n  double x = 0, y = 0;\n  rep(i,(int)poly.size()) {\n    x += ( poly[i].x + poly[(i+1)%V].x ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n    y += ( poly[i].y + poly[(i+1)%V].y ) * ( poly[i].x*poly[(i+1)%V].y - poly[(i+1)%V].x*poly[i].y );\n  }\n  return Point(x/(6.0*area),y/(6.0*area));\n}\n\n\n//// --additional\n\nbool isValid(vector<Point> &vec) {\n  Line line = Line(vec[0],vec[1]);\n  bool ok = false;\n  rep(i,vec.size()) {\n    if( !intersectLP(line,vec[i]) ) { ok = true; break; }\n  }\n  if( !ok ) return false;\n  return true;\n}\n\nbool isAnswer(Line line,vector<Point> &vec){\n  vector<Point> vec_CW,vec_CCW;\n  int on_line = 0;\n  rep(j,n){\n    if( intersectLP(line,vec[j]) ) { ++on_line; continue; }\n    int res = ccw(line.p1,line.p2,vec[j]);\n    assert( res == COUNTER_CLOCKWISE || res == CLOCKWISE );\n    if( res == CLOCKWISE ) vec_CW.push_back(vec[j]);\n    else                   vec_CCW.push_back(vec[j]);\n  }\n  if( vec_CW.size() != vec_CCW.size() ) return false;\n  if( !( on_line <= 2 ) ) return false;\n\n  map<Point,bool> mp;\n  rep(j,vec_CCW.size()) mp[vec_CCW[j]] = true;\n  bool success = true;\n  rep(j,vec_CW.size()){\n    Point rp = reflection(line,vec_CW[j]);\n    if( !mp.count(rp) ) { success = false; break; }\n  }\n  return success;\n}\n\nvoid compute(vector<Point> &vec){\n  if( !isValid(vec) ) {\n    cout << NO << endl;\n    return;\n  }\n\n  Polygon poly = answerScan(vec);\n  //rep(i,poly.size()) cout << poly[i] << endl;\n  Point centroid = getCentroidOfConvex(poly);\n\n  rep(i,poly.size()){\n    Vector v = poly[(i+1)%poly.size()] - poly[i];\n    v = rotate(v,toRad(90));\n    Vector e = v / abs(v);\n    Point mid_p = (poly[i]+poly[(i+1)%poly.size()])/2;\n    Line line = Line(mid_p,mid_p+e*100);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n\n    // --additional\n    line = Line(centroid,poly[i]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n\n  rep(i,n) REP(j,i+1,n) {\n    Line line = Line(vec[i],vec[j]);\n    if( isAnswer(line,vec) ) {\n      cout << YES << endl;\n      return;\n    }\n  }\n\n  cout << NO << endl;\n}\n\nint main(){\n  cin >> n;\n  vector<Point> vec(n);\n  rep(i,n) cin >> vec[i].x >> vec[i].y;\n  compute(vec);\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> PI;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\ntypedef double D;\ntypedef complex<D> P;\n#define X real()\n#define Y imag()\n\nconst D eps=1e-8;\nconst D inf=1e12;\n\nstruct L : public vector<P> { // line and segment\n  L(const P& a,const P &b){\n    push_back(a);\n    push_back(b);\n  }\n};\n\nbool cmp_x(const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; }\nD dot(P a,P b){ return (conj(a)*b).X; }\nD cross(P a,P b){ return (conj(a)*b).Y; }\nvector<P> convex_hull(vector<P>& ps){\n  sort(ps.begin(),ps.end(),[](const P& a,const P& b){ return a.X==b.X?a.Y<b.Y:a.X<b.X; });\n  int n=ps.size();\n  int k=0;\n  vector<P> qs(n*2);\n  for(int i=0;i<n;i++){\n    while(k>1&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  for(int i=n-2,t=k;i>=0;i--){\n    while(k>t&&cross(qs[k-1]-qs[k-2],ps[i]-qs[k-1])<0)k--;\n    qs[k++]=ps[i];\n  }\n  qs.resize(k-1);\n  return qs;\n}\n\nbool intersectLP(L l,P p){\n  return abs(cross(l[1]-p,l[0]-p))<eps;\n}\nP projection(L l,P p){\n  P b=l[1]-l[0],c=p-l[0];\n  return l[0]+b*(c/b).X;\n}\nP reflection(L l,P p) {\n  return p+2.0*(projection(l,p)-p);\n}\n\nint N;\nvector<P> ps;\n\nint main(){\n  cin>>N;\n  rep(i,N){\n    int x,y;\n    cin>>x>>y;\n    ps.push_back(P(x,y));\n  }\n  vector<P> cs=convex_hull(ps);\n  int M=cs.size();\n  vector<P> ds;\n  rep(i,M){\n    ds.push_back(cs[i]);\n    ds.push_back((cs[i]+cs[(i+1)%M])*0.5);\n  }\n  vector<L> cand;\n  rep(i,M){\n    bool ok=true;\n    P p1=ds[i],p2=ds[i+M];\n    for(int l=(i-1+2*M)%(2*M),r=i+1;l!=r;l=(l-1+2*M)%(2*M),r=(r+1)%(2*M)){\n      P m=(ds[l]+ds[r])*0.5;\n      if(!intersectLP(L(p1,p2),m)||abs(dot(ds[l]-ds[r],p1-p2))>eps)ok=false;\n    }\n    if(ok){\n      cand.push_back(L(p1,p2));\n    }\n  }\n\n  bool is_sym=false;\n  sort(all(ps),cmp_x);\n  vector<PI> ssps;\n  rep(i,N)ssps.push_back(PI(ps[i].X,ps[i].Y));\n  sort(all(ssps));\n  rep(i,cand.size()){\n    vector<PI> sps;\n    rep(j,N){\n      P r=reflection(cand[i],ps[j]);\n      sps.push_back(PI((int)r.X,(int)r.Y));\n    }\n    sort(all(sps));\n    bool ok=true;\n    int cnt=0;\n    rep(j,N){\n      if(sps[j]!=ssps[j])ok=false;\n      if(intersectLP(cand[i],ps[j]))cnt++;\n    }\n    if(ok&&cnt<3)is_sym=true;\n  }\n\n  if(is_sym)cout<<\"Yes\"<<endl;\n  else cout<<\"No\"<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <queue>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <complex>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <stdio.h>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<double> VEC;\ntypedef vector<VEC> MAT;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n//container util\n\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define MT(a,b,c) MP(a, MP(b, c))\n#define T1 first\n#define T2 second.first\n#define T3 second.second\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define MOD 1000000007\n\n//AOJ2159\nint n;\nint x[1000], y[1000];\nset<PII> spii;\n\nbool mirror(LL a, LL b, LL c, LL xa, LL ya, LL &xb, LL &yb){\n\tLL xx=-2*a*c-(a*a-b*b)*xa-2*a*b*ya;\n\tLL yy=-2*b*c+(a*a-b*b)*ya-2*a*b*xa;\n\tLL rr=a*a+b*b;\n\txb = xx/rr;\n\tyb = yy/rr;\n\tif(xb*rr==xx && yb*rr==yy)return false;\n\treturn true;\n}\n\nint solve1(int p, int q){\n\tint ret = 0;\n\tint ret2 = 0;\n\tLL a=2*(x[q]-x[p]);\n\tLL b=2*(y[q]-y[p]);\n\tLL c=x[p]*x[p]-x[q]*x[q]+y[p]*y[p]-y[q]*y[q];\n\tLL tx, ty;\n\tREP(i,n){\n\t\tif(i==p||i==q)continue;\n\t\tif(mirror(a,b,c,x[i],y[i],tx,ty)==false)return 100;\n\t\tif(!EXIST(spii, MP(tx,ty)))return 100;\n\t\tif(tx==x[i] && ty==y[i])ret++;\n\t\tif(x[p]+x[q] == 2*tx && y[p]+y[q] == 2*ty)ret2++;\n\t}\n\tif(ret2 == n/2)return 100;\n\treturn ret;\n}\n\nint solve2(int p, int q){\n\tint ret = 0;\n\tLL a=(y[q]-y[p]);\n\tLL b=-(x[q]-x[p]);\n\tLL c=y[p]*x[q]-y[q]*x[p];\n\tLL tx, ty;\n\tREP(i,n){\n\t\tif(i==p||i==q)continue;\n\t\tif(mirror(a,b,c,x[i],y[i],tx,ty)==false)return 100;\n\t\tif(!EXIST(spii, MP(tx,ty)))return 100;\n\t\tif(tx==x[i] && ty==y[i])return 100;\n\t}\n\treturn ret;\n}\nint main(){\n\tcin>>n;\n\tREP(i,n){\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tspii.insert(MP(x[i], y[i]));\n\t}\n\n\tREP(i,n){\n\t\tFOR(j,i+1,n){\n\t\t\tif(solve1(i,j)==n%2){\n\t\t\t\tcout << \"YES\" << endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(solve2(i,j)==0){\n\t\t\t\tcout << \"YES\"<<endl;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t}\n\tcout << \"NO\"<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-7;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\nconst Point rot(cos(0.001L), sin(0.001L));\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q):a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2):a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b):p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2,0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nbool solve(Polygon g, Line l)\n{\n\tint cnt = 0;\n\tPolygon r;\n\tREP(i, g.size())\n\t{\n\t\tif (isis_lp(l, g[i])) cnt++;\n\t\tr.push_back(mirror(l, g[i]));\n\t}\n\tif (cnt > 2) return false;\n\tsort(ALL(g));\n\tsort(ALL(r));\n\tREP(i, g.size())\n\t{\n\t\tif (abs(g[i] - r[i]) < EPS) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tPolygon p;\n\tREP(i, n)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(Point(x, y));\n\t}\n\tsort(ALL(p));\n\tPolygon g = convex_hull(p);\n\tint v = g.size();\n\tif (v < 3)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tREP(i, v)\n\t{\n\t\tLine l(g[i], g[(i + 1) % v]);\n\t\tPoint vec = l.b - l.a;\n\t\tPoint m = (l.a + l.b) / Point(2,0);\n\t\tLine s(m, m + Point(-vec.imag(), vec.real()));\n\t\tif (solve(p, s)) ans = true;\n\t}\n\tif (v % 2 == 0)\n\t{\n\t\tREP(i, v/2)\n\t\t{\n\t\t\tLine l(g[i], g[i + v / 2]);\n\t\t\tif (solve(p, l)) ans = true;\n\t\t}\n\t}\n\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-8;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntypedef long double ld;\nconst ld PI = acos(-1.0);\nbool eq(ld a, ld b) { return abs(a - b) < EPS; }\ntypedef complex<ld> Point;\ntypedef vector<Point> Polygon;\nconst Point rot(cos(0.1357L), sin(0.1357L));\n\nnamespace std\n{\n\tbool operator < (const Point& a, const Point& b)\n\t{\n\t\treturn real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n\t}\n}\n\nstruct Line\n{\n\tPoint a, b;\n\tLine(Point p, Point q):a(p), b(q) {};\n\tLine(ld x1, ld y1, ld x2, ld y2):a(Point(x1, y1)), b(Point(x2, y2)) {};\n};\n\nstruct Circle\n{\n\tPoint p; ld r;\n\tCircle(Point a, ld b):p(a), r(b) {};\n};\n\nld dot(Point a, Point b)\n{\n\treturn real(conj(a)*b);\n}\n\nld cross(Point a, Point b)\n{\n\treturn imag(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c)\n{\n\tb -= a; c -= a;\n\tif (cross(b, c) > EPS) return 1;    //counter cloclwise\n\tif (cross(b, c) < -EPS) return -1;  //cloclwise\n\tif (dot(b, c) < 0) return 2;        //c--a--b on line \n\tif (norm(b) < norm(c)) return -2;   //a--b--c on line\n\treturn 0;                           //a--c--b on line\n}\n\nbool isis_ll(Line l, Line m)\n{\n\treturn abs(cross(l.b - l.a, m.b - m.a)) > EPS;\n}\n\nbool isis_ls(Line l, Line s)\n{\n\treturn cross(l.b - l.a, s.a - l.a)*cross(l.b - l.a, s.b - l.a) < EPS;\n}\n\nbool isis_ss(Line s, Line t)\n{\n\treturn (ccw(s.a, s.b, t.a)*ccw(s.a, s.b, t.b) <= 0 &&\n\t\t\tccw(t.a, t.b, s.a)*ccw(t.a, t.b, s.b) <= 0);\n}\n\nbool isis_lp(Line l, Point p)\n{\n\treturn (abs(cross(l.b - p, l.a - p)) < EPS);\n}\n\nbool isis_sp(Line s, Point p)\n{\n\treturn (abs(s.a - p) + abs(s.b - p) - abs(s.b - s.a)) < EPS;\n}\n\nPoint projection(Line l, Point p)\n{\n\tPoint base = l.b - l.a;\n\tld r = dot(p - l.a, base) / norm(base);\n\treturn l.a + base*r;\n}\n\nPoint mirror(Line l, Point p)\n{\n\treturn Point(2,0)*projection(l, p) - p;\n}\n\nld dist_lp(Line l, Point p)\n{\n\treturn abs(p - projection(l, p));\n}\n\nld dist_ll(Line l, Line m)\n{\n\treturn isis_ll(l, m) ? 0 : dist_lp(l, m.a);\n}\n\nld dist_ls(Line l, Line s)\n{\n\tif (isis_ls(l, s)) return 0;\n\treturn min(dist_lp(l, s.a), dist_lp(l, s.b));\n}\n\nld dist_sp(Line s, Point p)\n{\n\tPoint r = projection(s, p);\n\tif (isis_sp(s, r)) return abs(r - p);\n\treturn min(abs(s.a - p), abs(s.b - p));\n}\n\nld dist_ss(Line s, Line t)\n{\n\tif (isis_ss(s, t)) return 0;\n\treturn min(min(dist_sp(s, t.a), dist_sp(s, t.b)), min(dist_sp(t, s.a), dist_sp(t, s.b)));\n}\n\nPoint is_ll(Line s, Line t)\n{\n\tld a = cross(s.b - s.a, t.b - t.a);\n\tld b = cross(s.b - s.a, s.b - t.a);\n\treturn t.a + b / a*(t.b - t.a);\n}\n\nvector<Point> is_cc(Circle c1, Circle c2)\n{\n\tvector<Point> res;\n\tld d = abs(c1.p - c2.p);\n\tld rc = (d*d + pow(c1.r, 2) - pow(c2.r, 2)) / (2 * d);\n\tld dfr = pow(c1.r, 2) - rc*rc;\n\tif (abs(dfr) < EPS) dfr = 0;\n\tif (dfr < 0.0) return res;\n\tld rs = sqrt(dfr);\n\tPoint diff = (c2.p - c1.p) / d;\n\tres.push_back(c1.p + diff*Point(rc, rs));\n\tif (dfr != 0.0) res.push_back(c1.p + diff*Point(rc, -rs));\n\treturn res;\n}\n\nint isis_cc(Circle c1, Circle c2)\n{\n\tld d = abs(c1.p - c2.p);\n\tif (d - c1.r - c2.r < -EPS) return -2; //separate\n\tif (abs(d - c1.r - c2.r) < EPS) return -1; //circumscribe\n\tif (c1.r < c2.r) swap(c1, c2);\n\tif (abs(d - c1.r + c2.r) < EPS) return 1;//inscribe\n\tif (c1.r - d - c2.r > EPS) return 2;//involve\n\telse return 0;//intersect\n}\n\nbool isis_cl(Circle c, Line l)\n{\n\tld d = dist_lp(l, c.p);\n\treturn d - c.r < -EPS;\n}\n\nvector<Point> is_cl(Circle c, Line l)\n{\n\tvector<Point> res;\n\tld d = dist_lp(l, c.p);\n\tif (d > c.r + EPS) return res;\n\tld len = (d > c.r) ? 0 : sqrt(c.r*c.r - d*d);\n\tPoint nor = (l.a - l.b) / abs(l.a - l.b);\n\tres.push_back(projection(l, c.p) + len*nor);\n\tif (abs(len) > EPS) res.push_back(projection(l, c.p - len*nor));\n\treturn res;\n}\n\nvector<Point> is_cs(Circle c, Line s)\n{\n\tvector<Point> v = is_cl(c, s), res;\n\tREP(i, v.size())\n\t{\n\t\tif (ccw(s.a, v[i], s.b) == -2) res.push_back(v[i]);\n\t}\n\treturn res;\n}\n\nvector<Line> tangent_cp(Circle c, Point p)\n{\n\tvector<Line> res;\n\tPoint v = c.p - p;\n\tld d = abs(v);\n\tld l = sqrt(norm(v) - c.r * c.r);\n\tif (isnan(l)) { return res; }\n\tPoint v1 = v * Point(l / d, c.r / d);\n\tPoint v2 = v * Point(l / d, -c.r / d);\n\tres.push_back(Line(p, p + v1));\n\tif (l < EPS) return res;\n\tres.push_back(Line(p, p + v2));\n\treturn res;\n}\n\nvector<Line> tangent_cc(Circle c1, Circle c2)\n{\n\tvector<Line> res;\n\tif (abs(c1.p - c2.p) - (c1.r + c2.r) > -EPS)\n\t{\n\t\tPoint center = (c1.p * c2.r + c2.p * c1.r) / (c1.r + c2.r);\n\t\tres = tangent_cp(c1, center);\n\t}\n\tif (abs(c1.r - c2.r) > EPS)\n\t{\n\t\tPoint out = (-c1.p * c2.r + c2.p * c1.r) / (c1.r - c2.r);\n\t\tvector<Line> nres = tangent_cp(c1, out);\n\t\tres.insert(res.end(), nres.begin(), nres.end());\n\t}\n\telse\n\t{\n\t\tPoint v = c2.p - c1.p; v /= abs(v);\n\t\tPoint q1 = c1.p + v * Point(0, 1) * c1.r;\n\t\tPoint q2 = c1.p + v * Point(0, -1) * c1.r;\n\t\tres.push_back(Line(q1, q1 + v));\n\t\tres.push_back(Line(q2, q2 + v));\n\t}\n\treturn res;\n}\n\n/*--------------------template--------------------*/\n\n\nPolygon convex_hull(Polygon s)\n{\n\tPolygon u, l;\n\tif (s.size() < 3) return s;\n\tsort(ALL(s));\n\tu.push_back(s[0]);\n\tu.push_back(s[1]);\n\tl.push_back(s[s.size() - 1]);\n\tl.push_back(s[s.size() - 2]);\n\tFOR(i, 2, s.size())\n\t{\n\t\tfor (int n = u.size(); n >= 2 && ccw(u[n - 2], u[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tu.pop_back();\n\t\t}\n\t\tu.push_back(s[i]);\n\t}\n\tfor (int i = s.size() - 3; i >= 0; i--)\n\t{\n\t\tfor (int n = l.size(); n >= 2 && ccw(l[n - 2], l[n - 1], s[i]) != -1; n--)\n\t\t{\n\t\t\tl.pop_back();\n\t\t}\n\t\tl.push_back(s[i]);\n\t}\n\tfor (int i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\treturn l;\n}\n\nbool solve(Polygon g, Line l)\n{\n\tint cnt = 0;\n\tPolygon r;\n\tREP(i, g.size())\n\t{\n\t\tif (isis_lp(l, g[i])) cnt++;\n\t\tr.push_back(mirror(l, g[i]));\n\t}\n\tif (cnt > 2) return false;\n\tsort(ALL(g));\n\tsort(ALL(r));\n\tREP(i, g.size())\n\t{\n\t\tif (abs(g[i] - r[i]) < EPS) continue;\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nint main()\n{\n\tint n; cin >> n;\n\tPolygon p;\n\tREP(i, n)\n\t{\n\t\tld x, y;\n\t\tcin >> x >> y;\n\t\tp.push_back(Point(x, y));\n\t}\n\tsort(ALL(p));\n\tPolygon g = convex_hull(p);\n\tint v = g.size();\n\tif (v < 3)\n\t{\n\t\tputs(\"No\");\n\t\treturn 0;\n\t}\n\tbool ans = false;\n\tREP(i, v)\n\t{\n\t\tLine l(g[i], g[(i + 1) % v]);\n\t\tPoint vec = l.b - l.a;\n\t\tPoint m = (l.a + l.b) / Point(2,0);\n\t\tLine s(m, m + Point(-vec.imag(), vec.real()));\n\t\tif (solve(p, s)) ans = true;\n\t}\n\tif (v % 2 == 0)\n\t{\n\t\tREP(i, v/2)\n\t\t{\n\t\t\tLine l(g[i], g[i + v / 2]);\n\t\t\tif (solve(p, l)) ans = true;\n\t\t}\n\t}\n\tcout << (ans ? \"Yes\" : \"No\") << endl;\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "\nimport java.math.BigInteger\n\ndata class Rational(val numerator: BigInteger, val denominator: BigInteger): Comparable<Rational> {\n    override fun compareTo(other: Rational): Int = (numerator * other.denominator).compareTo(denominator * other.denominator)\n    operator fun plus(that: Rational): Rational = Rational.new(numerator * that.denominator + denominator * that.numerator, denominator * that.denominator)\n    operator fun minus(that: Rational): Rational = Rational.new(numerator * that.denominator - denominator * that.numerator, denominator * that.denominator)\n    operator fun times(that: Rational): Rational = Rational.new(numerator * that.numerator, denominator * that.denominator)\n    operator fun div(that: Rational): Rational = Rational.new(numerator * that.denominator, denominator * that.numerator)\n    operator fun unaryMinus():Rational = Rational(-numerator, denominator)\n    companion object {\n        fun new(numerator: BigInteger, denominator: BigInteger): Rational {\n            val g = gcd(numerator.abs(), denominator.abs())\n            return Rational(numerator * denominator.signum().toBigInteger() / g, denominator.abs() / g)\n        }\n        fun new(number: Int): Rational = Rational(number.toBigInteger(), 1.toBigInteger())\n        tailrec fun gcd(a: BigInteger, b: BigInteger): BigInteger {\n            return if (b == 0.toBigInteger()){\n                a\n            }else {\n                gcd(b, a % b)\n            }\n        }\n    }\n}\nfun Int.toRational(): Rational = Rational.new(this)\nfun Int.toBigInteger(): BigInteger = BigInteger.valueOf(this.toLong())\n\ndata class Point(val x: Rational, val y: Rational) {\n    operator fun plus(that: Point): Point = Point(x + that.x, y + that.y)\n    operator fun plus(that: Vector): Point = Point(x + that.x, y + that.y)\n    operator fun minus(that: Point): Vector = Vector(x - that.x, y - that.y)\n    constructor(x: Int, y: Int):this(Rational.new(x), Rational.new(y))\n}\ndata class Vector(val x: Rational, val y: Rational)\nclass Line private constructor(private val a: Rational, private val b: Rational, private val c: Rational) {\n    fun cathetus(point: Point): Line = Line(b, -a, a * point.y - b * point.x)\n    fun isParallel(that: Line): Boolean = a * that.b == b * that.a\n    fun crossPoint(that: Line): Point? = if (isParallel(that)) null else (a * that.b - b * that.a).let{d -> Point((b * that.c - c * that.b) / d, (c * that.a - a * that.c) / d)}\n    fun symmetryPoint(point: Point): Point = (crossPoint(cathetus(point))!! - point).let{vec -> point + vec + vec}\n    fun isOnLine(that: Point): Boolean = a * that.x + b * that.y + c == 0.toRational()\n    companion object {\n        fun byTwoPoints(a: Point, b: Point): Line = Line(a.y - b.y, b.x - a. x, a.x * b.y - a.y * b.x)\n    }\n}\nfun isOnLine(points: Array<Point>): Boolean {\n    val line = Line.byTwoPoints(points[0], points[1])\n    return (2 until points.size).all{line.isOnLine(points[it])}\n}\nfun main(args: Array<String>?): Unit {\n    val n = readLine()!!.trim().toInt()\n    val points = Array(n){\n        val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n        Point(x, y)\n    }\n    if (isOnLine(points)) {\n        println(\"No\")\n        return\n    }\n    val set = points.toHashSet()\n    var isSymmetry = false\n    for (p in 0 .. 1) {\n        for (i in p + 1 until n ){\n            if (isSymmetry) {\n                println(\"Yes\")\n                return\n            }\n            val midLine = Line.byTwoPoints(points[p], points[i]).cathetus(Point((points[p].x + points[i].x) / 2.toRational(), (points[p].y + points[i].y) / 2.toRational()))\n            isSymmetry = true\n            var onLineCount = 0\n            for (j in 0 until n) {\n                if (i != j && midLine.isOnLine(points[j])) {\n                    ++onLineCount\n                }\n                if (i != j && (onLineCount > 2 || midLine.symmetryPoint(points[j]) !in set)) {\n                    isSymmetry = false\n                    break\n                }\n            }\n        }\n    }\n    for (i in 1 until n){\n        if (isSymmetry){\n            println(\"Yes\")\n            return\n        }\n        val midLine = Line.byTwoPoints(points[0], points[i])\n        isSymmetry = true\n        for (j in 1 .. n){\n            if (i != j && (midLine.isOnLine(points[j]) || midLine.symmetryPoint(points[j]) !in set)) {\n                isSymmetry = false\n                break\n            }\n        }\n    }\n    println(\"No\")\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n\tvoid run() throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolver();\n\t\tout.flush();\n\t\tif(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception { new Main().run(); }\n\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif(eq(this.dist,o.dist))ret=0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-2;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif(ord.length<3){\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t// tr(c * gy - a * gx - b, 0);\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0))\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\treturn rad;\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-2;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif(ord.length<3){\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t// tr(c * gy - a * gx - b, 0);\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0))\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\treturn rad;\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-4;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t\tif (angle[i] < EPS) {\n\t\t\t\tSystem.out.println(\"NO\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"YES\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (angle[(i + j) % angle.length] != angle[(i - 1 - j + angle.length) % angle.length]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && list.get(j).dist == 0) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\twhile (j + 1 < list.size() && list.get(j).angle == list.get(j + 1).angle\n\t\t\t\t\t\t\t\t&& list.get(j).dist == list.get(j + 1).dist) {\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\t\tSystem.out.println(\"YES!\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"NO\");\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\treturn Math.toDegrees(rad);\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n\tvoid run() throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolver();\n\t\tout.flush();\n\t\tif(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception { new Main().run(); }\n\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif(eq(this.dist,o.dist))ret=0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j < ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\t// showList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t\t// return dot_product(x1, y1, x2, y2) * dot_product(x1, y1, x2, y2) /\n\t\t// ((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-2;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t// tr(c * gy - a * gx - b, 0);\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0))\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\treturn rad;\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-4;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t\tif (angle[i] < EPS) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (angle[(i + j) % angle.length] != angle[(i - 1 - j + angle.length) % angle.length]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && list.get(j).dist == 0) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\twhile (j + 1 < list.size() && list.get(j).angle == list.get(j + 1).angle\n\t\t\t\t\t\t\t\t&& list.get(j).dist == list.get(j + 1).dist) {\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\treturn Math.toDegrees(rad);\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n\tvoid run() throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolver();\n\t\tout.flush();\n\t\tif(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception { new Main().run(); }\n\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif(eq(this.dist,o.dist))ret=0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t\t// return dot_product(x1, y1, x2, y2) * dot_product(x1, y1, x2, y2) /\n\t\t// ((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif(eq(this.dist,o.dist))ret=0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j < ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[(i + j) % angle.length], y[(i + j) % angle.length])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-4;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[(i + j) % angle.length], y[(i + j) % angle.length])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[(i + j) % angle.length], y[(i + j) % angle.length])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n//\t\tdouble rad = Math\n//\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n//\t\tSystem.out.println(rad);\n//\t\treturn rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n//\t\t\tSystem.out.println(angle.length);\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\t// showList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t\t// return dot_product(x1, y1, x2, y2) * dot_product(x1, y1, x2, y2) /\n\t\t// ((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-4;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t\tif (angle[i] < EPS) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (angle[(i + j) % angle.length] != angle[(i - 1 - j + angle.length) % angle.length]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && list.get(j).dist == 0) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\twhile (j + 1 < list.size() && list.get(j).angle == list.get(j + 1).angle\n\t\t\t\t\t\t\t\t&& list.get(j).dist == list.get(j + 1).dist) {\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\treturn Math.toDegrees(rad);\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\t// System.out.println(angle.length);\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i+angle.length / 2)%angle.length]], y[ord[(i+angle.length / 2)%angle.length]])){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\telse\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i+angle.length / 2)%angle.length]], y[ord[(i+angle.length / 2)%angle.length]])){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\t// showList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t\t// return dot_product(x1, y1, x2, y2) * dot_product(x1, y1, x2, y2) /\n\t\t// ((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-2;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t// tr(c * gy - a * gx - b, 0);\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0))\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\treturn rad;\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n\tvoid run() throws Exception {\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolver();\n\t\tout.flush();\n\t\tif (!INPUT.isEmpty())\n\t\t\ttr(System.currentTimeMillis() - s + \"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte() {\n\t\tif (lenbuf == -1)\n\t\t\tthrow new InputMismatchException();\n\t\tif (ptrbuf >= lenbuf) {\n\t\t\tptrbuf = 0;\n\t\t\ttry {\n\t\t\t\tlenbuf = is.read(inbuf);\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new InputMismatchException();\n\t\t\t}\n\t\t\tif (lenbuf <= 0)\n\t\t\t\treturn -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) {\n\t\treturn !(c >= 33 && c <= 126);\n\t}\n\n\tprivate int skip() {\n\t\tint b;\n\t\twhile ((b = readByte()) != -1 && isSpaceChar(b))\n\t\t\t;\n\t\treturn b;\n\t}\n\n\tprivate double nd() {\n\t\treturn Double.parseDouble(ns());\n\t}\n\n\tprivate char nc() {\n\t\treturn (char) skip();\n\t}\n\n\tprivate String ns() {\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile (!(isSpaceChar(b))) { // when nextLine, (isSpaceChar(b) && b != '\n\t\t\t\t\t\t\t\t\t// ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n) {\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile (p < n && !(isSpaceChar(b))) {\n\t\t\tbuf[p++] = (char) b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n) {\n\t\tint[] a = new int[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n) {\n\t\tlong[] a = new long[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\ta[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tmap[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() {\n\t\treturn (int) nl();\n\t}\n\n\tprivate long nl() {\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile ((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'))\n\t\t\t;\n\t\tif (b == '-') {\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile (true) {\n\t\t\tif (b >= '0' && b <= '9') {\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t} else {\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\t// showList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif (eq(this.dist, o.dist))\n\t\t\t\tret = 0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n\tvoid run() throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolver();\n\t\tout.flush();\n\t\tif(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception { new Main().run(); }\n\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif(eq(this.dist,o.dist))ret=0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-4;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t\tif (angle[i] < EPS) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && list.get(j).dist == 0) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\twhile (j + 1 < list.size() &&eq( list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\treturn Math.toDegrees(rad);\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-2;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t// tr(c * gy - a * gx - b, 0);\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[(i + j) % angle.length], y[(i + j) % angle.length])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[(i + j) % angle.length], y[(i + j) % angle.length])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0))\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\treturn rad;\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-2;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t\tif (angle[i] < EPS) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t// tr(c * gy - a * gx - b, 0);\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0))\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\treturn rad;\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j < ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) * dot_product(x1, y1, x2, y2) / ((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-4;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"NO\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t\tif (angle[i] < EPS) {\n\t\t\t\tSystem.out.println(\"No\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t\tif (!eq(gx, p[0]))\n\t\t\t\t\tcontinue;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t\tif (!eq(gy, a * gx + b))\n\t\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tboolean flag = true;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (angle[(i + j) % angle.length] != angle[(i - 1 - j + angle.length) % angle.length]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && list.get(j).dist == 0) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\twhile (j + 1 < list.size() && list.get(j).angle == list.get(j + 1).angle\n\t\t\t\t\t\t\t\t&& list.get(j).dist == list.get(j + 1).dist) {\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\treturn Math.toDegrees(rad);\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n\tvoid run() throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolver();\n\t\tout.flush();\n\t\tif(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception { new Main().run(); }\n\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif(eq(this.dist,o.dist))ret=0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n//\t\t\tSystem.out.println(angle.length);\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\t// showList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t\t// return dot_product(x1, y1, x2, y2) * dot_product(x1, y1, x2, y2) /\n\t\t// ((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-2;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t// tr(c * gy - a * gx - b, 0);\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\n\t\t\tfor (int j = 1; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[(i + j) % angle.length], y[(i + j) % angle.length])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout:if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!eq(c * gy - a * gx - b, 0))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[(i + j) % angle.length], y[(i + j) % angle.length])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\tdouble rad = Math\n\t\t\t\t.acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\treturn rad;\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static void main(String[] args) {\n\t\tnew Main().solver();\n\n\t}\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint N = sc.nextInt();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tSystem.out.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j < ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 0 && ord[angle.length / 2] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - x[ord[i]], y[j] - y[ord[i]], 1, -a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif(!onLine(a,b,c,gx,gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j] || (angle.length % 2 == 1 && ord[angle.length / 2 + 1] == j)) {\n\t\t\t\t\t\tlist.add(new Pair(angle(x[j] - p[0], y[j] - p[1], 1, a),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tSystem.out.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tvoid run() throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\t\t\n\t\tlong s = System.currentTimeMillis();\n\t\tsolver();\n\t\tout.flush();\n\t\tif(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n//\t\tThread t = new Thread(null, null, \"~\", Runtime.getRuntime().maxMemory()){\n//\t\t\t@Override\n//\t\t\tpublic void run() {\n//\t\t\t\tlong s = System.currentTimeMillis();\n//\t\t\t\tsolve();\n//\t\t\t\tout.flush();\n//\t\t\t\tif(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n//\t\t\t}\n//\t\t};\n//\t\tt.start();\n//\t\tt.join();\n\t}\n\t\n\tpublic static void main(String[] args) throws Exception { new Main().run(); }\n\t\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\t\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\t\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\t\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\t\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\t\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\t\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\t\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\t\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\t\n\tprivate int ni() { return (int)nl(); }\n\t\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\t\t\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\t\n\n\t\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\t\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\t// ax+b-cy=0;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\t// double rad = Math\n\t\t// .acos(dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) *\n\t\t// Math.sqrt(x2 * x2 + y2 * y2)));\n\t\t// return Math.toDegrees(rad);\n\t\t// System.out.println(rad);\n\t\t// return rad;\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t\t// return dot_product(x1, y1, x2, y2) * dot_product(x1, y1, x2, y2) /\n\t\t// ((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif(eq(this.dist,o.dist))ret=0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Line2D;\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.InputMismatchException;\n\npublic class Main {\n\n\tvoid run() throws Exception\n\t{\n\t\tis = INPUT.isEmpty() ? System.in : new ByteArrayInputStream(INPUT.getBytes());\n\t\tout = new PrintWriter(System.out);\n\n\t\tlong s = System.currentTimeMillis();\n\t\tsolver();\n\t\tout.flush();\n\t\tif(!INPUT.isEmpty())tr(System.currentTimeMillis()-s+\"ms\");\n\t}\n\n\tpublic static void main(String[] args) throws Exception { new Main().run(); }\n\n\tprivate byte[] inbuf = new byte[1024];\n\tprivate int lenbuf = 0, ptrbuf = 0;\n\n\tprivate int readByte()\n\t{\n\t\tif(lenbuf == -1)throw new InputMismatchException();\n\t\tif(ptrbuf >= lenbuf){\n\t\t\tptrbuf = 0;\n\t\t\ttry { lenbuf = is.read(inbuf); } catch (IOException e) { throw new InputMismatchException(); }\n\t\t\tif(lenbuf <= 0)return -1;\n\t\t}\n\t\treturn inbuf[ptrbuf++];\n\t}\n\n\tprivate boolean isSpaceChar(int c) { return !(c >= 33 && c <= 126); }\n\tprivate int skip() { int b; while((b = readByte()) != -1 && isSpaceChar(b)); return b; }\n\n\tprivate double nd() { return Double.parseDouble(ns()); }\n\tprivate char nc() { return (char)skip(); }\n\n\tprivate String ns()\n\t{\n\t\tint b = skip();\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(!(isSpaceChar(b))){ // when nextLine, (isSpaceChar(b) && b != ' ')\n\t\t\tsb.appendCodePoint(b);\n\t\t\tb = readByte();\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tprivate char[] ns(int n)\n\t{\n\t\tchar[] buf = new char[n];\n\t\tint b = skip(), p = 0;\n\t\twhile(p < n && !(isSpaceChar(b))){\n\t\t\tbuf[p++] = (char)b;\n\t\t\tb = readByte();\n\t\t}\n\t\treturn n == p ? buf : Arrays.copyOf(buf, p);\n\t}\n\n\tprivate int[] na(int n)\n\t{\n\t\tint[] a = new int[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = ni();\n\t\treturn a;\n\t}\n\n\tprivate long[] nal(int n)\n\t{\n\t\tlong[] a = new long[n];\n\t\tfor(int i = 0;i < n;i++)a[i] = nl();\n\t\treturn a;\n\t}\n\n\tprivate char[][] nm(int n, int m) {\n\t\tchar[][] map = new char[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = ns(m);\n\t\treturn map;\n\t}\n\n\tprivate int[][] nmi(int n, int m) {\n\t\tint[][] map = new int[n][];\n\t\tfor(int i = 0;i < n;i++)map[i] = na(m);\n\t\treturn map;\n\t}\n\n\tprivate int ni() { return (int)nl(); }\n\n\tprivate long nl()\n\t{\n\t\tlong num = 0;\n\t\tint b;\n\t\tboolean minus = false;\n\t\twhile((b = readByte()) != -1 && !((b >= '0' && b <= '9') || b == '-'));\n\t\tif(b == '-'){\n\t\t\tminus = true;\n\t\t\tb = readByte();\n\t\t}\n\n\t\twhile(true){\n\t\t\tif(b >= '0' && b <= '9'){\n\t\t\t\tnum = num * 10 + (b - '0');\n\t\t\t}else{\n\t\t\t\treturn minus ? -num : num;\n\t\t\t}\n\t\t\tb = readByte();\n\t\t}\n\t}\n\n\n\n\tInputStream is;\n\tPrintWriter out;\n\tString INPUT = \"\";\n\n\tdouble EPS = 1e-7;\n\n\tvoid solver() {\n\t\tint N = ni();\n\t\tdouble gx = 0, gy = 0;\n\t\tdouble[] x = new double[N];\n\t\tdouble[] y = new double[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = ni();\n\t\t\ty[i] = ni();\n\t\t\tgx += x[i];\n\t\t\tgy += y[i];\n\t\t}\n\t\tgx /= N;\n\t\tgy /= N;\n\t\tint[] ord = convexHull(x, y);\n\t\tif (ord.length < 3) {\n\t\t\tout.println(\"No\");\n\t\t\treturn;\n\t\t}\n\t\tboolean[] vertex_of_convexHull = new boolean[N];\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tvertex_of_convexHull[ord[i]] = true;\n\t\t}\n\n\t\tdouble[] angle = new double[ord.length];\n\n\t\tfor (int i = 0; i < ord.length; i++) {\n\t\t\tint n0 = ord[i];\n\t\t\tint n1 = ord[(i - 1 + ord.length) % ord.length];\n\t\t\tint n2 = ord[(i + 1) % ord.length];\n\t\t\tangle[i] = angle((x[n1] - x[n0]), (y[n1] - y[n0]), (x[n2] - x[n0]), (y[n2] - y[n0]));\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[(i + 1) % angle.length]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[(i + 1) % angle.length]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// the formula for the pseudo symmetric line\n\t\t\tdouble dy = (p[1] - y[ord[(i + 1) % ord.length]]);\n\t\t\tdouble dx = p[0] - x[ord[(i + 1) % ord.length]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 1;\n\t\t\tfor (int j = 1; j <= ((angle.length % 2 == 0) ? -1 : 0) + angle.length / 2; j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[(i - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 0 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t} else\n\t\t\t\ton_symmetric_line++;\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair(\n\t\t\t\t\t\t\t\t(x[j] - x[ord[i]]) * (x[j] - x[ord[i]]) + (y[j] - y[ord[i]]) * (y[j] - y[ord[i]]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < angle.length; i++) {\n\t\t\t// the middle point between p_(i+1) and p_(i-1)\n\t\t\tdouble[] p = { (x[ord[i]] + x[ord[(i - 1 + angle.length) % angle.length]]) / 2.0,\n\t\t\t\t\t(y[ord[i]] + y[ord[(i - 1 + angle.length) % angle.length]]) / 2.0 };\n\t\t\t// The symmetric line must go on the center of gravity\n\t\t\tdouble dy = p[1] - y[ord[i]];\n\t\t\tdouble dx = p[0] - x[ord[i]];\n\t\t\tdouble a, b, c;\n\t\t\tif (dy == 0) {\n\t\t\t\ta = 1;\n\t\t\t\tb = -p[0];\n\t\t\t\tc = 0;\n\t\t\t} else {\n\t\t\t\ta = -dx / dy;\n\t\t\t\tb = -a * p[0] + p[1];\n\t\t\t\tc = 1;\n\t\t\t}\n\t\t\tif (!onLine(a, b, c, gx, gy))\n\t\t\t\tcontinue;\n\t\t\tboolean flag = true;\n\t\t\tint on_symmetric_line = 0;\n\t\t\tfor (int j = 0; j < angle.length / 2 + (angle.length % 2 == 1 ? -1 : 0); j++) {\n\t\t\t\tif (!eq(angle[(i + j) % angle.length], angle[((i - 1) - j + angle.length) % angle.length])) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif (onLine(a, b, c, x[ord[(i + j) % angle.length]], y[ord[(i + j) % angle.length]])) {\n\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\tif (on_symmetric_line >= 3) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (angle.length % 2 == 1 && !onLine(a, b, c, x[ord[(i + angle.length / 2) % angle.length]],\n\t\t\t\t\ty[ord[(i + angle.length / 2) % angle.length]])) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tout: if (flag) {\n\t\t\t\tArrayList<Pair> list = new ArrayList<>();\n\t\t\t\tfor (int j = 0; j < N; j++) {\n\t\t\t\t\tif (!vertex_of_convexHull[j]) {\n\t\t\t\t\t\tlist.add(new Pair((x[j] - p[0]) * (x[j] - p[0]) + (y[j] - p[1]) * (y[j] - p[1]),\n\t\t\t\t\t\t\t\tMath.abs(a * x[j] + b - c * y[j]) / (Math.sqrt(a * a + c * c))));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.sort(null);\n//\t\t\t\tshowList(list);\n\t\t\t\tfor (int j = 0; j < list.size(); j++) {\n\t\t\t\t\twhile (list.size() > 0 && eq(list.get(j).dist, 0)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\ton_symmetric_line++;\n\t\t\t\t\t\tif (on_symmetric_line >= 3)\n\t\t\t\t\t\t\tbreak out;\n\t\t\t\t\t}\n\t\t\t\t\twhile (j + 1 < list.size() && eq(list.get(j).angle, list.get(j + 1).angle)\n\t\t\t\t\t\t\t&& eq(list.get(j).dist, list.get(j + 1).dist)) {\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t\tlist.remove(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (list.isEmpty()) {\n\t\t\t\t\tout.println(\"Yes\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tout.println(\"No\");\n\n\t}\n\n\tdouble angle(double x1, double y1, double x2, double y2) {\n\t\treturn dot_product(x1, y1, x2, y2) / (Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2));\n\t}\n\n\tdouble dot_product(double x1, double y1, double x2, double y2) {\n\t\treturn x1 * x2 + y1 * y2;\n\t}\n\n\tpublic static int[] convexHull(final double[] x, final double[] y) {\n\t\tint n = x.length;\n\t\tInteger[] ord = new Integer[n];\n\t\tfor (int i = 0; i < n; i++)\n\t\t\tord[i] = i;\n\t\tArrays.sort(ord, new Comparator<Integer>() {\n\t\t\t@Override\n\t\t\tpublic int compare(Integer a, Integer b) {\n\t\t\t\tif (x[a] != x[b])\n\t\t\t\t\treturn x[a] < x[b] ? -1 : 1;\n\t\t\t\tif (y[a] != y[b])\n\t\t\t\t\treturn y[a] < y[b] ? -1 : 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t});\n\n\t\tint[] ret = new int[n + 1];\n\t\tint p = 0;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (p >= 1 && x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= 2 && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\tint inf = p + 1;\n\t\tfor (int i = n - 2; i >= 0; i--) {\n\t\t\tif (x[ret[p - 1]] == x[ord[i]] && y[ret[p - 1]] == y[ord[i]])\n\t\t\t\tcontinue;\n\t\t\twhile (p >= inf && Line2D.relativeCCW(x[ret[p - 2]], y[ret[p - 2]], x[ret[p - 1]], y[ret[p - 1]], x[ord[i]],\n\t\t\t\t\ty[ord[i]]) == 1)\n\t\t\t\tp--;\n\t\t\tret[p++] = ord[i];\n\t\t}\n\n\t\treturn Arrays.copyOf(ret, p - 1);\n\t}\n\n\tvoid tr(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tclass Pair implements Comparable<Pair> {\n\t\tdouble angle;\n\t\tdouble dist;\n\n\t\tPair(double angle, double dist) {\n\t\t\tthis.angle = angle;\n\t\t\tthis.dist = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Pair o) {\n\t\t\tint ret = Double.compare(this.dist, o.dist);\n\t\t\tif(eq(this.dist,o.dist))ret=0;\n\t\t\treturn (ret != 0) ? ret : Double.compare(this.angle, o.angle);\n\t\t}\n\t}\n\n\tboolean eq(double a, double b) {\n\t\treturn Math.abs(a - b) < EPS;\n\t}\n\n\tboolean onLine(double a, double b, double c, double x, double y) {\n\t\treturn eq(c * y - a * x - b, 0);\n\t}\n\n\tvoid showList(ArrayList<Pair> list) {\n\t\tfor (int i = 0; i < list.size(); i++) {\n\t\t\tSystem.out.println(list.get(i).angle + \" \" + list.get(i).dist);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "include Math\n\nn = gets.to_i\npoints = (1..n).map { gets.split.map(&:to_i) }\n\nif (2..n-1).all? {|i|\n  (points[1][1] - points[0][1]) * (points[i][0] - points[0][0]) ==\n  (points[i][1] - points[0][1]) * (points[1][0] - points[0][0])\n}\n  puts 'No'\n  exit\nend\n\ncenter = [points.map(&:first).inject(:+) / n.to_f, points.map(&:last).inject(:+) / n.to_f]\npoints.map! {|x, y| [x - center[0], y - center[1]] }\npoints.reject! {|x, y| x.abs + y.abs < 1e-5 }\npoints.sort_by! {|x, y| atan2(y, x) }\n\na = []\npoints.each {|point| a << point }\npoints.each_cons(2) {|p1, p2| a << [(p1[0] + p2[0]) / 2.0, (p1[1] + p2[1]) / 2.0] }\na << [(points[-1][0] + points[0][0]) / 2.0, (points[-1][1] + points[0][1]) / 2.0]\n\nret = false\na.each do |x0, y0|\n  t = atan2(y0, x0)\n\n  rotated = points.map {|x, y| [cos(-t) * x - sin(-t) * y, sin(-t) * x + cos(-t) * y] }\n  rotated.map! {|x, y| [x.round(5), y.round(5)] }\n  rotated.reject! {|_, y| y.abs < 1e-5 }\n  next if rotated.size < n - 2\n  upper_points, lower_points = rotated.partition {|_, y| y > 0 }\n  next if upper_points.empty? || lower_points.empty?\n  next if upper_points.size != lower_points.size\n  turned_lower_points = lower_points.map {|x, y| [x, -y] }\n  upper_points.sort!\n  turned_lower_points.sort!\n  if upper_points.zip(turned_lower_points).all? {|p1, p2| (p1[0] - p2[0]).abs + (p1[1] - p2[1]).abs < 1e-5 }\n    ret = true\n    break\n  end\nend\nputs ret ? 'Yes' : 'No'\n\n"
  },
  {
    "language": "Python",
    "code": "from collections import defaultdict\nimport sys\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\ndef gcd(m, n):\n    while n:\n        m, n = n, m % n\n    return m\ndef solve():\n    N = int(readline())\n    P = [list(map(int, readline().split())) for i in range(N)]\n    ok = 0\n    x0, y0 = P[0]; x1, y1 = P[1]\n    for i in range(2, N):\n        x2, y2 = P[i]\n        if (x1 - x0) * (y2 - y0) != (x2 - x0) * (y1 - y0):\n            ok = 1\n            break\n    if not ok:\n        write(\"No\\n\")\n        return\n    A = defaultdict(int)\n    B = defaultdict(int)\n    for i in range(N):\n        xi, yi = P[i]\n        for j in range(i):\n            xj, yj = P[j]\n            dx = xi - xj; dy = yi - yj\n            g = gcd(abs(dx), abs(dy))\n            dx //= g; dy //= g\n            if dy < 0:\n                dx = -dx; dy = -dy\n            if dx == 0:\n                p = xi * dy - yi * dx; q = dy\n                g = gcd(abs(p), abs(q))\n                p //= g; q //= g\n                if q < 0:\n                    q = -q; p = -p\n                key = (p, 0, q, dx, dy)\n            else:\n                p = yi * dx - xi * dy; q = dx\n                g = gcd(abs(p), abs(q))\n                p //= g; q //= g\n                if q < 0:\n                    q = -q; p = -p\n                key = (0, p, q, dx, dy)\n            A[key] += 1\n\n            gx = -dy; gy = dx\n            if gy < 0:\n                gx = -gx; gy = -gy\n            if dy == 0:\n                p = dy * (yi + yj) + dx * (xi + xj)\n                q = 2 * dx\n                g = gcd(abs(p), abs(q))\n                p //= g; q //= g\n                if q < 0:\n                    q = -q; p = -p\n                key = (p, 0, q, gx, gy)\n            else:\n                p = dx * (xi + xj) + dy * (yi + yj)\n                q = 2 * dy\n                g = gcd(abs(p), abs(q))\n                p //= g; q //= g\n                if q < 0:\n                    q = -q; p = -p\n                key = (0, p, q, gx, gy)\n            B[key] += 1\n    ok = 0\n    if N % 2 == 0:\n        for k, v in B.items():\n            if 2*v == N:\n                ok = 1\n                break\n            if 2*v == N-2:\n                if A[k] == 1:\n                    ok = 1\n                    break\n    else:\n        R = []\n        for k, v in B.items():\n            if 2*v+1 == N:\n                R.append(k)\n        ok = 0\n        for x0, y0, z0, dx, dy in R:\n            cnt = 0\n            for x, y in P:\n                if dy*(x*z0 - x0) == dx*(y*z0 - y0):\n                    cnt += 1\n            if cnt == 1:\n                ok = 1\n                break\n    if ok:\n        write(\"Yes\\n\")\n    else:\n        write(\"No\\n\")\nsolve()\n"
  }
]