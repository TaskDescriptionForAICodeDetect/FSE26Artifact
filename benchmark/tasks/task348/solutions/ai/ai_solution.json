[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\nPoint points[1000];\nint n;\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nint cmp(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->x != p2->x) return (p1->x > p2->x) ? 1 : -1;\n    return (p1->y > p2->y) ? 1 : -1;\n}\n\nvoid convexHull(Point *points, int n, Point *hull, int *hull_size) {\n    qsort(points, n, sizeof(Point), cmp);\n    *hull_size = 0;\n    for (int i = 0; i < n; i++) {\n        while (*hull_size >= 2 && cross(hull[*hull_size - 2], hull[*hull_size - 1], points[i]) <= 0) {\n            (*hull_size)--;\n        }\n        hull[(*hull_size)++] = points[i];\n    }\n    int lower = *hull_size;\n    for (int i = n - 2; i >= 0; i--) {\n        while (*hull_size > lower && cross(hull[*hull_size - 2], hull[*hull_size - 1], points[i]) <= 0) {\n            (*hull_size)--;\n        }\n        hull[(*hull_size)++] = points[i];\n    }\n    (*hull_size)--;\n}\n\nint isReflection(Point a, Point b, Point p, Point q) {\n    double dx = b.x - a.x;\n    double dy = b.y - a.y;\n    double det = dx * dx + dy * dy;\n    if (det == 0) return 0;\n    double a1 = (dx * dx - dy * dy) / det;\n    double a2 = 2 * dx * dy / det;\n    double x = a1 * (p.x - a.x) + a2 * (p.y - a.y) + a.x;\n    double y = a2 * (p.x - a.x) - a1 * (p.y - a.y) + a.y;\n    return fabs(x - q.x) < 1e-9 && fabs(y - q.y) < 1e-9;\n}\n\nint isSymmetric(Point *hull, int hull_size) {\n    for (int i = 0; i < hull_size; i++) {\n        int j = (i + 1) % hull_size;\n        int symmetric = 1;\n        for (int k = 0; k < hull_size; k++) {\n            int l = (2 * i - k + hull_size) % hull_size;\n            if (!isReflection(hull[i], hull[j], hull[k], hull[l])) {\n                symmetric = 0;\n                break;\n            }\n        }\n        if (symmetric) return 1;\n    }\n    return 0;\n}\n\nint main() {\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n        }\n        Point hull[1000];\n        int hull_size;\n        convexHull(points, n, hull, &hull_size);\n        if (hull_size != n) {\n            printf(\"NO\\n\");\n            continue;\n        }\n        if (isSymmetric(hull, hull_size)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <complex>\nusing namespace std;\n\ntypedef complex<double> Point;\nconst double EPS = 1e-8;\n\nnamespace std {\n    bool operator<(const Point& a, const Point& b) {\n        return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n    }\n}\n\ndouble cross(const Point& a, const Point& b) {\n    return imag(conj(a)*b);\n}\n\ndouble dot(const Point& a, const Point& b) {\n    return real(conj(a)*b);\n}\n\nint ccw(Point a, Point b, Point c) {\n    b -= a; c -= a;\n    if (cross(b, c) > EPS) return 1;   // counter clockwise\n    if (cross(b, c) < -EPS) return -1; // clockwise\n    if (dot(b, c) < -EPS) return 2;    // c--a--b on line\n    if (norm(b) < norm(c)) return -2;  // a--b--c on line\n    return 0;                          // a--c--b on line\n}\n\nvector<Point> convex_hull(vector<Point> ps) {\n    int n = ps.size(), k = 0;\n    sort(ps.begin(), ps.end());\n    vector<Point> ch(2*n);\n    for (int i = 0; i < n; ch[k++] = ps[i++])\n        while (k >= 2 && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    for (int i = n-2, t = k+1; i >= 0; ch[k++] = ps[i--])\n        while (k >= t && ccw(ch[k-2], ch[k-1], ps[i]) <= 0) --k;\n    ch.resize(k-1);\n    return ch;\n}\n\nbool is_line_symmetric(const vector<Point>& poly) {\n    int n = poly.size();\n    for (int i = 0; i <= n/2; ++i) {\n        Point p1 = poly[i];\n        Point p2 = poly[(i+1)%n];\n        Point mid = (p1 + p2) * 0.5;\n        Point dir = p2 - p1;\n        Point normal = Point(-imag(dir), real(dir));\n        bool ok = true;\n        for (int j = 0; j < n; ++j) {\n            Point p = poly[j];\n            Point vec = p - mid;\n            double dot_val = dot(vec, normal);\n            Point reflected = p - 2.0 * dot_val / norm(normal) * normal;\n            bool found = false;\n            for (const Point& q : poly) {\n                if (abs(q - reflected) < EPS) {\n                    found = true;\n                    break;\n                }\n            }\n            if (!found) {\n                ok = false;\n                break;\n            }\n        }\n        if (ok) return true;\n    }\n    return false;\n}\n\nint main() {\n    int n;\n    while (cin >> n, n != 0) {\n        vector<Point> points(n);\n        for (int i = 0; i < n; ++i) {\n            double x, y;\n            cin >> x >> y;\n            points[i] = Point(x, y);\n        }\n        vector<Point> hull = convex_hull(points);\n        if (hull.size() != points.size()) {\n            cout << \"NO\" << endl;\n            continue;\n        }\n        if (is_line_symmetric(hull)) {\n            cout << \"YES\" << endl;\n        } else {\n            cout << \"NO\" << endl;\n        }\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 21:11:57"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.Point2D;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            Point2D.Double[] points = new Point2D.Double[n];\n            for (int i = 0; i < n; i++) {\n                double x = scanner.nextDouble();\n                double y = scanner.nextDouble();\n                points[i] = new Point2D.Double(x, y);\n            }\n            System.out.println(isLineSymmetric(points) ? \"YES\" : \"NO\");\n        }\n        scanner.close();\n    }\n\n    private static boolean isLineSymmetric(Point2D.Double[] points) {\n        int n = points.length;\n        for (int i = 0; i <= n; i++) {\n            Point2D.Double p1 = points[i % n];\n            Point2D.Double p2 = points[(i + 1) % n];\n            double dx = p2.x - p1.x;\n            double dy = p2.y - p1.y;\n            double a = -dy;\n            double b = dx;\n            double c = -a * p1.x - b * p1.y;\n            if (isReflectionSymmetric(points, a, b, c)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isReflectionSymmetric(Point2D.Double[] points, double a, double b, double c) {\n        Set<Point2D.Double> reflected = new HashSet<>();\n        for (Point2D.Double p : points) {\n            double x = p.x;\n            double y = p.y;\n            double denom = a * a + b * b;\n            if (denom == 0) continue;\n            double xRef = x - 2 * a * (a * x + b * y + c) / denom;\n            double yRef = y - 2 * b * (a * x + b * y + c) / denom;\n            reflected.add(new Point2D.Double(xRef, yRef));\n        }\n        for (Point2D.Double p : points) {\n            if (!reflected.contains(p)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}",
    "timestamp": "2025-08-05 21:12:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class LineSymmetricPolygon {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            \n            Point[] points = new Point[n];\n            for (int i = 0; i < n; i++) {\n                points[i] = new Point(scanner.nextInt(), scanner.nextInt());\n            }\n            \n            System.out.println(isLineSymmetric(points) ? \"YES\" : \"NO\");\n        }\n        \n        scanner.close();\n    }\n    \n    static boolean isLineSymmetric(Point[] points) {\n        // Find the potential line of symmetry\n        Point midPoint = findMidPoint(points);\n        \n        // Check if each point has a symmetric counterpart\n        for (int i = 0; i < points.length; i++) {\n            Point symmetricPoint = getSymmetricPoint(points[i], midPoint);\n            if (!containsPoint(points, symmetricPoint)) {\n                return false;\n            }\n        }\n        \n        // Check if polygon is valid\n        return isValidPolygon(points);\n    }\n    \n    static Point findMidPoint(Point[] points) {\n        int minX = Integer.MAX_VALUE, maxX = Integer.MIN_VALUE;\n        int minY = Integer.MAX_VALUE, maxY = Integer.MIN_VALUE;\n        \n        for (Point p : points) {\n            minX = Math.min(minX, p.x);\n            maxX = Math.max(maxX, p.x);\n            minY = Math.min(minY, p.y);\n            maxY = Math.max(maxY, p.y);\n        }\n        \n        return new Point((minX + maxX) / 2, (minY + maxY) / 2);\n    }\n    \n    static Point getSymmetricPoint(Point p, Point midPoint) {\n        return new Point(\n            2 * midPoint.x - p.x, \n            2 * midPoint.y - p.y\n        );\n    }\n    \n    static boolean containsPoint(Point[] points, Point target) {\n        for (Point p : points) {\n            if (p.x == target.x && p.y == target.y) {\n                return true;\n            }\n        }\n        return false;\n    }\n    \n    static boolean isValidPolygon(Point[] points) {\n        int n = points.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 2; j < n; j++) {\n                if (j == n - 1 && i == 0) continue;\n                if (lineIntersect(points[i], points[(i+1)%n], \n                                  points[j], points[(j+1)%n])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    \n    static boolean lineIntersect(Point p1, Point p2, Point p3, Point p4) {\n        int o1 = orientation(p1, p2, p3);\n        int o2 = orientation(p1, p2, p4);\n        int o3 = orientation(p3, p4, p1);\n        int o4 = orientation(p3, p4, p2);\n        \n        if (o1 != o2 && o3 != o4) return true;\n        return false;\n    }\n    \n    static int orientation(Point p, Point q, Point r) {\n        int val = (q.y - p.y) * (r.x - q.x) - \n                  (q.x - p.x) * (r.y - q.y);\n        \n        if (val == 0) return 0;\n        return (val > 0) ? 1 : 2;\n    }\n    \n    static class Point {\n        int x, y;\n        Point(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n}",
    "timestamp": "2025-08-05 21:12:31"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdbool.h>\n\n#define MAX_POINTS 1000\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\ndouble distance(Point a, Point b) {\n    return sqrt((a.x - b.x) * (a.x - b.x) + (a.y - b.y) * (a.y - b.y));\n}\n\nbool line_segments_intersect(Point a, Point b, Point c, Point d) {\n    double cp1 = cross_product(a, b, c);\n    double cp2 = cross_product(a, b, d);\n    double cp3 = cross_product(c, d, a);\n    double cp4 = cross_product(c, d, b);\n\n    if (fabs(cp1) < EPS && fabs(cp2) < EPS && fabs(cp3) < EPS && fabs(cp4) < EPS) {\n        return false;\n    }\n\n    return (cp1 * cp2 <= 0) && (cp3 * cp4 <= 0);\n}\n\nbool is_symmetric_polygon(Point points[], int n) {\n    for (int axis = 0; axis < n; axis++) {\n        Point mid_line_start = points[axis];\n        Point mid_line_end = points[(axis + n/2) % n];\n\n        bool symmetric = true;\n        for (int i = 0; i < n/2; i++) {\n            Point p1 = points[i];\n            Point p2 = points[(i + n/2) % n];\n\n            // Check if distances are equal\n            if (fabs(distance(mid_line_start, p1) - distance(mid_line_end, p2)) > EPS) {\n                symmetric = false;\n                break;\n            }\n\n            // Check for intersections\n            for (int j = 0; j < n; j++) {\n                if (j == i || j == (i + n/2) % n || \n                    j == (i + 1) % n || j == (i + n/2 + 1) % n) continue;\n\n                Point e1_start = points[j];\n                Point e1_end = points[(j + 1) % n];\n\n                if (line_segments_intersect(p1, p2, e1_start, e1_end)) {\n                    symmetric = false;\n                    break;\n                }\n            }\n\n            if (!symmetric) break;\n        }\n\n        if (symmetric) return true;\n    }\n\n    return false;\n}\n\nint main() {\n    int n;\n    while (1) {\n        scanf(\"%d\", &n);\n        if (n == 0) break;\n        if (n % 2 != 0) {\n            printf(\"No\\n\");\n            continue;\n        }\n\n        Point points[MAX_POINTS];\n        for (int i = 0; i < n; i++) {\n            scanf(\"%lf %lf\", &points[i].x, &points[i].y);\n        }\n\n        printf(\"%s\\n\", is_symmetric_polygon(points, n) ? \"Yes\" : \"No\");\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:42"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <iomanip>\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator-(const Point& p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool arePointsEqual(const Point& a, const Point& b) {\n    return std::abs(a.x - b.x) < EPS && std::abs(a.y - b.y) < EPS;\n}\n\nbool isLinearlyDependent(const Point& a, const Point& b, const Point& c) {\n    return std::abs(cross(b - a, c - a)) < EPS;\n}\n\nbool checkSymmetry(std::vector<Point>& points) {\n    int n = points.size();\n    if (n < 3) return false;\n    \n    // Find axis of symmetry\n    Point midPoint((points[0].x + points[n/2].x) / 2, \n                   (points[0].y + points[n/2].y) / 2);\n    \n    // Reflect and compare points\n    for (int i = 0; i < n/2; ++i) {\n        Point reflected(\n            2 * midPoint.x - points[i].x,\n            2 * midPoint.y - points[i].y\n        );\n        \n        bool found = false;\n        for (int j = n/2; j < n; ++j) {\n            if (arePointsEqual(reflected, points[j])) {\n                found = true;\n                break;\n            }\n        }\n        \n        if (!found) return false;\n    }\n    \n    // Check non-linearity and polygon conditions\n    for (int i = 0; i < n; ++i) {\n        int j = (i + 1) % n;\n        int k = (i + 2) % n;\n        if (isLinearlyDependent(points[i], points[j], points[k])) \n            return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    int n;\n    while (true) {\n        std::cin >> n;\n        if (n == 0) break;\n        \n        std::vector<Point> points(n);\n        for (int i = 0; i < n; ++i) {\n            std::cin >> points[i].x >> points[i].y;\n        }\n        \n        std::sort(points.begin(), points.end(), \n            [](const Point& a, const Point& b) {\n                return a.x < b.x || (a.x == b.x && a.y < b.y);\n            });\n        \n        if (checkSymmetry(points)) {\n            std::cout << \"YES\" << std::endl;\n        } else {\n            std::cout << \"NO\" << std::endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 21:12:52"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_symmetric_polygon(points):\n    n = len(points)\n    if n < 3 or n % 2 != 0:\n        return False\n\n    # Sorting points lexicographically\n    points.sort()\n\n    # Checking symmetry with respect to a line between two middle points\n    for i in range(n//2):\n        if points[i] != tuple((points[n-i-1][0], points[i][1])):\n            return False\n            \n    return True\n\ndef main():\n    import sys\n    input = sys.stdin.read().strip().split(\"\\n\")\n    \n    data_sets = []\n    current_set = []\n    for line in input:\n        if line.strip() == '0':\n            break\n        current_set.append(tuple(map(int, line.strip().split())))\n    data_sets.append(current_set)\n\n    for points in data_sets:\n        if is_symmetric_polygon(points):\n            print(\"YES\")\n        else:\n            print(\"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:19:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\nimport java.awt.geom.Line2D;\n\npublic class LineSymmetricPolygon {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        while (true) {\n            int n = scanner.nextInt();\n            if (n == 0) break;\n            Point[] points = new Point[n];\n            for (int i = 0; i < n; i++) {\n                points[i] = new Point(scanner.nextInt(), scanner.nextInt());\n            }\n            if (isLineSymmetricPolygon(points)) {\n                System.out.println(\"YES\");\n            } else {\n                System.out.println(\"NO\");\n            }\n        }\n        scanner.close();\n    }\n\n    static class Point {\n        int x, y;\n        Point(int x, int y) { this.x = x; this.y = y; }\n    }\n\n    private static boolean isLineSymmetricPolygon(Point[] points) {\n        if (!isSimplePolygon(points)) {\n            return false;\n        }\n        int n = points.length;\n        if (n % 2 != 0) {\n            return false;\n        }\n        for (int i = 0; i < n / 2; i++) {\n            if (!isSymmetric(points[i], points[i + n / 2], findCentroid(points))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private static boolean isSymmetric(Point p1, Point p2, Point centroid) {\n        return (p1.x + p2.x == 2 * centroid.x) && (p1.y + p2.y == 2 * centroid.y);\n    }\n\n    private static Point findCentroid(Point[] points) {\n        int n = points.length;\n        double cx = 0, cy = 0;\n        double signedArea = 0;\n        double x0, y0, x1, y1;\n        double a;\n        for (int i = 0; i < n; i++) {\n            x0 = points[i].x;\n            y0 = points[i].y;\n            x1 = points[(i + 1) % n].x;\n            y1 = points[(i + 1) % n].y;\n            a = x0 * y1 - x1 * y0;\n            signedArea += a;\n            cx += (x0 + x1) * a;\n            cy += (y0 + y1) * a;\n        }\n        signedArea *= 0.5;\n        cx /= (6.0 * signedArea);\n        cy /= (6.0 * signedArea);\n        return new Point((int) Math.round(cx), (int) Math.round(cy));\n    }\n\n    private static boolean isSimplePolygon(Point[] points) {\n        int n = points.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int nextI = (i + 1) % n;\n                int nextJ = (j + 1) % n;\n                if (i == nextJ || nextI == j) continue;\n                if (linesIntersect(points[i], points[nextI], points[j], points[nextJ])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    private static boolean linesIntersect(Point p1, Point q1, Point p2, Point q2) {\n        return Line2D.linesIntersect(\n                p1.x, p1.y, q1.x, q1.y,\n                p2.x, p2.y, q2.x, q2.y\n        );\n    }\n}",
    "timestamp": "2025-08-13 05:19:29"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint compare(const void *a, const void *b) {\n    Point *p1 = (Point *)a;\n    Point *p2 = (Point *)b;\n    if (p1->x != p2->x)\n        return p1->x - p2->x;\n    return p1->y - p2->y;\n}\n\nint is_mirrored(Point *pts, int n) {\n    qsort(pts, n, sizeof(Point), compare);\n\n    for (int i = 0; i < n / 2; i++) {\n        int j = n - i - 1;\n        if (pts[i].x + pts[j].x != 2 * pts[n / 2].x || pts[i].y != pts[j].y)\n            return 0;\n    }\n    return 1;\n}\n\nint main() {\n    int n;\n    while (scanf(\"%d\", &n), n != 0) {\n        Point *points = (Point *)malloc(n * sizeof(Point));\n        for (int i = 0; i < n; i++) {\n            scanf(\"%d %d\", &points[i].x, &points[i].y);\n        }\n\n        if (n % 2 != 0) {\n            printf(\"NO\\n\");\n        } else if (is_mirrored(points, n)) {\n            printf(\"YES\\n\");\n        } else {\n            printf(\"NO\\n\");\n        }\n        free(points);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 05:19:37"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_symmetric_polygon(points):\n    n = len(points)\n    if n < 3:\n        return False\n    \n    def is_line_symmetric(line_axis):\n        used = [False] * n\n        for i in range(n):\n            symmetric_found = False\n            for j in range(n):\n                if not used[j] and is_point_symmetric(points[i], points[j], line_axis):\n                    used[i] = True\n                    used[j] = True\n                    symmetric_found = True\n                    break\n            if not symmetric_found and not used[i]:\n                return False\n        return all(used)\n    \n    def is_point_symmetric(p1, p2, line):\n        x1, y1 = p1\n        x2, y2 = p2\n        a, b, c = line\n        \n        # Check if point is symmetric\n        mid_x = (x1 + x2) / 2\n        mid_y = (y1 + y2) / 2\n        \n        # Line equation: ax + by + c = 0\n        return abs(a * mid_x + b * mid_y + c) < 1e-9\n    \n    # Try all possible symmetric lines\n    for i in range(n):\n        for j in range(i+1, n):\n            # Line passing through midpoint of points\n            x1, y1 = points[i]\n            x2, y2 = points[j]\n            \n            # Perpendicular line through midpoint\n            mid_x = (x1 + x2) / 2\n            mid_y = (y1 + y2) / 2\n            \n            # Line equation coefficients\n            a = x2 - x1\n            b = y2 - y1\n            c = -(a * mid_x + b * mid_y)\n            \n            if is_line_symmetric((a, b, c)):\n                return True\n    \n    return False\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        \n        points = []\n        for _ in range(n):\n            x, y = map(float, input().split())\n            points.append((x, y))\n        \n        print(\"YES\" if is_symmetric_polygon(points) else \"NO\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:19:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef cross(o, a, b):\n    return (a[0]-o[0])*(b[1]-o[1]) - (a[1]-o[1])*(b[0]-o[0])\n\ndef convex_hull(points):\n    points = sorted(points)\n    lower = []\n    for p in points:\n        while len(lower) >= 2 and cross(lower[-2], lower[-1], p) <= 0:\n            lower.pop()\n        lower.append(p)\n    upper = []\n    for p in reversed(points):\n        while len(upper) >= 2 and cross(upper[-2], upper[-1], p) <= 0:\n            upper.pop()\n        upper.append(p)\n    return lower[:-1] + upper[:-1]\n\ndef is_line_symmetric(points):\n    n = len(points)\n    if n < 3:\n        return False\n    \n    ch = convex_hull(points)\n    m = len(ch)\n    if m != n:\n        return False\n    \n    def find_symmetry_axis():\n        for i in range(m // 2 + 1):\n            j = (i + 1) % m\n            k = (i + m // 2) % m\n            l = (k + 1) % m\n            \n            mid1 = ((ch[i][0] + ch[k][0]) / 2, (ch[i][1] + ch[k][1]) / 2)\n            mid2 = ((ch[j][0] + ch[l][0]) / 2, (ch[j][1] + ch[l][1]) / 2)\n            \n            dx1 = ch[k][0] - ch[i][0]\n            dy1 = ch[k][1] - ch[i][1]\n            dx2 = ch[l][0] - ch[j][0]\n            dy2 = ch[l][1] - ch[j][1]\n            \n            if dx1 * dy2 == dx2 * dy1:\n                continue\n            \n            a = dy1 + dy2\n            b = -dx1 - dx2\n            c = dx1 * mid1[1] + dx2 * mid2[1] - dy1 * mid1[0] - dy2 * mid2[0]\n            \n            symmetric = True\n            for p in ch:\n                px, py = p\n                dist = a * px + b * py + c\n                mirror_px = px - 2 * a * dist / (a*a + b*b)\n                mirror_py = py - 2 * b * dist / (a*a + b*b)\n                \n                found = False\n                for q in ch:\n                    if abs(q[0] - mirror_px) < 1e-8 and abs(q[1] - mirror_py) < 1e-8:\n                        found = True\n                        break\n                if not found:\n                    symmetric = False\n                    break\n            if symmetric:\n                return True\n        return False\n    \n    return find_symmetry_axis()\n\ndef main():\n    while True:\n        line = sys.stdin.readline()\n        if not line:\n            break\n        n = int(line.strip())\n        if n == 0:\n            break\n        points = []\n        for _ in range(n):\n            x, y = map(int, sys.stdin.readline().split())\n            points.append((x, y))\n        if is_line_symmetric(points):\n            print(\"Yes\")\n        else:\n            print(\"No\")\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 05:20:22"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <complex>\n\nusing namespace std;\nusing Point = complex<double>;\n\nbool isSymmetricPolygon(const vector<Point>& points) {\n    int n = points.size();\n    if (n < 3) return false; // Polygon can't have less than 3 vertices\n    \n    Point center = (points.front() + points.back()) / 2.0;\n    for (int i = 0; i < n / 2; ++i) {\n        if (abs(center - points[i]) != abs(center - points[n - 1 - i])) return false;\n    }\n    \n    return true;\n}\n\nint main() {\n    vector<Point> points;\n    double x, y;\n    \n    while (cin >> x) {\n        if (x == 0) break;\n        \n        cin >> y;\n        points.push_back(Point(x, y));\n    }\n    \n    if (isSymmetricPolygon(points)) {\n        cout << \"Symmetric Polygon\" << endl;\n    } else {\n        cout << \"Not a Symmetric Polygon\" << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 11:24:26"
  }
]