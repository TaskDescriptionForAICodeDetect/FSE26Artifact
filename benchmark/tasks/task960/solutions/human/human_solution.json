[
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nint x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\t\t\tif (dp[i][mask] >= 0) {\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\tif (e[i] < 0 && e[j] < 0) continue;\n\t\t\t//if (e[i] >= 0 && e[j] >= 0) continue;\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 1e100, Q = 0, R;\n\tF0(i, n) Q = max(Q, 1.0 * a[i]);\n\tF0(i, n) P = min(P, 1.0 * a[i]);\n\tF0(it, 60) {\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "/*\n                ____________    ______________       __\n               / _________  /\\ /_____   _____/\\     / /\\\n              / /\\       / /  \\\\    /  /\\    \\ \\   / /  \\\n             / /  \\_____/ /   / \\__/  /  \\____\\/  / /   /\n            / /   /    / /   /    /  /   /       / /   /\n           / /   /    / /   /    /  /   /       / /   /\n          / /   /    / /   /    /  /   /       / /   /\n         / /___/____/ /   /    /  /   /       / /___/________\n        /____________/   /    /__/   /       /______________/\\\n        \\            \\  /     \\  \\  /        \\              \\ \\\n         \\____________\\/       \\__\\/          \\______________\\/\n           ___       ___               ___    __________\n          /  /\\     /  /\\             /  /\\  /_______  /\\\n         /  /__\\___/  /  \\           /  /  \\ \\      /  /  \\\n        /____    ____/   /          /  /   /  \\____/  /   /\n        \\   /   /\\   \\  /          /  /   /       /  /   /\n         \\_/   /  \\___\\/ ___      /  /   /       /  /   /\n          /   /   /     /  /\\    /  /   /       /  /   /\n         /   /   /     /  /__\\__/  /   /       /  /___/____\n        /___/   /     /___________/   /       /___________/\\\n        \\   \\  /      \\           \\  /        \\           \\ \\\n         \\___\\/        \\___________\\/          \\___________\\/\n\n          A FAN OF FIZZYDAVID\n\n*/\n\n#include<bits/stdc++.h>\n\n#define HEAP priority_queue\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define per(i,n) for(int i=(n)-1;i>=0;i--)\n#define forn(i,l,r) for(int i=(l);i<=(r);i++)\n#define nrof(i,r,l) for(int i=(r);i>=(l);i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define X first\n#define Y second\n#define eps 1e-20\n#define pi 3.1415926535897932384626433832795\n#define orz int\n#define yjz main\n#define fizzydavid return\n#define ak 0\n#define la ;\n#define SZ(x) (int)x.size()\n#define ALL(x) x.begin(),x.end()\n#define FILL(a,b) memset((a),(b),sizeof((a)))\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef double flt;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef vector<LL> vl;\ntypedef pair<int,LL> pil;\ntypedef pair<LL,int> pli;\ntypedef pair<LL,LL> pll;\ntypedef vector<pil> vil;\ntypedef vector<pii> vii;\n\nconst int iinf=1e9+7;\nconst LL linf=1ll<<60;\nconst flt dinf=1e10;\n\ntemplate <typename T>\ninline void scf(T &x)\n{\n\tbool f=0; x=0; char c=getchar();\n\twhile((c<'0' || c>'9') && c!='-') c=getchar();\n\tif(c=='-') { f=1; c=getchar(); }\n\twhile(c>='0' && c<='9') { x=x*10+c-'0'; c=getchar(); }\n\tif(f) x=-x; return;\n}\n\ntemplate <typename T1,typename T2>\nvoid scf(T1 &x,T2 &y) { scf(x); return scf(y); }\n\ntemplate <typename T1,typename T2,typename T3>\nvoid scf(T1 &x,T2 &y,T3 &z) { scf(x); scf(y); return scf(z); }\n\ntemplate <typename T1,typename T2,typename T3,typename T4>\nvoid scf(T1 &x,T2 &y,T3 &z,T4 &w) { scf(x); scf(y); scf(z); return scf(w); }\n\n#ifdef ONLINE_JUDGE\n#define debug(x) ;\n#else\n#define DEBUGg\n#define debug(x) cerr<<#x<<\"=\"<<x<<endl;\n#endif\n\n//---------------------------head----------------------------\n\nconst int N=20;\n\nint n,m;\nint x[N],y[N];\nint u[N*N],v[N*N];\nint water[N];\nflt e[N*N];\nflt dp[1<<N];\nint par[N];\nvi all;\nint id[N*N];\n\ninline int find(int u){ return par[u]==u?u:par[u]=find(par[u]); }\n\nflt solve()\n{\n    flt tot=0.0;\n    for(auto i:all) par[i]=i, tot+=1.0*water[i];\n    rep(i,m) id[i]=i;\n    sort(id,id+m,[](const int &x,const int &y)\n         {\n             return e[x]<e[y];\n         });\n\n    #ifdef DEBUG\n    rep(i,m) cerr<<u[i]<<' '<<v[i]<<' '<<e[i]<<endl;\n    #endif // DEBUG\n\n    rep(ii,m)\n    {\n        int i=id[ii];\n        u[i]=find(u[i]);\n        v[i]=find(v[i]);\n        if(u[i]!=v[i])\n        {\n            tot-=1.0*e[i];\n            par[u[i]]=v[i];\n        }\n    }\n\n    return tot/(1.0*SZ(all));\n}\n\norz yjz()\n{\n    scf(n);\n    forn(i,1,n)\n    {\n        scf(x[i],y[i],water[i]);\n    }\n    rep(msk,1<<n)\n    {\n        all.clear();\n        forn(i,1,n)\n        {\n            if(msk & (1<<i-1)) all.pb(i);\n        }\n\n        m=0;\n        rep(i,SZ(all)) rep(j,i)\n        {\n            u[m]=all[i]; v[m]=all[j];\n            e[m++]=hypot(1.0*(x[all[i]]-x[all[j]]),1.0*(y[all[i]]-y[all[j]]));\n        }\n\n        #ifdef DEBUG\n        cerr<<msk<<endl;\n        #endif // DEBUG\n\n        dp[msk]=solve();\n        for(int mask=msk;mask;mask=(mask-1&msk))\n        {\n            dp[msk]=max(dp[msk],min(dp[mask],dp[msk^mask]));\n        }\n    }\n\n    printf(\"%.12f\\n\",dp[(1<<n)-1]);\n\tfizzydavid ak la\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define rer(i,l,u) for(int (i)=(int)(l);(i)<=(int)(u);++(i))\n#define reu(i,l,u) for(int (i)=(int)(l);(i)<(int)(u);++(i))\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\ntypedef vector<int> vi; typedef pair<int, int> pii; typedef vector<pair<int, int> > vpii; typedef long long ll;\ntemplate<typename T, typename U> static void amin(T &x, U y) { if(y < x) x = y; }\ntemplate<typename T, typename U> static void amax(T &x, U y) { if(x < y) x = y; }\n\nstruct City {\n\tint x, y, a;\n};\n\nint main() {\n\tint N;\n\twhile(~scanf(\"%d\", &N)) {\n\t\tvector<City> cities(N);\n\t\trep(i, N) {\n\t\t\tint x; int y; int a;\n\t\t\tscanf(\"%d%d%d\", &x, &y, &a);\n\t\t\tcities[i] = { x, y, a };\n\t\t}\n\t\tvector<vector<double>> dist(N, vector<double>(N));\n\t\trep(i, N) rep(j, N)\n\t\t\tdist[i][j] = hypot(cities[i].x - cities[j].x, cities[i].y - cities[j].y);\n\t\tvector<double> mstCost(1 << N, 1e99);\n\t\trep(i, N) mstCost[1 << i] = 0;\n\t\treu(S, 1, (1 << N) - 1) {\n\t\t\tdouble x = mstCost[S];\n\t\t\trep(i, N) if(S >> i & 1) rep(j, N) if(~S >> j & 1)\n\t\t\t\tamin(mstCost[S | 1 << j], x + dist[i][j]);\n\t\t}\n\t\tvector<double> value(1 << N);\n\t\treu(S, 1, 1 << N) {\n\t\t\tdouble A = 0;\n\t\t\tint K = 0;\n\t\t\trep(i, N) if(S >> i & 1) {\n\t\t\t\tA += cities[i].a;\n\t\t\t\t++ K;\n\t\t\t}\n\t\t\tvalue[S] = max(0., A - mstCost[S]) / K;\n\t\t}\n\t\tvector<double> dp(1 << N);\n\t\tdp[0] = 1e99;\n\t\treu(S, 1, 1 << N) {\n\t\t\tdouble x = 0;\n\t\t\tfor(int T = S; T > 0; (-- T) &= S)\n\t\t\t\tamax(x, min(value[T], dp[S - T]));\n\t\t\tdp[S] = x;\n\t\t}\n\t\tdouble ans = dp.back();\n\t\tprintf(\"%.10f\\n\", ans);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <cassert>\nusing namespace std;\n#define rep(i,a,n) for (int i=a;i<n;i++)\n#define per(i,a,n) for (int i=n-1;i>=a;i--)\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n#define SZ(x) ((int)(x).size())\ntypedef vector<int> VI;\ntypedef long long ll;\ntypedef pair<int,int> PII;\nconst ll mod=1000000007;\nll powmod(ll a,ll b) {ll res=1;a%=mod; assert(b>=0); for(;b;b>>=1){if(b&1)res=res*a%mod;a=a*a%mod;}return res;}\n// head\n\nconst int M=20,N=(1<<15)+10;\ndouble g[M][M],dis[M];\nint vis[M],n,x[M],y[M],a[M];\ndouble dp[N];\ndouble dist(double x,double y) { return sqrt(x*x+y*y); }\ndouble solve(vector<PII> x) {\n\tint m=SZ(x);\n\trep(i,0,m) rep(j,i+1,m) g[i][j]=g[j][i]=dist(x[i].fi-x[j].fi,x[i].se-x[j].se);\n\trep(i,0,m) vis[i]=0;\n\tvis[0]=1; rep(i,1,m) dis[i]=g[0][i];\n\tdouble r=0;\n\trep(i,0,m-1) {\n\t\tdouble pd=1e20; int pp=-1;\n\t\trep(j,0,m) if (!vis[j]&&dis[j]<pd) {\n\t\t\tpd=dis[j]; pp=j;\n\t\t}\n\t\tvis[pp]=1; r+=pd; \n\t\trep(j,0,m) dis[j]=min(dis[j],g[pp][j]);\n\t}\n\treturn r;\n}\nint main() {\n\tscanf(\"%d\",&n);\n\trep(i,0,n) scanf(\"%d%d%d\",x+i,y+i,a+i);\n\trep(S,1,(1<<n)) {\n\t\tvector<PII> v;\n\t\trep(i,0,n) if (S&(1<<i)) {\n\t\t\tdp[S]+=a[i];\n\t\t\tv.pb(mp(x[i],y[i]));\n\t\t}\n\t\tdp[S]-=solve(v); dp[S]/=SZ(v);\n\t}\n\trep(S,1,(1<<n)) {\n\t\tint nS=S;\n\t\twhile (1) {\n\t\t\tdp[S]=max(dp[S],min(dp[nS],dp[S-nS]));\n\t\t\tif (nS==0) break;\n\t\t\tnS=(nS-1)&S;\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\",dp[(1<<n)-1]);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <vector>\n#include <string>\n#include <string.h>\n#include <cstdlib>\n#include <ctime>\n#include <cmath>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <numeric>\n#include <cctype>\n#include <bitset>\n#include <cassert>\n#define fi first\n#define se second\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = 1; i <= (n); ++i)\n#define drep(i,n) for(int i = (n)-1; i >= 0; --i)\n#define gep(i,g,j) for(int i = g.head[j]; i != -1; i = g.e[i].next)\n#define each(it,c) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)\n#define rng(a) a.begin(),a.end()\n#define maxs(x,y) x = max(x,y)\n#define mins(x,y) x = min(x,y)\n#define pb push_back\n#define sz(x) (int)(x).size()\n#define pcnt __builtin_popcount\n#define uni(x) x.erase(unique(rng(x)),x.end())\n#define snuke srand((unsigned)clock()+(unsigned)time(NULL));\n#define df(x) int x = in()\n#define dame { puts(\"-1\"); return 0;}\n#define show(x) cout<<#x<<\" = \"<<x<<endl;\n#define PQ(T) priority_queue<T,vector<T>,greater<T> >\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int,int> P;\ntypedef pair<double,P> DP;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<P> vp;\ninline int in() { int x; scanf(\"%d\",&x); return x;}\ninline void priv(vi a) { rep(i,sz(a)) printf(\"%d%c\",a[i],i==sz(a)-1?'\\n':' ');}\ntemplate<typename T>istream& operator>>(istream&i,vector<T>&v)\n{rep(j,sz(v))i>>v[j];return i;}\ntemplate<typename T>string join(vector<T>&v)\n{stringstream s;rep(i,sz(v))s<<' '<<v[i];return s.str().substr(1);}\ntemplate<typename T>ostream& operator<<(ostream&o,vector<T>&v)\n{if(sz(v))o<<join(v);return o;}\ntemplate<typename T1,typename T2>istream& operator>>(istream&i,pair<T1,T2>&v)\n{return i>>v.fi>>v.se;}\ntemplate<typename T1,typename T2>ostream& operator<<(ostream&o,pair<T1,T2>&v)\n{return o<<v.fi<<\",\"<<v.se;}\nconst int MX = 15, INF = 1001001001;\nconst ll LINF = 1e18;\nconst double eps = 1e-10;\ndouble yosupot(double a, double b) { return sqrt(a * a + b * b);}\n\n// Union find\nstruct uf {\n  vi d;\n  uf(){}\n  uf(int mx):d(mx,-1){}\n  int root(int x) {\n    if(d[x] < 0) return x;\n    return d[x] = root(d[x]);\n  }\n  bool unite(int x, int y) {\n    x = root(x); y = root(y);\n    if(x == y) return false;\n    if(d[x] > d[y]) swap(x,y);\n    d[x] += d[y]; d[y] = x;\n    return true;\n  }\n  int size(int x) { return -d[root(x)];}\n};\n//\n\ndouble d[1<<15];\ndouble dp[1<<15];\n\nint main() {\n  int n;\n  scanf(\"%d\",&n);\n  vi x(n), y(n), a(n);\n  rep(i,n) scanf(\"%d%d%d\",&x[i],&y[i],&a[i]);\n  rep(i,1<<n) {\n    if (!i) continue;\n    vector<DP> es;\n    rep(j,n) if (i>>j&1) {\n      rep(k,n) if (i>>k&1) {\n        es.pb(DP(yosupot(x[j]-x[k],y[j]-y[k]),P(j,k)));\n      }\n    }\n    uf t(n);\n    sort(rng(es));\n    double now = 0;\n    rep(j,n) if (i>>j&1) now += a[j];\n    for (auto e : es) {\n      if (t.unite(e.se.fi,e.se.se)) now -= e.fi;\n    }\n    now /= pcnt(i);\n    d[i] = now;\n  }\n  dp[0] = 1e10;\n  rep(i,1<<n) {\n    int ii = ((1<<n)-1)^i;\n    for (int j = ii; j; j = (j-1)&ii) {\n      maxs(dp[i^j], min(dp[i],d[j]));\n    }\n  }\n  printf(\"%.10f\\n\",dp[(1<<n)-1]);\n  return 0;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region include\n#include <iostream>\n#include <iomanip>\n#include <stdio.h>\n\n#include <sstream>\n#include <algorithm>\n#include <iterator>\n#include <cmath>\n#include <complex>\n\n#include <string>\n#include <cstring>\n#include <vector>\n#include <tuple>\n#include <bitset>\n\n#include <queue>\n#include <complex>\n#include <set>\n#include <map>\n#include <stack>\n#include <list>\n\n#include <fstream>\n#include <random>\n//#include <time.h>\n#include <ctime>\n#pragma endregion //#include\n/////////\n#define REP(i, x, n) for(int i = x; i < n; ++i)\n#define rep(i,n) REP(i,0,n)\n#define ALL(X) X.begin(), X.end()\n/////////\n#pragma region typedef\ntypedef long long LL;\ntypedef long double LD;\ntypedef unsigned long long ULL;\ntypedef std::pair<LL,LL> PLL;//\ntypedef std::pair<int,int> PII;//\n#pragma endregion //typedef\n////定数\nconst int INF = (int)1e9;\nconst LL MOD = (LL)1e9+7;\nconst LL LINF = (LL)1e18+20;\nconst LD PI = acos(-1.0);\nconst double EPS = 1e-9;\n/////////\nusing namespace::std;\n\n/*\nthx\nhttp://cf16-exhibition-final-open.contest.atcoder.jp/submissions/1005311\n*/\n\nstruct City{//位置x,位置y,水量\n\tint x,y,a;\n};\nvoid solve(){\n\tint N;\n\tcin >> N;\n\tvector<City> cities(N);\n\tfor(int i=0;i<N;++i){\n\t\tint x,y,a;\n\t\tcin >> x >> y >> a;\n\t\t//cities[i] = {x,y,a};\n\t\tcities[i].x = x;\n\t\tcities[i].y = y;\n\t\tcities[i].a = a;\n\t}\n\t//dist[i][j]:=i,j間の距離\n\tvector< vector<double> > dist(N,vector<double>(N));\n\tfor(int i=0;i<N;++i){\n\t\tfor(int j=0;j<N;++j){\n\t\t\t//ユークリッド距離\n\t\t\t//dist[i][j] = hypot(cities[i].x-cities[j].x, cities[i].y-cities[j].y);\n\t\t\t//Cityの中がint\n\t\t\t// 10^5*10^5 などでOVF\n\t\t\t/*dist[i][j] = (cities[i].x-cities[j].x)*(cities[i].x-cities[j].x)\n\t\t\t\t+(cities[i].y-cities[j].y)*(cities[i].y-cities[j].y);\n\t\t\tdist[i][j] = sqrt( dist[i][j] );\n\t\t\t*/\n\t\t\tdouble X = (cities[i].x-cities[j].x);\n\t\t\tdouble Y = (cities[i].y-cities[j].y);\n\t\t\tdist[i][j] = sqrt(X*X+Y*Y);\n\t\t}\n\t}\n\t\n\t//初期化\n\tvector<double> mstCost(1<<N,1e99);\n\tfor(int i=0;i<N;++i){\n\t\tmstCost[1<<i] = 0;\n\t}\n\n\t/*\n\t集合Sを連結にするための最小コスト:最小全域木\n\t(MST:Minimum Spanning Tree)\n\t*/\n\tfor(int S=1;S<(1<<N)-1;++S){\n\t\tdouble x = mstCost[S];\n\t\tfor(int i=0;i<N;++i){\n\t\t\tif( (S >> i) & 1 ){//\n\t\t\t\tfor(int j=0;j<N;++j){\n\t\t\t\t\tif( ~S >> j & 1){//\n\t\t\t\t\t\tmstCost[S|(1<<j)] = min(mstCost[S|(1<<j)],\n\t\t\t\t\t\t\tx + dist[i][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/////\n\t/*\n\tある部分集合Sで、水量の平均を最大化すると\n\tvalue[S]になる。かな？\n\t*/\n\tvector<double> value(1<<N,0);\n\tfor(int S=1;S<(1<<N);++S){\n\t\tdouble sumA = 0;//Sに含まれる都市の水量\n\t\tint K = 0;//Sに含まれる都市の数\n\t\tfor(int i=0;i<N;++i){\n\t\t\tif( (S>>i) & 1 ){\n\t\t\t\tsumA += cities[i].a;\n\t\t\t\t++K;\n\t\t\t}\n\t\t}\n\t\tvalue[S] = max(0.0, sumA - mstCost[S]) / K;\n\t}\n\n\t/////\n\tvector<double> dp(1<<N);\n\tdp[0] = 1e99;\n\t/*\n\tあるSのときSの部分集合は計算済み\n\t*/\n\tfor(int S=1;S<(1<<N);++S){\n\t\tdouble x = 0;//dp[S]での最大値を入れる\n\n\t\t//Sを分割して、それぞれ最小値の最大値を見る\n\t\tfor(int T = S; T> 0 ; (--T) &= S ){\n\t\t\t//T=0の場合,value[0]=0 => min(value[0],dp[S]) => 0\n\t\t\t//max(x,0) => x\n\t\t\tx = max(x, min(value[T],dp[S-T]) );\n\t\t}\n\t\tdp[S] = x;\n\t}\n\tdouble ans = dp.back();//dp[(1<<N)-1];//dp.back();\n\tcout << ans << endl;\n}\n\n#pragma region main\nsigned main(void){\n\tstd::cin.tie(0);\n\tstd::ios::sync_with_stdio(false);\n\tstd::cout << std::fixed;//小数を10進数表示\n\tcout << setprecision(16);//小数点以下の桁数を指定//coutとcerrで別\t\n\n\tsolve();\n}\n#pragma endregion //main()"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/08/30.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\n\nstruct UnionFind{\n    vi node;\n\n    UnionFind(int sz){\n        node = vi(sz);\n        iota(all(node), 0);\n    }\n\n    int root(int x){\n        if(node[x] == x) return x;\n        return node[x] = root(node[x]);\n    }\n\n    bool uni(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y)return false;\n        node[x] = y;\n        return true;\n    }\n};\n\nint n;\nvector<double> x, y, a;\n\ndouble dist(int p, int q){\n    return sqrt(norm(x[p]-x[q])+norm(y[p]-y[q]));\n}\n\ndouble solve(int f){\n    double total=0;\n    vector<int> idx;\n    vector<pair<int,pair<int,int>>> edge;\n    rep(i, n){\n        if(f & (1 << i)){\n            idx.push_back(i);\n        }\n    }\n    int sz=idx.size();\n    rep(i,sz){\n        total+=a[idx[i]];\n        rep(j,i){\n            edge.push_back({dist(idx[i], idx[j]),{i,j}});\n        }\n    }\n    sort(all(edge));\n    UnionFind uf(sz);\n    double cost=0;\n    rep(i,edge.size()){\n        if(uf.uni(edge[i].second.first,edge[i].second.second)) cost+=edge[i].first;\n    }\n    return max(0.0,total-cost)/sz;\n}\n\nint main(){\n    cin >> n;\n    x = vector<double>(n);\n    y = vector<double>(n);\n    a = vector<double>(n);\n    rep(i, n) cin >> x[i] >> y[i] >> a[i];\n    vector<double> dp(1 << n, 0);\n    dp[0]=IINF;\n    vector<double> ans(1 << n, IINF);\n    repl(i, 1, 1 << n) ans[i] = solve(i);\n    repl(i, 1, 1 << n){\n        vector<int> b;\n        rep(j, n) if(i & (1 << j)) b.push_back(j);\n        int s = b.size();\n        repl(j, 1, (1 << s)){\n            int ad = 0;\n            rep(k, s) if(j & (1 << k)) ad |= (1 << b[k]);\n            dp[i] = max(dp[i],min(dp[i ^ ad], ans[ad]));\n        }\n    }\n    CST(10);\n    cout << dp[(1 << n) - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <stdio.h>\n#include <cmath>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<double, pair<int, int> >  edge;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 0; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nllint N;\ndouble x[15], y[15];\nllint a[15];\ndouble G[15][15];\nvector<edge> E;\nUnionFind uf(16);\n\ndouble mst[1<<15];\ndouble sum[1<<15];\ndouble dp[1<<15];\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> x[i] >> y[i] >> a[i];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i == j) G[i][j] = 0.0;\n\t\t\telse{\n\t\t\t\tG[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint S = 1 << N;\n\tfor(int s = 0; s < S; s++){\n\t\tE.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif((s & (1<<i)) == 0) continue; \n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tif((s & (1<<j)) == 0) continue; \n\t\t\t\tE.push_back(make_pair(G[i][j], make_pair(i, j)));\n\t\t\t}\n\t\t}\n\t\tsort(E.begin(), E.end());\n\t\tuf.init();\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < E.size(); i++){\n\t\t\tedge e = E[i];\n\t\t\tif(uf.same(e.second.first, e.second.second)) continue;\n\t\t\tuf.unite(e.second.first, e.second.second);\n\t\t\tsum += e.first;\n\t\t}\n\t\tmst[s] = sum;\n\t}\n\tfor(int s = 0; s < S; s++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(s & (1<<i)) sum[s] += a[i];\n\t\t}\n\t}\n\t\n\tvector<int> vec;\n\tdp[0] = -inf;\n\tfor(int s = 1; s < S; s++){\n\t\tvec.clear();\n\t\tfor(int i = 0; i < N; i++) if(s & (1<<i)) vec.push_back(i);\n\t\tint n = vec.size();\n\t\tdp[s] = (sum[s] - mst[s]) / n;\n\t\tfor(int i = 0; i < (1<<n); i++){\n\t\t\tint bit = 0, cbit = 0;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i & (1<<j)) bit |= (1<<vec[j]);\n\t\t\t\telse cbit |= (1<<vec[j]);\n\t\t\t}\n\t\t\tdp[s] = max(dp[s], min(dp[bit], dp[cbit]));\n\t\t}\n\t}\n\t\n\t//for(int i = 1; i < S; i++) cout << dp[i] << \" \";  cout << endl;\n\t\n\tprintf(\"%.11f\\n\", dp[S-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint nth_bit(int64_t num, int n){\n    return (num >> n) & 1;\n}\n\nvoid chmax(double& a, double b){\n\ta = max(a, b);\n}\n\nint main(){\n\tint N, X[15], Y[15], A[15];\n    cin >> N;\n\tfor(int i=0; i<N; i++) cin >> X[i] >> Y[i] >> A[i];\n\t\n\tdouble D[15][15];\n\tfor(int i=0; i<N; i++) for(int j=0; j<N; j++){\n\t\tdouble xd = X[i] - X[j], yd = Y[i] - Y[j];\n\t\tD[i][j] = sqrt(xd*xd + yd*yd);\n\t}\n\n\tint B = 1<<N;\n\tdouble dp[1<<15] = {0};\n\tdp[0] = 1e18;\n\tfor(int b=1; b<B; b++){\n\t\tint num = 0;\n\t\tfor(int i=0; i<N; i++) if(nth_bit(b, i)){\n\t\t\tnum++;\n\t\t\tdp[b] += A[i];\n\t\t}\n\n\t\tvector<pair<double, pair<int, int>>> edges;\n\t\tfor(int i=0; i<N; i++) for(int j=0; j<i; j++) if(nth_bit(b, i) && nth_bit(b, j)) edges.push_back({D[i][j], {i, j}});\n\t\tUnionFind uf(N);\n\t\tsort(edges.begin(), edges.end());\n\t\tfor(auto& e : edges){\n\t\t\tint i = e.second.first, j = e.second.second;\n\t\t\tif(!uf.same(i, j)){\n\t\t\t\tuf.unite(i, j);\n\t\t\t\tdp[b] -= e.first;\n\t\t\t}\n\t\t}\n\t\tdp[b] /= num;\n\t}\n\n\tfor(int b=1; b<B; b++){\n\t\tfor(int b2=b; b2>0; b2=(b2-1)&b){\n\t\t\tchmax(dp[b], min(dp[b2], dp[b-b2]));\n\t\t}\n\t}\n\n\tcerr << fixed << setprecision(20) << dp[B-1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<iostream>\n#include<set>\n#include<cmath>\n#include<tuple>\n#include<string>\n//#include<chrono>\n#include<functional>\n#include<iterator>\n#include<random>\n#include<list>\n#include<unordered_set>\n#include<array>\n#include<map>\n#include<iomanip>\n#include<assert.h>\n#include<bitset>\n#include<stack>\nusing namespace std;\ntypedef long long int llint;\ntypedef long double lldo;\n#define mp make_pair\n#define mt make_tuple\n#define pub push_back\n#define puf push_front\n#define pob pop_back\n#define pof pop_front\n#define fir first\n#define sec second\n#define res resize\n#define ins insert\n#define era erase\n/*\ncout<<setprecision(20);\ncin.tie(0);\nios::sync_with_stdio(false);\n*/\nconst llint mod=1e9+7;\nconst llint big=2.19e15+1;\nconst long double pai=3.141592653589793238462643383279502884197;\nconst long double eps=1e-15;\ntemplate <class T,class U>void mineq(T& a,U b){if(a>b){a=b;}}\ntemplate <class T,class U>void maxeq(T& a,U b){if(a<b){a=b;}}\nllint gcd(llint a,llint b){if(a%b==0){return b;}else return gcd(b,a%b);}\n//llint lcm(llint a,llint b){return a/gcd(a,b)*b;}\ntemplate<class T> void SO(T& ve){sort(ve.begin(),ve.end());}\ntemplate<class T> void REV(T& ve){reverse(ve.begin(),ve.end());}\ntemplate<class T>llint LBI(vector<T>&ar,T in){return lower_bound(ar.begin(),ar.end(),in)-ar.begin();}\ntemplate<class T>llint UBI(vector<T>&ar,T in){return upper_bound(ar.begin(),ar.end(),in)-ar.begin();}\nint main(void){\n\t//最小全域木を作る、最小全域木でつながった中で任意の配分ができる\n\t//二分探索ではなく有理数でも解くことができる\n\t//3^n DP しかなくない?\n\tcout<<setprecision(20);\n\tdouble dp[32768];\n\tllint i,j,n;cin>>n;\n\tdouble x[15],y[15];\n\tdouble a[15];\n\tfor(i=0;i<(1<<n);i++){dp[i]=big;}\n\tfor(i=0;i<n;i++){cin>>x[i]>>y[i]>>a[i];dp[1<<i]=0;}\n\t//全域木のコストを求める,葉に何かを入れるタイプの探索をする\n\tfor(int bi=1;bi<(1<<n);bi++){\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(!(bi&(1<<i))){continue;}\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tif(!(bi&(1<<j))){continue;}\n\t\t\t\tif(i==j){continue;}\n\t\t\t\tmineq(dp[bi],dp[bi-(1<<j)]+sqrt((x[i]-x[j])*(x[i]-x[j])+(y[i]-y[j])*(y[i]-y[j])));\n\t\t\t}\n\t\t}\n\t}\n\tfor(int bi=1;bi<(1<<n);bi++){\n\t\tdouble wata=0,mati=0;\n\t\tfor(i=0;i<n;i++){if(bi&(1<<i)){wata+=a[i];mati+=1;}}\n\t\tdp[bi]=(wata-dp[bi])/mati;\n\t}\n\tfor(int bi=1;bi<(1<<n);bi++){\n\t\tfor(int Anum=0;Anum<bi;Anum++){\n\t\t\twhile(-1){\n\t\t\t\tint x=Anum&(~bi);\n\t\t\t\tif(x==0){break;}\n\t\t\t\telse{Anum+=x;}\n\t\t\t}\n\t\t\tint Bnum=bi-Anum;\n\t\t\tmaxeq(dp[bi],min(dp[Anum],dp[Bnum]));\n\t\t}\n\t}\n\tcout<<dp[(1<<n)-1]<<endl;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cmath>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ninline int bits(int m) { return (1<<m)-1; }\nusing Double = double;\nconst Double INF = 1e100;\n\nint N;\nLL X[15], Y[15], A[15];\n\nDouble D[15][15];\nDouble cst[1<<15];\nDouble sum[1<<15];\nDouble dp[1<<15];\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld%lld%lld\", X+i, Y+i, A+i);\n\n    REP (s, 1<<N) if (s) {\n\tREP (i, N) if (s>>i&1) {\n\t    sum[s] = sum[s^(1<<i)] + A[i];\n\t    break;\n\t}\n    }\n\n    REP (i, N) REP (j, N) D[i][j] = hypot((Double)X[i]-X[j], (Double)Y[i]-Y[j]);\n    REP (s, 1<<N) cst[s] = INF;\n    REP (s, 1<<N) {\n\tif (__builtin_popcount(s) <= 1) cst[s] = 0;\n\tREP (i, N) if (s>>i&1) REP (j, N) if (~s>>j&1) amin(cst[s|1<<j], cst[s] + D[i][j]);\n    }\n\n    dp[0] = INF;\n    REP (s, 1<<N) if (dp[s] > 0) {\n\tint other = bits(N) ^ s;\n\tif (other == 0) continue;\n\tint sup = other & (other-1);\n\tint small = sup ^ other;\n\tfor (int t=sup; ; t=(t-1)&sup) {\n\t    int pc = __builtin_popcount(t|small);\n\t    Double val = (sum[t|small] - cst[t|small]) / pc;\n\t    amax(dp[s|t|small], min(val, dp[s]));\n\t    if (t == 0) break;\n\t}\n    }\n    double ans = dp[bits(N)];\n    printf(\"%.12f\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c) {\n\tvector<string> v; stringstream ss(s); string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \", err(++it, args...);\n}\n\n\n// Description: 素集合を管理するデータ構造\n// TimeComplexity: 初期化$\\mathcal{O}(n)$ 更新$\\mathcal{O}(\\log n)$\n// Verifyed: AOJ DSL_1_A\n\nstruct Union_find {\n\tUnion_find(int n) {data.assign(n, -1);}\n\tint find(int x) {return (data[x] < 0) ? x : data[x] = find(data[x]);}\n\tvoid unite(int a, int b) {\n\t\ta = find(a), b = find(b);\n\t\tif (a != b) {\n\t\t\tif (data[a] < data[b]) swap(a, b);\n\t\t\tdata[a] += data[b], data[b] = a;\n\t\t}\n\t}\n\tbool same(int a, int b) {return find(a) == find(b);}\n\tint size(int x) {return -data[x];}\n\tvector<int> data;\n};\n\nint x[15], y[15], a[15];\nbool dp[1 << 15];\nR cost[1 << 15];\n\nbool check(int n, R val) {\n\trep(mask, 1 << n) {\n\t\tdp[mask] = false;\n\t\tconst R m = __builtin_popcountll(mask);\n\t\tR cur = 0.0;\n\t\trep(i, n) if (mask & (1 << i)) cur += a[i];\n\t\tcur -= cost[mask] + m * val;\n\t\tif (cur >= 0.0) dp[mask] = true;\n\t\t//error(mask, dp[mask]);\n\t}\n\n\trep(mask, 1 << n) {\n\t\tif (dp[mask]) continue;\n\t\tfor (int smask = (mask - 1) &mask; smask > 0; smask = (smask - 1) & mask) {\n\t\t\tconst int tmask = mask ^ smask;\n\t\t\tif (dp[smask] and dp[tmask]) {\n\t\t\t\tdp[mask] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[(1 << n) - 1];\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\trep(i, n) cin >> x[i] >> y[i] >> a[i];\n\n\trep(mask, 1 << n) {\n\t\tcost[mask] = 0.0;\n\t\tusing edge = tuple<R, int, int>;\n\t\tvector<edge> ary;\n\n\t\trep(j, n)rep(i, j) {\n\t\t\tif (((mask >> i) & 1) == 0) continue;\n\t\t\tif (((mask >> j) & 1) == 0) continue;\n\t\t\tary.push_back(edge(hypot(x[i] - x[j], y[i] - y[j]), i, j));\n\t\t}\n\n\t\tsort(begin(ary), end(ary));\n\t\tUnion_find uf(n);\n\n\t\tfor (auto &e : ary) {\n\t\t\tR w;\n\t\t\tint a, b;\n\t\t\ttie(w, a, b) = e;\n\t\t\tif (uf.same(a, b)) continue;\n\t\t\tcost[mask] += w;\n\t\t\tuf.unite(a, b);\n\t\t}\n\t\t//error(mask, cost[mask]);\n\t}\n\n\tR low = 0.0, high = 1e10;\n\t\n\trep(loop, 100) {\n\t\tconst R mid = (low + high) / 2.0;\n\t\tif (check(n, mid))\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\tcout.precision(20);\n\tcout << fixed << low << endl;\n\t\n\t/*\t\n\tcerr << check(n, 5.5) << endl;\n\tcerr << check(n, 7.5) << endl;\n\t*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<math.h>\n#include<algorithm>\n#include<queue>\n#include<deque>\n#include<stack>\n#include<string>\n#include<string.h>\n#include<vector>\n#include<set>\n#include<map>\n#include<bitset>\n#include<stdlib.h>\n#include<cassert>\n#include<time.h>\n#include<bitset>\nusing namespace std;\nconst long long mod=1000000007;\nconst long long inf=mod*mod;\nconst long long d2=(mod+1)/2;\nconst long double EPS=1e-13;\nconst long double PI=acos(-1.0);\nint ABS(int a){return max(a,-a);}\nlong long ABS(long long a){return max(a,-a);}\nlong double ABS(long double a){return max(a,-a);}\nint x[110];\nint y[110];\nint p[110];\ndouble g[20][20];\ndouble t[1<<15];\ndouble dp[1<<15];\nint UF[20];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);b=FIND(b);if(a==b)return;UF[a]+=UF[b];UF[b]=a;\n}\npair<double,pair<int,int> > edge[400];\nint main(){\n\tint a;scanf(\"%d\",&a);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d%d\",x+i,y+i,p+i);\n\t}\n\tfor(int i=0;i<a;i++){\n\t\tfor(int j=0;j<a;j++){\n\t\t\tg[i][j]=sqrt((long long)(x[i]-x[j])*(x[i]-x[j])+(long long)(y[i]-y[j])*(y[i]-y[j]));\n\t\t}\n\t}\n\tfor(int i=1;i<(1<<a);i++){\n\t\tdouble tmp=0;\n\t\tint cnt=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tif(i&(1<<j)){\n\t\t\t\tcnt++;\n\t\t\t\ttmp+=p[j];\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<a;j++){UF[j]=-1;}\n\t\tint sz=0;\n\t\tfor(int j=0;j<a;j++){\n\t\t\tfor(int k=j+1;k<a;k++){\n\t\t\t\tif(i&(1<<j)){\n\t\t\t\t\tif(i&(1<<k)){\n\t\t\t\t\t\tedge[sz++]=make_pair(g[j][k],make_pair(j,k));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstd::sort(edge,edge+sz);\n\t\tfor(int j=0;j<sz;j++){\n\t\t\tif(FIND(edge[j].second.first)!=FIND(edge[j].second.second)){\n\t\t\t\ttmp-=edge[j].first;\n\t\t\t\tUNION(edge[j].second.first,edge[j].second.second);\n\t\t\t}\n\t\t}\n\t\tt[i]=tmp/cnt;\n\t}\n\tdp[0]=mod;\n\tfor(int i=1;i<(1<<a);i++){\n\t\tint j=i;\n\t\twhile(j){\n\t\t\tdp[i]=max(dp[i],min(dp[i-j],t[j]));\n\t\t\tj=((j-1)&i);\n\t\t}\n\t}\n\tprintf(\"%.12f\\n\",dp[(1<<a)-1]);\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define int long long\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb push_back\n#define all(v) (v).begin(),(v).end()\n#define fi first\n#define se second\ntypedef vector<int>vint;\ntypedef pair<int,int>pint;\ntypedef vector<pint>vpint;\n\ntemplate<typename A,typename B>inline void chmin(A &a,B b){if(a>b)a=b;}\ntemplate<typename A,typename B>inline void chmax(A &a,B b){if(a<b)a=b;}\n\nstruct UnionFindTree{\n    vector<int>par,sz;\n    UnionFindTree(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        sz[x]+=sz[y];\n        par[y]=x;\n    }\n    bool areSame(int x,int y){\n        return find(x)==find(y);\n    }\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint N;\nint X[15],Y[15],A[15];\n\ndouble ei[1<<15];\ndouble dp[1<<15];\n\n\nsigned main(){\n    cin>>N;\n    rep(i,N)cin>>X[i]>>Y[i]>>A[i];\n\n    for(int i=1;i<1<<N;i++){\n        vector<tuple<int,int,int>>es;\n        rep(j,N){\n            if(~i>>j&1)continue;\n            for(int k=j+1;k<N;k++){\n                if(~i>>k&1)continue;\n                int d=(X[j]-X[k])*(X[j]-X[k])+(Y[j]-Y[k])*(Y[j]-Y[k]);\n                es.pb(make_tuple(d,j,k));\n            }\n        }\n        sort(all(es));\n        UnionFindTree uf(N);\n        double sum=0;\n        rep(j,N)if(i>>j&1)sum+=A[j];\n        for(auto &w:es){\n            int d,u,v;\n            tie(d,u,v)=w;\n            if(uf.areSame(u,v))continue;\n            uf.unite(u,v);\n            sum-=sqrt(d);\n        }\n        ei[i]=sum/__builtin_popcount(i);\n    }\n\n    dp[0]=1e20;\n    rep(i,1<<N){\n        int sup=(1<<N)-1-i;\n        for(int j=sup;j;j=(j-1)&sup){\n            chmax(dp[i|j],min(dp[i],ei[j]));\n        }\n    }\n\n\n    printf(\"%.20f\\n\",dp[(1<<N)-1]);\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nint x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\t\t\tif (dp[i][mask] >= 0) {\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\tif (e[i] < 0 && e[j] < 0) continue;\n\t\t\t//if (e[i] >= 0 && e[j] >= 0) continue;\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 0.0, Q = 1e9, R;\n\tF0(it, 50) {\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\n//#define int long long\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 998244353;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<ll> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nstruct uf {\nprivate:\n\tvector<int> par, ran;\npublic:\n\tuf(int n) {\n\t\tpar.resize(n, 0);\n\t\tran.resize(n, 0);\n\t\trep(i, n) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (par[x] == x)return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x), y = find(y);\n\t\tif (x == y)return;\n\t\tif (ran[x] < ran[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (ran[x] == ran[y])ran[x]++;\n\t\t}\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint n;\nld x[15], y[15], a[15];\nld dist[15][15];\nld high[1 << 15];\n\nld dp[1 << 15];\n\ntypedef pair<ld, P> speP;\nvoid solve() {\n\tcin >> n;\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tdist[i][j] = sqrt(pow(x[j] - x[i], 2) + pow(y[j] - y[i], 2));\n\t\t}\n\t}\n\tfor (int i = 1; i < (1 << n); i++) {\n\t\tvector<int> v;\n\t\trep(j, n) {\n\t\t\tif (i&(1 << j)) {\n\t\t\t\tv.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint len = v.size();\n\t\tuf u(len);\n\t\tld sum = 0;\n\t\tvector<speP> z;\n\t\trep(j, len) {\n\t\t\tsum += a[v[j]];\n\t\t\tRep(k, j + 1, len) {\n\t\t\t\tz.push_back({ dist[v[j]][v[k]],{j,k} });\n\t\t\t}\n\t\t}\n\t\tsort(z.begin(), z.end());\n\t\trep(j, z.size()) {\n\t\t\tint l = z[j].second.first, r = z[j].second.second;\n\t\t\tif (u.same(l, r))continue;\n\t\t\tsum -= z[j].first; u.unite(l, r);\n\t\t}\n\t\tif (sum < 0)sum = 0;\n\t\thigh[i] = sum / len;\n\t}\n\t//3^n\n\tdp[0] = INF;\n\tfor (int i = 1; i < (1 << n); i++) {\n\t\tdp[i] = high[i];\n\t\tvector<int> v;\n\t\trep(j, n) {\n\t\t\tif (i&(1 << j)) {\n\t\t\t\tv.push_back(j);\n\t\t\t}\n\t\t}\n\t\tint len = v.size();\n\t\tfor (int j = 1; j < (1 << len) - 1;j++) {\n\t\t\tint s = 0;\n\t\t\trep(k, len) {\n\t\t\t\tif (j&(1 << k)) {\n\t\t\t\t\ts += (1 << v[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tdp[i] = max(dp[i], min(dp[s], dp[s^i]));\n\t\t}\n\t}\n\tcout << dp[(1 << n) - 1] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(10);\n\t//init();\n\tsolve();\n\t//cout << \"finish\" << endl;\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <stdio.h>\n#include <cmath>\n#define llint long long\n#define inf 1e18\n\nusing namespace std;\ntypedef pair<double, pair<int, int> >  edge;\n\nstruct UnionFind{\n\tint size;\n\tvector<int> parent;\n\t\n\tUnionFind(){}\n\tUnionFind(int size){\n\t\tthis->size = size;\n\t\tparent.resize(size+1);\n\t\tinit();\n\t}\n\tvoid init(){\n\t\tfor(int i = 1; i <= size; i++) parent[i] = i;\n\t}\n\tint root(int i){\n\t\tif(parent[i] == i) return i;\n\t\treturn parent[i] = root(parent[i]);\n\t}\n\tbool same(int i, int j){\n\t\treturn root(i) == root(j);\n\t}\n\tvoid unite(int i, int j){\n\t\tint root_i = root(i), root_j = root(j);\n\t\tif(root_i == root_j) return;\n\t\tparent[root_i] = root_j;\n\t}\n};\n\nllint N;\ndouble x[15], y[15];\nllint a[15];\ndouble G[15][15];\nvector<edge> E;\nUnionFind uf(16);\n\ndouble mst[1<<15];\ndouble sum[1<<15];\ndouble dp[1<<15];\n\nint main(void)\n{\n\tcin >> N;\n\tfor(int i = 0; i < N; i++) cin >> x[i] >> y[i] >> a[i];\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int j = 0; j < N; j++){\n\t\t\tif(i == j) G[i][j] = 0.0;\n\t\t\telse{\n\t\t\t\tG[i][j] = sqrt((x[i]-x[j])*(x[i]-x[j]) + (y[i]-y[j])*(y[i]-y[j]));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint S = 1 << N;\n\tfor(int s = 0; s < S; s++){\n\t\tE.clear();\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif((s & (1<<i)) == 0) continue; \n\t\t\tfor(int j = 0; j < N; j++){\n\t\t\t\tif(i >= j) continue;\n\t\t\t\tif((s & (1<<j)) == 0) continue; \n\t\t\t\tE.push_back(make_pair(G[i][j], make_pair(i, j)));\n\t\t\t}\n\t\t}\n\t\tsort(E.begin(), E.end());\n\t\tuf.init();\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < E.size(); i++){\n\t\t\tedge e = E[i];\n\t\t\tif(uf.same(e.second.first, e.second.second)) continue;\n\t\t\tuf.unite(e.second.first, e.second.second);\n\t\t\tsum += e.first;\n\t\t}\n\t\tmst[s] = sum;\n\t}\n\tfor(int s = 0; s < S; s++){\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(s & (1<<i)) sum[s] += a[i];\n\t\t}\n\t}\n\t\n\tvector<int> vec;\n\tdp[0] = -inf;\n\tfor(int s = 1; s < S; s++){\n\t\tvec.clear();\n\t\tfor(int i = 0; i < N; i++) if(s & (1<<i)) vec.push_back(i);\n\t\tint n = vec.size();\n\t\tdp[s] = (sum[s] - mst[s]) / n;\n\t\tfor(int i = 0; i < (1<<n); i++){\n\t\t\tint bit = 0, cbit = 0;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(i & (1<<j)) bit |= (1<<vec[j]);\n\t\t\t\telse cbit |= (1<<vec[j]);\n\t\t\t}\n\t\t\tdp[s] = max(dp[s], min(dp[bit], dp[cbit]));\n\t\t}\n\t}\n\t\n\tprintf(\"%.11f\\n\", dp[S-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n    vector<int> par;\n    vector<int> sz;\n\n    UnionFind(int n=0){\n        if(n>0) initialize(n);\n    }\n\n    void initialize(int n){\n        par.resize(n);\n        sz.resize(n);\n        for(int i=0; i<n; i++){\n            par[i] = i;\n            sz[i] = 1;\n        }\n    }\n\n    int find(int x){\n        if(par[x] == x){\n            return x;\n        }else{\n            return par[x] = find(par[x]);\n        }\n    }\n\n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n        if(x == y) return;\n        if(sz[x] > sz[y]) swap(x, y);\n        par[x] = y;\n        sz[y] += sz[x];\n    }\n\n    bool same(int x, int y){\n        return find(x) == find(y);\n    }\n\n    int size(int x){\n        return sz[find(x)];\n    }\n};\n\nint nth_bit(int64_t num, int n){\n    return (num >> n) & 1;\n}\n\nvoid chmax(double& a, double b){\n\ta = max(a, b);\n}\n\nint main(){\n\tint N, X[15], Y[15], A[15];\n    cin >> N;\n\tfor(int i=0; i<N; i++) cin >> X[i] >> Y[i] >> A[i];\n\t\n\tdouble D[15][15];\n\tfor(int i=0; i<N; i++) for(int j=0; j<N; j++){\n\t\tdouble xd = X[i] - X[j], yd = Y[i] - Y[j];\n\t\tD[i][j] = sqrt(xd*xd + yd*yd);\n\t}\n\n\tint B = 1<<N;\n\tdouble dp[1<<15] = {0};\n\tdp[0] = 1e18;\n\tfor(int b=1; b<B; b++){\n\t\tint num = 0;\n\t\tfor(int i=0; i<N; i++) if(nth_bit(b, i)){\n\t\t\tnum++;\n\t\t\tdp[b] += A[i];\n\t\t}\n\n\t\tvector<pair<double, pair<int, int>>> edges;\n\t\tfor(int i=0; i<N; i++) for(int j=0; j<i; j++) if(nth_bit(b, i) && nth_bit(b, j)) edges.push_back({D[i][j], {i, j}});\n\t\tUnionFind uf(N);\n\t\tsort(edges.begin(), edges.end());\n\t\tfor(auto& e : edges){\n\t\t\tint i = e.second.first, j = e.second.second;\n\t\t\tif(!uf.same(i, j)){\n\t\t\t\tuf.unite(i, j);\n\t\t\t\tdp[b] -= e.first;\n\t\t\t}\n\t\t}\n\t\tdp[b] /= num;\n\t}\n\n\tfor(int b=1; b<B; b++){\n\t\tfor(int b2=b; b2>0; b2=(b2-1)&b){\n\t\t\tchmax(dp[b], min(dp[b2], dp[b-b2]));\n\t\t}\n\t}\n\n\tcout << fixed << setprecision(20) << dp[B-1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cmath>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ninline int bits(int m) { return (1<<m)-1; }\nusing Double = double;\nconst Double INF = 1e100;\n\nint N;\nLL X[15], Y[15], A[15];\n\nDouble D[15][15];\nDouble cst[1<<15];\nDouble sum[1<<15];\nbool dp[1<<15];\n\nbool ok(Double mid) {\n    Double need = 0;\n    Double rest = 0;\n    REP (i, N) {\n\tif (A[i] < mid) { need += mid - A[i]; }\n\telse { rest += A[i] - mid; }\n    }\n    if (need == 0) return true;\n    if (rest < need) return false;\n\n    REP (s, 1<<N) if (s) {\n\tREP (i, N) if (s>>i&1) {\n\t    sum[s] = sum[s^(1<<i)] + A[i];\n\t    break;\n\t}\n    }\n\n    memset(dp, 0, sizeof dp);\n    dp[0] = true;\n    REP (s, 1<<N) if (dp[s]) {\n\tint sup = bits(N) ^ s;\n\tfor (int t=sup; t; t=(t-1)&sup) {\n\t    if (sum[t] - __builtin_popcount(t) * mid - cst[t] >= 0) dp[s|t] = true;\n\t}\n    }\n\n    return dp[bits(N)];\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld%lld%lld\", X+i, Y+i, A+i);\n\n    REP (t, N) REP (i, N-1) if (A[i] > A[i+1]) {\n\tswap(X[i], X[i+1]);\n\tswap(Y[i], Y[i+1]);\n\tswap(A[i], A[i+1]);\n    }\n\n    REP (i, N) REP (j, N) D[i][j] = hypot((Double)X[i]-X[j], (Double)Y[i]-Y[j]);\n    REP (s, 1<<N) cst[s] = INF;\n    REP (s, 1<<N) {\n\tif (__builtin_popcount(s) <= 1) cst[s] = 0;\n\tREP (i, N) if (s>>i&1) REP (j, N) if (~s>>j&1) amin(cst[s|1<<j], cst[s] + D[i][j]);\n    }\n    \n    Double lo = *min_element(A, A+N), hi = *max_element(A, A+N);\n    REP (t, 60) {\n\tDouble mid = (lo + hi) / 2;\n\t(ok(mid)? lo: hi) = mid;\n    }\n    double ans = (lo + hi) / 2;\n    printf(\"%.12f\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define X first\n#define Y second\n#define pb emplace_back\n#define FOR(i,a,b) for(int (i)=(a);i<(b);++(i))\n#define EFOR(i,a,b) for(int (i)=(a);i<=(b);++(i))\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define REP rep\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define all(X) (X).begin(),(X).end()\n#define eb emplace_back\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\nconst ll MOD=1e9+7;\n\n#define rall(X) (X).rbegin(),(X).rend()\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n\nconst double EPS = 1e-10;\nconst double INF = 1.0/0.0;\n\nint N;\ndouble X[16];\ndouble Y[16];\ndouble A[16];\ndouble D[16][16];\ndouble dp[1 << 15];\nbool pos[1 << 15];\n\nbool check(double x) {\n  int lim = 1 << N;\n  fill(&dp[0], &dp[lim], -INF);\n  fill(&pos[0], &pos[lim], false);\n\n  int h = lower_bound(A, A+N, x) - A;\n  if (h == N) return false;\n  if (h == 0) return true;\n\n  rep(i, N) {\n    dp[1 << i] = A[i] - x;\n  }\n\n  rep(st, lim) {\n    rep(v, N) {\n      if (st >> v & 1) continue;\n      int nst = st | (1 << v);\n      rep(u, N) {\n        if (!(st >> u & 1)) continue;\n\n        //if (v >= h) MX(dp[nst], dp[st]);\n        MX(dp[nst], dp[st] - D[v][u] + A[v] - x);\n      }\n    }\n  }\n\n  rep(st, lim) {\n    if (dp[st] > -EPS) pos[st] = true;\n    rrep(U, lim) {\n      U &= st;\n      int V = st & ~U;\n      if (pos[U] && pos[V]) {\n        pos[st] = true; \n        break;\n      }\n    }\n  }\n\n  return pos[lim-1];\n  //if (dp[lim-1] > -EPS) return true;\n  //return false;\n}\n\nsigned main(){\n  ios_base::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n\n  cin >> N;\n  double high = 0;\n  using Pair = pair<int, pii>;\n  vector<Pair> ds;\n  rep(i, N) {\n    int x, y, a;\n    cin >> x >> y >> a;\n    ds.eb(Pair(a, pii(x, y)));\n    MX(high, double(a));\n  }\n  sort(all(ds));\n\n  rep(i, N) {\n    A[i] = ds[i].X;\n    X[i] = ds[i].Y.X;\n    Y[i] = ds[i].Y.Y;\n  }\n\n  rep(i, N) {\n    rep(j, N) {\n      double dx = X[i]-X[j];\n      double dy = Y[i]-Y[j];\n      D[i][j] = sqrt(dx*dx + dy*dy);\n    }\n  }\n\n  double low = 0;\n  rep(i, 45) {\n    double mid = (low+high)/2;\n    if (check(mid)) low = mid;\n    else high = mid;\n  }\n  cout << low << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\ndouble x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\t\t\tif (dp[i][mask] >= 0) \n\t\t\t{\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 1e100, Q = 0, R;\n\tF0(i, n) Q = max(Q, 1.0 * a[i]);\n\tF0(i, n) P = min(P, 1.0 * a[i]);\n\tF0(it, 150) {\n\t\tif (Q - P < 1e-10) break;\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", (P + Q) / 2.0);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef pair<ll,ll> pll;\ntypedef vector<bool> vb;\nconst ll oo = 0x3f3f3f3f3f3f3f3f;\nconst double eps = 1e-9;\n#define sz(c) ll((c).size())\n#define all(c) begin(c), end(c)\n#define FOR(i,a,b) for (ll i = (a); i < (b); i++)\n#define FORD(i,a,b) for (ll i = (b)-1; i >= (a); i--)\n#define mp make_pair\n#define mt make_tuple\n#define pb push_back\n#define eb emplace_back\n#define xx first\n#define yy second\n#define has(c,i) ((c).find(i) != end(c))\n#define DBGDO(X) ({ if(1) cerr << \"DBGDO: \" << (#X) << \" = \" << (X) << endl; })\n\nll n, x[15], y[15], a[15], p[15];\n\nll Find(ll x) {\n\tif (x == p[x]) return x;\n\treturn p[x] = Find(p[x]);\n}\n\nbool Union(ll x, ll y) {\n\tx = Find(x), y = Find(y);\n\tif (x == y) return false;\n\tif (rand() & 1) swap(x,y);\n\tp[x] = y;\n\treturn true;\n}\n\n\nint main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(NULL);\n\n\tcin >> n;\n\tFOR(i,0,n) cin >> x[i] >> y[i] >> a[i];\n\n\tvector<double> dp(1 << n);\n\tFOR(mask,0,1 << n) {\n\t\tvector<pair<double,pll>> q;\n\t\tFOR(i,0,n) if (mask & (1 << i)) FOR(j,0,n) if (mask & (1 << j))\n\t\t\tq.pb({hypot(x[i]-x[j],y[i]-y[j]),{i,j}});\n\t\tsort(all(q));\n\n\t\tiota(p,p+n,0);\n\t\tFOR(i,0,n) if (mask & (1 << i)) dp[mask] += a[i];\n\t\tfor (auto e: q) if (Union(e.yy.xx,e.yy.yy)) dp[mask] -= e.xx;\n\t\tdp[mask] /= __builtin_popcount(mask);\n\n\t\tfor (ll mask1 = mask; mask1; mask1 = (mask1 - 1) & mask)\n\t\t\tdp[mask] = max(dp[mask], min(dp[mask1],dp[mask ^ mask1]));\n\t}\n\tcout << fixed << setprecision(12) << dp[(1 << n) - 1] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nint x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\t\t\tif (dp[i][mask] >= 0) {\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\t//if (e[i] < 0 && e[j] < 0) continue;\n\t\t\t//if (e[i] >= 0 && e[j] >= 0) continue;\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 0.0, Q = 0, R;\n\tF0(i, n) Q = max(Q, 1.0 * a[i]);\n\tF0(it, 50) {\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nint x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\n\t\t\tif (dp[i][mask] >= 0) \n\t\t\t{\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 1e100, Q = 0, R;\n\tF0(i, n) Q = max(Q, 1.0 * a[i]);\n\tF0(i, n) P = min(P, 1.0 * a[i]);\n\tF0(it, 100) {\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<cstring>\n#include<cstdlib>\n#include<cmath>\n#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<queue>\n#include<bitset>\n#include<utility>\n#include<functional>\n#include<iomanip>\n#include<sstream>\n#include<ctime>\n#include<cassert>\nusing namespace std;\n#define y0 y0z\n#define y1 y1z\n#define yn ynz\n#define j0 j0z\n#define j1 j1z\n#define jn jnz\n#define tm tmz\n#define buli(x) (__builtin_popcountll(x))\n#define bur0(x) (__builtin_ctzll(x))\n#define bul2(x) (63-__builtin_clzll(x))\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n#define fil(a,b) memset((a),(b),sizeof(a))\n#define cl(a) fil(a,0)\n#define siz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define foreach(it,a) for(__typeof((a).begin()) it=(a).begin();it!=(a).end();it++)\n#define rep(i,a,b) for (int i=(a),_ed=(b);i<_ed;i++)\n#define per(i,a,b) for (int i=(b)-1,_ed=(a);i>=_ed;i--)\n#define forg(i,gu) for (int i=gu;~i;i=e[i].next)\n#define pw(x) ((ll(1))<<(x))\n#define upmo(a,b) (((a)=((a)+(b))%mo)<0?(a)+=mo:(a))\n#define mmo(a,b) (((a)=1ll*(a)*(b)%mo)<0?(a)+=mo:(a))\nvoid getre(){int x=0;printf(\"%d\\n\",1/x);}\nvoid gettle(){int res=1;while(1)res<<=1;printf(\"%d\\n\",res);}\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<pii> vpii;\ntemplate<typename T,typename S>inline bool upmin(T&a,const S&b){return a>b?a=b,1:0;}\ntemplate<typename T,typename S>inline bool upmax(T&a,const S&b){return a<b?a=b,1:0;}\ntemplate<typename N,typename PN>inline N flo(N a,PN b){return a>=0?a/b:-((-a-1)/b)-1;}\ntemplate<typename N,typename PN>inline N cei(N a,PN b){return a>0?(a-1)/b+1:-(-a/b);}\ntemplate<typename N>N gcd(N a,N b){return b?gcd(b,a%b):a;}\ntemplate<typename N>inline int sgn(N a){return a>0?1:(a<0?-1:0);}\n#if ( ( _WIN32 || __WIN32__ ) && __cplusplus < 201103L)\n#define lld \"%I64d\"\n#else\n#define lld \"%lld\"\n#endif\ninline void gn(long long&x){\n\tint sg=1;char c;while(((c=getchar())<'0'||c>'9')&&c!='-');c=='-'?(sg=-1,x=0):(x=c-'0');\n\twhile((c=getchar())>='0'&&c<='9')x=x*10+c-'0';x*=sg;\n}\ninline void gn(int&x){long long t;gn(t);x=t;}\ninline void gn(unsigned long long&x){long long t;gn(t);x=t;}\ninline void gn(double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gn(long double&x){double t;scanf(\"%lf\",&t);x=t;}\ninline void gs(char *s){scanf(\"%s\",s);}\ninline void gc(char &c){while((c=getchar())>126 || c<33);}\ninline void pc(char c){putchar(c);}\n#ifdef JCVB\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define debug(...)\n#endif\ntypedef long long ll;\ntypedef double db;\ninline ll sqr(ll a){return a*a;}\ninline db sqrf(db a){return a*a;}\nconst int inf=0x3f3f3f3f;\nconst db pi=3.14159265358979323846264338327950288L;\nconst db eps=1e-6;\n//const int mo=0;\n//int qp(int a,ll b){int n=1;do{if(b&1)n=1ll*n*a%mo;a=1ll*a*a%mo;}while(b>>=1);return n;}\n\nint n;\n\nstruct pkt{\n\tint x,y;\n\tvoid read(){gn(x);gn(y);}\n\tll dissq(){return 1ll*x*x+1ll*y*y;}\n\tfriend pkt operator+(const pkt&a,const pkt&b){return (pkt){a.x+b.x,a.y+b.y};}\n\tfriend pkt operator-(const pkt&a,const pkt&b){return (pkt){a.x-b.x,a.y-b.y};}\n\tfriend pkt operator-(const pkt&a){return (pkt){-a.x,-a.y};}\n\tfriend ll dot(const pkt&a,const pkt&b){return 1ll*a.x*b.x+1ll*a.y*b.y;}\n\tfriend ll cro(const pkt&a,const pkt&b){return 1ll*a.x*b.y-1ll*a.y*b.x;}\n\tfriend bool operator<(const pkt&a,const pkt&b){return a.y==b.y?a.x<b.x:a.y<b.y;}\n\t/*friend bool operator<(const pkt&a,const pkt&b){\n\t\tint aa=a.y>0 || a.y==0&& a.x>0;\n\t\tint bb=b.y>0 || b.y==0&& b.x>0;\n\t\tif(aa!=bb)return aa<bb;\n\t\telse return cro(a,b)>0;\n\t}*/\n}p[15];\n\n\ndb mst[1<<15];\n\nint fa[15];\nint gf(int x){\n\treturn x==fa[x]?x:fa[x]=gf(fa[x]);\n}\nbool un(int u,int v){\n\tu=gf(u);v=gf(v);\n\tif(u!=v){\n\t\tfa[u]=v;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstruct edg{\n\tint u,v;\n\tdb x;\n}ee[1111];\nint cmp(const edg&a,const edg&b){\n\treturn a.x<b.x;\n}\nint etot;\n\ndb gao(int b){\n\tetot=0;\n\trep(i,0,n)fa[i]=i;\n\trep(i,0,n)if(pw(i)&b)rep(j,i+1,n)if(pw(j)&b){\n\t\tee[++etot]=(edg){i,j,sqrt((p[i]-p[j]).dissq())};\n\t}\n\tsort(ee+1,ee+1+etot,cmp);\n\tdb su=0.0;\n\trep(i,1,etot+1){\n\t\tif(un(ee[i].u,ee[i].v))su+=ee[i].x;\n\t}\n\treturn su;\n}\ndb ini[15];\n\ndb f[1<<15];\nint main()\n{\n#ifdef JCVB\n\t//freopen(\"1.in\",\"r\",stdin);\n\t//freopen(\"1.out\",\"w\",stdout);\n\tint _time_jc=clock();\n#endif\n\tgn(n);\n\trep(i,0,n){\n\t\tp[i].read();\n\t\tgn(ini[i]);\n\t}\n\t\n\trep(b,1,pw(n)){\n\t\tmst[b]=gao(b);\n\t}\n\trep(b,1,pw(n)){\n\t\tdb mia=1e18;\n\t\tdb su=0.0;\n\t\tint cnt=0;\n\t\trep(i,0,n)if(pw(i)&b){\n\t\t\tupmin(mia,ini[i]);\n\t\t\tsu+=ini[i];\n\t\t\tcnt++;\n\t\t}\n\t\tf[b]=mia;\n\n\t\tsu-=mst[b];\n\t\tupmax(su,0.0);\n\t\tsu/=cnt;\n\t\tupmax(f[b],su);\n\t}\n\n\tf[0]=0.0;\n\trep(b,1,pw(n)){\n\t\tfor (int x=b;x;x=(x-1)&b){\n\t\t\tupmax(f[b],min(f[x],f[b^x]));\n\t\t}\n\t}\n\tprintf(\"%.10lf\\n\",f[pw(n)-1]);\n\n\n#ifdef JCVB\n\tdebug(\"time: %d\\n\",int(clock()-_time_jc));\n#endif\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cmath>\n#include<stdio.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<string.h>\n\n#ifdef LOCAL\n#define eprintf(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define NDEBUG\n#define eprintf(...) do {} while (0)\n#endif\n#include<cassert>\n\nusing namespace std;\n\ntypedef long long LL;\ntypedef vector<int> VI;\n\n#define REP(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i)\n#define EACH(i,c) for(__typeof((c).begin()) i=(c).begin(),i##_end=(c).end();i!=i##_end;++i)\n\ntemplate<class T> inline void amin(T &x, const T &y) { if (y<x) x=y; }\ntemplate<class T> inline void amax(T &x, const T &y) { if (x<y) x=y; }\ntemplate<class Iter> void rprintf(const char *fmt, Iter begin, Iter end) {\n    for (bool sp=0; begin!=end; ++begin) { if (sp) putchar(' '); else sp = true; printf(fmt, *begin); }\n    putchar('\\n');\n}\ninline int bits(int m) { return (1<<m)-1; }\nusing Double = double;\nconst Double INF = 1e100;\n\nint N;\nLL X[15], Y[15], A[15];\n\nDouble D[15][15];\nDouble cst[1<<15];\nDouble sum[1<<15];\nbool dp[1<<15];\n\nbool ok(Double mid) {\n    Double need = 0;\n    Double rest = 0;\n    REP (i, N) {\n\tif (A[i] < mid) { need += mid - A[i]; }\n\telse { rest += A[i] - mid; }\n    }\n    if (need == 0) return true;\n    if (rest < need) return false;\n\n    REP (s, 1<<N) if (s) {\n\tREP (i, N) if (s>>i&1) {\n\t    sum[s] = sum[s^(1<<i)] + A[i];\n\t    break;\n\t}\n    }\n\n    memset(dp, 0, sizeof dp);\n    dp[0] = true;\n    REP (s, 1<<N) if (dp[s]) {\n\tint other = bits(N) ^ s;\n\tint sup = other & (other-1);\n\tint small = sup ^ other;\n\tfor (int t=sup; ; t=(t-1)&sup) {\n\t    if (sum[t|small] - __builtin_popcount(t|small) * mid - cst[t|small] >= 0) dp[s|t|small] = true;\n\t    if (t == 0) break;\n\t}\n    }\n\n    return dp[bits(N)];\n}\n\nvoid MAIN() {\n    scanf(\"%d\", &N);\n    REP (i, N) scanf(\"%lld%lld%lld\", X+i, Y+i, A+i);\n\n    REP (t, N) REP (i, N-1) if (A[i] > A[i+1]) {\n\tswap(X[i], X[i+1]);\n\tswap(Y[i], Y[i+1]);\n\tswap(A[i], A[i+1]);\n    }\n\n    REP (i, N) REP (j, N) D[i][j] = hypot((Double)X[i]-X[j], (Double)Y[i]-Y[j]);\n    REP (s, 1<<N) cst[s] = INF;\n    REP (s, 1<<N) {\n\tif (__builtin_popcount(s) <= 1) cst[s] = 0;\n\tREP (i, N) if (s>>i&1) REP (j, N) if (~s>>j&1) amin(cst[s|1<<j], cst[s] + D[i][j]);\n    }\n    \n    Double lo = *min_element(A, A+N), hi = *max_element(A, A+N);\n    REP (t, 60) {\n\tDouble mid = (lo + hi) / 2;\n\t(ok(mid)? lo: hi) = mid;\n    }\n    double ans = (lo + hi) / 2;\n    printf(\"%.12f\\n\", ans);\n}\n\nint main() {\n    int TC = 1;\n//    scanf(\"%d\", &TC);\n    REP (tc, TC) MAIN();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nint x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\t\t\tif (dp[i][mask] >= 0) {\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\t//if (e[i] < 0 && e[j] < 0) continue;\n\t\t\t//if (e[i] >= 0 && e[j] >= 0) continue;\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 1e100, Q = 0, R;\n\tF0(i, n) Q = max(Q, 1.0 * a[i]);\n\tF0(i, n) P = min(P, 1.0 * a[i]);\n\tF0(it, 60) {\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// #include {{{\n#include <iostream>\n#include <cassert>\n#include <cstring>\n#include <cstdlib>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <ctime>\n#include <queue>\n#include <set>\n#include <map>\n#include <stack>\n#include <string>\n#include <bitset>\n#include <vector>\n#include <complex>\n#include <algorithm>\nusing namespace std;\n// }}}\n// #define {{{\ntypedef long long ll;\ntypedef double db;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\n#define de(x) cout << #x << \"=\" << x << endl\n#define rep(i,a,b) for(int i=a;i<(b);++i)\n#define per(i,a,b) for(int i=(b)-1;i>=(a);--i)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) (int)(x).size()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n// }}}\n\nconst int N = 15;\nint n , x[N] , y[N] , a[N] , fa[N];\ndb f[1 << N] , dis[N][N];\ninline int F(int x) {return fa[x] == x ? x : fa[x] = F(fa[x]);}\n\nint main(){\n  cin >> n;\n  rep(i,0,n) cin >> x[i] >> y[i] >> a[i];\n  rep(i,0,n) rep(j,0,n) {\n    db dx = x[i] - x[j];\n    db dy = y[i] - y[j];\n    dis[i][j] = sqrt(dx*dx+dy*dy);\n  }\n  rep(i,0,1<<n) {\n    if(i == 0) continue;\n    vi pts;\n    rep(j,0,n) if(i >> j & 1) pts.pb(j);\n    vector<pair<db,pii> > edges;\n    rep(i,0,sz(pts)) rep(j,0,i) {\n      edges.pb(mp(dis[pts[i]][pts[j]] , mp(pts[i] , pts[j])));\n    }\n    sort(all(edges));\n    for(int p : pts) fa[p] = p;\n    db cost = 0.;\n    for(auto e : edges) {\n      int u = F(e.se.fi);\n      int v = F(e.se.se);\n      if(u != v) {\n        fa[v] = u;\n        cost += e.fi;\n      }\n    }\n    db sum = 0;\n    for(int p : pts) sum += a[p];\n    f[i] = (sum - cost) / sz(pts);\n  }\n  rep(i,1,1<<n) {\n    for(int j=i;j;j=(j-1)&i) {\n      f[i] = max(f[i] , min(f[j] , f[i ^ j]));\n    }\n  }\n  printf(\"%.12f\\n\",f[(1<<n)-1]);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1.0);\n\nvoid precalc() {\n}\n\nconst int maxn = 15;\nint xs[maxn], ys[maxn], a[maxn];\n\nint n;\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return 0;\n  }\n  for (int i = 0; i < n; ++i) {\n    scanf(\"%d%d%d\", xs + i, ys + i, a + i);\n  }\n  return 1;\n}\n\nlong long sum[1 << maxn];\nld dp[1 << maxn];\n\nld ans[1 << maxn];\n\nld dist[maxn][maxn];\n\nvoid solve() {\n  sum[0] = 0;\n  dp[0] = 0;\n\n  for (int i = 0; i < n; ++i) {\n    for (int j = 0; j < n; ++j) {\n      int dx = xs[i] - xs[j], dy = ys[i] - ys[j];\n      dist[i][j] = sqrt((ld) dx * dx + (ld) dy * dy);\n    }\n  }\n\n  ans[0] = inf;\n  for (int mask = 1; mask < (1 << n); ++mask) {\n    int id = __builtin_ctz(mask);\n    sum[mask] = sum[mask ^ (1 << id)] + a[id];\n\n    if (mask == (1 << id)) {\n      dp[mask] = 0;\n    } else {\n      dp[mask] = 1e18;\n      for (int i = 0; i < n; ++i) {\n        if (!((mask >> i) & 1)) {\n          continue;\n        }\n        for (int j = 0; j < n; ++j) {\n          if (i == j || !((mask >> j) & 1)) {\n            continue;\n          }\n          dp[mask] = min(dp[mask], dp[mask ^ (1 << i)] + dist[i][j]);\n        }\n      }\n    }\n\n    ans[mask] = (sum[mask] - dp[mask]) / __builtin_popcount(mask);\n    for (int x = mask; x; x = ((x - 1) & mask)) {\n      ans[mask] = max(ans[mask], min(ans[x], ans[mask ^ x]));\n    }\n  }\n  printf(\"%.18f\\n\", (double) ans[(1 << n) - 1]);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  freopen(TASK \".out\", \"w\", stdout);\n  assert(freopen(TASK \".in\", \"r\", stdin));\n#endif\n\n  while (1) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef signed long long ll;\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define FOR(x,to) for(x=0;x<(to);x++)\n#define FORR(x,arr) for(auto& x:arr)\n#define ITR(x,c) for(__typeof(c.begin()) x=c.begin();x!=c.end();x++)\n#define ALL(a) (a.begin()),(a.end())\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n//-------------------------------------------------------\n\nint N;\nint X[15],Y[15],A[15];\ndouble AS[1<<15],DS[1<<15],V[1<<15];\ndouble D[15][15];\nvector<int> C[1<<15];\n\nvoid solve() {\n\tint i,j,k,l,r,x,y; string s;\n\t\n\tcin>>N;\n\tFOR(i,N) cin>>X[i]>>Y[i]>>A[i];\n\tFOR(x,N) FOR(y,N) D[x][y]=hypot(X[x]-X[y],Y[x]-Y[y]);\n\t\n\tfor(int mask=1;mask<1<<N;mask++) {\n\t\tFOR(i,N) if(mask&(1<<i)) {\n\t\t\tAS[mask]+=A[i];\n\t\t\tC[mask].push_back(i);\n\t\t}\n\t\t\t\n\t\tif(__builtin_popcount(mask)==1) {\n\t\t\tV[mask]=AS[mask];\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tDS[mask]=1e10;\n\t\tfor(int smask=(mask-1)&mask; smask>0; smask=(smask-1)&mask) {\n\t\t\tFORR(x,C[smask]) FORR(y,C[smask^mask]) {\n\t\t\t\tDS[mask]=min(DS[mask],DS[smask]+DS[mask^smask]+D[x][y]);\n\t\t\t}\n\t\t}\n\t\tV[mask]=(AS[mask]-DS[mask])/__builtin_popcount(mask);\n\t\tfor(int smask=(mask-1)&mask; smask>0; smask=(smask-1)&mask) {\n\t\t\tV[mask]=max(V[mask],min(V[smask],V[mask^smask]));\n\t\t}\n\t}\n\t_P(\"%.12lf\\n\",V[(1<<N)-1]);\n\t\n}\n\n\nint main(int argc,char** argv){\n\tstring s;int i;\n\tif(argc==1) ios::sync_with_stdio(false), cin.tie(0);\n\tFOR(i,argc-1) s+=argv[i+1],s+='\\n'; FOR(i,s.size()) ungetc(s[s.size()-1-i],stdin);\n\tcout.tie(0); solve(); return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#endif\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long ll;\n\n#ifdef DEBUG\n#define eprintf(...) fprintf(stderr, __VA_ARGS__), fflush(stderr)\n#else\n#define eprintf(...) ;\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define sz(x) ((int) (x).size())\n#define TASK \"text\"\n\nconst int inf = (int) 1.01e9;\nconst ld eps = 1e-9;\nconst ld pi = acos((ld) -1);\n\nmt19937 mrand(random_device{} ()); \n\nint rnd(int x) {\n  return mrand() % x;\n}\n\nvoid precalc() {\n}\n\nstruct point {\n  int x, y;\n\n  point() {}\n\n  point(int _x, int _y): x(_x), y(_y) {}\n\n  point operator - (const point &p) const {\n    return point(x - p.x, y - p.y);\n  }\n\n  long long slen() const {\n    return (long long) x * x + (long long) y * y;\n  }\n\n  ld len() const {\n    return sqrt(slen());\n  }\n};\n\nconst int maxn = 16, pown = (1 << maxn);\nint n;\npoint p[maxn];\nint a[maxn];\n\nint read() {\n  if (scanf(\"%d\", &n) < 1) {\n    return false;\n  }\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d%d%d\", &p[i].x, &p[i].y, &a[i]);\n  }\n  return true;\n}\n\nld mst[pown];\nld val[pown];\nld dp[pown];\n\nvoid solve() {\n  mst[0] = 0;\n  for (int i = 1; i < (1 << n); i++) {\n    if (__builtin_popcount(i) == 1) {\n      mst[i] = 0;\n    } else {\n      mst[i] = 100. * inf;\n      for (int j = 0; j < n; j++) {\n        if (i & (1 << j)) {\n          for (int k = 0; k < n; k++) {\n            if (k != j && (i & (1 << k))) {\n              mst[i] = min(mst[i], mst[i ^ (1 << j)] + (p[j] - p[k]).len());\n            }\n          }\n        }\n      }\n    }\n    val[i] = 0;\n    for (int j = 0; j < n; j++) {\n      if (i & (1 << j)) {\n        val[i] += a[j];\n      }\n    }\n    val[i] -= mst[i];\n    val[i] /= __builtin_popcount(i);\n  }\n  dp[0] = inf;\n  for (int i = 1; i < (1 << n); i++) {\n    dp[i] = 0;\n    for (int j = i;; j = ((j - 1) & i)) {\n      dp[i] = max(dp[i], min(dp[i ^ j], val[j]));\n      if (!j) {\n        break;\n      }\n    }\n  }\n  printf(\"%.20f\\n\", (double) dp[(1 << n) - 1]);\n}\n\nint main() {\n  precalc();\n#ifdef LOCAL\n  assert(freopen(TASK \".in\", \"r\", stdin));\n  assert(freopen(TASK \".out\", \"w\", stdout));\n#endif\n  while (true) {\n    if (!read()) {\n      break;\n    }\n    solve();\n#ifdef DEBUG\n    eprintf(\"Time %.2f\\n\", (double) clock() / CLOCKS_PER_SEC);\n#endif\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define VI vector<int>\n\nint main() {\n    //ifstream cin(\"testE.in\");\n    int n; cin >> n;\n\n    vector<int> x(n, 0), y(n, 0), a(n, 0);\n    for(int i = 0; i < n; ++i)\n        cin >> x[i] >> y[i] >> a[i];\n    \n    vector<vector<double>> d(n, vector<double>(n, 0));\n\n    auto getDist = [&] (int i, int j) -> double {\n        double ans = sqrt(0.0 + 1LL * (x[i] - x[j]) * (x[i] - x[j]) + 1LL * (y[i] - y[j]) * (y[i] - y[j]));\n        return ans;\n    };\n    \n    for(int i = 0; i < n; ++i)\n        for(int j = 0; j < n; ++j)\n            d[i][j] = getDist(i, j);\n\n    auto mst = [&] (vector<int> v) {\n        int m = v.size();\n        vector<double> dist(m, 2e10);\n        vector<int> in(m, 0);\n        for(int i = 0; i < m; ++i) {\n            dist[i] = d[v[i]][v[0]];\n        }\n\n        in[0] = 1;\n        double ans = 0.0;\n\n        for(int it = 0; it < m - 1; ++it) {\n            double minn = 2e10;\n            int who = -1;\n            for(int i = 0; i < m; ++i)\n                if(not in[i] and dist[i] < minn) {\n                    minn = dist[i];\n                    who = i;\n                }\n            \n            ans += minn;\n            in[who] = 1;\n            for(int i = 0; i < m; ++i)\n                if(not in[i])\n                    dist[i] = min(dist[i], d[v[who]][v[i]]);\n        }\n        \n        return ans;\n    };\n    \n    vector<double> costComp((1 << n), 0);\n\n    for(int mask = 1; mask < (1 << n); ++mask) {\n        double cost = 0;\n        vector<int> sub;\n        for(int i = 0; i < n; ++i) {\n            if((1 << i) & mask) {\n                cost += a[i];\n                sub.push_back(i);\n            }\n        }\n        costComp[mask] = (cost - mst(sub)) / (sub.size() + 0.0);\n    }\n    \n    vector<double> dp((1 << n), 0);\n    dp[0] = 1e10;\n\n    for(int mask = 0; mask < (1 << n); ++mask) {\n        for(int sub = mask; sub > 0; sub = ((sub - 1) & mask)) {\n            dp[mask] = max(dp[mask], min(dp[mask - sub], costComp[sub]));\n        }\n    }\n\n    cout.precision(15);\n    cout << dp[(1 << n) - 1] << \"\\n\";\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nint x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\t\t\tif (dp[i][mask] >= 0) \n\t\t\t{\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 1e100, Q = 0, R;\n\tF0(i, n) Q = max(Q, 1.0 * a[i]);\n\tF0(i, n) P = min(P, 1.0 * a[i]);\n\tF0(it, 150) {\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  edge &operator=(const int &x) {\n    to = x;\n    return *this;\n  }\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\nstruct UnionFind {\n  vector< int > data;\n\n  UnionFind(int sz) {\n    data.assign(sz, -1);\n  }\n\n  bool unite(int x, int y) {\n    x = find(x), y = find(y);\n    if(x == y) return (false);\n    if(data[x] > data[y]) swap(x, y);\n    data[x] += data[y];\n    data[y] = x;\n    return (true);\n  }\n\n  int find(int k) {\n    if(data[k] < 0) return (k);\n    return (data[k] = find(data[k]));\n  }\n\n  int size(int k) {\n    return (-data[find(k)]);\n  }\n};\n\n\ntemplate< typename T >\nT kruskal(Edges< T > &edges, int V) {\n  sort(begin(edges), end(edges), [](const edge< T > &a, const edge< T > &b) {\n    return (a.cost < b.cost);\n  });\n  UnionFind tree(V);\n  T ret = 0;\n  for(auto &e : edges) {\n    if(tree.unite(e.src, e.to)) ret += e.cost;\n  }\n  return (ret);\n}\n\nint main() {\n  int N, X[15], Y[15], A[15];\n\n\n  cin >> N;\n  for(int i = 0; i < N; i++) {\n    cin >> X[i] >> Y[i] >> A[i];\n  }\n  double dp[1 << 15] = {};\n  fill_n(dp, 1 << 15, -1e30);\n  for(int i = 1; i < (1 << N); i++) {\n    Edges< double > edges;\n    int64 sum = 0;\n    for(int j = 0; j < N; j++) {\n      if((i >> j) & 1) {\n        sum += A[j];\n        for(int k = j + 1; k < N; k++) {\n          if((i >> k) & 1) {\n            edges.emplace_back(j, k, hypot(X[j] - X[k], Y[j] - Y[k]));\n          }\n        }\n      }\n    }\n    dp[i] = (sum - kruskal(edges, N)) / __builtin_popcount(i);\n  }\n\n  for(int bit = 0; bit < (1 << N); bit++) {\n    for(int i = bit; i > 0; i = (i - 1) & bit) {\n      int other = i ^bit;\n      dp[bit] = max(dp[bit], min(dp[i], dp[other]));\n    }\n  }\n  cout << fixed << setprecision(12) << dp[(1 << N) - 1] << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ADD(a, b) a = (a + ll(b)) % mod\n#define MUL(a, b) a = (a * ll(b)) % mod\n#define MAX(a, b) a = max(a, b)\n#define MIN(a, b) a = min(a, b)\n#define rep(i, a, b) for(int i = int(a); i < int(b); i++)\n#define rer(i, a, b) for(int i = int(a) - 1; i >= int(b); i--)\n#define all(a) (a).begin(), (a).end()\n#define sz(v) (int)(v).size()\n#define pb push_back\n#define sec second\n#define fst first\n#define debug(fmt, ...) Debug(__LINE__, \":\", fmt, ##__VA_ARGS__)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<int, pi> ppi;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vl> mat;\ntypedef complex<double> comp;\nvoid Debug() {cout << '\\n'; }\ntemplate<class FIRST, class... REST>void Debug(FIRST arg, REST... rest){\n\tcout<<arg<<\" \";Debug(rest...);}\ntemplate<class T>ostream& operator<<(ostream& out,const vector<T>& v) {\n\tout<<\"[\";if(!v.empty()){rep(i,0,sz(v)-1)out<<v[i]<<\", \";out<<v.back();}out<<\"]\";return out;}\ntemplate<class S, class T>ostream& operator<<(ostream& out,const pair<S, T>& v){\n\tout<<\"(\"<<v.first<<\", \"<<v.second<<\")\";return out;}\nconst int MAX_N = 200010;\nconst int MAX_V = 100010;\nconst double eps = 1e-6;\nconst ll mod = 1000000007;\nconst int inf = 1 << 29;\nconst ll linf = 1LL << 60;\nconst double PI = 3.14159265358979323846;\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\ntypedef pair<pi, double> pd;\n\nint N;\ndouble C[(1 << 15)];\ndouble dp[(1 << 15)];\n\ndouble X[15], Y[15], cap[15];\n\nint par[MAX_N];\n\nint find(int p) {\n\tif(p == par[p]) return p;\n\telse return par[p] = find(par[p]);\n}\n\ndouble dist(int a, int b) {\n\tdouble dx = X[a] - X[b], dy = Y[a] - Y[b];\n\treturn sqrt(dx * dx + dy * dy);\n}\n\ndouble pre(int bit) {\n\tvector<pd> e;\n\trep(i, 0, N) {\n\t\trep(j, i + 1, N) {\n\t\t\tif(!(bit & (1 << i)) || !(bit & (1 << j))) continue;\n\t\t\te.pb(make_pair(pi(i, j), dist(i, j)));\n\t\t}\n\t}\n\tsort(all(e), [](const pd& p1, const pd& p2){return p1.sec < p2.sec;});\n\n\trep(i, 0, N) par[i] = i;\n\tdouble res = 0;\n\tfor(auto p : e) {\n\t\tint a, b;\n\t\ttie(a, b) = p.fst;\n\t\tdouble d = p.sec;\n\t\ta = find(a); b = find(b);\n\t\tif(a != b) {\n\t\t\tres -= d;\n\t\t\tpar[a] = b;\n\t\t}\n\t}\n\n\tint cnt = 0;\n\trep(i, 0, N) {\n\t\tif(!(bit & (1 << i))) continue;\n\t\tcnt++;\n\t\tres += cap[i];\n\t}\n\treturn res / cnt;\n}\n\nvoid solve() {\n\tcin >> N;\n\trep(i, 0, N) cin >> X[i] >> Y[i] >> cap[i];\n\trep(bit, 1, (1 << N)) {\n\t\tC[bit] = pre(bit);\n\t}\n\trep(i, 0, (1 << N)) dp[i] = -inf;\n\n\tdp[0] = inf;\n\trep(bit, 0, (1 << N)) {\n\t\tvector<int> vec;\n\t\trep(i, 0, N) {\n\t\t\tif(!(bit & (1 << i))) vec.pb(i);\n\t\t}\n\t\tint sn = sz(vec);\n\t\trep(bit2, 1, (1 << sn)) {\n\t\t\tint sbit = 0;\n\t\t\trep(i, 0, N) {\n\t\t\t\tif(!(bit2 & (1 << i))) continue;\n\t\t\t\tsbit |= (1 << vec[i]);\n\t\t\t}\n\t\t\tdp[bit | sbit] = max(dp[bit | sbit], min(dp[bit], C[sbit]));\n\t\t}\n\t}\n\tcout << dp[(1 << N) - 1] << \"\\n\";\n}\n\nint main() {\n#ifndef LOCAL\n\tios::sync_with_stdio(false);\n    cin.tie(0);\n#endif\n    cout << fixed;\n\tcout.precision(20);\n\tsrand((unsigned int)time(NULL));\n#ifdef LOCAL\n\t//freopen(\"in.txt\", \"wt\", stdout); //for tester\n    freopen(\"in.txt\", \"rt\", stdin);\n#endif\t\n\tsolve();\n#ifdef LOCAL\n    cerr << \"Time elapsed: \" << 1.0 * clock() / CLOCKS_PER_SEC << \" s.\\n\";\n#endif\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n \nusing namespace std;\nusing namespace __gnu_pbds;\n \n#define fi first\n#define se second\n#define mp make_pair\n#define pb push_back\n#define fbo find_by_order\n#define ook order_of_key\n \ntypedef long long ll;\ntypedef pair<ll,ll> ii;\ntypedef vector<int> vi;\ntypedef long double ld; \ntypedef tree<int, null_type, less<int>, rb_tree_tag, tree_order_statistics_node_update> pbds;\ntypedef set<int>::iterator sit;\ntypedef map<int,int>::iterator mit;\ntypedef vector<int>::iterator vit;\ntypedef pair<ld,ld> point;\n\nconst int N = 16;\n\nld dist[N][N];\npoint pt[N];\nld mst[(1<<N)];\nld dp[(1<<N)];\nld tot[N];\nld d(point x, point y)\n{\n\treturn sqrt((x.fi-y.fi)*(x.fi-y.fi) + (x.se-y.se)*(x.se-y.se));\n}\n\nstruct DSU\n{\n\tint S;\n\t\n\tstruct node\n\t{\n\t\tint p; ll sum;\n\t};\n\tvector<node> dsu;\n\t\n\tDSU(int n)\n\t{\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tvoid reset(int n)\n\t{\n\t\tdsu.clear();\n\t\tS = n;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tnode tmp;\n\t\t\ttmp.p = i; tmp.sum = 0;\n\t\t\tdsu.pb(tmp);\n\t\t}\n\t}\n\t\n\tint rt(int u)\n\t{\n\t\tif(dsu[u].p == u) return u;\n\t\tdsu[u].p = rt(dsu[u].p);\n\t\treturn dsu[u].p;\n\t}\n\t\n\tvoid merge(int u, int v)\n\t{\n\t\tu = rt(u); v = rt(v);\n\t\tif(u == v) return ;\n\t\tif(rand()&1) swap(u, v);\n\t\tdsu[v].p = u;\n\t\tdsu[u].sum += dsu[v].sum;\n\t}\n\t\n\tbool sameset(int u, int v)\n\t{\n\t\tif(rt(u) == rt(v)) return true;\n\t\treturn false;\n\t}\n\t\n\tll getstat(int u)\n\t{\n\t\treturn dsu[rt(u)].sum;\n\t}\n};\n\nint n; \n\nvoid calcmst(int mask)\n{\n\tDSU dsu(15);\n\tvector<pair<ld,ii> > vec;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(i==j) continue;\n\t\t\tif((mask&(1<<i))&&(mask&(1<<j)))\n\t\t\t{\n\t\t\t\tvec.pb(mp(dist[i][j],mp(i,j)));\n\t\t\t}\n\t\t}\n\t}\n\tsort(vec.begin(),vec.end());\n\tint cnt = __builtin_popcount(mask) - 1;\n\tld ans = 0;\n\tfor(int i = 0; i < vec.size(); i++)\n\t{\n\t\t//cerr<<\"VEC : \"<<vec[i].fi<<' '<<vec[i].se.fi<<' '<<vec[i].se.se<<'\\n';\n\t\tif(dsu.sameset(vec[i].se.fi,vec[i].se.se))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tcnt--;\n\t\tdsu.merge(vec[i].se.fi,vec[i].se.se);\n\t\tans+=vec[i].fi;\n\t}\n\tassert(cnt==0);\n\tmst[mask] = ans;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(0); cin.tie(0);\n\tcin >> n;\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tcin>>pt[i].fi>>pt[i].se>>tot[i];\n\t\tdp[(1<<i)] = tot[i];\n\t}\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tdist[i][j] = d(pt[i],pt[j]);\n\t\t\t//cerr<<i<<' '<<j<<' '<<dist[i][j]<<'\\n';\n\t\t}\n\t}\n\tfor(int i = 1; i < (1<<n); i++) calcmst(i);\n\tmst[0] = 0;\n\tfor(int i = 1; i < (1<<n); i++)\n\t{\n\t\tdp[i] = -mst[i];\n\t\tfor(int j = 0; j < n; j++)\n\t\t{\n\t\t\tif(i&(1<<j)) dp[i]+=tot[j];\n\t\t}\n\t\tdp[i]/=ld(__builtin_popcount(i));\n\t\t//cerr<<i<<' '<<dp[i]<<' '<<mst[i]<<'\\n';\n\t\tfor(int j = i; j > 0; j = ((j-1)&i))\n\t\t{\n\t\t\tif(j == i) continue;\n\t\t\tdp[i] = max(dp[i], min(dp[j], dp[(i^j)]));\n\t\t}\n\t}\n\tcout<<fixed<<setprecision(12)<<dp[(1<<n) - 1]<<'\\n';\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n#define error(args...) { vector<string> _debug = split(#args, ',');err(begin(_debug), args);}\n\nvector<string> split(const string& s, char c) {\n\tvector<string> v; stringstream ss(s); string x;\n\twhile (getline(ss, x, c)) v.emplace_back(x);\n\treturn move(v);\n}\n\nvoid err(vector<string>::iterator it) {cerr << endl;}\ntemplate<typename T, typename... Args> void err(vector<string>::iterator it, T a, Args... args) {\n\tcerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \" \", err(++it, args...);\n}\n\n\n// Description: 素集合を管理するデータ構造\n// TimeComplexity: 初期化$\\mathcal{O}(n)$ 更新$\\mathcal{O}(\\log n)$\n// Verifyed: AOJ DSL_1_A\n\nstruct Union_find {\n\tUnion_find(int n) {data.assign(n, -1);}\n\tint find(int x) {return (data[x] < 0) ? x : data[x] = find(data[x]);}\n\tvoid unite(int a, int b) {\n\t\ta = find(a), b = find(b);\n\t\tif (a != b) {\n\t\t\tif (data[a] < data[b]) swap(a, b);\n\t\t\tdata[a] += data[b], data[b] = a;\n\t\t}\n\t}\n\tbool same(int a, int b) {return find(a) == find(b);}\n\tint size(int x) {return -data[x];}\n\tvector<int> data;\n};\n\nint x[15], y[15], a[15];\nbool dp[1 << 15];\nR cost[1 << 15];\n\nbool check(int n, R val) {\n\trep(mask, 1 << n) {\n\t\tdp[mask] = false;\n\t\tconst R m = __builtin_popcountll(mask);\n\t\tR cur = 0.0;\n\t\trep(i, n) if (mask & (1 << i)) cur += a[i];\n\t\tcur -= cost[mask] + m * val;\n\t\tif (cur >= 0.0) dp[mask] = true;\n\t\t//error(mask, dp[mask]);\n\t}\n\n\trep(mask, 1 << n) {\n\t\tif (dp[mask]) continue;\n\t\tfor (int smask = (mask - 1) &mask; ; smask = (smask - 1) & mask) {\n\t\t\tconst int tmask = mask ^ smask;\n\t\t\tif (smask < tmask) break;\n\n\t\t\tif (dp[smask] and dp[tmask]) {\n\t\t\t\tdp[mask] = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dp[(1 << n) - 1];\n}\n\nint main(void) {\n\tint n;\n\tcin >> n;\n\n\trep(i, n) cin >> x[i] >> y[i] >> a[i];\n\n\tusing edge = tuple<R, int, int>;\n\tvector<edge> ary;\n\n\trep(j, n)rep(i, j)  ary.push_back(edge(hypot(x[i] - x[j], y[i] - y[j]), i, j));\n\tsort(begin(ary), end(ary));\n\n\trep(mask, 1 << n) {\n\t\tcost[mask] = 0.0;\n\t\tUnion_find uf(n);\n\n\t\tfor (auto &e : ary) {\n\t\t\tR w;\n\t\t\tint a, b;\n\t\t\ttie(w, a, b) = e;\n\t\t\tif (((mask >> a) & 1) == 0) continue;\n\t\t\tif (((mask >> b) & 1) == 0) continue;\n\t\t\tif (uf.same(a, b)) continue;\n\t\t\tcost[mask] += w;\n\t\t\tuf.unite(a, b);\n\t\t}\n\t\t//error(mask, cost[mask]);\n\t}\n\n\tR low = 0.0, high = 1e10;\n\n\trep(loop, 100) {\n\t\tconst R mid = (low + high) / 2.0;\n\t\tif (check(n, mid))\n\t\t\tlow = mid;\n\t\telse\n\t\t\thigh = mid;\n\t}\n\n\tcout.precision(20);\n\tcout << fixed << low << endl;\n\n\t/*\n\tcerr << check(n, 5.5) << endl;\n\tcerr << check(n, 7.5) << endl;\n\t*/\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int maxn = 15;\nusing ld = long double;\nlong long x[maxn], y[maxn], a[maxn];\nld dist(int a, int b){\n\treturn sqrtl((x[a] - x[b])*(x[a] - x[b]) + (y[a] - y[b]) * (y[a] - y[b]));\n}\nint uf[maxn];\nvoid init(){\n\tiota(uf, uf + maxn, 0);\n}\nint find(int x){\n\tif(x == uf[x]) return x;\n\treturn uf[x] = find(uf[x]);\n}\nld val[1<<maxn], f[1<<maxn];\nint main(){\n\tint n; cin >> n;\n\tfor(int i = 0; i < n; i++) cin >> x[i] >> y[i] >> a[i];\n\tfor(int i = 1; i < 1<<n; i++){\n\t\tvector<int> here;\n\t\tld sum = 0;\n\t\tfor(int j = 0; j < n; j++) if((i>>j)&1) sum += a[j], here.push_back(j);\n\t\tvector<tuple<ld, int, int> > edg;\n\t\tint sz = here.size();\n\t\tfor(int j = 0; j < sz; j++) for(int g = j + 1; g < sz; g++){\n\t\t\tedg.push_back(make_tuple(dist(here[j], here[g]), here[j], here[g]));\n\t\t}\n\t\tsort(edg.begin(), edg.end());\n\t\tinit();\n\t\tld mst = 0;\n\t\tfor(auto e : edg){\n\t\t\tld w; int u, v; tie(w, u, v) = e;\n\t\t\tif(find(u) != find(v)){\n\t\t\t\tmst += w;\n\t\t\t\tuf[find(u)] = find(v);\n\t\t\t}\n\t\t}\n\t\tval[i] = max((sum - mst) / sz, (ld)0.);\n\t}\n\tfor(int i = 1; i < 1<<n; i++){\n\t\tf[i] = val[i];\n\t\tfor(int j = i & (i - 1); j; j = i & (j - 1)){\n\t\t\tf[i] = max(f[i], min(f[j], f[i ^ j]));\n\t\t}\n\t}\n\tcout << fixed << setprecision(12) << f[(1<<n) - 1] << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct unionfind {\n\tvector<int> par;\n\t\n\tvoid init(int n)\n\t{\n\t\tpar.resize(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\t\n\tint find(int x)\n\t{\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t\n\tvoid unite(int x, int y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tpar[y] = x;\n\t}\n} uf;\n\nint N;\nint x[16], y[16];\ndouble a[16];\ndouble d[16][16];\ndouble af[1<<15];\ndouble dp[1<<15];\n\nint main() {\n\tcin >> N;\n\tfor (int i = 0; i < N; ++i) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tdouble t = (double)(x[i]-x[j]) * (x[i]-x[j]) + (double)(y[i]-y[j]) * (y[i]-y[j]);\n\t\t\tt = sqrt(t);\n\t\t\td[i][j] = d[j][i] = t;\n\t\t}\n\t}\n\t\n\tfor (int i = 1; i < (1 << N); ++i) {\n\t\tvector<pair<double, pair<int, int> > >vec;\n\t\t\n\t\tdouble sm = 0.0;\n\t\tint num = 0;\n\t\t\n\t\tfor (int j = 0; j < N; ++j) if ((i >> j) & 1) {\n\t\t\tsm += a[j];\n\t\t\t++num;\n\t\t\tfor (int k = 0; k < j; ++k) if ((i >> k) & 1) {\n\t\t\t\tvec.push_back(make_pair(d[j][k], make_pair(j, k)));\n\t\t\t}\n\t\t}\n\t\tsort(vec.begin(), vec.end());\n\t\t\n\t\tuf.init(N);\n\t\t\n\t\tdouble c = 0.0;\n\t\tfor (auto e : vec) {\n\t\t\tint x = uf.find(e.second.first);\n\t\t\tint y = uf.find(e.second.second);\n\t\t\tif (x == y) continue;\n\t\t\tuf.unite(x, y);\n\t\t\tc += e.first;\n\t\t}\n\t\t\n\t\taf[i] = max(0.0, (sm-c) / num);\n\t}\n\t\n\tdp[0] = 1e12;\n\t\n\tfor (int i = 1; i < (1<<N); ++i) {\n\t\tfor (int j = i; j > 0; --j &= i) {\n\t\t\tdp[i]=max(dp[i],min(dp[i^j],af[j]));\n\t\t}\n\t}\n\tprintf(\"%.10f\\n\", dp[(1<<N)-1]);\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing D = double;\nusing uint = unsigned int;\n\n#ifdef WIN32\n    #define LLD \"%I64d\"\n#else\n    #define LLD \"%lld\"\n#endif\n\n#define pb push_back\n#define mp make_pair\n#define all(x) (x).begin(),(x).end()\n#define fi first\n#define se second\n\n#define popcount(x) __builtin_popcount(x)\n\nconst int maxn = 16;\nconst int maxmask = 1 << 16;\nconst ld inf = 1e18;\n\nint x[maxn], y[maxn], a[maxn];\nld ans[maxmask], answer[maxmask];\nld d[maxn][maxn];\nld mindist[maxmask][maxn];\nint n;\n\ninline ld shedge(int m1, int m2)\n{\n    ld answer = inf;\n    for (int j = 0; j < n; j++) if (m1 & (1 << j)) answer = min(answer, mindist[m2][j]);\n    return answer;\n}\n\nint main()\n{\n    scanf(\"%d\", &n);\n    for (int i = 0; i < n; i++)\n    {\n        scanf(\"%d%d%d\", &x[i], &y[i], &a[i]);\n    }\n    for (int i = 0; i < n; i++)\n    {\n        for (int j = 0; j < n; j++) d[i][j] = sqrt((ld)(x[i] - x[j]) * (x[i] - x[j]) + (ld)(y[i] - y[j]) * (y[i] - y[j]));\n    }\n    int km = 1 << n;\n    for (int mask = 0; mask < km; mask++)\n    {\n        for (int i = 0; i < n; i++)\n        {\n            mindist[mask][i] = inf;\n            for (int j = 0; j < n; j++) if (mask & (1 << j)) mindist[mask][i] = min(mindist[mask][i], d[i][j]);\n        }\n    }\n    for (int i = 0; i < n; i++) ans[1 << i] = a[i];\n    for (int mask = 1; mask < km; mask++) if (popcount(mask) > 1)\n    {\n        ans[mask] = -inf;\n//         for (int i = 0; i < n; i++) if (mask & (1 << i))\n//         {\n//             ld d = mindist[mask ^ (1 << i)][i];\n//             /*if (a[i] > d || ans[mask ^ (1 << i)] / (popcount(mask) - 1) > d)*/ ans[mask] = max(ans[mask], ans[mask ^ (1 << i)] + a[i] - d);\n//         }\n        for (int submask = (mask & (mask - 1)); submask > 0; submask = ((submask - 1) & mask))\n        {\n            ld d = shedge(submask, mask ^ submask);\n            ans[mask] = max(ans[mask], ans[submask] + ans[mask ^ submask] - d);\n        }\n//         cout << mask << ' ' << ans[mask] << endl;\n    }\n//     cout.precision(20);\n//     cout << ans[km - 1] / n << endl;\n    for (int i = 0; i < n; i++) answer[1 << i] = a[i];\n    for (int mask = 1; mask < km; mask++) if (popcount(mask) > 1)\n    {\n        answer[mask] = ans[mask] / popcount(mask);\n        for (int submask = (mask & (mask - 1)); submask > 0; submask = ((submask - 1) & mask))\n        {\n            answer[mask] = max(answer[mask], min(answer[submask], answer[mask ^ submask]));\n        }\n    }\n    cout.precision(20);\n    cout << answer[km - 1] << endl;\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define DEB\n#include<bits/stdc++.h>\n#define REP(i,m) for(int i=0;i<(m);++i)\n#define REPN(i,m,in) for(int i=(in);i<(m);++i)\n#define ALL(t) (t).begin(),(t).end()\n#define CLR(a) memset((a),0,sizeof(a))\n#define pb push_back\n#define mp make_pair\n#define fr first\n#define sc second\n\nusing namespace std;\n\n\n#ifdef DEB\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define prl cerr<<\"called:\"<< __LINE__<<endl\n#define dumpR(x) cerr<<\"\\x1b[31m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpY(x) cerr<<\"\\x1b[33m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\n#define dumpG(x) cerr<<\"\\x1b[32m\"<<#x<<\" = \" <<(x)<<\"\\x1b[39m\"<<endl\ntemplate<class T> void debug(T a,T b){ for(;a!=b;++a) cerr<<*a<<' ';cerr<<endl;}\n#else\n#define dump(x) ;\n#define dumpR(x) ;\n#define dumpY(x) ;\n#define dumpG(x) ;\n#define prl ;\ntemplate<class T> void debug(T a,T b){ ;}\n#endif\n\ntemplate<class T> void chmin(T& a,const T& b) { if(a>b) a=b; }\ntemplate<class T> void chmax(T& a,const T& b) { if(a<b) a=b; }\n\ntypedef long long int lint;\ntypedef pair<int,int> pi;\n\nnamespace std{\n  template<class S,class T>\n  ostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.fr<<','<<a.sc<<')';\n    return out;\n  }\n}\n\nconst double INF=1e10;\n\nint n;\npi ps[20];\ndouble d[20][20];\nint ar[20];\ndouble sq(double a){\n  return a*a;\n}\nstruct uf{\n\n  static const int MAXN=18;\n  int par[MAXN];\n  int size[MAXN];\n  void init(){\n    memset(par,-1,sizeof(par));\n    REP(i,MAXN) size[i]=1;\n  }\n  int root(int a){\n    if(par[a]==-1) return a;\n    return par[a]=root(par[a]);\n  }\n  void unite(int a,int b){\n    a=root(a);b=root(b);\n    if(a==b) return;\n    if(size[a]<size[b]) swap(a,b);\n\n    par[b]=a;\n    size[a]+=size[b];\n  }\n  bool same(int a,int b){\n    return root(a)==root(b);\n  }\n};\n\n\nuf u;\nvector<int> g[20];\npair<double,pi> es[150];\n\ndouble dfs(int v,int p,double thr){\n  double cur=ar[v];\n  for(auto to:g[v]){\n    if(to==p) continue;\n    double a=dfs(to,v,thr);\n    if(a>0){\n      cur-=d[v][to]+a;\n    }else{\n      cur+=max(0.0,-a-d[v][to]);\n    }\n  }\n  return -(cur-thr);\n}\nbool check(double thr,int r){\n  double req=dfs(r,-1,thr);\n  if(req<=0) return true;\n  return false;\n}\ndouble calc(int bit){\n  int m=0;\n  int r=-1;\n  REP(i,n) g[i].clear();\n  REP(i,n) if(bit>>i&1){\n    REP(j,i) if(bit>>j&1){\n      es[m++]=mp(d[i][j],mp(i,j));\n    }\n    r=i;\n  }\n  sort(es,es+m);\n  u.init();\n  REP(i,m){\n    int a=es[i].sc.fr,b=es[i].sc.sc;\n    if(!u.same(a,b)){\n      u.unite(a,b);\n      g[a].pb(b);\n      g[b].pb(a);\n    }\n  }\n\n  double lb=0,ub=1e9+10;\n  REP(i,100){\n    double md=(lb+ub)/2;\n    if(check(md,r)) lb=md;\n    else ub=md;\n  }\n  return lb;\n}\n\ndouble wat[1<<15];\ndouble dp[1<<15];\nint main(){\n  cin>>n;\n  REP(i,n){\n    cin>>ps[i].fr>>ps[i].sc>>ar[i];\n  }\n  REP(i,n) REP(j,n) {\n    d[i][j]=sqrt(sq(ps[i].fr-ps[j].fr)+sq(ps[i].sc-ps[j].sc));\n  }\n\n  REP(i,1<<n) if(i>0){\n    wat[i]=calc(i);\n  }\n  dp[0]=INF;\n  for(int i=1;i<(1<<n);++i){\n    int cur=i;\n    do{\n      chmax(dp[i],min(wat[cur],dp[i^cur]));\n      cur=(cur-1)&i;\n    }while(cur>0);\n  }\n  printf(\"%.10f\\n\",dp[(1<<n)-1]);\n  return 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//\n// Created by yamunaku on 2019/08/30.\n//\n\n#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repl(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perl(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD9 998244353\n#define MOD1 1000000007\n#define IINF 1000000000\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n#define CST(x) cout<<fixed<<setprecision(x)\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<vector<int>> mti;\ntypedef vector<ll> vl;\ntypedef vector<vector<ll>> mtl;\n\nstruct UnionFind{\n    vi node;\n\n    UnionFind(int sz){\n        node = vi(sz);\n        iota(all(node), 0);\n    }\n\n    int root(int x){\n        if(node[x] == x) return x;\n        return node[x] = root(node[x]);\n    }\n\n    bool uni(int x, int y){\n        x = root(x);\n        y = root(y);\n        if(x == y)return false;\n        node[x] = y;\n        return true;\n    }\n};\n\nint n;\nvector<double> x, y, a;\n\ndouble dist(int p, int q){\n    return sqrt((x[p] - x[q]) * (x[p] - x[q]) + (y[p] - y[q]) * (y[p] - y[q]));\n}\n\ndouble solve(int f){\n    double total = 0;\n    vector<int> idx;\n    vector<pair<double, pair<int, int>>> edge;\n    rep(i, n){\n        if(f & (1 << i)){\n            idx.push_back(i);\n        }\n    }\n    int sz = idx.size();\n    rep(i, sz){\n        total += a[idx[i]];\n        rep(j, i){\n            edge.push_back({dist(idx[i], idx[j]), {i, j}});\n        }\n    }\n    sort(all(edge));\n    UnionFind uf(sz);\n    double cost = 0;\n    rep(i, edge.size()){\n        if(uf.uni(edge[i].second.first, edge[i].second.second)) cost += edge[i].first;\n    }\n    return max(0.0, total - cost) / (double)sz;\n}\n\nint main(){\n    cin >> n;\n    x = vector<double>(n);\n    y = vector<double>(n);\n    a = vector<double>(n);\n    rep(i, n) cin >> x[i] >> y[i] >> a[i];\n    vector<double> dp(1 << n, 0);\n    dp[0] = IINF;\n    CST(10);\n    vector<double> ans(1 << n, IINF);\n    repl(i, 1, 1 << n) ans[i] = solve(i);\n    repl(i, 1, 1 << n){\n        vector<int> b;\n        rep(j, n) if(i & (1 << j)) b.push_back(j);\n        int s = b.size();\n        repl(j, 1, (1 << s)){\n            int ad = 0;\n            rep(k, s) if(j & (1 << k)) ad |= (1 << b[k]);\n            dp[i] = max(dp[i], min(dp[i ^ ad], ans[ad]));\n        }\n    }\n    cout << dp[(1 << n) - 1] << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nint x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\t\t\tif (dp[i][mask] >= 0) {\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\tif (e[i] < 0 && e[j] < 0) continue;\n\t\t\t//if (e[i] >= 0 && e[j] >= 0) continue;\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 0.0, Q = 1e9, R;\n\tF0(it, 100) {\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#define MAXN 15\n#define Point pair<int, int>\n#define x first\n#define y second\n#define INF 1e20\nusing namespace std;\n\nstruct Edge {\n    int u, v;\n    double cost;\n\n    Edge(int u, int v, double cost): u(u), v(v), cost(cost) {}\n};\n\nint dad[MAXN], sz[MAXN];\nint n, liters[MAXN];\ndouble ccBest[1 << MAXN], dp[1 << MAXN];\nPoint pos[MAXN];\n\ndouble dist(const Point &A, const Point &B) {\n    int dx = A.x - B.x;\n    int dy = A.y - B.y;\n    return sqrt(1LL * dx * dx + 1LL * dy * dy);\n}\n\nbool Comp(Edge a, Edge b) {\n    return a.cost < b.cost;\n}\n\nint root(int x) {\n    int y = x;\n    while(dad[y] != y)\n        y = dad[y];\n\n    while(x != y) {\n        int aux = dad[x];\n        dad[x] = y;\n        x = aux;\n    }\n\n    return y;\n}\n\nbool unify(int x, int y) {\n    if((x = root(x)) == (y = root(y))) return 0;\n\n    if(sz[x] < sz[y])\n        dad[x] = y;\n    else {\n        dad[y] = x;\n        if(sz[x] == sz[y])\n            ++sz[x];\n    }\n\n    return 1;\n}\n\ndouble getMstCost(int mask) {\n    vector<int> nodes;\n    vector<Edge> edges;\n\n    for(int i = 0; i < n; ++i) {\n        if(mask & (1 << i))\n            nodes.push_back(i);\n    }\n\n    if((int) nodes.size() < 2)\n        return 0;\n\n    for(int i = 0; i < (int) nodes.size(); ++i) {\n        for(int j = i + 1; j < (int) nodes.size(); ++j) {\n            edges.push_back(Edge(nodes[i], nodes[j], dist(pos[nodes[i]], pos[nodes[j]])));\n        }\n    }\n\n    sort(edges.begin(), edges.end(), Comp);\n    \n    for(auto node: nodes) {\n        dad[node] = node;\n        sz[node] = 0;\n    }\n\n    double ans = 0;\n    for(auto edge: edges) {\n        if(unify(edge.u, edge.v)) {\n            ans += edge.cost; \n        }\n    }\n\n    return ans;\n}\n\nint main() {\n\n    scanf(\"%d\", &n);\n    for(int i = 0; i < n; ++i)\n        scanf(\"%d %d %d\", &pos[i].x, &pos[i].y, &liters[i]);\n\n    for(int mask = 1; mask < (1 << n); ++mask) {\n        double mstCost = getMstCost(mask);\n        \n        long long totLiters = 0;\n        int cnt = 0;\n        for(int i = 0; i < n; ++i) {\n            if(mask & (1 << i)) {\n                totLiters += liters[i];\n                ++cnt;\n            }\n        }\n\n        ccBest[mask] = (totLiters - mstCost) / cnt;\n    }\n\n    dp[0] = INF;\n    for(int mask = 1; mask < (1 << n); ++mask) {\n        vector<int> bits;\n\n        for(int i = 0; i < n; ++i) {\n            if(mask & (1 << i)) {\n                bits.push_back(i);\n            }\n        }\n\n        dp[mask] = 0;\n\n        int nn = (int) bits.size() - 1;\n        for(int submask = 0; submask < (1 << nn); ++submask) {\n            int mask1 = 0;\n\n            for(int i = 0; i < nn; ++i) {\n                if(submask & (1 << i)) {\n                    mask1 |= (1 << bits[i]);\n                }\n            }\n\n            int mask2 = mask & (~mask1);\n            dp[mask] = max(dp[mask], min(dp[mask1], ccBest[mask2]));\n        }\n    }\n\n    printf(\"%.20f\\n\", dp[(1 << n) - 1]);\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "15\n335279264 849598327 822889311\n446755913 526239859 548830120\n181424399 715477619 342858071\n625711486 448565595 480845266\n647639160 467825612 449656269\n160714711 336869678 545923679\n61020590 573085537 816372580\n626006012 389312924 135599877\n547865075 511429216 605997004\n561330066 539239436 921749002\n650693494 63219754 786119025\n849028504 632532642 655702582\n285323416 611583586 211428413\n990607689 590857173 393671555\n560686330 679513171 501983447"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <map>\n#include <set>\n#include <iostream>\n#include <sstream>\n#include <cstring>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define F0(i,n) for (int i = 0; i < n; i++)\n#define F1(i,n) for (int i = 1; i <= n; i++)\n#define CL(a,x) memset(x, a, sizeof(x));\n#define SZ(x) ((int)x.size())\nconst double eps = 1e-10;\nconst int inf = 1000000009;\nint i, j, k, m, n, l;\nint ans;\nint x[15], y[15], a[15];\ndouble d[15][15], e[15], dp[15][1<<15];\n\nint ok(double R) {\n\tF0(i, n) e[i] = a[i] - R;\n\n\tF0(i, n) F0(j, (1 << n)) dp[i][j] = -1e100;\n\tF0(i, n) dp[i][(1 << i)] = e[i];\n\n\tF0(mask, (1 << n)) F0(i, n) if ((1 << i)&mask) {\n\t\tF0(j, n) if (((1 << j)&mask) == 0) {\n\t\t\tint mm = mask | (1 << j);\n\n\t\t\tif (dp[i][mask] >= 0) {\n\t\t\t\tdp[j][mm] = max(dp[j][mm], e[j]);\n\t\t\t}\n\n\t\t\t//if (e[i] < 0 && e[j] < 0) continue;\n\t\t\t//if (e[i] >= 0 && e[j] >= 0) continue;\n\n\t\t\tdouble total = dp[i][mask] + e[j] - d[i][j];\n\n\t\t\tdp[i][mm] = max(dp[i][mm], total);\n\t\t\tdp[j][mm] = max(dp[j][mm], total);\n\t\t}\n\t}\n\tF0(i, n) if (dp[i][(1 << n) - 1] >= 0) return 1;\n\treturn 0;\n}\n\nint main() {\n\t//freopen(\"x.in\", \"r\", stdin);\n\n\tcin >> n;\n\tF0(i, n) {\n\t\tcin >> x[i] >> y[i] >> a[i];\n\t}\n\n\tF0(i, n) F0(j, n) d[i][j] = hypot(1.0*x[i] - x[j], 1.0*y[i] - y[j]);\n\n\tdouble P = 0.0, Q = 1e9, R;\n\tF0(it, 50) {\n\t\tR = (P + Q) / 2;\n\t\tif (ok(R)) P = R; else Q = R;\n\t}\n\tprintf(\"%.10lf\\n\", P);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define inf 1e18\n\ntypedef struct {\n\tint u;\n\tint v;\n\tdouble d;\n}edge;\n\ntypedef struct {\n\tint N;\n\tint *u;\n\tint *u_rank;\n}union_find;\n\nunion_find *make_union_find(int N){\n\tint i;\n\tunion_find *uf = (union_find *)malloc(sizeof(union_find));\n\tuf->N = N;\n\tuf->u = (int *)malloc(sizeof(int) * N);\n\tuf->u_rank = (int *)malloc(sizeof(int) * N);\n\tfor(i = 0; i < N; i++){\n\t\t(uf->u)[i] = i;\n\t\t(uf->u_rank)[i] = 1;\n\t}\n\treturn uf;\n}\n\nvoid flush_uf(union_find *uf){\n\tint i;\n\tfor(i = 0; i < uf->N; i++){\n\t\tuf->u[i] = i;\n\t\tuf->u_rank[i] = 1;\n\t}\n}\n\nint root_uf(int x, union_find *uf){\n\tint *u = uf->u;\n\tif(u[x] == x){\n\t\treturn x;\n\t}\n\telse{\n\t\tu[x] = root_uf(u[x], uf);\n\t\treturn u[x];\n\t}\n}\n\nvoid combine_uf(int x, int y, union_find *uf){\n\tint x_root = root_uf(x, uf);\n\tint y_root = root_uf(y, uf);\n\tint *u = uf->u;\n\tint *u_rank = uf->u_rank;\n\tif(x_root == y_root){\n\t\treturn;\n\t}\n\telse if(u_rank[x_root] < u_rank[y_root]){\n\t\tu[x_root] = y_root;\n\t\tu_rank[y_root] += u_rank[x_root];\n\t\tu_rank[x_root] = 0;\n\t}\n\telse{\n\t\tu[y_root] = x_root;\n\t\tu_rank[x_root] += u_rank[y_root];\n\t\tu_rank[y_root] = 0;\n\t}\n}\n\n//xとyが同じ集合に属していれば1を,そうでなければ0を返す\nint is_same_union_uf(int x, int y, union_find *uf){\n\tif(root_uf(x, uf) == root_uf(y, uf)){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\n//xが属する集合の要素数を返す\nint rank_uf(int x, union_find *uf){\n\treturn (uf->u_rank)[root_uf(x, uf)];\n}\n\nint compare(const void *a, const void *b){\n\tif(((edge *)a)->d - ((edge *)b)->d < 0){\n\t\treturn -1;\n\t}\n\telse if(((edge *)a)->d - ((edge *)b)->d > 0){\n\t\treturn 1;\n\t}\n\telse{\n\t\treturn 0;\n\t}\n}\n\ndouble max(double a, double b){\n\treturn a >= b ? a : b;\n}\n\ndouble min(double a, double b){\n\treturn a <= b ? a : b;\n}\n\nint main(){\n\tint N, i, j, k, l;\n\tscanf(\"%d\", &N);\n\tdouble *x = (double *)malloc(sizeof(double) * N);\n\tdouble *y = (double *)malloc(sizeof(double) * N);\n\tdouble *a = (double *)malloc(sizeof(double) * N);\n\tfor(i = 0; i < N; i++){\n\t\tscanf(\"%lf%lf%lf\", &x[i], &y[i], &a[i]);\n\t}\n\tedge *e = (edge *)malloc(sizeof(edge) * ((N * (N - 1)) / 2));\n\tdouble *amaxmin = (double *)malloc(sizeof(double) * (1 << N));\n\tunion_find *uf = make_union_find(N);\n\tdouble mst, asum;\n\tint V;\n\tamaxmin[0] = inf;\n\tfor(i = 1; i < (1 << N); i++){\n//\t\tprintf(\"i = %d\\n\", i);\n\t\tmst = 0;\n\t\tasum = 0;\n\t\tV = 0;\n\t\tl = 0;\n\t\tfor(j = 0; j < N; j++){\n\t\t\tif((i | (1 << j)) == i){\n\t\t\t\tfor(k = j + 1; k < N; k++){\n\t\t\t\t\tif((i | (1 << k)) == i){\n\t\t\t\t\t\te[l].u = j;\n\t\t\t\t\t\te[l].v = k;\n\t\t\t\t\t\te[l].d = hypot(x[j] - x[k], y[j] - y[k]);\n\t\t\t\t\t\tl++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tasum += a[j];\n\t\t\t\tV++;\n\t\t\t}\n\t\t}\n\t\tqsort(e, l, sizeof(edge), compare);\n//\t\tprintf(\"l = %d\\n\", l);\n\t\tflush_uf(uf);\n\t\tfor(j = 0; j < l; j++){\n\t\t\tif(is_same_union_uf(e[j].u, e[j].v, uf) == 0){\n\t\t\t\tcombine_uf(e[j].u, e[j].v, uf);\n\t\t\t\tmst += e[j].d;\n\t\t\t}\n\t\t}\n\t\tamaxmin[i] = (asum - mst) / V;\n//\t\tprintf(\"(mst, asum, V, amaxmin) = (%lf, %lf, %d, %lf)\\n\", mst, asum, V, amaxmin[i]);\n\t}\n\tdouble *dp = (double *)malloc(sizeof(double) * (1 << N));\n\tdp[0] = inf;\n\tfor(i = 1; i < (1 << N); i++){\n\t\tdp[i] = amaxmin[i];\n\t\tfor(j = (i & (i - 1)); j > 0; j = (i & (j - 1))){\n\t\t\tdp[i] = max(dp[i], min(dp[j], dp[i ^ j]));\n\t\t}\n\t}\n\tprintf(\"%.12lf\\n\", dp[(1 << N) - 1]);\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\ntypedef struct weightEdge{\n  double w;\n  int a,b;\n} node;\n\nint cmp(const void *a,const void *b){\n  double p=((node *)a)->w;\n  double q=((node *)b)->w;\n  return p==q?0:p<q?-1:1;\n}\n\nint root(int *u,int x){\n  if(u[x]==x) return x;\n  return u[x]=root(u,u[x]);\n}\n\nint same(int *u,int x,int y){\n  return root(u,x)==root(u,y);\n}\n\nvoid unite(int *u,int x,int y){\n  x=root(u,x);\n  y=root(u,y);\n  if(x==y) return;\n  u[y]=x;\n}\n\nvoid run(void){\n  int n;\n  scanf(\"%d\",&n);\n  int x[15],y[15],a[15];\n  int i,j,k;\n  for(i=0;i<n;i++) scanf(\"%d%d%d\",x+i,y+i,a+i);\n  double d[15*15];\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      int dx=x[i]-x[j];\n      int dy=y[i]-y[j];\n      d[i*n+j]=sqrt((double)dx*dx+(double)dy*dy);\n    }\n  }\n  double *dp=(double *)calloc(1<<n,sizeof(double));\n  for(i=1;i<(1<<n);i++){\n    double sum=0;\n    int c[15];\n    int len=0;\n    for(j=0;j<n;j++){\n      if((i>>j)&1){\n\tc[len++]=j;\n\tsum+=a[j];\n      }\n    }\n    node t[15*15];\n    int lent=0;\n    for(j=0;j<len;j++) for(k=j+1;k<len;k++) t[lent++]=(node){d[c[j]*n+c[k]],c[j],c[k]};\n    qsort(t,lent,sizeof(node),cmp);\n    int u[15];\n    for(j=0;j<len;j++) u[c[j]]=c[j];\n    double weight=0;\n    int cnt=0;\n    for(j=0;cnt<len-1;j++){\n      if(same(u,t[j].a,t[j].b)) continue;\n      unite(u,t[j].a,t[j].b);\n      weight+=t[j].w;\n      cnt++;\n    }\n    double local=MAX(0,(sum-weight)/len);\n    for(j=(i-1)&i;j>0;j=(j-1)&i){\n      local=MAX(local,MIN(dp[j],dp[i^j]));\n    }\n    dp[i]=local;\n  }\n  printf(\"%.9lf\\n\",dp[(1<<n)-1]);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "//set many funcs template\n//Ver.20181228\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n#include<stdbool.h>\n#include<time.h>\n#include<math.h>\n#define inf 1072114514\n#define llinf 4154118101919364364\n#define mod 1000000007\n#define pi 3.1415926535897932384\n\ndouble dbmax(double a,double b){if(a>b){return a;}return b;}\ndouble dbmin(double a,double b){if(a<b){return a;}return b;}\ndouble dbzt(double a,double b){return dbmax(a,b)-dbmin(a,b);}\nint dsumb(int x,int b){int r=0;while(x){r+=(x%b);x/=b;}return r;}\n\ntypedef struct{\nint node;\ndouble cost;\n}data;\n\ndata heap[262144];\nint hsize=0;\n\nvoid resheap(){\n    int i;\n    heap[0].node=-1;\n    heap[0].cost=-llinf;\n    for(i=1;i<262144;i++){\n        heap[i].node=-1;\n        heap[i].cost=llinf;\n    }\n}\n\nint swjud(data high,data low){\n    if(high.cost > low.cost){return 1;}\n    return -1;\n}\n\nvoid pqpush(data x){\n    int a,b;\n    data m;\n    hsize++;\n    heap[hsize]=x;\n    a=hsize;\n    while(1){\n        b=a/2;\n        if(swjud(heap[b],heap[a]) == 1){\n            m=heap[a];heap[a]=heap[b];heap[b]=m;\n        }\n        else{break;}\n        a=b;\n    }\n}\n\ndata pqpop(){\n    int a,b,c;\n    data m,sw;\n    m=heap[1];\n    heap[1]=heap[hsize];\n    heap[hsize].node=-1;\n    heap[hsize].cost=llinf;\n    hsize--;\n    a=1;\n    while(1){\n        b=a*2;c=a*2+1;\n        if(swjud(heap[a],heap[b])==-1 && swjud(heap[a],heap[c])==-1){break;}\n        if(swjud(heap[b],heap[c])==-1){\n            sw=heap[a];heap[a]=heap[b];heap[b]=sw;\n            a=b;\n        }\n        else{\n            sw=heap[a];heap[a]=heap[c];heap[c]=sw;\n            a=c;\n        }\n    }\n    return m;\n}\n\nint n;\ndouble x[16],y[16],a[16],ds[16][16];\n\ndouble calcmst(int fl){\n  int i,w,vf=0;\n  data pd,od;\n  double res=0.0;\n  while(hsize>0){od=pqpop();}\n  for(i=0;i<n;i++){\n    if((fl&(1<<i))!=0){w=i;break;}\n  }\n  pd.node=w;pd.cost=0.0;pqpush(pd);\n  while((vf&fl)!=fl){\n    od=pqpop();\n    if((vf&(1<<od.node))!=0){continue;}\n    vf|=(1<<od.node);\n    res+=od.cost;\n    for(i=0;i<n;i++){\n      if(((vf&(1<<i))!=0) || ((fl&(1<<i))==0)){continue;}\n      pd.node=i;\n      pd.cost=ds[i][od.node];\n      pqpush(pd);\n    }\n  }\n  return res;\n}\n\ndouble csig(int fl){\n  int i;\n  double res=0.0;\n  for(i=0;i<n;i++){\n    if((fl&(1<<i))!=0){res+=a[i];}\n  }\n  return res;\n}\n\nint main(void){\n    resheap();\n    int i,j,w;\n    double dp[65536],mst[65536],cs[65536],bc[65536],v;\n    scanf(\"%d\",&n);\n    for(i=0;i<n;i++){\n      scanf(\"%lf%lf%lf\",&x[i],&y[i],&a[i]);\n    }\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n        ds[i][j]=sqrt((x[j]-x[i])*(x[j]-x[i])+(y[j]-y[i])*(y[j]-y[i]));\n      }\n    }\n    for(i=0;i<65536;i++){dp[i]=-100;mst[i]=-100;}\n    dp[0]=inf;\n    for(i=0;i<(1<<n);i++){\n      if(dp[i]<-1.0){continue;}\n      for(j=0;j<n;j++){\n        if((i&(1<<j))!=0){w=j;break;}\n      }\n      for(j=(1<<w);j<(1<<n);j+=(1<<w)){\n        if((i&j)!=0){continue;}\n        if(mst[j]<-1.0){\n          mst[j]=calcmst(j);\n          cs[j]=csig(j);\n          bc[j]=dsumb(j,2);\n        }\n        v=dbmax((cs[j]-mst[j])/bc[j],0.0);\n        dp[i|j]=dbmax(dbmin(dp[i],v),dp[i|j]);\n      }\n    }\n    printf(\"%.12lf\\n\",dp[(1<<n)-1]);\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<math.h>\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n\ntypedef struct weightEdge{\n  double w;\n  int a,b;\n} node;\n\nint cmp(const void *a,const void *b){\n  double p=((node *)a)->w;\n  double q=((node *)b)->w;\n  return p==q?0:p<q?-1:1;\n}\n\nint root(int *u,int x){\n  if(u[x]==x) return x;\n  return u[x]=root(u,u[x]);\n}\n\nint same(int *u,int x,int y){\n  return root(u,x)==root(u,y);\n}\n\nvoid unite(int *u,int x,int y){\n  x=root(u,x);\n  y=root(u,y);\n  if(x==y) return;\n  u[y]=x;\n}\n\nvoid run(void){\n  int n;\n  scanf(\"%d\",&n);\n  int x[15],y[15],a[15];\n  int i,j,k;\n  for(i=0;i<n;i++) scanf(\"%d%d%d\",x+i,y+i,a+i);\n  double d[15*15];\n  for(i=0;i<n;i++){\n    for(j=0;j<n;j++){\n      int dx=x[i]-x[j];\n      int dy=y[i]-y[j];\n      d[i*n+j]=sqrt((double)dx*dx+(double)dy*dy);\n    }\n  }\n  double *dp=(double *)calloc(1<<n,sizeof(double));\n  for(i=1;i<(1<<n);i++){\n    double sum=0;\n    int c[15];\n    int len=0;\n    for(j=0;j<n;j++){\n      if((i>>j)&1){\n\tc[len++]=j;\n\tsum+=a[j];\n      }\n    }\n    if(len==1){\n      dp[i]=sum;\n      continue;\n    }\n    node t[15*15];\n    int lent=0;\n    for(j=0;j<len;j++) for(k=j+1;k<len;k++) t[lent++]=(node){d[c[j]*n+c[k]],c[j],c[k]};\n    qsort(t,lent,sizeof(node),cmp);\n    int u[15];\n    for(j=0;j<n;j++) u[j]=j;\n    double weight=0;\n    int cnt=0;\n    for(j=0;cnt<len-1;j++){\n      if(same(u,t[j].a,t[j].b)) continue;\n      unite(u,t[j].a,t[j].b);\n      weight+=t[j].w;\n      cnt++;\n    }\n    double local=MAX(0,(sum-weight)/len);\n    for(j=1;j<(1<<len)-1;j++){\n      int bit=0;\n      for(k=0;k<len;k++) if((j>>k)&1) bit|=1<<c[k];\n      local=MAX(local,MIN(dp[bit],dp[i^bit]));\n    }\n    dp[i]=local;\n  }\n  printf(\"%.9lf\\n\",dp[(1<<n)-1]);\n}\n\nint main(void){\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<math.h>\n\ntypedef int32_t i32;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n#define SORT(a,num,cmp) qsort((a),(num),sizeof(*(a)),cmp)\n\ntypedef struct union_find {\n  int32_t *parent;\n  int32_t size;\n} union_find;\n\nvoid init_union_find (union_find * const u) {\n  for (int32_t i = 0; i < u->size; ++i){\n    u->parent[i] = -1;\n  }\n}\n\nunion_find* new_union_find (const int32_t size) {\n  union_find * const u = (union_find *) calloc (1, sizeof (union_find));\n  u->parent = (int32_t *) calloc (size, sizeof (int32_t));\n  u->size = size;\n  init_union_find (u);\n  return u;\n}\n\nint32_t root (union_find * const u, int32_t x) {\n  if (u->parent[x] < 0) return x;\n  return u->parent[x] = root (u, u->parent[x]);\n}\n\nint same (union_find * const u, const int32_t x, const int32_t y) {\n  return root (u, x) == root (u, y);\n}\n\nvoid unite (union_find * const u, int32_t x, int32_t y) {\n  x = root (u, x);\n  y = root (u, y);\n  if (x == y) return;\n  if (u->parent[x] > u->parent[y]) {\n    const int32_t swap = x;\n    x = y;\n    y = swap;\n  }\n  u->parent[x] += u->parent[y];\n  u->parent[y] = x;\n}\n\ntypedef struct edge {\n  i32 a, b;\n  double c;\n} edge;\n\nint cmp_edge (const void *a, const void *b) {\n  return ((edge *)a)->c <= ((edge *)b)->c ? -1 : 1;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  i32 *x = ALLOC (3 * n, i32);\n  i32 *y = x + n;\n  i32 *a = y + n;\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, x + i, y + i, a + i);\n  }\n  double *dp = ALLOC (1 << n, double);\n  union_find *u = new_union_find (n);\n  edge *e = ALLOC (n * n, edge);\n  for (i32 i = 1; i < (1 << n); ++i) {\n    init_union_find (u);\n    i32 len = 0;\n    double sum = 0;\n    i32 cnt = 0;\n    for (i32 j = 0; j < n; ++j) {\n      if (((i >> j) & 1) == 0) continue;\n      sum += a[j];\n      cnt++;\n      for (i32 k = j + 1; k < n; ++k) {\n        if (((i >> k) & 1) == 0) continue;\n        double dx = x[j] - x[k];\n        double dy = y[j] - y[k];\n        e[len++] = (edge) {j, k, sqrt (dx * dx + dy * dy)};\n      }\n    }\n    SORT (e, len, cmp_edge);\n    for (i32 j = 0; j < len; ++j) {\n      if (same (u, e[j].a, e[j].b)) continue;\n      unite (u, e[j].a, e[j].b);\n      sum -= e[j].c;\n    }\n    double max = sum / cnt;\n    for (i32 j = (i - 1) & i; j > 0; j = (j - 1) & i) {\n      double v = MIN (dp[j], dp[i ^ j]);\n      max = MAX (max, v);\n    }\n    dp[i] = max;\n  }\n  printf (\"%.10f\\n\", dp[(1 << n) - 1]);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#include<inttypes.h>\n#include<math.h>\n\ntypedef int32_t i32;\n\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#define ALLOC(size,type) ((type*)calloc((size),sizeof(type)))\n#define SORT(a,num,cmp) qsort((a),(num),sizeof(*(a)),cmp)\n\ntypedef struct union_find {\n  int32_t *parent;\n  int32_t size;\n} union_find;\n\nvoid init_union_find (union_find * const u) {\n  for (int32_t i = 0; i < u->size; ++i){\n    u->parent[i] = -1;\n  }\n}\n\nunion_find* new_union_find (const int32_t size) {\n  union_find * const u = (union_find *) calloc (1, sizeof (union_find));\n  u->parent = (int32_t *) calloc (size, sizeof (int32_t));\n  u->size = size;\n  init_union_find (u);\n  return u;\n}\n\nint32_t root (union_find * const u, int32_t x) {\n  if (u->parent[x] < 0) return x;\n  return u->parent[x] = root (u, u->parent[x]);\n}\n\nint same (union_find * const u, const int32_t x, const int32_t y) {\n  return root (u, x) == root (u, y);\n}\n\nvoid unite (union_find * const u, int32_t x, int32_t y) {\n  x = root (u, x);\n  y = root (u, y);\n  if (x == y) return;\n  if (u->parent[x] > u->parent[y]) {\n    const int32_t swap = x;\n    x = y;\n    y = swap;\n  }\n  u->parent[x] += u->parent[y];\n  u->parent[y] = x;\n}\n\ntypedef struct edge {\n  i32 a, b;\n  double c;\n} edge;\n\nint cmp_edge (const void *a, const void *b) {\n  return ((edge *)a)->c <= ((edge *)b)->c ? -1 : 1;\n}\n\nvoid run (void) {\n  i32 n;\n  scanf (\"%\" SCNi32, &n);\n  i32 *x = ALLOC (3 * n, i32);\n  i32 *y = x + n;\n  i32 *a = y + n;\n  for (i32 i = 0; i < n; ++i) {\n    scanf (\"%\" SCNi32 \"%\" SCNi32 \"%\" SCNi32, x + i, y + i, a + i);\n  }\n  double *dp = ALLOC (1 << n, double);\n  union_find *u = new_union_find (n);\n  edge *e = ALLOC (n * n, edge);\n  for (i32 i = 1; i < (1 << n); ++i) {\n    init_union_find (u);\n    i32 len = 0;\n    double sum = 0;\n    i32 cnt = 0;\n    for (i32 j = 0; j < n; ++j) {\n      if (((i >> j) & 1) == 0) continue;\n      sum += a[j];\n      cnt++;\n      for (i32 k = j + 1; k < n; ++k) {\n        if (((i >> k) & 1) == 0) continue;\n        double dx = x[j] - x[k];\n        double dy = y[j] - y[k];\n        e[len++] = (edge) {j, k, sqrt (dx * dx + dy * dy)};\n      }\n    }\n    SORT (e, len, cmp_edge);\n    for (i32 j = 0; j < len; ++j) {\n      if (same (u, e[j].a, e[j].b)) continue;\n      unite (u, e[j].a, e[j].b);\n      sum -= e[j].c;\n    }\n    double max = sum / cnt;\n    for (i32 j = (i - 1) & i; j > (i ^ j); j = (j - 1) & i) {\n      double v = MIN (dp[j], dp[i ^ j]);\n      max = MAX (max, v);\n    }\n    dp[i] = max;\n  }\n  printf (\"%.10f\\n\", dp[(1 << n) - 1]);\n}\n\nint main (void) {\n  run();\n  return 0;\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Edge implements Comparable<Edge> {\n  final int src, dst;\n  final double distance;\n\n  Edge(int src, int dst, double distance) {\n    this.src = src;\n    this.dst = dst;\n    this.distance = distance;\n  }\n\n  public int compareTo(Edge edge) {\n    return Double.compare(this.distance, edge.distance);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n  \n  public void dump() {\n    Map<Integer, Set<Integer>> rootToSetMap = new HashMap<>();\n    for (int i = 0; i < parents.length; i++) {\n      int root = getRoot(i);\n      if (rootToSetMap.get(root) == null) {\n        rootToSetMap.put(root, new HashSet<>());\n      }\n      rootToSetMap.get(root).add(i);\n    }\n    for (Map.Entry<Integer, Set<Integer>> entry : rootToSetMap.entrySet()) {\n      System.err.printf(\"%d: %s\\n\", entry.getKey(), entry.getValue());\n    }\n  }\n}\n\nclass Solver {\n  final int n;\n  final int[][] xyas;\n  double[] oneGroupCache;\n  double[] assignmentCache;\n\n  Solver(int n, int[][] xyas) {\n    this.n = n;\n    this.xyas = xyas;\n  }\n\n  private static boolean isInBitset(int bitset, int index) {\n    return ((bitset >> index) & 1) == 1;\n  }\n\n  private double calculateGroupWater(int bitset) {\n    double totalWater = 0.0;\n    int totalCity = 0;\n    for (int i = 0; i < n; i++) {\n      if (isInBitset(bitset, i)) {\n        totalWater += xyas[i][2];\n        totalCity++;\n      }\n    }\n\n    List<Edge> edges = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      if (!isInBitset(bitset, i)) {\n        continue;\n      }\n      for (int j = i + 1; j < n; j++) {\n        if (!isInBitset(bitset, j)) {\n          continue;\n        }\n        double distance = Math.hypot(xyas[i][0] - xyas[j][0], xyas[i][1] - xyas[j][1]);\n        edges.add(new Edge(i, j, distance));  \n      }\n    }\n    Collections.sort(edges);\n\n    UnionFind unionFind = new UnionFind(n);\n    int count = 0;\n    for (Edge edge : edges) {\n      if (unionFind.sameGroup(edge.src, edge.dst)) {\n        continue;\n      }\n      unionFind.merge(edge.src, edge.dst);\n      totalWater -= edge.distance;\n      count++;\n      if (count == totalCity - 1) {\n        break;\n      }\n    }\n\n    return totalWater / totalCity;\n  }\n\n  private double solve(int bitset) {\n    if (assignmentCache[bitset] != Double.NEGATIVE_INFINITY) {\n      return assignmentCache[bitset];\n    }\n    List<Integer> indexes = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      if (isInBitset(bitset, i)) {\n        indexes.add(i);\n      }\n    }\n    assignmentCache[bitset] = oneGroupCache[bitset];\n    for (int nextBitsetTemp = 1; nextBitsetTemp < (1 << indexes.size()) - 1; nextBitsetTemp += 2) {\n      int nextBitset = 0;\n      for (int j = 0; j < indexes.size(); j++) {\n        if (isInBitset(nextBitsetTemp, j)) {\n          nextBitset |= (1 << indexes.get(j));\n        }\n      }\n      assignmentCache[bitset] = \n        Math.max(assignmentCache[bitset], \n          Math.min(oneGroupCache[nextBitset], solve(bitset - nextBitset)));\n    }\n//    System.err.printf(\"%d: %f\\n\", bitset, assignmentCache[bitset]);\n    return assignmentCache[bitset];\n  }\n\n  public double solve() {\n    oneGroupCache = new double[1 << n];\n    for (int bitset = 1; bitset < (1 << n); bitset++) {\n      oneGroupCache[bitset] = calculateGroupWater(bitset);\n//      System.err.printf(\"%d: %f\\n\", bitset, oneGroupCache[bitset]);\n    }\n//    System.err.println();\n\n    assignmentCache = new double[1 << n];\n    Arrays.fill(assignmentCache, Double.NEGATIVE_INFINITY);\n    return solve((1 << n) - 1);\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int n = reader.nextInt();\n    int[][] xyas = reader.nextInt(n, 3);\n    out.printf(\"%.20f\\n\", new Solver(n, xyas).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printeStream) {\n    super(printeStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "Java",
    "code": "package tester;\n\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n\tint n;\n\tlong[] x;\n\tlong[] y;\n\tlong[] a;\n\tdouble[][] dist;\n\tdouble[] weight;\n\tlong[] water;\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u;\n\t\tint v;\n\t\tdouble cost;\n\n\t\tpublic Edge(int u_, int v_, double dist) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn Double.compare(cost, o.cost);\n\t\t}\n\t}\n\n\tclass UnionFind {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic UnionFind(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tx = new long[n];\n\t\ty = new long[n];\n\t\ta = new long[n];\n\t\tdist = new double[n][n];\n\t\tweight = new double[1 << n];\n\t\twater = new long[1 << n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tdist[i][j] = Math.sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n\t\t\t}\n\t\t}\n\t\tfor (int s = 1; s < 1 << n; ++s) {\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tPriorityQueue<Edge> pq = new PriorityQueue<>();\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif ((s >> i) % 2 == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\twater[s] += a[i];\n\t\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\t\tif ((s >> j) % 2 == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpq.add(new Edge(i, j, dist[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tEdge e = pq.poll();\n\t\t\t\tif (uf.equiv(e.u, e.v))\n\t\t\t\t\tcontinue;\n\t\t\t\tweight[s] += e.cost;\n\t\t\t\tuf.setUnion(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\tdouble[] a = new double[1 << n];\n\t\ta[0] = 1 << 30;\n\t\tfor (int s = 0; s < 1 << n; ++s) {\n\t\t\tfor (int s2 = ((1 << n) - 1) & ~s; s2 > 0; s2 = (s2 - 1) & ~s) {\n\t\t\t\tint m = Integer.bitCount(s2);\n\t\t\t\tint ns = s | s2;\n\t\t\t\ta[ns] = Math.max(a[ns], Math.min(a[s], ((water[s2] - weight[s2]) / m)));\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.20f\", a[(1 << n) - 1]);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\nclass Main {\n\tint n;\n\tlong[] x;\n\tlong[] y;\n\tlong[] a;\n\tdouble[][] dist;\n\tdouble[] weight;\n\tlong[] water;\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint u;\n\t\tint v;\n\t\tdouble cost;\n\n\t\tpublic Edge(int u_, int v_, double dist) {\n\t\t\tu = u_;\n\t\t\tv = v_;\n\t\t\tcost = dist;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn Double.compare(cost, o.cost);\n\t\t}\n\t}\n\n\tclass UnionFind {\n\t\tint n;\n\t\tint[] upper;\n\n\t\tpublic UnionFind(int n_) {\n\t\t\tn = n_;\n\t\t\tupper = new int[n];\n\t\t\tArrays.fill(upper, -1);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn upper[x] < 0 ? x : (upper[x] = root(upper[x]));\n\t\t}\n\n\t\tboolean equiv(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tvoid setUnion(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (upper[x] < upper[y]) {\n\t\t\t\tx ^= y;\n\t\t\t\ty ^= x;\n\t\t\t\tx ^= y;\n\t\t\t}\n\t\t\tupper[y] += upper[x];\n\t\t\tupper[x] = y;\n\t\t}\n\t}\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tx = new long[n];\n\t\ty = new long[n];\n\t\ta = new long[n];\n\t\tdist = new double[n][n];\n\t\tweight = new double[1 << n];\n\t\twater = new long[1 << n];\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t\ta[i] = sc.nextInt();\n\t\t}\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j = 0; j < n; ++j) {\n\t\t\t\tif (i == j)\n\t\t\t\t\tcontinue;\n\t\t\t\tdist[i][j] = Math.sqrt((x[i] - x[j]) * (x[i] - x[j]) + (y[i] - y[j]) * (y[i] - y[j]));\n\t\t\t}\n\t\t}\n\t\tfor (int s = 1; s < 1 << n; ++s) {\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tPriorityQueue<Edge> pq = new PriorityQueue<>();\n\t\t\tfor (int i = 0; i < n; ++i) {\n\t\t\t\tif ((s >> i) % 2 == 0)\n\t\t\t\t\tcontinue;\n\t\t\t\twater[s] += a[i];\n\t\t\t\tfor (int j = i + 1; j < n; ++j) {\n\t\t\t\t\tif ((s >> j) % 2 == 0)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tpq.add(new Edge(i, j, dist[i][j]));\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile (!pq.isEmpty()) {\n\t\t\t\tEdge e = pq.poll();\n\t\t\t\tif (uf.equiv(e.u, e.v))\n\t\t\t\t\tcontinue;\n\t\t\t\tweight[s] += e.cost;\n\t\t\t\tuf.setUnion(e.u, e.v);\n\t\t\t}\n\t\t}\n\t\tdouble[] a = new double[1 << n];\n\t\ta[0] = 1 << 30;\n\t\tfor (int s = 0; s < 1 << n; ++s) {\n\t\t\tfor (int s2 = ((1 << n) - 1) & ~s; s2 > 0; s2 = (s2 - 1) & ~s) {\n\t\t\t\tint m = Integer.bitCount(s2);\n\t\t\t\tint ns = s | s2;\n\t\t\t\ta[ns] = Math.max(a[ns], Math.min(a[s], ((water[s2] - weight[s2]) / m)));\n\t\t\t}\n\t\t}\n\t\tSystem.out.printf(\"%.20f\", a[(1 << n) - 1]);\n\t}\n\n\tvoid tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nclass Edge implements Comparable<Edge> {\n  final int src, dst;\n  final double distance;\n\n  Edge(int src, int dst, double distance) {\n    this.src = src;\n    this.dst = dst;\n    this.distance = distance;\n  }\n\n  public int compareTo(Edge edge) {\n    return Double.compare(this.distance, edge.distance);\n  }\n}\n\nclass UnionFind {\n  int[] parents;\n  int[] ranks;\n\n  UnionFind(int n) {\n    parents = new int[n];\n    ranks = new int[n];\n\n    for (int i = 0; i < n; i++) {\n      parents[i] = i;\n    }\n  }\n\n  public int getRoot(int index) {\n    if (parents[index] == index) {\n      return index;\n    } else {\n      parents[index] = getRoot(parents[index]);\n      return parents[index];\n    }\n  }\n\n  public boolean sameGroup(int a, int b) {\n    return getRoot(a) == getRoot(b);\n  }\n\n  public void merge(int a, int b) {\n    int rootA = getRoot(a);\n    int rootB = getRoot(b);\n    if (rootA == rootB) {\n      return;\n    }\n    if (ranks[rootA] < ranks[rootB]) {\n      parents[rootA] = rootB;\n    } else if (ranks[rootB] < ranks[rootA]) {\n      parents[rootB] = rootA;\n    } else {\n      parents[rootA] = rootB;\n      ranks[rootB]++;\n    }\n  }\n  \n  public void dump() {\n    Map<Integer, Set<Integer>> rootToSetMap = new HashMap<>();\n    for (int i = 0; i < parents.length; i++) {\n      int root = getRoot(i);\n      if (rootToSetMap.get(root) == null) {\n        rootToSetMap.put(root, new HashSet<>());\n      }\n      rootToSetMap.get(root).add(i);\n    }\n    for (Map.Entry<Integer, Set<Integer>> entry : rootToSetMap.entrySet()) {\n      System.err.printf(\"%d: %s\\n\", entry.getKey(), entry.getValue());\n    }\n  }\n}\n\nclass Solver {\n  final int n;\n  final int[][] xyas;\n  double[] oneGroupCache;\n  double[] assignmentCache;\n\n  Solver(int n, int[][] xyas) {\n    this.n = n;\n    this.xyas = xyas;\n  }\n\n  private static boolean isInBitset(int bitset, int index) {\n    return ((bitset >> index) & 1) == 1;\n  }\n\n  private double calculateGroupWater(int bitset) {\n    double totalWater = 0.0;\n    int totalCity = 0;\n    for (int i = 0; i < n; i++) {\n      if (isInBitset(bitset, i)) {\n        totalWater += xyas[i][2];\n        totalCity++;\n      }\n    }\n\n    List<Edge> edges = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      if (!isInBitset(bitset, i)) {\n        continue;\n      }\n      for (int j = i + 1; j < n; j++) {\n        if (!isInBitset(bitset, j)) {\n          continue;\n        }\n        double distance = Math.hypot(xyas[i][0] - xyas[j][0], xyas[i][1] - xyas[j][1]);\n        edges.add(new Edge(i, j, distance));  \n      }\n    }\n    Collections.sort(edges);\n\n    UnionFind unionFind = new UnionFind(n);\n    int count = 0;\n    for (Edge edge : edges) {\n      if (unionFind.sameGroup(edge.src, edge.dst)) {\n        continue;\n      }\n      unionFind.merge(edge.src, edge.dst);\n      totalWater -= edge.distance;\n      count++;\n      if (count == totalCity - 1) {\n        break;\n      }\n    }\n\n    return totalWater / totalCity;\n  }\n\n  private double solve(int bitset) {\n    if (assignmentCache[bitset] != Double.NEGATIVE_INFINITY) {\n      return assignmentCache[bitset];\n    }\n    List<Integer> indexes = new ArrayList<>();\n    for (int i = 0; i < n; i++) {\n      if (isInBitset(bitset, i)) {\n        indexes.add(i);\n      }\n    }\n    assignmentCache[bitset] = oneGroupCache[bitset];\n    for (int nextBitsetTemp = 1; nextBitsetTemp < (1 << indexes.size()) - 1; nextBitsetTemp += 2) {\n      int nextBitset = 0;\n      for (int j = 0; j < indexes.size(); j++) {\n        if (isInBitset(nextBitsetTemp, j)) {\n          nextBitset |= (1 << indexes.get(j));\n        }\n      }\n      assignmentCache[bitset] = \n        Math.max(assignmentCache[bitset], \n          Math.min(oneGroupCache[nextBitset], solve(bitset - nextBitset)));\n    }\n    return assignmentCache[bitset];\n  }\n\n  public double solve() {\n    oneGroupCache = new double[1 << n];\n    for (int bitset = 1; bitset < (1 << n); bitset++) {\n      oneGroupCache[bitset] = calculateGroupWater(bitset);\n    }\n\n    assignmentCache = new double[1 << n];\n    Arrays.fill(assignmentCache, Double.NEGATIVE_INFINITY);\n    return solve((1 << n) - 1);\n  }\n}\n\npublic class Main {\n  private static void execute(ContestReader reader, ContestWriter out) {\n    int n = reader.nextInt();\n    int[][] xyas = reader.nextInt(n, 3);\n    out.printf(\"%.20f\\n\", new Solver(n, xyas).solve());\n  }\n  \n  public static void main(String[] args) {\n    ContestReader reader = new ContestReader(System.in);\n    ContestWriter out = new ContestWriter(System.out);\n    execute(reader, out);\n    out.flush();\n  }\n}\n\nclass ContestWriter extends PrintWriter {\n  ContestWriter(PrintStream printeStream) {\n    super(printeStream);\n  }\n\n  public void printList(List<? extends Object> list) {\n    for (Object object : list) {\n      println(object);\n    }\n  }\n\n  public void printListOneLine(List<? extends Object> list) {\n    List<String> stringList = new ArrayList<>();\n    for (Object object : list) {\n      stringList.add(object.toString());\n    }\n    println(String.join(\" \", stringList));\n  }\n}\n\nclass ContestReader {\n  private static final int BUFFER_SIZE = 1024;\n  \n  private final InputStream stream;\n  private final byte[] buffer;\n  private int pointer;\n  private int bufferLength;\n  \n  ContestReader(InputStream stream) {\n    this.stream = stream;\n    this.buffer = new byte[BUFFER_SIZE];\n    this.pointer = 0;\n    this.bufferLength = 0;\n  }\n  \n  private boolean hasNextByte() {\n    if (pointer < bufferLength) {\n      return true;\n    }\n    \n    pointer = 0;\n    try {\n      bufferLength = stream.read(buffer);\n    } catch (IOException e) {\n      throw new RuntimeException(e);\n    }\n    return bufferLength > 0;\n  }\n  \n  private int readByte() {\n    if (hasNextByte()) {\n      return buffer[pointer++];\n    } else {\n      return -1;\n    }\n  }\n  \n  private static boolean isPrintableChar(int c) {\n    return 33 <= c && c <= 126;\n  }\n  \n  public boolean hasNext() {\n    while (hasNextByte() && !isPrintableChar(buffer[pointer])) {\n      pointer++;\n    }\n    return hasNextByte();\n  }\n  \n  public String next() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b)) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public String nextLine() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    StringBuilder sb = new StringBuilder();\n    while(true) {\n      int b = readByte();\n      if (!isPrintableChar(b) && b != 0x20) {\n        break;\n      }\n      sb.appendCodePoint(b);\n    }\n    return sb.toString();\n  }\n  \n  public char nextChar() {\n    return next().charAt(0);\n  }\n  \n  public int nextInt() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    int n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public long nextLong() {\n    if (!hasNext()) {\n      throw new NoSuchElementException();\n    }\n    \n    long n = 0;\n    boolean minus = false;\n    \n    {\n      int b = readByte();\n      if (b == '-') {\n        minus = true;\n      } else if ('0' <= b && b <= '9') {\n        n = b - '0';\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n    \n    while(true){\n      int b = readByte();\n      if ('0' <= b && b <= '9') {\n        n *= 10;\n        n += b - '0';\n      } else if (b == -1 || !isPrintableChar(b)) {\n        return minus ? -n : n;\n      } else {\n        throw new NumberFormatException();\n      }\n    }\n  }\n  \n  public double nextDouble() {\n    return Double.parseDouble(next());\n  }\n  \n  public String[] next(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = next();\n    }\n    return array;\n  }\n  \n  public String[] nextLine(int n) {\n    String[] array = new String[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLine();\n    }\n    return array;\n  }\n  \n  public char[] nextChar(int n) {\n    char[] array = new char[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextChar();\n    }\n    return array;\n  }\n  \n  public int[] nextInt(int n) {\n    int[] array = new int[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextInt();\n    }\n    return array;\n  }\n  \n  public long[] nextLong(int n) {\n    long[] array = new long[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextLong();\n    }\n    return array;\n  }\n  \n  public double[] nextDouble(int n) {\n    double[] array = new double[n];\n    for (int i = 0; i < n; i++) {\n      array[i] = nextDouble();\n    }\n    return array;\n  }\n  \n  public char[] nextCharArray() {\n    return next().toCharArray();\n  }\n  \n  public String[][] next(int n, int m) {\n    String[][] matrix = new String[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = next();\n      }\n    }\n    return matrix;\n  }\n  \n  public int[][] nextInt(int n, int m) {\n    int[][] matrix = new int[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextInt();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextChar(int n, int m) {\n    char[][] matrix = new char[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextChar();\n      }\n    }\n    return matrix;\n  }\n  \n  public long[][] nextLong(int n, int m) {\n    long[][] matrix = new long[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextLong();\n      }\n    }\n    return matrix;\n  }\n  \n  public double[][] nextDouble(int n, int m) {\n    double[][] matrix = new double[n][m];\n    for (int i = 0; i < n; i++) {\n      for (int j = 0; j < m; j++) {\n        matrix[i][j] = nextDouble();\n      }\n    }\n    return matrix;\n  }\n  \n  public char[][] nextCharArray(int n) {\n    char[][] matrix = new char[n][];\n    for (int i = 0; i < n; i++) {\n      matrix[i] = next().toCharArray();\n    }\n    return matrix;\n  }\n}\n\nclass MyAssert {\n  public static void myAssert(boolean flag, String message) {\n    if (!flag) {\n      throw new RuntimeException(message);\n    }\n  }\n \n  public static void myAssert(boolean flag) {\n    myAssert(flag, \"\");\n  }\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing Number = System.Int64;\nusing System.Numerics;\nusing static System.Math;\nnamespace Program {\n    public class Solver {\n        //Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            var P = Enumerate(n, x => new long[] { ri, ri, ri });\n            var es = new List<KeyValuePair<int, double>>();\n            for (int i = 0; i < n; i++)\n                for (int j = i + 1; j < n; j++)\n                {\n                    var dx = P[i][0] - P[j][0];\n                    var dy = P[i][1] - P[j][1];\n                    es.Add(new KeyValuePair<int, double>(i * n + j, Math.Sqrt(dx * dx + dy * dy)));\n                }\n            es.Sort((l, r) => l.Value.CompareTo(r.Value));\n            var cost = new double[1 << n];\n            for (int i = 1; i < 1 << n; i++)\n            {\n                var set = new DisjointSet(n);\n                foreach (var e in es)\n                {\n                    var u = e.Key / n;\n                    var v = e.Key % n;\n                    if ((i >> u & 1) == 1 && (i >> v & 1) == 1 && set.Unite(u, v)) cost[i] -= e.Value;\n                }\n                var cnt = 0;\n                for (int j = 0; j < n; j++)\n                    if ((i >> j & 1) == 1) { cost[i] += P[j][2]; cnt++; }\n                cost[i] /= cnt;\n            }\n            var dp = new double[1 << n];\n            for (int i = 0; i < 1 << n; i++)\n            {\n                dp[i] = cost[i];\n                for (int s = i; s > 0; s = (s - 1) & i)\n                    dp[i] = Max(dp[i], Min(dp[s], dp[s ^ i]));\n            }\n\n            Console.WriteLine(\"{0:0.000000000000}\", dp.Last());\n\n        }\n        const long INF = 1L << 60;\n        //static int[] dx = { -1, 0, 1, 0 };\n        //static int[] dy = { 0, 1, 0, -1 };\n\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        try\n        {\n            solver.Solve();\n            Console.Out.Flush();\n        }\n        catch { }\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n#region DisjointSet\npublic class DisjointSet {\n    int[] par;\n    byte[] rank;\n    public DisjointSet(int n) {\n        par = new int[n];\n        for (int i = 0; i < n; i++)\n            par[i] = -1;\n        rank = new byte[n];\n    }\n    public int this[int id] {\n        get {\n            if ((par[id] < 0)) return id;\n            return par[id] = this[par[id]];\n        }\n    }\n    public bool Unite(int x, int y) {\n        x = this[x]; y = this[y];\n        if (x == y) return false;\n        if (rank[x] < rank[y]) { var z = x; x = y; y = z; }\n        par[x] += par[y];\n        par[y] = x;\n        if (rank[x] == rank[y])\n            rank[x]++;\n        return true;\n    }\n    public int Size(int x) { return -par[this[x]]; }\n    public bool IsUnited(int x, int y) { return this[x] == this[y]; }\n\n}\n#endregion"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nclass Solve{\n    public Solve(){}\n    StringBuilder sb;\n    public static int Main(){\n        new Solve().Run();\n        return 0;\n    }\n    void Run(){\n        sb = new StringBuilder();\n        Calc();\n        Console.Write(sb.ToString());\n    }\n    void Calc(){\n        int N = int.Parse(Console.ReadLine());\n        double[] data = new double[1 << N];\n        {   \n            long[] X = new long[N];\n            long[] Y = new long[N];\n            long[] A = new long[N];\n            for(int i=0;i<N;i++){\n                string[] str = Console.ReadLine().Split(' ');\n                X[i] = int.Parse(str[0]);\n                Y[i] = int.Parse(str[1]);\n                A[i] = int.Parse(str[2]);\n            }\n            data[0] = 1000000000000000000;\n            for(int i=1;i<1 << N;i++){\n                List<int> choose = new List<int>();\n                double sum = 0;\n                for(int j=0;j<N;j++){\n                    if((i & (1 << j)) != 0){\n                        choose.Add(j);\n                        sum += A[j];\n                    }\n                }\n                List<int> p1 = new List<int>();\n                List<int> p2 = new List<int>();\n                List<double> d = new List<double>();\n                for(int j=0;j<choose.Count;j++){\n                    for(int k=j+1;k<choose.Count;k++){\n                        p1.Add(j);\n                        p2.Add(k);\n                        d.Add(Math.Sqrt((X[choose[j]]-X[choose[k]])*(X[choose[j]]-X[choose[k]])+(Y[choose[j]]-Y[choose[k]])*(Y[choose[j]]-Y[choose[k]])));\n                    }\n                }\n                Kruskal K = new Kruskal(choose.Count,p1.ToArray(),p2.ToArray(),d.ToArray());\n                data[i] = (sum - K.cost)/choose.Count;\n            }\n        }\n        double[] dp = new double[1 << N];\n        dp[0] = 1000000000000000000;\n        for(int i=1;i< 1 << N;i++){\n            double max = 0;\n            for(int j = i;j != 0;j = (i & (j-1))){\n                max = Math.Max(max,Math.Min(dp[i-j],data[j]));\n            }\n            dp[i] = max;\n        }\n        sb.Append(dp[(1 << N) - 1]+\"\\n\");\n    }\n}\nclass UnionFind{\n    int[] par;\n    public UnionFind(int n){\n        par = new int[n];\n        for(int i=0;i<n;i++){\n            par[i] = i;\n        }\n    }\n    public void Union(int x,int y){\n        par[Get(x)] = Get(y); \n    }\n    public bool Same(int x,int y){\n        return Get(x) == Get(y);\n    }\n    int Get(int x){\n        if(x != par[x]){\n            par[x] = Get(par[x]);\n        }\n        return par[x];\n    }\n}\nclass Edge{\n    public int a;\n    public int b;\n    public double cost;\n    public Edge(int a0,int b0,double c){\n        a = a0;\n        b = b0;\n        cost = c;\n    }\n}\nclass Kruskal{\n    int N,M;\n    public Edge[] edges;\n    public double cost;\n    public Kruskal(int n,Edge[] e){\n        N = n;\n        edges = e;\n        M = e.Length;\n        Act();\n    }\n    public Kruskal(int n,int[] a,int[] b,double[] c){\n        N = n;\n        M = a.Length;\n        edges = new Edge[M];\n        for(int i=0;i<M;i++){\n            edges[i] = new Edge(a[i],b[i],c[i]);\n        }\n        Act();\n    }\n    void Act(){\n        UnionFind U = new UnionFind(N);\n        cost = 0;\n        Array.Sort(edges,(a,b) => a.cost > b.cost ? 1 : (a.cost == b.cost ? 0 : -1));\n        for(int i=0;i<M;i++){\n            if(!U.Same(edges[i].a,edges[i].b)){\n                U.Union(edges[i].a,edges[i].b);\n                cost += edges[i].cost;\n            }\n        }\n    } \n}"
  },
  {
    "language": "D",
    "code": "/+ dub.sdl:\n    name \"A\"\n    dependency \"dcomp\" version=\">=0.6.0\"\n+/\n\nimport std.stdio, std.algorithm, std.range, std.conv;\nimport std.typecons, std.math;\n// import dcomp.foundation, dcomp.scanner;\n// import dcomp.datastructure.unionfind;\n\nint n;\ndouble[2][] p;\ndouble[] a;\n\ndouble[] costs;\n\ndouble calc(int f) {\n    alias Q = Tuple!(double, int, int);\n    Q[] edges;\n    foreach (i; 0..n) {\n        foreach (j; i+1..n) {\n            if (!(f & (1<<i))) continue;\n            if (!(f & (1<<j))) continue;\n            double u = 0;\n            u += (p[i][0]-p[j][0])*(p[i][0]-p[j][0]);\n            u += (p[i][1]-p[j][1])*(p[i][1]-p[j][1]);\n            edges ~= Q(sqrt(u), i, j);\n        }\n    }\n    edges.sort!\"a[0]<b[0]\";\n    auto uf = UnionFind(n);\n    double ans = 0;\n    foreach (e; edges) {\n        if (uf.same(e[1], e[2])) continue;\n        ans += e[0];\n        uf.merge(e[1], e[2]);\n    }\n    double sm = 0;\n    int co = 0;\n    foreach (i; 0..n) {\n        if (f & (1<<i)) {\n            co++;\n            sm += a[i];\n        }\n    }\n    return max(0.0, (sm-ans))/co;\n}\nint main() {\n    auto sc = new Scanner(stdin);\n    sc.read(n);\n    p = new double[2][n];\n    a = new double[n];\n    foreach (i; 0..n) {\n        sc.read(p[i][0], p[i][1], a[i]);\n    }\n    costs = new double[1<<n];\n    iota(1, 1<<n).each!(i => costs[i] = calc(i));\n//    writeln(costs);\n\n    auto dp = new double[1<<n];\n    foreach (i; 1..(1<<n)) {\n        dp[i] = costs[i];\n        for (auto j = 0; j < i; j = ((j|~i)+1)&i) {\n            if (j == 0) continue;\n            dp[i] = max(dp[i], min(dp[j], costs[i^j]));\n        }\n    }\n    writefln(\"%.20f\", dp[(1<<n)-1]);\n    return 0;\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/foundation.d */\n// module dcomp.foundation;\n//fold(for old compiler)\nstatic if (__VERSION__ <= 2070) {\n    template fold(fun...) if (fun.length >= 1) {\n        auto fold(R, S...)(R r, S seed) {\n            import std.algorithm : reduce;\n            static if (S.length < 2) {\n                return reduce!fun(seed, r);\n            } else {\n                import std.typecons : tuple;\n                return reduce!fun(tuple(seed), r);\n            }\n        }\n    }\n    unittest {\n        import std.stdio;\n        auto l = [1, 2, 3, 4, 5];\n        assert(l.fold!\"a+b\"(10) == 25);\n    }\n}\nversion (X86) static if (__VERSION__ < 2071) {\n    int bsf(ulong v) {\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;\n    }\n    int bsr(ulong v) {\n        foreach_reverse (i; 0..64) {\n            if (v & (1UL << i)) return i;\n        }\n        return -1;   \n    }\n    int popcnt(ulong v) {\n        int c = 0;\n        foreach (i; 0..64) {\n            if (v & (1UL << i)) c++;\n        }\n        return c;\n    }\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/scanner.d */\n// module dcomp.scanner;\n\nclass Scanner {\n    import std.stdio : File;\n    import std.conv : to;\n    import std.range : front, popFront, array, ElementType;\n    import std.array : split;\n    import std.traits : isSomeChar, isStaticArray, isArray; \n    import std.algorithm : map;\n    File f;\n    this(File f) {\n        this.f = f;\n    }\n    char[512] lineBuf;\n    char[] line;\n    private bool succ() {\n        import std.range.primitives : empty, front, popFront;\n        import std.ascii : isWhite;\n        while (true) {\n            while (!line.empty && line.front.isWhite) {\n                line.popFront;\n            }\n            if (!line.empty) break;\n            if (f.eof) return false;\n            line = lineBuf[];\n            f.readln(line);\n        }\n        return true;\n    }\n\n    private bool readSingle(T)(ref T x) {\n        import std.algorithm : findSplitBefore;\n        import std.string : strip;\n        import std.conv : parse;\n        if (!succ()) return false;\n        static if (isArray!T) {\n            alias E = ElementType!T;\n            static if (isSomeChar!E) {\n                //string or char[10] etc\n                //todo optimize\n                auto r = line.findSplitBefore(\" \");\n                x = r[0].strip.dup;\n                line = r[1];\n            } else {\n                auto buf = line.split.map!(to!E).array;\n                static if (isStaticArray!T) {\n                    //static\n                    assert(buf.length == T.length);\n                }\n                x = buf;\n                line.length = 0;\n            }\n        } else {\n            x = line.parse!T;\n        }\n        return true;\n    }\n    int read(T, Args...)(ref T x, auto ref Args args) {\n        if (!readSingle(x)) return 0;\n        static if (args.length == 0) {\n            return 1;\n        } else {\n            return 1 + read(args);\n        }\n    }\n}\n\n\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    fout.writeln(\"1 2 3\");\n    fout.writeln(\"ab cde\");\n    fout.writeln(\"1.0 1.0 2.0\");\n    fout.close;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    int a;\n    int[2] b;\n    char[2] c;\n    string d;\n    double e;\n    double[] f;\n    sc.read(a, b, c, d, e, f);\n    assert(a == 1);\n    assert(equal(b[], [2, 3]));\n    assert(equal(c[], \"ab\"));\n    assert(equal(d, \"cde\"));\n    assert(e == 1.0);\n    assert(equal(f, [1.0, 2.0]));\n}\n\nunittest {\n    import std.path : buildPath;\n    import std.file : tempDir;\n    import std.algorithm : equal;\n    import std.stdio : File, writeln;\n    import std.datetime;\n    string fileName = buildPath(tempDir, \"kyuridenanmaida.txt\");\n    auto fout = File(fileName, \"w\");\n    foreach (i; 0..1_000_000) {\n        fout.writeln(3*i, \" \", 3*i+1, \" \", 3*i+2);\n    }\n    fout.close;\n    writeln(\"Scanner Speed Test(3*1,000,000 int)\");\n    StopWatch sw;\n    sw.start;\n    Scanner sc = new Scanner(File(fileName, \"r\"));\n    foreach (i; 0..500_000) {\n        int a, b, c;\n        sc.read(a, b, c);\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 500_000..700_000) {\n        int[3] d;\n        sc.read(d);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    foreach (i; 700_000..1_000_000) {\n        int[] d;\n        sc.read(d);\n        assert(d.length == 3);\n        int a = d[0], b = d[1], c = d[2];\n        assert(a == 3*i);\n        assert(b == 3*i+1);\n        assert(c == 3*i+2);\n    }\n    writeln(sw.peek.msecs, \"ms\");\n}\n/* IMPORT /home/yosupo/Program/dcomp/source/dcomp/datastructure/unionfind.d */\n// module dcomp.datastructure.unionfind;\n\nstruct UnionFind {\n    import std.algorithm : map, swap, each;\n    import std.range : iota, array;\n    int[] id; // group id\n    int[][] groups; // group list\n    int count; // group count\n    this(int n) {\n        id = iota(n).array;\n        groups = iota(n).map!(a => [a]).array;\n        count = n;\n    }\n    void merge(int a, int b) {\n        if (same(a, b)) return;\n        count--;\n        int x = id[a], y = id[b];\n        if (groups[x].length < groups[y].length) swap(x, y);\n        groups[y].each!(a => id[a] = x);\n        groups[x] ~= groups[y];\n        groups[y] = [];\n    }\n    int[] group(int i) {\n        return groups[id[i]];\n    }\n    bool same(int a, int b) {\n        return id[a] == id[b];\n    }\n}\n\nunittest {\n    import std.algorithm : equal, sort;\n    auto uf = UnionFind(5);\n    assert(!uf.same(1, 3));\n    assert(uf.same(0, 0));\n\n    uf.merge(3, 2);\n    uf.merge(1, 1);\n    uf.merge(4, 2);\n    uf.merge(4, 3);\n\n    assert(uf.count == 3);\n    assert(uf.id[2] == uf.id[3]);\n    assert(uf.id[2] == uf.id[4]);\n    assert(equal(uf.group(0), [0]));\n    assert(equal(uf.group(1), [1]));\n    assert(equal(sort(uf.group(2)), [2, 3, 4]));\n}\n\nunittest {\n    import std.datetime, std.stdio, std.range;\n    // speed check\n    writeln(\"UnionFind Speed Test\");\n    StopWatch sw;\n    sw.start;\n    UnionFind uf;\n    // line\n    uf = UnionFind(1_000_000);\n    foreach (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // line(reverse)\n    uf = UnionFind(1_000_000);\n    foreach_reverse (i; 1..1_000_000) {\n        uf.merge(i-1, i);\n    }\n    // binary tree\n    uf = UnionFind(1_000_000);\n    foreach (lg; 1..20) {\n        int len = 1<<lg;\n        foreach (i; iota(0, 1_000_000-len/2, len)) {\n            uf.merge(i, i+len/2);\n        }\n    }\n    sw.stop;\n    writeln(sw.peek.msecs, \"ms\");\n}\n"
  },
  {
    "language": "Python",
    "code": "from math import sqrt\nn = input()\nP = [map(int, raw_input().split()) for i in xrange(n)]\nA = [e[2] for e in P]\n\ndef dist(p, q):\n    return sqrt((p[0] - q[0])**2 + (p[1] - q[1])**2)\nque = []\nfor i in xrange(n):\n    for j in xrange(i+1, n):\n        que.append((dist(P[i], P[j]), i, j))\nque.sort()\n\nmemo = [-1]*2**n\nmemo[0] = 0\ndef calc(state):\n    if memo[state] != -1:\n        return memo[state]\n    res = 0\n    cnt = 0\n    for i in xrange(n):\n        if (state >> i) & 1:\n            res += A[i]\n            cnt += 1\n    parent = range(n)\n    def root(x):\n        if x != parent[x]:\n            parent[x] = x = root(parent[x])\n        return x\n    def unite(x, y):\n        px = root(x); py = root(y)\n        if px < py:\n            parent[py] = px\n        else:\n            parent[px] = py\n    for d, i, j in que:\n        if (state >> i) & 1 and (state >> j) & 1 and root(i) != root(j):\n            unite(i, j)\n            res -= d\n    res /= float(cnt)\n    memo[state] = res\n    return res\n\ndic = {}\nfor i in xrange(n):\n    dic[1<<i] = A[i]\ndef dfs(state):\n    if state in dic:\n        return dic[state]\n\n    res = calc(state)\n    sub = (state - 1) & state\n    while sub != 0:\n        if sub <= sub ^ state:\n            res = max(res, min(calc(sub ^ state), dfs(sub)))\n        sub = (sub - 1) & state\n    dic[state] = res\n    return res\nprint \"%.10f\" % dfs(2**n-1)\n"
  }
]