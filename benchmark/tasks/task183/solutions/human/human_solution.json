[
  {
    "language": "Scala",
    "code": "\nobject Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  solve\n  def solve: Unit ={\n    val Array(h, w) = readLine.trim.split(' ').map(_.toInt)\n    if (h == 0) return\n    val state = Array.tabulate(h){_ ⇒ readLine.trim}\n    val girl = state.indices.flatMap(h ⇒ state(h).indices.map{w ⇒ Coordinate(w, h)}).find{c ⇒ state(c.y)(c.x) == 'A'}.get\n    val minTime = Array.tabulate(h){_ ⇒ Array.tabulate(w){_ ⇒ Int.MaxValue}}.also{arr ⇒ arr(girl.y)(girl.x) = 0}\n    var current = List(girl)\n    while (current.nonEmpty){\n      var next = Nil: List[Coordinate]\n      for {c ← current; n ← c.neighbor} {\n        if ((0 until h).contains(n.y) && (0 until w).contains(n.x) && state(n.y)(n.x) != '#' && minTime(n.y)(n.x) > minTime(c.y)(c.x) + 1) {\n          minTime(n.y)(n.x) = minTime(c.y)(c.x) + 1\n          next ::= n\n        }\n      }\n      current = next\n    }\n    val pattern = readLine.trim.map{_.asDigit}.toArray\n    val count = Array.tabulate(h){_ ⇒ Array.tabulate(w){_ ⇒ 0}}\n    var ghost = state.indices.flatMap(h ⇒ state(h).indices.map{w ⇒ Coordinate(w, h)}).find{c ⇒ state(c.y)(c.x) == 'B'}.get\n\n    var time = 0\n    var firstContact: Option[(Int, Int, Int)] = None\n    while (count(ghost.y)(ghost.x) <= pattern.length && firstContact.isEmpty){\n      count(ghost.y)(ghost.x) += 1\n      if (minTime(ghost.y)(ghost.x) <= time){\n        firstContact = Some(time, ghost.y, ghost.x)\n      }\n      ghost = move(ghost, pattern(time % pattern.length), h, w)\n      time += 1\n    }\n    var additional = 0\n    while (firstContact.isEmpty && additional <= h * w){\n      if (minTime(ghost.y)(ghost.x) <= time + additional){\n        firstContact = Some(time + additional, ghost.y, ghost.x)\n      }\n      ghost = move(ghost, pattern((time + additional) % pattern.length), h, w)\n      additional += 1\n    }\n    println(\n      firstContact match {\n        case Some((t, y, x)) ⇒ s\"$t $y $x\"\n        case None ⇒ \"impossible\"\n      }\n    )\n    solve\n  }\n  def move(coordinate: Coordinate, direction: Int, h: Int, w: Int): Coordinate = {\n    (direction match {\n      case 8 ⇒ Coordinate(0, -1) + coordinate\n      case 6 ⇒ Coordinate(1, 0) + coordinate\n      case 4 ⇒ Coordinate(-1, 0) + coordinate\n      case 2 ⇒ Coordinate(0, 1) + coordinate\n      case _ ⇒ coordinate\n    }).let{c ⇒\n      if ((0 until h).contains(c.y) && (0 until w).contains(c.x)) c\n      else coordinate\n    }\n  }\n  case class Coordinate(x: Int, y: Int) {\n    def +(that: Coordinate): Coordinate = Coordinate(x + that.x, y + that.y)\n    def neighbor: List[Coordinate] = List(Coordinate(x + 1, y), Coordinate(x - 1, y), Coordinate(x, y + 1), Coordinate(x, y - 1))\n    def nextPosition: List[Coordinate] = this::neighbor\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "Scala",
    "code": "object Main extends App {\n\n  import scala.io.StdIn._\n  import scala.math._\n\n  solve\n  def solve: Unit ={\n    val Array(h, w) = readLine.trim.split(' ').map(_.toInt)\n    if (h == 0) return\n    val state = Array.tabulate(h){_ ⇒ readLine.trim}\n    val girl = state.indices.flatMap(h ⇒ state(h).indices.map{w ⇒ Coordinate(w, h)}).find{c ⇒ state(c.y)(c.x) == 'A'}.get\n    val minTime = Array.tabulate(h){_ ⇒ Array.tabulate(w){_ ⇒ Int.MaxValue}}.also{arr ⇒ arr(girl.y)(girl.x) = 0}\n    var current = List(girl)\n    while (current.nonEmpty){\n      var next = Nil: List[Coordinate]\n      for {c ← current; n ← c.neighbor} {\n        if ((0 until h).contains(n.y) && (0 until w).contains(n.x) && state(n.y)(n.x) != '#' && minTime(n.y)(n.x) > minTime(c.y)(c.x) + 1) {\n          minTime(n.y)(n.x) = minTime(c.y)(c.x) + 1\n          next ::= n\n        }\n      }\n      current = next\n    }\n    val pattern = readLine.trim.map(_.asDigit).toArray\n    var ghost = (state.indices.flatMap(h ⇒ state(h).indices.map{w ⇒ Coordinate(w, h)}).find{c ⇒ state(c.y)(c.x) == 'B'}.get, 0)\n    var doubleGhost = (move(ghost._1, pattern(ghost._2 % pattern.length), h, w), (ghost._2 + 1) % pattern.length)\n    var canContact = false\n    while ((ghost._1 != doubleGhost._1 || ghost._2 % pattern.length != doubleGhost._2 % pattern.length) && !canContact){\n      ghost = (move(ghost._1, pattern(ghost._2 % pattern.length), h, w), ghost._2 + 1)\n      if (minTime(ghost._1.y)(ghost._1.x) <= ghost._2) {\n        canContact = true\n      }\n      doubleGhost = (move(doubleGhost._1, pattern(doubleGhost._2), h, w), (doubleGhost._2 + 1) % pattern.length)\n      doubleGhost = (move(doubleGhost._1, pattern(doubleGhost._2), h, w), (doubleGhost._2 + 1) % pattern.length)\n    }\n    var findReachable = false\n    if (minTime(ghost._1.y)(ghost._1.x) != Int.MaxValue){\n      findReachable = true\n    }\n    if (minTime(ghost._1.y)(ghost._1.x) <= ghost._2) {\n      canContact = true\n    }\n    doubleGhost = ghost\n    ghost = (move(ghost._1, pattern(ghost._2 % pattern.length), h, w), ghost._2 + 1)\n    while (((ghost._1 != doubleGhost._1 || ghost._2 % pattern.length != doubleGhost._2 % pattern.length) || findReachable) && !canContact) {\n      if (minTime(ghost._1.y)(ghost._1.x) != Int.MaxValue){\n        findReachable = true\n      }\n      if (minTime(ghost._1.y)(ghost._1.x) <= ghost._2) {\n        canContact = true\n      }\n      ghost = (move(ghost._1, pattern(ghost._2 % pattern.length), h, w), ghost._2 + 1)\n    }\n    println(\n      canContact match {\n        case true ⇒ s\"${ghost._2 - 1} ${ghost._1.y} ${ghost._1.x}\"\n        case false ⇒ \"impossible\"\n      }\n    )\n    solve\n  }\n  def move(coordinate: Coordinate, direction: Int, h: Int, w: Int): Coordinate = {\n    (direction match {\n      case 8 ⇒ Coordinate(0, -1) + coordinate\n      case 6 ⇒ Coordinate(1, 0) + coordinate\n      case 4 ⇒ Coordinate(-1, 0) + coordinate\n      case 2 ⇒ Coordinate(0, 1) + coordinate\n      case _ ⇒ coordinate\n    }).let{c ⇒\n      if ((0 until h).contains(c.y) && (0 until w).contains(c.x)) c\n      else coordinate\n    }\n  }\n  case class Coordinate(x: Int, y: Int) {\n    def +(that: Coordinate): Coordinate = Coordinate(x + that.x, y + that.y)\n    def neighbor: List[Coordinate] = List(Coordinate(x + 1, y), Coordinate(x - 1, y), Coordinate(x, y + 1), Coordinate(x, y - 1))\n    def nextPosition: List[Coordinate] = this::neighbor\n  }\n  implicit class Extension[T](val value :T){\n    def also(func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    def let[R](func: T ⇒ R): R = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[0][0] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 9000000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <fstream>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nmain(){\n  int h,w;\n  while(cin>>h>>w,h|w){\n    string in[h],pa;\n    int sx,sy,bx,by;\n    rep(i,h){\n      cin>>in[i];\n      rep(j,w){\n\tif(in[i][j]=='A'){\n\t  sx=i;\n\t  sy=j;\n\t  in[i][j]='.';\n\t}\n\tif(in[i][j]=='B'){\n\t  bx=i;\n\t  by=j;\n\t  in[i][j]='.';\n\t}\n      }\n    }\n    cin>>pa;\n\n\n    int cost[h][w];\n    rep(i,h)rep(j,w)cost[i][j]=INT_MAX/2;\n\n    queue<PI> Q;\n    Q.push(mp(0,sx*1000+sy));\n\n    while(!Q.empty()){\n      int cc=Q.front().F,cx=Q.front().S/1000,cy=Q.front().S%1000;\n      Q.pop();\n      //cout<<cx<<\" \"<<cy<<endl;\n      if(cost[cx][cy]<=cc)continue;\n      cost[cx][cy]=cc;\n\n      rep(i,4){\n\tint nx=cx+dx[i],ny=cy+dy[i];\n\tif(nx<0 || h<=nx || ny<0 || w<=ny || in[nx][ny]=='#'){\n\t  continue;\n\t}\n\tQ.push(mp(cc+1,1000*nx+ny));\n      }\n    }\n\n    int ans=-1,ax,ay;\n    set<int> app[h][w];\n    int po=0;\n    int time=0;\n    int imp=0;\n\n    while(true){\n      if(cost[bx][by]<=time){\n\tans=time;\n\tax=bx;\n\tay=by;\n\tbreak;\n      }\n\n      if(app[bx][by].count(po)){\n\tbreak;\n      }\n\n      if(cost[bx][by]==INT_MAX/2){\n\timp++;\n      }\n\n      if(cost[bx][by]==INT_MAX/2 && imp>=pa.size()){\n\tapp[bx][by].insert(po);\n      }\n      \n      int px=bx,py=by;\n      switch(pa[po]){\n      case '8':\n\tbx--;\n\tbreak;\n      case '6':\n\t++by;\n\tbreak;\n      case '4':\n\t--by;\n\tbreak;\n      case '2':\n\t++bx;\n\tbreak;\n      }\n      if(bx<0 || h<=bx || by<0 || w<=by){\n\tbx=px;\n\tby=py;\n      }\n      ++time;\n      ++po;\n      if(po>=pa.size()){\n\tpo=0;\n\tif(imp<pa.size())imp=0;\n      }\n    }\n    if(ans==-1)cout<<\"impossible\";\n    else cout<<ans<<\" \"<<ax<<\" \"<<ay;\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\nint H, W;\nchar grid[25][25];\nstring pat;\nint grid2[25][25];\nint ay, ax;\nint by, bx;\n\nvoid bfs()\n{\n    const int INF = 100000000;\n    int dy[4] = {0, -1, 0, 1};\n    int dx[4] = {-1, 0, 1, 0};\n\n    typedef pair<int, int> P;\n\n    queue<P> que;\n    rep(i,H) rep(j,W) {\n        grid2[i][j] = INF;\n    }\n\n    que.push(P(ay, ax));\n    grid2[ay][ax] = 0;\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        rep(i,4) {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n\n            if (0 <= ny && ny < H && 0 <= nx && nx < W && grid[ny][nx] == '.' && grid2[ny][nx] == INF) {\n                que.push(P(ny, nx));\n                grid2[ny][nx] = grid2[p.first][p.second] + 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n#ifdef LOCAL\n    ifstream in(\"input.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n\n    while (true) {\n        cin >> H >> W;\n        if (H == 0 && W == 0) break;\n\n        rep(i,H) rep(j,W) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'A') {\n                ay = i;\n                ax = j;\n                grid[i][j] = '.';\n            } else if (grid[i][j] == 'B') {\n                by = i;\n                bx = j;\n                grid[i][j] = '.';\n            }\n        }\n        cin >> pat;\n\n        /*\n        int sy = 0, sx = 0;\n        rep(i,pat.length()) {\n            if (pat[i] == '5') {\n                sy += 0;\n                sx += 0;\n            } else if(pat[i] == '4') {\n                sy += 0;\n                sx -= 1;\n            } else if (pat[i] == '8') {\n                sy -= 1;\n                sx += 0;\n            } else if (pat[i] == '6') {\n                sy += 0;\n                sx += 1;\n            } else if (pat[i] == '2') {\n                sy += 1;\n                sx += 0;\n            }\n        }\n        bool try_only_one = false;\n        if (sy == 0 && sx == 0) try_only_one = true;\n        */\n\n        bfs();\n\n        /*\n        rep(i,H) {\n            rep(j,W) {\n                printf(\"% 3d \", grid2[i][j]);\n            }\n            cout << endl;\n        }\n        */\n\n        bool possible = false;\n        int ans;\n        int ansy, ansx;\n        int cnt = 0;\n        rep(i,25) {\n            rep(j,pat.length()) {\n                cnt++;\n                if (pat[j] == '5') {\n                    by += 0;\n                    bx += 0;\n                } else if(pat[j] == '4') {\n                    by += 0;\n                    if (bx >= 1) bx -= 1;\n                } else if (pat[j] == '8') {\n                    if (by >= 1) by -= 1;\n                    bx += 0;\n                } else if (pat[j] == '6') {\n                    by += 0;\n                    if (bx < W - 1) bx += 1;\n                } else if (pat[j] == '2') {\n                    if (by < H - 1) by += 1;\n                    bx += 0;\n                }\n                if (grid2[by][bx] <= cnt && !possible) {\n                    possible = true;\n                    ans = cnt;\n                    ansy = by;\n                    ansx = bx;\n                }\n            }\n        }\n\n        if (possible) {\n            cout << ans << \" \" << ansy << \" \" << ansx << endl;\n        } else {\n            cout << \"impossible\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n           // cout<<q.size()<<endl;\n            pair<pair<int,int>,int> p = q.front();\n            q.pop();\n            if(co[p.first.second][p.first.first]!=INT_MAX){\n                continue;\n            }\n           // cout<<p.first.second<<\" \"<<p.first.first<<endl;\n            co[p.first.second][p.first.first]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n           // cout<<q.size()<<endl;\n        }\n        string pat;\n        cin>>pat;\n        int go=0;\n        for(int j=0;;j++){\n            int i=j%pat.length();\n         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>100000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='5'){\n                \n            } else if(pat[i]=='8'){\n                gy--;\n            } else if(pat[i]=='6'){\n                gx++;\n            } else if(pat[i]=='4'){\n                gx--;\n            } else if(pat[i]=='2'){\n                gy++;\n            }\n            gy=max(0,gy);\n            gy=min(h-1,gy);\n            gx=max(0,gx);\n            gx=min(w-1,gx);\n            go++;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<queue>\n#include<string.h>\nusing namespace std;\nint dx[]={0,1,0,-1,0};\nint dy[]={1,0,-1,0,0};\nchar m[30][30];\nchar str[30];\nint bfs[30][30];\nint main(){\n\tint a,b;\n\twhile(scanf(\"%d%d\",&a,&b),a){\n\t\tfor(int i=0;i<a;i++)scanf(\"%s\",m[i]);\n\t\tscanf(\"%s\",str);\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)bfs[i][j]=-1;\n\t\tqueue<pair<int,int> > Q;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(m[i][j]=='A'){\n\t\t\tQ.push(make_pair(i,j));\n\t\t\tbfs[i][j]=0;\n\t\t}\n\t\twhile(Q.size()){\n\t\t\tint row=Q.front().first;\n\t\t\tint col=Q.front().second;\n\t\t\tQ.pop();\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tif(0<=row+dx[i]&&row+dx[i]<a&&0<=col+dy[i]&&col+dy[i]<b&&m[row+dx[i]][col+dy[i]]!='#'&&!~bfs[row+dx[i]][col+dy[i]]){\n\t\t\t\t\tbfs[row+dx[i]][col+dy[i]]=bfs[row][col]+1;\n\t\t\t\t\tQ.push(make_pair(row+dx[i],col+dy[i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint row,col;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<b;j++)if(m[i][j]=='B'){\n\t\t\trow=i;col=j;\n\t\t}\n\t\tint len=strlen(str);\n\t\tbool ok=false;\n\t\tfor(int i=0;i<500;i++){\n\t\t\tif(~bfs[row][col]&&bfs[row][col]<=i){\n\t\t\t\tprintf(\"%d %d %d\\n\",i,row,col);ok=true;break;\n\t\t\t}\n\t\t\tif(str[i%len]=='2')row=min(row+1,a-1);\n\t\t\tif(str[i%len]=='4')col=max(col-1,0);\n\t\t\tif(str[i%len]=='6')col=min(col+1,b-1);\n\t\t\tif(str[i%len]=='8')row=max(row-1,0);\n\t\t}\n\t\tif(!ok)printf(\"impossible\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n\tint x, y;\n} Vector;\n\ntypedef struct {\n\tint x, y;\n\tint step;\n} DATA;\n\nunsigned int data[16 + 2][16 + 2];\nchar map[16 + 2][16 + 2];\n\nint change(char move[], Vector mv[])\n{\n\tint i = 0;\n\twhile (move[i] != '\\0'){\n\t\tmv[i].x = mv[i].y = 0;\n\t\tswitch (move[i]){\n\t\t  case '5':\n\t\t  \tbreak;\n\t\t  case '8':\n\t\t  \tmv[i].y = -1;\n\t\t\tbreak;\n\t\t  case '6':\n\t\t  \tmv[i].x = 1;\n\t\t\tbreak;\n\t\t  case '4':\n\t\t  \tmv[i].x = -1;\n\t\t\tbreak;\n\t\t  case '2':\n\t\t  \tmv[i].y = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn (i);\n}\n\nunsigned int move_sml(int gx, int gy, Vector mv[], int move_count, int* ans_x, int* ans_y)\n{\n\tunsigned int ret = 0xffffffff;\n\tfor (unsigned int i = 0; i < 1000000; i++){\n\t\tint mx = mv[i % move_count].x;\n\t\tint my = mv[i % move_count].y;\n\t\t\n\t\tif (data[gx][gy] <= i && ret > i){\n\t\t\tret = max(data[gx][gy], i);\n\t\t\t*ans_x = gx;\n\t\t\t*ans_y = gy;\n\t\t}\n\t\t\n\t\tif (map[gx + mx][gy + my] != -1){\n\t\t\tgx += mx;\n\t\t\tgy += my;\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint move_short_root(int sx, int sy)\n{\n\tlist<DATA> lst;\n\tDATA add;\n\t\n\tdata[sx][sy] = 0;\n\t\n\tadd.x = sx + 1;\n\tadd.y = sy;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx - 1;\n\tadd.y = sy;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx;\n\tadd.y = sy + 1;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx;\n\tadd.y = sy - 1;\n\tadd.step = 1;\n\tlst.push_back(add);\n\t\n\twhile (!lst.empty()){\n\t\tif (map[lst.front().x][lst.front().y] != -1 && map[lst.front().x][lst.front().y] != '#' && data[lst.front().x][lst.front().y] > lst.front().step){\n\t\t\tdata[lst.front().x][lst.front().y] = lst.front().step;\n\t\t\tadd.x = lst.front().x + 1;\n\t\t\tadd.y = lst.front().y;\n\t\t\tadd.step = lst.front().step + 1;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x - 1;\n\t\t\tadd.y = lst.front().y;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x;\n\t\t\tadd.y = lst.front().y + 1;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x;\n\t\t\tadd.y = lst.front().y - 1;\n\t\t\tlst.push_back(add);\n\t\t}\n\t\tlst.pop_front();\n\t}\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\tint hight, width;\n\tint ans_x, ans_y;\n\tint sx, sy, gx, gy;\n\tchar move[11];\n\tVector mv[10];\n\tint move_count;\n\tunsigned int ans;\n\t\n\twhile (1){\n\t\tmemset(data, 0xff, (18 * 18) * 4);\n\t\tmemset(map, -1, (18 * 18));\n\t\tcin >> hight >> width;\n\t\tif (hight == 0 && width == 0)break;\n\t\tfor (int y = 0; y < hight + 2; y++){\n\t\t\tchar str[16 + 1];\n\t\t\tif (y == 0 || y == hight + 1){\n\t\t\t\tfor (int x = 0; x < width + 2; x++){\n\t\t\t\t\tmap[x][y] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> str;\n\t\t\t\tmap[0][y] = map[width + 1][y] = -1;\n\t\t\t\tfor (int x = 0; x < width; x++){\n\t\t\t\t\tif (str[x] == 'A'){\n\t\t\t\t\t\tsx = x + 1;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (str[x] == 'B'){\n\t\t\t\t\t\tgx = x + 1;\n\t\t\t\t\t\tgy = y;\n\t\t\t\t\t}\n\t\t\t\t\tmap[x + 1][y] = str[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> move;\n\t\t\n\t\tmove_count = change(move, mv);\n\t\t\n\t\tmove_short_root(sx, sy);\n\t\t\n\t\tans = move_sml(gx, gy, mv, move_count, &ans_x, &ans_y);\n\t\t\n\t\tif (ans == 0xffffffff){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << ' ' << ans_y - 1 << ' ' << ans_x - 1 << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nchar g[20][20];\nint h,w;\nint t[20][20];\n\nvoid ff(int x,int y,int ct){\n  if(x<0||w<=x||y<0||h<=y||t[y][x]<ct||g[y][x]=='#')return;\n  t[y][x]=ct;\n  for(int i=0;i<4;i++){\n    int d[]={0,1,0,-1,0};\n    ff(x+d[i],y+d[i+1],ct+1);\n  }\n}\n\nint main(){\n  while(cin>>h>>w,h|w){\n    int ax,ay,bx,by;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n\tif(g[y][x]=='A'){\n\t  ax=x;\n\t  ay=y;\n\t}else if(g[y][x]=='B'){\n\t  bx=x;\n\t  by=y;\n\t}\n      }\n    }\n    fill(t[0],t[20],1<<30);\n    ff(ax,ay,0);\n    string p;\n    getline(cin.ignore(),p);\n    int e;\n    for(e=0;e<10000;e++){\n      if(t[by][bx]<=e)break;\n      char o=p[e%p.size()];\n      int ny=by+(o=='2')-(o=='8');\n      int nx=bx+(o=='6')-(o=='4');\n      if(0<=ny&&ny<h&&0<=nx&&nx<w){\n\tby=ny;\n\tbx=nx;\n      }\n    }\n    if(e<10000){\n      cout<<e<<' '<<by<<' '<<bx<<endl;\n    }else{\n      cout<<\"impossible\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        memset(visited, 0, sizeof(visited));\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pair<pair<int,int>,int> p = q.front();\n            visited[p.first.second][p.first.first]=1;\n            co[p.first.second][p.first.first]=p.second;\n           // cout<<p.first.second<<\"  \"<<p.first.first<<\"  \"<<p.second<<endl;\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX&&ma[ny][nx]!='A'&&!visited[ny][nx]){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n        }\n        string pat;\n        cin>>pat;\n        int go=0;\n        for(int j=0;;j++){\n            int i=j%pat.length();\n         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>10000000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='5'){\n                \n            } else if(pat[i]=='8'){\n                gy--;\n            } else if(pat[i]=='6'){\n                gx++;\n            } else if(pat[i]=='4'){\n                gx--;\n            } else if(pat[i]=='2'){\n                gy++;\n            }\n            gy=max(0,gy);\n            gy=min(h-1,gy);\n            gx=max(0,gx);\n            gx=min(w-1,gx);\n            go++;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\n\nusing namespace std;\n\nstruct St{\n  int ax, ay, bx, by, cst;\n  St() {}\n  St(int _ay, int _ax, int _by, int _bx, int _cst): ay(_ay), ax(_ax), by(_by), bx(_bx), cst(_cst) {}\n\n  bool check(){\n    return (ax == bx && ay == by);\n  }\n\n  void print(){\n    cout << cst << \" \" << by << \" \" << bx << endl;\n    return ;\n  }\n};\n\nint p_n, w, h, pat[10];\nchar a[21][21];\nbool vis[20][20][20][20][10];\nint xdir[5] = {0, 1, 0, -1, 0}, ydir[5] = {-1, 0, 1, 0, 0};\n\nbool bfs(St stt)\n{\n  queue<St> que;\n  que.push(stt);\n\n  while(!que.empty()){\n    St st = que.front();\n    que.pop();\n\n    if(st.check()){\n      st.print();\n      return false;\n    }\n    int p = st.cst%p_n;\n    int nby = st.by+ydir[pat[p]], nbx = st.bx+xdir[pat[p]];\n\n    if(0 > nby || nby >= h || 0 > nbx || nbx >= w){\n      nby = st.by; nbx = st.bx;\n    }\n\n    for(int i = 0; i < 5; ++i){\n      int dy = st.ay+ydir[i], dx = st.ax+xdir[i];\n      if(!(0 <= dy && dy < h && 0 <= dx && dx < w && a[dy][dx] == '.')){\n\tdy = st.ay; dx = st.ax;\n      }\n\n      if(vis[dy][dx][nby][nbx][p]){\n\tvis[dy][dx][nby][nbx][p] = false;\n\tque.push(St(dy, dx, nby, nbx, st.cst+1));\n      }\n    }\n  }\n\n  return true;\n}\n\nint main()\n{\n  int s, t, u, v;\n  string str;\n\n  while(cin>>h>>w && h+w){\n    fill(&vis[0][0][0][0][0], &vis[20][0][0][0][0], true);\n\n    for(int i = 0; i < h; ++i)\n      for(int j = 0; j < w; ++j){\n\tcin >> a[i][j];\n\tif(a[i][j] == 'A'){\n\t  s = i; t = j;\n\t  a[i][j] = '.';\n\t} else if(a[i][j] == 'B'){\n\t  u = i; v = j;\n\t  a[i][j] = '.';\n\t}\n      }\n    cin >> str;\n    p_n = str.size();\n\n    for(int i = 0; i < p_n; ++i){\n      if(str[i] == '8') pat[i] = 0;\n      else if(str[i] == '2') pat[i] = 2;\n      else if(str[i] == '6') pat[i] = 1;\n      else if(str[i] == '4') pat[i] = 3;\n      else if(str[i] == '5') pat[i] = 4;\n    }\n\n    if(bfs(St(s, t, u, v, 0))) cout << \"impossible\" << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        memset(visited, 0, sizeof(visited));\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pair<pair<int,int>,int> p = q.front();\n            if(visited[p.first.second][p.first.first]){\n                continue;\n            }\n            visited[p.first.second][p.first.first]=1;\n            co[p.first.second][p.first.first]=p.second;\n           // cout<<p.first.second<<\"  \"<<p.first.first<<\"  \"<<p.second<<endl;\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX&&ma[ny][nx]!='A'&&!visited[ny][nx]){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n        }\n        string pat;\n        cin>>pat;\n        int go=0;\n        for(int j=0;;j++){\n            int i=j%pat.length();\n         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>1000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='5'){\n                \n            } else if(pat[i]=='8'){\n                gy--;\n            } else if(pat[i]=='6'){\n                gx++;\n            } else if(pat[i]=='4'){\n                gx--;\n            } else if(pat[i]=='2'){\n                gy++;\n            }\n            gy=max(0,gy);\n            gy=min(h-1,gy);\n            gx=max(0,gx);\n            gx=min(w-1,gx);\n            go++;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tqueue<int> q;\n\tint w,h,f[484],i,j,d[]={22,0,-1,0,1,0,-22},a,b,t,x,z;\n\tchar p[15];\n\tfor(;scanf(\"%d%d \",&h,&w),h;){\n\t\tfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tf[x=i*22+j]=-1;\n\t\t\t\tswitch(getchar()){\n\t\t\t\t\tcase'#':--f[x];break;\n\t\t\t\t\tcase'A':a=x;break;\n\t\t\t\t\tcase'B':b=x;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i*22]=f[i*22-~w]=-9;\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tf[a]=t=0;\n\t\tq.push(0);\n\t\tfor(q.push(a);q.size()>1;){\n\t\t\ta=q.front();\n\t\t\tq.pop();\n\t\t\tif(a){\n\t\t\t\tfor(i=0;i<7;i+=2)\n\t\t\t\t\tif(f[x=a+d[i]]==-1){\n\t\t\t\t\t\tf[x]=t;\n\t\t\t\t\t\tq.push(x);\n\t\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t++t;\n\t\t\t\tq.push(0);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t\tscanf(\"%s\",p);\n\t\tfor(a=t=0;!a;){\n\t\t\tx=b;\n\t\t\tz=0;\n\t\t\tfor(i=0;!a&&p[i];i++){\n\t\t\t\tt++;\n\t\t\t\tif(f[j=b+d[p[i]-'2']]>-3)b=j;\n\t\t\t\tif(f[b]>=0&&t>=f[b])a=b;\n\t\t\t\tif(f[b]>=0)z=1;\n\t\t\t}\n\t\t\tif(!z&&!a&&!p[i]&&b==x&&f[b]<0)a=-1;\n\t\t}\n\t\tprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <cstdio>\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nint h, w;\nstring s[20];\nint meY, meX;\nint gostY, gostX;\nstring moves;\n\nint minCost[20][20];\nint INF = 1000;\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid outAns() {\n\tint y = gostY;\n\tint x = gostX;\n\t\n\tfor (int i = 0; i < INF; i++) {\n\t\tif (minCost[y][x] <= i) {\n\t\t\tcout << i << \" \" << y << \" \" << x << endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tchar type = moves[i % moves.length()];\n\t\tchar *dir = \"8624\";\n\t\tint j;\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tif (dir[j] == type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == 4) continue;\n\t\t\n\t\t//?????? == j??§?§????\n\t\tint ny = y + dy[j];\n\t\tint nx = x + dx[j];\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w) {\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t}\n\tcout << \"impossible\" << endl;\n}\n\nint main() {\n\twhile (cin >> h >> w, h) {\n\t\tint i, j;\n\t\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'A') {\n\t\t\t\t\tmeY = i;\n\t\t\t\t\tmeX = j;\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'B') {\n\t\t\t\t\tgostY = i;\n\t\t\t\t\tgostX = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> moves;\n\t\t\n\t\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) minCost[i][j] = INF;\n\t\t\n\t\tqueue<T> que;\t//cst, y, x\n\t\tque.push(T(0, meY, meX));\n\t\twhile (!que.empty()) {\n\t\t\tT now = que.front(); que.pop();\n\t\t\tint cst = get<0>(now);\n\t\t\tint y = get<1>(now);\n\t\t\tint x = get<2>(now);\n\t\t\tif (minCost[y][x] <= cst) continue;\n\t\t\tminCost[y][x] = cst;\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\t\tif (s[ny][nx] == '#') continue;\n\t\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\t}\n\t\t}\n\t\t\n\t\toutAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<queue>\n#include<algorithm>\n#define INF 99999999\nusing namespace std;\nqueue <int> qy,qx,qcnt;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,x,y,cnt,nx,ny,mini,ansx,ansy;\nint t[20][20],sx,sy,tx,ty,vd[20][20];\nstring in;\nint main(){\n  while(cin>>n>>m&&n){\n    for(int i=0;i<n;i++){\n      cin>>in;\n      for(int j=0;j<(int)in.size();j++){\n\tif(in[j]=='A')sx=j,sy=i;\n\telse if(in[j]=='B')tx=j,ty=i;\n\tt[i][j]=(in[j]=='#');\n      }\n    }\n    \n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)vd[i][j]=INF;\n    vd[sy][sx]=1;\n    qx.push(sx);\n    qy.push(sy);\n    qcnt.push(1);\n    while(!qx.empty()){\n      x=qx.front();qx.pop();\n      y=qy.front();qy.pop();\n      cnt=qcnt.front();qcnt.pop();\n      for(int i=0;i<4;i++){\n\tnx=x+dx[i];ny=y+dy[i];\n\tif(!(0<=nx&&nx<m&&0<=ny&&ny<n))continue;\n\tif(vd[ny][nx]>0||t[ny][nx]==1)continue;\n\tvd[ny][nx]=cnt+1;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqcnt.push(cnt+1);\n      }\n    }\n    \n    cin>>in;\n    cnt=0;\n    mini=INF;\n\n    for(int I=0;I<n*m;I++){\n      for(int i=0;i<(int)in.size();i++){\n\tcnt++;\n\tif(cnt>=vd[ty][tx]){\n\t  if(mini>cnt){\n\t    mini=cnt;\n\t    ansy=ty;\n\t    ansx=tx;\n\t  }\n\t}\n\tif(in[i]=='5')continue;\n\telse if(in[i]=='8'){\n\t  if(ty==0)continue;\n\t  ty--;\n\t}else if(in[i]=='6'){\n\t  if(tx==m-1)continue;\n\t  tx++;\n\t}else if(in[i]=='4'){\n\t  if(tx==0)continue;\n\t  tx--;\n\t}else{\n\t  if(ty==n-1)continue;\n\t  ty++;\n\t}\n      }//for\n    }//while\n    if(mini==INF)cout<<\"impossible\"<<endl;\n    else cout<<mini-1<<' '<<ansy<<' '<<ansx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n\n#define pb push_back\n#define mp make_pair\n#define contains(c, x) (c).find(x) != (c).end()\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\nint h, w;\nvector<string> grid(21);\nstring pattern;\nint g[21][21];\n\nint dx[5] = { 0, -1, 0, 0, 1 };\nint dy[5] = { 0, 0, -1, 1, 0 };\n\nint p2i(int Time)\n{\n\tswitch (pattern[Time % pattern.size()] - '0') {\n\t\tcase 5: return 0;\n\t\tcase 8: return 2;\n\t\tcase 6: return 4;\n\t\tcase 4: return 1;\n\t\tcase 2: return 3;\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> h >> w; if (h == 0 && w == 0) break;\n\t\trep(i, h) cin >> grid[i];\n\t\tcin >> pattern;\n\t\t\n\t\tpair<int, int> a, b;\n\t\trep(i, h) rep(j, w)\n\t\t\tif (grid[i][j] == 'A') a = mp(i, j);\n\t\t\telse if (grid[i][j] == 'B') b = mp(i, j);\n\n\t\trep(i, h) rep(j, w) g[i][j] = -1;\n\t\tqueue<pair<int, int> > q;\n\t\tmap<pair<int, int>, int> m;\n\t\tq.push(a);\n\t\tm[a] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> t = q.front(); q.pop();\n\t\t\tg[t.first][t.second] = m[t];\n\t\t\trep(i, 5) {\n\t\t\t\tint dr = t.first + dy[i];\n\t\t\t\tint dc = t.second + dx[i];\n\t\t\t\tpair<int, int> next = mp(dr, dc);\n\t\t\t\tif (dr < 0 || dr >= h || dc < 0 || dc >= w) continue;\n\t\t\t\tif (grid[dr][dc] == '#' || contains(m, next)) continue;\n\t\t\t\tq.push(next);\n\t\t\t\tm[next] = m[t] + 1;\n\t\t\t}\n\t\t}\n\t\tint T = 1;\n\t\tpair<int, int> prev = b;\n\t\twhile (true) {\n\t\t\trep(i, pattern.size()) {\n\t\t\t\tint k = p2i(T-1);\n\t\t\t\tint br = b.first + dy[k];\n\t\t\t\tint bc = b.second + dx[k];\n\t\t\t\tif (0 <= br && br < h && 0 <= bc && bc < w)\n\t\t\t\t\tb = mp(b.first + dy[k], b.second + dx[k]);\n\t\t\t\tbr = b.first;\n\t\t\t\tbc = b.second;\n\t\t\t\tif (g[br][bc] >= 0 && g[br][bc] <= T) {\n\t\t\t\t\tcout << max(g[br][bc], T) << \" \" << br << \" \" << bc << endl;\n\t\t\t\t\tgoto CONTINUE;\n\t\t\t\t}\n\t\t\t\tT++;\n\t\t\t}\n\t\t\tif (prev == b && g[b.first][b.second] == -1) break;\n\t\t\tprev = b;\n\t\t}\n\t\tcout << \"impossible\" << endl;\nCONTINUE:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nstruct Place{ int x,y; };\nstruct State\n{\n    Place h,g;\n    int p;\n};\n\nconst int INF=123456789;\nint z[20][20][20][20][10];\ninline void init()\n{\n    rep(a,20)rep(b,20)rep(c,20)rep(d,20)rep(e,10) z[a][b][c][d][e]=INF;\n}\n\nint dx[5]={1,-1,0,0,0}, dy[5]={0,0,1,-1,0};\n\nint main()\n{\n    int h,w;\n    while(cin >>h >>w,h)\n    {\n        vector<string> s(h);\n        rep(i,h) cin >>s[i];\n\n        string pattern;\n        cin >>pattern;\n        int P=pattern.size();\n        vector<int> pat(P);\n        rep(i,P)\n        {\n            if(pattern[i]=='6') pat[i]=0;\n            else if(pattern[i]=='4') pat[i]=1;\n            else if(pattern[i]=='2') pat[i]=2;\n            else if(pattern[i]=='8') pat[i]=3;\n            else if(pattern[i]=='5') pat[i]=4;\n        }\n\n        Place a,b;\n        rep(i,h)rep(j,w)\n        {\n            if(s[i][j]=='A') a=Place{j,i};\n            if(s[i][j]=='B') b=Place{j,i};\n        }\n\n        init();\n        z[a.y][a.x][b.y][b.x][0]=0;\n        queue<State> que;\n        que.push(State{a,b,0});\n        #define IN(x,y) (0<=x && x<w && 0<=y && y<h)\n        while(!que.empty())\n        {\n            State now=que.front(); que.pop();\n            a=now.h;\n            b=now.g;\n            int idx=now.p;\n            int nowZ=z[a.y][a.x][b.y][b.x][idx];\n\n            // ???????????????\n            int nbx=b.x+dx[pat[idx]], nby=b.y+dy[pat[idx]];\n            if(!IN(nbx,nby))\n            {\n                nbx=b.x;\n                nby=b.y;\n            }\n            Place nb=Place{nbx,nby};\n            int nidx=(idx+1)%P;\n\n            // ????????????\n            rep(i,5)\n            {\n                int nax=a.x+dx[i], nay=a.y+dy[i];\n                if(IN(nax,nay) && s[nay][nax]!='#' && z[nay][nax][nby][nbx][nidx] > nowZ+1)\n                {\n                    z[nay][nax][nby][nbx][nidx] = nowZ+1;\n                    Place na=Place{nax,nay};\n                    que.push(State{na,nb,nidx});\n                }\n            }\n        }\n\n        int ans=INF,ax=-1,ay=-1;\n        rep(i,h)rep(j,w)rep(k,P)\n        {\n            if(ans>z[i][j][i][j][k])\n            {\n                ans=z[i][j][i][j][k];\n                ax=j;\n                ay=i;\n            }\n        }\n\n        if(ans==INF) printf(\"impossible\\n\");\n        else printf(\"%d %d %d\\n\", ans,ay,ax);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\nint m = 999999;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;;j++,go++){\n            int i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>10000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\nint m = 99999;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;;j++,go++){\n            int i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>100000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cctype>\n#include <limits.h>\n#include <math.h>\n#include <complex>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define BINARY(x) static_cast<bitset<16> >(x);\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n#define if_range(x, y, w, h) if (0<=(int)(x) && (int)(x)<(int)(w) && 0<=(int)(y) && (int)(y)<(int)(h))\n\nconst int INF = 1000000000;\nconst double EPS = 1e-8;\nconst double PI = 3.14159;\n//int dx[4]={-1, 0, 1, 0}, dy[4]={0, -1, 0, 1};\nusing namespace std;\n//typedef pair<int, int> P;\n\n/** Problem1046 : Ghost Buster! **/\nint dx[]={-1, 0, 1, 0, 0}, dy[]={0, -1, 0, 1, 0};\n\nint W, H;\nstring s;\n\nstruct P {\n\tint x, y;\n\tP(){}\n\tP(int _x, int _y) : x(_x), y(_y) {}\n};\n\nstruct S {\n\tP p;\n\tint time;\n\tS(){}\n\tS(P _p, int _time) : p(_p), time(_time) {}\n};\n\ntypedef pair<S, S> SS;\n\nint main()\n{\n\t\n\twhile (cin>>H>>W, W||H) {\n\t\tchar field[20][20];\n\t\t\n\t\tS A, B;\n\t\t\n\t\trep(i, H) rep(j, W) {\n\t\t\tcin>>field[i][j];\n\t\t\tif (field[i][j] == 'A')\n\t\t\t\tA = S(P(j, i), 0);\n\t\t\telse if (field[i][j] == 'B')\n\t\t\t\tB = S(P(j, i), 0);\n\t\t}\n\t\tcin>>s;\n\t\tint N = (int)s.size();\n\t\t\n\t\tqueue<SS> Q;\n\t\tbool vis[H][W][H][W][10];\n\t\tmemset(vis, 0, sizeof(vis));\n\t\t\n\t\tQ.push(SS(A, B));\n\t\tvis[A.p.y][A.p.x][B.p.y][B.p.x][0] = true;\n\t\t\n\t\twhile (Q.size()) {\n\t\t\tSS ss = Q.front(); Q.pop();\n\t\t\tS a = ss.first, b = ss.second;\n\n\t\t\t//cerr << \"(\" << a.p.x << \", \" << a.p.y << \")\" << \" \";\n\t\t\t//cerr << \"(\" << b.p.x << \", \" << b.p.y << \")\" << \" \" << a.time << endl;\n\t\t\t\n\t\t\tif (a.p.x == b.p.x && a.p.y == b.p.y) {\n\t\t\t\tcout << a.time << \" \" << a.p.y << \" \" << a.p.x << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t// Move Ghost\n\t\t\tif (s[b.time%N] == '8' && b.p.y>0)\n\t\t\t\tb.p.y--;\n\t\t\telse if (s[b.time%N] == '6' && b.p.x<W-1)\n\t\t\t\tb.p.x++;\n\t\t\telse if (s[b.time%N] == '4' && b.p.x>0)\n\t\t\t\tb.p.x--;\n\t\t\telse if (s[b.time%N] == '2' && b.p.y<H-1)\n\t\t\t\tb.p.y++;\n\t\t\tb.time++;\n\t\t\t\n\t\t\t// Move Girl\n\t\t\ta.time++;\n\t\t\trep(i, 5) {\n\t\t\t\tint nx = a.p.x + dx[i], ny = a.p.y + dy[i];\n\t\t\t\tif_range(nx, ny, W, H) {\n\t\t\t\t\tif (!vis[ny][nx][b.p.y][b.p.x][a.time%N] && field[ny][nx] != '#') {\n\t\t\t\t\t\tQ.push(SS(S(P(nx, ny), a.time), b));\n\t\t\t\t\t\tvis[ny][nx][b.p.y][b.p.x][a.time%N] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (!vis[a.p.y][a.p.x][b.p.y][b.p.x][b.time%N]) {\n\t\t\t\tQ.push(SS(a, b));\n\t\t\t\tvis[a.p.y][a.p.x][b.p.y][b.p.x][b.time%N] = true;\n\t\t\t}\n\t\t}\n\t\tcout << \"impossible\" << endl;\n\tend:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<list>\n#include<set>\nusing namespace std;\n#define fr first\n#define sc second\n#define INFTY 1000000\ntypedef pair< int,int > Pt;\ntypedef pair< pair<Pt,Pt>,int > P;\nPt A,B;\nint h,w,dx[]={0,1,0,-1,0},dy[]={1,0,-1,0,0};\nchar mas[20][20];\nint used[20][20][20][20][11];\nstring pattern;\npair<int,Pt> bfs();\nbool judge(int,int);\nint main(){\n  while(cin >> h >> w && h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'A') A = Pt(i,j);\n        else if(mas[i][j] == 'B') B = Pt(i,j);\n      }\n    }\n    cin >> pattern;\n    pair<int,Pt> ans = bfs();\n    if(ans.fr == -1) cout << \"impossible\" << endl;\n    else cout << ans.fr << \" \" << ans.sc.fr << \" \" << ans.sc.sc << endl;\n  }\n}\npair<int,Pt> bfs(){\n  map<char,int> tmp;\n  tmp['5'] = 4,tmp['8'] = 3,tmp['6'] = 0,tmp['4'] = 2,tmp['2'] = 1;\n  queue<P> que;\n  memset(used,-1,sizeof(used));\n  que.push(P(make_pair(A,B),-1));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    if(p.fr.fr == p.fr.sc){\n      return (make_pair(used[p.fr.fr.fr][p.fr.fr.sc][p.fr.sc.fr][p.fr.sc.sc][p.sc],Pt(p.fr.fr.fr,p.fr.fr.sc)));\n    }\n    int cnt = (p.sc + 1) % pattern.size();\n    int bx = p.fr.sc.fr + dx[tmp[pattern[cnt]]];\n    int by = p.fr.sc.sc + dy[tmp[pattern[cnt]]];\n    if(!judge(bx,by)) bx = p.fr.sc.fr , by = p.fr.sc.sc;\n    for(int i=0;i<5;i++){\n      int ax = p.fr.fr.fr + dx[i] , ay = p.fr.fr.sc + dy[i];\n      if(!judge(ax,ay) || mas[ax][ay] == '#') ax = p.fr.fr.fr , ay = p.fr.fr.sc;\n      if(used[ax][ay][bx][by][cnt] == -1){\n        que.push(P(make_pair(Pt(ax,ay),Pt(bx,by)),cnt));\n        used[ax][ay][bx][by][cnt] = used[p.fr.fr.fr][p.fr.fr.sc][p.fr.sc.fr][p.fr.sc.sc][p.sc] + 1;\n      }\n    }\n  }\n  return make_pair(-1,Pt(0,0));\n}\nbool judge(int x,int y){\n  return (x >= 0 && x < h && y >= 0 && y < w ? true : false);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <cstdio>\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nint h, w;\nstring s[20];\nint meY, meX;\nint gostY, gostX;\nstring moves;\n\nint minCost[20][20];\nint INF = 1000;\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid outAns() {\n\tint y = gostY;\n\tint x = gostX;\n\t\n\tfor (int i = 0; i < INF; i++) {\n\t\tif (minCost[y][x] <= i) {\n\t\t\tcout << i << \" \" << y << \" \" << x << endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tchar type = moves[i % moves.length()];\n\t\tstring dir = \"8624\";\n\t\tint j;\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tif (dir[j] == type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == 4) continue;\n\t\t\n\t\t//?????? == j??§?§????\n\t\tint ny = y + dy[j];\n\t\tint nx = x + dx[j];\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w) {\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t}\n\tcout << \"impossible\" << endl;\n}\n\nint main() {\n\twhile (cin >> h >> w, h) {\n\t\tint i, j;\n\t\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'A') {\n\t\t\t\t\tmeY = i;\n\t\t\t\t\tmeX = j;\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'B') {\n\t\t\t\t\tgostY = i;\n\t\t\t\t\tgostX = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> moves;\n\t\t\n\t\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) minCost[i][j] = INF;\n\t\t\n\t\tqueue<T> que;\t//cst, y, x\n\t\tque.push(T(0, meY, meX));\n\t\twhile (!que.empty()) {\n\t\t\tT now = que.front(); que.pop();\n\t\t\tint cst = get<0>(now);\n\t\t\tint y = get<1>(now);\n\t\t\tint x = get<2>(now);\n\t\t\tif (minCost[y][x] <= cst) continue;\n\t\t\tminCost[y][x] = cst;\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\t\tif (s[ny][nx] == '#') continue;\n\t\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\t}\n\t\t}\n\t\t\n\t\toutAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint t[20][20];\nconst int inf = 1000;\nvoid solve(int sum, int i, int j, int h, int w, char t2[20][20]) {\n\tif (i + 1 < h&&t2[i + 1][j] == '.'&&t[i+1][j]>sum+1) {\n\t\tt[i + 1][j] = sum + 1;\n\t\tsolve(sum + 1, i + 1, j, h, w, t2);\n\t}\n\tif (i - 1 >= 0 && t2[i - 1][j] == '.'&&t[i-1][j]>sum+1) {\n\t\tt[i - 1][j] = sum + 1;\n\t\tsolve(sum + 1, i - 1, j, h, w, t2);\n\t}\n\tif (j + 1 < w&&t2[i][j + 1] == '.'&&t[i][j+1]>sum+1) {\n\t\tt[i][j + 1] = sum + 1;\n\t\tsolve(sum + 1, i, j + 1, h, w, t2);\n\t}\n\tif (j - 1 >= 0 && t2[i][j - 1] == '.'&&t[i][j-1]>sum+1) {\n\t\tt[i][j - 1] = sum + 1;\n\t\tsolve(sum + 1, i, j - 1, h, w, t2);\n\t}\n}\nint main() {\n\tint h, w;\n\tchar t2[20][20];\n\tint t3[20][20][10];\n\twhile (cin >> h >> w&&h != 0 && w != 0) {\n\t\tstring u;\n\t\tint p[2];\n\t\tint g[2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> u;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tt2[i][j] = u[j];\n\t\t\t\tif (u[j] == 'A') {\n\t\t\t\t\tp[0] = i;\n\t\t\t\t\tp[1] = j;\n\t\t\t\t}\n\t\t\t\tif (u[j] == 'B') {\n\t\t\t\t\tg[0] = i;\n\t\t\t\t\tg[1] = j;\n\t\t\t\t}\n\t\t\t\tt[i][j] = inf;\n\t\t\t\tfor (int z = 0; z < 10; z++) t3[i][j][z] = 0;\n\t\t\t}\n\t\t}\n\t\tstring a;\n\t\tcin >> a;\n\t\tint b[10][2];\n\t\tfor (int i = 0; i < a.length(); i++) {\n\t\t\tswitch (a[i])\n\t\t\t{\n\t\t\tcase '5':\n\t\t\t\tb[i][0] = 0;\n\t\t\t\tb[i][1] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tb[i][0] = -1;\n\t\t\t\tb[i][1] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\tb[i][0] = 0;\n\t\t\t\tb[i][1] = 1;\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tb[i][0] = 0;\n\t\t\t\tb[i][1] = -1;\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tb[i][0] = 1;\n\t\t\t\tb[i][1] = 0;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tt[p[0]][p[1]] = 0;\n\t\tt2[g[0]][g[1]] = '.';\n\t\tint sum2 = 0;\n\t\tbool l = false;\n\t\tsolve(0, p[0], p[1], h, w, t2);\n\t\tint k = 0, x = g[0], y = g[1], sum = 0;\n\t\twhile (true) {\n\t\t\tx += b[k][0];\n\t\t\ty += b[k][1];\n\t\t\tk++;\n\t\t\tsum++;\n\t\t\tif (k >= a.length()) k = 0;\n\t\t\tx = max(0, min(x, h - 1));\n\t\t\ty = max(0, min(y, w - 1));\n\t\t\tif (t[x][y] <= sum) {\n\t\t\t\tcout << sum << \" \" << x << \" \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t3[x][y][k] == 1&&!l) {\n\t\t\t\tsum2 = 0;\n\t\t\t\tl = true;\n\t\t\t}\n\t\t\tif (t3[x][y][k] == 2) {\n\t\t\t\tif (sum2 == 0) {\n\t\t\t\t\tcout << \"impossible\" << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l&&t[x][y]!=inf) {\n\t\t\t\tsum2++;\n\t\t\t}\n\t\t\tt3[x][y][k]++;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct node{\n    int y,x,t,cost;\n    node(int y,int x,int t,int cost):y(y),x(x),t(t),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\n\nconst int MAX=INT_MAX/10;\ntypedef vector<vvi> vvvi;\nint dx[]={-1,0,1,0,0},dy[]={0,-1,0,1,0};\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        vvi field(n,vi(m));\n\t\tpii girl,ghost;\n        REP(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tREP(j,s.size()){\n\t\t\t\tswitch(s[j]){\n\t\t\t\tcase 'A':\n\t\t\t\t\tgirl=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tghost=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(0);\n\t\t\t\t}\n\t\t\t}\n        }\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tint len=pattern.size()*20*20;\n\n\t\tvector<pii> glocs;\n\t\tREP(i,len){\n\t\t\tglocs.push_back(ghost);\n\t\t\tswitch(pattern[i%pattern.size()]){\n\t\t\tcase '2':\n\t\t\t\tif(ghost.first<n-1)ghost.first++;break;\n\t\t\tcase '4':\n\t\t\t\tif(ghost.second>0)ghost.second--;break;\n\t\t\tcase '8':\n\t\t\t\tif(ghost.first>0)ghost.first--;break;\n\t\t\tcase '6':\n\t\t\t\tif(ghost.second<m-1)ghost.second++;break;\n\t\t\tcase '5':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n        \n        priority_queue<node> q;\n\t\tq.push(node(girl.first,girl.second,0,0));\n        vvvi cost(n,vvi(m,vi(len,MAX)));\n\t\tcost[girl.first][girl.second][0]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.y][cnode.x][cnode.t]<cnode.cost){\n                continue;\n            }\n\t\t\tREP(i,5){\n\t\t\t\tint x=cnode.x+dx[i];\n\t\t\t\tint y=cnode.y+dy[i];\n\t\t\t\tif(x>=0&&y>=0&&x<m&&y<n&&field[y][x]==0){\n\t\t\t\t\tint newcost=cnode.cost+1;\n\t\t\t\t\tint t=cnode.t+1;\n\t\t\t\t\tif(t<len&&cost[y][x][t]>newcost){\n\t\t\t\t\t\tcost[y][x][t]=newcost;\n\t\t\t\t\t\tq.push(node(y,x,t,newcost));\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tint ans=MAX;\n\t\tpii ansloc;\n\t\tREP(i,len){\n\t\t\tint c=cost[glocs[i].first][glocs[i].second][i];\n\t\t\tif(c<ans){\n\t\t\t\tans=c;\n\t\t\t\tansloc=glocs[i];\n\t\t\t}\n\t\t}\n\t\tif(ans==MAX){\n\t\t\tcout<<\"impossible\"<<endl;\n\t\t}else{\n\t\t\tcout<<ans<<\" \"<<ansloc.first<<\" \"<<ansloc.second<<endl;\n\t\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<PP,int> State;\n\n// 入力\nint w, h;\nstring s[20], p;\n\n// d[ay][ax][by][bx][i] := (ax,ay),(bx,by),i分目のときの手数\n// 5次元配列とかやばすぎ.\nint d[20][20][20][20][10];\n\nint dx[256] = {0,0,-1,1};\nint dy[256] = {-1,1,0,0};\n\nvoid debug(int ax, int ay, int bx, int by, int t){\n\tcout << \"[debug]\" << \" t:\" << t << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( x == ax && y == ay ){\n\t\t\t\tcout << \"A\";\n\t\t\t}else if( x == bx && y == by ){\n\t\t\t\tcout << \"B\";\n\t\t\t}else{\n\t\t\t\tcout << s[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// 初期化 \nvoid ini(){\n\tfor(int ay=0 ; ay < h ; ay++ ){\n\t\tfor(int ax=0 ; ax < w ; ax++ ){\n\t\t\tfor(int by=0 ; by < h ; by++ ){\n\t\t\t\tfor(int bx=0 ; bx < w ; bx++ ){\n\t\t\t\t\tfor(int i=0 ; i < p.size() ; i++ ){\n\t\t\t\t\t\td[ay][ax][by][bx][i] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 幅優先探索.\npair<int,P> bfs(int ax, int ay, int bx, int by){\n\tqueue<State> q;\n\tPP pp(P(ax,ay),P(bx,by));\n\tq.push( State( pp , 0 ) );\n\td[ay][ax][by][bx][0] = 0;\n\tini();\n\t\n\twhile( !q.empty() ){\n\t\tint ax = q.front().first.first.first;\n\t\tint ay = q.front().first.first.second;\n\t\tint bx = q.front().first.second.first;\n\t\tint by = q.front().first.second.second;\n\t\tint t  = q.front().second;\n\t\tq.pop();\n\t\t//debug(ax,ay,bx,by,t);\n\t\t\n\t\tint bx_ = bx + dx[p[t % p.size()]];\n\t\tint by_ = by + dy[p[t % p.size()]];\n\t\tif( bx_ < 0 || w <= bx_ ) bx_ = bx;\n\t\tif( by_ < 0 || h <= by_ ) by_ = by;\n\t\tP b(bx_,by_);\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint ax_ = ax + dx[i];\n\t\t\tint ay_ = ay + dy[i];\n\t\t\tif( ax_ < 0 || w <= ax_ ) ax_ = ax;\n\t\t\tif( ay_ < 0 || h <= ay_ ) ay_ = ay;\n\t\t\tif( s[ay_][ax_] == '#' ){\n\t\t\t\tax_ = ax; ay_ = ay;\n\t\t\t}\n\t\t\tP a(ax_,ay_);\n\t\t\t\n\t\t\tif( a == b ){ // ゴールの時\n\t\t\t\treturn pair<int,P>(t+1,a);\n\t\t\t}else if( d[ay_][ax_][by_][bx_][(t+1) % p.size()] == INF ){\n\t\t\t\td[ay_][ax_][by_][bx_][(t+1) % p.size()] = t+1;\n\t\t\t\tPP pp(P(ax_,ay_),P(bx_,by_));\n\t\t\t\tq.push( State( pp , t+1 ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn pair<int,P>(-1,P(0,0));\n}\n\nint main(){\n\tdx['6'] = 1; dx['4'] = -1; dy['8'] = -1; dy['2'] = 1;\n\t\n\twhile( cin >> h >> w , h || w ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> s[y];\n\t\t}\n\t\tcin >> p;\n\t\t\n\t\tint ax, ay, bx, by;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] == 'A' ){\n\t\t\t\t\tax = x; ay = y; s[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif( s[y][x] == 'B' ){\n\t\t\t\t\tbx = x; by = y; s[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpair<int,P> ans = bfs(ax, ay, bx, by);\n\t\tif( ans.first == -1 ){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}else{\n\t\t\tcout << ans.first << \" \";\n\t\t\tcout << ans.second.second << \" \";\n\t\t\tcout << ans.second.first << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[0][0] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 10000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w) {\n\t\t\t\t\tx = nx; y = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int dx[4] = {1,-1,0,0};\nconst int dy[4] = {0,0,1,-1};\n\nconst int gdx[10] = {\n  0,\n  0,0,0,\n  -1,0,1,\n  0,0,0\n};\n\nconst int gdy[10] = {\n  0,\n  0,1,0,\n  0,0,0,\n  0,-1,0\n};\n\nint main(){\n  int h,w;\n  while(scanf(\"%d%d \",&h,&w), h+w){\n    char buff[h][w+3];\n    int dist[h][w];\n    int mx,my,gx,gy;\n\n    REP(i,h) fgets(buff[i],sizeof(buff[i]),stdin);\n    REP(i,h){\n      REP(j,w){\n        dist[i][j] = -1;\n        if(buff[i][j] == 'A'){\n          mx = j; my = i;\n          buff[i][j] = '.';\n        }else if(buff[i][j] == 'B'){\n          gx = j; gy = i;\n          buff[i][j] = '.';\n        }\n      }\n    }\n\n    queue<pair<int,int> > q;\n    q.push(mp(mx,my)); dist[mx][my]=0;\n    int last = 0;\n    while(!q.empty()){\n      int x = q.front().f;\n      int y = q.front().s;\n      q.pop();\n\n      REP(i,4){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(xx < 0 || yy < 0) continue;\n        if(xx >=w || yy >=h) continue;\n        if(buff[yy][xx] == '#') continue;\n        if(dist[yy][xx] != -1) continue;\n        dist[yy][xx] = dist[y][x] + 1;\n        q.push(mp(xx,yy));\n      }\n    }\n\n    //REP(i,h){ REP(j,w) printf(\"  %c\",buff[i][j]); puts(\"\");}\n    //REP(i,h){ REP(j,w) printf(\"%3d\",dist[i][j]); puts(\"\");}\n\n    char pat[20];\n    fgets(pat,sizeof(pat),stdin);\n    int plen = strlen(pat);\n    if(!isdigit(pat[plen-1])) plen--;\n    bool flag[h][w][plen]; memset(flag, 0, sizeof(flag));\n    int turn = 0;\n    while(true){\n      int pp = pat[turn % plen] - '0'; turn++;\n      int xx = gx + gdx[pp];\n      int yy = gy + gdy[pp];\n\n      if(xx < 0 || yy < 0 || xx >=w || yy >=h){\n        xx = gx; yy = gy;\n      }\n\n      //printf(\"goast: (%d,%d) pp=%d\\n\",xx,yy,pp);\n\n      if(dist[yy][xx] != -1 && dist[yy][xx] <= turn){\n        printf(\"%d %d %d\\n\",turn,yy,xx);\n        break;\n      }\n\n      if(flag[yy][xx][turn % plen]){\n        puts(\"impossible\");\n        break;\n      }\n\n      if(turn >= w * h)\n        flag[yy][xx][turn % plen] = true;\n\n      gx = xx; gy = yy;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pi;\n#define MAX 32\n#define fr first\n#define sc second\n\nconst int di[] = {-1,0,1,0};\nconst int dj[] = {0,1,0,-1};\nstatic const int di_sz = sizeof(di)/sizeof(*di);\n\ninline pi comp(pi p, int H, int W){\n  if(p.fr>=H)p.fr=H-1;\n  if(p.fr<0)p.fr=0;\n  if(p.sc>=W)p.sc=W-1;\n  if(p.sc<0)p.sc=0;\n  return p;\n}\n\nstruct ghost{\n  pi p;\n  ghost():p(0,0){}\n  ghost(pi p):p(p){}\n  void move(int ind, const string &pat, int H, int W){\n    pi next=p;\n    switch(pat[ind]){\n    case '5':return;break;\n    case '8':next.fr--;break;\n    case '6':next.sc++;break;\n    case '4':next.sc--;break;\n    case '2':next.fr++;break;\n    }\n    if(next.fr>=H)next.fr=H-1;\n    if(next.fr<0)next.fr=0;\n    if(next.sc>=W)next.sc=W-1;\n    if(next.sc<0)next.sc=0;\n    p = next;\n  }\n};\n\nstruct state{\n  int now;\n  pi girl;\n  vector<ghost> g;\n  bool operator<(const state &t)const{\n    if(now!=t.now)return now<t.now;\n    if(girl.fr!=t.girl.fr)return girl.fr<t.girl.fr;\n    if(girl.sc!=t.girl.sc)return girl.sc<t.girl.sc;\n    for(int i=0;i<g.size();++i){\n      if(g[i].p.fr!=t.g[i].p.fr)return g[i].p.fr<t.g[i].p.fr;\n      if(g[i].p.sc!=t.g[i].p.sc)return g[i].p.sc<t.g[i].p.sc;\n    }\n    return false;\n  }\n};\n\nint bfs(state init, int H, int W, char M[][MAX], const string &pat, pi &ans_pos){\n  map<state,int> vis;\n  queue<state> qs;\n  vis[init]=0;\n  qs.push(init);\n\n  while(!qs.empty()){\n    state nst = qs.front(); qs.pop();\n    int ns = vis[nst];\n\n    for(int i = 0; i < nst.g.size(); ++i){\n      if( nst.girl.fr == nst.g[i].p.fr && nst.girl.sc == nst.g[i].p.sc ){\n\tans_pos = nst.girl;\n\treturn ns;\n      }\n    }\n\n    for(int k = 0; k < di_sz; ++k){\n      state Next=nst;\n      pi next(nst.girl.fr+di[k], nst.girl.sc+dj[k]);\n      next =comp(next,H,W);\n      if(M[next.fr][next.sc]=='#')next=nst.girl;\n      Next.girl = next;\n    \n      // move ghosts;\n      for(int i = 0; i < nst.g.size(); ++i){\n\tNext.g[i].move( nst.now, pat, H, W );\n      }\n      Next.now++;\n      if(Next.now>=pat.length()){\n\tNext.now=0;\n      }\n      \n      if( vis.find(Next) == vis.end() ){\n\tvis[Next]=ns+1;\n\tqs.push(Next);\n      }else if( vis[Next] > ns+1 ){\n\tvis[Next]=ns+1;\n\tqs.push(Next);\n      }\n    }\n\n  }\n  return -1;\n}\n\n\nint main()\n{\n  while(true){\n    int H,W;\n    string pat;\n    state init;\n    char M[MAX][MAX] = {{0,},};\n    cin >> H >> W;\n    if( H == 0 && W == 0 )break;\n    \n    for(int i = 0; i < H; ++i){\n      for(int j = 0; j < W; ++j){\n\tchar c; cin >> c;\n\tif( c == 'A'){\n\t  init.girl = make_pair(i,j);\n\t  M[i][j]='.';\n\t}else if( c == 'B'){\n\t  init.g.push_back( ghost(make_pair(i,j) ) );\n\t  M[i][j]='.';\n\t}else{\n\t  M[i][j]=c;\n\t}\n      }\n    }\n    init.now=0;\n    cin >> pat;\n    pi ans_pos;\n    int ans_step = bfs(init,H,W,M,pat,ans_pos);\n    if( ans_step >= 0 ){\n      cout << ans_step << ' ' << ans_pos.fr << ' ' << ans_pos.sc << endl;\n    }else{\n      cout << \"impossible\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int ,int > P;\ntypedef pair<int, P> P2;\n\nbool v[30][30],vb[30][30][20];\nstring g[30],L;\nint h,w,s;\nint ay,ax,by,bx;\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++)cin >> g[i];\n    cin >> L;\n    s = L.size();\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == 'A'){\n\t  g[i][j] == '.';\n\t  ay = i; ax = j;\n\t}\n\tif(g[i][j] == 'B'){\n\t  g[i][j] == '.';\n\t  by = i; bx = j;\n\t}\n\tv[i][j] = false;\n\tfor(int k=0;k<s;k++)vb[i][j][k] = false;\n      }\n\n    int t = 0;\n    queue<P2> q;\n    q.push(P2(0,P(ay,ax)));\n\n    while(!q.empty()){\n      P2 p = q.front();q.pop();\n      /*\n      cout << \"[\" << p.first << \" \" << p.second.first << \" \" << p.second.second << \"]\" << endl;\n      cout << by << \" \" << bx << endl;\n      */\n      if(p.first==t+1){\n\tvb[by][bx][t%s] = true;\n\tif(v[by][bx])break;\n\tif(L[t%s] == '8' && 0<by)by--;\n\tif(L[t%s] == '6' && bx<w-1)bx++;\n\tif(L[t%s] == '2' && by<h-1)by++;\n\tif(L[t%s] == '4' && 0<bx)bx--;\n\tt++;\n      }\n\n      v[p.second.first][p.second.second] = true;\n\n      int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n      for(int i=0;i<4;i++){\n\tint sy = p.second.first + dy[i] , sx = p.second.second + dx[i];\n\tif(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\tif(v[sy][sx] || g[sy][sx]=='#')continue;\n\tq.push(P2(p.first+1,P(sy,sx)));\n      }\n    }\n\n    if(v[by][bx])cout << t << \" \" << by << \" \" << bx << endl;\n    else {\n      for(int i=0;;i++){\n\tif(vb[by][bx][(t+i)%s]){\n\t  //cout << t+i << endl;\n\t  cout << \"impossible\\n\";\n\t  break;\n\t}\n\tvb[by][bx][(t+i)%s] = true;\n\tif(L[(t+i)%s] == '2' && 0<by)by--;\n\tif(L[(t+i)%s] == '6' && bx<w-1)bx++;\n\tif(L[(t+i)%s] == '8' && by<h-1)by++;\n\tif(L[(t+i)%s] == '4' && 0<bx)bx--;\n\tif(v[by][bx]){\n\t  cout << t+i+1 << \" \" << by << \" \" << bx << endl;\n\t  break;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\nstruct po{int x,y,dis;};\nint h,w;\nstring mp[20],str;\nint D[21][21];\n\nvoid bfs(po s){\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) D[i][j] = 10000000;\n  D[s.y][s.x] = 0;\n  queue<po> Q;\n  Q.push((po){s.x,s.y,0});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    int dx[]={0,0,-1,1};\n    int dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx = t.x+dx[i];\n      int ny = t.y+dy[i];\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!='.'||D[ny][nx]<=t.dis+1)continue;\n      Q.push((po){nx,ny,t.dis+1});\n      D[ny][nx]=t.dis+1;\n    }\n  }\n}\n\nvoid move(po s){\n  po ima,ans;\n  ima.x=s.x,ima.y=s.y;\n  if(D[ima.y][ima.x]==0)ans.x=ima.x,ans.y=ima.y,ans.dis=0;\n  else ans.dis = 10000000;\n  int visited[21][21]={};\n  int dx[]={0,-1,1,0};\n  int dy[]={1,0,0,-1};\n  int cnt=0;\n  while(1){\n    visited[ima.y][ima.x]=1;\n    for(int i=0;i<str.size();i++){\n      cnt++;\n      int j = (str[i]-'0')/2-1;\n      int nx=ima.x+dx[j];\n      int ny=ima.y+dy[j];\n      if(nx<0||ny<0||nx>=w||ny>=h||str[i]=='5')nx=ima.x,ny=ima.y;\n      ima.x=nx,ima.y=ny;\n      if(ans.dis>cnt&&cnt>D[ny][nx]) ans.x=ima.x,ans.y=ima.y,ans.dis=cnt;\n    }\n    if(cnt>5000)break;\n  }\n  if(ans.dis==10000000) cout <<\"impossible\"<<endl;\n  else cout<< ans.dis<<\" \" << ans.y <<\" \"<< ans.x<<endl;\n}\n \n\nint main() {\n\n  while(1){\n    cin >> h >> w;\n    if(h==0 && w==0)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n    cin>> str;\n    \n    po A,B;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[i][j] == 'A') A.y=i ,A.x=j;\n\tif(mp[i][j]=='B') B.y=i,B.x=j;\n      }\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(mp[i][j] == 'A'||mp[i][j]=='B') mp[i][j] = '.';\n  \n    bfs(A);\n    move(B);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[0][0] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 100000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint h,w;\nchar field[21][21];\n\nconst int INF=100000000;\n\n// INFÈç­ªBÅ«È¢\nint minArrivalCost[21][21];\n// HìÌÚ®[gði[\nvector<pair<int,int> > ghostPath;\n// HìªÊßµ½êði[\nbool passedGhost[11][21][21];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\n// ­ªe}XÖ½Çè­½ßÌÅ¬RXgðßé\nvoid bfs(int sx,int sy){\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> > ();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> > ();\n\tprv->push(make_pair(sy,sx));\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tpassed[i][j]=false;\n\t\t}\n\t}\n\tint cnt=0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp=prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\tminArrivalCost[cp.first][cp.second]=min(minArrivalCost[cp.first][cp.second],cnt);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tnp.first+=dy[i];\n\t\t\t\tnp.second+=dx[i];\n\t\t\t\tif(np.first>=0&&np.second>=0&&np.first<h&&np.second<w){\n\t\t\t\t\tif(!passed[np.first][np.second]&&field[np.first][np.second]!='#'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\n\tdelete prv,nxt;\n}\n\nint searchGhost(pair<int,int> cp,int tern,string pattern,pair<int,int> sp){\n\t// 500ñ®¢Äàoï¦È¢ÈçÎA-1ðÔ·B»¤ÅÈ¯êÎAoï¦éÅ¬^[ðÔ·\n\tint cnt=-1;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < pattern.size(); i++){\n\t\t\tcnt++;\n\t\t\tif(cnt==100)\n\t\t\t\treturn -1;\n\t\t\t// ­ÌÊuÉBµ½ê\n\t\t\tif(sp==cp){\n\t\t\t\tif(tern<=cnt){\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar c = pattern[i];\n\t\t\tpair<int,int> np=cp;\n\t\t\t\n\t\t\tif(c=='8')\n\t\t\t\tnp.first-=1;\n\t\t\telse if(c=='6')\n\t\t\t\tnp.second+=1;\n\t\t\telse if(c=='4')\n\t\t\t\tnp.second-=1;\n\t\t\telse if(c=='2')\n\t\t\t\tnp.first++;\n\t\t\t\n\t\t\tif(np.first<0)\n\t\t\t\tnp.first=0;\n\t\t\telse if(np.first>=h)\n\t\t\t\tnp.first=h-1;\n\t\t\telse if(np.second>=w)\n\t\t\t\tnp.second=w-1;\n\t\t\telse if(np.second<0)\n\t\t\t\tnp.second=0;\n\t\t\tcp=np;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>h>>w&&!(h==0&&w==0)){\n\t\tghostPath.clear();\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 11; k++){\n\t\t\t\t\tpassedGhost[k][i][j]=false;\n\t\t\t\t}\n\t\t\t\tminArrivalCost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='A'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='B'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tbfs(sx,sy);\n\n\t\tpair<int,int> cp=make_pair(gy,gx);\n\t\tint minCost=INF;\n\t\tpair<int,int> rp;\n\t\t// eHìÌB|CgÉÂ¢ÄAÞªBÅ«Ä¢é©Ç¤©ðÝé\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcp=make_pair(i,j);\n\t\t\t\tint cst=minArrivalCost[cp.first][cp.second];\n\t\t\t\tif(cst!=INF){\n\t\t\t\t\tint r=searchGhost(make_pair(gy,gx),cst,pattern,cp);\n\t\t\t\t\tif(r!=-1){\n\t\t\t\t\t\tif(minCost>r){\n\t\t\t\t\t\t\tminCost=min(minCost,r);\n\t\t\t\t\t\t\trp=cp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost==INF)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse{\n\t\t\tcout<<minCost<<\" \"<<rp.first<<\" \"<<rp.second<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\ntypedef pair<int,int> P;\ntypedef pair<P,P> PP;\ntypedef pair<PP,int> State;\n\n// 入力\nint w, h;\nstring s[20], p;\n\n// d[ay][ax][by][bx][i] := (ax,ay),(bx,by),i分目のときの手数\n// 5次元配列とかやばすぎ.\nint d[20][20][20][20][10];\n\nint dx[256] = {0,0,-1,1};\nint dy[256] = {-1,1,0,0};\n\nvoid debug(int ax, int ay, int bx, int by, int t){\n\tcout << \"[debug]\" << \" t:\" << t << endl;\n\tfor(int y=0 ; y < h ; y++ ){\n\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\tif( x == ax && y == ay ){\n\t\t\t\tcout << \"A\";\n\t\t\t}else if( x == bx && y == by ){\n\t\t\t\tcout << \"B\";\n\t\t\t}else{\n\t\t\t\tcout << s[y][x];\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n}\n\n// 初期化 \nvoid ini(){\n\tfor(int ay=0 ; ay < h ; ay++ ){\n\t\tfor(int ax=0 ; ax < w ; ax++ ){\n\t\t\tfor(int by=0 ; by < h ; by++ ){\n\t\t\t\tfor(int bx=0 ; bx < w ; bx++ ){\n\t\t\t\t\tfor(int i=0 ; i < p.size() ; i++ ){\n\t\t\t\t\t\td[ay][ax][by][bx][i] = INF;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n// 幅優先探索.\npair<int,P> bfs(int ax, int ay, int bx, int by){\n\tqueue<State> q;\n\tPP pp(P(ax,ay),P(bx,by));\n\tq.push( State( pp , 0 ) );\n\td[ay][ax][by][bx][0] = 0;\n\tini();\n\t\n\twhile( !q.empty() ){\n\t\tint ax = q.front().first.first.first;\n\t\tint ay = q.front().first.first.second;\n\t\tint bx = q.front().first.second.first;\n\t\tint by = q.front().first.second.second;\n\t\tint t  = q.front().second;\n\t\tq.pop();\n\t\t//debug(ax,ay,bx,by,t);\n\t\t\n\t\tint bx_ = bx + dx[p[t % p.size()]];\n\t\tint by_ = by + dy[p[t % p.size()]];\n\t\tif( bx_ < 0 || w <= bx_ ) bx_ = bx;\n\t\tif( by_ < 0 || h <= by_ ) by_ = by;\n\t\tP b(bx_,by_);\n\t\tfor(int i=0 ; i < 4 ; i++ ){\n\t\t\tint ax_ = ax + dx[i];\n\t\t\tint ay_ = ay + dy[i];\n\t\t\tif( ax_ < 0 || w <= ax_ ) ax_ = ax;\n\t\t\tif( ay_ < 0 || h <= ay_ ) ay_ = ay;\n\t\t\tif( s[ay_][ax_] == '#' ) continue;\n\t\t\tP a(ax_,ay_);\n\t\t\t\n\t\t\tif( a == b ){ // ゴールの時\n\t\t\t\treturn pair<int,P>(t+1,a);\n\t\t\t}else if( d[ay_][ax_][by_][bx_][(t+1) % p.size()] == INF ){\n\t\t\t\td[ay_][ax_][by_][bx_][(t+1) % p.size()] = t+1;\n\t\t\t\tPP pp(P(ax_,ay_),P(bx_,by_));\n\t\t\t\tq.push( State( pp , t+1 ) );\n\t\t\t}\n\t\t}\n\t}\n\treturn pair<int,P>(-1,P(0,0));\n}\n\nint main(){\n\tdx['6'] = 1; dx['4'] = -1; dy['8'] = -1; dy['2'] = 1;\n\t\n\twhile( cin >> h >> w , h || w ){\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tcin >> s[y];\n\t\t}\n\t\tcin >> p;\n\t\t\n\t\tint ax, ay, bx, by;\n\t\tfor(int y=0 ; y < h ; y++ ){\n\t\t\tfor(int x=0 ; x < w ; x++ ){\n\t\t\t\tif( s[y][x] == 'A' ){\n\t\t\t\t\tax = x; ay = y; s[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif( s[y][x] == 'B' ){\n\t\t\t\t\tbx = x; by = y; s[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tpair<int,P> ans = bfs(ax, ay, bx, by);\n\t\tif( ans.first == -1 ){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}else{\n\t\t\tcout << ans.first << \" \";\n\t\t\tcout << ans.second.second << \" \";\n\t\t\tcout << ans.second.first << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n#include <tuple>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w,h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tstring p; cin>>p;\n\t\t\n\t\tvvi t(h,vi(w,INFTY));\n\t\tqueue<tuple<int,int,int>> q;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='A')\n\t\t\tq.emplace(i,j,0);\n\t\twhile(!q.empty()){\n\t\t\tauto cur=q.front(); q.pop();\n\t\t\tint ci=get<0>(cur),cj=get<1>(cur),ct=get<2>(cur);\n\t\t\tif(ci<0 || h<=ci || cj<0 || w<=cj || grid[ci][cj]=='#' || t[ci][cj]!=INFTY)\n\t\t\t\tcontinue;\n\t\t\tt[ci][cj]=ct;\n\t\t\trep(i,4) q.emplace(ci+\"\\xff\\x1\\0\\0\"[i],cj+\"\\0\\0\\xff\\x1\"[i],ct+1);\n\t\t}\n\t\t\n\t\tvvi mask(h,vi(w,INFTY));\n\t\tint ci=-1,cj=-1;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='B')\n\t\t\tci=i,cj=j;\n\t\tint res=INFTY;\n\t\tpii pos;\n\t\tfor(int ct=0,i=0;;ct++,i=(i+1)%p.size()){\n\t\t\tif(res>max(ct,t[ci][cj])){\n\t\t\t\tres=max(ct,t[ci][cj]);\n\t\t\t\tpos=mp(ci,cj);\n\t\t\t}\n\t\t\tif(mask[ci][cj]&1<<i)\n\t\t\t\tbreak;\n\t\t\tmask[ci][cj]|=1<<i;\n\t\t\tint ni=ci,nj=cj;\n\t\t\tif(p[i]=='8') ni--;\n\t\t\tif(p[i]=='2') ni++;\n\t\t\tif(p[i]=='4') nj--;\n\t\t\tif(p[i]=='6') nj++;\n\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w)\n\t\t\t\tci=ni,cj=nj;\n\t\t}\n\t\t\n\t\tif(res==INFTY)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse\n\t\t\tcout<<res<<' '<<pos.first<<' '<<pos.second<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pair<pair<int,int>,int> p = q.front();\n            if(co[p.first.second][p.first.first]!=INT_MAX){\n                continue;\n            }\n            co[p.first.second][p.first.first]=p.second;\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n        }\n        string pat;\n        cin>>pat;\n//        int go=0;\n//        for(int j=0;;j++){\n//            int i=j%pat.length();\n//         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n//            if(co[gy][gx]<=go){\n//                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n//                break;\n//            }\n//            if(go>1000){\n//                cout<<\"impossible\"<<endl;\n//                break;\n//            }\n//            if(pat[i]=='5'){\n//                \n//            } else if(pat[i]=='8'){\n//                gy--;\n//            } else if(pat[i]=='6'){\n//                gx++;\n//            } else if(pat[i]=='4'){\n//                gx--;\n//            } else if(pat[i]=='2'){\n//                gy++;\n//            }\n//            gy=max(0,gy);\n//            gy=min(h-1,gy);\n//            gx=max(0,gx);\n//            gx=min(w-1,gx);\n//            go++;\n//        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\nint m = 999999;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;;j++,go++){\n            int i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>100000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<queue>\n#include<algorithm>\nusing namespace std;\nqueue <int> qy,qx,qcnt;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,x,y,cnt,nx,ny,mini,ansx,ansy;\nint t[20][20],sx,sy,tx,ty,vd[20][20],ghost[20][20];\nstring in;\nint main(){\n  while(cin>>n>>m&&n){\n    for(int i=0;i<n;i++){\n      cin>>in;\n      for(int j=0;j<(int)in.size();j++){\n\tif(in[j]=='A')sx=j,sy=i;\n\telse if(in[j]=='B')tx=j,ty=i;\n\tt[i][j]=(in[j]=='#');\n      }\n    }\n    \n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)vd[i][j]=0;\n    vd[sy][sx]=1;\n    qx.push(sx);\n    qy.push(sy);\n    qcnt.push(1);\n    while(!qx.empty()){\n      x=qx.front();qx.pop();\n      y=qy.front();qy.pop();\n      cnt=qcnt.front();qcnt.pop();\n      for(int i=0;i<4;i++){\n\tnx=x+dx[i];ny=y+dy[i];\n\tif(!(0<=nx&&nx<m&&0<=ny&&ny<n))continue;\n\tif(vd[ny][nx]>0||t[ny][nx]==1)continue;\n\tvd[ny][nx]=cnt+1;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqcnt.push(cnt+1);\n      }\n    }\n    \n    \n    cin>>in;\n    cnt=0;\n    mini=99999999;\n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)ghost[i][j]=0;\n    \n    for(int I=0;I<400;I++){\n      \n      \n      ghost[ty][tx]=1;\n      for(int i=0;i<(int)in.size();i++){\n\tcnt++;\n\t\n\tif(cnt>=vd[ty][tx]&&vd[ty][tx]!=0){\n\t  if(mini>cnt){\n\t    mini=cnt;\n\t    ansy=ty;\n\t    ansx=tx;\n\t  }\n\t}\n\tif(in[i]=='5')continue;\n\telse if(in[i]=='8'){\n\t  if(ty==0)continue;\n\t  ty--;\n\t}else if(in[i]=='6'){\n\t  if(tx==m-1)continue;\n\t  tx++;\n\t}else if(in[i]=='4'){\n\t  if(tx==0)continue;\n\t  tx--;\n\t}else{\n\t  if(ty==n-1)continue;\n\t  ty++;\n\t}\n      }//for\n    }//while\n    if(mini==99999999)cout<<\"impossible\"<<endl;\n    else cout<<mini-1<<' '<<ansy<<' '<<ansx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\n\nint x[4]={-1,0,0,1},y[4]={0,-1,1,0};\nint main(){\n    int a,b;\n    string s[20];\n    while(cin>>a>>b,a|b){\n\tP n,m;\n\tfor(int c=0;c<a;c++){cin>>s[c];\n\t    for(int i=0;i<b;i++){\n\t\tif(s[c][i]=='A'){n=P(c,i);s[c][i]='.';}\n\t\telse if(s[c][i]=='B'){m=P(c,i);s[c][i]='.';}\n\t\t}\n\t    }\n\tstring d;cin>>d;\n\tint mincost[20][20];\n\tmemset(mincost,-1,sizeof(mincost));\n\tqueue<P>Q;\n\tQ.push(n);\n\tmincost[n.first][n.second]=0;\n\twhile(Q.size()){\n\t    P t=Q.front();Q.pop();\n\t    for(int i=0;i<4;i++){\n\t\tint dx=t.first+x[i],dy=t.second+y[i];\n\t\tif(dx>=0&&dx<a&&dy>=0&&dy<b&&mincost[dx][dy]==-1&&s[dx][dy]=='.'){\n\t\t    mincost[dx][dy]=mincost[t.first][t.second]+1;\n\t\t    Q.push(P(dx,dy));\n\t\t    }\n\t\t}\n\t    }\n\t    int X=m.first,Y=m.second;\n\tfor(int i=0;i<1000;i++){\n            if(mincost[X][Y]!=-1&&mincost[X][Y]<=i){cout<<i<<\" \"<<X<<\" \"<<Y<<endl;goto r;}\n\t    switch(d[i%d.length()]){\n\t\tcase '2':X++;break;\n\t\tcase '6':Y++;break;\n\t\tcase '4':Y--;break;\n\t\tcase '8':X--;break;\n\t    }\n\t    if(X==a)X=a-1;\n\t    if(X==-1)X=0;\n\t    if(Y==b)Y=b-1;\n\t    if(Y==-1)Y=0;\n\t     }\n\t     puts(\"impossible\");\n\t     r:;\n\t    }\n    }"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nint H, W, dist[25][25]; string s[25], t;\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tint ax = -1, ay = -1, bx = -1, by = -1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> s[i];\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == 'A') ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B') bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdist[i][j] = 999999999;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int> > que; que.push(make_pair(ax, ay)); dist[ax][ay] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, int> u = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = u.first + dir[i], ty = u.second + dir[i ^ 1];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && dist[tx][ty] == 999999999) {\n\t\t\t\t\tdist[tx][ty] = dist[u.first][u.second] + 1;\n\t\t\t\t\tque.push(make_pair(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tif (dist[bx][by] <= i) {\n\t\t\t\tcout << i << ' ' << bx << ' ' << by << endl;\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tint tx = bx, ty = by;\n\t\t\tif (t[i % t.size()] == '2') tx++;\n\t\t\tif (t[i % t.size()] == '4') ty--;\n\t\t\tif (t[i % t.size()] == '6') ty++;\n\t\t\tif (t[i % t.size()] == '8') tx--;\n\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) bx = tx, by = ty;\n\t\t}\n\t\tif (!flag) cout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint h, w, ax, ay, bx, by, t, flag;\nchar field[20][20];\nchar pattern[10];\n\nint main() {\n\n\twhile(true) {\n\n\t\tscanf(\"%d%d\", &h, &w);\n\n\t\tif (h == 0 && w == 0) break;\n\n\t\tREP(y,h) {\n\t\t\tscanf(\"%s\", field[y]);\n\t\t\tREP(x,w) {\n\t\t\t\tif (field[y][x] == 'A') {\n\t\t\t\t\tax = x;\n\t\t\t\t\tay = y;\n\t\t\t\t} else if (field[y][x] == 'B') {\n\t\t\t\t\tbx = x;\n\t\t\t\t\tby = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\", pattern);\n\n\t\tint leng = strlen(pattern);\n\n\t\tt = 0, flag = 0;\n\n\t\tqueue<pii> q, nq;\n\t\tq.push(pii(ax,ay));\n\n\t\tREP(i,200) {\n\t\t\tt++;\n\n\t\t\t// girl\n\t\t\twhile(!q.empty()) {\n\t\t\t\tpii p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tREP(j,4) {\n\t\t\t\t\tint nx = p.first + dx[j];\n\t\t\t\t\tint ny = p.second + dy[j];\n\t\t\t\t\tif (0<=nx&&nx<w && 0<=ny&&ny<h && field[ny][nx]!='#') {\n\t\t\t\t\t\tfield[ny][nx] = 'A';\n\t\t\t\t\t\tnq.push(pii(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!nq.empty()) {\n\t\t\t\tq.push(nq.front());\n\t\t\t\tnq.pop();\n\t\t\t}\n\n\t\t\t// ghost\n\t\t\tswitch(pattern[i%leng]) {\n\t\t\t\tcase '5':\n\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\tby--;\n\t\t\t\tif(by<0)by=0;\n\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\tbx++;\n\t\t\t\tif(bx>=w)bx=w-1;\n\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\tbx--;\n\t\t\t\tif(bx<0)bx=0;\n\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\tby++;\n\t\t\t\tif(by>=h)by=h-1;\n\t\t\t\tbreak;\t\n\t\t\t}\n\n\t\t\tif (field[by][bx] == 'A') {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (flag == 0) {\n\t\t\tprintf(\"impossible\\n\");\n\t\t} else {\n\t\t\tprintf(\"%d %d %d\\n\", t, by, bx);\n\t\t}\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\nint dist[21][21], x[21][21], sx, sy, gx, gy, H, W; string S;\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; if (H == 0 && W == 0)break;\n\t\tfor (int i = 0; i < 441; i++)dist[i / 21][i % 21] = 99999;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar c; cin >> c; dist[i][j] = 99999;\n\t\t\t\tif (c == 'A') { sx = i; sy = j; x[i][j] = 0; }\n\t\t\t\tif (c == 'B') { gx = i; gy = j; x[i][j] = 0; }\n\t\t\t\tif (c == '#') { x[i][j] = 1; }\n\t\t\t\tif (c == '.') { x[i][j] = 0; }\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>>Q; Q.push(make_pair(sx, sy)); dist[sx][sy] = 0;\n\t\tint dx[4] = { 1,0,0,-1 }, dy[4] = { 0,-1,1,0 };\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front().first, a2 = Q.front().second; Q.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint cx = a1 + dx[i], cy = a2 + dy[i];\n\t\t\t\tif (cx < 0 || cy < 0 || cx >= H || cy >= W)continue;\n\t\t\t\tif (dist[cx][cy] > dist[a1][a2] + 1 && x[cx][cy] == 0) {\n\t\t\t\t\tdist[cx][cy] = dist[a1][a2] + 1;\n\t\t\t\t\tQ.push(make_pair(cx, cy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> S; for (int i = 0; i < 10; i++)S += S; bool OK = false;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tif (gx >= 0 && gx < H && gy >= 0 && gy < W) {\n\t\t\t\tif (dist[gx][gy] <= i) { cout << i << ' ' << gx << ' ' << gy << endl; OK = true; break; }\n\t\t\t}\n\t\t\tif (S[i] != '5') {\n\t\t\t\tgx += dx[(S[i] - '2') / 2]; gy += dy[(S[i] - '2') / 2];\n\t\t\t\tif (gx == -1)gx = 0; if (gx == H)gx = H - 1;\n\t\t\t\tif (gy == -1)gy = 0; if (gy == W)gy = W - 1;\n\t\t\t}\n\t\t}\n\t\tif (OK == false)cout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        memset(visited, 0, sizeof(visited));\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pair<pair<int,int>,int> p = q.front();\n            visited[p.first.second][p.first.first]=1;\n            co[p.first.second][p.first.first]=p.second;\n           // cout<<p.first.second<<\"  \"<<p.first.first<<\"  \"<<p.second<<endl;\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX&&ma[ny][nx]!='A'&&!visited[ny][nx]){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n        }\n        string pat;\n        cin>>pat;\n        int go=0;\n        for(int j=0;;j++){\n            int i=j%pat.length();\n         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>100000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='5'){\n                \n            } else if(pat[i]=='8'){\n                gy--;\n            } else if(pat[i]=='6'){\n                gx++;\n            } else if(pat[i]=='4'){\n                gx--;\n            } else if(pat[i]=='2'){\n                gy++;\n            }\n            gy=max(0,gy);\n            gy=min(h-1,gy);\n            gx=max(0,gx);\n            gx=min(w-1,gx);\n            go++;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\nint dist[21][21], x[21][21], sx, sy, gx, gy, H, W; string S;\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; if (H == 0 && W == 0)break;\n\t\tfor (int i = 0; i < 441; i++)dist[i / 21][i % 21] = 99999;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar c; cin >> c; dist[i][j] = 99999;\n\t\t\t\tif (c == 'A') { sx = i; sy = j; x[i][j] = 0; }\n\t\t\t\tif (c == 'B') { gx = i; gy = j; x[i][j] = 0; }\n\t\t\t\tif (c == '#') { x[i][j] = 1; }\n\t\t\t\tif (c == '.') { x[i][j] = 0; }\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>>Q; Q.push(make_pair(sx, sy)); dist[sx][sy] = 0;\n\t\tint dx[4] = { 1,0,0,-1 }, dy[4] = { 0,-1,1,0 };\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front().first, a2 = Q.front().second; Q.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint cx = a1 + dx[i], cy = a2 + dy[i];\n\t\t\t\tif (cx < 0 || cy < 0 || cx >= H || cy >= W)continue;\n\t\t\t\tif (dist[cx][cy] > dist[a1][a2] + 1 && x[cx][cy] == 0) {\n\t\t\t\t\tdist[cx][cy] = dist[a1][a2] + 1;\n\t\t\t\t\tQ.push(make_pair(cx, cy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> S; for (int i = 0; i < 10; i++)S += S; bool OK = false;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tif (gx >= 0 && gx < H && gy >= 0 && gy < W) {\n\t\t\t\tif (dist[gx][gy] <= i) { cout << i << ' ' << gx << ' ' << gy << endl; OK = true; break; }\n\t\t\t}\n\t\t\tif (S[i] != '5') {\n\t\t\t\tgx += dx[(S[i] - '2') / 2]; gy += dy[(S[i] - '2') / 2];\n\t\t\t\tif (gx == -1)gx = 0; if (gx == H)gx = H - 1;\n\t\t\t\tif (gy == -1)gy = 0; if (gy == W)gy = W - 1;\n\t\t\t}\n\t\t}\n\t\tif (OK == false)cout << \"impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint n,m;\nvector<string>in;\nvvi cnt;\nint sx,sy,bx,by;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint main(){\n\twhile(cin>>n>>m,n+m){\n\t\tin=vector<string>(n);\n\t\tcnt=vvi(n,vi(m,-1));\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,n)rep(j,m)if(in[i][j]=='B'){\n\t\t\tbx=i;by=j;in[i][j]='.';\n\t\t}else if(in[i][j]=='A'){\n\t\t\tsx=i;sy=j;in[i][j]='.';\n\t\t}\n//\t\tf(sx,sy,0);\n\t\tqueue<pair<pii,int> >qu;\n\t\tqu.push(pair<pii,int>(pii(sx,sy),0));\n\t\tcnt[sx][sy]=0;\n\t\twhile(!qu.empty()){\n\t\t\tpair<pii,int>q=qu.front();qu.pop();\n\t\t\tpii t=q.first;\n\t\t\trep(i,4){\n\t\t\t\tint nx=t.first+dx[i];\n\t\t\t\tint ny=t.second+dy[i];\n\t\t\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\t\t\tif(in[nx][ny]=='.'&&cnt[nx][ny]==-1){\n\t\t\t\t\tcnt[nx][ny]=q.second+1;\n\t\t\t\t\tqu.push(pair<pii,int>(pii(nx,ny),q.second+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//\t\trep(i,n){rep(j,m)cout<<\" \"<<(int)cnt[i][j];cout<<endl;}\n\t\tint mi=inf,ax,ay;\n\t\tstring s;\n\t\tcin>>s;\n\t\tint c=0;\n\t\trep(i,300){\n//\t\t\tcout<<bx<<\" \"<<by<<endl;\n\t\t\tif(cnt[bx][by]!=-1){\n\t\t\t\tint t=cnt[bx][by];\n\t\t\t\tif(t<=i&&mi>i){\n\t\t\t\t\tmi=min(mi,i);\n\t\t\t\t\tax=bx;ay=by;\n\t\t\t\t}\n\t\t\t}//442688\n\t\t\tif(s[c]=='5');\n\t\t\telse if(s[c]=='8'&&bx)bx--;\n\t\t\telse if(s[c]=='6'&&by<m-1)by++;\n\t\t\telse if(s[c]=='4'&&by)by--;\n\t\t\telse if(s[c]=='2'&&bx<n-1)bx++;\n\t\t\tc++;\n\t\t\tif(c==s.size())c=0;\n\t\t}\n\t\t\n\t\tif(mi==inf)cout<<\"impossible\"<<endl;\n\t\telse cout<<mi<<\" \"<<ax<<\" \"<<ay<<endl;\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;for(i=1;i<=h;i++){for(j=1;j<=w;j++)f[x=i*22+j]=-1,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-9;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-1)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];f[b]>=0&&++z){++t,f[j=b-54+\"L65676 \"[p[i++]-50]]>-3?b=j:0,f[b]>=0&t>=f[b]?a=b:0;!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int h,w;\n  string g[30],p;\n  int t[30][30];\n\n  while(cin >> h >> w , h||w){\n    int ay,ax,by,bx;\n    for(int i=0;i<h;i++){\n      cin >> g[i];\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == 'A'){ay = i; ax = j; g[i][j] = '.';}\n\tif(g[i][j] == 'B'){by = i; bx = j; g[i][j] = '.';}\n\tt[i][j] = -1;\n      }\n    }\n\n    cin >> p;\n    int s = p.size();\n\n    t[ay][ax] = 0;\n    queue<P> q;\n    q.push(P(ay,ax));\n    int m;\n\n    while(q.size()){\n      P p = q.front();q.pop();\n      int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\n      for(int i=0;i<4;i++){\n\tint ty = p.first + dy[i], tx = p.second + dx[i];\n\tif(ty<0 || tx<0 || h<=ty || w<=tx || g[ty][tx] == '#')continue;\n\tif(t[ty][tx]<0){\n\t  m = t[ty][tx] = t[p.first][p.second] + 1;\n\t  q.push(P(ty,tx));\n\t}\n      }\n    }\n\n    bool f = false;\n    for(int cnt=0;cnt<100000;cnt++){\n      if(p[cnt%s]=='8' && 0<by)by--;\n      if(p[cnt%s]=='6' && bx<w-1)bx++;\n      if(p[cnt%s]=='4' && 0<bx)bx--;\n      if(p[cnt%s]=='2' && by<h-1)by++;\n      if(0<=t[by][bx] && t[by][bx]<=cnt+1){\n\tcout << cnt+1 << \" \" << by << \" \" << bx << endl;\n\tf = true;\n\tbreak;\n      }\n    }\n    if(!f)cout << \"impossible\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;for(i=1;i<=h;i++){for(j=1;j<=w;j++)f[x=i*22+j]=-1,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-9;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-1)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];f[b]>=0&&++z)++t,f[j=b-54+\"L65676 \"[p[i++]-50]]>-3?b=j:0,f[b]>=0&t>=f[b]?a=b:0;!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\n\tint h, w;\n\twhile (cin >> h >> w, h)\n\t{\n\t\tstring s[32], pattern;\n\t\trep (i, h)\n\t\t\tcin >> s[i];\n\t\tcin >> pattern;\n\n\n\t\tint dis[32][32];\n\t\tconst int INF = 1 << 24;\n\t\tint sx, sy, gx, gy;\n\t\tfor (int y = 0; y < h; ++y)\n\t\t{\n\t\t\tfor (int x = 0; x < w; ++x)\n\t\t\t{\n\t\t\t\tdis[y][x] = INF;\n\t\t\t\tif (s[y][x] == 'A')\n\t\t\t\t\tsx = x, sy = y;\n\t\t\t\telse if (s[y][x] == 'B')\n\t\t\t\t\tgx = x, gy = y;\n\t\t\t}\n\t\t}\n\n\t\tqueue<pint> q;\n\t\tq.push(pint(sx, sy));\n\t\tdis[sy][sx] = 0;\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tpint t = q.front(); q.pop();\n\t\t\tint x = t.first, y = t.second;\n\n\t\t\tint nc = dis[y][x] + 1;\n\t\t\tfor (int i = 0; i < 4; ++i)\n\t\t\t{\n\t\t\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\t\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h\n\t\t\t\t\t&& s[ny][nx] != '#' && nc < dis[ny][nx])\n\t\t\t\t{\n\t\t\t\t\tq.push(pint(nx, ny));\n\t\t\t\t\tdis[ny][nx] = nc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> pat;\n\t\tfor (int i = 0; i < pattern.size(); ++i)\n\t\t{\n\t\t\tstatic const char* ps = \"26845\";\n\t\t\tpat.push_back(strchr(ps, pattern[i]) - ps);\n\t\t}\n\t\tint res = -1, x, y;\n\t\tfor (int t = 1, p = 0; t < 10000; ++t, ++p %= pat.size())\n\t\t{\n\t\t\tif (pat[p] < 4)\n\t\t\t{\n\t\t\t\tint nx = gx + dx[pat[p]], ny = gy + dy[pat[p]];\n\t\t\t\tif (0 <= nx && nx < w && 0 <= ny && ny < h)\n\t\t\t\t\tgx = nx, gy = ny;\n\t\t\t}\n\t\t\tif (dis[gy][gx] <= t)\n\t\t\t{\n\t\t\t\tres = t, x = gx, y = gy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (res != -1)\n\t\t\tprintf(\"%d %d %d\\n\", res, y, x);\n\t\telse\n\t\t\tputs(\"impossible\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int h,w;\n  while(cin >> h>>w,h||w) {\n    char ba[h][w];\n    int ax,ay, bx,by;\n    REP(i,h) {\n      REP(j,w) {\n        cin >> ba[i][j];\n        if (ba[i][j]=='A') {\n          ax = j;\n          ay = i;\n        }else if (ba[i][j]=='B') {\n          bx = j;\n          by = i;\n        }\n      }\n    }\n    \n    const int dx[] = {0,-1,1,0};\n    const int dy[] = {1,0,0,-1};\n\n    int dis[h][w];\n    REP(i,h) REP(j,w) dis[i][j] = INF;\n    typedef pair<int,int> pii;\n    queue<pair<int,pii> > Q;\n    Q.push(make_pair(0, pii(ax,ay)));\n    int maxd = 0;\n    while(!Q.empty()) {\n      int x = Q.front().second.first;\n      int y = Q.front().second.second;\n      int d = Q.front().first;\n      Q.pop();\n\n      if (dis[y][x] != INF) continue;\n      dis[y][x] = d;\n      maxd = max(maxd,d);\n      REP(k,4) {\n        int xx = x+dx[k];\n        int yy = y+dy[k];\n\n        if (xx<0||xx>=w||yy<0||yy>=h) continue;\n        if (ba[yy][xx]=='#') continue;\n        if (dis[yy][xx] != INF) continue;\n        \n        Q.push(make_pair(d+1, pii(xx,yy)));\n      }\n    }\n    // REP(y,h) {\n    //   REP(x,w) {\n    //     if (dis[y][x] == INF) cout << -1 << \" \";\n    //     else\n    //       printf(\"%2d \", dis[y][x]);\n    //   }\n    //   cout << endl;\n    // }\n    string s;\n    cin >> s;\n    int m = s.size();\n    int memo[h][w][m];\n    memset(memo,0,sizeof(memo));\n\n    int cnt = 0;\n    int res = INF;\n    int ansx,ansy;\n    while(1) {\n//      printf(\"(%d,%d) \",bx,by);\n      if (dis[by][bx] <= cnt) {\n        if(cnt<res) {\n          res = cnt;\n          ansx = bx;\n          ansy = by;\n        }\n      }\n      if (cnt >= maxd) {\n        if (memo[by][bx][cnt%m]) {\n          break;\n        }\n        memo[by][bx][cnt%m] = 1;\n      }\n\n\n      if (s[cnt%m]-'0' != 5) {\n        int dir = (s[cnt%m]-'0')/2-1;\n        bx += dx[dir];\n        by += dy[dir];\n        if (bx<0||bx>=w||by<0||by>=h) {\n          bx -= dx[dir];\n          by -= dy[dir];\n        }\n      }\n      \n      cnt++;\n    }\n\n    if (res == INF) {\n      cout << \"impossible\" << endl;\n    } else\n      printf(\"%d %d %d\\n\", res, ansy, ansx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint h,w;\nchar field[21][21];\n\nconst int INF=100000000;\n\n// INFÈç­ªBÅ«È¢\nint minArrivalCost[21][21];\n// HìÌÚ®[gði[\nvector<pair<int,int> > ghostPath;\n// HìªÊßµ½êði[\nbool passedGhost[11][21][21];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\n// ­ªe}XÖ½Çè­½ßÌÅ¬RXgðßé\nvoid bfs(int sx,int sy){\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> > ();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> > ();\n\tprv->push(make_pair(sy,sx));\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tpassed[i][j]=false;\n\t\t}\n\t}\n\tint cnt=0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp=prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\tminArrivalCost[cp.first][cp.second]=min(minArrivalCost[cp.first][cp.second],cnt);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tnp.first+=dy[i];\n\t\t\t\tnp.second+=dx[i];\n\t\t\t\tif(np.first>=0&&np.second>=0&&np.first<h&&np.second<w){\n\t\t\t\t\tif(!passed[np.first][np.second]&&field[np.first][np.second]!='#'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\n\tdelete prv,nxt;\n}\n\nint searchGhost(pair<int,int> cp,int tern,string pattern,pair<int,int> sp){\n\t// 500ñ®¢Äàoï¦È¢ÈçÎA-1ðÔ·B»¤ÅÈ¯êÎAoï¦éÅ¬^[ðÔ·\n\tint cnt=-1;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < pattern.size(); i++){\n\t\t\tcnt++;\n\t\t\tif(cnt==300)\n\t\t\t\treturn -1;\n\t\t\t// ­ÌÊuÉBµ½ê\n\t\t\tif(sp==cp){\n\t\t\t\tif(tern<=cnt){\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar c = pattern[i];\n\t\t\tpair<int,int> np=cp;\n\t\t\t\n\t\t\tif(c=='8')\n\t\t\t\tnp.first-=1;\n\t\t\telse if(c=='6')\n\t\t\t\tnp.second+=1;\n\t\t\telse if(c=='4')\n\t\t\t\tnp.second-=1;\n\t\t\telse if(c=='2')\n\t\t\t\tnp.first++;\n\t\t\t\n\t\t\tif(np.first<0)\n\t\t\t\tnp.first=0;\n\t\t\telse if(np.first>=h)\n\t\t\t\tnp.first=h-1;\n\t\t\telse if(np.second>=w)\n\t\t\t\tnp.second=w-1;\n\t\t\telse if(np.second<0)\n\t\t\t\tnp.second=0;\n\t\t\tcp=np;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>h>>w&&!(h==0&&w==0)){\n\t\tghostPath.clear();\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 11; k++){\n\t\t\t\t\tpassedGhost[k][i][j]=false;\n\t\t\t\t}\n\t\t\t\tminArrivalCost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='A'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='B'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tbfs(sx,sy);\n\n\t\tpair<int,int> cp=make_pair(gy,gx);\n\t\tint minCost=INF;\n\t\tpair<int,int> rp;\n\t\t// eHìÌB|CgÉÂ¢ÄAÞªBÅ«Ä¢é©Ç¤©ðÝé\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcp=make_pair(i,j);\n\t\t\t\tint cst=minArrivalCost[cp.first][cp.second];\n\t\t\t\tif(cst!=INF){\n\t\t\t\t\tint r=searchGhost(make_pair(gy,gx),cst,pattern,cp);\n\t\t\t\t\tif(r!=-1){\n\t\t\t\t\t\tif(minCost>r){\n\t\t\t\t\t\t\tminCost=min(minCost,r);\n\t\t\t\t\t\t\trp=cp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost==INF)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse{\n\t\t\tcout<<minCost<<\" \"<<rp.first<<\" \"<<rp.second<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;for(i=1;i<=h;i++){for(j=1;j<=w;j++)f[x=i*22+j]=-1,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-9;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-1)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];f[b]>=0&&++z)++t,f[j=b-54+\"L65676 \"[p[i++]-50]]>-3?b=j:0,f[b]>=0&t>=f[b]?a=b:0;!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(~a?\"%d %d %d\\n\":\"impossible\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nint H, W, dist[25][25]; string s[25], t;\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tint ax = -1, ay = -1, bx = -1, by = -1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> s[i];\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == 'A') ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B') bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdist[i][j] = 999999999;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int> > que; que.push(make_pair(ax, ay)); dist[ax][ay] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, int> u = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = u.first + dir[i], ty = u.second + dir[i ^ 1];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && dist[tx][ty] == 999999999) {\n\t\t\t\t\tdist[tx][ty] = dist[u.first][u.second] + 1;\n\t\t\t\t\tque.push(make_pair(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbool flag = false;\n\t\tfor (int i = 0; i < 10000; i++) {\n\t\t\tif (dist[bx][by] <= i) {\n\t\t\t\tcout << i << ' ' << bx << ' ' << by << endl;\n\t\t\t\tflag = true; break;\n\t\t\t}\n\t\t\tint tx = bx, ty = by;\n\t\t\tif (t[i % t.size()] == '2') tx++;\n\t\t\tif (t[i % t.size()] == '4') ty--;\n\t\t\tif (t[i % t.size()] == '6') ty++;\n\t\t\tif (t[i % t.size()] == '8') tx--;\n\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) bx = tx, by = ty;\n\t\t}\n\t\tif (!flag) cout << \"impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[5] = {-1, 0, 1, 0, 0};\nconst int dy[5] = {0, -1, 0, 1, 0};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nstring s[21];\nint dis[21][21];\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  cout << fixed << setprecision(20);\n  while(true){\n  \tINT(h); INT(w); if(h == 0 && w == 0)break;\n  \trep(i, h)cin >> s[i];\n  \tstring u; cin >> u;\n  \tvector<int> v(sz(u));\n  \trep(i, sz(u)){\n  \t\tif(u[i] == '5')v[i] = 4;\n  \t\telse if(u[i] == '8')v[i] = 0;\n  \t\telse if(u[i] == '6')v[i] = 3;\n  \t\telse if(u[i] == '4')v[i] = 1;\n  \t\telse if(u[i] == '2')v[i] = 2;\n  \t}\n\trep(i, h)rep(j, w)dis[i][j] = inf;\n\tint sx, sy; rep(i, h)rep(j, w)if(s[i][j] == 'A')sx = i, sy = j;\n\tqueue<P> q; q.push(mk(sx, sy)); dis[sx][sy] = 0;\n\twhile(!q.empty()){\n\t\tauto p = q.front(); q.pop();\n\t\trep(k, 4){\n\t\t\tint nx = p.FI + dx[k];\n\t\t\tint ny = p.SE + dy[k];\n\t\t\tif(0 <= nx && nx < h && 0 <= ny && ny < w && s[nx][ny] != '#'){\n\t\t\t\tif(dis[nx][ny] > dis[p.FI][p.SE] + 1){\n\t\t\t\t\tdis[nx][ny] = dis[p.FI][p.SE] + 1;\n\t\t\t\t\tq.push(mk(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t//rep(i, h)rep(j, w)cout << dis[i][j] << \"\\n \"[j + 1 != w];\n\tint bx, by; rep(i, h)rep(j, w)if(s[i][j] == 'B')bx = i, by = j;\n\tfor(int i = 0; i < 10000; i++){\n\t\tif(i >= dis[bx][by]){\n\t\t\tcout << i << \" \" << bx << \" \" << by << endl;\n\t\t\tbreak;\n\t\t}\n\t\tbx += dx[v[i%sz(v)]];\n\t\tby += dy[v[i%sz(v)]];\n\t\tif(bx < 0)bx = 0; if(bx >= h)bx = h - 1;\n\t\tif(by < 0)by = 0; if(by >= w)by = w - 1;\n\t\tif(i + 1 == 10000){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t}\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,P> Pi;\ntypedef pair<P,Pi> Pii;\nint H,W;\nchar mas[22][22];\nstring pat;\nint ax,ay,bx,by;\nint dx[] = {0,1,-1,0,0};\nint dy[] = {0,0,0,-1,1};\n\nint solved(){\n  bool used[10][20][20][20][20];\n  memset(used,false,sizeof(used));\n  queue<Pii> que;\n  int len = pat.size();\n  que.push(Pii(P(0,0),Pi(P(ax,ay),P(bx,by))));\n  used[0][ax][ay][bx][by] = true;\n  while(!que.empty()){\n    Pii p = que.front(); que.pop();\n    int cnt = p.first.first;\n    int idx = p.first.second;\n    int Ax = p.second.first.first;\n    int Ay = p.second.first.second;\n    int Bx = p.second.second.first;\n    int By = p.second.second.second;\n    if(Ax == Bx && Ay == By) {\n      cout << cnt << \" \" << Ay << \" \" << Ax << endl;\n      return 1;\n    }\n    int nBx = Bx;\n    int nBy = By;\n    if(pat[idx] == '8') nBy = max(0,nBy-1);\n    else if(pat[idx] == '6') nBx = min(W-1,nBx+1);\n    else if(pat[idx] == '4') nBx = max(0,nBx-1);\n    else if(pat[idx] == '2') nBy = min(H-1,nBy+1);\n    for(int i=0;i<5;i++){\n      int nAx = Ax+dx[i];\n      int nAy = Ay+dy[i];\n      if(nAx >= W || nAx < 0) nAx = Ax;\n      if(nAy >= H || nAy < 0) nAy = Ay;\n      if(mas[nAy][nAx] != '#'){\n\tint next = (idx+1)%len;\n\tif(used[next][nAx][nAy][nBx][nBy] == false){\n\t  used[next][nAx][nAy][nBx][nBy] = true;\n\t  que.push(Pii(P(cnt+1,next),Pi(P(nAx,nAy),P(nBx,nBy))));\n\t}\t\n      }\n    }\n  }\n  return 0;\n}\n\nint main(){\n  while(1){\n    cin >> H >> W;\n    if(H == 0 && W == 0) break;\n    for(int i=0;i<H;i++){\n      for(int j=0;j<W;j++){\n\tcin >> mas[i][j];\n\tif(mas[i][j] == 'A'){\n\t  ax = j;\n\t  ay = i;\n\t}\n\tif(mas[i][j] == 'B'){\n\t  bx = j;\n\t  by = i;\n\t}\n      }\n    }\n    cin >> pat;\n    if(solved() == 0){\n      cout << \"impossible\" << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint h,w;\nchar field[21][21];\n\nconst int INF=100000000;\n\n// INFÈç­ªBÅ«È¢\nint minArrivalCost[21][21];\n// HìÌÚ®[gði[\nvector<pair<int,int> > ghostPath;\n// HìªÊßµ½êði[\nbool passedGhost[11][21][21];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\n// ­ªe}XÖ½Çè­½ßÌÅ¬RXgðßé\nvoid bfs(int sx,int sy){\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> > ();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> > ();\n\tprv->push(make_pair(sy,sx));\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tpassed[i][j]=false;\n\t\t}\n\t}\n\tint cnt=0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp=prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\tminArrivalCost[cp.first][cp.second]=min(minArrivalCost[cp.first][cp.second],cnt);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tnp.first+=dy[i];\n\t\t\t\tnp.second+=dx[i];\n\t\t\t\tif(np.first>=0&&np.second>=0&&np.first<h&&np.second<w){\n\t\t\t\t\tif(!passed[np.first][np.second]&&field[np.first][np.second]!='#'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\n\tdelete prv,nxt;\n}\n\nint searchGhost(pair<int,int> cp,int tern,string pattern,pair<int,int> sp){\n\t// 500ñ®¢Äàoï¦È¢ÈçÎA-1ðÔ·B»¤ÅÈ¯êÎAoï¦éÅ¬^[ðÔ·\n\tint cnt=-1;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < pattern.size(); i++){\n\t\t\tcnt++;\n\t\t\tif(cnt==180)\n\t\t\t\treturn -1;\n\t\t\t// ­ÌÊuÉBµ½ê\n\t\t\tif(sp==cp){\n\t\t\t\tif(tern<=cnt){\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar c = pattern[i];\n\t\t\tpair<int,int> np=cp;\n\t\t\t\n\t\t\tif(c=='8')\n\t\t\t\tnp.first-=1;\n\t\t\telse if(c=='6')\n\t\t\t\tnp.second+=1;\n\t\t\telse if(c=='4')\n\t\t\t\tnp.second-=1;\n\t\t\telse if(c=='2')\n\t\t\t\tnp.first++;\n\t\t\t\n\t\t\tif(np.first<0)\n\t\t\t\tnp.first=0;\n\t\t\telse if(np.first>=h)\n\t\t\t\tnp.first=h-1;\n\t\t\telse if(np.second>=w)\n\t\t\t\tnp.second=w-1;\n\t\t\telse if(np.second<0)\n\t\t\t\tnp.second=0;\n\t\t\tcp=np;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>h>>w&&!(h==0&&w==0)){\n\t\tghostPath.clear();\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 11; k++){\n\t\t\t\t\tpassedGhost[k][i][j]=false;\n\t\t\t\t}\n\t\t\t\tminArrivalCost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='A'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='B'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tbfs(sx,sy);\n\n\t\tpair<int,int> cp=make_pair(gy,gx);\n\t\tint minCost=INF;\n\t\tpair<int,int> rp;\n\t\t// eHìÌB|CgÉÂ¢ÄAÞªBÅ«Ä¢é©Ç¤©ðÝé\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcp=make_pair(i,j);\n\t\t\t\tint cst=minArrivalCost[cp.first][cp.second];\n\t\t\t\tif(cst!=INF){\n\t\t\t\t\tint r=searchGhost(make_pair(gy,gx),cst,pattern,cp);\n\t\t\t\t\tif(r!=-1){\n\t\t\t\t\t\tif(minCost>r){\n\t\t\t\t\t\t\tminCost=min(minCost,r);\n\t\t\t\t\t\t\trp=cp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost==INF)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse{\n\t\t\tcout<<minCost<<\" \"<<rp.first<<\" \"<<rp.second<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int h,w;\n  while(cin >> h>>w,h||w) {\n    char ba[h][w];\n    int ax,ay, bx,by;\n    REP(i,h) {\n      REP(j,w) {\n        cin >> ba[i][j];\n        if (ba[i][j]=='A') {\n          ax = j;\n          ay = i;\n        }else if (ba[i][j]=='B') {\n          bx = j;\n          by = i;\n        }\n      }\n    }\n    const int dx[] = {0,-1,1,0};\n    const int dy[] = {1,0,0,-1};\n\n    int dis[h][w];\n    REP(i,h) REP(j,w) dis[i][j] = INF;\n    typedef pair<int,int> pii;\n    queue<pair<int,pii> > Q;\n    Q.push(make_pair(0, pii(ax,ay)));\n    int maxd = 0;\n    while(!Q.empty()) {\n      int x = Q.front().second.first;\n      int y = Q.front().second.second;\n      int d = Q.front().first;\n      Q.pop();\n\n      dis[y][x] = d;\n      maxd = max(maxd,d);\n      REP(k,4) {\n        int xx = x+dx[k];\n        int yy = y+dy[k];\n\n        if (xx<0||xx>=w||yy<0||yy>=h) continue;\n        if (ba[yy][xx]=='#') continue;\n        if (dis[yy][xx] != INF) continue;\n        \n        Q.push(make_pair(d+1, pii(xx,yy)));\n      }\n    }\n    // REP(y,h) {\n    //   REP(x,w) {\n    //     if (dis[y][x] == INF) cout << -1 << \" \";\n    //     else\n    //       printf(\"%2d \", dis[y][x]);\n    //   }\n    //   cout << endl;\n    // }\n    string s;\n    cin >> s;\n    int m = s.size();\n    int memo[h][w][m];\n    memset(memo,0,sizeof(memo));\n\n    int cnt = 0;\n    int res = INF;\n    int ansx,ansy;\n    while(1) {\n//      printf(\"(%d,%d) \",bx,by);\n      if (dis[by][bx] <= cnt) {\n        if(cnt<res) {\n          res = cnt;\n          ansx = bx;\n          ansy = by;\n        }\n      }\n\n      if (cnt >= maxd) {\n        if (memo[by][bx][cnt%m]) {\n          break;\n        }\n        memo[by][bx][cnt%m] = 1;\n      }\n\n\n      if (s[cnt%m]-'0' != 5) {\n        int dir = (s[cnt%m]-'0')/2-1;\n        bx += dx[dir];\n        by += dy[dir];\n        if (bx<0||bx>=w||by<0||by>=h) {\n          bx -= dx[dir];\n          by -= dy[dir];\n        }\n      }\n      \n      cnt++;\n    }\n\n    if (res == INF) {\n      cout << \"Impossible\" << endl;\n    } else\n      printf(\"%d %d %d\\n\", res, ansy, ansx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n\nconst size_t di[]={size_t(-1), 0, 1, 0};\nconst size_t dj[]={0, size_t(-1), 0, 1};\nconst int INF=1e9;\nconst size_t dti[]={0, 0, 1, 0, 0, 0, 0, 0, size_t(-1)};\nconst size_t dtj[]={0, 0, 0, 0, size_t(-1), 0, 1, 0, 0};\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0)\n    return 1;\n\n  std::vector<std::string> s(H);\n  size_t si=-1, sj=-1;\n  size_t ti=-1, tj=-1;\n  for (size_t i=0; i<H; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] == 'A') {\n        si = i;\n        sj = j;\n      } else if (s[i][j] == 'B') {\n        ti = i;\n        tj = j;\n      }\n    }\n  }\n\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string t=buf;\n\n  std::queue<std::pair<size_t, size_t>> q;\n  q.emplace(si, sj);\n  std::vector<std::vector<int>> dp(H, std::vector<int>(W, INF));\n  dp[si][sj] = 0;\n  while (!q.empty()) {\n    std::pair<size_t, size_t> p=q.front();\n    q.pop();\n    size_t i=p.first, j=p.second;\n    for (size_t k=0; k<4; ++k) {\n      size_t ni=i+di[k], nj=j+dj[k];\n      if (!(ni < H && nj < W)) continue;\n      if (s[ni][nj] == '#') continue;\n      if (dp[ni][nj] < dp[i][j] + 1) continue;\n      dp[ni][nj] = dp[i][j] + 1;\n      q.emplace(ni, nj);\n    }\n  }\n\n  // for (size_t i=0; i<H; ++i)\n  //   for (size_t j=0; j<W; ++j)\n  //     if (dp[i][j] < INF)\n  //       printf(\"%d%c\", dp[i][j], j+1<W? ' ':'\\n');\n  //     else\n  //       printf(\"#%c\", j+1<W? ' ':'\\n');\n\n  size_t tlen=t.length();\n  std::pair<size_t, size_t> res(-1, -1);\n  int tt=INF;\n  for (int i=0; i<1000; ++i) {\n    size_t nti=ti+dti[t[i%tlen]-'0'];\n    size_t ntj=tj+dtj[t[i%tlen]-'0'];\n    if (nti < H) ti = nti;\n    if (ntj < W) tj = ntj;\n    if (dp[ti][tj] < INF) {\n      if (dp[ti][tj] > i+1) continue;\n      if (i+1 < tt) {\n        tt = i+1;\n        res = {ti, tj};\n      }\n    }\n  }\n  if (tt < INF)\n    return !printf(\"%d %zu %zu\\n\", tt, res.first, res.second);\n  printf(\"impossible\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <limits>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 20;\nconstexpr int MAX_LENGTH = 10;\nconstexpr int MAX_DEPTH = 2000;\n\nconstexpr int dx[5] = {1, -1, 0, 0, 0};\nconstexpr int dy[5] = {0, 0, 1, -1, 0};\nconst unordered_map<char, int> conv{{'6', 0}, {'4', 1}, {'2', 2}, {'8', 3}, {'5', 4}};\n\nint h, w;\nstring field[MAX_SIZE];\nstring pattern;\n\nint t, ax, ay;\nint label[MAX_SIZE][MAX_SIZE];\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nvoid bfs(int sx, int sy) {\n\tmemset(label, -1, sizeof(label));\n\tlabel[sy][sx] = 0;\n\tqueue<pair<int, int>> que;\n\tque.push({sx, sy});\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().first;\n\t\tconst int y = que.front().second;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(out(nx, ny) || field[ny][nx] == '#') continue;\n\t\t\tif(label[ny][nx] == -1) {\n\t\t\t\tlabel[ny][nx] = label[y][x] + 1;\n\t\t\t\tque.push({nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid search(int x, int y, int tc) {\n\tif(label[y][x] != -1 && label[y][x] <= tc) {\n\t\tt = tc;\n\t\tax = x;\n\t\tay = y;\n\t\treturn;\n\t}\n\n\tif(tc == MAX_DEPTH) return;\n\n\tconst int idx = tc % pattern.size();\n\tint nx = x + dx[conv.at(pattern[idx])];\n\tint ny = y + dy[conv.at(pattern[idx])];\n\tif(out(nx, ny)) {\n\t\tnx = x;\n\t\tny = y;\n\t}\n\tsearch(nx, ny, tc + 1);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> field[i];\n\t\t}\n\t\tcin >> pattern;\n\n\t\tint sx, sy, gx, gy;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'A') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'B') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbfs(sx, sy);\n\t\tt = numeric_limits<int>::max();\n\t\tsearch(gx, gy, 0);\n\t\tif(t == numeric_limits<int>::max()) {\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << t << \" \" << ay << \" \"<< ax << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;for(i=1;i<=h;i++){for(j=1;j<=w;j++)f[x=i*22+j]=-1,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-9;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(a){for(i=4;i--;)if(f[x=a+\" 57L\"[i]]==-1)f[x]=t,q.push(x);}else++t,q.push(0);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];i++){t++;f[j=b+\"L65676 \"[p[i]-50]-54]>-3?b=j:0;f[b]>=0&&t>=f[b]?a=b:0;f[b]>=0&&++z;}!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid minDist(const vector<string>& plane, char wall, int y0, int x0, vector<vector<int> >& dist)\n{\n    int dy[] = {0, 0, -1, 1};\n    int dx[] = {-1, 1, 0, 0};\n\n    int h = plane.size();\n    int w = plane[0].size();\n    dist.assign(h, vector<int>(w, -1));\n\n    queue<pair<int, int> > q;\n    q.push(make_pair(y0, x0));\n    dist[y0][x0] = 0;\n    int n = 1;\n    while(!q.empty()){\n        queue<pair<int, int> > q1;\n        while(!q.empty()){\n            int y = q.front().first;\n            int x = q.front().second;\n            q.pop();\n            for(int i=0; i<4; ++i){\n                int y1 = y + dy[i];\n                int x1 = x + dx[i];\n                if(0 <= y1 && y1 < h && 0 <= x1 && x1 < w && plane[y1][x1] != wall && dist[y1][x1] == -1){\n                    q1.push(make_pair(y1, x1));\n                    dist[y1][x1] = n;\n                }\n            }\n        }\n        ++ n;\n        q = q1;\n    }\n}\n\nvoid solve(vector<string>& plane, string& pattern)\n{\n    int h = plane.size();\n    int w = plane[0].size();\n\n    int ay, ax, by, bx;\n    for(int i=0; i<h; ++i){\n        for(int j=0; j<w; ++j){\n            if(plane[i][j] == 'A'){\n                ay = i;\n                ax = j;\n            }else if(plane[i][j] == 'B'){\n                by = i;\n                bx = j;\n            }\n        }\n    }\n\n    vector<vector<int> > dist;\n    minDist(plane, '#', ay, ax, dist);\n\n    int dy[] = {0, 0, 1, 0, 0, 0, 0, 0, -1};\n    int dx[] = {0, 0, 0, 0, -1, 0, 1, 0, 0};\n    int n = pattern.size();\n    int move = 0;\n    while(move < 400){\n        for(int i=0; i<n; ++i){\n            by += dy[pattern[i]-'0'];\n            bx += dx[pattern[i]-'0'];\n            by = max(0, min(h-1, by));\n            bx = max(0, min(w-1, bx));\n            ++ move;\n            if(dist[by][bx] != -1 && dist[by][bx] <= move){\n                cout << move << ' ' << by << ' ' << bx << endl;\n                return;\n            }\n        }\n    }\n    cout << \"impossible\" << endl;\n}\n\nint main()\n{\n    for(;;){\n        int h, w;\n        cin >> h >> w;\n        if(h == 0)\n            return 0;\n\n        vector<string> plane(h);\n        for(int i=0; i<h; ++i)\n            cin >> plane[i];\n        string pattern;\n        cin >> pattern;\n        solve(plane, pattern);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nvector<string> s;\nP d[10],q;\nmap<int,int> mp;\nstring op;\nint dp[20][20];\nbool in(P n){\n\tif(n.second>=0&&n.second<w&&n.first>=0&&n.first<h)\n\t\treturn true;\n\treturn false;\n}\nint ret(P b,int time){\n\tif(time>400)\n\t\treturn INF;\n\tif(dp[b.first][b.second]<=time){\n\t\tq.first=b.first;q.second=b.second;\n\t\treturn time;\n\t}\n\tP nb;\n\tnb.first=b.first+d[op[time%op.size()]-'0'].first;\n\tnb.second=b.second+d[op[time%op.size()]-'0'].second;\n\tif(!in(nb))\n\t\tnb=b;\n\treturn ret(nb,time+1);\n}\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nvoid bfs(P a){\n\tqueue<P> que;\n\tque.push(a);\n\tdp[a.first][a.second]=0;\n\twhile(!que.empty()){\n\t\tP t=que.front(),nt;\n\t\tque.pop();\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnt.first=t.first+dy[i];\n\t\t\tnt.second=t.second+dx[i];\n\t\t\tif(in(nt)&&dp[nt.first][nt.second]==INF&&s[nt.first][nt.second]!='#'){\n\t\t\t\tque.push(nt);\n\t\t\t\tdp[nt.first][nt.second]=dp[t.first][t.second]+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\td[5]=P(0,0);d[8]=P(-1,0);d[6]=P(0,1);d[4]=P(0,-1);d[2]=P(1,0);\n\tmp[0]=5;mp[1]=8;mp[2]=6;mp[3]=4;mp[4]=2;\n\twhile(cin>>h>>w,h||w){\n\t\ts.clear();\n\t\tP a,b;\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tdp[i][j]=INF;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\ts.pb(t);\n\t\t\tfor(int j=0;j<t.size();j++){\n\t\t\t\tif(t[j]=='A'){\n\t\t\t\t\ta.first=i;a.second=j;\n\t\t\t\t}else if(t[j]=='B'){\n\t\t\t\t\tb.first=i;b.second=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>op;\n\t\tbfs(a);\n\t\tint ans=ret(b,0);\n\t\t(ans==INF)?cout<<\"impossible\"<<endl:cout<<ans<<\" \"<<q.first<<\" \"<<q.second<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\nint H, W;\nchar grid[25][25];\nstring pat;\nint grid2[25][25];\nint ay, ax;\nint by, bx;\n\nvoid bfs()\n{\n    const int INF = 100000000;\n    int dy[4] = {0, -1, 0, 1};\n    int dx[4] = {-1, 0, 1, 0};\n\n    typedef pair<int, int> P;\n\n    queue<P> que;\n    rep(i,H) rep(j,W) {\n        grid2[i][j] = INF;\n    }\n\n    que.push(P(ay, ax));\n    grid2[ay][ax] = 0;\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        rep(i,4) {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n\n            if (0 <= ny && ny < H && 0 <= nx && nx < W && grid[ny][nx] == '.' && grid2[ny][nx] == INF) {\n                que.push(P(ny, nx));\n                grid2[ny][nx] = grid2[p.first][p.second] + 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n#ifdef LOCAL\n    ifstream in(\"input.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n\n    while (true) {\n        cin >> H >> W;\n        if (H == 0 && W == 0) break;\n\n        rep(i,H) rep(j,W) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'A') {\n                ay = i;\n                ax = j;\n                grid[i][j] = '.';\n            } else if (grid[i][j] == 'B') {\n                by = i;\n                bx = j;\n                grid[i][j] = '.';\n            }\n        }\n        cin >> pat;\n\n        /*\n        int sy = 0, sx = 0;\n        rep(i,pat.length()) {\n            if (pat[i] == '5') {\n                sy += 0;\n                sx += 0;\n            } else if(pat[i] == '4') {\n                sy += 0;\n                sx -= 1;\n            } else if (pat[i] == '8') {\n                sy -= 1;\n                sx += 0;\n            } else if (pat[i] == '6') {\n                sy += 0;\n                sx += 1;\n            } else if (pat[i] == '2') {\n                sy += 1;\n                sx += 0;\n            }\n        }\n        bool try_only_one = false;\n        if (sy == 0 && sx == 0) try_only_one = true;\n        */\n\n        bfs();\n\n        /*\n        rep(i,H) {\n            rep(j,W) {\n                printf(\"% 3d \", grid2[i][j]);\n            }\n            cout << endl;\n        }\n        */\n\n        bool possible = false;\n        int ans;\n        int ansy, ansx;\n        int cnt = 0;\n        rep(i,25) {\n            rep(j,pat.length()) {\n                cnt++;\n                if (pat[j] == '5') {\n                    by += 0;\n                    bx += 0;\n                } else if(pat[j] == '4') {\n                    by += 0;\n                    if (bx >= 1) bx -= 1;\n                } else if (pat[j] == '8') {\n                    if (by >= 1) by -= 1;\n                    bx += 0;\n                } else if (pat[j] == '6') {\n                    by += 0;\n                    if (bx < W - 1) bx += 1;\n                } else if (pat[j] == '2') {\n                    if (by < H - 1) by += 1;\n                    bx += 0;\n                }\n                if (grid2[by][bx] <= cnt && !possible) {\n                    possible = true;\n                    ans = cnt;\n                    ansy = by;\n                    ansx = bx;\n                }\n            }\n        }\n\n        if (possible) {\n            cout << ans << \" \" << ansy << \" \" << ansx << endl;\n        } else {\n            cout << \"impossible\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {0, 0, 1, 0, -1};\n\nclass State\n{\npublic:\n  int sx, sy, gx, gy, time;\n  State(int _sx, int _sy, int _gx, int _gy, int _time)\n    :sx(_sx), sy(_sy), gx(_gx), gy(_gy), time(_time) {}\n};\n\nint main()\n{\n  int H, W;\n  while (cin >> H >> W) {\n    if ((H|W) == 0)\n      break;\n\n    vector<string> city(H);\n    int sx, sy, gx, gy;\n    for (int i = 0; i < H; ++i) {\n      cin >> city[i];\n\n      if (city[i].find_first_of(\"A\") != string::npos) {\n\tsy = i;\n\tsx = city[i].find_first_of(\"A\");\n\tcity[sy][sx] = '.';\n      }\n      if (city[i].find_first_of(\"B\") != string::npos) {\n\tgy = i;\n\tgx = city[i].find_first_of(\"B\");\n\tcity[gy][gx] = '.';\n      }\n    }\n\n    string pattern;\n    cin >> pattern;\n    for (int i = 0; i < pattern.size(); ++i) {\n      if (pattern[i] == '5')\n\tpattern[i] = '0';\n      else if (pattern[i] == '8')\n\tpattern[i] = '4';\n      else if (pattern[i] == '6')\n\tpattern[i] = '1';\n      else if (pattern[i] == '4')\n\tpattern[i] = '3';\n      else\n\tpattern[i] = '2';\n    }\n\n    bool found = false;\n    queue<State> que;\n    que.push(State(sx, sy, gx, gy, 0));\n    vector<vector<vector<vector<vector<int> > > > > dp(H, vector<vector<vector<vector<int> > > >(W, vector<vector<vector<int> > >(H, vector<vector<int > >(W, vector<int>(pattern.size(), INF)))));\n    while (!que.empty()) {\n      const State st = que.front();\n      que.pop();\n\n      if(st.sx == st.gx && st.sy == st.gy) {\n\tcout << st.time << \" \" << st.sy << \" \" << st.sx << endl;\n\tfound = true;\n\tbreak;\n      }\n\n      if (dp[st.sy][st.sx][st.gy][st.gx][st.time%pattern.size()] < st.time)\n\tcontinue;\n      dp[st.sy][st.sx][st.gy][st.gx][st.time%pattern.size()] = st.time;\n\n      for (int d = 0; d < 5; ++d) {\n\tsx = st.sx + dx[d];\n\tsy = st.sy + dy[d];\n\tgx = st.gx + dx[pattern[st.time%pattern.size()]-'0'];\n\tgy = st.gy + dy[pattern[st.time%pattern.size()]-'0'];\n\n\tif (sx < 0 || W <= sx || sy < 0 || H <= sy || city[sy][sx] == '#')\n\t  continue;\n\n\tif (gx < 0 || W <= gx)\n\t  gx = st.gx;\n\tif (gy < 0 || H <= gy)\n\t  gy = st.gy;\n\n\tif (dp[sy][sx][gy][gx][(st.time+1)%pattern.size()] > st.time+1) {\n\t  dp[sy][sx][gy][gx][(st.time+1)%pattern.size()] = st.time+1;\n\t  que.push(State(sx, sy, gx, gy, st.time+1));\n\t}\n      }\n\n    }\n\n    if (!found)\n      cout << \"impossible\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int h,w;\n  string g[30],p;\n  bool vis[30][30][30];\n  int t[30][30];\n\n  while(cin >> h >> w , h||w){\n    int ay,ax,by,bx;\n    for(int i=0;i<h;i++){\n      cin >> g[i];\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == 'A'){ay = i; ax = j; g[i][j] = '.';}\n\tif(g[i][j] == 'B'){by = i; bx = j; g[i][j] = '.';}\n\tt[i][j] = -1;\n\tfor(int k=0;k<10;k++)vis[i][j][k] = false;\n      }\n    }\n\n    cin >> p;\n    int s = p.size();\n\n    t[ay][ax] = 0;\n    queue<P> q;\n    q.push(P(ay,ax));\n    int m;\n\n    while(q.size()){\n      P p = q.front();q.pop();\n      int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\n      for(int i=0;i<4;i++){\n\tint ty = p.first + dy[i], tx = p.second + dx[i];\n\tif(ty<0 || tx<0 || h<=ty || w<=tx || g[ty][tx] == '#')continue;\n\tif(t[ty][tx]<0){\n\t  m = t[ty][tx] = t[p.first][p.second] + 1;\n\t  q.push(P(ty,tx));\n\t}\n      }\n    }\n\n    int cnt = 0;\n    bool f = false;\n    for(;;){\n      if(vis[by][bx][cnt%s] && m+s<cnt)break;\n      vis[by][bx][cnt%s] = true;\n      if(p[cnt%s]=='8' && 0<by)by--;\n      if(p[cnt%s]=='6' && bx<w-1)bx++;\n      if(p[cnt%s]=='4' && 0<bx)bx--;\n      if(p[cnt%s]=='2' && by<h-1)by++;\n      cnt++;\n      if(0<=t[by][bx] && t[by][bx]<=cnt){\n\tcout << cnt << \" \" << by << \" \" << bx << endl;\n\tf = true;\n\tbreak;\n      }\n    }\n    if(!f)cout << \"Impossible\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "int main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;for(i=1;i<=h;i++){for(j=1;j<=w;j++)f[x=i*22+j]=-1,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-9;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-1)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];f[b]>=0&&++z)++t,f[j=b-54+\"L65676 \"[p[i++]-50]]>-3?b=j:0,f[b]>=0&t>=f[b]?a=b:0;!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n\nusing namespace std;\n\nchar g[25][25];\nint memo[25][25][25][25][15];\nchar pat[15];\n\nint dx[10] = {\n  0, 0, 0, 0, -1, 0, 1, 0, 0, 0\n};\nint dy[10] = {\n  0, 0, 1, 0, 0, 0, 0, 0, -1, 0\n};\n\nconst int _dx[] = {0,1,0,-1,0};\nconst int _dy[] = {-1,0,1,0,0};\n\nstruct data{\n  int x1, y1, x2, y2;\n  int p;\n};\n\nint main(){\n  while(true){\n    int h = getInt();\n    int w = getInt();\n    int len;\n    int x1, x2, y1, y2;\n    queue<data> que;\n    bool ok = false;\n\n    if(h + w == 0) break;\n    REP(i,h) scanf(\"%s\", g[i]);\n    REP(i,h) REP(j,w){\n      if(g[i][j] == 'A'){\n        x1 = j; y1 = i;\n        g[i][j] = '.';\n      }else if(g[i][j] == 'B'){\n        x2 = j; y2 = i;\n        g[i][j] = '.';\n      }\n    }\n\n    scanf(\"%s\", pat);\n    len = strlen(pat);\n\n    memset(memo, -1, sizeof(memo));\n    que.push((data){x1,y1,x2,y2,0});\n    memo[y1][x1][y2][x2][0] = 0;\n\n    while(que.size()){\n      data d = que.front(); que.pop();\n      int x1 = d.x1;\n      int y1 = d.y1;\n      int x2 = d.x2;\n      int y2 = d.y2;\n      int p  = d.p;\n      int t  = memo[y1][x1][y2][x2][p];\n\n      if(x1 == x2 && y1 == y2){\n        ok = true;\n        printf(\"%d %d %d\\n\", t, y1, x1);\n        break;\n      }\n\n      REP(i,5){\n        int xx1 = x1 + _dx[i];\n        int yy1 = y1 + _dy[i];\n\n        int xx2 = x2 + dx[pat[p] - '0'];\n        int yy2 = y2 + dy[pat[p] - '0'];\n        int pp  = (p + 1) % len;\n\n        if(!ISIN(xx2,yy2,w,h)){\n          xx2 = x2;\n          yy2 = y2;\n        }\n\n        if(ISIN(xx1,yy1,w,h) && memo[yy1][xx1][yy2][xx2][pp] == -1 &&\n           g[yy1][xx1] == '.'){\n\n          memo[yy1][xx1][yy2][xx2][pp] = t + 1;\n          que.push((data){xx1,yy1,xx2,yy2,pp});\n        }\n      }\n    }\n\n    if(!ok) puts(\"impossible\");\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(i=0;i++<h;f[i*22]=f[i*22-~w]=-1,getchar())for(j=0;j++<w;z-35?z>65?b=x:z>64?a=x:1:--f[x])f[j]=f[j-~h*22]=-1,f[x=i*22+j]=-2,z=getchar();f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-2)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;!z&!a&!p[i]&b==x&f[b]<0&&--a){x=b;for(z=i=0;!a&&p[i];f[b]>=0&&++z)++t,~f[j=b-54+\"L65676 \"[p[i++]-50]]?b=j:0,f[b]>=0&t>=f[b]?a=b:0;}printf(~a?\"%d %d %d\\n\":\"impossible\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\n//#define DEBUG\n\ntypedef struct {\n\tint px, py;\n\tint gx, gy;\n\tint move_index;\n\tint depth;\n} DATA;\n\n\nchar map[20 + 2][20 + 2];\nchar move_inst[11];\nlist<unsigned> lstHash;\nlist<DATA> lstSarch;\n\nunsigned calc_hash(const DATA& data)\n{\n\tunsigned hash;\n\t\n\thash = data.px | (data.py << 5) | (data.gx << 10) | (data.gy << 15) | (data.move_index << 20);\n\t\n\treturn (hash);\n}\n\nbool is_add(const DATA& data)\n{\n\tunsigned hash;\n\t\n\thash = calc_hash(data);\n\tif (map[data.px][data.py] == -1 || map[data.px][data.py] == '#' || find(lstHash.begin(), lstHash.end(), hash) != lstHash.end()){\n\t\treturn (false);\n\t}\n\t\n\treturn (true);\n}\n\nint width_priority_sarch(const DATA& data)\n{\n\tDATA add;\n\t\n\tadd.depth = data.depth + 1;\n\tadd.move_index = (data.move_index + 1) % strlen(move_inst);\n\t\n\tadd.gx = data.gx;\n\tadd.gy = data.gy;\n\tswitch (move_inst[data.move_index]){\n\t  case '8': add.gy--; break;\n\t  case '4': add.gx--; break;\n\t  case '6': add.gx++; break;\n\t  case '2': add.gy++; break;\n\t  default :           break;\n\t}\n\t\n\tif (map[add.gx][add.gy] == -1){\n\t\tadd.gx = data.gx;\n\t\tadd.gy = data.gy;\n\t}\n\t\n\tadd.px = data.px;\n\tadd.py = data.py;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n#ifdef DEBUG\n\tprintf(\"%d %d\\n\", add.move_index, data.move_index);\n\tprintf(\"%u %u\\n\", calc_hash(add), calc_hash(data));\n#endif\n\t\n\tadd.px++;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n\tadd.px = data.px;\n\tadd.px--;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n\tadd.px = data.px;\n\tadd.py++;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n\tadd.py = data.py;\n\tadd.py--;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n\t\n\treturn (0);\n}\n\nbool is_end(DATA& data)\n{\n\tif (data.px == data.gx && data.py == data.gy){\n\t\treturn (true);\n\t}\n\treturn (false);\n}\n\nint main(void)\n{\n\tDATA start;\n\tint hight, with;\n\t\n\twhile (1){\n\t\tlstHash.clear();\n\t\tlstSarch.clear();\n\t\t\n\t\tscanf(\"%d%d\", &hight, &with);\n\t\t\n\t\tif (hight == 0 || with == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 22; i++){\n\t\t\tfor (int j = 0; j < 22; j++){\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int y = 0; y < hight; y++){\n\t\t\tchar str[21];\n\t\t\tscanf(\"%s\", str);\n\t\t\tfor (int x = 0; x < with; x++){\n\t\t\t\tmap[x + 1][y + 1] = str[x];\n\t\t\t\tif (map[x + 1][y + 1] == 'A'){\n\t\t\t\t\tstart.px = x + 1;\n\t\t\t\t\tstart.py = y + 1;\n\t\t\t\t\tmap[x + 1][y + 1] = '.';\n\t\t\t\t}\n\t\t\t\tif (map[x + 1][y + 1] == 'B'){\n\t\t\t\t\tstart.gx = x + 1;\n\t\t\t\t\tstart.gy = y + 1;\n\t\t\t\t\tmap[x + 1][y + 1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\", move_inst);\n\t\tstart.move_index = 0;\n\t\tstart.depth = 0;\n\t\t\n\t\tlstHash.push_back(calc_hash(start));\n\t\tlstSarch.push_back(start);\n\t\t\n\t\twhile (lstSarch.empty() == false && is_end(lstSarch.front()) == false){\n#ifdef DEBUG\n\t\t\tprintf(\"%d %d %d %d %d %d\\n\", lstSarch.front().px, lstSarch.front().py, lstSarch.front().gx, lstSarch.front().gy, lstSarch.front().depth, lstSarch.front().move_index);\n#endif\n\t\t\twidth_priority_sarch(lstSarch.front());\n\t\t\tlstSarch.pop_front();\n\t\t}\n\t\t\n\t\tif (lstSarch.empty() == true){\n\t\t\tputs(\"impossible\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d %d %d\\n\", lstSarch.front().depth, lstSarch.front().py - 1, lstSarch.front().px - 1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cstring>\n#include <limits>\n#include <iostream>\n#include <queue>\n#include <unordered_map>\n#include <vector>\nusing namespace std;\n\nconstexpr int MAX_SIZE = 20;\nconstexpr int MAX_LENGTH = 10;\n\nconstexpr int dx[5] = {1, -1, 0, 0, 0};\nconstexpr int dy[5] = {0, 0, 1, -1, 0};\nconst unordered_map<char, int> conv{{'6', 0}, {'4', 1}, {'2', 2}, {'8', 3}, {'5', 4}};\n\nint h, w;\nstring field[MAX_SIZE];\nstring pattern;\n\nint t, ax, ay;\nint label[MAX_SIZE][MAX_SIZE];\nbool visited[MAX_SIZE][MAX_SIZE][MAX_LENGTH];\n\ninline bool out(int x, int y) {\n\treturn x < 0 || y < 0 || x >= w || y >= h;\n}\n\nvoid bfs(int sx, int sy) {\n\tmemset(label, -1, sizeof(label));\n\tlabel[sy][sx] = 0;\n\tqueue<pair<int, int>> que;\n\tque.push({sx, sy});\n\n\twhile(!que.empty()) {\n\t\tconst int x = que.front().first;\n\t\tconst int y = que.front().second;\n\t\tque.pop();\n\n\t\tfor(int d = 0; d < 4; ++d) {\n\t\t\tconst int nx = x + dx[d];\n\t\t\tconst int ny = y + dy[d];\n\n\t\t\tif(out(nx, ny) || field[ny][nx] == '#') continue;\n\t\t\tif(label[ny][nx] == -1) {\n\t\t\t\tlabel[ny][nx] = label[y][x] + 1;\n\t\t\t\tque.push({nx, ny});\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid search(int x, int y, int tc) {\n\tif(label[y][x] != -1) {\n\t\tconst int tt = max(tc, label[y][x]);\n\t\tif(tt < t) {\n\t\t\tt = tt;\n\t\t\tax = x;\n\t\t\tay = y;\n\t\t}\n\t}\n\n\tconst int idx = tc % pattern.size();\n\tif(visited[x][y][idx]) return;\n\tvisited[x][y][idx] = true;\n\n\tint nx = x + dx[conv.at(pattern[idx])];\n\tint ny = y + dy[conv.at(pattern[idx])];\n\tif(out(nx, ny)) {\n\t\tnx = x;\n\t\tny = y;\n\t}\n\tsearch(nx, ny, tc + 1);\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> h >> w && h) {\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tcin >> field[i];\n\t\t}\n\t\tcin >> pattern;\n\n\t\tint sx, sy, gx, gy;\n\t\tfor(int i = 0; i < h; ++i) {\n\t\t\tfor(int j = 0; j < w; ++j) {\n\t\t\t\tif(field[i][j] == 'A') {\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if(field[i][j] == 'B') {\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t\tfield[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbfs(sx, sy);\n\t\tmemset(visited, false, sizeof(visited));\n\t\tt = numeric_limits<int>::max();\n\t\tsearch(gx, gy, 0);\n\t\tif(t == numeric_limits<int>::max()) {\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << t << \" \" << ay << \" \"<< ax << endl;\n\t\t}\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <queue>\n#define m make_pair\n#define INF (1e9)\n#define N 20\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\nvoid bfs();\nint h,w,sx,sy,gy,gx,p,d[N][N],anst,ansy,ansx;\nstring str[N],pat;\n\nint main(){\n  while(1){\n    cin>>h>>w;\n    if(!h&&!w) break;\n    for(int i=0;i<h;i++) cin>>str[i];\n    cin>>pat;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(str[i][j]=='A') sx=j,sy=i;\n\tif(str[i][j]=='B') gx=j,gy=i;\n      }\n    bfs();\n    int len=pat.size(),t=0,eflag=0;\n    p=0;\n    while(1){\n      int cy=gy,cx=gx;\n      if(pat[p]=='8') gy--;\n      if(pat[p]=='6') gx++;\n      if(pat[p]=='4') gx--;\n      if(pat[p]=='2') gy++;\n      p++;\n      t++;\n      if(p==len) p=0;\n      if(gy<0||h<=gy||gx<0||w<=gx) gy=cy,gx=cx;\n      if(d[gy][gx]!=INF&&d[gy][gx]<=t){\n\tanst=max(d[gy][gx],t);\n\tansy=gy;\n\tansx=gx;\n\tbreak;\n      }\n      if(t==100000){\n\teflag=1;\n\tbreak;\n      }\n    }\n    if(!eflag) cout<<anst<<' '<<ansy<<' '<<ansx<<endl;\n    else cout<<\"impossible\"<<endl;\n  }\n  return 0;\n}\n\nvoid bfs(){\n  int dy[4]={-1,0,1,0};\n  int dx[4]={0,1,0,-1};\n  queue<P1> q;\n  for(int i=0;i<N;i++)\n    for(int j=0;j<N;j++) d[i][j]=INF;\n  d[sy][sx]=0;\n  q.push(m(0,m(sy,sx)));\n  while(!q.empty()){\n    P1 t=q.front(); q.pop();\n    int c=t.first,uy=t.second.first,ux=t.second.second;\n    for(int i=0;i<4;i++){\n      int ny=uy+dy[i],nx=ux+dx[i];\n      if(ny<0||h<=ny||nx<0||w<=nx) continue;\n      if(str[ny][nx]=='#') continue;\n      if(d[ny][nx]>c+1){\n\td[ny][nx]=c+1;\n\tq.push(m(d[ny][nx],m(ny,nx)));\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n\nusing namespace std;\n\n//#define DEBUG\n\ntypedef struct {\n\tint px, py;\n\tint gx, gy;\n\tint move_index;\n\tint depth;\n} DATA;\n\n\nchar map[20 + 2][20 + 2];\nchar move_inst[11];\nlist<unsigned> lstHash;\nlist<DATA> lstSarch;\n\nunsigned calc_hash(const DATA& data)\n{\n\tunsigned hash;\n\t\n\thash = data.px | (data.py << 5) | (data.gx << 10) | (data.gy << 15) | (data.move_index << 20);\n\t\n\treturn (hash);\n}\n\nbool is_add(const DATA& data)\n{\n\tunsigned hash;\n\t\n\thash = calc_hash(data);\n\tif (map[data.px][data.py] == -1 || map[data.px][data.py] == '#' || find(lstHash.begin(), lstHash.end(), hash) != lstHash.end()){\n\t\treturn (false);\n\t}\n\t\n\treturn (true);\n}\n\nint width_priority_sarch(const DATA& data)\n{\n\tDATA add;\n\t\n\tadd.depth = data.depth + 1;\n\tadd.move_index = (data.move_index + 1) % strlen(move_inst);\n\t\n\tadd.gx = data.gx;\n\tadd.gy = data.gy;\n\tswitch (move_inst[data.move_index]){\n\t  case '8': add.gy--; break;\n\t  case '4': add.gx--; break;\n\t  case '6': add.gx++; break;\n\t  case '2': add.gy++; break;\n\t  default :           break;\n\t}\n\t\n\tif (map[add.gx][add.gy] == -1){\n\t\tadd.gx = data.gx;\n\t\tadd.gy = data.gy;\n\t}\n\t\n\tadd.px = data.px;\n\tadd.py = data.py;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n#ifdef DEBUG\n\tprintf(\"%d %d\\n\", add.move_index, data.move_index);\n\tprintf(\"%u %u\\n\", calc_hash(add), calc_hash(data));\n#endif\n\t\n\tadd.px++;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n\tadd.px = data.px;\n\tadd.px--;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n\tadd.px = data.px;\n\tadd.py++;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n\tadd.py = data.py;\n\tadd.py--;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.push_back(calc_hash(add));\n\t}\n\t\n\treturn (0);\n}\n\nbool is_end(DATA& data)\n{\n\tif (data.px == data.gx && data.py == data.gy){\n\t\treturn (true);\n\t}\n\treturn (false);\n}\n\nint main(void)\n{\n\tDATA start;\n\tint hight, with;\n\t\n\twhile (1){\n\t\tlstHash.clear();\n\t\tlstSarch.clear();\n\t\t\n\t\tscanf(\"%d%d\", &hight, &with);\n\t\t\n\t\tif (hight == 0 || with == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 22; i++){\n\t\t\tfor (int j = 0; j < 22; j++){\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int y = 0; y < hight; y++){\n\t\t\tchar str[21];\n\t\t\tscanf(\"%s\", str);\n\t\t\tfor (int x = 0; x < with; x++){\n\t\t\t\tmap[x + 1][y + 1] = str[x];\n\t\t\t\tif (map[x + 1][y + 1] == 'A'){\n\t\t\t\t\tstart.px = x + 1;\n\t\t\t\t\tstart.py = y + 1;\n\t\t\t\t\tmap[x + 1][y + 1] = '.';\n\t\t\t\t}\n\t\t\t\tif (map[x + 1][y + 1] == 'B'){\n\t\t\t\t\tstart.gx = x + 1;\n\t\t\t\t\tstart.gy = y + 1;\n\t\t\t\t\tmap[x + 1][y + 1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\", move_inst);\n\t\tstart.move_index = 0;\n\t\tstart.depth = 0;\n\t\t\n\t\tlstHash.push_back(calc_hash(start));\n\t\tlstSarch.push_back(start);\n\t\t\n\t\twhile (lstSarch.empty() == false && is_end(lstSarch.front()) == false){\n#ifdef DEBUG\n\t\t\tprintf(\"%d %d %d %d %d %d\\n\", lstSarch.front().px, lstSarch.front().py, lstSarch.front().gx, lstSarch.front().gy, lstSarch.front().depth, lstSarch.front().move_index);\n#endif\n\t\t\twidth_priority_sarch(lstSarch.front());\n\t\t\tlstSarch.pop_front();\n\t\t}\n\t\t\n\t\tif (lstSarch.empty() == true){\n\t\t\tputs(\"impossible\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d %d %d\\n\", lstSarch.front().depth, lstSarch.front().py - 1, lstSarch.front().px - 1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H,W;\n\nint diff_row[4] = {-1,0,0,1},diff_col[4] = {0,-1,1,0};\nchar map[20][21],pattern[11];\nbool***** check;\n\nstruct Info{\n\tint my_row,my_col,my_time,enemy_row,enemy_col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tbool FLG;\n\tint ans_row,ans_col,ans_time,next_my_row,next_my_col,next_enemy_row,next_enemy_col,pattern_length,tmp;\n\tcheck = new bool****[20];\n\tfor(int i = 0; i < 20; i++){\n\t\tcheck[i] = new bool***[20];\n\t\tfor(int a = 0; a < 20; a++){\n\t\t\tcheck[i][a] = new bool**[20];\n\t\t\tfor(int b = 0; b < 20; b++){\n\t\t\t\tcheck[i][a][b] = new bool*[20];\n\t\t\t\tfor(int c = 0; c < 20; c++)check[i][a][b][c] = new bool[10];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tFLG = false;\n\t\tInfo first;\n\n\t\tfirst.my_time = 0;\n\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++){\n\t\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\t\tfor(int e = 0; e < 10;e++)check[a][b][c][d][e] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",map[i]);\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tswitch(map[i][k]){\n\t\t\t\tcase 'A':\n\t\t\t\t\tfirst.my_row = i;\n\t\t\t\t\tfirst.my_col = k;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tfirst.enemy_row = i;\n\t\t\t\t\tfirst.enemy_col = k;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:break;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\",pattern);\n\t\tfor(pattern_length = 0; pattern[pattern_length] != '\\0';pattern_length++);\n\n\t\tqueue<Info> Q;\n\n\t\tQ.push(first);\n\n\t\tint debug = 0;\n\n\t\twhile(!Q.empty()){\n\n\t\t\tdebug++;\n\t\t\tif(debug > 100){\n\t\t\t\tprintf(\"Minhi!\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif(Q.front().my_row == Q.front().enemy_row && Q.front().my_col == Q.front().enemy_col){\n\t\t\t\tFLG = true;\n\t\t\t\tans_row = Q.front().my_row;\n\t\t\t\tans_col = Q.front().my_col;\n\t\t\t\tans_time = Q.front().my_time;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tQ.front().my_time++;\n\n\t\t\ttmp = (Q.front().my_time-1+pattern_length)%pattern_length;\n\t\t\tswitch(pattern[tmp]){\n\t\t\tcase '5':\n\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row+1,Q.front().enemy_col)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row+1;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row,Q.front().enemy_col-1)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col-1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row,Q.front().enemy_col+1)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col+1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row-1,Q.front().enemy_col)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row-1;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tnext_my_row = Q.front().my_row + diff_row[i];\n\t\t\t\tnext_my_col = Q.front().my_col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(next_my_row,next_my_col) == true && map[next_my_row][next_my_col] != '#' &&\n\t\t\t\t\t\tcheck[next_my_row][next_my_col][next_enemy_row][next_enemy_col][tmp] == false){\n\t\t\t\t\tcheck[next_my_row][next_my_col][next_enemy_row][next_enemy_col][tmp] = true;\n\t\t\t\t\tInfo next;\n\t\t\t\t\tnext.enemy_row = next_enemy_row;\n\t\t\t\t\tnext.enemy_col = next_enemy_col;\n\t\t\t\t\tnext.my_row = next_my_row;\n\t\t\t\t\tnext.my_col = next_my_col;\n\t\t\t\t\tnext.my_time = Q.front().my_time;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}else{\n\t\t\t\t\tif(check[Q.front().my_row][Q.front().my_col][next_enemy_row][next_enemy_col][tmp] == false){\n\t\t\t\t\t\tcheck[Q.front().my_row][Q.front().my_col][next_enemy_row][next_enemy_col][tmp] = true;\n\t\t\t\t\t\tInfo next;\n\t\t\t\t\t\tnext.enemy_row = next_enemy_row;\n\t\t\t\t\t\tnext.enemy_col = next_enemy_col;\n\t\t\t\t\t\tnext.my_row = Q.front().my_row;\n\t\t\t\t\t\tnext.my_col = Q.front().my_col;\n\t\t\t\t\t\tnext.my_time = Q.front().my_time;\n\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"impossible\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d %d %d\\n\",ans_time,ans_row,ans_col);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nvector<string> s;\nP d[10];\nint antime;\nP q;\nmap<int,int> mp;\nstring op;\nint dp[20][20][20][20][100];\nbool in(P n){\n\tif(n.second>=0&&n.second<w&&n.first>=0&&n.first<h)\n\t\treturn true;\n\treturn false;\n}\nvoid f(int cnt){\n\tcout<<cnt<<endl;\n\tf(cnt+1);\n}\nint ans;\nint ret(P a,P b,int time){\n\t//cout<<time<<endl;\n\t\n\tif(a==b){\n\t\tif(antime>time){\n\t\t\tantime=time;\n\t\t\tq.first=a.first;\n\t\t\tq.second=a.second;\n\t\t}\n\t\t//cout<<a.first<<\" \"<<a.second<<endl;\n\t\t//cout<<time<<endl;\n\t\treturn time;\n\t}\n\tif(100<time)\n\treturn INF;\n\t\n\tif(dp[a.first][a.second][b.first][b.second][time]!=-1)\n\t\treturn dp[a.first][a.second][b.first][b.second][time];\n\t\n\tint ans=INF;\n\tP na,nb;\n\t\n\tnb.first=b.first+d[op[time%op.size()]-'0'].first;\n\tnb.second=b.second+d[op[time%op.size()]-'0'].second;\n\t\n\tif(!in(nb))\n\t\tnb=b;\n\tfor(int i=0;i<5;i++){\n\t\tna.first=a.first+d[mp[i]].first;\n\t\tna.second=a.second+d[mp[i]].second;\n\t\t\n\t\tif(in(na)&&s[na.first][na.second]!='#'){\n\t\t\t//<<\"-------\"<<endl;\n\t\t\tans=min(ans,ret(na,nb,time+1));\n\t\t}/*(time%op.size()))*/\n\t}\n\treturn dp[a.first][a.second][b.first][b.second][time]=ans;\n}\nint main(){\n\td[5]=P(0,0);d[8]=P(-1,0);d[6]=P(0,1);d[4]=P(0,-1);d[2]=P(1,0);\n\tmp[0]=5;mp[1]=8;mp[2]=6;mp[3]=4;mp[4]=2;\n\twhile(cin>>h>>w,h||w){\n\t\ts.clear();\n\t\tP a,b;\n\t\tantime=INF;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\ts.pb(t);\n\t\t\tfor(int j=0;j<t.size();j++){\n\t\t\t\tif(t[j]=='A'){\n\t\t\t\t\ta.first=i;a.second=j;\n\t\t\t\t}else if(t[j]=='B'){\n\t\t\t\t\tb.first=i;b.second=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}cin>>op;\n\t\tret(a,b,0);\n\t\tif(antime!=INF)\n\t\t\tcout<<antime<<  \" \"<<q.first<<\" \"<<q.second<<endl;\n\t\telse\n\t\tcout<<\"impossible\"<<endl;\n\t\t//f(0);\n\t\t\n\t\t//cout<<<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define SIZE 21\n\nclass Point {\npublic:\n    int r, c;\n    Point( int r, int c ) : r(r), c(c) {};\n    Point() { r = 0, c = 0; };\n\n    bool operator == ( const Point& right ) const\n    {\n        return r == right.r && c == right.c;\n    }\n\n    bool operator < ( const Point& right ) const\n    {\n        return r != right.r ? r < right.r : c < right.c;\n    }\n};\n\ntypedef pair <Point, Point> PPP;\ntypedef pair <int, PPP> PIP;\n\nint h, w;\nint m[SIZE][SIZE];\n\n// for girl\nbool check_girl( Point p )\n{\n    int r = p.r, c = p.c;\n    if ( r >= 0 && r < h && c >= 0 && c < w ) {\n        if ( m[r][c] == 0 ) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// for ghost\nbool check_ghost( Point p )\n{\n    int r = p.r, c = p.c;\n    return r >= 0 && r < h && c >= 0 && c < w;\n}\n\nint main( void )\n{\n    string line;\n    while ( getline( cin, line ) ) {\n        // input\n        istringstream is(line);\n        is >> h >> w;\n        if ( h == 0 && w == 0 ) break;\n        \n        for ( int i = 0; i < h; i++ )\n        {\n            getline( cin, line );\n            for ( int j = 0; j < w; j++ ) {\n                if ( line[j] == '.' ) {\n                    m[i][j] = 0;\n                } else if ( line[j] == '#' ) {\n                    m[i][j] = 1;\n                } else if ( line[j] == 'A' ) {\n                    m[i][j] = 2;\n                } else if ( line[j] == 'B' ) {\n                    m[i][j] = 3;\n                }\n            }\n        }\n\n        string op;\n        getline( cin, op );\n        int opsize = op.size();\n\n        queue <PIP> Q;\n        set <PIP>   V;\n        {\n            // start node\n            Point start, goal;\n            for ( int i = 0; i < h; i++ ) for ( int j = 0; j < w; j++ ) {\n                if ( m[i][j] == 2 ) {\n                    start.r = i;\n                    start.c = j;\n                    m[i][j] = 0;\n                } else if ( m[i][j] == 3 ) {\n                    goal.r = i;\n                    goal.c = j;\n                    m[i][j] = 0;\n                }\n            }\n\n            PPP init_second( start, goal );\n            PIP init( 0, init_second );\n            Q.push( init );\n            V.insert( init );\n        }\n\n        // bfs\n        int a_first = -1, a_second, a_third;\n        while ( !Q.empty() ) {\n            PIP e = Q.front();\n            Q.pop();\n            int t = e.first;\n            Point s = e.second.first, g = e.second.second;\n\n            // is it goal?\n            if ( s == g ) {\n                a_first = t;\n                a_second = s.r;\n                a_third = s.c;\n                break;\n            }\n\n            // move ghost\n            int index = t % opsize;\n            char c = op[index];\n            \n            Point next_s = s, next_g = g;\n            int next_t = t+1;\n            int next_index = ( next_t ) % opsize;\n            if ( c == '5' ) {\n                // stop\n            } else if ( c == '8' ) {\n                // north\n                next_g.r -= 1;\n            } else if ( c == '6' ) {\n                // east\n                next_g.c += 1;\n            } else if ( c == '4' ) { \n                // west\n                next_g.c -= 1;\n            } else if ( c == '2' ) {\n                // south\n                next_g.r += 1;\n            }\n            if ( !check_ghost( next_g ) ) next_g = g;\n\n            // move girl\n            int dr[5] = { 0, -1, 0, 0, 1 };\n            int dc[5] = { 0, 0, 1, -1, 0 };\n            for ( int k = 0; k < 5; k++ ) {\n                next_s = s;\n                next_s.r += dr[k];\n                next_s.c += dc[k];\n                if ( !check_girl( next_s ) ) continue;\n\n                // already visited\n                PPP next_second( next_s, next_g );\n                PIP next_check( next_index, next_second );\n                if ( V.count( next_check ) ) continue;\n                V.insert( next_check );\n                \n                PIP next( next_t, next_second );\n                Q.push( next );\n            }\n        } // end of bfs\n\n        if ( a_first == -1 ) {\n            cout << \"impossible\" << endl;\n        } else {\n            cout << a_first << \" \" << a_second << \" \" << a_third << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint H,W;\nchar stage[20][20];\nstring ghost;\nbool visited[20][20][20][20][10];\nint gTime = 0;\nint rx,ry;\n\nclass State {\npublic:\n  int _sx,_sy,_gx,_gy,_time;\n  State(int sx,int sy,int gx,int gy,int time) : \n    _sx(sx),_sy(sy),_gx(gx),_gy(gy),_time(time) {}\n  bool operator<(const State &s) const {\n    return _time < s._time;\n  }\n  bool operator>(const State &s) const {\n    return _time > s._time;\n  }\n};\n\nvoid bfs(int sx,int sy,int gx,int gy){\n  State init(sx,sy,gx,gy,0);\n  \n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(init);\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n\n    int pattern_i = s._time % ghost.size();\n    if(ghost[pattern_i] == '5'){\n      //nothing to do\n    }\n    else if(ghost[pattern_i] == '8' && s._gy - 1 >= 0){\n      s._gy--;\n    }\n    else if(ghost[pattern_i] == '6' && s._gx + 1 < W){\n      s._gx++;\n    }\n    else if(ghost[pattern_i] == '4' && s._gx - 1 >= 0){\n      s._gx--;\n    }\n    else if(ghost[pattern_i] == '2' && s._gy + 1 < H){\n      s._gy++;\n    }\n\n    if(!visited[s._sx][s._sy][s._gx][s._gy][pattern_i]){\n      visited[s._sx][s._sy][s._gx][s._gy][pattern_i] = true;\n      if(s._sx == s._gx && s._sy == s._gy && gTime > s._time){\n        gTime = s._time;\n        rx = s._gx;\n        ry = s._gy;\n        return;\n      }\n      que.push(State(sx,sy,s._gx,s._gy,s._time+1));\n    }\n    for(int i = 0; i < 4; i++){\n      int dx = tx[i] + s._sx;\n      int dy = ty[i] + s._sy;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n         if(stage[dy][dx] == '#') continue;\n         if(visited[dx][dy][s._gx][s._gy][pattern_i]) continue;\n         \n         visited[dx][dy][s._gx][s._gy][pattern_i] = true;\n         if(dx == s._gx && dy == s._gy && gTime > s._time){\n           gTime = s._time;\n           rx = s._gx;\n           ry = s._gy;\n           return;\n         }\n         que.push(State(dx,dy,s._gx,s._gy,s._time+1));\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&H,&W)){\n    if(H == 0 && W == 0) break;\n\n    int sx,sy,gx,gy;\n    memset(visited,false,sizeof(visited));\n    gTime = INF;\n\n    for(int y = 0; y < H; y++){\n      char line[32];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        if(stage[y][x] == 'A'){\n          sx = x;\n          sy = y;\n        }\n        if(stage[y][x] == 'B'){\n          gx = x;\n          gy = y;\n        }\n      }\n    }\n    cin >> ghost;\n    rx = -1;\n    ry = -1;\n    bfs(sx,sy,gx,gy);\n    \n    if(gTime == INF){\n      printf(\"impossible\\n\");\n    }\n    else{\n      printf(\"%d %d %d\\n\",gTime + 1,ry,rx);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<string>\n#include<iostream>\n\n#define\tmp\tmake_pair\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\n\nint main(){\n\tfor(int w,h;cin>>h>>w,h;){\n\t\tchar grid[20][21];\n\t\tint px,py,qx,qy;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tcin>>grid[i];\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tif(grid[i][j]=='A')\tpx=j,py=i,grid[i][j]='.';\n\t\t\t\tif(grid[i][j]=='B')\tqx=j,qy=i,grid[i][j]='.';\n\t\t\t}\n\t\t}\n\t\tstring cmd;\tcin>>cmd;\n\n\t\tint girlcost[20][20];\n\t\tfor(int i=0;i<h;i++)for(int j=0;j<w;j++)\tgirlcost[i][j]=1<<30;\n\t\tgirlcost[py][px]=0;\n\t\tqueue< pair<int,pii> > qu;\tqu.push(mp(0,mp(px,py)));\n\t\twhile(!qu.empty()){\n\t\t\tpair<int,pii> a=qu.front();\tqu.pop();\n\t\t\tint cost=a.first,x=a.second.first,y=a.second.second;\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint xx=x+dx[i],yy=y+dy[i];\n\t\t\t\tif(0<=xx && xx<w && 0<=yy && yy<h && grid[yy][xx]!='#'){\n\t\t\t\t\tint nextcost=cost+1;\n\t\t\t\t\tif(nextcost<girlcost[yy][xx]){\n\t\t\t\t\t\tqu.push(mp(nextcost,mp(xx,yy)));\n\t\t\t\t\t\tgirlcost[yy][xx]=nextcost;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=1<<30,ansx,ansy;\n\t\tint len=cmd.length();\n\t\tbool visited[20][20][10]={};\n\t\tfor(int t=0,i=0;;t++,i=(i+1)%len){\n\t\t\tif(t>w*h && visited[qy][qx][i])\tbreak;\n\t\t\tvisited[qy][qx][i]=true;\n\n\t\t\tif(girlcost[qy][qx]<=t){\n\t\t\t\tans=t;\n\t\t\t\tansx=qx;\n\t\t\t\tansy=qy;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tswitch(cmd[i]){\n\t\t\t\tcase '2':\tif(qy<h-1)\tqy++; break;\n\t\t\t\tcase '4':\tif(qx>0)\tqx--; break;\n\t\t\t\tcase '6':\tif(qx<w-1)\tqx++; break;\n\t\t\t\tcase '8':\tif(qy>0)\tqy--; break;\n\t\t\t}\n\t\t}\n\n\t\tif(ans<(1<<30))\tcout<<ans<<' '<<ansy<<' '<<ansx<<endl;\n\t\telse\t\t\tcout<<\"impossible\"<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;for(i=1;i<=h;i++){for(j=1;j<=w;j++)f[x=i*22+j]=-1,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-9;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-1)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];i++){t++;f[j=b-54+\"L65676 \"[p[i]-50]]>-3?b=j:0;f[b]>=0&&t>=f[b]?a=b:0;f[b]>=0&&++z;}!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n \nusing namespace std;\n \ntypedef long long ll;\ntypedef pair <int,int> P;\n \nstatic const double EPS = 1e-8;\n\nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint H,W;\nchar stage[20][20];\nstring ghost;\nbool visited[20][20][20][20][10];\nint gTime = 0;\nint rx,ry;\n\nclass State {\npublic:\n  int _sx,_sy,_gx,_gy,_time;\n  State(int sx,int sy,int gx,int gy,int time) : \n    _sx(sx),_sy(sy),_gx(gx),_gy(gy),_time(time) {}\n  bool operator<(const State &s) const {\n    return _time < s._time;\n  }\n  bool operator>(const State &s) const {\n    return _time > s._time;\n  }\n};\n\nvoid bfs(int sx,int sy,int gx,int gy){\n  State init(sx,sy,gx,gy,0);\n  \n  priority_queue<State,vector<State>,greater<State> > que;\n  que.push(init);\n\n  while(!que.empty()){\n    State s = que.top();\n    que.pop();\n\n    int pattern_i = s._time % ghost.size();\n    if(ghost[pattern_i] == '5'){\n      //nothing to do\n    }\n    else if(ghost[pattern_i] == '8' && s._gy - 1 >= 0){\n      s._gy--;\n    }\n    else if(ghost[pattern_i] == '6' && s._gx + 1 < W){\n      s._gx++;\n    }\n    else if(ghost[pattern_i] == '4' && s._gx - 1 >= 0){\n      s._gx--;\n    }\n    else if(ghost[pattern_i] == '2' && s._gy + 1 < H){\n      s._gy++;\n    }\n\n    if(!visited[s._sx][s._sy][s._gx][s._gy][pattern_i]){\n      visited[s._sx][s._sy][s._gx][s._gy][pattern_i] = true;\n      if(s._sx == s._gx && s._sy == s._gy && gTime > s._time){\n        gTime = s._time;\n        rx = s._gx;\n        ry = s._gy;\n        return;\n      }\n      que.push(State(sx,sy,s._gx,s._gy,s._time+1));\n    }\n    for(int i = 0; i < 4; i++){\n      int dx = tx[i] + s._sx;\n      int dy = ty[i] + s._sy;\n      if(dx < 0 || dx >= W || dy < 0 || dy >= H) continue;\n         if(stage[dy][dx] == '#') continue;\n         if(visited[dx][dy][s._gx][s._gy][pattern_i]) continue;\n         \n         visited[dx][dy][s._gx][s._gy][pattern_i] = true;\n         if(dx == s._gx && dy == s._gy && gTime > s._time){\n           gTime = s._time;\n           rx = s._gx;\n           ry = s._gy;\n           return;\n         }\n         que.push(State(dx,dy,s._gx,s._gy,s._time+1));\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d %d\",&H,&W)){\n    if(H == 0 && W == 0) break;\n\n    int sx,sy,gx,gy;\n    memset(visited,false,sizeof(visited));\n    gTime = INF;\n\n    for(int y = 0; y < H; y++){\n      char line[32];\n      scanf(\"%s\",line);\n      for(int x = 0; x < W; x++){\n        stage[y][x] = line[x];\n        if(stage[y][x] == 'A'){\n          sx = x;\n          sy = y;\n        }\n        if(stage[y][x] == 'B'){\n          gx = x;\n          gy = y;\n        }\n      }\n    }\n    cin >> ghost;\n    rx = -1;\n    ry = -1;\n    bfs(sx,sy,gx,gy);\n    \n    if(gTime == INF){\n      printf(\"Impossible\\n\");\n    }\n    else{\n      printf(\"%d %d %d\\n\",gTime + 1,ry,rx);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <PII, PII> PPP;\ntypedef pair <int, PPP> NODE;\ntypedef priority_queue <NODE, vector<NODE>, greater<NODE> > QUEUE;\ntypedef vector <string> VS;\n\nbool V[21][21][21][21][11];\n\nvoid solve( int w, int h ) {\n    VS M(h);\n    for ( int i = 0; i < h; ++ i ) {\n        cin >> M[i];\n    }\n    int sr, sc, gr, gc;\n    for ( int i = 0; i < h; ++ i ) {\n        for ( int j = 0; j < w; ++ j ) {\n            if ( M[i][j] == 'A' ) {\n                sr = i;\n                sc = j;\n            }\n            if ( M[i][j] == 'B' ) {\n                gr = i;\n                gc = j;\n            }\n        }\n    }\n    string s;\n    cin >> s;\n    int n = s.size();\n    QUEUE Q;\n    NODE start( 0, PPP( PII( sr, sc ), PII( gr, gc ) ) );\n    Q.push( start );\n    for ( int i = 0; i < 21; ++ i ) {\n        for ( int j = 0; j < 21; ++ j ) {\n            for ( int k = 0; k < 21; ++ k ) {\n                for ( int l = 0; l < 21; ++ l ) {\n                    for ( int m = 0; m < 11; ++ m ) {\n                        V[i][j][k][l][m] = false;\n                    }\n                }\n            }\n        }\n    }\n\n    while ( ! Q.empty() ) {\n        NODE node = Q.top();\n        Q.pop();\n\n        int cost = node.first;\n        int r1 = node.second.first.first;\n        int c1 = node.second.first.second;\n        int r2 = node.second.second.first;\n        int c2 = node.second.second.second;\n        if ( r1 == r2 && c1 == c2 ) {\n            cout << cost << \" \" << r1 << \" \" << c1 << endl;\n            return;\n        }\n        \n        int ncost = cost + 1;\n        int nr2 = r2;\n        int nc2 = c2;\n        if ( s[cost%n] == '8' ) {\n            nr2 --;\n        } else if ( s[cost%n] == '2' ) {\n            nr2 ++;\n        } else if ( s[cost%n] == '6' ) {\n            nc2 ++;\n        } else if ( s[cost%n] == '4' ) {\n            nc2 --;\n        }\n        if ( nr2 < 0 || nr2 >= h ) nr2 = r2, nc2 = c2;\n        if ( nc2 < 0 || nc2 >= w ) nr2 = r2, nc2 = c2;\n\n        const int dr[5] = { 0, 0, 1, -1, 0 };\n        const int dc[5] = { 1, -1, 0, 0, 0 };\n        for ( int k = 0; k < 5; ++ k ) {\n            int nr1 = r1 + dr[k];\n            int nc1 = c1 + dc[k];\n            if ( nr1 < 0 || nr1 >= h ) nr1 = r1, nc1 = c1;\n            if ( nc1 < 0 || nc1 >= w ) nr1 = r1, nc1 = c1;\n            if ( M[nr1][nc1] == '#' ) continue;\n            if ( V[nr1][nc1][nr2][nc2][ncost%n] ) continue;\n            V[nr1][nc1][nr2][nc2][ncost%n] = true;\n            NODE next_node( ncost, PPP( PII( nr1, nc1 ), PII( nr2, nc2 ) ) );\n            Q.push( next_node );\n        }\n    }\n\n    cout << \"impossible\" << endl;\n}\n\nint main() {\n    int h, w;\n    while ( cin >> h >> w && h && w ) {\n        solve( w, h );\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint h,w;\nchar field[21][21];\n\nconst int INF=100000000;\n\n// INFÈç­ªBÅ«È¢\nint minArrivalCost[21][21];\n// HìÌÚ®[gði[\nvector<pair<int,int> > ghostPath;\n// HìªÊßµ½êði[\nbool passedGhost[11][21][21];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\n// ­ªe}XÖ½Çè­½ßÌÅ¬RXgðßé\nvoid bfs(int sx,int sy){\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> > ();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> > ();\n\tprv->push(make_pair(sy,sx));\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tpassed[i][j]=false;\n\t\t}\n\t}\n\tint cnt=0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp=prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\tminArrivalCost[cp.first][cp.second]=min(minArrivalCost[cp.first][cp.second],cnt);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tnp.first+=dy[i];\n\t\t\t\tnp.second+=dx[i];\n\t\t\t\tif(np.first>=0&&np.second>=0&&np.first<h&&np.second<w){\n\t\t\t\t\tif(!passed[np.first][np.second]&&field[np.first][np.second]!='#'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\n\tdelete prv,nxt;\n}\n\nint searchGhost(pair<int,int> cp,int tern,string pattern,pair<int,int> sp){\n\t// 500ñ®¢Äàoï¦È¢ÈçÎA-1ðÔ·B»¤ÅÈ¯êÎAoï¦éÅ¬^[ðÔ·\n\tint cnt=-1;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < pattern.size(); i++){\n\t\t\tcnt++;\n\t\t\tif(cnt==200)\n\t\t\t\treturn -1;\n\t\t\t// ­ÌÊuÉBµ½ê\n\t\t\tif(sp==cp){\n\t\t\t\tif(tern<=cnt){\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar c = pattern[i];\n\t\t\tpair<int,int> np=cp;\n\t\t\t\n\t\t\tif(c=='8')\n\t\t\t\tnp.first-=1;\n\t\t\telse if(c=='6')\n\t\t\t\tnp.second+=1;\n\t\t\telse if(c=='4')\n\t\t\t\tnp.second-=1;\n\t\t\telse if(c=='2')\n\t\t\t\tnp.first++;\n\t\t\t\n\t\t\tif(np.first<0)\n\t\t\t\tnp.first=0;\n\t\t\telse if(np.first>=h)\n\t\t\t\tnp.first=h-1;\n\t\t\telse if(np.second>=w)\n\t\t\t\tnp.second=w-1;\n\t\t\telse if(np.second<0)\n\t\t\t\tnp.second=0;\n\t\t\tcp=np;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>h>>w&&!(h==0&&w==0)){\n\t\tghostPath.clear();\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 11; k++){\n\t\t\t\t\tpassedGhost[k][i][j]=false;\n\t\t\t\t}\n\t\t\t\tminArrivalCost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='A'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='B'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tbfs(sx,sy);\n\n\t\tpair<int,int> cp=make_pair(gy,gx);\n\t\tint minCost=INF;\n\t\tpair<int,int> rp;\n\t\t// eHìÌB|CgÉÂ¢ÄAÞªBÅ«Ä¢é©Ç¤©ðÝé\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcp=make_pair(i,j);\n\t\t\t\tint cst=minArrivalCost[cp.first][cp.second];\n\t\t\t\tif(cst!=INF){\n\t\t\t\t\tint r=searchGhost(make_pair(gy,gx),cst,pattern,cp);\n\t\t\t\t\tif(r!=-1){\n\t\t\t\t\t\tif(minCost>r){\n\t\t\t\t\t\t\tminCost=min(minCost,r);\n\t\t\t\t\t\t\trp=cp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost==INF)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse{\n\t\t\tcout<<minCost<<\" \"<<rp.first<<\" \"<<rp.second<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nvector<string> data(20);\nint dist[20][20]={};\nbool visited[20][20];\nint h,w;\n\n\nvoid dfs(int y,int x){\n\tif( y<0 || y>=h || x<0 || x>=w || visited[y][x]==true || data[y][x]=='#' )return ;\n\n\tvisited[y][x]=true;\n\n\tint a = (y+1<h )?dist[y+1][x]:999999999;\n\tint b = (y-1>=0)?dist[y-1][x]:999999999;\n\tint c = (x+1<w )?dist[y][x+1]:999999999;\n\tint d = (x-1>=0)?dist[y][x-1]:999999999;\n\n\tdist[y][x]=min( dist[y][x] , min(min(a,b) , min(c,d))+1 );\n\n\tdfs(y+1,x);\n\tdfs(y-1,x);\n\tdfs(y,x+1);\n\tdfs(y,x-1);\n}\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(h==0&&w==0)break;\n\t\tdata.clear();\n\t\trep(i,20)rep(j,20){dist[i][j]=999999999;visited[i][j]=false;}\n\t\tstring move;\n\n\t\trep(i,h) cin>>data[i];\n\t\tcin>>move;\t\t\n\n\t\tint sx,sy,gx,gy;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(data[i][j]=='A'){ sy=i;sx=j; }\n\t\t\tif(data[i][j]=='B'){ gy=i;gx=j;data[i][j]='.'; }\n\t\t}\n\n\t\tdist[sy][sx]=0;\n\t\tdfs(sy,sx);\n\n\t\tfor(int i=0;;i++){\n\t\t\tif(dist[gy][gx]<=i){\n\t\t\t\tcout<<i<<\" \"<<gy<<\" \"<<gx<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(move[i%move.size()]=='5'){;\t\t\t\t\t}\n\t\t\tif(move[i%move.size()]=='8'){gy=max(0,gy-1);\t}\n\t\t\tif(move[i%move.size()]=='6'){gx=min(w-1,gx+1);\t}\n\t\t\tif(move[i%move.size()]=='4'){gx=max(0,gx-1);\t}\n\t\t\tif(move[i%move.size()]=='2'){gy=min(h-1,gy+1);\t}\n\t\t\tif(i==1000000){\n\t\t\t\tcout<<\"impossible\"<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\nint m = 999999;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;;j++,go++){\n            int i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>700){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int ,int > P;\ntypedef pair<int, P> P2;\n\nbool v[30][30],vb[30][30][20];\nstring g[30],L;\nint h,w,s;\nint ay,ax,by,bx;\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++)cin >> g[i];\n    cin >> L;\n    s = L.size();\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == 'A'){\n\t  ay = i; ax = j;\n\t}\n\tif(g[i][j] == 'B'){\n\t  by = i; bx = j;\n\t}\n\tv[i][j] = false;\n\tfor(int k=0;k<s;k++)vb[i][j][k] = false;\n      }\n\n    int t = 0;\n    queue<P2> q;\n    q.push(P2(0,P(ay,ax)));\n\n    while(!q.empty()){\n      P2 p = q.front();q.pop();\n \n      if(p.first==t+1){\n\tvb[by][bx][t%s] = true;\n\tif(v[by][bx])break;\n\tif(L[t%s] == '8' && 0<by)by--;\n\tif(L[t%s] == '6' && bx<w-1)bx++;\n\tif(L[t%s] == '2' && by<h-1)by++;\n\tif(L[t%s] == '4' && 0<bx)bx--;\n\tt++;\n      }\n\n      v[p.second.first][p.second.second] = true;\n\n      int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n      for(int i=0;i<4;i++){\n\tint sy = p.second.first + dy[i] , sx = p.second.second + dx[i];\n\tif(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\tif(v[sy][sx] || g[sy][sx]=='#')continue;\n\tq.push(P2(p.first+1,P(sy,sx)));\n      }\n    }\n\n    if(v[by][bx])cout << t << \" \" << by << \" \" << bx << endl;\n    else {\n      for(int i=0;;i++){\n\tif(vb[by][bx][(t+i)%s]){\n\t  cout << \"impossible\\n\";\n\t  break;\n\t}\n\tvb[by][bx][(t+i)%s] = true;\n\tif(L[(t+i)%s] == '2' && 0<by)by--;\n\tif(L[(t+i)%s] == '6' && bx<w-1)bx++;\n\tif(L[(t+i)%s] == '8' && by<h-1)by++;\n\tif(L[(t+i)%s] == '4' && 0<bx)bx--;\n\tif(v[by][bx]){\n\t  cout << t+i+1 << \" \" << by << \" \" << bx << endl;\n\t  break;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nconst int INF=1001001001;\ntypedef pair<int,int>P;\nconst int dx[]={-1,0,1,0,0};\nconst int dy[]={0,-1,0,1,0};\nint H,W;\nchar fld[50][50];\nint sy,sx,gy,gx;\nint dist[50][50];\nint ord[10],N;\nbool ok(int y,int x){\n    if(y<0||y>=H||x<0||x>=W)return false;\n    return true;\n}\n\nvoid bfs(){\n    for(int i=0;i<H;i++)for(int j=0;j<W;j++)dist[i][j]=INF;\n    dist[sy][sx]=0;\n\n    queue<P>que;que.push(P(sy,sx));\n\n    while(que.size()){\n        P p=que.front();que.pop();\n\n        for(int i=0;i<4;i++){\n            int ny=p.first+dy[i],nx=p.second+dx[i];\n            if(!ok(ny,nx)||fld[ny][nx]=='#'||dist[ny][nx]!=INF)continue;\n            dist[ny][nx]=dist[p.first][p.second]+1;\n            que.push(P(ny,nx));\n        }\n    }\n}\n\nvoid solve(){\n    for(int i=0;i<H;i++){\n        cin>>fld[i];\n        for(int j=0;j<W;j++){\n            if(fld[i][j]=='A')sy=i,sx=j;\n            if(fld[i][j]=='B')gy=i,gx=j;\n        }\n    }\n\n    bfs();\n\n    string str;cin>>str;\n    N=str.size();\n    for(int i=0;i<N;i++){\n        switch(str[i]){\n            case '5':ord[i]=4;break;\n            case '8':ord[i]=1;break;\n            case '4':ord[i]=0;break;\n            case '2':ord[i]=3;break;\n            case '6':ord[i]=2;break;\n        }\n    }\n\n    for(int i=0;i<100000;i++){\n        int ny=gy+dy[ord[i%N]],nx=gx+dx[ord[i%N]];\n        if(ok(ny,nx)){\n            gy=ny;gx=nx;\n        }\n\n        if(dist[gy][gx]<=i+1){\n            cout<<i+1<<\" \"<<gy<<\" \"<<gx<<endl;\n            return;\n        }\n    }\n\n    cout<<\"impossible\"<<endl;\n}\n\nint main(){\n    while(cin>>H>>W,H||W)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define S 23\n\nint dx[] = {-1, 0, 1, 0};\nint dy[] = {0, -1, 0, 1};\n\nint main() {\n  int h, w;\n  char s[S][S];\n  int dist[S][S];\n  int sx, sy, gx, gy;\n  string pat;\n  while(cin >> h >> w && h+w) {\n    rep(i, h) rep(j, w) {\n      dist[i][j] = INF;\n      char c;\n      cin >> c;\n      s[i][j] = c;\n      if(c != '#') {\n        s[i][j] = '.';\n        if(c == 'A') {\n          sx = j; sy = i;\n        } else if(c == 'B') {\n          gx = j; gy = i;\n        }\n      }\n    }\n    cin >> pat;\n\n    queue<P> que;\n    que.push(P(sx, sy));\n    dist[sy][sx] = 0;\n    while(!que.empty()) {\n      P e = que.front(); que.pop();\n      int x = e.first, y = e.second;\n      rep(k, 4) {\n        int nx = x + dx[k], ny = y + dy[k];\n        if(!(0 <= nx && nx < w && 0 <= ny && ny < h) || dist[ny][nx] < INF || s[ny][nx] == '#') {\n          continue;\n        }\n        dist[ny][nx] = dist[y][x] + 1;\n        que.push(P(nx, ny));\n      }\n    }\n\n    int ans = INF;\n    repl(i, 1, w*h*pat.length()) {\n      int com = pat[(i-1)%pat.length()] - '0';\n      int cy = 1 - (com - 1)/3, cx = ((com - 1)%3) - 1;\n      if(0 <= gx + cx && gx + cx < w && 0 <= gy + cy && gy + cy < h) {\n        gx += cx; gy += cy;\n      }\n      int t = dist[gy][gx];\n      if(t <= i) {\n        ans = i;\n        cout << i SP gy SP gx << endl;\n        break;\n      }\n    }\n    if(ans == INF) {\n      cout << \"impossible\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int ,int > P;\ntypedef pair<int, P> P2;\n\nbool v[30][30],vb[30][30][20];\nstring g[30],L;\nint h,w,s;\nint ay,ax,by,bx;\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++)cin >> g[i];\n    cin >> L;\n    s = L.size();\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == 'A'){\n\t  ay = i; ax = j;\n\t}\n\tif(g[i][j] == 'B'){\n\t  by = i; bx = j;\n\t}\n\tv[i][j] = false;\n\tfor(int k=0;k<s;k++)vb[i][j][k] = false;\n      }\n\n    int t = 0;\n    queue<P2> q;\n    v[ay][ax] = true;\n    q.push(P2(0,P(ay,ax)));\n\n    while(!q.empty()){\n      P2 p = q.front();q.pop();\n \n      if(p.first==t+1){\n\tvb[by][bx][t%s] = true;\n\tif(v[by][bx])break;\n\tif(L[t%s] == '8' && 0<by)by--;\n\tif(L[t%s] == '6' && bx<w-1)bx++;\n\tif(L[t%s] == '2' && by<h-1)by++;\n\tif(L[t%s] == '4' && 0<bx)bx--;\n\tt++;\n      }\n\n      for(int i=0;i<4;i++){\n\tint sy = p.second.first + dy[i] , sx = p.second.second + dx[i];\n\tif(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\tif(v[sy][sx] || g[sy][sx]=='#')continue;\n\tv[sy][sx] = true;\n\tq.push(P2(p.first+1,P(sy,sx)));\n      }\n    }\n\n    if(v[by][bx])cout << t << \" \" << by << \" \" << bx << endl;\n    else {\n      for(int i=0;;i++){\n\tif(vb[by][bx][(t+i)%s]){\n\t  cout << \"impossible\\n\";\n\t  break;\n\t}\n\tvb[by][bx][(t+i)%s] = true;\n\tif(L[(t+i)%s] == '2' && 0<by)by--;\n\tif(L[(t+i)%s] == '6' && bx<w-1)bx++;\n\tif(L[(t+i)%s] == '8' && by<h-1)by++;\n\tif(L[(t+i)%s] == '4' && 0<bx)bx--;\n\tif(v[by][bx]){\n\t  cout << t+i+1 << \" \" << by << \" \" << bx << endl;\n\t  break;\n\t}\n      }\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=INT_MAX)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;;j++,go++){\n            int i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>100000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(i=0;i++<h;){for(j=0;j++<w;)f[j]=f[j-~h*22]=-1,f[x=i*22+j]=-2,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-1;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-2)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];f[b]>=0&&++z)++t,~f[j=b-54+\"L65676 \"[p[i++]-50]]?b=j:0,f[b]>=0&t>=f[b]?a=b:0;!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(~a?\"%d %d %d\\n\":\"impossible\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\nint m = 999999;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;;j++,go++){\n            int i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>1000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define REP(i,n) for(ll i=0;i<n;i++)\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint h, w, ax, ay, bx, by, t, flag;\nchar field[30][30];\nchar pattern[20];\n\nint main() {\n\n\twhile(true) {\n\n\t\tscanf(\"%d%d\", &h, &w);\n\n\t\tif (h == 0 && w == 0) break;\n\n\t\tREP(y,h) {\n\t\t\tscanf(\"%s\", field[y]);\n\t\t\tREP(x,w) {\n\t\t\t\tif (field[y][x] == 'A') {\n\t\t\t\t\tax = x;\n\t\t\t\t\tay = y;\n\t\t\t\t} else if (field[y][x] == 'B') {\n\t\t\t\t\tbx = x;\n\t\t\t\t\tby = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\", pattern);\n\n\t\tint leng = strlen(pattern);\n\n\t\tt = 0, flag = 0;\n\n\t\tqueue<pii> q, nq;\n\t\tq.push(pii(ax,ay));\n\n\t\tREP(i,200) {\n\t\t\tt++;\n\n\t\t\t// girl\n\t\t\twhile(!q.empty()) {\n\t\t\t\tpii p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tREP(j,4) {\n\t\t\t\t\tint nx = p.first + dx[j];\n\t\t\t\t\tint ny = p.second + dy[j];\n\t\t\t\t\tif (0<=nx&&nx<w && 0<=ny&&ny<h && field[ny][nx]!='#') {\n\t\t\t\t\t\tfield[ny][nx] = 'A';\n\t\t\t\t\t\tnq.push(pii(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!nq.empty()) {\n\t\t\t\tq.push(nq.front());\n\t\t\t\tnq.pop();\n\t\t\t}\n\n\t\t\t// ghost\n\t\t\tswitch(pattern[i%leng]) {\n\t\t\t\tcase '5':\n\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\tby--;\n\t\t\t\tif(by<0)by=0;\n\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\tbx++;\n\t\t\t\tif(bx>=w)bx=w-1;\n\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\tbx--;\n\t\t\t\tif(bx<0)bx=0;\n\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\tby++;\n\t\t\t\tif(by>=h)by=h-1;\n\t\t\t\tbreak;\t\n\t\t\t}\n\n\t\t\tif (field[by][bx] == 'A') {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (flag == 0) {\n\t\t\tprintf(\"impossible\\n\");\n\t\t} else {\n\t\t\tprintf(\"%d %d %d\\n\", t, by, bx);\n\t\t}\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<deque>\n#include<list>\n#include<map>\n#include<queue>\n#include<set>\n#include<stack>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<sstream>\n#include<cmath>\n#include<cstdlib>\n#include<cstdio>\n#include<cstring>\nusing namespace std;\nint main(){\n  int i,j,k;\n  int h,w;\n  while(cin>>h>>w,h||w){\n    int a[22][22],sx,sy,tx,ty;\n    memset(a,-1,sizeof(a));\n    for(i=1;i<h+1;i++){\n      for(j=1;j<w+1;j++){\n\tchar s;\n\tcin>>s;\n\tif(0){\n\t}else if(s=='#'){\n\t  a[j][i]=-2;\n\t}else{\n\t  a[j][i]=-3;\n\t  if(0){\n\t  }else if(s=='A'){\n\t    sx=j;\n\t    sy=i;\n\t  }else if(s=='B'){\n\t    tx=j;\n\t    ty=i;\n\t  }\n\t}\n      }\n    }\n    string s;\n    cin>>s;\n    int ln=s.length();\n    queue<pair<pair<int,int>,int> > b;\n    b.push(make_pair(make_pair(sx,sy),0));\n    while(b.empty()==0){\n      int x,y,z;\n      x=b.front().first.first;\n      y=b.front().first.second;\n      z=b.front().second;\n      b.pop();\n      if(a[x][y]==-3){\n\ta[x][y]=z;\n\tb.push(make_pair(make_pair(x-1,y),z+1));\n\tb.push(make_pair(make_pair(x+1,y),z+1));\n\tb.push(make_pair(make_pair(x,y-1),z+1));\n\tb.push(make_pair(make_pair(x,y+1),z+1));\n      }\n    }\n    int x=tx,y=ty;\n    int c[22][22][10],d[22][22][10];\n    memset(c,-1,sizeof(c));\n    memset(d,-1,sizeof(d));\n    c[x][y][ln-1]=0;\n    int mn=1<<30,xmn,ymn;\n    j=0;\n    for(;;){\n      for(i=0;i<ln;i++){\n\tj++;\n\tif(0){\n\t}else if(s[i]=='5'){\n\t}else if(s[i]=='8'){\n\t  if(a[x][y-1]!=-1)\n\t    y--;\n\t}else if(s[i]=='6'){\n\t  if(a[x+1][y]!=-1)\n\t    x++;\n\t}else if(s[i]=='4'){\n\t  if(a[x-1][y]!=-1)\n\t    x--;\n\t}else if(s[i]=='2'){\n\t  if(a[x][y+1]!=-1)\n\t    y++;\n\t}\n\tif(c[x][y][i]==-1){\n\t  c[x][y][i]=j;\n\t  if(a[x][y]>=0&&a[x][y]<=j){\n\t    if(mn>j){\n\t      mn=j;\n\t      xmn=x-1;\n\t      ymn=y-1;\n\t    }\n\t  }\n\t}else{\n\t  if(d[x][y][i]){\n\t    d[x][y][i]=0;\n\t    if(a[x][y]>=0&&a[x][y]>c[x][y][i]){\n\t      for(k=0;a[x][y]>c[x][y][i]+ln*k;k++);\n\t      if(mn>c[x][y][i]+ln*k){\n\t\tmn=c[x][y][i]+ln*k;\n\t\txmn=x-1;\n\t\tymn=y-1;\n\t      }\n\t    }\n\t  }else{\n\t    break;\n\t  }\n\t}\n      }\n      if(i!=ln)\n\tbreak;\n    }\n    if(mn==1<<30)\n      cout<<\"impossible\"<<endl;\n    else\n      cout<<mn<<\" \"<<ymn<<\" \"<<xmn<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<set>\n#include<string>\n#include<algorithm>\nusing namespace std;\nint t[20][20];\nconst int inf = 1000;\nvoid solve(int sum, int i, int j, int h, int w, char t2[20][20]) {\n\tif (i + 1 < h&&t2[i + 1][j] == '.') {\n\t\tt2[i + 1][j] = '#';\n\t\tt[i + 1][j] = sum + 1;\n\t\tsolve(sum + 1, i + 1, j, h, w, t2);\n\t}\n\tif (i - 1 >= 0 && t2[i - 1][j] == '.') {\n\t\tt2[i - 1][j] = '#';\n\t\tt[i - 1][j] = sum + 1;\n\t\tsolve(sum + 1, i - 1, j, h, w, t2);\n\t}\n\tif (j + 1 < w&&t2[i][j + 1] == '.') {\n\t\tt2[i][j + 1] = '#';\n\t\tt[i][j + 1] = sum + 1;\n\t\tsolve(sum + 1, i, j + 1, h, w, t2);\n\t}\n\tif (j - 1 >= 0 && t2[i][j - 1] == '.') {\n\t\tt2[i][j - 1] = '#';\n\t\tt[i][j - 1] = sum + 1;\n\t\tsolve(sum + 1, i, j - 1, h, w, t2);\n\t}\n}\nint main() {\n\tint h, w;\n\tchar t2[20][20];\n\tint t3[20][20][10];\n\twhile (cin >> h >> w&&h != 0 && w != 0) {\n\t\tstring u;\n\t\tint p[2];\n\t\tint g[2];\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tcin >> u;\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tt2[i][j] = u[j];\n\t\t\t\tif (u[j] == 'A') {\n\t\t\t\t\tp[0] = i;\n\t\t\t\t\tp[1] = j;\n\t\t\t\t}\n\t\t\t\tif (u[j] == 'B') {\n\t\t\t\t\tg[0] = i;\n\t\t\t\t\tg[1] = j;\n\t\t\t\t}\n\t\t\t\tt[i][j] = inf;\n\t\t\t\tfor (int z = 0; z < 10; z++) t3[i][j][z] = 0;\n\t\t\t}\n\t\t}\n\t\tstring a;\n\t\tcin >> a;\n\t\tint b[10][2];\n\t\tfor (int i = 0; i < a.length(); i++) {\n\t\t\tswitch (a[i])\n\t\t\t{\n\t\t\tcase '5':\n\t\t\t\tb[i][0] = 0;\n\t\t\t\tb[i][1] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tb[i][0] = -1;\n\t\t\t\tb[i][1] = 0;\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\tb[i][0] = 0;\n\t\t\t\tb[i][1] = 1;\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tb[i][0] = 0;\n\t\t\t\tb[i][1] = -1;\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tb[i][0] = 1;\n\t\t\t\tb[i][1] = 0;\n\t\t\tdefault:\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tt[p[0]][p[1]] = 0;\n\t\tt2[g[0]][g[1]] = '.';\n\t\tint sum2 = 0;\n\t\tbool l = false;\n\t\tsolve(0, p[0], p[1], h, w, t2);\n\t\tint k = 0, x = g[0], y = g[1], sum = 0;\n\t\twhile (true) {\n\t\t\tx += b[k][0];\n\t\t\ty += b[k][1];\n\t\t\tk++;\n\t\t\tsum++;\n\t\t\tif (k >= a.length()) k = 0;\n\t\t\tx = max(0, min(x, h - 1));\n\t\t\ty = max(0, min(y, w - 1));\n\t\t\tif (t[x][y] <= sum) {\n\t\t\t\tcout << sum << \" \" << x << \" \" << y << endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (t3[x][y][k] == 1&&!l) {\n\t\t\t\tsum2 = 0;\n\t\t\t\tl = true;\n\t\t\t}\n\t\t\tif (t3[x][y][k] == 2) {\n\t\t\t\tif (sum2 == 0) {\n\t\t\t\t\tcout << \"impossible\" << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l&&t[x][y]!=inf) {\n\t\t\t\tsum2++;\n\t\t\t}\n\t\t\tt3[x][y][k]++;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[0][0] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 10000000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <climits>\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <list>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <iterator>\n#include <tuple>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define iter(c) __typeof__((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();++i)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nconst int INFTY=1<<29;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nint main()\n{\n\tfor(int h,w;cin>>h>>w,h|w;){\n\t\tvs grid(h);\n\t\trep(i,h) cin>>grid[i];\n\t\tstring p; cin>>p;\n\t\t\n\t\tvvi t(h,vi(w,INFTY));\n\t\tqueue<tuple<int,int,int>> q;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='A')\n\t\t\tq.emplace(i,j,0);\n\t\twhile(!q.empty()){\n\t\t\tauto cur=q.front(); q.pop();\n\t\t\tint ci=get<0>(cur),cj=get<1>(cur),ct=get<2>(cur);\n\t\t\tif(ci<0 || h<=ci || cj<0 || w<=cj || grid[ci][cj]=='#' || t[ci][cj]!=INFTY)\n\t\t\t\tcontinue;\n\t\t\tt[ci][cj]=ct;\n\t\t\trep(i,4) q.emplace(ci+\"\\xff\\x1\\0\\0\"[i],cj+\"\\0\\0\\xff\\x1\"[i],ct+1);\n\t\t}\n\t\t\n\t\tint ci=-1,cj=-1;\n\t\trep(i,h) rep(j,w) if(grid[i][j]=='B')\n\t\t\tci=i,cj=j;\n\t\tint res=INFTY;\n\t\tpii pos;\n\t\tfor(int ct=0,i=0;ct<1e6;ct++,i=(i+1)%p.size()){\n\t\t\tif(ct>=t[ci][cj]){\n\t\t\t\tres=ct;\n\t\t\t\tpos=mp(ci,cj);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint ni=ci,nj=cj;\n\t\t\tif(p[i]=='8') ni--;\n\t\t\tif(p[i]=='2') ni++;\n\t\t\tif(p[i]=='4') nj--;\n\t\t\tif(p[i]=='6') nj++;\n\t\t\tif(0<=ni && ni<h && 0<=nj && nj<w)\n\t\t\t\tci=ni,cj=nj;\n\t\t}\n\t\t\n\t\tif(res==INFTY)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse\n\t\t\tcout<<res<<' '<<pos.first<<' '<<pos.second<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\nint w,h;\nchar data[20][20];\nbool able[20][20];\nvector<int>  step[20][20];\nstring L;\nint mi,miy,mix;\nvector<int>::iterator it;\n\nqueue< pair<pair<int,int>,int> > que;\n\nvoid go(int y,int x,int dp){\n\tif(y-1>=0 && data[y-1][x]!='#'){\n\t\tque.push(mp(mp(y-1,x),dp));\n\t\tdata[y-1][x]='#';\n\t}\n\tif(y+1<h  && data[y+1][x]!='#'){\n\t\tque.push(mp(mp(y+1,x),dp));\n\t\tdata[y+1][x]='#';\n\t}\n\tif(x-1>=0 && data[y][x-1]!='#'){\n\t\tque.push(mp(mp(y,x-1),dp));\n\t\tdata[y][x-1]='#';\n\t}\n\tif(x+1<w  && data[y][x+1]!='#'){\n\t\tque.push(mp(mp(y,x+1),dp));\n\t\tdata[y][x+1]='#';\n\t}\n}\nvoid bfs(int y,int x,int dp){\n\tint wait;\n\tgo(y,x,dp+1);\n\n\tif(able[y][x]){\n\t\tit = lower_bound(step[y][x].begin(),step[y][x].end(),dp);\n\t\tif(it == step[y][x].end())return;\n\t\twait = *it-dp;\n\t\tif(dp+wait<mi){\n\t\t\tmi = dp+wait;\n\t\t\tmiy = y;\n\t\t\tmix = x;\n\t\t}\n\t}\n\n\twhile(!que.empty()){\n\t\ty = que.front().first.first;\n\t\tx = que.front().first.second;\n\t\tdp = que.front().second;\n\t\tque.pop();\n\t\tif(able[y][x]){\n\t\t\tit = lower_bound(step[y][x].begin(),step[y][x].end(),dp);\n\t\t\tif(it == step[y][x].end())return;\n\t\t\twait = *it-dp;\n\t\t\tif(dp+wait<mi){\n\t\t\t\tmi = dp+wait;\n\t\t\t\tmiy = y;\n\t\t\t\tmix = x;\n\t\t\t}\n\t\t}\n\t\tgo(y,x,dp+1);\n\t}\n}\n\nint main(){\n\tint sx,sy,gy,gx;\n\twhile(cin >> h >> w , h){\n\t\tmi = (1<<21);\n\t\tbool flag = true;\n\t\trep(i,20)rep(j,20){\n\t\t\table[i][j]=false;\n\t\t\tstep[i][j].clear();\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tcin >> data[i][j];\n\t\t\tif(data[i][j]=='A'){\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}\n\t\t\tif(data[i][j]=='B'){\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t}\n\t\t}\n\t\tcin >> L;\n\t\tint r = 0;\n\t\tfor(int k=0;k<40000;k++){\n\t\t\tfor(int i=0;i<L.size();i++){\n\t\t\t\table[gy][gx] = true;\n\t\t\t\tstep[gy][gx].push_back(r);\n\t\t\t\tswitch(L[i]){\n\t\t\t\tcase '5':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tif(gy-1>=0)gy-=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tif(gy+1<h)gy+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\t\tif(gx-1>=0)gx-=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\tif(gx+1<w)gx+=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\tbfs(sy,sx,0);\n\t\tif(mi != (1<<21) ){\n\t\t\tcout << mi << \" \" << miy << \" \" << mix << endl;\n\t\t}else{\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define mp make_pair\nint w,h;\nchar data[20][20];\nbool able[20][20];\nvector<int>  step[20][20];\nstring L;\nint mi,miy,mix;\nvector<int>::iterator it;\n\nqueue< pair<pair<int,int>,int> > que;\n\nvoid go(int y,int x,int dp){\n\tif(y-1>=0 && data[y-1][x]!='#'){\n\t\tque.push(mp(mp(y-1,x),dp));\n\t\tdata[y-1][x]='#';\n\t}\n\tif(y+1<h  && data[y+1][x]!='#'){\n\t\tque.push(mp(mp(y+1,x),dp));\n\t\tdata[y+1][x]='#';\n\t}\n\tif(x-1>=0 && data[y][x-1]!='#'){\n\t\tque.push(mp(mp(y,x-1),dp));\n\t\tdata[y][x-1]='#';\n\t}\n\tif(x+1<w  && data[y][x+1]!='#'){\n\t\tque.push(mp(mp(y,x+1),dp));\n\t\tdata[y][x+1]='#';\n\t}\n}\nvoid bfs(int y,int x,int dp){\n\tint wait;\n\tgo(y,x,dp+1);\n\n\tif(able[y][x]){\n\t\tit = lower_bound(step[y][x].begin(),step[y][x].end(),dp);\n\t\tif(it == step[y][x].end())return;\n\t\twait = *it-dp;\n\t\tif(dp+wait<mi){\n\t\t\tmi = dp+wait;\n\t\t\tmiy = y;\n\t\t\tmix = x;\n\t\t}\n\t}\n\n\twhile(!que.empty()){\n\t\ty = que.front().first.first;\n\t\tx = que.front().first.second;\n\t\tdp = que.front().second;\n\t\tque.pop();\n\t\tif(able[y][x]){\n\t\t\tit = lower_bound(step[y][x].begin(),step[y][x].end(),dp);\n\t\t\tif(it == step[y][x].end())return;\n\t\t\twait = *it-dp;\n\t\t\tif(dp+wait<mi){\n\t\t\t\tmi = dp+wait;\n\t\t\t\tmiy = y;\n\t\t\t\tmix = x;\n\t\t\t}\n\t\t}\n\t\tgo(y,x,dp+1);\n\t}\n}\n\nint main(){\n\tint sx,sy,gy,gx;\n\twhile(cin >> h >> w , h){\n\t\tmi = (1<<21);\n\t\tbool flag = true;\n\t\trep(i,20)rep(j,20){\n\t\t\table[i][j]=false;\n\t\t\tstep[i][j].clear();\n\t\t}\n\n\t\trep(i,h)rep(j,w){\n\t\t\tcin >> data[i][j];\n\t\t\tif(data[i][j]=='A'){\n\t\t\t\tsy = i;\n\t\t\t\tsx = j;\n\t\t\t}\n\t\t\tif(data[i][j]=='B'){\n\t\t\t\tgy = i;\n\t\t\t\tgx = j;\n\t\t\t}\n\t\t}\n\t\tcin >> L;\n\t\tint r = 0;\n\t\tfor(int k=0;k<1000;k++){\n\t\t\tfor(int i=0;i<L.size();i++){\n\t\t\t\table[gy][gx] = true;\n\t\t\t\tstep[gy][gx].push_back(r);\n\t\t\t\tswitch(L[i]){\n\t\t\t\tcase '5':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tif(gy-1>=0)gy-=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tif(gy+1<h)gy+=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\t\tif(gx-1>=0)gx-=1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\tif(gx+1<w)gx+=1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tr++;\n\t\t\t}\n\t\t}\n\t\tbfs(sy,sx,0);\n\t\tif(mi != (1<<21) ){\n\t\t\tcout << mi << \" \" << miy << \" \" << mix << endl;\n\t\t}else{\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int h,w;\n  string g[30],p;\n  int t[30][30];\n\n  while(cin >> h >> w , h||w){\n    int ay,ax,by,bx;\n    for(int i=0;i<h;i++){\n      cin >> g[i];\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == 'A'){ay = i; ax = j; g[i][j] = '.';}\n\tif(g[i][j] == 'B'){by = i; bx = j; g[i][j] = '.';}\n\tt[i][j] = -1;\n      }\n    }\n\n    cin >> p;\n    int s = p.size();\n\n    t[ay][ax] = 0;\n    queue<P> q;\n    q.push(P(ay,ax));\n    int m;\n\n    while(q.size()){\n      P p = q.front();q.pop();\n      int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\n      for(int i=0;i<4;i++){\n\tint ty = p.first + dy[i], tx = p.second + dx[i];\n\tif(ty<0 || tx<0 || h<=ty || w<=tx || g[ty][tx] == '#')continue;\n\tif(t[ty][tx]<0){\n\t  m = t[ty][tx] = t[p.first][p.second] + 1;\n\t  q.push(P(ty,tx));\n\t}\n      }\n    }\n\n    bool f = false;\n    for(int cnt=0;cnt<100000;cnt++){\n      if(p[cnt%s]=='8' && 0<by)by--;\n      if(p[cnt%s]=='6' && bx<w-1)bx++;\n      if(p[cnt%s]=='4' && 0<bx)bx--;\n      if(p[cnt%s]=='2' && by<h-1)by++;\n      if(0<=t[by][bx] && t[by][bx]<=cnt+1){\n\tcout << cnt+1 << \" \" << by << \" \" << bx << endl;\n\tf = true;\n\tbreak;\n      }\n    }\n    if(!f)cout << \"Impossible\\n\";\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-1;for(i=1;i<=h;i++){for(j=1;j<=w;j++)f[x=i*22+j]=-2,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-1;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-2)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];f[b]>=0&&++z)++t,~f[j=b-54+\"L65676 \"[p[i++]-50]]?b=j:0,f[b]>=0&t>=f[b]?a=b:0;!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(~a?\"%d %d %d\\n\":\"impossible\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define mp(a,b,c) make_pair(make_pair(a,b),c)\n\nint h,w,sx,sy,gx,gy,m=999999;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(mp(sx, sy, 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(mp(nx, ny, p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;int i=j%pat.length();j++,go++){\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>1000000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdint>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <queue>\n\nconst size_t di[]={size_t(-1), 0, 1, 0};\nconst size_t dj[]={0, size_t(-1), 0, 1};\nconst int INF=1e9;\nconst size_t dti[]={0, 0, 1, 0, 0, 0, 0, 0, size_t(-1)};\nconst size_t dtj[]={0, 0, 0, 0, size_t(-1), 0, 1, 0, 0};\n\nint testcase_ends() {\n  size_t H, W;\n  scanf(\"%zu %zu\", &H, &W);\n\n  if (H == 0 && W == 0)\n    return 1;\n\n  std::vector<std::string> s(H);\n  size_t si=-1, sj=-1;\n  size_t ti=-1, tj=-1;\n  for (size_t i=0; i<H; ++i) {\n    char buf[128];\n    scanf(\"%s\", buf);\n    s[i] = buf;\n    for (size_t j=0; j<W; ++j) {\n      if (s[i][j] == 'A') {\n        si = i;\n        sj = j;\n      } else if (s[i][j] == 'B') {\n        ti = i;\n        tj = j;\n      }\n    }\n  }\n\n  char buf[128];\n  scanf(\"%s\", buf);\n  std::string t=buf;\n\n  std::queue<std::pair<size_t, size_t>> q;\n  q.emplace(si, sj);\n  std::vector<std::vector<int>> dp(H, std::vector<int>(W, INF));\n  dp[si][sj] = 0;\n  while (!q.empty()) {\n    std::pair<size_t, size_t> p=q.front();\n    q.pop();\n    size_t i=p.first, j=p.second;\n    for (size_t k=0; k<4; ++k) {\n      size_t ni=i+di[k], nj=j+dj[k];\n      if (!(ni < H && nj < W)) continue;\n      if (s[ni][nj] == '#') continue;\n      if (dp[ni][nj] <= dp[i][j] + 1) continue;\n      dp[ni][nj] = dp[i][j] + 1;\n      q.emplace(ni, nj);\n    }\n  }\n\n  // for (size_t i=0; i<H; ++i)\n  //   for (size_t j=0; j<W; ++j)\n  //     if (dp[i][j] < INF)\n  //       printf(\"%d%c\", dp[i][j], j+1<W? ' ':'\\n');\n  //     else\n  //       printf(\"#%c\", j+1<W? ' ':'\\n');\n\n  size_t tlen=t.length();\n  std::pair<size_t, size_t> res(-1, -1);\n  int tt=INF;\n  for (int i=0; i<1000; ++i) {\n    size_t nti=ti+dti[t[i%tlen]-'0'];\n    size_t ntj=tj+dtj[t[i%tlen]-'0'];\n    if (nti < H) ti = nti;\n    if (ntj < W) tj = ntj;\n    if (dp[ti][tj] < INF) {\n      if (dp[ti][tj] > i+1) continue;\n      if (i+1 < tt) {\n        tt = i+1;\n        res = {ti, tj};\n      }\n    }\n  }\n  if (tt < INF)\n    return !printf(\"%d %zu %zu\\n\", tt, res.first, res.second);\n  printf(\"impossible\\n\");\n  return 0;\n}\n\nint main() {\n  while (!testcase_ends()) {}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define MP make_pair\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\n#define SET(a,c) memset(a,c,sizeof(a))\n\n#define DEBUG(x) cout<<\"#x\"<<\": \"<<x<<endl\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\n\nconst ll INF = INT_MAX/3;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-14;\nconst int dx[] = {1,0,-1,0} , dy[] = {0,1,0,-1};\n\nint h,w;\nint board[21][21];\nvector<string> ss;\n\nvoid moveG(int &x,int &y,char p){\n    int tx,ty;\n    tx = x;\n    ty = y;\n    if(p == '5'){\n\treturn;\n    }else if(p == '8'){\n\tif(y > 0)\n\t    y--;\n    }else if(p == '6'){\n\tif(x < w-1)\n\t    x++;\n    }else if(p == '4'){\n\tif(x > 0)\n\t    x--;\n    }else if(p == '2'){\n\tif(y < h-1)\n\t    y++;\n    }\n\n}\nint main(){\n    while(true){\n\tcin >> h >> w;\n\tif(h == 0 && w == 0) break;\n\tstring pattern;\n\tss = vector<string>(h);\n\tREP(i,h) cin >> ss[i];\n\tcin >> pattern;\n\n\tint sx,sy,gx,gy;\n\tint ans = 0;\n\tREP(i,h)REP(j,w){\n\t    board[i][j] = INF;\n\t    if(ss[i][j] == 'A'){\n\t\tsx = j;\n\t\tsy = i;\n\t    }else if(ss[i][j] == 'B'){\n\t\tgx = j;\n\t\tgy = i;\n\t    }\n\t}\n\n\tbool flg = false;\n\tint p = 0;\n\tint t = 0;\n\tboard[sy][sx] = 0;\n\tqueue<int> qx;\n\tqueue<int> qy;\n\tqx.push(sx);\n\tqy.push(sy);\n\twhile(!qx.empty()){\n\t    int x = qx.front();\n\t    int y = qy.front();\n\t    qx.pop();\n\t    qy.pop();\n\t    int v = board[y][x]+1;\n\t    REP(i,4){\n\t\tint nx = x + dx[i];\n\t\tint ny = y + dy[i];\n\t\tif(nx < 0 || w <= nx || ny < 0 || h <= ny || ss[ny][nx] == '#') continue;\n\t\tif(board[ny][nx] > v){\n\t\t    board[ny][nx] = v;\n\t\t    qx.push(nx);\n\t\t    qy.push(ny);\n\t\t}\n\t    }\n\t}\n\tbool u[31][31];\n\tREP(i,31)REP(j,31) u[i][j] = false;\n\twhile(t < 1000){\n\t    if(board[gy][gx] <= t ){\n\t\tprintf(\"%d %d %d\\n\",t,gy,gx);\n\t\tflg = true;\n\t\tbreak;\n\t    }\n\t    moveG(gx,gy,pattern[p]);\n\t    p = (p+1) % pattern.size();\n\t    t++;\n\t}\n\tif(!flg) cout << \"impossible\" << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(i=0;i++<h;f[i*22]=f[i*22-~w]=-1,getchar())for(j=0;j++<w;z-35?z>65?b=x:z>64?a=x:1:--f[x])f[j]=f[j-~h*22]=-1,f[x=i*22+j]=-2,z=getchar();f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-2)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];f[b]>=0&&++z)++t,~f[j=b-54+\"L65676 \"[p[i++]-50]]?b=j:0,f[b]>=0&t>=f[b]?a=b:0;!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(~a?\"%d %d %d\\n\":\"impossible\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n \nusing namespace std;\n \n#define MAX 20\n#define INF 1e9\n \nint H,W,ax,ay,bx,by;\nchar field[MAX][MAX];\nstring str;\nconst int dx[] = {-1,0,0,1,0};\nconst int dy[] = {0,-1,1,0,0};\n \nstruct State{\n    int sx,sy,gx,gy;\n    State(int sx,int sy,int gx,int gy) : sx(sx),sy(sy),gx(gx),gy(gy) {}\n};\n \nbool inField(int y,int x){\n    return 0 <= y && y < H && 0 <= x && x < W;\n}\n \nint getDir(char ch){\n    if(ch == '4') return 0;\n    if(ch == '8') return 1;\n    if(ch == '2') return 2;\n    if(ch == '6') return 3;\n    return 4;\n}\n \nvoid bfs(){\n    int size = str.size();\n    bool visited[MAX][MAX][MAX][MAX][MAX];\n    memset(visited,0,sizeof(visited));\n    visited[ay][ax][by][bx][0] = true;\n    queue<State> Q;\n    queue<int> Count;\n    Q.push(State(ax,ay,bx,by));\n    Count.push(0);\n    while(!Q.empty()){\n\tState s = Q.front(); Q.pop();\n\tint cnt = Count.front(); Count.pop();\n \n\tif(s.sx == s.gx && s.sy == s.gy){\n\t    cout << cnt << \" \" << s.sy << \" \" << s.sx << endl;\n\t    return;\n\t}\n \n\tint dir = getDir(str[cnt%size]);\n\tint Gx = s.gx + dx[dir], Gy = s.gy + dy[dir];\n\tif(!inField(Gy,Gx)) Gx = s.gx, Gy = s.gy;\n \n\tfor(int i = 0 ; i < 5 ; i++){\n\t    int nx = s.sx + dx[i], ny = s.sy + dy[i];\n\t    if(!inField(ny,nx)) continue;\n\t    if(field[ny][nx] == '#') continue;\n\t    if(visited[ny][nx][Gy][Gx][(cnt+1)%size]) continue;\n\t    visited[ny][nx][Gy][Gx][(cnt+1)%size] = true;\n\t    Q.push(State(nx,ny,Gx,Gy));\n\t    Count.push(cnt+1);\n\t}\n    }\n    cout << \"impossible\" << endl;\n}\n \nint main(){\n    while(cin >> H >> W, (H|W)){\n\tfor(int i = 0 ; i < H ; i++){\n\t    for(int j = 0 ; j < W ; j++){\n\t\tcin >> field[i][j];\n\t\tif(field[i][j] == 'A'){\n\t\t    ax = j, ay = i;\n\t\t}else if(field[i][j] == 'B'){\n\t\t    bx = j, by = i;\n\t\t}\n\t    }\n\t}\n\tcin >> str;\n\tbfs();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <complex>\n#include <map>\n\nusing namespace std;\n\ntypedef complex<int> P;\n\n#define INF 1 << 16\n\nint main() {\n\tint H, W;\n\twhile (cin >> H >> W, H || W) {\n\t\tint m[20][20];\n\t\tint sx, sy, gx, gy;\n\t\tfor (int y = 0; y < H; ++y) {\n\t\t\tstring str; cin >> str;\n\t\t\tfor (int x = 0; x < W; ++x)\n\t\t\t\tm[y][x] =\n\t\t\t\t\t  str[x] == '#' ? 1\n\t\t\t\t\t: str[x] == 'A' ? (sx = x, sy = y, 0)\n\t\t\t\t\t: str[x] == 'B' ? (gx = x, gy = y, 0)\n\t\t\t\t\t: 0\n\t\t\t\t\t;\n\t\t}\n\t\tstring pattern; cin >> pattern;\n\n\t\tint step[20][20]; fill(&step[0][0], &step[0][0]+20*20, INF);\n\t\tqueue<P> que; que.push( P(sx, sy) );\n\t\tqueue<int> steps; steps.push( 0 );\n\t\twhile ( !que.empty() ) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tint s = steps.front(); steps.pop();\n\t\t\tint x = p.real(), y = p.imag();\n\n\t\t\tif (x < 0 || x >= W || y < 0 || y >= H) continue;\n\t\t\tif (m[y][x]) continue;\n\t\t\tif (s >= step[y][x]) continue;\n\n\t\t\tstep[y][x] = s;\n\n\t\t\tque.push( P(x+1, y) ); steps.push(s+1);\n\t\t\tque.push( P(x-1, y) ); steps.push(s+1);\n\t\t\tque.push( P(x, y+1) ); steps.push(s+1);\n\t\t\tque.push( P(x, y-1) ); steps.push(s+1);\n\t\t}\n\n\t\tmap<char, P> dir;\n\t\tdir['8'] = P(0, -1);\n\t\tdir['4'] = P(-1, 0);\n\t\tdir['5'] = P(0, 0);\n\t\tdir['6'] = P(1, 0);\n\t\tdir['2'] = P(0, 1);\n\n\t\tint t = 0;\n\t\tP pos = P(gx, gy), ans;\n\t\tbool flag = false;\n\t\twhile (++t < INF) {\n\t\t\tP next = dir[pattern[(t-1)%pattern.size()]];\n\t\t\tpos += next;\n\n\t\t\tif (pos.real() < 0 || pos.real() >= W || pos.imag() < 0 || pos.imag() >= H) pos -= next;\n\n\t\t\tif (step[pos.imag()][pos.real()] <= t) {\n\t\t\t\tans = pos;\n\t\t\t\tflag = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (flag) cout << t << \" \" << ans.imag() << \" \" << ans.real() << endl;\n\t\telse cout << \"impossible\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<queue>\n#include<string>\n#include<limits.h>\n#define N 100\n\nusing namespace std;\nstruct Point{int y, x;};\n\nint Calc[N][N],H,W,SaveX[1],SaveY[1];\nchar Input[N][N];\nstring Action;\n\nint BFS();\n\n\nint main(){\n  int i,j,Ghostcount=0,Ghost=0,GSaveX[1],GSaveY[1],ImpossibleCount=0,flag=0,ImpossibleSaveX,ImpossibleSaveY;\n\n  while(1){\n\n  cin >> H >> W;\n  if(H == 0 && W == 0)break;\n\n\n\n\n\n  for(i=0;i<H;i++){\n    for(j=0;j<W;j++){\n      cin >> Input[i][j];\n      if(Input[i][j] == 'A'){\n        Calc[i][j]=0;\n        SaveX[0]=j;\n        SaveY[0]=i;\n      }\n      else if(Input[i][j] == '#')Calc[i][j]=-1;\n      else if(Input[i][j] == '.' )Calc[i][j]=INT_MAX;\n      else if(Input[i][j] == 'B'){\n        Calc[i][j]=INT_MAX;\n        GSaveX[0]=j;\n        GSaveY[0]=i;\n      }\n    }\n  }\n  \n \n  cin >> Action;\n\n    Ghostcount=Action.length();     \n    /* cout << Ghostcount <<\"--Ghostcount\" <<endl; */\n   \n  \n\n  \n\n  BFS();\n  /*\n  cout << endl;\n  \n  cout << \"Input\" << endl;\n  for(i=0;i<H;i++){\n    for(j=0;j<W;j++){\n      printf(\"%c \",Input[i][j]);\n    }\n    cout << endl;\n  }\n\n  cout << endl;  \n\n  cout << \"Calc\" << endl;\n  for(i=0;i<H;i++){\n    for(j=0;j<W;j++){\n      printf(\"%d \",Calc[i][j]);\n    }\n    cout << endl;\n  }\n  \n  cout << endl;\n*/\n\n  Ghost=0;\n \n  ImpossibleSaveX = GSaveX[0]; \n  ImpossibleSaveY = GSaveY[0];\n  /* cout << \"úÌImpossibleSaveY--\" << ImpossibleSaveY << endl;\n     cout << \"úÌImpossibleSaveX--\" << ImpossibleSaveX << endl;*/\n \n  i=0;\n  while(1){\n    if(Action[i] == '8'){\n      if(GSaveY[0]-1 < 0){}\n      else{GSaveY[0]=GSaveY[0]-1;}\n}\n    else if(Action[i] == '4'){\n      if(GSaveX[0]-1 < 0 ){}\n      else{GSaveX[0]=GSaveX[0]-1;}\n} \n    else if(Action[i] == '2'){\n      if(GSaveY[0]+1 > H-1){}\n      else{GSaveY[0]=GSaveY[0]+1;}\n} \n    else if(Action[i] == '6'){\n      if(GSaveX[0]+1 > W-1){}\n      else{GSaveX[0]=GSaveX[0]+1;}\n}\n    else if(Action[i] == '5'){}\n    /* cout << \"GSaveY[0]--\" << GSaveY[0] << endl;\n       cout << \"GSaveX[0]--\" << GSaveX[0] << endl; */\n    Ghost+=1;\n\n    \n    /* cout << \"i:\"<<i << \" \" << \"Action[\"<<i<<\"]:\" << Action[i] << endl;\n   \n       cout << \"Ghost--\" << Ghost << endl;*/\n\n    if((Ghost >= Calc[GSaveY[0]][GSaveX[0]]) && Calc[GSaveY[0]][GSaveX[0]] != -1 ){\n      if(Calc[GSaveY[0]][GSaveX[0]] == 0){ cout << Ghost << \" \" << GSaveY[0] << \" \" << GSaveX[0] << endl;}\n      else{ cout << Ghost << \" \" << GSaveY[0] << \" \" << GSaveX[0] << endl;}\n      break;\n    }\n\n    if((Calc[GSaveY[0]][GSaveX[0]] != -1) && (Calc[GSaveY[0]][GSaveX[0]] != INT_MAX))flag=1;  /*ålöªÊêéÆ±ëª êÎtOON*/\n       \n\n    /*\n    if(){\n      cout << \"impossible\" << endl;\n      break; \n    }    \n    */\n\n    \n    if(Ghostcount == i){\n      if( (GSaveY[0] == ImpossibleSaveY) &&(GSaveX[0] == ImpossibleSaveX) &&  (Calc[GSaveY[0]][GSaveX[0]] == -1 || Calc[GSaveY[0]][GSaveX[0]] == INT_MAX) && flag == 0){ \n\t/*\tcout << \"Calc[GSaveY[0]][GSaveX[0]] --\" << Calc[GSaveY[0]][GSaveX[0]] << endl;\n\t\tcout << \"Calc[ImpossibleSaveY][ImpossibleSaveX]--\" << Calc[ImpossibleSaveY][ImpossibleSaveX]  << endl;*/\n\n\tcout << \"impossible\" << endl;\n\tbreak;\n      }\n      ImpossibleSaveY = GSaveY[0];\n      ImpossibleSaveX = GSaveX[0];\n     /* cout << \"ImpossibleSaveY--\" << ImpossibleSaveY << endl;\n\tcout << \"ImpossibleSaveX--\" << ImpossibleSaveX << endl; */\n      i=0;\n      flag=0;\n      \n    }\n\n    \n\n\n    i++;\n\n   \n    \n    if(Ghostcount == i){\n      if( (GSaveY[0] == ImpossibleSaveY) &&(GSaveX[0] == ImpossibleSaveX) &&  (Calc[GSaveY[0]][GSaveX[0]] == -1 || Calc[GSaveY[0]][GSaveX[0]] == INT_MAX) && flag == 0){ \n\t/*\tcout << \"Calc[GSaveY[0]][GSaveX[0]] --\" << Calc[GSaveY[0]][GSaveX[0]] << endl;\n\t\tcout << \"Calc[ImpossibleSaveY][ImpossibleSaveX]--\" << Calc[ImpossibleSaveY][ImpossibleSaveX]  << endl; */\n\n\tcout << \"impossible\" << endl;\n\tbreak;\n      }\n      ImpossibleSaveY = GSaveY[0];\n      ImpossibleSaveX = GSaveX[0];\n      /* cout << \"ImpossibleSaveY--\" << ImpossibleSaveY << endl;\n\t cout << \"ImpossibleSaveX--\" << ImpossibleSaveX << endl; */\n      i=0;\n      flag=0;\n      \n    }\n\n    \n\n\n\n\n   \n  }\n\n\n\n  }\n  \n  \n\n  return 0;\n}\n\n\n\n\n\nint BFS(){\n  Point u,v;\n  queue<Point> Q;\n  int ny,nx;\n  int dy[4]={0,-1,0,1};\n  int dx[4]={1,0,-1,0};\n\n  u.y=SaveY[0];\n  u.x=SaveX[0];\n  Calc[u.y][u.x]=0; \n  Q.push(u);\n\n  while(!Q.empty()){\n    u= Q.front();\n    Q.pop();\n    /*if(u.y == H-1 && u.x == W-1) return Calc[u.y][u.x];*/\n    for(int r=0 ; r<4 ; r++ ){\n      nx = u.x + dx[r];\n      ny = u.y + dy[r];\n      if(  nx < 0 || ny < 0 || ny >= H || nx >= W )continue;\n          if(Calc[ny][nx] != INT_MAX ) continue;\n          if(Calc[ny][nx] == -1)continue; \n          Calc[ny][nx] = Calc[u.y][u.x] + 1;\n          v.x = nx;\n          v.y = ny;\n          Q.push(v);\n          }\n    }\n\n    return -1;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        memset(visited, 0, sizeof(visited));\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pair<pair<int,int>,int> p = q.front();\n            if(visited[p.first.second][p.first.first]){\n                continue;\n            }\n            visited[p.first.second][p.first.first]=1;\n            co[p.first.second][p.first.first]=p.second;\n           // cout<<p.first.second<<\"  \"<<p.first.first<<\"  \"<<p.second<<endl;\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX&&ma[ny][nx]!='A'&&!visited[ny][nx]){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n        }\n        string pat;\n        cin>>pat;\n//        int go=0;\n//        for(int j=0;;j++){\n//            int i=j%pat.length();\n//         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n//            if(co[gy][gx]<=go){\n//                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n//                break;\n//            }\n//            if(go>1000){\n//                cout<<\"impossible\"<<endl;\n//                break;\n//            }\n//            if(pat[i]=='5'){\n//                \n//            } else if(pat[i]=='8'){\n//                gy--;\n//            } else if(pat[i]=='6'){\n//                gx++;\n//            } else if(pat[i]=='4'){\n//                gx--;\n//            } else if(pat[i]=='2'){\n//                gy++;\n//            }\n//            gy=max(0,gy);\n//            gy=min(h-1,gy);\n//            gx=max(0,gx);\n//            gx=min(w-1,gx);\n//            go++;\n//        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nchar g[20][20];\nint h,w;\nint t[20][20];\n\nstruct S{\n  int t,x,y;\n};\n\nint main(){\n  while(cin>>h>>w,h|w){\n    int ax,ay,bx,by;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n\tif(g[y][x]=='A'){\n\t  ax=x;\n\t  ay=y;\n\t}else if(g[y][x]=='B'){\n\t  bx=x;\n\t  by=y;\n\t}\n      }\n    }\n    fill(t[0],t[20],1<<30);\n    queue<S> que;\n    S is={0,ax,ay};\n    que.push(is);\n    while(!que.empty()){\n      int x=que.front().x;\n      int y=que.front().y;\n      int ct=que.front().t;\n      que.pop();\n      if(t[y][x]<=ct)continue;\n      t[y][x]=ct;\n      for(int i=0;i<4;i++){\n\tint d[]={0,1,0,-1,0};\n\tint nx=x+d[i];\n\tint ny=y+d[i+1];\n\tif(nx<0||w<=nx||ny<0||h<=ny||t[ny][nx]<=ct+1||g[ny][nx]=='#')continue;\n\tS ns={ct+1,nx,ny};\n\tque.push(ns);\n      }\n    }\n    string p;\n    cin>>p;\n    int e;\n    for(e=0;e<10000;e++){\n      if(t[by][bx]<=e)break;\n      char o=p[e%p.size()];\n      int ny=by+(o=='2')-(o=='8');\n      int nx=bx+(o=='6')-(o=='4');\n      if(0<=ny&&ny<h&&0<=nx&&nx<w){\n\tby=ny;\n\tbx=nx;\n      }\n    }\n    if(e<10000){\n      cout<<e<<' '<<by<<' '<<bx<<endl;\n    }else{\n      cout<<\"impossible\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        memset(visited, 0, sizeof(visited));\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pair<pair<int,int>,int> p = q.front();\n            visited[p.first.second][p.first.first]=1;\n            co[p.first.second][p.first.first]=p.second;\n           // cout<<p.first.second<<\"  \"<<p.first.first<<\"  \"<<p.second<<endl;\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX&&ma[ny][nx]!='A'&&!visited[ny][nx]){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n        }\n        string pat;\n        cin>>pat;\n        int go=0;\n        for(int j=0;;j++){\n            int i=j%pat.length();\n         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>1000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='5'){\n                \n            } else if(pat[i]=='8'){\n                gy--;\n            } else if(pat[i]=='6'){\n                gx++;\n            } else if(pat[i]=='4'){\n                gx--;\n            } else if(pat[i]=='2'){\n                gy++;\n            }\n            gy=max(0,gy);\n            gy=min(h-1,gy);\n            gx=max(0,gx);\n            gx=min(w-1,gx);\n            go++;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\nint dd[]={0,1,0,-1,0};\nbool check(int a,int b){\n\tif(0<=a&&a<h&&0<=b&&b<w) return true;\n\treturn false;\n}\nvoid bfs(pii p,int x,vector<string> &v,vvint &vv){\n\tif(vv[p.F][p.S]>=0) return;\n\tvv[p.F][p.S]=x;\n\trep(i,4){\n\t\tpii ne=pii(p.F+dd[i],p.S+dd[i+1]);\n\t\tif(!check(ne.F,ne.S)||v[ne.F][ne.S]=='#') continue;\n\t\tbfs(ne,x+1,v,vv);\n\t}\n}\nvoid mainmain(){\n\tvector<pii> vec(10);\n\tvec[2]=pii(1,0);\n\tvec[4]=pii(0,-1);\n\tvec[5]=pii(0,0);\n\tvec[6]=pii(0,1);\n\tvec[8]=pii(-1,0);\n\twhile(cin>>h>>w,h||w){\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tstring s;\n\t\tcin>>s;\n\t\tvvint vv;\n\t\tinitvv(vv,h,w,-1);\n\t\tpii A,B;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='A'){\n\t\t\t\t\tA=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t\tif(v[i][j]=='B'){\n\t\t\t\t\tB=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(A,0,v,vv);\n\t\tint ans=-1;\n\t\tpii pos;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\t// printf(\"%2d \",vv[i][j]);\n\t\t\t\tif(vv[i][j]==-1) vv[i][j]=INF;\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\trep(i,6*1e6){\n\t\t\t// cout<<i<<\" \"<<B.F<<\" \"<<B.S<<endl;\n\t\t\tif(vv[B.F][B.S]<=i){\n\t\t\t\tans=i;\n\t\t\t\tpos=B;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint t=s[i%s.size()]-'0';\n\t\t\tpii ne=pii(B.F+vec[t].F,B.S+vec[t].S);\n\t\t\tif(check(ne.F,ne.S)){\n\t\t\t\tB=ne;\n\t\t\t}\n\t\t}\n\t\tif(ans==-1){\n\t\t\tcout<<\"impossible\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<ans<<\" \"<<pos.F<<\" \"<<pos.S<<endl;\n\t\t}\n\t\t// return;\n\t}\n}\n\n\nsigned main() {\n\t// ios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\nint m = 999999;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;;j++,go++){\n            int i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>100){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H,W;\n\nint diff_row[5] = {-1,0,0,1,0},diff_col[5] = {0,-1,1,0,0};\nchar map[20][21],pattern[11];\nbool***** check;\n\nstruct Info{\n\tint my_row,my_col,my_time,enemy_row,enemy_col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tbool FLG;\n\tint ans_row,ans_col,ans_time,next_my_row,next_my_col,next_enemy_row,next_enemy_col,pattern_length,tmp;\n\tcheck = new bool****[20];\n\tfor(int i = 0; i < 20; i++){\n\t\tcheck[i] = new bool***[20];\n\t\tfor(int a = 0; a < 20; a++){\n\t\t\tcheck[i][a] = new bool**[20];\n\t\t\tfor(int b = 0; b < 20; b++){\n\t\t\t\tcheck[i][a][b] = new bool*[20];\n\t\t\t\tfor(int c = 0; c < 20; c++)check[i][a][b][c] = new bool[10];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tFLG = false;\n\t\tInfo first;\n\n\t\tfirst.my_time = 0;\n\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++){\n\t\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\t\tfor(int e = 0; e < 10;e++)check[a][b][c][d][e] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",map[i]);\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tswitch(map[i][k]){\n\t\t\t\tcase 'A':\n\t\t\t\t\tfirst.my_row = i;\n\t\t\t\t\tfirst.my_col = k;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tfirst.enemy_row = i;\n\t\t\t\t\tfirst.enemy_col = k;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:break;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\",pattern);\n\t\tfor(pattern_length = 0; pattern[pattern_length] != '\\0';pattern_length++);\n\n\t\tqueue<Info> Q;\n\n\t\tQ.push(first);\n\n\t\tint debug = 0;\n\n\t\twhile(!Q.empty()){\n\n\t\t\tdebug++;\n\t\t\tif(debug > 100){\n\t\t\t\tprintf(\"Minhi!\\n\");\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tif(Q.front().my_row == Q.front().enemy_row && Q.front().my_col == Q.front().enemy_col){\n\t\t\t\tFLG = true;\n\t\t\t\tans_row = Q.front().my_row;\n\t\t\t\tans_col = Q.front().my_col;\n\t\t\t\tans_time = Q.front().my_time;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tQ.front().my_time++;\n\n\t\t\ttmp = (Q.front().my_time-1+pattern_length)%pattern_length;\n\t\t\tswitch(pattern[tmp]){\n\t\t\tcase '5':\n\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row+1,Q.front().enemy_col)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row+1;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row,Q.front().enemy_col-1)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col-1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row,Q.front().enemy_col+1)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col+1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row-1,Q.front().enemy_col)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row-1;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tnext_my_row = Q.front().my_row + diff_row[i];\n\t\t\t\tnext_my_col = Q.front().my_col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(next_my_row,next_my_col) == true && map[next_my_row][next_my_col] != '#' &&\n\t\t\t\t\t\tcheck[next_my_row][next_my_col][next_enemy_row][next_enemy_col][tmp] == false){\n\t\t\t\t\tcheck[next_my_row][next_my_col][next_enemy_row][next_enemy_col][tmp] = true;\n\t\t\t\t\tInfo next;\n\t\t\t\t\tnext.enemy_row = next_enemy_row;\n\t\t\t\t\tnext.enemy_col = next_enemy_col;\n\t\t\t\t\tnext.my_row = next_my_row;\n\t\t\t\t\tnext.my_col = next_my_col;\n\t\t\t\t\tnext.my_time = Q.front().my_time;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}else{\n\t\t\t\t\tif(check[Q.front().my_row][Q.front().my_col][next_enemy_row][next_enemy_col][tmp] == false){\n\t\t\t\t\t\tcheck[Q.front().my_row][Q.front().my_col][next_enemy_row][next_enemy_col][tmp] = true;\n\t\t\t\t\t\tInfo next;\n\t\t\t\t\t\tnext.enemy_row = next_enemy_row;\n\t\t\t\t\t\tnext.enemy_col = next_enemy_col;\n\t\t\t\t\t\tnext.my_row = Q.front().my_row;\n\t\t\t\t\t\tnext.my_col = Q.front().my_col;\n\t\t\t\t\t\tnext.my_time = Q.front().my_time;\n\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"impossible\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d %d %d\\n\",ans_time,ans_row,ans_col);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n#include <string.h>\nusing namespace std;\n\ntypedef pair<int,int> P;//y,x\n\nconst int dx[] = {1,0,-1,0,0};//東、南、西、北、無\nconst int dy[] = {0,1,0,-1,0};\n\nint gdx[10];\nint gdy[10];\nint field[22][22];\n\nint cost[22][22][22][22][10];\n\nstruct S\n{\n\tP m;\n\tP g;\n\tint gp;\n\tS(P m_,P g_,int gp_):m(m_),g(g_),gp(gp_){}\n};\n\nint main(void)\n{\n\tgdx[5]=0;gdx[8]=0;gdx[6]=1;gdx[4]=-1;gdx[2]=0;\n\tgdy[5]=0;gdy[8]=-1;gdy[6]=0;gdy[4]=0;gdy[2]=1;\n\twhile(1){\n\t\tmemset(cost,-1,sizeof(cost));\n\t\tmemset(field,0,sizeof(field));\n\t\tP ms,gs;\n\t\tvector<int> gp;\n\t\tint W,H;\n\t\tcin >> H >> W;\n\t\tif(H==0 && W==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=H;++y){\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tfor(int x=1;x<=W;++x){\n\t\t\t\tfield[y][x] = in[x-1];\n\t\t\t\tif(field[y][x] == 'A'){\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t\tms.first = y;\n\t\t\t\t\tms.second = x;\n\t\t\t\t}\n\t\t\t\tif(field[y][x] == 'B'){\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t\tgs.first = y;\n\t\t\t\t\tgs.second = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring in;\n\t\tcin >> in;\n\t\tfor(int i=0;i<in.size();++i){\n\t\t\tgp.push_back(in[i]-'0');\n\t\t}\n\t\t////////////////////////////////////////\n\t\tqueue<S> q;\n\t\tq.push(S(ms,gs,0));\n\t\tint turn=0;\n\t\tP g(-1,-1);\n\t\tint gt=-1;\n\t\tbool isGoal=false;\n\t\tcost[ms.first][ms.second][gs.first][gs.second][gp.size()-1] = 0;\n\t\twhile(!q.empty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int aaa=0;aaa<size;++aaa){\n\t\t\t\tS s = q.front(); q.pop();\n\t\t\t\tP gn = P(s.g.first+gdy[gp[turn]],s.g.second+gdx[gp[turn]]);\n\t\t\t\tif(field[gn.first][gn.second] == 0)\n\t\t\t\t\tgn = s.g;\n\t\t\t\tfor(int i=0;i<5;++i){\n\t\t\t\t\tP mn = P(s.m.first+dy[i],s.m.second+dx[i]);\n\t\t\t\t\tif(cost[mn.first][mn.second][gn.first][gn.second][turn] == -1 && field[mn.first][mn.second] == '.'){\n\t\t\t\t\t\tcost[mn.first][mn.second][gn.first][gn.second][turn] = cost[s.m.first][s.m.second][s.g.first][s.g.second][(turn+gp.size()-1)%gp.size()]+1;\n\t\t\t\t\t\tif(mn == gn){\n\t\t\t\t\t\t\tg = mn;\n\t\t\t\t\t\t\tgt =  turn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(S(mn,gn,gp[turn]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(g.first != -1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(g.first != -1)\n\t\t\t\tbreak;\n\t\t\t++turn;\n\t\t\tturn%=gp.size();\n\t\t}\n\t\tif(g.first != -1)\n\t\t\tcout << cost[g.first][g.second][g.first][g.second][gt] << ' ' << g.first-1  << ' '<< g.second-1 << endl;\n\t\telse\n\t\t\tcout << \"impossible\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[0][0] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 1000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w) {\n\t\t\t\t\tx = nx; y = ny;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "4 7\nA#...#B\n.#.#.#.\n.#.#.#.\n...#...\n5\n4 7\nA#...#B\n.#.#.#.\n.#.#.#.\n...#...\n2\n4 7\nA#...#B\n.#.#.#.\n.#.#.#.\n...#...\n4\n4 7\nA#...#B\n.#.#.#.\n.#.#.#.\n...#...\n442668\n1 10\nA#.......B\n55555554\n1 10\nA#.......B\n55555555\n0 0"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define P pair<int,int>\nusing namespace std;\n\nint x[4]={-1,0,0,1},y[4]={0,-1,1,0};\nint main(){\n    int a,b;\n    string s[20];\n    while(cin>>a>>b,a|b){\n\tP n,m;\n\tfor(int c=0;c<a;c++){cin>>s[c];\n\t    for(int i=0;i<b;i++){\n\t\tif(s[c][i]=='A'){n=P(c,i);s[c][i]='.';}\n\t\telse if(s[c][i]=='B'){m=P(c,i);s[c][i]='.';}\n\t\t}\n\t    }\n\tstring d;cin>>d;\n\tint mincost[20][20];\n\tmemset(mincost,-1,sizeof(mincost));\n\tqueue<P>Q;\n\tQ.push(n);\n\tmincost[n.first][n.second]=0;\n\twhile(Q.size()){\n\t    P t=Q.front();Q.pop();\n\t    for(int i=0;i<4;i++){\n\t\tint dx=t.first+x[i],dy=t.second+y[i];\n\t\tif(dx>=0&&dx<a&&dy>=0&&dy<b&&mincost[dx][dy]==-1&&s[dx][dy]=='.'){\n\t\t    mincost[dx][dy]=mincost[t.first][t.second]+1;\n\t\t    Q.push(P(dx,dy));\n\t\t    }\n\t\t}\n\t    }\n\t    int X=m.first,Y=m.second;\n\tfor(int i=0;i<1000;i++){\n\t    switch(d[i%d.length()]){\n\t\tcase '2':X++;break;\n\t\tcase '6':Y++;break;\n\t\tcase '4':Y--;break;\n\t\tcase '8':X--;break;\n\t    }\n\t    if(X==a)X=a-1;\n\t    if(X==-1)X=0;\n\t    if(Y==a)Y=b-1;\n\t    if(Y==-1)Y=0;\n\t    if(mincost[X][Y]==-1)continue;\n\t    if(mincost[X][Y]>i)continue;\n\t    cout<<i<<\" \"<<X<<\" \"<<Y<<endl;\n\t    goto l;\n\t    }\n\t    puts(\"impossible\");\n\t    l:;\n\t    }\n    }"
  },
  {
    "language": "C++",
    "code": "# include <bits/stdc++.h>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nusing Pll=pair<LL,LL>;\nconst double PI = acos(-1);\ntemplate<class T>constexpr T INF() { return ::std::numeric_limits<T>::max(); }\ntemplate<class T>constexpr T HINF() { return INF<T>() / 2; }\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\ntemplate<typename T>vector<T> make_v(size_t a){ return vector<T>(a); }\ntemplate<typename T,typename... Ts>auto make_v(size_t a, Ts... ts){ return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value==0>::type fill_v(T &t, const V &v){ t = v; }\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value!=0>::type fill_v(T &t, const V &v){ for(auto &e : t) fill_v(e, v); }\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\nint popcnt(unsigned long long n) { int cnt = 0; for (int i = 0; i < 64; i++)if ((n >> i) & 1)cnt++; return cnt; }\nint d_sum(LL n) { int ret = 0; while (n > 0) { ret += n % 10; n /= 10; }return ret; }\nint d_cnt(LL n) { int ret = 0; while (n > 0) { ret++; n /= 10; }return ret; }\nLL gcd(LL a, LL b) { if (b == 0)return a; return gcd(b, a%b); };\nLL lcm(LL a, LL b) { LL g = gcd(a, b); return a / g*b; };\n# define ALL(qpqpq)           (qpqpq).begin(),(qpqpq).end()\n# define UNIQUE(wpwpw)        sort(ALL((wpwpw)));(wpwpw).erase(unique(ALL((wpwpw))),(wpwpw).end())\n# define LOWER(epepe)         transform(ALL((epepe)),(epepe).begin(),TL<char>)\n# define UPPER(rprpr)         transform(ALL((rprpr)),(rprpr).begin(),TU<char>)\n# define FOR(i,tptpt,ypypy)   for(LL i=(tptpt);i<(ypypy);i++)\n# define REP(i,upupu)         FOR(i,0,upupu)\n# define INIT                 std::ios::sync_with_stdio(false);std::cin.tie(0)\nLL h,w,d[500][500],ans;\nPll st,ed,ans_pos;\nchar c[500][500];\nstring s;\nint main(){\n    while(cin>>h&&h!=0){\n      cin>>w;\n      ans=INF<LL>();\n      REP(i,h){\n       REP(j,w){\n         cin>>c[i][j];\n         if(c[i][j]=='A')\n         st=Pll(i,j);\n        if(c[i][j]=='B')\n         ed=Pll(i,j);\n       }\n      }\n      cin>>s;\n      queue<Pll>qu;\n      REP(i,h)REP(j,w)d[i][j]=INF<LL>();\n      qu.push(st);\n      d[st.first][st.second]=0;\n      while(!qu.empty()){\n          Pll now=qu.front();\n          qu.pop();\n          REP(i,4){\n              LL X=now.first+dx[i],Y=now.second+dy[i];\n              if(X>=0&&X<h&&Y>=0&&Y<w&&c[X][Y]!='#'){\n                  if(d[X][Y]>d[now.first][now.second]+1){\n                     d[X][Y]=d[now.first][now.second]+1;\n                     qu.push(Pll(X,Y));\n                    }\n              }\n          }\n      }\n      LL cost=0;\n      REP(cnt,400){\n          REP(i,s.size()){\n              if(d[ed.first][ed.second]<=cost){\n                  if(cost<ans){\n                  ans=min(ans,cost);\n                  ans_pos=ed;\n                  }\n              }\n              if(s[i]=='8'&&ed.first-1>=0){\n                  ed.first--;\n              }\n              if(s[i]=='2'&&ed.first+1<h){\n                  ed.first++;\n              }\n              if(s[i]=='4'&&ed.second-1>=0){\n                  ed.second--;\n              }\n              if(s[i]=='6'&&ed.second+1<w){\n                  ed.second++;\n              }\n          cost++;\n          }\n      }\n      if(ans==INF<LL>()){\n          cout<<\"impossible\"<<endl;\n      }\n      else{\n          cout<<ans<<\" \"<<ans_pos.first<<\" \"<<ans_pos.second<<endl;\n      }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define F first\n#define S second\n#define INF 1<<29\ntypedef pair<int,int> P;\nstruct PP {\n  P a,b;\n  int kk;\n};\n\nint dx[5]={-1,0,1,0,0},dy[5]={0,1,0,-1,0};\nbool check(int n,int m,int x,int y){return x>=0&&x<n&&y>=0&&y<m;}\n\nint main() {\n  int n,m;\n  while(cin >> n >> m && n) {\n    string s[n],t;\n    for(int i=0; i<n; i++) cin >> s[i];\n    cin >> t;\n    for(int i=0; i<t.size(); i++) {\n      if(t[i]=='5') t[i]='4';\n      else if(t[i]=='8') t[i]='0';\n      else if(t[i]=='6') t[i]='1';\n      else if(t[i]=='2') t[i]='2';\n      else t[i]='3';\n    }\n    P p1,p2;\n    for(int i=0; i<n; i++) {\n      for(int j=0; j<m; j++) {\n        if(s[i][j]=='A') p1=P(i,j);\n        if(s[i][j]=='B') p2=P(i,j);\n      }\n    }\n    int d[n][m][n][m][t.size()];\n    for(int i=0;i<n;i++)for(int i2=0;i2<m;i2++)for(int i3=0;i3<n;i3++)for(int i4=0;i4<m;i4++)for(int i5=0;i5<t.size();i5++)d[i][i2][i3][i4][i5]=INF;\n    d[p1.F][p1.S][p2.F][p2.S][t.size()-1]=0;\n    queue<PP> que;\n    que.push((PP){p1,p2,t.size()-1});\n    while(!que.empty()) {\n      PP p=que.front();que.pop();\n      int nx=p.a.F,ny=p.a.S,k=p.kk;\n      P q=p.b;\n      int cost=d[nx][ny][p.b.F][p.b.S][p.kk];\n      if(p.a==p.b) {\n        cout << cost << \" \" << nx << \" \" << ny << endl;\n        goto end;\n      }\n      k=(k+1)%t.size();\n      int r=t[k]-'0';\n      q.F+=dx[r],q.S+=dy[r];\n      if(!check(n,m,q.F,q.S)) q=p.b;\n      for(int i=0; i<5; i++) {\n        int x=nx+dx[i],y=ny+dy[i];\n        if(!check(n,m,x,y)||s[x][y]=='#') continue;\n        if(d[x][y][q.F][q.S][k]>cost+1) {\n          d[x][y][q.F][q.S][k]=cost+1;\n          que.push((PP){P(x,y),q,k});\n        }\n      }\n    }\n    cout << \"impossible\" << endl;\n  end:;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<queue>\n#include<map>\n#include<vector>\nusing namespace std;\n\nconst int inf = 1<<29;\n#define rep(i,n) for(i=0; i<n; ++i)\n\nint dx[4] = {0, 1, 0, -1};\nint dy[4] = {1, 0, -1, 0};\n\nvoid bfs(const vector<vector<bool> > &grid,vector< vector<int> > &dist,\n\t pair<int,int> start) {\n  int i;\n  dist[start.first][start.second] = 0;\n  queue<pair<int,int> > Q;\n  Q.push(start);\n  while(!Q.empty()) {\n    pair<int,int> now = Q.front(); Q.pop();\n    int nx = now.second,ny = now.first;\n    rep(i,4) {\n      if(nx+dx[i] >= 0 && nx+dx[i] < grid[0].size() &&\n\t ny+dy[i] >= 0 && ny+dy[i] < grid.size() &&\n\t grid[ny+dy[i]][nx+dx[i]] == true && dist[ny+dy[i]][nx+dx[i]] == inf) {\n\tdist[ny+dy[i]][nx+dx[i]] = dist[ny][nx]+1;\n\tQ.push(make_pair(ny+dy[i],nx+dx[i]));\n      }\n    }\n  }\n  return;\n}\n\nint main() {\n  int h,w,i,j,k;\n  string s,pattern;\n  while(cin>>h>>w, h|w) {\n    vector< vector<bool> > grid(h, vector<bool>(w, true));\n    vector< vector<int> > dist(h, vector<int>(w, inf));\n    pair<int,int> start,ghost;\n    rep(i,h) {\n      cin>>s;\n      rep(j,w) {\n\tif(s[j] == 'A') start = make_pair(i,j);\n\tif(s[j] == 'B') ghost = make_pair(i,j);\n\tif(s[j] == '#') grid[i][j] = false;\n      }\n    }\n    cin>>pattern;\n    bfs(grid,dist,start);\n    int pat = pattern.length();\n    bool possible = false;\n\n    rep(i, h*w+h*w*pat+2) {\n      if(dist[ghost.first][ghost.second] <= i) {\n\tcout<<i<<\" \"<<ghost.first<<\" \"<<ghost.second<<endl;\n\tgoto NEXT;\n      }\n      int d = i%pat;\n      if(pattern[d] == '8') {\n\tghost.first--;\n\tif(ghost.first < 0) ghost.first = 0;\n      }else if(pattern[d] == '2') {\n\tghost.first++;\n\tif(ghost.first >= h) ghost.first = h-1;\n      }else if(pattern[d] == '6') {\n\tghost.second++;\n\tif(ghost.second >= w) ghost.second = w-1;\n      }else if(pattern[d] == '4') {\n\tghost.second--;\n\tif(ghost.second < 0) ghost.second = 0;\n      }\n    }\n    cout<<\"impossible\"<<endl;\n  NEXT:;\n\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\nint dist[21][21], x[21][21], sx, sy, gx, gy, H, W; string S;\nint main() {\n\twhile (true) {\n\t\tcin >> H >> W; if (H == 0 && W == 0)break;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tchar c; cin >> c; dist[i][j] = 99999;\n\t\t\t\tif (c == 'A') { sx = i; sy = j; x[i][j] = 0; }\n\t\t\t\tif (c == 'B') { gx = i; gy = j; x[i][j] = 0; }\n\t\t\t\tif (c == '#') { x[i][j] = 1; }\n\t\t\t\tif (c == '.') { x[i][j] = 0; }\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int>>Q; Q.push(make_pair(sx, sy)); dist[sx][sy] = 0;\n\t\tint dx[4] = { 1,0,0,-1 }, dy[4] = { 0,1,-1,0 };\n\t\twhile (!Q.empty()) {\n\t\t\tint a1 = Q.front().first, a2 = Q.front().second; Q.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint cx = a1 + dx[i], cy = a2 + dy[i];\n\t\t\t\tif (cx < 0 || cy < 0 || cx >= H | cy >= W)continue;\n\t\t\t\tif (dist[cx][cy] > dist[a1][a2] + 1 && x[cx][cy] == 0) {\n\t\t\t\t\tdist[cx][cy] = dist[a1][a2] + 1;\n\t\t\t\t\tQ.push(make_pair(cx, cy));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> S; for (int i = 0; i < 10; i++)S += S; bool OK = false;\n\t\tfor (int i = 0; i < 1000; i++) {\n\t\t\tif (dist[gx][gy] <= i) { cout << i << ' ' << gx << ' ' << gy << endl; OK = true; break; }\n\t\t\tif (S[i] != '5') { gx += dx[(S[i] - '2') / 2]; gy += dy[(S[i] - '2') / 2]; }\n\t\t}\n\t\tif (OK == false)cout << \"Impossible\" << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n\tint x, y;\n} Vector;\n\ntypedef struct {\n\tint x, y;\n\tint step;\n} DATA;\n\nunsigned int data[16 + 2][16 + 2];\nchar map[16 + 2][16 + 2];\n\nint change(char move[], Vector mv[])\n{\n\tint i = 0;\n\twhile (move[i] != '\\0'){\n\t\tmv[i].x = mv[i].y = 0;\n\t\tswitch (move[i]){\n\t\t  case '5':\n\t\t  \tbreak;\n\t\t  case '8':\n\t\t  \tmv[i].y = -1;\n\t\t\tbreak;\n\t\t  case '6':\n\t\t  \tmv[i].x = 1;\n\t\t\tbreak;\n\t\t  case '4':\n\t\t  \tmv[i].x = -1;\n\t\t\tbreak;\n\t\t  case '2':\n\t\t  \tmv[i].y = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn (i);\n}\n\nunsigned int move_sml(int gx, int gy, Vector mv[], int move_count, int* ans_x, int* ans_y)\n{\n\tunsigned int ret = 0xffffffff;\n\tfor (unsigned int i = 0; i < 1000000; i++){\n\t\tint mx = mv[i % move_count].x;\n\t\tint my = mv[i % move_count].y;\n\t\t\n\t\tif (data[gx][gy] <= i && ret > i){\n\t\t\tret = max(data[gx][gy], i);\n\t\t\t*ans_x = gx;\n\t\t\t*ans_y = gy;\n\t\t}\n\t\t\n\t\tif (map[gx + mx][gy + my] != -1){\n\t\t\tgx += mx;\n\t\t\tgy += my;\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint move_short_root(int sx, int sy)\n{\n\tlist<DATA> lst;\n\tDATA add;\n\t\n\tdata[sx][sy] = 0;\n\t\n\tadd.x = sx + 1;\n\tadd.y = sy;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx - 1;\n\tadd.y = sy;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx;\n\tadd.y = sy + 1;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx;\n\tadd.y = sy - 1;\n\tadd.step = 1;\n\tlst.push_back(add);\n\t\n\twhile (!lst.empty()){\n\t\tif (map[lst.front().x][lst.front().y] != -1 && map[lst.front().x][lst.front().y] != '#' && data[lst.front().x][lst.front().y] > lst.front().step){\n\t\t\tdata[lst.front().x][lst.front().y] = lst.front().step;\n\t\t\tadd.x = lst.front().x + 1;\n\t\t\tadd.y = lst.front().y;\n\t\t\tadd.step = lst.front().step + 1;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x - 1;\n\t\t\tadd.y = lst.front().y;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x;\n\t\t\tadd.y = lst.front().y + 1;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x;\n\t\t\tadd.y = lst.front().y - 1;\n\t\t\tlst.push_back(add);\n\t\t}\n\t\tlst.pop_front();\n\t}\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\tint hight, width;\n\tint ans_x, ans_y;\n\tint sx, sy, gx, gy;\n\tchar move[11];\n\tVector mv[10];\n\tVector mbp[10];\n\tint move_count;\n\tunsigned int ans;\n\t\n\twhile (1){\n\t\tmemset(data, 0xff, (18 * 18) * 4);\n\t\tmemset(map, -1, (18 * 18));\n\t\tcin >> hight >> width;\n\t\tif (hight == 0 && width == 0)break;\n\t\tfor (int y = 0; y < hight + 2; y++){\n\t\t\tchar str[16 + 1];\n\t\t\tif (y == 0 || y == hight + 1){\n\t\t\t\tfor (int x = 0; x < width + 2; x++){\n\t\t\t\t\tmap[x][y] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> str;\n\t\t\t\tmap[0][y] = map[width + 1][y] = -1;\n\t\t\t\tfor (int x = 0; x < width; x++){\n\t\t\t\t\tif (str[x] == 'A'){\n\t\t\t\t\t\tsx = x + 1;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (str[x] == 'B'){\n\t\t\t\t\t\tgx = x + 1;\n\t\t\t\t\t\tgy = y;\n\t\t\t\t\t}\n\t\t\t\t\tmap[x + 1][y] = str[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> move;\n\t\t\n\t\tmove_count = change(move, mv);\n\t\t\n\t\tmove_short_root(sx, sy);\n\t\t\n\t\tans = move_sml(gx, gy, mv, move_count, &ans_x, &ans_y);\n\t\t\n\t\tif (ans == 0xffffffff){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << ' ' << ans_y - 1 << ' ' << ans_x - 1 << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include<iostream>\n#include<string>\n#include<sstream>\n#include<algorithm>\n#include<cmath>\n#include<bitset>\n#include<map>\n#include<set>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<deque>\nusing namespace std;\n\nlong INF = 1000000;\n\nint main() {\n\n    int h, w;\n    while(cin >> h >> w && (h || w)) {\n        queue<int> x;\n        queue<int> y;\n        char town[h][w];\n        long time[h][w];\n        int gx, gy;\n        string str;\n        getline(cin, str);\n        for(int i = 0; i < h; i++) {\n            getline(cin, str);\n            for(int j = 0; j < w; j++) {\n                time[i][j] = INF;\n                town[i][j] = str[j];\n                if(str[j] == 'A') {\n                    x.push(i);\n                    y.push(j);\n                    town[i][j] = '.';\n                    time[i][j] = 0;\n                }\n                if(str[j] == 'B') {\n                    gx = i;\n                    gy = j;\n                    town[i][j] = '.';\n                }\n            }\n        }\n\n        while(!x.empty()) {\n            int i = x.front();\n            int j = y.front();\n            x.pop();\n            y.pop();\n            if ( i > 0 && town[i-1][j] != '#' && time[i-1][j] == INF ) {\n                time[i-1][j] = time[i][j] + 1;\n                x.push(i-1);\n                y.push(j);\n            }\n            if ( j > 0 && town[i][j-1] != '#' && time[i][j-1] == INF ) {\n                time[i][j-1] = time[i][j] + 1;\n                x.push(i);\n                y.push(j-1);\n            }\n            if ( i < h - 1 && town[i+1][j] != '#' && time[i+1][j] == INF ) {\n                time[i+1][j] = time[i][j] + 1;\n                x.push(i+1);\n                y.push(j);\n            }\n            if ( j < w - 1 && town[i][j+1] != '#' && time[i][j+1] == INF ) {\n                time[i][j+1] = time[i][j] + 1;\n                x.push(i);\n                y.push(j+1);\n            }\n        }\n\n        getline(cin, str);\n\n        long t = 1;\n        int lenpat = str.length();\n        while(t < lenpat * 1000) {\n            switch(str[(t - 1) % lenpat]) {\n                case '2':\n                    if (gx < h - 1) gx += 1;\n                    break;\n                case '4':\n                    if (gy > 0) gy -= 1;\n                    break;\n                case '6':\n                    if (gy < w - 1) gy += 1;\n                    break;\n                case '8':\n                    if (gx > 0) gx -= 1;\n                    break;\n            }\n            if (time[gx][gy] <= t) {\n                cout << t << \" \" << gx << \" \" << gy << endl; \n                break;\n            }\n            t += 1;\n        }\n        if (t == lenpat * 1000) {\n            cout << \"impossible\" << endl;\n        }\n\n    }\n     \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\nstruct po{int x,y,dis;};\nint h,w;\nstring mp[20],str;\nint D[21][21];\n\nvoid bfs(po s){\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) D[i][j] = 10000000;\n  D[s.y][s.x] = 0;\n  queue<po> Q;\n  Q.push((po){s.x,s.y,0});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    int dx[]={0,0,-1,1};\n    int dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx = t.x+dx[i];\n      int ny = t.y+dy[i];\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!='.'||D[ny][nx]<=t.dis+1)continue;\n      Q.push((po){nx,ny,t.dis+1});\n      D[ny][nx]=t.dis+1;\n    }\n  }\n}\n\nvoid move(po s){\n  po ima,ans;\n  ima.x=s.x,ima.y=s.y;\n  if(D[ima.y][ima.x]==0)ans.x=ima.x,ans.y=ima.y,ans.dis=0;\n  else ans.dis = 10000000;\n  int visited[21][21]={};\n  int dx[]={0,-1,1,0};\n  int dy[]={1,0,0,-1};\n  int cnt=0;\n  while(1){\n    visited[ima.y][ima.x]=1;\n    for(int i=0;i<str.size();i++){\n      cnt++;\n      int j = (str[i]-'0')/2-1;\n      int nx=ima.x+dx[j];\n      int ny=ima.y+dy[j];\n      if(nx<0||ny<0||nx>=w||ny>=h||str[i]=='5')nx=ima.x,ny=ima.y;\n      ima.x=nx,ima.y=ny;\n      if(ans.dis>cnt && cnt>D[ny][nx]) ans.x=ima.x,ans.y=ima.y,ans.dis=cnt;\n    }\n    if(cnt>5000)break;\n  }\n  if(ans.dis==10000000 || ans.dis>1000) cout <<\"impossible\"<<endl;\n  else cout<< ans.dis<<\" \" << ans.y <<\" \"<< ans.x<<endl;\n}\n \n\nint main() {\n\n  while(1){\n    cin >> h >> w;\n    if(h==0 && w==0)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n    cin>> str;\n    \n    po A,B;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[i][j] == 'A') A.y=i ,A.x=j;\n\tif(mp[i][j]=='B') B.y=i,B.x=j;\n      }\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(mp[i][j] == 'A'||mp[i][j]=='B') mp[i][j] = '.';\n  \n    bfs(A);\n    move(B);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <string>\n#include <vector>\n#include <iostream>\nusing namespace std;\nint dir[] = { 0, 1, 0, -1 };\nint H, W, dist[25][25]; string s[25], t;\nint main() {\n\twhile (cin >> H >> W, H) {\n\t\tint ax = -1, ay = -1, bx = -1, by = -1;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tcin >> s[i];\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tif (s[i][j] == 'A') ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B') bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tcin >> t;\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\tdist[i][j] = 999999999;\n\t\t\t}\n\t\t}\n\t\tqueue<pair<int, int> > que; que.push(make_pair(ax, ay)); dist[ax][ay] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpair<int, int> u = que.front(); que.pop();\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint tx = u.first + dir[i], ty = u.second + dir[i ^ 1];\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W && s[tx][ty] != '#' && dist[tx][ty] == 999999999) {\n\t\t\t\t\tdist[tx][ty] = dist[u.first][u.second] + 1;\n\t\t\t\t\tque.push(make_pair(tx, ty));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (dist[bx][by] == -1) cout << \"Impossible\" << endl;\n\t\telse {\n\t\t\tfor (int i = 0; ; i++) {\n\t\t\t\tif (dist[bx][by] <= i) {\n\t\t\t\t\tcout << i << ' ' << bx << ' ' << by << endl;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint tx = bx, ty = by;\n\t\t\t\tif (t[i % t.size()] == '2') tx++;\n\t\t\t\tif (t[i % t.size()] == '4') ty--;\n\t\t\t\tif (t[i % t.size()] == '6') ty++;\n\t\t\t\tif (t[i % t.size()] == '8') tx--;\n\t\t\t\tif (0 <= tx && tx < H && 0 <= ty && ty < W) bx = tx, by = ty;\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int dx[4] = {1,-1,0,0};\nconst int dy[4] = {0,0,1,-1};\n\nconst int gdx[10] = {\n  0,\n  0,0,0,\n  -1,0,1,\n  0,0,0\n};\n\nconst int gdy[10] = {\n  0,\n  0,1,0,\n  0,0,0,\n  0,-1,0\n};\n\nint main(){\n  int h,w;\n  while(scanf(\"%d%d \",&h,&w), h+w){\n    char buff[h][w+3];\n    int dist[h][w];\n    int mx,my,gx,gy;\n\n    REP(i,h) fgets(buff[i],sizeof(buff[i]),stdin);\n    REP(i,h){\n      REP(j,w){\n        dist[i][j] = -1;\n        if(buff[i][j] == 'A'){\n          mx = j; my = i;\n          buff[i][j] = '.';\n        }else if(buff[i][j] == 'B'){\n          gx = j; gy = i;\n          buff[i][j] = '.';\n        }\n      }\n    }\n\n    queue<pair<int,int> > q;\n    q.push(mp(mx,my)); dist[mx][my]=0;\n    int last = 0;\n    while(!q.empty()){\n      int x = q.front().f;\n      int y = q.front().s;\n      q.pop();\n\n      REP(i,4){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(xx < 0 || yy < 0) continue;\n        if(xx >=w || yy >=h) continue;\n        if(buff[yy][xx] == '#') continue;\n        if(dist[yy][xx] != -1) continue;\n        last = dist[yy][xx] = dist[y][x] + 1;\n        q.push(mp(xx,yy));\n      }\n    }\n\n    //REP(i,h){ REP(j,w) printf(\"  %c\",buff[i][j]); puts(\"\");}\n    //REP(i,h){ REP(j,w) printf(\"%3d\",dist[i][j]); puts(\"\");}\n\n    char pat[20];\n    fgets(pat,sizeof(pat),stdin);\n    int plen = strlen(pat);\n    if(pat[plen-1] == '\\n') plen--;\n    bool flag[h][w][plen]; memset(flag, 0, sizeof(flag));\n    int turn = 0;\n    while(true){\n      int pp = pat[turn % plen] - '0'; turn++;\n      int xx = gx + gdx[pp];\n      int yy = gy + gdy[pp];\n\n      if(xx < 0 || yy < 0 || xx >=w || yy >=h){\n        xx = gx; yy = gy;\n      }\n\n      //printf(\"goast: (%d,%d) pp=%d\\n\",xx,yy,pp);\n\n      if(dist[yy][xx] != -1 && dist[yy][xx] <= turn){\n        printf(\"%d %d %d\\n\",turn,yy,xx);\n        break;\n      }\n\n      if(flag[yy][xx][turn % plen]){\n        puts(\"impossible\");\n        break;\n      }\n\n      if(turn >= last + last)\n        flag[yy][xx][turn % plen] = true;\n\n      gx = xx; gy = yy;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n#include <string.h>\nusing namespace std;\n\ntypedef pair<int,int> P;//y,x\n\nconst int dx[] = {1,0,-1,0,0};//東、南、西、北、無\nconst int dy[] = {0,1,0,-1,0};\n\nint gdx[10];\nint gdy[10];\nint field[21][21];\n\nint cost[21][21][21][21][10];\n\nstruct S\n{\n\tP m;\n\tP g;\n\tint gp;\n\tS(P m_,P g_,int gp_):m(m_),g(g_),gp(gp_){}\n};\n\nint main(void)\n{\n\tgdx[5]=0;gdx[8]=0;gdx[6]=1;gdx[4]=-1;gdx[2]=0;\n\tgdy[5]=0;gdy[8]=-1;gdy[6]=0;gdy[4]=0;gdy[2]=1;\n\twhile(1){\n\t\tmemset(cost,-1,sizeof(cost));\n\t\tmemset(field,0,sizeof(field));\n\t\tP ms,gs;\n\t\tvector<int> gp;\n\t\tint W,H;\n\t\tcin >> H >> W;\n\t\tif(H==0 && W==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=H;++y){\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tfor(int x=1;x<=W;++x){\n\t\t\t\tfield[y][x] = in[x-1];\n\t\t\t\tif(field[y][x] == 'A'){\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t\tms.first = y;\n\t\t\t\t\tms.second = x;\n\t\t\t\t}\n\t\t\t\tif(field[y][x] == 'B'){\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t\tgs.first = y;\n\t\t\t\t\tgs.second = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring in;\n\t\tcin >> in;\n\t\tfor(int i=0;i<in.size();++i){\n\t\t\tgp.push_back(in[i]-'0');\n\t\t}\n\t\t////////////////////////////////////////\n\t\tqueue<S> q;\n\t\tq.push(S(ms,gs,0));\n\t\tint turn=0;\n\t\tP g(-1,-1);\n\t\tint gt=-1;\n\t\tbool isGoal=false;\n\t\tcost[ms.first][ms.second][gs.first][gs.second][gp.size()-1] = 0;\n\t\twhile(!q.empty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int aaa=0;aaa<size;++aaa){\n\t\t\t\tS s = q.front(); q.pop();\n\t\t\t\tP gn = P(s.g.first+gdy[gp[turn]],s.g.second+gdx[gp[turn]]);\n\t\t\t\tif(field[gn.first][gn.second] == 0)\n\t\t\t\t\tgn = s.g;\n\t\t\t\tfor(int i=0;i<5;++i){\n\t\t\t\t\tP mn = P(s.m.first+dy[i],s.m.second+dx[i]);\n\t\t\t\t\tif(cost[mn.first][mn.second][gn.first][gn.second][turn] == -1 && field[mn.first][mn.second] == '.'){\n\t\t\t\t\t\tcost[mn.first][mn.second][gn.first][gn.second][turn] = cost[s.m.first][s.m.second][s.g.first][s.g.second][(turn+gp.size()-1)%gp.size()]+1;\n\t\t\t\t\t\tif(mn == gn){\n\t\t\t\t\t\t\tg = mn;\n\t\t\t\t\t\t\tgt =  turn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(S(mn,gn,gp[turn]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(g.first != -1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(g.first != -1)\n\t\t\t\tbreak;\n\t\t\t++turn;\n\t\t\tturn%=gp.size();\n\t\t}\n\t\tif(g.first != -1)\n\t\t\tcout << cost[g.first][g.second][g.first][g.second][gt] << ' ' << g.first-1  << ' '<< g.second-1 << endl;\n\t\telse\n\t\t\tcout << \"impossible\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<cstdio>\n#include<sstream>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e9;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef pair<int,int> pii;\nint n,m;\nvector<string>in;\nint sx,sy,bx,by;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nvoid f(int x,int y,int c){\n\tin[x][y]=c;\n\trep(i,4){\n\t\tint nx=x+dx[i],ny=y+dy[i];\n\t\tif(nx<0||ny<0||nx>=n||ny>=m)continue;\n\t\tif(in[nx][ny]=='.')f(nx,ny,c+1);\n\t}\n}\nint main(){\n\twhile(cin>>n>>m,n+m){\n\t\tin=vector<string>(n);\n\t\trep(i,n)cin>>in[i];\n\t\trep(i,n)rep(j,m)if(in[i][j]=='B'){\n\t\t\tbx=i;by=j;in[i][j]='.';\n\t\t}else if(in[i][j]=='A'){\n\t\t\tsx=i;sy=j;in[i][j]='.';\n\t\t}\n\t\tf(sx,sy,0);\n//\t\trep(i,n){rep(j,m)cout<<\" \"<<(int)in[i][j];cout<<endl;}\n\t\tint mi=inf,ax,ay;\n\t\tstring s;\n\t\tcin>>s;\n\t\tint c=0;\n\t\trep(i,300){\n//\t\t\tcout<<bx<<\" \"<<by<<endl;\n\t\t\tif(in[bx][by]!='#'&&in[bx][by]!='.'){\n\t\t\t\tint t=in[bx][by];\n\t\t\t\tif(t<=i){\n\t\t\t\t\tmi=min(mi,i);\n\t\t\t\t\tax=bx;ay=by;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(s[c]=='5');\n\t\t\telse if(s[c]=='8'&&bx)bx--;\n\t\t\telse if(s[c]=='6'&&by<m-1)by++;\n\t\t\telse if(s[c]=='4'&&by)by--;\n\t\t\telse if(s[c]=='2'&&bx<n-1)bx++;\n\t\t\tc++;\n\t\t\tif(c==s.size())c=0;\n\t\t}\n\t\t\n\t\tif(mi==inf)cout<<\"impossible\"<<endl;\n\t\telse cout<<mi<<\" \"<<ax<<\" \"<<ay<<endl;\n\t}\n}\n "
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <bitset>\n#include <ctype.h>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, b) for(int i = (a); i < (b); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<double, double> dP;\n\nconst int INF = 1000000000;\nconst double EPS = 1e-10;\n\n\t\t\t\t//  2      4  5  6      8\nint dx[10] = {1,-1, 0, 0, -1, 0, 1, 0,  0, 0};\nint dy[10] = {0, 0, 1,-1,  0, 0, 0, 0, -1, 0};\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\twhile(1){\n\t\tint h, w;\n\t\tcin >> h >> w;\n\t\tif(!h && !w) break;\n\t\tvector<string> v(h);\n\t\trep(i, h){\n\t\t\tcin >> v[i];\n\t\t}\n\t\tstring pt;\n\t\tcin >> pt;\n\n\t\tP a, b;\n\t\trep(i, h){\n\t\t\trep(j, w){\n\t\t\t\tif(v[i][j] == 'A') a = MP(j,i);\n\t\t\t\tif(v[i][j] == 'B') b = MP(j,i);\n\t\t\t}\n\t\t}\n\n\t\tqueue<P> next;\n\t\tnext.push(a);\n\t\tint cnt = 0;\n\t\twhile(1){\n\t\t\tqueue<P> q = next;\n\t\t\twhile(!q.empty()){\n\t\t\t\tP p = q.front(); q.pop();\n\n\t\t\t\trep(i, 4){\n\t\t\t\t\tint x = p.X + dx[i];\n\t\t\t\t\tint y = p.Y + dy[i];\n\t\t\t\t\tif(x < 0 || x >= w || y < 0 || y >= h) continue;\n\t\t\t\t\tif(v[y][x] == '#' || v[y][x] == 'A' ) continue;\n\t\t\t\t\tv[y][x] = 'A';\n\t\t\t\t\tnext.push(MP(x, y));\n\t\t\t\t}\n\t\t\t}\n\t\t\tint x = b.X + dx[pt[cnt%pt.size()]-'0'];\n\t\t\tint y = b.Y + dy[pt[cnt%pt.size()]-'0'];\n\t\t\tif(x >= 0 && x < w) b.X = x;\n\t\t\tif(y >= 0 && y < h) b.Y = y;\n\t\t\tcnt++;\n\t\t\tif(v[b.Y][b.X] == 'A') break;\n\t\t\tif(cnt > 1000) break;\n\t\t}\n\n\n\t\tif(cnt <= 1000) cout << cnt << ' ' << b.Y << ' ' << b.X << endl;\n\t\telse cout << \"impossible\" << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nvector<string> data(20);\nint dist[20][20]={};\nbool visited[20][20];\nint h,w;\n\n\nvoid dfs(int y,int x){\n\tif( y<0 || y>=h || x<0 || x>=w || visited[y][x]==true || data[y][x]=='#' )return ;\n\n\tvisited[y][x]=true;\n\n\tint a = (y+1<h )?dist[y+1][x]:999999999;\n\tint b = (y-1>=0)?dist[y-1][x]:999999999;\n\tint c = (x+1<w )?dist[y][x+1]:999999999;\n\tint d = (x-1>=0)?dist[y][x-1]:999999999;\n\n\tdist[y][x]=min( dist[y][x] , min(min(a,b) , min(c,d))+1 );\n\n\tdfs(y+1,x);\n\tdfs(y-1,x);\n\tdfs(y,x+1);\n\tdfs(y,x-1);\n}\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(h==0&&w==0)break;\n\t\tdata.clear();\n\t\trep(i,20)rep(j,20){dist[i][j]=999999999;visited[i][j]=false;}\n\t\tstring move;\n\n\t\trep(i,h) cin>>data[i];\n\t\tcin>>move;\t\t\n\n\t\tint sx,sy,gx,gy;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(data[i][j]=='A'){ sy=i;sx=j; }\n\t\t\tif(data[i][j]=='B'){ gy=i;gx=j;data[i][j]='.'; }\n\t\t}\n\n\t\tdist[sy][sx]=0;\n\t\tdfs(sy,sx);\n\n\t\tfor(int i=0;;i++){\n\t\t\tif(dist[gy][gx]<=i){\n\t\t\t\tcout<<i<<\" \"<<gy<<\" \"<<gx<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(move[i%move.size()]=='5'){;\t\t\t\t\t}\n\t\t\tif(move[i%move.size()]=='8'){gy=max(0,gy-1);\t}\n\t\t\tif(move[i%move.size()]=='6'){gx=min(w-1,gx+1);\t}\n\t\t\tif(move[i%move.size()]=='4'){gx=max(0,gx-1);\t}\n\t\t\tif(move[i%move.size()]=='2'){gy=min(h-1,gy+1);\t}\n\t\t\tif(i==3000000){\n\t\t\t\tcout<<\"impossible\"<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\nint H, W;\nchar grid[25][25];\nstring pat;\nint grid2[25][25];\nint ay, ax;\nint by, bx;\n\nvoid bfs()\n{\n    const int INF = 100000000;\n    int dy[4] = {0, -1, 0, 1};\n    int dx[4] = {-1, 0, 1, 0};\n\n    typedef pair<int, int> P;\n\n    queue<P> que;\n    rep(i,H) rep(j,W) {\n        grid2[i][j] = INF;\n    }\n\n    que.push(P(ay, ax));\n    grid2[ay][ax] = 0;\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        rep(i,4) {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n\n            if (0 <= ny && ny < H && 0 <= nx && nx < W && grid[ny][nx] == '.' && grid2[ny][nx] == INF) {\n                que.push(P(ny, nx));\n                grid2[ny][nx] = grid2[p.first][p.second] + 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n#ifdef LOCAL\n    ifstream in(\"input.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n\n    while (true) {\n        cin >> H >> W;\n        if (H == 0 && W == 0) break;\n\n        rep(i,H) rep(j,W) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'A') {\n                ay = i;\n                ax = j;\n                grid[i][j] = '.';\n            } else if (grid[i][j] == 'B') {\n                by = i;\n                bx = j;\n                grid[i][j] = '.';\n            }\n        }\n        cin >> pat;\n\n        /*\n        int sy = 0, sx = 0;\n        rep(i,pat.length()) {\n            if (pat[i] == '5') {\n                sy += 0;\n                sx += 0;\n            } else if(pat[i] == '4') {\n                sy += 0;\n                sx -= 1;\n            } else if (pat[i] == '8') {\n                sy -= 1;\n                sx += 0;\n            } else if (pat[i] == '6') {\n                sy += 0;\n                sx += 1;\n            } else if (pat[i] == '2') {\n                sy += 1;\n                sx += 0;\n            }\n        }\n        bool try_only_one = false;\n        if (sy == 0 && sx == 0) try_only_one = true;\n        */\n\n        bfs();\n\n        /*\n        rep(i,H) {\n            rep(j,W) {\n                printf(\"% 3d \", grid2[i][j]);\n            }\n            cout << endl;\n        }\n        */\n\n        bool possible = false;\n        int ans;\n        int ansy, ansx;\n        int cnt = 0;\n        rep(i,100) {\n            rep(j,pat.length()) {\n                cnt++;\n                if (pat[j] == '5') {\n                    by += 0;\n                    bx += 0;\n                } else if(pat[j] == '4') {\n                    by += 0;\n                    if (bx >= 1) bx -= 1;\n                } else if (pat[j] == '8') {\n                    if (by >= 1) by -= 1;\n                    bx += 0;\n                } else if (pat[j] == '6') {\n                    by += 0;\n                    if (bx < W - 1) bx += 1;\n                } else if (pat[j] == '2') {\n                    if (by < H - 1) by += 1;\n                    bx += 0;\n                }\n                if (grid2[by][bx] <= cnt && !possible) {\n                    possible = true;\n                    ans = cnt;\n                    ansy = by;\n                    ansx = bx;\n                }\n            }\n        }\n\n        if (possible) {\n            cout << ans << \" \" << ansy << \" \" << ansx << endl;\n        } else {\n            cout << \"impossible\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define f(a,b) for(int a=0;a<b;a++)\n\nint h,w,sx,sy,gx,gy,i,j,go,m = 999999;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[20][20];\nchar ma[20][20];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        f(i,h){\n            f(j,w){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            f(i,4){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(j=0,go=0;;j++,go++){\n            i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>700){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\ntypedef struct {\n\tint x, y;\n} Vector;\n\nchar map[16 + 2][16 + 2];\nunsigned int data[16][16][16][16][10];\nint ans;\nint ans_x, ans_y;\n\nint change(char move[], Vector mv[])\n{\n\tint i = 0;\n\twhile (move[i] != '\\0'){\n\t\tmv[i].x = mv[i].y = 0;\n\t\tswitch (move[i]){\n\t\t  case '5':\n\t\t  \tbreak;\n\t\t  case '8':\n\t\t  \tmv[i].y = -1;\n\t\t\tbreak;\n\t\t  case '6':\n\t\t  \tmv[i].x = 1;\n\t\t\tbreak;\n\t\t  case '4':\n\t\t  \tmv[i].x = -1;\n\t\t\tbreak;\n\t\t  case '2':\n\t\t  \tmv[i].y = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn (i);\n}\n\nint calc(int sx, int sy, int gx, int gy, Vector mv[], int move_count, int depth)\n{\n\tint mx, my;\n\t\n\t\n\tif (map[sx][sy] == -1 || map[sx][sy] == '#' || ans <= depth){\n\t\treturn (0);\n\t}\n\tif (sx == gx && sy == gy){\n\t\tif (ans > depth){\n\t\t\tans = depth;\n\t\t\tans_x = sx - 1;\n\t\t\tans_y = sy - 1;\n\t\t}\n\t\treturn (0);\n\t}\n\tif (data[sx - 1][sy - 1][gx - 1][gy - 1][depth % move_count] == 1){\n\t\treturn (0);\n\t}\n\tdata[sx - 1][sy - 1][gx - 1][gy - 1][depth % move_count] = 1;\n\t\n\tmx = mv[depth % move_count].x;\n\tmy = mv[depth % move_count].y;\n\t\n\tif (map[gx + mx][gy + my] != -1){\n\t\tgx += mx;\n\t\tgy += my;\n\t}\n\tcalc(sx + 1, sy, gx, gy, mv, move_count, depth + 1);\n\tcalc(sx - 1, sy, gx, gy, mv, move_count, depth + 1);\n\tcalc(sx, sy + 1, gx, gy, mv, move_count, depth + 1);\n\tcalc(sx, sy - 1, gx, gy, mv, move_count, depth + 1);\n\tcalc(sx, sy,     gx, gy, mv, move_count, depth + 1);\n\t\n\tdata[sx - 1][sy - 1][gx - 1][gy - 1][depth % move_count] = 0;\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\tint hight, width;\n\tint sx, sy, gx, gy;\n\tchar move[11];\n\tVector mv[10];\n\tint move_count;\n\t\n\twhile (1){\n\t\tans = 16 * 16 * 16 * 16 * 10;\n\t\tcin >> hight >> width;\n\t\tif (hight == 0 && width == 0)break;\n\t\tfor (int y = 0; y < hight + 2; y++){\n\t\t\tchar str[16 + 1];\n\t\t\tif (y == 0 || y == hight + 1){\n\t\t\t\tfor (int x = 0; x < width + 2; x++){\n\t\t\t\t\tmap[x][y] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> str;\n\t\t\t\tmap[0][y] = map[width + 1][y] = -1;\n\t\t\t\tfor (int x = 0; x < width; x++){\n\t\t\t\t\tif (str[x] == 'A'){\n\t\t\t\t\t\tsx = x + 1;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (str[x] == 'B'){\n\t\t\t\t\t\tgx = x + 1;\n\t\t\t\t\t\tgy = y;\n\t\t\t\t\t}\n\t\t\t\t\tmap[x + 1][y] = str[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> move;\n\t\tmemset(data, 0, 16 * 16 * 16 * 16 * 10);\n\t\t\n\t\tmove_count = change(move, mv);\n\t\t\n\t\tcalc(sx, sy, gx, gy, mv, move_count, 0);\n\t\t\n\t\tif (ans == 16 * 16 * 16 * 16 * 10){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << ' ' << ans_y << ' ' << ans_x << endl;\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){\n\tstd::queue<int>q;\n\tint w,h,f[484],i,j,d[]={22,0,-1,0,1,0,-22},a,b,t,x,z;\n\tchar p[15];\n\tfor(;scanf(\"%d%d \",&h,&w),h;){\n\t\tfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tf[x=i*22+j]=-1;\n\t\t\t\tswitch(getchar()){\n\t\t\t\t\tcase'#':--f[x];break;\n\t\t\t\t\tcase'A':a=x;break;\n\t\t\t\t\tcase'B':b=x;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i*22]=f[i*22-~w]=-9;\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tf[a]=t=0;\n\t\tq.push(0);\n\t\tfor(q.push(a);q.size()>1;){\n\t\t\ta=q.front();\n\t\t\tq.pop();\n\t\t\tif(a)\n\t\t\t\tfor(i=0;i<7;i+=2)\n\t\t\t\t\tif(f[x=a+d[i]]==-1)\n\t\t\t\t\t\tf[x]=t,q.push(x);\n\t\t\telse\n\t\t\t\t++t,q.push(0);\n\t\t}\n\t\tq.pop();\n\t\tscanf(\"%s\",p);\n\t\tfor(a=t=0;!a;){\n\t\t\tx=b;\n\t\t\tz=0;\n\t\t\tfor(i=0;!a&&p[i];i++){\n\t\t\t\tt++;\n\t\t\t\tf[j=b+d[p[i]-'2']]>-3?b=j:0;\n\t\t\t\tf[b]>=0&&t>=f[b]?a=b:0;\n\t\t\t\tf[b]>=0&&++z;\n\t\t\t}\n\t\t\t!z&!a&!p[i]&b==x&f[b]<0&&--a;\n\t\t}\n\t\tprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w;\nchar ma[21][21];\nint sx,sy;\nint gx,gy;\nint co[21][21];\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nint main(){\n    cin>>h>>w;\n    memset(co,0,sizeof(co));\n    for(int i=0;i<h;i++){\n        for(int j=0;j<w;j++){\n            cin>>ma[i][j];\n            if(ma[i][j]=='A'){\n                sx=j,sy=i;\n            } else if(ma[i][j]=='B'){\n                gx=j,gy=i;\n            } else if(ma[i][j]=='#'){\n                co[i][j]=INT_MAX;\n            }\n        }\n    }\n    queue<pair<pair<int,int>,int> >q;\n    q.push(make_pair(make_pair(sx, sy), 0));\n    while(q.size()){\n        pair<pair<int,int>,int> p = q.front();\n        co[p.first.second][p.first.first]=p.second;\n        q.pop();\n        for(int i=0;i<4;i++){\n            int nx=p.first.first+dx[i];\n            int ny=p.first.second+dy[i];\n            if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==0){\n                q.push(make_pair(make_pair(nx, ny), p.second));\n            }\n        }\n    }\n    string pat;\n    cin>>pat;\n    int visited[21][21];\n    memset(visited, 0, sizeof(visited));\n    int go=0;\n    for(int i=0;;i=(i+1)%pat.length()){\n        if(visited[gy][gx]==i){\n            cout<<\"impossible\"<<endl;\n            break;\n        }\n        if(pat[i]=='5'){\n            \n        } else if(pat[i]=='8'){\n            gy--;\n        } else if(pat[i]=='6'){\n            gx++;\n        } else if(pat[i]=='4'){\n            gx--;\n        } else if(pat[i]=='2'){\n            gy++;\n        }\n        gy=max(0,gy);\n        gy=min(h-1,gy);\n        gx=max(0,gx);\n        gx=min(w-1,gx);\n        if(co[gy][gx]<=go){\n            cout<<go<<endl;\n            break;\n        }\n        go++;\n        visited[gy][gx]=i;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\nusing namespace std;\n\nint main(){\n\tqueue<int> q;\n\tint w,h,f[484],i,j,d[]={22,0,-1,0,1,0,-22},a,b,t,x;\n\tchar p[15];\n\tfor(;scanf(\"%d%d \",&h,&w),h;){\n\t\tfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tf[x=i*22+j]=-1;\n\t\t\t\tswitch(getchar()){\n\t\t\t\t\tcase'#':--f[x];break;\n\t\t\t\t\tcase'A':a=x;break;\n\t\t\t\t\tcase'B':b=x;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i*22]=f[i*22-~w]=-9;\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tf[a]=t=0;\n\t\tq.push(0);\n\t\tfor(q.push(a);q.size()>1;){\n\t\t\ta=q.front();\n\t\t\tq.pop();\n\t\t\tif(a){\n\t\t\t\tfor(i=0;i<7;i+=2)\n\t\t\t\t\tif(f[x=a+d[i]]==-1){\n\t\t\t\t\t\tf[x]=t;\n\t\t\t\t\t\tq.push(x);\n\t\t\t\t\t}\n\t\t\t}else{\n\t\t\t\t++t;\n\t\t\t\tq.push(0);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t\tscanf(\"%s\",p);\n\t\tfor(a=t=0;!a;){\n\t\t\tx=b;\n\t\t\tfor(i=0;!a&&p[i];i++){\n\t\t\t\tt++;\n\t\t\t\tif(f[j=b+d[p[i]-'2']]>-3)b=j;\n\t\t\t\tif(f[b]>=0&&t>=f[b])a=b;\n\t\t\t}\n\t\t\tif(!a&&!p[i]&&b==x&&f[b]<0)a=-1;\n\t\t}\n\t\tprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[ax][ay] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 100) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint h,w;\nchar field[21][21];\n\nconst int INF=100000000;\n\n// INFツづ按づァツ渉ュツ渉猟つェツ督楪達ツづつォツづ按つ「\nint minArrivalCost[21][21];\n// ツ幽ツ療ャツづ個暗堋督ョツδ仰ーツトツづーツ格ツ納\nvector<pair<int,int> > ghostPath;\n// ツ幽ツ療ャツつェツ津環嘉淞つオツつスツ湘ェツ渉環づーツ格ツ納\nbool passedGhost[11][21][21];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\n// ツ渉ュツ渉猟つェツ各ツマツスツづ鳴つスツづづィツ陳つュツつスツづ淞づ個催渉ャツコツスツトツづーツ仰づ淞づゥ\nvoid bfs(int sx,int sy){\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> > ();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> > ();\n\tprv->push(make_pair(sy,sx));\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tpassed[i][j]=false;\n\t\t}\n\t}\n\tint cnt=0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp=prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\tminArrivalCost[cp.first][cp.second]=min(minArrivalCost[cp.first][cp.second],cnt);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tnp.first+=dy[i];\n\t\t\t\tnp.second+=dx[i];\n\t\t\t\tif(np.first>=0&&np.second>=0&&np.first<h&&np.second<w){\n\t\t\t\t\tif(!passed[np.first][np.second]&&field[np.first][np.second]!='#'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\n\tdelete prv,nxt;\n}\n\nint main(){\n\n\twhile(cin>>h>>w&&!(h==0&&w==0)){\n\t\tghostPath.clear();\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 11; k++){\n\t\t\t\t\tpassedGhost[k][i][j]=false;\n\t\t\t\t}\n\t\t\t\tminArrivalCost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='A'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='B'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tbfs(sx,sy);\n\n\t\tpair<int,int> cp=make_pair(gy,gx);\n\t\twhile(1){\n\t\t\tbool f=false;\n\t\t\tfor(int i = 0; i < pattern.size(); i++){\n\t\t\t\tif(passedGhost[i][cp.first][cp.second]){\n\t\t\t\t\tf=true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tpassedGhost[i][cp.first][cp.second]=true;\n\t\t\t\tghostPath.push_back(cp);\n\t\t\t\tchar c = pattern[i];\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tif(c=='8'){\n\t\t\t\t\tnp.first-=1;\n\t\t\t\t}\n\t\t\t\telse if(c=='6'){\n\t\t\t\t\tnp.second+=1;\n\t\t\t\t}\n\t\t\t\telse if(c=='4'){\n\t\t\t\t\tnp.second-=1;\n\t\t\t\t}\n\t\t\t\telse if(c=='2'){\n\t\t\t\t\tnp.first++;\n\t\t\t\t}\n\t\t\t\tif(np.first<0)\n\t\t\t\t\tnp.first=0;\n\t\t\t\telse if(np.first>=h)\n\t\t\t\t\tnp.first=h-1;\n\t\t\t\telse if(np.second>=w)\n\t\t\t\t\tnp.second=w-1;\n\t\t\t\telse if(np.second<0)\n\t\t\t\t\tnp.second=0;\n\t\t\t\tcp=np;\n\t\t\t}\n\t\t\tif(f)\n\t\t\t\tbreak;\n\t\t}\n\t\tint minCost=INF;\n\t\tpair<int,int> rp;\n\t\t// ツ各ツ幽ツ療ャツづ個督楪達ツポツイツδ督トツづ可づつつ「ツづ、ツ氾楪渉猟つェツ督楪達ツづつォツづつ「ツづゥツつゥツづつ、ツつゥツづーツづ敖づゥ\n\t\tfor(int i = 0; i < ghostPath.size(); i++){\n\t\t\tcp=ghostPath[i];\n\t\t\tint cst=minArrivalCost[cp.first][cp.second];\n\t\t\tif(cst!=INF){\n\t\t\t\t// ツ渉ュツ渉猟づ個督楪達ツつェツ幽ツ療ャツづ個督楪達ツづヲツづィツ堕つゥツづつスツ湘ェツ債\t\t\t\tif(cst<=i){\n\t\t\t\t\tif(minCost>i){\n\t\t\t\t\t\trp=cp;\n\t\t\t\t\t\tminCost=min(minCost,i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// ­ÌBªHìæèx©Á½ê\n\t\t\t\telse{\n\t\t\t\t\t// Hìª­éÜÅÒÂ\n\t\t\t\t\tint cnt=cst;\n\t\t\t\t\tint j=(cst)%ghostPath.size();\n\t\t\t\t\twhile(1){\n\t\t\t\t\t\tif(ghostPath[j]==cp){\n\t\t\t\t\t\t\tif(minCost>cnt){\n\t\t\t\t\t\t\t\tminCost=min(minCost,cnt);\n\t\t\t\t\t\t\t\trp=cp;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tj=(j+1)%ghostPath.size();\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost==INF)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse{\n\t\t\tcout<<minCost<<\" \"<<rp.first<<\" \"<<rp.second<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){\nstd::queue<int>q;\nint w,h,f[484],i,j,a,b,t,x,z;\nchar p[15];\nfor(;scanf(\"%d%d \",&h,&w),h;){\nfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\nfor(i=1;i<=h;i++){\nfor(j=1;j<=w;j++)\nf[x=i*22+j]=-1,\nz=getchar(),\nz-35?z>65?b=x:z>64?a=x:1:--f[x];\nf[i*22]=f[i*22-~w]=-9;\ngetchar();\n}\n\nf[a]=t=0;\nq.push(0);\nfor(q.push(a);a=q.front(),q.size()>1;q.pop())\nif(!a)++t,q.push(0);\nelse for(i=4;i--;)\nif(f[x=a+\" 57L\"[i]-54]==-1)\nf[x]=t,q.push(x);\n\nq.pop();\nscanf(\"%s\",p);\nfor(a=t=0;!a;){\nx=b;\nz=0;\nfor(i=0;!a&&p[i];i++){\nt++;\nf[j=b-54+\"L65676 \"[p[i]-50]]>-3?b=j:0;\nf[b]>=0&&t>=f[b]?a=b:0;\nf[b]>=0&&++z;\n}\n!z&!a&!p[i]&b==x&f[b]<0&&--a;\n}\nprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF 999999999\n\nint h,w;\nstring data[30];\nbool visited[30][30];\nint dist[30][30];\n\nvoid dfs(int y,int x){\n\tif( y<0 || h<=y || x<0 || w<=x || visited[y][x]==true || data[y][x]=='#' )return ;\n\n\tvisited[y][x]=true;\n\n\tint left=INF,right=INF,up=INF,down=INF;\n\tif(x-1>=0) left  = dist[y][x-1]+1;\n\tif(y-1>=0) up \t = dist[y-1][x]+1;\n\tif(x+1<w ) right = dist[y][x+1]+1;\n\tif(y+1<h ) down  = dist[y+1][x]+1;\n\n\tdist[y][x] = min( dist[y][x] , min( min(left,right) , min(up,down) ) );\n\n\n\tdfs(y,x+1);\n\tdfs(y,x-1);\n\tdfs(y+1,x);\n\tdfs(y-1,x);\n\n}\n\n\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(h==0&&w==0)break;\n\n\t\tstring move;\n\t\tint sx,sy,gx,gy;\n\t\trep(i,30)rep(j,30)visited[i][j]=false;\n\t\trep(i,30)rep(j,30)dist[i][j]=INF;\n\n\t\trep(i,h)cin>>data[i];\n\t\tcin>>move;\n\n\t\trep(i,h)rep(j,w){\n\t\t\tif(data[i][j]=='A'){\n\t\t\t\tsy=i;sx=j;\n\t\t\t\tdata[i][j]='.';\n\t\t\t}\n\t\t\tif(data[i][j]=='B'){\n\t\t\t\tgy=i;gx=j;\n\t\t\t\tdata[i][j]='.';\n\t\t\t}\n\t\t}\n\n\t\tdist[sy][sx]=0;\n\t\tdfs(sy,sx);\n\n\t\tfor(int i=0;;i++){\n\t\t\tif(dist[gy][gx]<=i){\n\t\t\t\tcout<<i<<\" \"<<gy<<\" \"<<gx<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(i>=1000000){\n\t\t\t\tcout<<\"impossible\"<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tif(move[i%move.size()]=='5');\n\t\t\tif(move[i%move.size()]=='8')if(0<=gy-1)gy--;\n\t\t\tif(move[i%move.size()]=='6')if(gx+1<w) gx++;\n\t\t\tif(move[i%move.size()]=='4')if(0<=gx-1)gx--;\n\t\t\tif(move[i%move.size()]=='2')if(gy+1<h) gy++;\n\t\t}\n\t}\n\n}\n\n\n/*\n'5'\t????????´????????????\n'8'\t??????1????????????\n'6'\t??±???1????????????\n'4'\t?\\????1????????????\n'2'\t??????1????????????\n*/"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nchar g[20][20];\nint h,w;\nint t[20][20];\n\nstruct S{\n  int t,x,y;\n};\n\nint main(){\n  while(cin>>h>>w,h|w){\n    int ax,ay,bx,by;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n\tif(g[y][x]=='A'){\n\t  ax=x;\n\t  ay=y;\n\t}else if(g[y][x]=='B'){\n\t  bx=x;\n\t  by=y;\n\t}\n      }\n    }\n    fill(t[0],t[20],1<<30);\n    queue<S> que;\n    S is={0,ax,ay};\n    que.push(is);\n    while(!que.empty()){\n      int x=que.front().x;\n      int y=que.front().y;\n      int ct=que.front().t;\n      que.pop();\n      if(x<0||w<=x||y<0||h<=y||t[y][x]<ct||g[y][x]=='#')continue;\n      t[y][x]=ct;\n      for(int i=0;i<4;i++){\n\tint d[]={0,1,0,-1,0};\n\tS ns={ct+1,x+d[i],y+d[i+1]};\n\tque.push(ns);\n      }\n    }\n    string p;\n    cin>>p;\n    int e;\n    for(e=0;e<10000;e++){\n      if(t[by][bx]<=e)break;\n      char o=p[e%p.size()];\n      int ny=by+(o=='2')-(o=='8');\n      int nx=bx+(o=='6')-(o=='4');\n      if(0<=ny&&ny<h&&0<=nx&&nx<w){\n\tby=ny;\n\tbx=nx;\n      }\n    }\n    if(e<10000){\n      cout<<e<<' '<<by<<' '<<bx<<endl;\n    }else{\n      cout<<\"impossible\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[0][0] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 8000000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define SIZE 21\n\nclass Point {\npublic:\n    int r, c;\n    Point( int r, int c ) : r(r), c(c) {};\n    Point() { r = 0, c = 0; };\n\n    bool operator == ( const Point& right ) const\n    {\n        return r == right.r && c == right.c;\n    }\n\n    bool operator < ( const Point& right ) const\n    {\n        return r != right.r ? r < right.r : c < right.c;\n    }\n};\n\ntypedef pair <Point, Point> PPP;\ntypedef pair <int, PPP> PIP;\n\nint h, w;\nint m[SIZE][SIZE];\n\n// for girl\nbool check_girl( Point p )\n{\n    int r = p.r, c = p.c;\n    if ( r >= 0 && r < h && c >= 0 && c < w ) {\n        if ( m[r][c] == 0 ) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// for ghost\nbool check_ghost( Point p )\n{\n    int r = p.r, c = p.c;\n    return r >= 0 && r < h && c >= 0 && c < w;\n}\n\nint main( void )\n{\n    string line;\n    while ( getline( cin, line ) ) {\n        // input\n        istringstream is(line);\n        is >> h >> w;\n        if ( h == 0 && w == 0 ) break;\n        \n        for ( int i = 0; i < h; i++ )\n        {\n            getline( cin, line );\n            for ( int j = 0; j < w; j++ ) {\n                if ( line[j] == '.' ) {\n                    m[i][j] = 0;\n                } else if ( line[j] == '#' ) {\n                    m[i][j] = 1;\n                } else if ( line[j] == 'A' ) {\n                    m[i][j] = 2;\n                } else if ( line[j] == 'B' ) {\n                    m[i][j] = 3;\n                }\n            }\n        }\n\n        string op;\n        getline( cin, op );\n        int opsize = op.size();\n\n        queue <PIP> Q;\n        set <PIP>   V;\n        {\n            // start node\n            Point start, goal;\n            for ( int i = 0; i < h; i++ ) for ( int j = 0; j < w; j++ ) {\n                if ( m[i][j] == 2 ) {\n                    start.r = i;\n                    start.c = j;\n                    m[i][j] = 0;\n                } else if ( m[i][j] == 3 ) {\n                    goal.r = i;\n                    goal.c = j;\n                    m[i][j] = 0;\n                }\n            }\n\n            PPP init_second( start, goal );\n            PIP init( 0, init_second );\n            Q.push( init );\n            V.insert( init );\n        }\n\n        // bfs\n        int a_first = -1, a_second, a_third;\n        while ( !Q.empty() ) {\n            PIP e = Q.front();\n            Q.pop();\n            int t = e.first;\n            Point s = e.second.first, g = e.second.second;\n\n            // is it goal?\n            if ( s == g ) {\n                a_first = t;\n                a_second = s.r;\n                a_third = s.c;\n                break;\n            }\n\n            // move ghost\n            int index = t % opsize;\n            char c = op[index];\n            \n            Point next_s = s, next_g = g;\n            int next_t = t+1;\n            int next_index = ( next_t ) % opsize;\n            if ( c == '5' ) {\n                // stop\n            } else if ( c == '8' ) {\n                // north\n                next_g.r -= 1;\n            } else if ( c == '6' ) {\n                // east\n                next_g.c += 1;\n            } else if ( c == '4' ) { \n                // west\n                next_g.c -= 1;\n            } else if ( c == '2' ) {\n                // south\n                next_g.r += 1;\n            }\n            if ( !check_ghost( next_g ) ) next_g = g;\n\n            // move girl\n            int dr[5] = { 0, -1, 0, 0, 1 };\n            int dc[5] = { 0, 0, 1, -1, 0 };\n            Point backup = next_s;\n            for ( int k = 0; k < 5; k++ ) {\n                next_s = backup;\n                next_s.r += dr[k];\n                next_s.c += dc[k];\n                PPP next_second( next_s, next_g );\n                PIP next_check( next_index, next_second );\n\n                // already visited\n                if ( V.count( next_check ) ) continue;\n                if ( !check_girl( next_s ) )  continue;\n                V.insert( next_check );\n                \n                PIP next( next_t, next_second );\n                Q.push( next );\n            }\n        } // end of bfs\n\n        if ( a_first == -1 ) {\n            cout << \"impossible\" << endl;\n        } else {\n            cout << a_first << \" \" << a_second << \" \" << a_third << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int dx[4] = {1,-1,0,0};\nconst int dy[4] = {0,0,1,-1};\n\nconst int gdx[10] = {\n  0,\n  0,0,0,\n  -1,0,1,\n  0,0,0\n};\n\nconst int gdy[10] = {\n  0,\n  0,1,0,\n  0,0,0,\n  0,-1,0\n};\n\nint main(){\n  int h,w;\n  while(cin>>h>>w, h+w){\n    string buff[h];\n    int dist[h][w];\n    int mx,my,gx,gy;\n\n    REP(i,h) cin>>buff[i];\n    REP(i,h){\n      REP(j,w){\n        dist[i][j] = -1;\n        if(buff[i][j] == 'A'){\n          mx = j; my = i;\n          buff[i][j] = '.';\n        }else if(buff[i][j] == 'B'){\n          gx = j; gy = i;\n          buff[i][j] = '.';\n        }\n      }\n    }\n\n    queue<pair<int,int> > q;\n    q.push(mp(mx,my)); dist[mx][my]=0;\n    int last = 0;\n    while(!q.empty()){\n      int x = q.front().f;\n      int y = q.front().s;\n      q.pop();\n\n      REP(i,4){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(xx < 0 || yy < 0) continue;\n        if(xx >=w || yy >=h) continue;\n        if(buff[yy][xx] == '#') continue;\n        if(dist[yy][xx] != -1) continue;\n        dist[yy][xx] = dist[y][x] + 1;\n        q.push(mp(xx,yy));\n      }\n    }\n\n    //REP(i,h){ REP(j,w) printf(\"  %c\",buff[i][j]); puts(\"\");}\n    //REP(i,h){ REP(j,w) printf(\"%3d\",dist[i][j]); puts(\"\");}\n\n    string pat;\n    cin>>pat;\n    int plen = pat.size();\n    if(!isdigit(pat[plen-1])) plen--;\n    bool flag[h][w][plen]; memset(flag, 0, sizeof(flag));\n    int turn = 0;\n    while(true){\n      int pp = pat[turn % plen] - '0'; turn++;\n      int xx = gx + gdx[pp];\n      int yy = gy + gdy[pp];\n\n      if(xx < 0 || yy < 0 || xx >=w || yy >=h){\n        xx = gx; yy = gy;\n      }\n\n      //printf(\"goast: (%d,%d) pp=%d\\n\",xx,yy,pp);\n\n      if(dist[yy][xx] != -1 && dist[yy][xx] <= turn){\n        printf(\"%d %d %d\\n\",turn,yy,xx);\n        break;\n      }\n\n      if(flag[yy][xx][turn % plen]){\n        puts(\"impossible\");\n        break;\n      }\n\n      if(turn >= w * h)\n        flag[yy][xx][turn % plen] = true;\n\n      gx = xx; gy = yy;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<string>\nusing namespace std;\n\n#define MAX 20\n#define PMAX 10\n#define rep(i, n) for ( int i = 0; i < (int)n; i++ )\n#define INFTY (1<<21)\n\nstruct State{ int a, b, cur; };\n\nint H, W;\nstring P;\nchar G[MAX][MAX];\n\nint getDi( char ch ){\n    if ( ch == '5' || ch == '4' || ch == '6') return 0;\n    else if ( ch == '2' ) return 1;\n    else if ( ch == '8' ) return -1;\n}\n\nint getDj( char ch ){\n    if ( ch == '5' || ch == '2' || ch == '8') return 0;\n    else if ( ch == '6' ) return 1;\n    else if ( ch == '4' ) return -1;\n}\n\nint bfs(int as, int bs, int &g){\n    int D[MAX*MAX][MAX*MAX][PMAX];\n    rep(i, H*W) rep(j, H*W) rep(k, P.size()) {\n\tD[i][j][k] = INFTY;\n    }\n    State s;\n    s.a = as;\n    s.b = bs;\n    s.cur = 0;\n    queue<State> Q;\n\n    Q.push(s);\n    D[s.a][s.b][s.cur] = 0;\n\n    static const int di[5] = {0, 0, -1, 0, 1};\n    static const int dj[5] = {0, 1, 0, -1, 0};\n\n    State u, v;\n    while( !Q.empty() ){\n\tu = Q.front(); Q.pop();\n\tif ( u.a == u.b ) {\n\t    g = u.a;\n\t    return D[u.a][u.b][u.cur];\n\t}\n\t\n\tint ni, nj;\n\tfor ( int r = 0; r < 5; r++ ){\n\t    ni = u.a/W + di[r];\n\t    nj = u.a%W + dj[r];\n\t    if ( ni < 0 || nj < 0 || ni >= H || nj >= W ) continue;\n\t    if ( G[ni][nj] == '#' ) continue;\n\n\t    v = u;\n\t    v.a = ni*W + nj;\n\n\t    ni = v.b/W + getDi(P[v.cur]);\n\t    nj = v.b%W + getDj(P[v.cur]);\n\t    \n\t    if ( ni < 0 || nj < 0 || ni >= H || nj >= W ){\n\t\tni = v.b/W;\n\t\tnj = v.b%W;\n\t    }\n\n\t    v.cur = (v.cur+1)%P.size();\n\t    v.b = ni*W + nj;\n\t    \n\t    if ( D[v.a][v.b][v.cur] == INFTY ){\n\t\tD[v.a][v.b][v.cur] = D[u.a][u.b][u.cur] + 1;\n\t\tQ.push(v);\n\t    }\n\t}\n    }\n\n    return INFTY;\n}\n\nmain(){\n    while( cin >> H >> W && H && W ){\t\n\tint s, g, p;\n\trep(i, H) rep(j, W) {\n\t    cin >> G[i][j];\n\t    if ( G[i][j] == 'A' ){ G[i][j] = '.'; s = i*W+j; }\n\t    if ( G[i][j] == 'B' ){ G[i][j] = '.'; p = i*W+j; }\n\t}\n\tcin >> P;\n\tint cost = bfs(s, p, g);\n\tif ( cost == INFTY ) cout << \"impossible\" << endl;\n\telse cout << cost << \" \" << g/W << \" \" << g%W << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\nint H, W;\nchar grid[25][25];\nstring pat;\nint grid2[25][25];\nint ay, ax;\nint by, bx;\n\nvoid bfs()\n{\n    const int INF = 100000000;\n    int dy[4] = {0, -1, 0, 1};\n    int dx[4] = {-1, 0, 1, 0};\n\n    typedef pair<int, int> P;\n\n    queue<P> que;\n    rep(i,H) rep(j,W) {\n        grid2[i][j] = INF;\n    }\n\n    que.push(P(ay, ax));\n    grid2[ay][ax] = 0;\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        rep(i,4) {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n\n            if (0 <= ny && ny < H && 0 <= nx && nx < W && grid[ny][nx] == '.' && grid2[ny][nx] == INF) {\n                que.push(P(ny, nx));\n                grid2[ny][nx] = grid2[p.first][p.second] + 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n#ifdef LOCAL\n    ifstream in(\"input.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n\n    while (true) {\n        cin >> H >> W;\n        if (H == 0 && W == 0) break;\n\n        rep(i,H) rep(j,W) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'A') {\n                ay = i;\n                ax = j;\n                grid[i][j] = '.';\n            } else if (grid[i][j] == 'B') {\n                by = i;\n                bx = j;\n                grid[i][j] = '.';\n            }\n        }\n        cin >> pat;\n\n        /*\n        int sy = 0, sx = 0;\n        rep(i,pat.length()) {\n            if (pat[i] == '5') {\n                sy += 0;\n                sx += 0;\n            } else if(pat[i] == '4') {\n                sy += 0;\n                sx -= 1;\n            } else if (pat[i] == '8') {\n                sy -= 1;\n                sx += 0;\n            } else if (pat[i] == '6') {\n                sy += 0;\n                sx += 1;\n            } else if (pat[i] == '2') {\n                sy += 1;\n                sx += 0;\n            }\n        }\n        bool try_only_one = false;\n        if (sy == 0 && sx == 0) try_only_one = true;\n        */\n\n        bfs();\n\n        rep(i,H) {\n            rep(j,W) {\n                printf(\"% 3d \", grid2[i][j]);\n            }\n            cout << endl;\n        }\n\n        bool possible = false;\n        int ans;\n        int ansy, ansx;\n        int cnt = 0;\n        rep(i,100) {\n            rep(j,pat.length()) {\n                cnt++;\n                if (pat[j] == '5') {\n                    by += 0;\n                    bx += 0;\n                } else if(pat[j] == '4') {\n                    by += 0;\n                    if (bx >= 1) bx -= 1;\n                } else if (pat[j] == '8') {\n                    if (by >= 1) by -= 1;\n                    bx += 0;\n                } else if (pat[j] == '6') {\n                    by += 0;\n                    if (bx < W - 1) bx += 1;\n                } else if (pat[j] == '2') {\n                    if (by < H - 1) by += 1;\n                    bx += 0;\n                }\n                if (grid2[by][bx] <= cnt && !possible) {\n                    possible = true;\n                    ans = cnt;\n                    ansy = by;\n                    ansx = bx;\n                }\n            }\n        }\n\n        if (possible) {\n            cout << ans << \" \" << ansy << \" \" << ansx << endl;\n        } else {\n            cout << \"impossible\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define mp(a,b,c) make_pair(make_pair(a,b),c)\n\nint h,w,sx,sy,gx,gy,m=9999;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(mp(sx, sy, 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(mp(nx, ny, p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;int i=j%pat.length();j++,go++){\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>100000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\ntypedef long long int ll;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000001\nusing namespace std;\n\nint H,W;\n\nint diff_row[5] = {-1,0,0,1,0},diff_col[5] = {0,-1,1,0,0};\nchar map[20][21],pattern[11];\nbool***** check;\n\nstruct Info{\n\tint my_row,my_col,my_time,enemy_row,enemy_col;\n};\n\nbool rangeCheck(int row,int col){\n\tif(row >= 0 && row <= H-1 && col >= 0 && col <= W-1)return true;\n\telse{\n\t\treturn false;\n\t}\n}\n\n\nint main(){\n\n\tbool FLG;\n\tint ans_row,ans_col,ans_time,next_my_row,next_my_col,next_enemy_row,next_enemy_col,pattern_length,tmp;\n\tcheck = new bool****[20];\n\tfor(int i = 0; i < 20; i++){\n\t\tcheck[i] = new bool***[20];\n\t\tfor(int a = 0; a < 20; a++){\n\t\t\tcheck[i][a] = new bool**[20];\n\t\t\tfor(int b = 0; b < 20; b++){\n\t\t\t\tcheck[i][a][b] = new bool*[20];\n\t\t\t\tfor(int c = 0; c < 20; c++)check[i][a][b][c] = new bool[10];\n\t\t\t}\n\t\t}\n\t}\n\n\twhile(true){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(H == 0 && W == 0)break;\n\n\t\tFLG = false;\n\t\tInfo first;\n\n\t\tfirst.my_time = 0;\n\n\t\tfor(int a = 0; a < H; a++){\n\t\t\tfor(int b = 0; b < W; b++){\n\t\t\t\tfor(int c = 0; c < H; c++){\n\t\t\t\t\tfor(int d = 0; d < W; d++){\n\t\t\t\t\t\tfor(int e = 0; e < 10;e++)check[a][b][c][d][e] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < H; i++){\n\t\t\tscanf(\"%s\",map[i]);\n\t\t\tfor(int k = 0; k < W; k++){\n\t\t\t\tswitch(map[i][k]){\n\t\t\t\tcase 'A':\n\t\t\t\t\tfirst.my_row = i;\n\t\t\t\t\tfirst.my_col = k;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tfirst.enemy_row = i;\n\t\t\t\t\tfirst.enemy_col = k;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:break;\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\",pattern);\n\t\tfor(pattern_length = 0; pattern[pattern_length] != '\\0';pattern_length++);\n\n\t\tqueue<Info> Q;\n\n\t\tQ.push(first);\n\n\t\twhile(!Q.empty()){\n\n\t\t\tif(Q.front().my_row == Q.front().enemy_row && Q.front().my_col == Q.front().enemy_col){\n\t\t\t\tFLG = true;\n\t\t\t\tans_row = Q.front().my_row;\n\t\t\t\tans_col = Q.front().my_col;\n\t\t\t\tans_time = Q.front().my_time;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tQ.front().my_time++;\n\n\t\t\ttmp = (Q.front().my_time-1+pattern_length)%pattern_length;\n\t\t\tswitch(pattern[tmp]){\n\t\t\tcase '5':\n\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\tbreak;\n\t\t\tcase '2':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row+1,Q.front().enemy_col)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row+1;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '4':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row,Q.front().enemy_col-1)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col-1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '6':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row,Q.front().enemy_col+1)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col+1;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase '8':\n\t\t\t\tif(rangeCheck(Q.front().enemy_row-1,Q.front().enemy_col)){\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row-1;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}else{\n\t\t\t\t\tnext_enemy_row = Q.front().enemy_row;\n\t\t\t\t\tnext_enemy_col = Q.front().enemy_col;\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < 5; i++){\n\t\t\t\tnext_my_row = Q.front().my_row + diff_row[i];\n\t\t\t\tnext_my_col = Q.front().my_col + diff_col[i];\n\n\t\t\t\tif(rangeCheck(next_my_row,next_my_col) == true && map[next_my_row][next_my_col] != '#' &&\n\t\t\t\t\t\tcheck[next_my_row][next_my_col][next_enemy_row][next_enemy_col][tmp] == false){\n\t\t\t\t\tcheck[next_my_row][next_my_col][next_enemy_row][next_enemy_col][tmp] = true;\n\t\t\t\t\tInfo next;\n\t\t\t\t\tnext.enemy_row = next_enemy_row;\n\t\t\t\t\tnext.enemy_col = next_enemy_col;\n\t\t\t\t\tnext.my_row = next_my_row;\n\t\t\t\t\tnext.my_col = next_my_col;\n\t\t\t\t\tnext.my_time = Q.front().my_time;\n\t\t\t\t\tQ.push(next);\n\t\t\t\t}else{\n\t\t\t\t\tif(check[Q.front().my_row][Q.front().my_col][next_enemy_row][next_enemy_col][tmp] == false){\n\t\t\t\t\t\tcheck[Q.front().my_row][Q.front().my_col][next_enemy_row][next_enemy_col][tmp] = true;\n\t\t\t\t\t\tInfo next;\n\t\t\t\t\t\tnext.enemy_row = next_enemy_row;\n\t\t\t\t\t\tnext.enemy_col = next_enemy_col;\n\t\t\t\t\t\tnext.my_row = Q.front().my_row;\n\t\t\t\t\t\tnext.my_col = Q.front().my_col;\n\t\t\t\t\t\tnext.my_time = Q.front().my_time;\n\t\t\t\t\t\tQ.push(next);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\n\t\tif(!FLG){\n\t\t\tprintf(\"impossible\\n\");\n\t\t}else{\n\t\t\tprintf(\"%d %d %d\\n\",ans_time,ans_row,ans_col);\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++) \n\nint dx[] = { 0, 0,-1, 1, 0};\nint dy[] = { 1,-1, 0, 0, 0};\n\nclass NODE{\npublic:\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n\tint depth;\n};\n\nint conv(char c){\n\tswitch(c){\n\tcase '2':return 0;\n\tcase '4':return 2;\n\tcase '8':return 1;\n\tcase '6':return 3;\n\tcase '5':return 4;\n\t}\n\tcout << \"aaaaaaaa\" << endl;\n}\nint main(){\n\tint X,Y,tx,ty,kx,ky;\n\tchar data[22][22];\n\tstring cmd;\n\twhile(cin >> Y >> X , X){\n\t\trep(i,22)rep(j,22)data[i][j] = '+';\n\t\trep(i,Y)rep(j,X){\n\t\t\tcin >> data[1+i][1+j];\n\t\t\tif(data[1+i][1+j] == 'A'){\n\t\t\t\ttx = 1+j;\n\t\t\t\tty = 1+i;\t\t\t\t\n\t\t\t\tdata[1+i][1+j] = '.';\n\t\t\t}\n\t\t\tif(data[1+i][1+j] == 'B'){\n\t\t\t\tkx = 1+j;\n\t\t\t\tky = 1+i;\t\t\t\t\n\t\t\t\tdata[1+i][1+j] = '.';\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcin >> cmd;\n\t\tqueue<NODE> Q;\n\t\tNODE t = {tx,ty,kx,ky,0};\n\t\tQ.push(t);\n\t\t\n\t\tbool done[22][22][22][22][10] = {0};\n\t\t\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.front();Q.pop();\n\t\t\tif( done[q.x1][q.y1][q.x2][q.y2][q.depth%cmd.size()] )continue;\n\t\t\tdone[q.x1][q.y1][q.x2][q.y2][q.depth%cmd.size()] = true;\n\t\t\t\n\t\t\tif(q.x1 == q.x2 && q.y1 == q.y2){\n\t\t\t\tcout << q.depth << \" \" <<  q.y1-1 << \" \" << q.x1-1 << endl;\n\t\t\t\tgoto end;\n\t\t\t}\n\t\t\trep(i,5){\n\t\t\t\tNODE next;\n\t\t\t\tnext.x1 = q.x1 + dx[i];\n\t\t\t\tnext.y1 = q.y1 + dy[i];\n\t\t\t\tnext.x2 = q.x2 + dx[ conv( cmd[q.depth%cmd.size()] ) ];\n\t\t\t\tnext.y2 = q.y2 + dy[ conv( cmd[q.depth%cmd.size()] ) ];\n\t\t\t\tnext.depth = q.depth + 1;\n\t\t\t\tif(data[next.y1][next.x1] != '.'){\n\t\t\t\t\tnext.x1 = q.x1;\n\t\t\t\t\tnext.y1 = q.y1;\n\t\t\t\t}\n\t\t\t\tif(data[next.y2][next.x2] == '+'){\n\t\t\t\t\tnext.x2 = q.x2;\n\t\t\t\t\tnext.y2 = q.y2;\n\t\t\t\t}\n\t\t\t\tQ.push(next);\n\t\t\t}\n\t\t}\n\t\tcout << \"impossible\" << endl;\n\t\tend:;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define f(a,b) for(int a=0;a<b;a++)\n\nint h,w,x,y,sx,sy,gx,gy,i,j,g,m = 999999;\nint dx[4]={1,0,-1,0};\nint c[20][20];\nchar n[20][20];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        f(i,h)f(j,w){\n                c[i][j]=m;\n                cin>>n[i][j];\n                if(n[i][j]=='A')\n                    sx=j,sy=i;\n                else if(n[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(c[p.fs][p.ff]!=m)\n                continue;\n            c[p.fs][p.ff]=p.second;\n            f(i,4){\n                x=p.ff+dx[i];\n                y=p.fs+dx[(i+1)%4];\n                if(x>=0&&x<w&&y>=0&y<h&&n[y][x]!='#'&&c[y][x]==m)\n                    q.push(make_pair(make_pair(x, y), p.second+1));\n            }\n        }\n        cin>>pat;\n        g=0;\n        f(j,m){\n            i=j%pat.length();\n            if(c[gy][gx]<=g){\n                cout<<g<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(g>700){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n            g++;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define REP(i,n) for(ll i=0;i<n;i++)\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint h, w, ax, ay, bx, by, t, flag;\nchar field[30][30];\nchar pattern[20];\n\nint main() {\n\n\twhile(true) {\n\n\t\tscanf(\"%d%d\", &h, &w);\n\n\t\tif (h == 0 && w == 0) break;\n\n\t\tREP(y,h) {\n\t\t\tscanf(\"%s\", field[y]);\n\t\t\tREP(x,w) {\n\t\t\t\tif (field[y][x] == 'A') {\n\t\t\t\t\tax = x;\n\t\t\t\t\tay = y;\n\t\t\t\t} else if (field[y][x] == 'B') {\n\t\t\t\t\tbx = x;\n\t\t\t\t\tby = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\", pattern);\n\n\t\tint leng = strlen(pattern);\n\n\t\tt = 0, flag = 0;\n\n\t\tqueue<pii> q, nq;\n\t\tq.push(pii(ax,ay));\n\n\t\tREP(i,200) {\n\t\t\tt++;\n\n\t\t\t// girl\n\t\t\twhile(!q.empty()) {\n\t\t\t\tpii p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tREP(j,4) {\n\t\t\t\t\tint nx = p.first + dx[j];\n\t\t\t\t\tint ny = p.second + dy[j];\n\t\t\t\t\tif (0<=nx&&nx<w && 0<=ny&&ny<h && field[ny][nx]!='#' && field[ny][nx]!='A') {\n\t\t\t\t\t\tfield[ny][nx] = 'A';\n\t\t\t\t\t\tnq.push(pii(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!nq.empty()) {\n\t\t\t\tq.push(nq.front());\n\t\t\t\tnq.pop();\n\t\t\t}\n\n\t\t\t// ghost\n\t\t\tswitch(pattern[i%leng]) {\n\t\t\t\tcase '5':\n\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\tby--;\n\t\t\t\tif(by<0)by=0;\n\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\tbx++;\n\t\t\t\tif(bx>=w)bx=w-1;\n\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\tbx--;\n\t\t\t\tif(bx<0)bx=0;\n\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\tby++;\n\t\t\t\tif(by>=h)by=h-1;\n\t\t\t\tbreak;\t\n\t\t\t}\n\n\t\t\tif (field[by][bx] == 'A') {\n\t\t\t\tflag = 1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (flag == 0) {\n\t\t\tprintf(\"impossible\\n\");\n\t\t} else {\n\t\t\tprintf(\"%d %d %d\\n\", t, by, bx);\n\t\t}\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define mp(a,b,c) make_pair(make_pair(a,b),c)\n\nint h,w,sx,sy,gx,gy,m=99999;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(mp(sx, sy, 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(mp(nx, ny, p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;int i=j%pat.length();j++,go++){\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>100000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n\tint x, y;\n} Vector;\n\ntypedef struct {\n\tint x, y;\n\tint step;\n} DATA;\n\nunsigned int data[16 + 2][16 + 2];\nchar map[16 + 2][16 + 2];\n\nint change(char move[], Vector mv[])\n{\n\tint i = 0;\n\twhile (move[i] != '\\0'){\n\t\tmv[i].x = mv[i].y = 0;\n\t\tswitch (move[i]){\n\t\t  case '5':\n\t\t  \tbreak;\n\t\t  case '8':\n\t\t  \tmv[i].y = -1;\n\t\t\tbreak;\n\t\t  case '6':\n\t\t  \tmv[i].x = 1;\n\t\t\tbreak;\n\t\t  case '4':\n\t\t  \tmv[i].x = -1;\n\t\t\tbreak;\n\t\t  case '2':\n\t\t  \tmv[i].y = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn (i);\n}\n\nunsigned int move_sml(int gx, int gy, Vector mv[], int move_count, int* ans_x, int* ans_y)\n{\n\tunsigned int ret = 0xffffffff;\n\tfor (unsigned int i = 0; i < 1000000; i++){\n\t\tint mx = mv[i % move_count].x;\n\t\tint my = mv[i % move_count].y;\n\t\t\n\t\tif (data[gx][gy] <= i && ret > i){\n\t\t\tret = max(data[gx][gy], i);\n\t\t\t*ans_x = gx;\n\t\t\t*ans_y = gy;\n\t\t}\n\t\t\n\t\tif (map[gx + mx][gy + my] != -1){\n\t\t\tgx += mx;\n\t\t\tgy += my;\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint move_short_root(int sx, int sy)\n{\n\tlist<DATA> lst;\n\tDATA add;\n\t\n\tdata[sx][sy] = 0;\n\t\n\tadd.x = sx + 1;\n\tadd.y = sy;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx - 1;\n\tadd.y = sy;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx;\n\tadd.y = sy + 1;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx;\n\tadd.y = sy - 1;\n\tadd.step = 1;\n\tlst.push_back(add);\n\t\n\twhile (!lst.empty()){\n\t\tif (map[lst.front().x][lst.front().y] != -1 && map[lst.front().x][lst.front().y] != '#' && data[lst.front().x][lst.front().y] > lst.front().step){\n\t\t\tdata[lst.front().x][lst.front().y] = lst.front().step;\n\t\t\tadd.x = lst.front().x + 1;\n\t\t\tadd.y = lst.front().y;\n\t\t\tadd.step = lst.front().step + 1;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x - 1;\n\t\t\tadd.y = lst.front().y;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x;\n\t\t\tadd.y = lst.front().y + 1;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x;\n\t\t\tadd.y = lst.front().y - 1;\n\t\t\tlst.push_back(add);\n\t\t}\n\t\tlst.pop_front();\n\t}\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\tint hight, width;\n\tint ans_x, ans_y;\n\tint sx, sy, gx, gy;\n\tchar move[11];\n\tVector mv[10];\n\tint move_count;\n\tunsigned int ans;\n\t\n\twhile (1){\n\t\tmemset(data, 0xff, (18 * 18) * sizeof(int));\n\t\tcin >> hight >> width;\n\t\tif (hight == 0 && width == 0)break;\n\t\tfor (int y = 0; y < hight + 2; y++){\n\t\t\tchar str[16 + 1];\n\t\t\tif (y == 0 || y == hight + 1){\n\t\t\t\tfor (int x = 0; x < width + 2; x++){\n\t\t\t\t\tmap[x][y] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> str;\n\t\t\t\tmap[0][y] = map[width + 1][y] = -1;\n\t\t\t\tfor (int x = 0; x < width; x++){\n\t\t\t\t\tif (str[x] == 'A'){\n\t\t\t\t\t\tsx = x + 1;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (str[x] == 'B'){\n\t\t\t\t\t\tgx = x + 1;\n\t\t\t\t\t\tgy = y;\n\t\t\t\t\t}\n\t\t\t\t\tmap[x + 1][y] = str[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> move;\n\t\t\n\t\tmove_count = change(move, mv);\n\t\t\n\t\tmove_short_root(sx, sy);\n\t\t\n\t\tans = move_sml(gx, gy, mv, move_count, &ans_x, &ans_y);\n\t\t\n\t\tif (ans == 0xffffffff){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << ' ' << ans_y - 1 << ' ' << ans_x - 1 << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n\nusing namespace std;\n\ntypedef struct {\n\tint x, y;\n} Vector;\n\nchar map[16 + 2][16 + 2];\nunsigned int data[16][16][16][16][10];\nint ans;\nint ans_x, ans_y;\n\nint change(char move[], Vector mv[])\n{\n\tint i = 0;\n\twhile (move[i] != '\\0'){\n\t\tmv[i].x = mv[i].y = 0;\n\t\tswitch (move[i]){\n\t\t  case '5':\n\t\t  \tbreak;\n\t\t  case '8':\n\t\t  \tmv[i].y = -1;\n\t\t\tbreak;\n\t\t  case '6':\n\t\t  \tmv[i].x = 1;\n\t\t\tbreak;\n\t\t  case '4':\n\t\t  \tmv[i].x = -1;\n\t\t\tbreak;\n\t\t  case '2':\n\t\t  \tmv[i].y = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn (i);\n}\n\nint calc(int sx, int sy, int gx, int gy, Vector mv[], int move_count, int depth)\n{\n\tint mx, my;\n\t\n\t\n\tif (map[sx][sy] == -1 || map[sx][sy] == '#' || ans <= depth){\n\t\treturn (0);\n\t}\n\tif (sx == gx && sy == gy){\n\t\tif (ans > depth){\n\t\t\tans = depth;\n\t\t\tans_x = sx - 1;\n\t\t\tans_y = sy - 1;\n\t\t}\n\t\treturn (0);\n\t}\n\tif (data[sx - 1][sy - 1][gx - 1][gy - 1][depth % move_count] == 1){\n\t\treturn (0);\n\t}\n\tdata[sx - 1][sy - 1][gx - 1][gy - 1][depth % move_count] = 1;\n\t\n\tmx = mv[depth % move_count].x;\n\tmy = mv[depth % move_count].y;\n\t\n\tif (map[gx + mx][gy + my] != -1){\n\t\tgx += mx;\n\t\tgy += my;\n\t}\n\tcalc(sx + 1, sy, gx, gy, mv, move_count, depth + 1);\n\tcalc(sx - 1, sy, gx, gy, mv, move_count, depth + 1);\n\tcalc(sx, sy + 1, gx, gy, mv, move_count, depth + 1);\n\tcalc(sx, sy - 1, gx, gy, mv, move_count, depth + 1);\n\tcalc(sx, sy,     gx, gy, mv, move_count, depth + 1);\n\t\n\tdata[sx - 1][sy - 1][gx - 1][gy - 1][depth % move_count] = 0;\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\tint hight, width;\n\tint sx, sy, gx, gy;\n\tchar move[11];\n\tVector mv[10];\n\tint move_count;\n\t\n\twhile (1){\n\t\tans = 16 * 16 * 16 * 16 * 10;\n\t\tcin >> hight >> width;\n\t\tif (hight == 0 && width == 0)break;\n\t\tfor (int y = 0; y < hight + 2; y++){\n\t\t\tchar str[16 + 1];\n\t\t\tif (y == 0 || y == hight + 1){\n\t\t\t\tfor (int x = 0; x < width + 2; x++){\n\t\t\t\t\tmap[x][y] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> str;\n\t\t\t\tmap[0][y] = map[width + 1][y] = -1;\n\t\t\t\tfor (int x = 0; x < width; x++){\n\t\t\t\t\tif (str[x] == 'A'){\n\t\t\t\t\t\tsx = x + 1;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (str[x] == 'B'){\n\t\t\t\t\t\tgx = x + 1;\n\t\t\t\t\t\tgy = y;\n\t\t\t\t\t}\n\t\t\t\t\tmap[x + 1][y] = str[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> move;\n\t\tmemset(data, 0, 16 * 16 * 16 * 16 * 10);\n\t\t\n\t\tmove_count = change(move, mv);\n\t\t\n\t\tcalc(sx, sy, gx, gy, mv, move_count, 0);\n\t\t\n\t\tif (ans == 16 * 16 * 16 * 16 * 10){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << ' ' << ans_y << ' ' << ans_x << endl;\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n\nusing namespace std;\n\n#define MAX 20\n#define INF 1e9\n\nint H,W,ax,ay,bx,by;\nchar field[MAX][MAX];\nstring str;\nconst int dx[] = {-1,0,0,1,0};\nconst int dy[] = {0,-1,1,0,0};\n\nstruct State{\n  int sx,sy,gx,gy;\n  State(int sx,int sy,int gx,int gy) : sx(sx),sy(sy),gx(gx),gy(gy) {}\n};\n\nbool inField(int y,int x){\n  return 0 <= y && y < H && 0 <= x && x < W;\n}\n\nint getDir(char ch){\n  if(ch == '4') return 0;\n  if(ch == '8') return 1;\n  if(ch == '2') return 2;\n  if(ch == '6') return 3;\n  return 4;\n}\n\nvoid bfs(){\n  int size = str.size();\n  bool visited[MAX][MAX][MAX][MAX][MAX];\n  memset(visited,0,sizeof(visited));\n  visited[ay][ax][by][bx][0] = true;\n  queue<State> Q;\n  queue<int> Count;\n  Q.push(State(ax,ay,bx,by));\n  Count.push(0);\n  while(!Q.empty()){\n    State s = Q.front(); Q.pop();\n    int cnt = Count.front(); Count.pop();\n\n    if(s.sx == s.gx && s.sy == s.gy){\n      cout << cnt << \" \" << s.sy << \" \" << s.sx << endl;\n      return;\n    }\n\n    int dir = getDir(str[cnt%size]);\n    int Gx = s.gx + dx[dir], Gy = s.gy + dy[dir];\n    if(!inField(Gy,Gx)) Gx = s.gx, Gy = s.gy;\n\n    for(int i = 0 ; i < 5 ; i++){\n      int nx = s.sx + dx[i], ny = s.sy + dy[i];\n      if(!inField(ny,nx)) continue;\n      if(field[ny][nx] == '#') continue;\n      if(visited[ny][nx][Gy][Gx][(cnt+1)%size]) continue;\n      visited[ny][nx][Gy][Gx][(cnt+1)%size] = true;\n      Q.push(State(nx,ny,Gx,Gy));\n      Count.push(cnt+1);\n    }\n  }\n  cout << \"impossible\" << endl;\n}\n\nint main(){\n  while(cin >> H >> W, (H|W)){\n    for(int i = 0 ; i < H ; i++){\n      for(int j = 0 ; j < W ; j++){\n        cin >> field[i][j];\n        if(field[i][j] == 'A'){\n          ax = j, ay = i;\n        }else if(field[i][j] == 'B'){\n          bx = j, by = i;\n        }\n      }\n    }\n    cin >> str;\n    bfs();\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <set>\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,j) FOR(i,0,j)\n#define mp std::make_pair\n\nconst int INF = 1 << 24;\n// S N E W\nconst int dx[8] = {0, 0, 1, -1, 1, 1, -1, -1}, dy[8] = {1, -1, 0, 0, 1, -1, 1, -1};\n\ntypedef unsigned long long ull;\ntypedef std::pair<int,int> P;\ntypedef std::pair<int,P> State;\n\nint H, W;\nchar map[20][20];\nP a, b;\nint d[20][20];\nstd::string pattern;\n\nvoid bfs(){\n    REP(i, 20){\n        REP(j, 20){\n            d[i][j] = INF;\n        }\n    }\n\n    std::queue<State> q;\n    q.push(mp(0, a));\n    d[a.second][a.first] = 0;\n\n    while(!q.empty()){\n        State s = q.front(); q.pop();\n        int cost = s.first;\n        P p = s.second;\n\n        if(d[p.second][p.first] < cost){continue;}\n        \n        REP(i, 4){\n            int nx = p.first + dx[i],\n                ny = p.second + dy[i];\n            if(0 <= nx && nx < W &&\n               0 <= ny && ny < H &&\n               d[ny][nx] > cost + 1 && map[ny][nx] == '.'){\n                q.push(mp(cost+1, mp(nx, ny)));\n                d[ny][nx] = cost + 1;\n            }\n        }\n    }\n}\n\nState buster(){\n    std::string table = \"2864\";\n    int index = 0, t = 1;\n    while(t <= 400){\n        REP(i, 4){\n            if(pattern[index] == table[i]){\n                int nx = b.first + dx[i], ny = b.second + dy[i];\n                if(0 <= nx && nx < W &&\n                   0 <= ny && ny < H){\n                    b = mp(nx, ny);\n                }\n                break;\n            }\n        }\n\n        if(t >= d[b.second][b.first]){\n            return mp(t, b);\n        }\n\n        index = (index + 1) % pattern.size();\n        t++;\n    }\n\n    return mp(t, mp(-1, -1));\n}\n\nint main(){\n    while(std::cin >> H >> W, H){\n        REP(i, H){\n            REP(j, W){\n                std::cin >> map[i][j];\n                if(map[i][j] == 'A'){\n                    a = mp(j, i);\n                    map[i][j] = '.';\n                }else if(map[i][j] == 'B'){\n                    b = mp(j, i);\n                    map[i][j] = '.';\n                }\n            }\n        }\n\n        std::cin >> pattern;\n\n        bfs();\n\n        // REP(i, H){\n        //     REP(j, W){\n        //         printf(\"%d, \", d[i][j]);\n        //     }\n        //     puts(\"\");\n        // }\n\n        State res = buster();\n        if(res.first > 400){\n            puts(\"impossible\");\n        }else{\n            printf(\"%d %d %d\\n\", res.first, res.second.second, res.second.first);\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<utility>\n\nusing namespace std;\n\nchar g[20][20];\nint h,w;\nint t[20][20];\n\nstruct S{\n  int t,x,y;\n};\n\nint main(){\n  while(cin>>h>>w,h|w){\n    int ax,ay,bx,by;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n\tif(g[y][x]=='A'){\n\t  ax=x;\n\t  ay=y;\n\t}else if(g[y][x]=='B'){\n\t  bx=x;\n\t  by=y;\n\t}\n      }\n    }\n    fill(t[0],t[20],1<<30);\n    queue<S> que;\n    S is={0,ax,ay};\n    que.push(is);\n    while(!que.empty()){\n      int x=que.front().x;\n      int y=que.front().y;\n      int ct=que.front().t;\n      que.pop();\n      t[y][x]=ct;\n      for(int i=0;i<4;i++){\n\tint d[]={0,1,0,-1,0};\n\tint nx=x+d[i];\n\tint ny=y+d[i+1];\n\tif(nx<0||w<=nx||ny<0||h<=ny||t[ny][nx]<=ct+1||g[ny][nx]=='#')continue;\n\tS ns={ct+1,nx,ny};\n\tque.push(ns);\n      }\n    }\n    string p;\n    cin>>p;\n    int e;\n    for(e=0;e<10000;e++){\n      if(t[by][bx]<=e)break;\n      char o=p[e%p.size()];\n      int ny=by+(o=='2')-(o=='8');\n      int nx=bx+(o=='6')-(o=='4');\n      if(0<=ny&&ny<h&&0<=nx&&nx<w){\n\tby=ny;\n\tbx=nx;\n      }\n    }\n    if(e<10000){\n      cout<<e<<' '<<by<<' '<<bx<<endl;\n    }else{\n      cout<<\"impossible\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <queue>\nusing namespace std;\nstruct po{int x,y,dis;};\nint h,w;\nstring mp[20],str;\nint D[21][21];\n\nvoid bfs(po s){\n  for(int i=0;i<h;i++)\n    for(int j=0;j<w;j++) D[i][j] = 10000000;\n  D[s.y][s.x] = 0;\n  queue<po> Q;\n  Q.push((po){s.x,s.y,0});\n  while(!Q.empty()){\n    po t=Q.front();Q.pop();\n    int dx[]={0,0,-1,1};\n    int dy[]={1,-1,0,0};\n    for(int i=0;i<4;i++){\n      int nx = t.x+dx[i];\n      int ny = t.y+dy[i];\n      if(nx<0||ny<0||nx>=w||ny>=h||mp[ny][nx]!='.'||D[ny][nx]<=t.dis+1)continue;\n      Q.push((po){nx,ny,t.dis+1});\n      D[ny][nx]=t.dis+1;\n    }\n  }\n}\n\nvoid move(po s){\n  po ima,ans;\n  ima.x=s.x,ima.y=s.y;\n  if(D[ima.y][ima.x]==0)ans.x=ima.x,ans.y=ima.y,ans.dis=0;\n  else ans.dis = 10000000;\n  int visited[21][21]={};\n  int dx[]={0,-1,1,0};\n  int dy[]={1,0,0,-1};\n  int cnt=0;\n  while(1){\n    visited[ima.y][ima.x]=1;\n    for(int i=0;i<str.size();i++){\n      cnt++;\n      int j = (str[i]-'0')/2-1;\n      int nx=ima.x+dx[j];\n      int ny=ima.y+dy[j];\n      if(nx<0||ny<0||nx>=w||ny>=h||str[i]=='5')nx=ima.x,ny=ima.y;\n      ima.x=nx,ima.y=ny;\n      if(ans.dis>cnt && cnt>=D[ny][nx]) ans.x=ima.x,ans.y=ima.y,ans.dis=cnt;\n    }\n    if(cnt>5000)break;\n  }\n  if(ans.dis==10000000 || ans.dis>1000) cout <<\"impossible\"<<endl;\n  else cout<< ans.dis<<\" \" << ans.y <<\" \"<< ans.x<<endl;\n}\n \n\nint main() {\n\n  while(1){\n    cin >> h >> w;\n    if(h==0 && w==0)break;\n    for(int i=0;i<h;i++) cin >> mp[i];\n    cin>> str;\n    \n    po A,B;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(mp[i][j] == 'A') A.y=i ,A.x=j;\n\tif(mp[i][j]=='B') B.y=i,B.x=j;\n      }\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)\n\tif(mp[i][j] == 'A'||mp[i][j]=='B') mp[i][j] = '.';\n  \n    bfs(A);\n    move(B);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<map>\nusing namespace std;\n#define inRange(x,a,b) (a <= x && x < b)\nint di[5] = {0,0,1,-1,0};\nint dj[5] = {1,-1,0,0,0};\n\nint main(){\n    map<char,int> act;\n    act['5'] = 4;\n    act['8'] = 3;\n    act['6'] = 0;\n    act['4'] = 1;\n    act['2'] = 2;\n    int h, w;\n    while(cin >> h >> w, h+w){\n        int si, sj, gi, gj;\n        char mat[h][w];\n        for(int i = 0; i < h; i++){\n            for(int j = 0; j < w; j++){\n                cin >> mat[i][j];\n                if(mat[i][j] == 'A')    si = i, sj = j;\n                if(mat[i][j] == 'B')    gi = i, gj = j;\n            }\n        }\n        vector<vector<int>> step(h, vector<int>(w, 1<<30));\n        queue<pair<int, pair<int,int>>> q;\n        q.push({0, {si, sj}});\n        int maxstep;\n        while(!q.empty()){\n            auto p = q.front(); q.pop();\n            int cost = p.first, i = p.second.first, j = p.second.second;\n            if(step[i][j] <= cost)  continue;\n            step[i][j] = cost;\n            maxstep = cost;\n            for(int k = 0; k < 4; k++){\n                int ni = i+di[k], nj = j+dj[k];\n                if(inRange(ni, 0, h) && inRange(nj, 0, w) && mat[ni][nj] != '#' && cost+1 < step[ni][nj]){\n                    q.push({cost+1, {ni, nj}});\n                }\n            }\n        }\n        string s;\n        cin >> s;\n        int slen = s.length();\n        int last = 0, turn = 0;\n        vector<vector<bool>> ghost(h, vector<bool>(w, 0));\n        bool meet = false;\n        while(turn < maxstep+5 || turn-last < slen){\n            int ngi = gi+di[act[s[turn%slen]]], ngj = gj+dj[act[s[turn%slen]]];\n            if(!inRange(ngi, 0, h) || !inRange(ngj, 0, w))  ngi = gi, ngj = gj;\n            gi = ngi, gj = ngj;\n            if(!ghost[gi][gj]){\n                last = turn+1;\n                ghost[gi][gj] = true;\n            }\n            turn++;\n            if(step[gi][gj] <= turn){\n                cout << turn << \" \" << gi << \" \" << gj << endl;\n                meet = true;\n                break;\n            }\n        }\n\n        if(!meet){\n            cout << \"impossible\" << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint h,w;\nchar field[21][21];\n\nconst int INF=100000000;\n\n// INFÈç­ªBÅ«È¢\nint minArrivalCost[21][21];\n// HìÌÚ®[gði[\nvector<pair<int,int> > ghostPath;\n// HìªÊßµ½êði[\nbool passedGhost[11][21][21];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\n// ­ªe}XÖ½Çè­½ßÌÅ¬RXgðßé\nvoid bfs(int sx,int sy){\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> > ();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> > ();\n\tprv->push(make_pair(sy,sx));\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tpassed[i][j]=false;\n\t\t}\n\t}\n\tint cnt=0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp=prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\tminArrivalCost[cp.first][cp.second]=min(minArrivalCost[cp.first][cp.second],cnt);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tnp.first+=dy[i];\n\t\t\t\tnp.second+=dx[i];\n\t\t\t\tif(np.first>=0&&np.second>=0&&np.first<h&&np.second<w){\n\t\t\t\t\tif(!passed[np.first][np.second]&&field[np.first][np.second]!='#'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\n\tdelete prv,nxt;\n}\n\nint searchGhost(pair<int,int> cp,int tern,string pattern,pair<int,int> sp){\n\t// 500ñ®¢Äàoï¦È¢ÈçÎA-1ðÔ·B»¤ÅÈ¯êÎAoï¦éÅ¬^[ðÔ·\n\tint cnt=-1;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < pattern.size(); i++){\n\t\t\tcnt++;\n\t\t\tif(cnt==150)\n\t\t\t\treturn -1;\n\t\t\t// ­ÌÊuÉBµ½ê\n\t\t\tif(sp==cp){\n\t\t\t\tif(tern<=cnt){\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchar c = pattern[i];\n\t\t\tpair<int,int> np=cp;\n\t\t\t\n\t\t\tif(c=='8')\n\t\t\t\tnp.first-=1;\n\t\t\telse if(c=='6')\n\t\t\t\tnp.second+=1;\n\t\t\telse if(c=='4')\n\t\t\t\tnp.second-=1;\n\t\t\telse if(c=='2')\n\t\t\t\tnp.first++;\n\t\t\t\n\t\t\tif(np.first<0)\n\t\t\t\tnp.first=0;\n\t\t\telse if(np.first>=h)\n\t\t\t\tnp.first=h-1;\n\t\t\telse if(np.second>=w)\n\t\t\t\tnp.second=w-1;\n\t\t\telse if(np.second<0)\n\t\t\t\tnp.second=0;\n\t\t\tcp=np;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>h>>w&&!(h==0&&w==0)){\n\t\tghostPath.clear();\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 11; k++){\n\t\t\t\t\tpassedGhost[k][i][j]=false;\n\t\t\t\t}\n\t\t\t\tminArrivalCost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='A'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='B'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tbfs(sx,sy);\n\n\t\tpair<int,int> cp=make_pair(gy,gx);\n\t\tint minCost=INF;\n\t\tpair<int,int> rp;\n\t\t// eHìÌB|CgÉÂ¢ÄAÞªBÅ«Ä¢é©Ç¤©ðÝé\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcp=make_pair(i,j);\n\t\t\t\tint cst=minArrivalCost[cp.first][cp.second];\n\t\t\t\tif(cst!=INF){\n\t\t\t\t\tint r=searchGhost(make_pair(gy,gx),cst,pattern,cp);\n\t\t\t\t\tif(r!=-1){\n\t\t\t\t\t\tif(minCost>r){\n\t\t\t\t\t\t\tminCost=min(minCost,r);\n\t\t\t\t\t\t\trp=cp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(minCost==INF)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse{\n\t\t\tcout<<minCost<<\" \"<<rp.first<<\" \"<<rp.second<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int ,int > P;\ntypedef pair<int, P> P2;\n\nint v[30][30];\nbool vb[30][30][20];\nstring g[30],L;\nint h,w,s;\nint ay,ax,by,bx;\nint dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\nint main(){\n  while(cin >> h >> w , h||w){\n    for(int i=0;i<h;i++)cin >> g[i];\n    cin >> L;\n    s = L.size();\n\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == 'A'){\n\t  ay = i; ax = j;\n\t}\n\tif(g[i][j] == 'B'){\n\t  by = i; bx = j;\n\t}\n\tv[i][j] = -1;\n\tfor(int k=0;k<s;k++)vb[i][j][k] = false;\n      }\n\n    queue<P2> q;\n    v[ay][ax] = 0;\n    q.push(P2(0,P(ay,ax)));\n\n    while(!q.empty()){\n      P2 p = q.front();q.pop();\n \n      for(int i=0;i<4;i++){\n\tint sy = p.second.first + dy[i] , sx = p.second.second + dx[i];\n\tif(sy<0 || sx<0 || h<=sy || w<=sx)continue;\n\tif(v[sy][sx]>=0 || g[sy][sx]=='#')continue;\n\tv[sy][sx] = p.first+1;\n\tq.push(P2(p.first+1,P(sy,sx)));\n      }\n    }\n\n    int t = 0;\n    for(int i=0;i<h;i++)\n      for(int j=0;j<w;j++)t = max(t,v[i][j]);\n\n    for(int i=0;;i++){\n      if(i<=t){\n\tif(v[by][bx]>=0 && v[by][bx]<=i){\n\t  cout << i << \" \" << by << \" \" << bx << endl;\n\t  break;\n\t}\n      }else{\n\tif(v[by][bx]>=0){\n\t  cout << i << \" \" << by << \" \" << bx << endl;\n\t  break;\n\t}\n\tif(vb[by][bx][i%s]){\n\t  cout << \"impossible\\n\";\n\t  break;\n\t}\n      }\n      vb[by][bx][i%s] = true;\n      if(L[i%s] == '8' && 0<by)by--;\n      if(L[i%s] == '6' && bx<w-1)bx++;\n      if(L[i%s] == '2' && by<h-1)by++;\n      if(L[i%s] == '4' && 0<bx)bx--;\n    }\n\t\t\t\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nint main(){\nstd::queue<int>q;\nint w,h,f[484],i,j,d[]={22,0,-1,0,1,0,-22},a,b,t,x,z;\nchar p[15];\nfor(;scanf(\"%d%d \",&h,&w),h;){\nfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\nfor(i=1;i<=h;i++){\nfor(j=1;j<=w;j++)\nf[x=i*22+j]=-1,\nz=getchar(),\nz-'#'?z>65?b=x:z>64?a=x:1:--f[x];\nf[i*22]=f[i*22-~w]=-9;\ngetchar();\n}\n\nf[a]=t=0;\nq.push(0);\nfor(q.push(a);a=q.front(),q.size()>1;q.pop())\nif(a){\nfor(i=0;i<7;i+=2)\nif(f[x=a+d[i]]==-1)\nf[x]=t,q.push(x);}\nelse\n++t,q.push(0);\n\nq.pop();\nscanf(\"%s\",p);\nfor(a=t=0;!a;){\nx=b;\nz=0;\nfor(i=0;!a&&p[i];i++){\nt++;\nf[j=b+d[p[i]-'2']]>-3?b=j:0;\nf[b]>=0&&t>=f[b]?a=b:0;\nf[b]>=0&&++z;\n}\n!z&!a&!p[i]&b==x&f[b]<0&&--a;\n}\nprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\nint main() {\n  int h,w;\n  while(cin >> h>>w,h||w) {\n    char ba[h][w];\n    int ax,ay, bx,by;\n    REP(i,h) {\n      REP(j,w) {\n        cin >> ba[i][j];\n        if (ba[i][j]=='A') {\n          ax = j;\n          ay = i;\n        }else if (ba[i][j]=='B') {\n          bx = j;\n          by = i;\n        }\n      }\n    }\n    \n    const int dx[] = {0,-1,1,0};\n    const int dy[] = {1,0,0,-1};\n\n    int dis[h][w];\n    REP(i,h) REP(j,w) dis[i][j] = INF;\n    typedef pair<int,int> pii;\n    queue<pair<int,pii> > Q;\n    Q.push(make_pair(0, pii(ax,ay)));\n    int maxd = 0;\n    while(!Q.empty()) {\n      int x = Q.front().second.first;\n      int y = Q.front().second.second;\n      int d = Q.front().first;\n      Q.pop();\n\n      if (dis[y][x] != INF) continue;\n      dis[y][x] = d;\n      maxd = max(maxd,d);\n      REP(k,4) {\n        int xx = x+dx[k];\n        int yy = y+dy[k];\n\n        if (xx<0||xx>=w||yy<0||yy>=h) continue;\n        if (ba[yy][xx]=='#') continue;\n        if (dis[yy][xx] != INF) continue;\n        \n        Q.push(make_pair(d+1, pii(xx,yy)));\n      }\n    }\n    // REP(y,h) {\n    //   REP(x,w) {\n    //     if (dis[y][x] == INF) cout << -1 << \" \";\n    //     else\n    //       printf(\"%2d \", dis[y][x]);\n    //   }\n    //   cout << endl;\n    // }\n    string s;\n    cin >> s;\n    int m = s.size();\n    int memo[h][w][m];\n    memset(memo,0,sizeof(memo));\n\n    int cnt = 0;\n    int res = INF;\n    int ansx,ansy;\n    while(1) {\n//      printf(\"(%d,%d) \",bx,by);\n      if (dis[by][bx] <= cnt) {\n        if(cnt<res) {\n          res = cnt;\n          ansx = bx;\n          ansy = by;\n        }\n      }\n      if (cnt >= maxd) {\n        if (memo[by][bx][cnt%m]) {\n          break;\n        }\n        memo[by][bx][cnt%m] = 1;\n      }\n\n\n      if (s[cnt%m]-'0' != 5) {\n        int dir = (s[cnt%m]-'0')/2-1;\n        bx += dx[dir];\n        by += dy[dir];\n        if (bx<0||bx>=w||by<0||by>=h) {\n          bx -= dx[dir];\n          by -= dy[dir];\n        }\n      }\n      \n      cnt++;\n    }\n\n    if (res == INF) {\n      cout << \"Impossible\" << endl;\n    } else\n      printf(\"%d %d %d\\n\", res, ansy, ansx);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        memset(visited, 0, sizeof(visited));\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pair<pair<int,int>,int> p = q.front();\n            visited[p.first.second][p.first.first]=1;\n            co[p.first.second][p.first.first]=p.second;\n           // cout<<p.first.second<<\"  \"<<p.first.first<<\"  \"<<p.second<<endl;\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX&&ma[ny][nx]!='A'&&!visited[ny][nx]){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n        }\n        string pat;\n        cin>>pat;\n        int go=0;\n        for(int j=0;;j++){\n            int i=j%pat.length();\n         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>INT_MAX/90){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='5'){\n                \n            } else if(pat[i]=='8'){\n                gy--;\n            } else if(pat[i]=='6'){\n                gx++;\n            } else if(pat[i]=='4'){\n                gx--;\n            } else if(pat[i]=='2'){\n                gy++;\n            }\n            gy=max(0,gy);\n            gy=min(h-1,gy);\n            gx=max(0,gx);\n            gx=min(w-1,gx);\n            go++;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <map>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\nint H, W;\nchar grid[25][25];\nstring pat;\nint grid2[25][25];\nint ay, ax;\nint by, bx;\n\nvoid bfs()\n{\n    const int INF = 100000000;\n    int dy[4] = {0, -1, 0, 1};\n    int dx[4] = {-1, 0, 1, 0};\n\n    typedef pair<int, int> P;\n\n    queue<P> que;\n    rep(i,H) rep(j,W) {\n        grid2[i][j] = INF;\n    }\n\n    que.push(P(ay, ax));\n    grid2[ay][ax] = 0;\n\n    while (que.size()) {\n        P p = que.front(); que.pop();\n        rep(i,4) {\n            int ny = p.first + dy[i];\n            int nx = p.second + dx[i];\n\n            if (0 <= ny && ny < H && 0 <= nx && nx < W && grid[ny][nx] == '.' && grid2[ny][nx] == INF) {\n                que.push(P(ny, nx));\n                grid2[ny][nx] = grid2[p.first][p.second] + 1;\n            }\n        }\n    }\n}\n\nint main()\n{\n#ifdef LOCAL\n    ifstream in(\"input.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n\n    while (true) {\n        cin >> H >> W;\n        if (H == 0 && W == 0) break;\n\n        rep(i,H) rep(j,W) {\n            cin >> grid[i][j];\n            if (grid[i][j] == 'A') {\n                ay = i;\n                ax = j;\n                grid[i][j] = '.';\n            } else if (grid[i][j] == 'B') {\n                by = i;\n                bx = j;\n                grid[i][j] = '.';\n            }\n        }\n        cin >> pat;\n\n        /*\n        int sy = 0, sx = 0;\n        rep(i,pat.length()) {\n            if (pat[i] == '5') {\n                sy += 0;\n                sx += 0;\n            } else if(pat[i] == '4') {\n                sy += 0;\n                sx -= 1;\n            } else if (pat[i] == '8') {\n                sy -= 1;\n                sx += 0;\n            } else if (pat[i] == '6') {\n                sy += 0;\n                sx += 1;\n            } else if (pat[i] == '2') {\n                sy += 1;\n                sx += 0;\n            }\n        }\n        bool try_only_one = false;\n        if (sy == 0 && sx == 0) try_only_one = true;\n        */\n\n        bfs();\n\n        /*\n        rep(i,H) {\n            rep(j,W) {\n                printf(\"% 3d \", grid2[i][j]);\n            }\n            cout << endl;\n        }\n        */\n\n        bool possible = false;\n        int ans;\n        int ansy, ansx;\n        int cnt = 0;\n        rep(i,25) {\n            rep(j,pat.length()) {\n                cnt++;\n                if (pat[j] == '5') {\n                    by += 0;\n                    bx += 0;\n                } else if(pat[j] == '4') {\n                    by += 0;\n                    if (bx >= 1) bx -= 1;\n                } else if (pat[j] == '8') {\n                    if (by >= 1) by -= 1;\n                    bx += 0;\n                } else if (pat[j] == '6') {\n                    by += 0;\n                    if (bx < W - 1) bx += 1;\n                } else if (pat[j] == '2') {\n                    if (by < H - 1) by += 1;\n                    bx += 0;\n                }\n                if (grid2[by][bx] <= cnt && !possible) {\n                    possible = true;\n                    ans = cnt;\n                    ansy = by;\n                    ansx = bx;\n                }\n            }\n        }\n\n        if (possible) {\n            cout << ans << \" \" << ansy << \" \" << ansx << endl;\n        } else {\n            cout << \"impossible\" << endl;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<queue>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<list>\n#include<set>\nusing namespace std;\n#define fr first\n#define sc second\n#define INFTY 1000000\ntypedef pair< int,int > Pt;\ntypedef pair< pair<Pt,Pt>,int > P;\nPt A,B;\nint h,w,dx[]={0,1,0,-1,0},dy[]={1,0,-1,0,0};\nchar mas[20][20];\nint used[20][20][20][20][11];\nstring pattern;\npair<int,Pt> bfs();\nbool judge(int,int);\nint main(){\n  while(cin >> h >> w && h){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> mas[i][j];\n        if(mas[i][j] == 'A') A = Pt(i,j);\n        else if(mas[i][j] == 'B') B = Pt(i,j);\n      }\n    }\n    cin >> pattern;\n    pair<int,Pt> ans = bfs();\n    if(ans.fr == -1) cout << \"impossible\" << endl;\n    else cout << ans.fr << \" \" << ans.sc.fr << \" \" << ans.sc.sc << endl;\n  }\n}\npair<int,Pt> bfs(){\n  map<char,int> tmp;\n  tmp['5'] = 4,tmp['8'] = 3,tmp['6'] = 0,tmp['4'] = 2,tmp['2'] = 1;\n  queue<P> que;\n  memset(used,-1,sizeof(used));\n  que.push(P(make_pair(A,B),-1));\n  while(!que.empty()){\n    P p = que.front();\n    que.pop();\n    if(p.fr.fr == p.fr.sc){\n      return (make_pair(used[p.fr.fr.fr][p.fr.fr.sc][p.fr.sc.fr][p.fr.sc.sc][p.sc]+1,Pt(p.fr.fr.fr,p.fr.fr.sc)));\n    }\n    int cnt = (p.sc + 1) % pattern.size();\n    int bx = p.fr.sc.fr + dx[tmp[pattern[cnt]]];\n    int by = p.fr.sc.sc + dy[tmp[pattern[cnt]]];\n    if(!judge(bx,by)) bx = p.fr.sc.fr , by = p.fr.sc.sc;\n    for(int i=0;i<5;i++){\n      int ax = p.fr.fr.fr + dx[i] , ay = p.fr.fr.sc + dy[i];\n      if(!judge(ax,ay) || mas[ax][ay] == '#') ax = p.fr.fr.fr , ay = p.fr.fr.sc;\n      if(used[ax][ay][bx][by][cnt] == -1){\n        que.push(P(make_pair(Pt(ax,ay),Pt(bx,by)),cnt));\n        used[ax][ay][bx][by][cnt] = used[p.fr.fr.fr][p.fr.fr.sc][p.fr.sc.fr][p.fr.sc.sc][p.sc] + 1;\n      }\n    }\n  }\n  return make_pair(-1,Pt(0,0));\n}\nbool judge(int x,int y){\n  return (x >= 0 && x < h && y >= 0 && y < w ? true : false);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstdio>\n#include <queue>\n\nusing namespace std;\n\nclass State{\npublic:\n  int ay, ax, by, bx, t;\n  State(int ay = 0, int ax = 0, int by = 0, int bx = 0, int t = 0)\n    : ay(ay), ax(ax), by(by), bx(bx), t(t) {}\n};\n\nint h, w;\nchar data[20][20];\nint pat[10];\nint pat_size;\nint say, sax, sby, sbx;\nint dy[] = {-1, 0, 1, 0, 0};\nint dx[] = {0, 1, 0, -1, 0};\n\nbool check(int y, int x){\n  if(y<0 || y>=h) return false;\n  if(x<0 || x>=w) return false;\n  return true;\n}\n\nvoid solve(){\n  int ans = -1, ansy, ansx;\n  bool vis[20][20][20][20][10];\n  State u = State(say, sax, sby, sbx, 0), v;\n  fill(vis[0][0][0][0], vis[20][0][0][0], false);\n  queue<State> q;\n  q.push(u);\n  while(!q.empty()){\n    u = q.front(); q.pop();\n    if(u.ay == u.by && u.ax == u.bx){\n      ans = u.t;\n      ansy = u.ay;\n      ansx = u.ax;\n      break;\n    }\n    int nby = u.by + dy[pat[u.t%pat_size]];\n    int nbx = u.bx + dx [pat[u.t%pat_size]];\n    if(!check(nby, nbx)){\n      nby = u.by;\n      nbx = u.bx;\n    }\n    for(int i=0;i<4;i++){\n      int nay = u.ay + dy[i];\n      int nax = u.ax + dx[i];\n      if(!check(nay, nax)){\n        nay = u.ay;\n        nax = u.ax;\n      }\n      if(data[nay][nax] == '#'){\n        nay = u.ay;\n        nax = u.ax;\n      }\n      if(!vis[nay][nax][nby][nbx][u.t%pat_size]){\n        vis[nay][nax][nby][nbx][u.t%pat_size] = true;\n        q.push(State(nay, nax, nby, nbx, u.t+1));\n      }\n    }\n  }\n  if(ans == -1){\n    cout << \"impossible\" << endl;\n  }else{\n    cout << ans << ' ' << ansy << ' ' << ansx << endl;\n  }\n}\n\nmain(){\n  while(cin >> h >> w && (h|w)){\n    for(int i=0;i<h;i++){\n      for(int j=0;j<w;j++){\n        cin >> data[i][j];\n        if(data[i][j] == 'A'){\n          say = i;\n          sax =j;\n          data[i][j] = '.';\n        }\n        if(data[i][j] == 'B'){\n          sby = i;\n          sbx = j;\n          data[i][j] = '.';\n        }\n      }\n    }\n    getchar();\n    string in;\n    getline(cin, in);\n    pat_size = in.size();\n    for(int i=0;i<pat_size;i++){\n      if(in[i] == '8') pat[i] = 0;\n      if(in[i] == '6') pat[i] = 1;\n      if(in[i] == '2') pat[i] = 2;\n      if(in[i] == '4') pat[i] = 3;\n      if(in[i] == '5') pat[i] = 4;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\nint h,w;\nchar field[21][21];\n\nconst int INF=100000000;\n\n// INFÈç­ªBÅ«È¢\nint minArrivalCost[21][21];\n// HìÌÚ®[gði[\nvector<pair<int,int> > ghostPath;\n// HìªÊßµ½êði[\nbool passedGhost[11][21][21];\n\nconst int dy[]={-1,0,0,1};\nconst int dx[]={0,-1,1,0};\n\n// ­ªe}XÖ½Çè­½ßÌÅ¬RXgðßé\nvoid bfs(int sx,int sy){\n\tqueue<pair<int,int> > *prv=new queue<pair<int,int> > ();\n\tqueue<pair<int,int> > *nxt=new queue<pair<int,int> > ();\n\tprv->push(make_pair(sy,sx));\n\n\tbool passed[21][21];\n\tfor(int i = 0; i < 21; i++){\n\t\tfor(int j = 0; j < 21; j++){\n\t\t\tpassed[i][j]=false;\n\t\t}\n\t}\n\tint cnt=0;\n\twhile(prv->size()){\n\t\twhile(prv->size()){\n\t\t\tpair<int,int> cp=prv->front();prv->pop();\n\t\t\tif(passed[cp.first][cp.second])\n\t\t\t\tcontinue;\n\t\t\tpassed[cp.first][cp.second]=true;\n\t\t\tminArrivalCost[cp.first][cp.second]=min(minArrivalCost[cp.first][cp.second],cnt);\n\t\t\tfor(int i = 0; i < 4; i++){\n\t\t\t\tpair<int,int> np=cp;\n\t\t\t\tnp.first+=dy[i];\n\t\t\t\tnp.second+=dx[i];\n\t\t\t\tif(np.first>=0&&np.second>=0&&np.first<h&&np.second<w){\n\t\t\t\t\tif(!passed[np.first][np.second]&&field[np.first][np.second]!='#'){\n\t\t\t\t\t\tnxt->push(np);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcnt++;\n\t\tswap(prv,nxt);\n\t}\n\n\tdelete prv,nxt;\n}\n\nint searchGhost(pair<int,int> cp,int tern,string pattern,pair<int,int> sp){\n\t// 500ñ®¢Äàoï¦È¢ÈçÎA-1ðÔ·B»¤ÅÈ¯êÎAoï¦éÅ¬^[ðÔ·\n\tint cnt=-1;\n\twhile(1){\n\t\tbool f=false;\n\t\tfor(int i = 0; i < pattern.size(); i++){\n\t\t\tcnt++;\n\t\t\tif(cnt==500)\n\t\t\t\treturn -1;\n\t\t\t// ­ÌÊuÉBµ½ê\n\t\t\tif(sp==cp){\n\t\t\t\tif(tern<=cnt){\n\t\t\t\t\treturn cnt;\n\t\t\t\t}\n\t\t\t}\n//\t\t\tif(passedGhost[i][cp.first][cp.second]){\n//\t\t\t\tf=true;\n//\t\t\t\tbreak;\n//\t\t\t}\n//\t\t\tpassedGhost[i][cp.first][cp.second]=true;\n//\t\t\tghostPath.push_back(cp);\n\t\t\tchar c = pattern[i];\n\t\t\tpair<int,int> np=cp;\n\t\t\t\n\t\t\tif(c=='8')\n\t\t\t\tnp.first-=1;\n\t\t\telse if(c=='6')\n\t\t\t\tnp.second+=1;\n\t\t\telse if(c=='4')\n\t\t\t\tnp.second-=1;\n\t\t\telse if(c=='2')\n\t\t\t\tnp.first++;\n\t\t\t\n\t\t\tif(np.first<0)\n\t\t\t\tnp.first=0;\n\t\t\telse if(np.first>=h)\n\t\t\t\tnp.first=h-1;\n\t\t\telse if(np.second>=w)\n\t\t\t\tnp.second=w-1;\n\t\t\telse if(np.second<0)\n\t\t\t\tnp.second=0;\n\t\t\tcp=np;\n\t\t}\n\t}\n}\n\nint main(){\n\n\twhile(cin>>h>>w&&!(h==0&&w==0)){\n\t\tghostPath.clear();\n\t\tfor(int i = 0; i < 21; i++){\n\t\t\tfor(int j = 0; j < 21; j++){\n\t\t\t\tfor(int k = 0; k < 11; k++){\n\t\t\t\t\tpassedGhost[k][i][j]=false;\n\t\t\t\t}\n\t\t\t\tminArrivalCost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint sx,sy;\n\t\tint gx,gy;\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\tcin>>field[i][j];\n\t\t\t\tif(field[i][j]=='A'){\n\t\t\t\t\tsx=j;\n\t\t\t\t\tsy=i;\n\t\t\t\t}\n\t\t\t\telse if(field[i][j]=='B'){\n\t\t\t\t\tgx=j;\n\t\t\t\t\tgy=i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tbfs(sx,sy);\n\n\t\tpair<int,int> cp=make_pair(gy,gx);\n\t\t//while(1){\n\t\t//\tbool f=false;\n\t\t//\tfor(int i = 0; i < pattern.size(); i++){\n\t\t//\t\tif(passedGhost[i][cp.first][cp.second]){\n\t\t//\t\t\tf=true;\n\t\t//\t\t\tbreak;\n\t\t//\t\t}\n\t\t//\t\tpassedGhost[i][cp.first][cp.second]=true;\n\t\t//\t\tghostPath.push_back(cp);\n\t\t//\t\tchar c = pattern[i];\n\t\t//\t\tpair<int,int> np=cp;\n\t\t//\t\t\n\t\t//\t\tif(c=='8')\n\t\t//\t\t\tnp.first-=1;\n\t\t//\t\telse if(c=='6')\n\t\t//\t\t\tnp.second+=1;\n\t\t//\t\telse if(c=='4')\n\t\t//\t\t\tnp.second-=1;\n\t\t//\t\telse if(c=='2')\n\t\t//\t\t\tnp.first++;\n\n\t\t//\t\tif(np.first<0)\n\t\t//\t\t\tnp.first=0;\n\t\t//\t\telse if(np.first>=h)\n\t\t//\t\t\tnp.first=h-1;\n\t\t//\t\telse if(np.second>=w)\n\t\t//\t\t\tnp.second=w-1;\n\t\t//\t\telse if(np.second<0)\n\t\t//\t\t\tnp.second=0;\n\t\t//\t\tcp=np;\n\t\t//\t}\n\t\t//\tif(f)\n\t\t//\t\tbreak;\n\t\t//}\n\t\tint minCost=INF;\n\t\tpair<int,int> rp;\n\t\t// eHìÌB|CgÉÂ¢ÄAÞªBÅ«Ä¢é©Ç¤©ðÝé\n\t\tfor(int i = 0; i < h; i++){\n\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t//cp=ghostPath[i];\n\t\t\t\tcp=make_pair(i,j);\n\t\t\t\tint cst=minArrivalCost[cp.first][cp.second];\n\t\t\t\tif(cst!=INF){\n\t\t\t\t\tint r=searchGhost(make_pair(gy,gx),cst,pattern,cp);\n\t\t\t\t\tif(r!=-1){\n\t\t\t\t\t\tif(minCost>r){\n\t\t\t\t\t\t\tminCost=min(minCost,r);\n\t\t\t\t\t\t\trp=cp;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t//if(cst!=INF){\n\t\t\t//\t// ­ÌBªHìÌBæè©Á½ê\n\t\t\t//\tif(cst<=i){\n\t\t\t//\t\tif(minCost>i){\n\t\t\t//\t\t\trp=cp;\n\t\t\t//\t\t\tminCost=min(minCost,i);\n\t\t\t//\t\t}\n\t\t\t//\t}\n\t\t\t//\t// ­ÌBªHìæèx©Á½ê\n\t\t\t//\telse{\n\t\t\t//\t\t// HìÌ®«ðV~[g·é\n\n\t\t\t//\t\t//int j=0;\n\t\t\t//\t\t//while(1){\n\t\t\t//\t\t//\tif(ghostPath[j%ghostPath.size()]==cp){\n\t\t\t//\t\t//\t\tminCost=min(minCost,j);\n\t\t\t//\t\t//\t\tbreak;\n\t\t\t//\t\t//\t}\n\t\t\t//\t\t//\tj++;\n\t\t\t//\t\t//}\n\n\t\t\t//\t\t//// Hìª­éÜÅÒÂ\n\t\t\t//\t\t//int cnt=cst;\n\t\t\t//\t\t//int j=(cst)%ghostPath.size();\n\t\t\t//\t\t//while(1){\n\t\t\t//\t\t//\tif(ghostPath[j]==cp){\n\t\t\t//\t\t//\t\tif(minCost>cnt){\n\t\t\t//\t\t//\t\t\tminCost=min(minCost,cnt);\n\t\t\t//\t\t//\t\t\trp=cp;\n\t\t\t//\t\t//\t\t}\n\t\t\t//\t\t//\t\tbreak;\n\t\t\t//\t\t//\t}\n\t\t\t//\t\t//\tj=(j+1)%ghostPath.size();\n\t\t\t//\t\t//\tcnt++;\n\t\t\t//\t\t//}\n\t\t\t//\t}\n\t\t\t//}\n\t\t}\n\t\tif(minCost==INF)\n\t\t\tcout<<\"impossible\"<<endl;\n\t\telse{\n\t\t\tcout<<minCost<<\" \"<<rp.first<<\" \"<<rp.second<<endl;\n\t\t}\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <map>\n#include <cmath>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i< n; i++)\n#define rep2(i, m, n) for(int i = m; i < n; i++)\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> state;\nconst int INF = 1 << 29;\nconst double EPS = 1e-10;\n\nint H, W;\nint memo[12][500][500];\nint dx[] = {1, 0, -1, 0, 0};\nint dy[] = {0, 1, 0, -1, 0};\nchar field[22][22];\n\nint h(int x, int y){\n  return y * W + x;\n}\n\nint main(){\n  int sx, sy, gx, gy;\n  string order;\n  while(cin >> H >> W && (H || W)){\n    rep(i, H) rep(j, W){\n      cin >> field[i][j];\n      if(field[i][j] == 'A'){\n\tfield[i][j] = '.';\n\tsy = i;\n\tsx = j;\n      }\n      if(field[i][j] == 'B'){\n\tfield[i][j] = '.';\n\tgy = i;\n\tgx = j;\n      }\n    }\n    cin >> order;\n    bool f = false;\n    queue<state> que;\n    memset(memo, -1, sizeof(memo));\n    que.push(state(0, P(h(sx, sy), h(gx, gy))));\n    memo[0][h(sx, sy)][h(gx, gy)] = 0;\n    while(!que.empty()){\n      int ngx, ngy;\n      state st = que.front();que.pop();\n      int turn = st.first;\n      sx = st.second.first % W;\n      sy = st.second.first / W;\n      gx = st.second.second % W;\n      gy = st.second.second / W;\n      //      cout << turn << \" \" << sx << \" \"<< sy << endl;\n      if(sx == gx && sy == gy){\n\tcout << memo[turn][h(sx,sy)][h(gx,gy)] << \" \" << sy << \" \" << gx << endl;\n\tf = true;\n\tbreak;\n      }\n \n      ngx = gx, ngy = gy;\n      if(order[turn] == '8') ngx = gx, ngy = gy - 1;\n      if(order[turn] == '6') ngx = gx + 1, ngy = gy;\n      if(order[turn] == '4') ngx = gx - 1, ngy = gy;\n      if(order[turn] == '2') ngx = gx, ngy = gy + 1;\n      if(0 > ngx || ngx >= W || 0 > ngy || ngy >= H){\n\tngx = gx;\n\tngy = gy;\n      }\n      rep(i, 5){\n\tint nturn = (turn + 1) % (int)order.size();\n\tint nsy = sy + dy[i];\n\tint nsx = sx + dx[i];\n\tif(0<=nsx && nsx<W && 0<=nsy && nsy<H && field[nsy][nsx] == '.'){\n\t  if(memo[nturn][h(nsx,nsy)][h(ngx, ngy)] == -1){\n\t    memo[nturn][h(nsx,nsy)][h(ngx,ngy)]=memo[turn][h(sx,sy)][h(gx,gy)]+1;\n\t    que.push(state(nturn, P(h(nsx, nsy), h(ngx, ngy))));\n\t  }\n\t}\n      } \n    } \n    if(!f) cout << \"impossible\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//suhan lee,saitama university\n\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\n#include <complex>\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define rep(i,a,b) for(int i=(a);i<(b);++i)\n#define repn(i,n) for(int i=0;i<n;i++)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\n#define pb push_back \n#define pf push_front\n#define INF 500\n\n\nvoid tansaku(vvi& saitanmap,int ax,int ay,int h,int w){\n  saitanmap[ay][ax]=0;\n  stack<pii> haba;\n  int px,py;\n  haba.push(make_pair(ay,ax));\n  while(!haba.empty()){\n   \n    px=haba.top().first;\n    py=haba.top().second;\n    //   cout<<px<<\" \"<<py<<\" \"<<saitanmap[px][py]<<endl;\n    haba.pop();\n    if(px+1>=0&&px+1<h&&py>=0&&py<w )\n      if(saitanmap[px][py]+1<saitanmap[px+1][py]){\n\n      saitanmap[px+1][py]=saitanmap[px][py]+1;\n      haba.push(make_pair(px+1,py));\n    }\n    //\tcout<<\"haha\\n\";\n    if (px-1>=0&&px-1<h ) \n      if(saitanmap[px][py]+1<saitanmap[px-1][py]\n      ){\n\n      saitanmap[px-1][py]=saitanmap[px][py]+1;\n      haba.push(make_pair(px-1,py));\n    }\n    //\tcout<<\"hahah\\n\";\n    if (py+1<w ) \n      if(saitanmap[px][py]+1<saitanmap[px][py+1]\n      ){\n\n      saitanmap[px][py+1]=saitanmap[px][py]+1;\n      haba.push(make_pair(px,py+1));\n    }\n    // cout<<\"hahaha\\n\";\n    if(py-1>=0&&py-1<w )\n      if(saitanmap[px][py]+1<saitanmap[px][py-1]\n        ){\n\t//\tcout<<\"hahass\\n\";\n      saitanmap[px][py-1]=saitanmap[px][py]+1;\n      haba.push(make_pair(px,py-1));\n    }\n\n  }\n}\nvoid yuurei(vvi saitanmap,string pattern,int bx,int by,int h,int w){\n  int len=pattern.size();\n  repn(i,INF){\n    if(saitanmap[by][bx]<=i&&saitanmap[by][bx]>=0){\n      cout<<i<<\" \"<<by<<\" \"<<bx<<endl;\n      return;\n    }\n    else{\n      //   cout<<i<<\"not answer  \"<<bx<<\" \"<<by<<endl;\n      switch(pattern[i%len]){\n      case '5':\n\tbreak;\n      case '2':\n\tif(by<h-1)\n\t  by+=1;\n\tbreak;\n      case '4':\n\tif(bx>0)\n\t  bx-=1;\n\tbreak;\n      case '6':\n\tif(bx<w-1)\n\t  bx+=1;\n\tbreak;\n      case '8':\n\tif(by>0)\n\t  by-=1;\n\tbreak;\n     \n      }\n    }\n  }\n  cout<<\"impossible\"<<endl;\n}\nint main(){\n  int h,w,ax,bx,ay,by;\n  string maptmp,pattern;\n  vvi saitanmap;\n  while(true){\n    cin>>h>>w;\n    if(h==0&&w==0) break;\n    saitanmap=vvi(h,vi(w,INF));\n    repn(i,h){\n      cin>>maptmp;\n      repn(j,w){\n\tif(maptmp[j]=='A') {ax=j;ay=i;}\n\telse if(maptmp[j]=='B') {bx=j;by=i;}\n\telse if(maptmp[j]=='#') saitanmap[i][j]=-1;\n\telse if(maptmp[j]=='.') saitanmap[i][j]=INF;\n\telse {cout<<\"error!\"; return 0;}\n      }\n    }\n    \n    tansaku(saitanmap,ax,ay,h,w);\n    cin>>pattern;\n    yuurei(saitanmap,pattern,bx,by,h,w);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <cstring>\nusing namespace std;\n\n#define mp make_pair\n\ntypedef pair<int, int> P;\nstruct Node {\n\tP a, b;\n\tint cnt;\n\tNode(P a, P b, int cnt) : a(a), b(b), cnt(cnt) {}\n};\n\nint dy[] = {0, 1, 0, -1, 0};\nint dx[] = {1, 0, -1, 0, 0};\n\nint conv(char c) {\n\tint ret;\n\tswitch(c) {\n\t\tcase '6': ret = 0; break;\n\t\tcase '2': ret = 1; break;\n\t\tcase '4': ret = 2; break;\n\t\tcase '8': ret = 3; break;\n\t\tcase '5': ret = 4; break;\n\t}\n\treturn ret;\n}\n\nchar field[20][21];\n\nint main() {\n\tfor(int H, W; ~scanf(\"%d%d\", &H, &W), H || W;) {\n\t\tP a_fst, b_fst;\n\n\t\tfor(int y = 0; y < H; y++) {\n\t\t\tscanf(\" %s\", field[y]);\n\t\t\tfor(int x = 0; x < W; x++) {\n\t\t\t\tif(field[y][x] == 'A') {\n\t\t\t\t\ta_fst = mp(y, x);\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t}\n\t\t\t\tif(field[y][x] == 'B') {\n\t\t\t\t\tb_fst = mp(y, x);\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tchar goast[11];\n\t\tint gsize;\n\t\tscanf(\" %s\", goast);\n\t\tgsize = strlen(goast);\n\n\t\tqueue<Node> Q;\n\t\tQ.push(Node(a_fst, b_fst, 0));\n\n\t\tbool done[20][20][20][20][10]; // a.y, a.x, b.y, b.x, goast_command_number\n\t\tmemset(done, 0, sizeof done);\n\n\t\tNode answer = Node(a_fst, b_fst, -1);\n\n\t\twhile(!Q.empty()) {\n\t\t\tNode now = Q.front(); Q.pop();\n\t\t\tP a = now.a, b = now.b;\n\t\t\tif(a.first == b.first && a.second == b.second) {\n\t\t\t\tanswer = now;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tfor(int i = 0; i < 5; i++) {\n\t\t\t\tint nay = a.first + dy[i];\n\t\t\t\tint nax = a.second + dx[i];\n\t\t\t\tint nby = b.first + dy[conv(goast[now.cnt % gsize])];\n\t\t\t\tint nbx = b.second + dx[conv(goast[now.cnt % gsize])];\n\n\t\t\t\tif(!(0 <= nay && nay < H && 0 <= nax && nax < W)) continue;\n\t\t\t\tif(!(0 <= nby && nby < H && 0 <= nbx && nbx < W)) {\n\t\t\t\t\tnby = b.first;\n\t\t\t\t\tnbx = b.second;\n\t\t\t\t}\n\t\t\t\tif(field[nay][nax] != '#' && done[nay][nax][nby][nbx][now.cnt % gsize] == false) {\n\t\t\t\t\tdone[nay][nax][nby][nbx][now.cnt % gsize] = true;\n\t\t\t\t\tQ.push(Node(mp(nay, nax), mp(nby, nbx), now.cnt + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(answer.cnt == -1) {\n\t\t\tputs(\"impossible\");\n\t\t} else {\n\t\t\tprintf(\"%d %d %d\\n\", answer.cnt, answer.a.first, answer.a.second);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n\n#define pb push_back\n#define mp make_pair\n#define contains(c, x) (c).find(x) != (c).end()\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\nint h, w;\nvector<string> grid(21);\nstring pattern;\nint g[21][21];\n\nint dx[5] = { 0, -1, 0, 0, 1 };\nint dy[5] = { 0, 0, -1, 1, 0 };\n\nint p2i(int Time)\n{\n\tswitch (pattern[Time % pattern.size()] - '0') {\n\t\tcase 5: return 0;\n\t\tcase 8: return 2;\n\t\tcase 6: return 4;\n\t\tcase 4: return 1;\n\t\tcase 2: return 3;\n\t}\n}\n\nint main()\n{\n\twhile (true) {\n\t\tcin >> h >> w; if (h == 0 && w == 0) break;\n\t\trep(i, h) cin >> grid[i];\n\t\tcin >> pattern;\n\t\t\n\t\tpair<int, int> a, b;\n\t\trep(i, h) rep(j, w)\n\t\t\tif (grid[i][j] == 'A') a = mp(i, j);\n\t\t\telse if (grid[i][j] == 'B') b = mp(i, j);\n\n\t\trep(i, h) rep(j, w) g[i][j] = -1;\n\t\tqueue<pair<int, int> > q;\n\t\tmap<pair<int, int>, int> m;\n\t\tq.push(a);\n\t\tm[a] = 0;\n\t\twhile (!q.empty()) {\n\t\t\tpair<int, int> t = q.front(); q.pop();\n\t\t\tg[t.first][t.second] = m[t];\n\t\t\trep(i, 5) {\n\t\t\t\tint dr = t.first + dy[i];\n\t\t\t\tint dc = t.second + dx[i];\n\t\t\t\tpair<int, int> next = mp(dr, dc);\n\t\t\t\tif (dr < 0 || dr >= h || dc < 0 || dc >= w) continue;\n\t\t\t\tif (grid[dr][dc] == '#' || contains(m, next)) continue;\n\t\t\t\tq.push(next);\n\t\t\t\tm[next] = m[t] + 1;\n\t\t\t}\n\t\t}\n\t\tint T = 1;\n\t\twhile (T < 10000) {\n\t\t\trep(i, pattern.size()) {\n\t\t\t\tint k = p2i(T-1);\n\t\t\t\tint br = b.first + dy[k];\n\t\t\t\tint bc = b.second + dx[k];\n\t\t\t\tif (0 <= br && br < h && 0 <= bc && bc < w)\n\t\t\t\t\tb = mp(b.first + dy[k], b.second + dx[k]);\n\t\t\t\tbr = b.first;\n\t\t\t\tbc = b.second;\n\t\t\t\tif (g[br][bc] >= 0 && g[br][bc] <= T) {\n\t\t\t\t\tcout << max(g[br][bc], T) << \" \" << br << \" \" << bc << endl;\n\t\t\t\t\tgoto CONTINUE;\n\t\t\t\t}\n\t\t\t\tT++;\n\t\t\t}\n\t\t}\n\t\tcout << \"impossible\" << endl;\nCONTINUE:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nchar g[20][20];\nint h,w;\nint t[20][20];\n\nvoid ff(int x,int y,int ct){\n  if(x<0||w<=x||y<0||h<=y||t[y][x]<ct||g[y][x]=='#')return;\n  t[y][x]=ct;\n  for(int i=0;i<4;i++){\n    int d[]={0,1,0,-1,0};\n    ff(x+d[i],y+d[i+1],ct+1);\n  }\n}\n\nint main(){\n  while(cin>>h>>w,h|w){\n    int ax,ay,bx,by;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n\tif(g[y][x]=='A'){\n\t  ax=x;\n\t  ay=y;\n\t}else if(g[y][x]=='B'){\n\t  bx=x;\n\t  by=y;\n\t}\n      }\n    }\n    fill(t[0],t[20],1<<30);\n    ff(ax,ay,0);\n    string p;\n    cin>>p;\n    int e;\n    for(e=0;e<10000;e++){\n      if(t[by][bx]<=e)break;\n      char o=p[e%p.size()];\n      int ny=by+(o=='2')-(o=='8');\n      int nx=bx+(o=='6')-(o=='4');\n      if(0<=ny&&ny<h&&0<=nx&&nx<w){\n\tby=ny;\n\tbx=nx;\n      }\n    }\n    if(e<10000){\n      cout<<e<<' '<<by<<' '<<bx<<endl;\n    }else{\n      cout<<\"impossible\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <string>\n#include <string.h>\nusing namespace std;\n\ntypedef pair<int,int> P;//y,x\n\nconst int dx[] = {1,0,-1,0,0};//東、南、西、北、無\nconst int dy[] = {0,1,0,-1,0};\n\nint gdx[10];\nint gdy[10];\nint field[22][22];\n\nint cost[22][22][22][22][10];\n\nstruct S\n{\n\tP m;\n\tP g;\n\tint gp;\n\tS(P m_,P g_,int gp_):m(m_),g(g_),gp(gp_){}\n};\n\nint main(void)\n{\n\tgdx[5]=0;gdx[8]=0;gdx[6]=1;gdx[4]=-1;gdx[2]=0;\n\tgdy[5]=0;gdy[8]=-1;gdy[6]=0;gdy[4]=0;gdy[2]=1;\n\twhile(1){\n\t\tmemset(cost,-1,sizeof(cost));\n\t\tmemset(field,0,sizeof(field));\n\t\tP ms,gs;\n\t\tvector<int> gp;\n\t\tint W,H;\n\t\tcin >> H >> W;\n\t\tif(H==0 && W==0)\n\t\t\treturn 0;\n\t\tfor(int y=1;y<=H;++y){\n\t\t\tstring in;\n\t\t\tcin >> in;\n\t\t\tfor(int x=1;x<=W;++x){\n\t\t\t\tfield[y][x] = in[x-1];\n\t\t\t\tif(field[y][x] == 'A'){\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t\tms.first = y;\n\t\t\t\t\tms.second = x;\n\t\t\t\t}\n\t\t\t\tif(field[y][x] == 'B'){\n\t\t\t\t\tfield[y][x] = '.';\n\t\t\t\t\tgs.first = y;\n\t\t\t\t\tgs.second = x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tstring in;\n\t\tcin >> in;\n\t\tfor(int i=0;i<in.size();++i){\n\t\t\tgp.push_back(in[i]-'0');\n\t\t}\n\t\t////////////////////////////////////////\n\t\tqueue<S> q;\n\t\tq.push(S(ms,gs,0));\n\t\tint turn=0;\n\t\tP g(-1,-1);\n\t\tint gt=-1;\n\t\tbool isGoal=false;\n\t\tcost[ms.first][ms.second][gs.first][gs.second][gp.size()-1] = 0;\n\t\twhile(!q.empty()){\n\t\t\tint size=q.size();\n\t\t\tfor(int aaa=0;aaa<size;++aaa){\n\t\t\t\tS s = q.front(); q.pop();\n\t\t\t\tP gn = P(s.g.first+gdy[gp[turn]],s.g.second+gdx[gp[turn]]);\n\t\t\t\tif(field[gn.first][gn.second] == 0)\n\t\t\t\t\tgn = s.g;\n\t\t\t\tfor(int i=0;i<5;++i){\n\t\t\t\t\tP mn = P(s.m.first+dy[i],s.m.second+dx[i]);\n\t\t\t\t\tif(cost[mn.first][mn.second][gn.first][gn.second][turn] == -1 && field[mn.first][mn.second] == '.'){\n\t\t\t\t\t\tcost[mn.first][mn.second][gn.first][gn.second][turn] = cost[s.m.first][s.m.second][s.g.first][s.g.second][(turn+gp.size()-1)%gp.size()]+1;\n\t\t\t\t\t\tif(mn == gn){\n\t\t\t\t\t\t\tg = mn;\n\t\t\t\t\t\t\tgt =  turn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tq.push(S(mn,gn,gp[turn]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(g.first != -1)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(g.first != -1)\n\t\t\t\tbreak;\n\t\t\t++turn;\n\t\t\tturn%=gp.size();\n\t\t}\n\t\tif(g.first != -1)\n\t\t\tcout << cost[g.first][g.second][g.first][g.second][gt] << ' ' << g.first-1  << ' '<< g.second-1 << endl;\n\t\telse\n\t\t\tcout << \"impossible\" << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define f(a,b) for(i=a;i<b;i++)\n\nint i,j,h,w,sx,sy,gx,gy,x,y,go;\nint dx[4]={1,0,-1,0};\nint c[20][20];\nint m = 999999;\nchar n[20][20];\nstring pat;\nqueue<pa>q;\n\nint main(){\n    while(cin>>h>>w,h){\n        f(i,h)f(j,w){\n            c[i][j]=m;\n            cin>>n[i][j];\n            if(n[i][j]=='A')\n                sx=j,sy=i;\n            else if(n[i][j]=='B')\n                gx=j,gy=i;\n        }\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(c[p.fs][p.ff]!=m)\n                continue;\n            c[p.fs][p.ff]=p.second;\n            f(i,4){\n                x=p.ff+dx[i];\n                y=p.fs+dx[(i+1)%4];\n                if(x>=0&&x<w&&y>=0&y<h&&n[y][x]!='#'&&c[y][x]==m)\n                    q.push(make_pair(make_pair(x, y), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(j=0,go=0;;j++,go++){\n            i=j%pat.length();\n            if(c[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>700){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//35\n#include<iostream>\n#include<algorithm>\n#include<string>\n\nusing namespace std;\n\nchar g[20][20];\nint h,w;\nint t[20][20];\n\nvoid ff(int x,int y,int ct){\n  if(x<0||w<=x||y<0||h<=y||t[y][x]<ct||g[y][x]=='#')return;\n  t[y][x]=ct;\n  for(int i=0;i<4;i++){\n    int d[]={0,1,0,-1,0};\n    ff(x+d[i],y+d[i+1],ct+1);\n  }\n}\n\nint main(){\n  while(cin>>h>>w,h|w){\n    int ax,ay,bx,by;\n    for(int y=0;y<h;y++){\n      for(int x=0;x<w;x++){\n\tcin>>g[y][x];\n\tif(g[y][x]=='A'){\n\t  ax=x;\n\t  ay=y;\n\t}else if(g[y][x]=='B'){\n\t  bx=x;\n\t  by=y;\n\t}\n      }\n    }\n    fill(t[0],t[20],1<<30);\n    ff(ax,ay,0);\n    string p;\n    cin>>p;\n    int e;\n    for(e=0;e<100;e++){\n      if(t[by][bx]<=e)break;\n      char o=p[e%p.size()];\n      int ny=by+(o=='2')-(o=='8');\n      int nx=bx+(o=='6')-(o=='4');\n      if(0<=ny&&ny<h&&0<=nx&&nx<w){\n\tby=ny;\n\tbx=nx;\n      }\n    }\n    if(e<10000){\n      cout<<e<<' '<<by<<' '<<bx<<endl;\n    }else{\n      cout<<\"impossible\"<<endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define f(a,b) for(i=a;i<b;i++)\n\nint h,w,sx,sy,gx,gy,i,j,go,m = 999999;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        f(i,h){\n            f(j,w){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            f(i,4){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(j=0,go=0;;j++,go++){\n            i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>700){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\nint dd[]={0,1,0,-1,0};\nbool check(int a,int b){\n\tif(0<=a&&a<h&&0<=b&&b<w) return true;\n\treturn false;\n}\nvoid bfs(pii p,int x,vector<string> &v,vvint &vv){\n\tif(vv[p.F][p.S]<=x) return;\n\tvv[p.F][p.S]=x;\n\trep(i,4){\n\t\tpii ne=pii(p.F+dd[i],p.S+dd[i+1]);\n\t\tif(!check(ne.F,ne.S)||v[ne.F][ne.S]=='#') continue;\n\t\tbfs(ne,x+1,v,vv);\n\t}\n}\nvoid mainmain(){\n\tvector<pii> vec(10);\n\tvec[2]=pii(1,0);\n\tvec[4]=pii(0,-1);\n\tvec[5]=pii(0,0);\n\tvec[6]=pii(0,1);\n\tvec[8]=pii(-1,0);\n\twhile(cin>>h>>w,h||w){\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tstring s;\n\t\tcin>>s;\n\t\tvvint vv;\n\t\tinitvv(vv,h,w,-1);\n\t\tpii A,B;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='A'){\n\t\t\t\t\tA=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t\tif(v[i][j]=='B'){\n\t\t\t\t\tB=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// bfs(A,0,v,vv);\n\t\tqueue<pair<pii,int>> q;\n\t\tq.push(mkp(A,0));\n\t\tvv[A.F][A.S]=0;\n\t\twhile(q.size()){\n\t\t\tauto top=q.front();\n\t\t\tq.pop();\n\t\t\trep(i,4){\n\t\t\t\tpii ne(top.F.F+dd[i],top.F.S+dd[i+1]);\n\t\t\t\tif(!check(ne.F,ne.S)||v[ne.F][ne.S]=='#'||vv[ne.F][ne.S]>=0) continue;\n\t\t\t\tvv[ne.F][ne.S]=top.S+1;\n\t\t\t\tq.push(mkp(ne,top.S+1));\n\t\t\t}\n\t\t}\n\t\tint ans=-1;\n\t\tpii pos;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\t// printf(\"%2d \",vv[i][j]);\n\t\t\t\tif(vv[i][j]==-1) vv[i][j]=INF;\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\trep(i,1e5){\n\t\t\t// cout<<i<<\" \"<<B.F<<\" \"<<B.S<<endl;\n\t\t\tif(vv[B.F][B.S]<=i){\n\t\t\t\tans=i;\n\t\t\t\tpos=B;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint t=s[i%s.size()]-'0';\n\t\t\tpii ne=pii(B.F+vec[t].F,B.S+vec[t].S);\n\t\t\tif(check(ne.F,ne.S)){\n\t\t\t\tB=ne;\n\t\t\t}\n\t\t}\n\t\tif(ans==-1){\n\t\t\tcout<<\"impossible\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<ans<<\" \"<<pos.F<<\" \"<<pos.S<<endl;\n\t\t}\n\t\t// return;\n\t}\n}\n\n\nsigned main() {\n\t// ios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nvector<string> s;\nP d[10];\nint antime;\nP q;\nmap<int,int> mp;\nstring op;\nint dp[20][20];\nbool in(P n){\n\tif(n.second>=0&&n.second<w&&n.first>=0&&n.first<h)\n\t\treturn true;\n\treturn false;\n}\nint ans;\nint ret(P b,int time){\n\t//cout<<b.first<<\"  \"<<b.second<<endl;\n\tif(time>400)\n\treturn INF;\n\tif(dp[b.first][b.second]<=time){\n\t\tq.first=b.first;\n\t\tq.second=b.second;\n\t\treturn time;\n\t}\n\tP nb;\n\tnb.first=b.first+d[op[time%op.size()]-'0'].first;\n\tnb.second=b.second+d[op[time%op.size()]-'0'].second;\n\tif(!in(nb))\n\t\tnb=b;\n\treturn ret(nb,time+1);\n}\nint dx[]={0,0,1,-1},dy[]={1,-1,0,0};\nvoid bfs(P a){\n\tqueue<P> que;\n\tque.push(a);\n\tdp[a.first][a.second]=0;\n\twhile(!que.empty()){\n\t\tP t=que.front(),nt;\n\t\tque.pop();\n\t\t//cout<<dp[t.first][t.second]<<endl;\n\t\tfor(int i=0;i<4;i++){\n\t\t\tnt.first=t.first+dy[i];\n\t\t\tnt.second=t.second+dx[i];\n\t\t\tif(in(nt)&&dp[nt.first][nt.second]==INF&&s[nt.first][nt.second]!='#'){\n\t\t\t\tque.push(nt);\n\t\t\t\tdp[nt.first][nt.second]=dp[t.first][t.second]+1;\n\t\t\t}\n\t\t}\n\t}\n}\nint main(){\n\td[5]=P(0,0);d[8]=P(-1,0);d[6]=P(0,1);d[4]=P(0,-1);d[2]=P(1,0);\n\tmp[0]=5;mp[1]=8;mp[2]=6;mp[3]=4;mp[4]=2;\n\twhile(cin>>h>>w,h||w){\n\t\ts.clear();\n\t\tP a,b;\n\t\tantime=INF;\n\t\t//memset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++)\n\t\tfor(int j=0;j<w;j++)\n\t\tdp[i][j]=INF;\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\ts.pb(t);\n\t\t\tfor(int j=0;j<t.size();j++){\n\t\t\t\tif(t[j]=='A'){\n\t\t\t\t\ta.first=i;a.second=j;\n\t\t\t\t}else if(t[j]=='B'){\n\t\t\t\t\tb.first=i;b.second=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin>>op;\n\t\tbfs(a);\n\t\tint ans=ret(b,0);\n\t\tif(ans!=INF)\n\t\t\tcout<<ans<<\" \"<<q.first<<\" \"<<q.second<<endl;\n\t\telse\n\t\t\tcout<<\"impossible\"<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <queue>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\n#define SIZE 21\n\nclass Point {\npublic:\n    int r, c;\n    Point( int r, int c ) : r(r), c(c) {};\n    Point() { r = 0, c = 0; };\n\n    bool operator == ( const Point& right ) const\n    {\n        return r == right.r && c == right.c;\n    }\n\n    bool operator < ( const Point& right ) const\n    {\n        return r != right.r ? r < right.r : c < right.c;\n    }\n};\n\ntypedef pair <Point, Point> PPP;\ntypedef pair <int, PPP> PIP;\n\nint h, w;\nint m[SIZE][SIZE];\n\n// for girl\nbool check_girl( Point p )\n{\n    int r = p.r, c = p.c;\n    if ( r >= 0 && r < h && c >= 0 && c < w ) {\n        if ( m[r][c] == 0 ) {\n            return true;\n        }\n    }\n    return false;\n}\n\n// for ghost\nbool check_ghost( Point p )\n{\n    int r = p.r, c = p.c;\n    return r >= 0 && r < h && c >= 0 && c < w;\n}\n\nint main( void )\n{\n    string line;\n    while ( getline( cin, line ) ) {\n        // input\n        istringstream is(line);\n        is >> h >> w;\n        if ( h == 0 && w == 0 ) break;\n        \n        for ( int i = 0; i < h; i++ )\n        {\n            getline( cin, line );\n            for ( int j = 0; j < w; j++ ) {\n                if ( line[j] == '.' ) {\n                    m[i][j] = 0;\n                } else if ( line[j] == '#' ) {\n                    m[i][j] = 1;\n                } else if ( line[j] == 'A' ) {\n                    m[i][j] = 2;\n                } else if ( line[j] == 'B' ) {\n                    m[i][j] = 3;\n                }\n            }\n        }\n\n        string op;\n        getline( cin, op );\n        int opsize = op.size();\n\n        queue <PIP> Q;\n        set <PIP>   V;\n        {\n            // start node\n            Point start, goal;\n            for ( int i = 0; i < h; i++ ) for ( int j = 0; j < w; j++ ) {\n                if ( m[i][j] == 2 ) {\n                    start.r = i;\n                    start.c = j;\n                    m[i][j] = 0;\n                } else if ( m[i][j] == 3 ) {\n                    goal.r = i;\n                    goal.c = j;\n                    m[i][j] = 0;\n                }\n            }\n\n            PPP init_second( start, goal );\n            PIP init( 0, init_second );\n            Q.push( init );\n            V.insert( init );\n        }\n\n        // bfs\n        int a_first = -1, a_second, a_third;\n        while ( !Q.empty() ) {\n            PIP e = Q.front();\n            Q.pop();\n            int t = e.first;\n            Point s = e.second.first, g = e.second.second;\n\n            // is it goal?\n            if ( s == g ) {\n                a_first = t;\n                a_second = s.r;\n                a_third = s.c;\n                break;\n            }\n\n            // move ghost\n            int index = t % opsize;\n            char c = op[index];\n            \n            Point next_s = s, next_g = g;\n            int next_t = t+1;\n            int next_index = ( next_t ) % opsize;\n            if ( c == '5' ) {\n                // stop\n            } else if ( c == '8' ) {\n                // north\n                next_g.r -= 1;\n            } else if ( c == '6' ) {\n                // east\n                next_g.c += 1;\n            } else if ( c == '4' ) { \n                // west\n                next_g.c -= 1;\n            } else if ( c == '2' ) {\n                // south\n                next_g.r += 1;\n            }\n            if ( !check_ghost( next_g ) ) next_g = g;\n\n            // move girl\n            int dr[5] = { 0, -1, 0, 0, 1 };\n            int dc[5] = { 0, 0, 1, -1, 0 };\n            Point backup = next_s;\n            for ( int k = 0; k < 5; k++ ) {\n                next_s = backup;\n                next_s.r += dr[k];\n                next_s.c += dc[k];\n                PPP next_second( next_s, next_g );\n                PIP next_check( next_index, next_second );\n\n                // already visited\n                if ( V.count( next_check ) ) continue;\n                if ( !check_girl( next_s ) )  continue;\n                V.insert( next_check );\n                \n                PIP next( next_t, next_second );\n                Q.push( next );\n            }\n        } // end of bfs\n\n        if ( a_first == -1 ) {\n            cout << \"impossible\" << endl;\n        } else {\n            cout << a_first << \" \" << a_second << \" \" << a_third << endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<map>\n#include<string>\n#include<vector>\n#include<algorithm>\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\nint w,h;\nvector<string> s;\nP d[10];\nint antime;\nP q;\nmap<int,int> mp;\nstring op;\nint dp[20][20][20][20][100];\nbool in(P n){\n\tif(n.second>=0&&n.second<w&&n.first>=0&&n.first<h)\n\t\treturn true;\n\treturn false;\n}\nvoid f(int cnt){\n\tcout<<cnt<<endl;\n\tf(cnt+1);\n}\nint ans;\nint ret(P a,P b,int time){\n\t//cout<<time<<endl;\n\t\n\tif(a==b){\n\t\tif(antime>time){\n\t\t\tantime=time;\n\t\t\tq.first=a.first;\n\t\t\tq.second=a.second;\n\t\t}\n\t\t//cout<<a.first<<\" \"<<a.second<<endl;\n\t\t//cout<<time<<endl;\n\t\treturn time;\n\t}\n\tif(100<time)\n\treturn INF;\n\t\n\tif(dp[a.first][a.second][b.first][b.second][time]!=-1)\n\t\treturn dp[a.first][a.second][b.first][b.second][time];\n\t\n\tint ans=INF;\n\tP na,nb;\n\t\n\tnb.first=b.first+d[op[time%op.size()]-'0'].first;\n\tnb.second=b.second+d[op[time%op.size()]-'0'].second;\n\t\n\tif(!in(nb))\n\t\tnb=b;\n\tfor(int i=0;i<5;i++){\n\t\tna.first=a.first+d[mp[i]].first;\n\t\tna.second=a.second+d[mp[i]].second;\n\t\t\n\t\tif(in(na)&&s[na.first][na.second]!='#'){\n\t\t\t//<<\"-------\"<<endl;\n\t\t\tans=min(ans,ret(na,nb,time+1));\n\t\t}/*(time%op.size()))*/\n\t}\n\treturn dp[a.first][a.second][b.first][b.second][time]=ans;\n}\nint main(){\n\td[5]=P(0,0);d[8]=P(-1,0);d[6]=P(0,1);d[4]=P(0,-1);d[2]=P(1,0);\n\tmp[0]=5;mp[1]=8;mp[2]=6;mp[3]=4;mp[4]=2;\n\twhile(cin>>h>>w,h||w){\n\t\ts.clear();\n\t\tP a,b;\n\t\tantime=INF;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<h;i++){\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\ts.pb(t);\n\t\t\tfor(int j=0;j<t.size();j++){\n\t\t\t\tif(t[j]=='A'){\n\t\t\t\t\ta.first=i;a.second=j;\n\t\t\t\t}else if(t[j]=='B'){\n\t\t\t\t\tb.first=i;b.second=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}cin>>op;\n\t\tret(a,b,0);\n\t\tif(antime!=INF)\n\t\t\tcout<<antime<<  \" \"<<q.first<<\" \"<<q.second<<endl;\n\t\telse\n\t\tcout<<\"impossible\"<<endl;\n\t\t//f(0);\n\t\t\n\t\t//cout<<<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue>\nint main(){std::queue<int>q;int w,h,f[484],i,j,a,b,t,x,z;char p[15];for(;scanf(\"%d%d \",&h,&w),h;){for(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-1;for(i=1;i<=h;i++){for(j=1;j<=w;j++)f[x=i*22+j]=-2,z=getchar(),z-35?z>65?b=x:z>64?a=x:1:--f[x];f[i*22]=f[i*22-~w]=-9;getchar();}f[a]=t=0;q.push(0);for(q.push(a);a=q.front(),q.size()>1;q.pop())if(!a)++t,q.push(0);else for(i=4;i--;)if(f[x=a+\" 57L\"[i]-54]==-2)f[x]=t,q.push(x);q.pop();scanf(\"%s\",p);for(a=t=0;!a;){x=b;z=0;for(i=0;!a&&p[i];f[b]>=0&&++z)++t,~f[j=b-54+\"L65676 \"[p[i++]-50]]?b=j:0,f[b]>=0&t>=f[b]?a=b:0;!z&!a&!p[i]&b==x&f[b]<0&&--a;}printf(~a?\"%d %d %d\\n\":\"impossible\\n\",t,a/22-1,a%22-1);}}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <sstream>\n#include <cassert>\n#include <list>\n#include <fstream>\nusing namespace std;\nstatic const double EPS = 1e-5;\ntypedef long long ll;\ntypedef pair<int,int> PI;\ntypedef vector<int> vi;\n#ifndef M_PI\n#define M_PI 3.14159265358979323846\n#endif\n#define rep(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define F first\n#define S second\n\n\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\n\nmain(){\n  int h,w;\n  while(cin>>h>>w,h|w){\n    string in[h],pa;\n    int sx,sy,bx,by;\n    rep(i,h){\n      cin>>in[i];\n      rep(j,w){\n\tif(in[i][j]=='A'){\n\t  sx=i;\n\t  sy=j;\n\t  in[i][j]='.';\n\t}\n\tif(in[i][j]=='B'){\n\t  bx=i;\n\t  by=j;\n\t  in[i][j]='.';\n\t}\n      }\n    }\n    cin>>pa;\n\n\n    int cost[h][w];\n    rep(i,h)rep(j,w)cost[i][j]=INT_MAX/2;\n\n    queue<PI> Q;\n    Q.push(mp(0,sx*1000+sy));\n\n    while(!Q.empty()){\n      int cc=Q.front().F,cx=Q.front().S/1000,cy=Q.front().S%1000;\n      Q.pop();\n      if(cost[cx][cy]<cc)continue;\n      cost[cx][cy]=cc;\n      //cout<<cx<<\" \"<<cy<<endl;\n\n      rep(i,4){\n\tint nx=cx+dx[i],ny=cy+dy[i];\n\tif(nx<0 || h<=nx || ny<0 || w<=ny || in[nx][ny]=='#'){\n\t  continue;\n\t}\n\tQ.push(mp(cc+1,1000*nx+ny));\n      }\n    }\n\n    int ans=-1,ax,ay;\n    set<int> app[h][w];\n    int po=0;\n    int time=0;\n    int imp=0;\n\n    while(true){\n      if(cost[bx][by]<=time){\n\tans=time;\n\tax=bx;\n\tay=by;\n\tbreak;\n      }\n\n      if(app[bx][by].count(po)){\n\tbreak;\n      }\n\n      if(cost[bx][by]==INT_MAX/2){\n\timp++;\n      }\n\n      if(cost[bx][by]==INT_MAX/2 && imp>=pa.size()){\n\tapp[bx][by].insert(po);\n      }\n      \n      int px=bx,py=by;\n      switch(pa[po]){\n      case '8':\n\tbx--;\n\tbreak;\n      case '6':\n\t++by;\n\tbreak;\n      case '4':\n\t--by;\n\tbreak;\n      case '2':\n\t++bx;\n\tbreak;\n      }\n      if(bx<0 || h<=bx || by<0 || w<=by){\n\tbx=px;\n\tby=py;\n      }\n      ++time;\n      ++po;\n      if(po>=pa.size()){\n\tpo=0;\n\tif(imp<pa.size())imp=0;\n      }\n    }\n    if(ans==-1)cout<<\"impossible\";\n    else cout<<ans<<\" \"<<ax<<\" \"<<ay;\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\nint dd[]={0,1,0,-1,0};\nbool check(int a,int b){\n\tif(0<=a&&a<h&&0<=b&&b<w) return true;\n\treturn false;\n}\nvoid bfs(pii p,int x,vector<string> &v,vvint &vv){\n\tif(vv[p.F][p.S]>=0) return;\n\tvv[p.F][p.S]=x;\n\trep(i,4){\n\t\tpii ne=pii(p.F+dd[i],p.S+dd[i+1]);\n\t\tif(!check(ne.F,ne.S)||v[ne.F][ne.S]=='#') continue;\n\t\tbfs(ne,x+1,v,vv);\n\t}\n}\nvoid mainmain(){\n\tvector<pii> vec(10);\n\tvec[2]=pii(1,0);\n\tvec[4]=pii(0,-1);\n\tvec[5]=pii(0,0);\n\tvec[6]=pii(0,1);\n\tvec[8]=pii(-1,0);\n\twhile(cin>>h>>w,h||w){\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tstring s;\n\t\tcin>>s;\n\t\tvvint vv;\n\t\tinitvv(vv,h,w,-1);\n\t\tpii A,B;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='A'){\n\t\t\t\t\tA=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t\tif(v[i][j]=='B'){\n\t\t\t\t\tB=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(A,0,v,vv);\n\t\tint ans=-1;\n\t\tpii pos;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\t// printf(\"%2d \",vv[i][j]);\n\t\t\t\tif(vv[i][j]==-1) vv[i][j]=INF;\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\trep(i,1e6){\n\t\t\t// cout<<i<<\" \"<<B.F<<\" \"<<B.S<<endl;\n\t\t\tif(vv[B.F][B.S]<=i){\n\t\t\t\tans=i;\n\t\t\t\tpos=B;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint t=s[i%s.size()]-'0';\n\t\t\tpii ne=pii(B.F+vec[t].F,B.S+vec[t].S);\n\t\t\tif(check(ne.F,ne.S)){\n\t\t\t\tB=ne;\n\t\t\t}\n\t\t}\n\t\tif(ans==-1){\n\t\t\tcout<<\"impossible\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<ans<<\" \"<<pos.F<<\" \"<<pos.S<<endl;\n\t\t}\n\t\t// return;\n\t}\n}\n\n\nsigned main() {\n\t// ios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate <typename T>\nusing vec1 = vector<T>;\n\ntemplate <typename T>\nusing vec2 = vec1<vec1<T>>;\n\ntemplate <typename T>\nvec2<T> InitVec2(size_t x, size_t y, const T& i = T())\n{\n    return vec2<T>(y, vec1<T>(x, i));\n}\n\ntemplate <typename T>\nT Get(const vec2<T>& v2, size_t x, size_t y)\n{\n    return v2[y][x];\n}\n\ntemplate <typename T>\nT& Ref(vec2<T>& v2, size_t x, size_t y)\n{\n    return v2[y][x];\n}\n\ntemplate <typename T>\nbool Find(const vec2<T>& v2, const T& val, size_t& x, size_t& y)\n{\n    for (y = 0; y < v2.size(); ++y) {\n        for (x = 0; x < v2.front().size(); ++x) {\n            if (Get(v2, x, y) == val) return true;\n        }\n    }\n    return false;\n}\n\ntemplate <typename T>\nT cin2var()\n{\n    T val;\n    cin >> val;\n    return val;\n}\n\ntemplate <typename T>\nvec1<T> cin2vec(size_t size)\n{\n    vec1<T> vec1;\n    for (size_t i = 0; i < size; ++i) {\n        vec1.push_back(cin2var<T>());\n    }\n    return vec1;\n}\n\nconstexpr int Inf = INT_MAX / 2;\n\nstruct Immutable\n{\n    size_t     W;\n    size_t     H;\n    vec2<char> vec2map;\n    string     pattern;\n};\n\nstruct Mutable\n{\n    vec2<int> vec2map;\n    int       max_count;\n};\n\nImmutable it_{};\nMutable   mt_{};\n\nvoid Hosuu(size_t x, size_t y)\n{\n    const array<int, 4> dx{1, 0, -1, 0};\n    const array<int, 4> dy{0, 1, 0, -1};\n    const Immutable&    it(it_);\n    Mutable&            mt(mt_);\n    Ref(mt.vec2map, x, y) = 0;\n    using XY              = tuple<size_t, size_t>;\n    queue<XY> que;\n    que.push(make_tuple(x, y));\n    while (!que.empty()) {\n        const XY& xy(que.front());\n        que.pop();\n        const int max_count = Get(mt.vec2map, get<0>(xy), get<1>(xy)) + 1;\n        for (size_t i = 0; i < dx.size(); ++i) {\n            const int nx = get<0>(xy) + dx[i];\n            const int ny = get<1>(xy) + dy[i];\n            if (0 > nx || nx >= static_cast<int>(it.W) || 0 > ny || ny >= static_cast<int>(it.H)) continue;\n            if (Get(it.vec2map, nx, ny) == '#' || Get(mt.vec2map, nx, ny) != Inf) continue;\n            que.push(make_tuple(nx, ny));\n            Ref(mt.vec2map, nx, ny) = max_count;\n            if (mt.max_count < max_count) {\n                mt.max_count = max_count;\n            }\n        }\n    }\n}\n\nbool MoveG(int count, size_t& x, size_t& y)\n{\n    Mutable& mt(mt_);\n    if (Get(mt.vec2map, x, y) <= count) return true;\n    const Immutable& it(it_);\n    const size_t     pos = count % it.pattern.size();\n    const char       act = it.pattern.at(pos);\n    switch (act) {\n    case '5':\n        // 何もしない\n        return false;\n    case '8':\n        if (y > 0) {\n            --y;\n        }\n        return false;\n    case '6':\n        if (x < it.W - 1) {\n            ++x;\n        }\n        return false;\n    case '4':\n        if (x > 0) {\n            --x;\n        }\n        return false;\n    case '2':\n        if (y < it.H - 1) {\n            ++y;\n        }\n        return false;\n    default:\n        assert(!\"act\");\n        return false;\n    }\n}\n\nbool sub()\n{\n    it_.H = (cin2var<size_t>());\n    it_.W = (cin2var<size_t>());\n    if (!it_.H && !it_.W) {\n        return false;\n    }\n    it_.vec2map.clear();\n    for (size_t i = 0; i < it_.H; ++i) {\n        it_.vec2map.push_back(cin2vec<char>(it_.W));\n    }\n    it_.pattern = cin2var<string>();\n\n    mt_.vec2map = InitVec2<int>(it_.W, it_.H, Inf);\n\n    size_t a_x = 0;\n    size_t a_y = 0;\n    if (!Find(it_.vec2map, 'A', a_x, a_y)) {\n        assert(!\"Not found A\");\n        return false;\n    }\n\n    // 移動距離を求める\n    Hosuu(a_x, a_y);\n\n    size_t b_x = 0;\n    size_t b_y = 0;\n    if (!Find(it_.vec2map, 'B', b_x, b_y)) {\n        assert(!\"Not found B\");\n        return false;\n    }\n\n    // 調査するターン数を決める\n    const int  pattern_size = it_.pattern.size();\n    const int  g_count      = pattern_size * pattern_size * 2;\n    const auto count        = max(mt_.max_count, g_count);\n\n    // ゴーストを動かす\n    for (int i = 0; i <= count; ++i) {\n        if (MoveG(i, b_x, b_y)) {\n            cout << i << ' ' << b_y << ' ' << b_x << endl;\n            return true;\n        }\n    }\n\n    cout << \"impossible\" << endl;\n    return true;\n}\n\nint main()\n{\n    while (true) {\n        if (!sub()) {\n            break;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define mp(a,b,c) make_pair(make_pair(a,b),c)\n\nint h,w,sx,sy,gx,gy,m=9999;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(mp(sx, sy, 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            for(int i=0;i<4;i++){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(mp(nx, ny, p.second+1));\n            }\n        }\n        cin>>pat;\n        for(int j=0,go=0;int i=j%pat.length();j++,go++){\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>10000){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int dx[4] = {1,-1,0,0};\nconst int dy[4] = {0,0,1,-1};\n\nconst int gdx[10] = {\n  0,\n  0,0,0,\n  -1,0,1,\n  0,0,0\n};\n\nconst int gdy[10] = {\n  0,\n  0,1,0,\n  0,0,0,\n  0,-1,0\n};\n\nint main(){\n  int h,w;\n  while(scanf(\"%d%d \",&h,&w), h+w){\n    char buff[h][w+3];\n    int dist[h][w];\n    int mx,my,gx,gy;\n\n    REP(i,h) fgets(buff[i],sizeof(buff[i]),stdin);\n    REP(i,h){\n      REP(j,w){\n        dist[i][j] = -1;\n        if(buff[i][j] == 'A'){\n          mx = j; my = i;\n          buff[i][j] = '.';\n        }else if(buff[i][j] == 'B'){\n          gx = j; gy = i;\n          buff[i][j] = '.';\n        }\n      }\n    }\n\n    queue<pair<int,int> > q;\n    q.push(mp(mx,my)); dist[mx][my]=0;\n    int last = 0;\n    while(!q.empty()){\n      int x = q.front().f;\n      int y = q.front().s;\n      q.pop();\n\n      REP(i,4){\n        int xx = x + dx[i];\n        int yy = y + dy[i];\n        if(xx < 0 || yy < 0) continue;\n        if(xx >=w || yy >=h) continue;\n        if(buff[yy][xx] == '#') continue;\n        if(dist[yy][xx] != -1) continue;\n        last = dist[yy][xx] = dist[y][x] + 1;\n        q.push(mp(xx,yy));\n      }\n    }\n\n    //REP(i,h){ REP(j,w) printf(\"  %c\",buff[i][j]); puts(\"\");}\n    //REP(i,h){ REP(j,w) printf(\"%3d\",dist[i][j]); puts(\"\");}\n\n    char pat[20];\n    fgets(pat,sizeof(pat),stdin);\n    int plen = strlen(pat);\n    if(pat[plen-1] == '\\n') plen--;\n    bool flag[h][w][plen]; memset(flag, 0, sizeof(flag));\n    int turn = 0;\n    while(true){\n      int pp = pat[turn % plen] - '0'; turn++;\n      int xx = gx + gdx[pp];\n      int yy = gy + gdy[pp];\n\n      if(xx < 0 || yy < 0 || xx >=w || yy >=h){\n        xx = gx; yy = gy;\n      }\n\n      //printf(\"goast: (%d,%d) pp=%d\\n\",xx,yy,pp);\n\n      if(dist[yy][xx] != -1 && dist[yy][xx] <= turn){\n        printf(\"%d %d %d\\n\",turn,yy,xx);\n        break;\n      }\n\n      if(flag[yy][xx][turn % plen]){\n        puts(\"impossible\");\n        break;\n      }\n\n      if(turn >= last)\n        flag[yy][xx][turn % plen] = true;\n\n      gx = xx; gy = yy;\n    }\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[ax][ay] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 1000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class t>\nusing table = vector<vector<t>>;\nconst ld eps = 1e-9;\n\n//// < \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\a.txt\" > \"d:\\d_download\\visual studio 2015\\projects\\programing_contest_c++\\debug\\b.txt\"\n  \n\nconst int dx[] = { -1,0,1,0,0 };\nconst int dy[] = { 0,1,0,-1,0 };\n\nint memo[22][22][22][22][10];\n\nstruct aa{\n\tint mx;\n\tint my;\n\tint gx;\n\tint gy;\n\tint num;\n\tint time;\n};\n\nclass Compare {\npublic:\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\t//aa?????????????????¶\n\n\npair<int, int>amove(const vector<vector<int>>&field, const int nx, const int ny,const int move,bool gh) {\n\n\tconst int nexty = ny +dy[move];\n\tconst int nextx =nx + dx[move];\n\tif (gh) {\n\n\t\tif (field[nexty][nextx]!=2)return make_pair(nextx, nexty);\n\t\telse return make_pair(nx, ny);\n\t}\n\telse {\n\n\t\tif (!field[nexty][nextx])return make_pair(nextx, nexty);\n\t\telse return make_pair(nx, ny);\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tint H, W; cin >> H >> W;\n\t\tif (!H)break;\n\t\tfor (int i = 0; i < 22; ++i) {\n\t\t\tfor (int j = 0; j < 22; ++j) {\n\t\t\t\tfor (int k = 0; k < 22; ++k) {\n\t\t\t\t\tfor (int l = 0; l < 22; ++l) {\n\t\t\t\t\t\tfor (int m = 0; m < 10; ++m) {\n\t\t\t\t\t\t\tmemo[i][j][k][l][m] = 1e8;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint mx, my, gx, gy;\n\t\tvector<vector<int>>field(H + 2, vector<int>(W + 2,2));\n\t\tfor (int i = 0; i < H; ++i) {\n\t\t\tstring st; cin >> st;\n\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\tif (st[j] == 'A') {\n\t\t\t\t\tmx = j + 1; my = i + 1;\n\t\t\t\t\tfield[i+1][j+1] = false;\n\t\t\t\t}\n\t\t\t\telse if (st[j] == 'B') {\n\t\t\t\t\tgx = j + 1; gy = i + 1;\n\t\t\t\t\tfield[i + 1][j + 1] = false;\n\n\t\t\t\t}\n\t\t\t\telse if (st[j] == '#') {\n\t\t\t\t\tfield[i + 1][j + 1] =true;\n\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfield[i + 1][j + 1] = false;\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tstring pattern; cin >> pattern;\n\t\tvector<int>moves(pattern.size());\n\t\tfor (int i = 0; i < pattern.size(); ++i) {\n\t\t\tif (pattern[i] == '8')moves[i] = 3;\n\t\t\telse if (pattern[i] == '6')moves[i] = 2;\n\t\t\telse if (pattern[i] == '4')moves[i] = 0;\n\t\t\telse if (pattern[i] == '2')moves[i] = 1;\n\t\t\telse moves[i] = 4;\n\t\t}\n\t\tmemo[mx][my][gx][gy][0] = 0;\n\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\tque.push(aa{ mx,my,gx,gy,0,0 });\n\t\tint ans = -1;\n\t\tint ansx, ansy;\n\t\twhile (!que.empty()) {\n\t\t\taa atop(que.top());\n\t\t\tque.pop();\n\t\t\tif (atop.gx == atop.mx&&atop.gy == atop.my) {\n\t\t\t\tans = atop.time;\n\t\t\t\tansx = atop.gx;\n\t\t\t\tansy = atop.gy;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tauto gp(amove(field, atop.gx, atop.gy, moves[atop.num],true));\n\t\t\tconst int nextgx = gp.first;\n\t\t\tconst int nextgy = gp.second;\n\t\t\tconst int nextnum = (atop.num + 1) % moves.size();\n\t\t\tfor (int way = 0; way < 5; ++way) {\n\t\t\t\tauto amp(amove(field, atop.mx, atop.my, way,false));\n\n\t\t\t\tconst int nextmx = amp.first;\n\t\t\t\tconst int nextmy = amp.second;\n\t\t\t\tif (memo[nextmx][nextmy][nextgx][nextgy][nextnum]>atop.time + 1) {\n\t\t\t\t\tmemo[nextmx][nextmy][nextgx][nextgy][nextnum] = atop.time + 1;\n\t\t\t\t\tque.push(aa{ nextmx,nextmy,nextgx,nextgy,nextnum,atop.time + 1 });\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (ans == -1)cout << \"impossible\" << endl;\n\t\telse {\n\t\t\tcout << ans<<\" \"<<ansy-1<<\" \"<<ansx -1<< endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << P.first << \" \" << P.second; }\n\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\n\nint n, m;\nchar fi[25][25];\nstring pat;\n\nint dist[25][25][25][25][11];\n\npair<int,pint> solve() {\n    pint s, t;\n    for (int i = 0; i < n; ++i) for (int j = 0; j < m; ++j) {\n        cin >> fi[i][j];\n        if (fi[i][j] == 'A') s = pint(i,j);\n        if (fi[i][j] == 'B') t = pint(i,j);\n    }\n    cin >> pat;\n    memset(dist, -1, sizeof(dist));\n    dist[s.first][s.second][t.first][t.second][0] = 0;\n    queue< pair<pair<pint,pint>,int> > que;\n    que.push( MP(MP(s,t),0) );\n    while (!que.empty()) {\n        pint girl = que.front().first.first;\n        pint goast = que.front().first.second;\n        int p = que.front().second;\n        //cout << girl << \", \" << goast << \" : \" << dist[girl.first][girl.second][goast.first][goast.second] << endl;\n        que.pop();\n        if (girl == goast) { \n            return MP(dist[girl.first][girl.second][goast.first][goast.second][p], girl); \n        }\n        \n        pint ngoast = goast;\n        char c = pat[p];\n        if (c == '8') ngoast = pint(goast.first-1, goast.second);\n        if (c == '6') ngoast = pint(goast.first, goast.second+1);\n        if (c == '4') ngoast = pint(goast.first, goast.second-1);\n        if (c == '2') ngoast = pint(goast.first+1, goast.second);\n        if (ngoast.first < 0 || ngoast.first >= n || ngoast.second < 0 || ngoast.second >= m) ngoast = goast;\n        int np = (p+1)%pat.size();\n        \n        for (int i = 0; i < 5; ++i) {\n            pint ngirl = girl;\n            if (i < 4) ngirl = pint( girl.first + dx[i], girl.second + dy[i] );\n            if (ngirl.first < 0 || ngirl.first >= n || ngirl.second < 0 || ngirl.second >= m) continue;\n            if (fi[ngirl.first][ngirl.second] == '#') continue;\n            if ( dist[ngirl.first][ngirl.second][ngoast.first][ngoast.second][np] == -1 ) {\n                dist[ngirl.first][ngirl.second][ngoast.first][ngoast.second][np] \n                = dist[girl.first][girl.second][goast.first][goast.second][p] + 1;\n                que.push( MP(MP(ngirl, ngoast),np) );\n            }\n        }\n    }\n    return MP(-1,pint(-1,-1));\n}\n\nint main() {\n    while (cin >> n >> m) {\n        if (n == 0) break;\n        pair<int,pint> res = solve();\n        if (res.first == -1) puts(\"impossible\");\n        else cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nint main(){\n\tstd::queue<int>q;\n\tint w,h,f[484],i,j,d[]={22,0,-1,0,1,0,-22},a,b,t,x,z;\n\tchar p[15];\n\tfor(;scanf(\"%d%d \",&h,&w),h;){\n\t\tfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tf[x=i*22+j]=-1;\n\t\t\t\tswitch(getchar()){\n\t\t\t\t\tcase'#':--f[x];break;\n\t\t\t\t\tcase'A':a=x;break;\n\t\t\t\t\tcase'B':b=x;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i*22]=f[i*22-~w]=-9;\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tf[a]=t=0;\n\t\tq.push(0);\n\t\tfor(q.push(a);q.size()>1;){\n\t\t\ta=q.front();\n\t\t\tq.pop();\n\t\t\tif(a){\n\t\t\t\tfor(i=0;i<7;i+=2)\n\t\t\t\t\tif(f[x=a+d[i]]==-1)\n\t\t\t\t\t\tf[x]=t,q.push(x);}\n\t\t\telse\n\t\t\t\t++t,q.push(0);\n\t\t}\n\t\tq.pop();\n\t\tscanf(\"%s\",p);\n\t\tfor(a=t=0;!a;){\n\t\t\tx=b;\n\t\t\tz=0;\n\t\t\tfor(i=0;!a&&p[i];i++){\n\t\t\t\tt++;\n\t\t\t\tf[j=b+d[p[i]-'2']]>-3?b=j:0;\n\t\t\t\tf[b]>=0&&t>=f[b]?a=b:0;\n\t\t\t\tf[b]>=0&&++z;\n\t\t\t}\n\t\t\t!z&!a&!p[i]&b==x&f[b]<0&&--a;\n\t\t}\n\t\tprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int dx[] = {-1, 0, 1, 0, 0};\nconst int dy[] = {0, -1, 0, 1, 0};\n\nstruct STATE { int ax, ay, bx, by, d; };\n\nchar grid[32][32];\nbool done[32][32][32][32][16];\n\nint main()\n{\n\tint h, w;\n\twhile (scanf(\"%d %d\", &h, &w), h + w){\n\t\tmemset(grid, '*', sizeof(grid));\n\t\tmemset(done, false, sizeof(done));\n\t\tSTATE s = {0, 0, 0, 0, 0};\n\t\t\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tscanf(\" %c\", &grid[i][j]);\n\t\t\t\tif (grid[i][j] == 'A'){\n\t\t\t\t\ts.ax = i;\n\t\t\t\t\ts.ay = j;\n\t\t\t\t\tgrid[i][j] = '.';\n\t\t\t\t}\n\t\t\t\telse if (grid[i][j] == 'B'){\n\t\t\t\t\ts.bx = i;\n\t\t\t\t\ts.by = j;\n\t\t\t\t\tgrid[i][j] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t/*\n\t\tfor (int i = 1; i <= h; i++){\n\t\t\tfor (int j = 1; j <= w; j++){\n\t\t\t\tprintf(\"%c\", grid[i][j]);\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t\t*/\n\t\t\n\t\tstring pa;\n\t\tcin >> pa;\n\t\tfor (int i = 0; i < pa.size(); i++){\n\t\t\tif (pa[i] == '5') pa[i] = 4;\n\t\t\telse if (pa[i] == '8') pa[i] = 0;\n\t\t\telse if (pa[i] == '6') pa[i] = 3;\n\t\t\telse if (pa[i] == '4') pa[i] = 1;\n\t\t\telse if (pa[i] == '2') pa[i] = 2;\n\t\t}\n\t\t\n\t\tSTATE res = {0, 0, 0, 0, -1};\n\t\tqueue<STATE> que;\n\t\tfor (que.push(s); que.size(); que.pop()){\n\t\t\tSTATE st = que.front();\n\t\t\t\n\t\t\t//printf(\"%d %d %d %d\\n\", st.ax, st.ay, st.bx, st.by);\n\t\t\t\n\t\t\tif (done[st.ax][st.ay][st.bx][st.by][st.d % pa.size()]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tdone[st.ax][st.ay][st.bx][st.by][st.d % pa.size()] = true;\n\t\t\tif (st.ax == st.bx && st.ay == st.by){\n\t\t\t\tres = st;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tint tbx = st.bx + dx[pa[st.d % pa.size()]];\n\t\t\tint tby = st.by + dy[pa[st.d % pa.size()]];\n\t\t\tif (grid[tbx][tby] == '*'){\n\t\t\t\ttbx = st.bx;\n\t\t\t\ttby = st.by;\n\t\t\t}\n\t\t\tfor (int dir = 0; dir < 5; dir++){\n\t\t\t\tint tax = st.ax + dx[dir];\n\t\t\t\tint tay = st.ay + dy[dir];\n\t\t\t\tif (grid[tax][tay] != '.') continue;\n\t\t\t\tque.push({tax, tay, tbx, tby, st.d + 1});\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (res.d == -1) cout << \"impossible\" << endl;\n\t\telse cout << res.d << \" \" << res.ax - 1 << \" \" << res.ay - 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#import<stdio.h>\n#import<queue.h>\nint main(){\n\tqueue<int> q;\n\tint w,h,f[484],i,j,d[]={22,0,-1,0,1,0,-22},a,b,t,x,z;\n\tchar p[15];\n\tfor(;scanf(\"%d%d \",&h,&w),h;){\n\t\tfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tf[x=i*22+j]=-1;\n\t\t\t\tswitch(getchar()){\n\t\t\t\t\tcase'#':--f[x];break;\n\t\t\t\t\tcase'A':a=x;break;\n\t\t\t\t\tcase'B':b=x;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i*22]=f[i*22-~w]=-9;\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tf[a]=t=0;\n\t\tq.push(0);\n\t\tfor(q.push(a);q.size()>1;){\n\t\t\ta=q.front();\n\t\t\tq.pop();\n\t\t\tif(a){\n\t\t\t\tfor(i=0;i<7;i+=2)\n\t\t\t\t\tif(f[x=a+d[i]]==-1)\n\t\t\t\t\t\tf[x]=t,\n\t\t\t\t\t\tq.push(x);\n\t\t\t\t\telse\n\t\t\t\t\t\t++t,q.push(0);\n\t\t\t}\n\t\t}\n\t\tq.pop();\n\t\tscanf(\"%s\",p);\n\t\tfor(a=t=0;!a;){\n\t\t\tx=b;\n\t\t\tz=0;\n\t\t\tfor(i=0;!a&&p[i];i++){\n\t\t\t\tt++;\n\t\t\t\tf[j=b+d[p[i]-'2']]>-3?b=j:0;\n\t\t\t\tf[b]>=0&&t>=f[b]?a=b:0;\n\t\t\t\tf[b]>=0&&++z;\n\t\t\t}\n\t\t\t!z&!a&!p[i]&b==x&f[b]<0&&--a;\n\t\t}\n\t\tprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, x, y;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')x = i, y = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[ax][ay] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint t = 0;\n\t\trep(i, 100) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nstruct node{\n    int y,x,t,cost;\n    node(int y,int x,int t,int cost):y(y),x(x),t(t),cost(cost){}\n    bool operator<(const node& other)const{\n        return cost>other.cost;\n    }\n};\n\nconst int MAX=INT_MAX/10;\ntypedef vector<vvi> vvvi;\nint dx[]={-1,0,1,0,0},dy[]={0,-1,0,1,0};\n\nint main(){\n    int n,m;\n    while(cin>>n>>m,n){\n        vvi field(n,vi(m));\n\t\tpii girl,ghost;\n        REP(i,n){\n\t\t\tstring s;\n\t\t\tcin>>s;\n\t\t\tREP(j,s.size()){\n\t\t\t\tswitch(s[j]){\n\t\t\t\tcase 'A':\n\t\t\t\t\tgirl=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B':\n\t\t\t\t\tghost=make_pair(i,j);\n\t\t\t\t\tbreak;\n\t\t\t\tcase '.':\n\t\t\t\t\tfield[i][j]=0;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '#':\n\t\t\t\t\tfield[i][j]=1;\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tassert(0);\n\t\t\t\t}\n\t\t\t}\n        }\n\t\tstring pattern;\n\t\tcin>>pattern;\n\t\tint len=pattern.size()*50;\n\n\t\tvector<pii> glocs;\n\t\tREP(i,len){\n\t\t\tglocs.push_back(ghost);\n\t\t\tswitch(pattern[i%pattern.size()]){\n\t\t\tcase '2':\n\t\t\t\tif(ghost.first<n-1)ghost.first++;break;\n\t\t\tcase '4':\n\t\t\t\tif(ghost.second>0)ghost.second--;break;\n\t\t\tcase '8':\n\t\t\t\tif(ghost.first>0)ghost.first--;break;\n\t\t\tcase '6':\n\t\t\t\tif(ghost.second<m-1)ghost.second++;break;\n\t\t\tcase '5':\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tassert(0);\n\t\t\t}\n\t\t}\n        \n        priority_queue<node> q;\n\t\tq.push(node(girl.first,girl.second,0,0));\n        vvvi cost(n,vvi(m,vi(len,MAX)));\n\t\tcost[girl.first][girl.second][0]=0;\n        while(!q.empty()){\n            node cnode=q.top();q.pop();\n            if(cost[cnode.y][cnode.x][cnode.t]<cnode.cost){\n                continue;\n            }\n\t\t\tREP(i,5){\n\t\t\t\tint x=cnode.x+dx[i];\n\t\t\t\tint y=cnode.y+dy[i];\n\t\t\t\tif(x>=0&&y>=0&&x<m&&y<n&&field[y][x]==0){\n\t\t\t\t\tint newcost=cnode.cost+1;\n\t\t\t\t\tint t=cnode.t+1;\n\t\t\t\t\tif(t<len&&cost[y][x][t]>newcost){\n\t\t\t\t\t\tcost[y][x][t]=newcost;\n\t\t\t\t\t\tq.push(node(y,x,t,newcost));\n\t\t\t\t\t}\n\t\t\t\t}\n            }\n        }\n\t\tint ans=MAX;\n\t\tpii ansloc;\n\t\tREP(i,len){\n\t\t\tint c=cost[glocs[i].first][glocs[i].second][i];\n\t\t\tif(c<ans){\n\t\t\t\tans=c;\n\t\t\t\tansloc=glocs[i];\n\t\t\t}\n\t\t}\n\t\tif(ans==MAX){\n\t\t\tcout<<\"impossible\"<<endl;\n\t\t}else{\n\t\t\tcout<<ans<<\" \"<<ansloc.first<<\" \"<<ansloc.second<<endl;\n\t\t}\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <list>\n#include <string.h>\n#include <set>\n\nusing namespace std;\n\n//#define DEBUG\n\ntypedef struct {\n\tint px, py;\n\tint gx, gy;\n\tint move_index;\n\tint depth;\n} DATA;\n\n\nchar map[20 + 2][20 + 2];\nchar move_inst[11];\nset<unsigned> lstHash;\nlist<DATA> lstSarch;\n\nunsigned calc_hash(const DATA& data)\n{\n\tunsigned hash;\n\t\n\thash = data.px | (data.py << 5) | (data.gx << 10) | (data.gy << 15) | (data.move_index << 20);\n\t\n\treturn (hash);\n}\n\nbool is_add(const DATA& data)\n{\n\tunsigned hash;\n\t\n\thash = calc_hash(data);\n\tif (map[data.px][data.py] == -1 || map[data.px][data.py] == '#' || lstHash.find(hash) != lstHash.end()){\n\t\treturn (false);\n\t}\n\t\n\treturn (true);\n}\n\nint width_priority_sarch(const DATA& data)\n{\n\tDATA add;\n\t\n\tadd.depth = data.depth + 1;\n\tadd.move_index = (data.move_index + 1) % strlen(move_inst);\n\t\n\tadd.gx = data.gx;\n\tadd.gy = data.gy;\n\tswitch (move_inst[data.move_index]){\n\t  case '8': add.gy--; break;\n\t  case '4': add.gx--; break;\n\t  case '6': add.gx++; break;\n\t  case '2': add.gy++; break;\n\t  default :           break;\n\t}\n\t\n\tif (map[add.gx][add.gy] == -1){\n\t\tadd.gx = data.gx;\n\t\tadd.gy = data.gy;\n\t}\n\t\n\tadd.px = data.px;\n\tadd.py = data.py;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.insert(calc_hash(add));\n\t}\n#ifdef DEBUG\n\tprintf(\"%d %d\\n\", add.move_index, data.move_index);\n\tprintf(\"%u %u\\n\", calc_hash(add), calc_hash(data));\n#endif\n\t\n\tadd.px++;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.insert(calc_hash(add));\n\t}\n\tadd.px = data.px;\n\tadd.px--;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.insert(calc_hash(add));\n\t}\n\tadd.px = data.px;\n\tadd.py++;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.insert(calc_hash(add));\n\t}\n\tadd.py = data.py;\n\tadd.py--;\n\tif (is_add(add) == true){\n\t\tlstSarch.push_back(add);\n\t\tlstHash.insert(calc_hash(add));\n\t}\n\t\n\treturn (0);\n}\n\nbool is_end(DATA& data)\n{\n\tif (data.px == data.gx && data.py == data.gy){\n\t\treturn (true);\n\t}\n\treturn (false);\n}\n\nint main(void)\n{\n\tDATA start;\n\tint hight, with;\n\t\n\twhile (1){\n\t\tlstHash.clear();\n\t\tlstSarch.clear();\n\t\t\n\t\tscanf(\"%d%d\", &hight, &with);\n\t\t\n\t\tif (hight == 0 || with == 0){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < 22; i++){\n\t\t\tfor (int j = 0; j < 22; j++){\n\t\t\t\tmap[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tfor (int y = 0; y < hight; y++){\n\t\t\tchar str[21];\n\t\t\tscanf(\"%s\", str);\n\t\t\tfor (int x = 0; x < with; x++){\n\t\t\t\tmap[x + 1][y + 1] = str[x];\n\t\t\t\tif (map[x + 1][y + 1] == 'A'){\n\t\t\t\t\tstart.px = x + 1;\n\t\t\t\t\tstart.py = y + 1;\n\t\t\t\t\tmap[x + 1][y + 1] = '.';\n\t\t\t\t}\n\t\t\t\tif (map[x + 1][y + 1] == 'B'){\n\t\t\t\t\tstart.gx = x + 1;\n\t\t\t\t\tstart.gy = y + 1;\n\t\t\t\t\tmap[x + 1][y + 1] = '.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\", move_inst);\n\t\tstart.move_index = 0;\n\t\tstart.depth = 0;\n\t\t\n\t\tlstHash.insert(calc_hash(start));\n\t\tlstSarch.push_back(start);\n\t\t\n\t\twhile (lstSarch.empty() == false && is_end(lstSarch.front()) == false){\n#ifdef DEBUG\n\t\t\tprintf(\"%d %d %d %d %d %d\\n\", lstSarch.front().px, lstSarch.front().py, lstSarch.front().gx, lstSarch.front().gy, lstSarch.front().depth, lstSarch.front().move_index);\n#endif\n\t\t\twidth_priority_sarch(lstSarch.front());\n\t\t\tlstSarch.pop_front();\n\t\t}\n\t\t\n\t\tif (lstSarch.empty() == true){\n\t\t\tputs(\"impossible\");\n\t\t}\n\t\telse {\n\t\t\tprintf(\"%d %d %d\\n\", lstSarch.front().depth, lstSarch.front().py - 1, lstSarch.front().px - 1);\n\t\t}\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {0, 0, 1, 0, -1};\n\nclass State\n{\npublic:\n  int sx, sy, gx, gy, time;\n  State(int _sx, int _sy, int _gx, int _gy, int _time)\n    :sx(_sx), sy(_sy), gx(_gx), gy(_gy), time(_time) {}\n};\n\nint main()\n{\n  int H, W;\n  while (cin >> H >> W) {\n    if ((H|W) == 0)\n      break;\n\n    vector<string> city(H);\n    int sx, sy, gx, gy;\n    for (int i = 0; i < H; ++i) {\n      cin >> city[i];\n\n      if (city[i].find_first_of(\"A\") != string::npos) {\n\tsy = i;\n\tsx = city[i].find_first_of(\"A\");\n\tcity[sy][sx] = '.';\n      }\n      if (city[i].find_first_of(\"B\") != string::npos) {\n\tgy = i;\n\tgx = city[i].find_first_of(\"B\");\n\tcity[gy][gx] = '.';\n      }\n    }\n\n    string pattern;\n    cin >> pattern;\n    for (int i = 0; i < pattern.size(); ++i) {\n      if (pattern[i] == '5')\n\tpattern[i] = '0';\n      else if (pattern[i] == '8')\n\tpattern[i] = '4';\n      else if (pattern[i] == '6')\n\tpattern[i] = '1';\n      else if (pattern[i] == '4')\n\tpattern[i] = '3';\n      else\n\tpattern[i] = '2';\n    }\n\n    bool found = false;\n    queue<State> que;\n    que.push(State(sx, sy, gx, gy, 0));\n    vector<vector<vector<vector<vector<int> > > > > dp(H, vector<vector<vector<vector<int> > > >(W, vector<vector<vector<int> > >(H, vector<vector<int > >(W, vector<int>(pattern.size(), INF)))));\n    while (!que.empty()) {\n      const State st = que.front();\n      que.pop();\n\n      if(st.sx == st.gx && st.sy == st.gy) {\n\tcout << st.time << \" \" << st.sy << \" \" << st.sx << endl;\n\tfound = true;\n\tbreak;\n      }\n\n      if (dp[st.sy][st.sx][st.gy][st.gx][st.time%pattern.size()] < st.time)\n\tcontinue;\n      dp[st.sy][st.sx][st.gy][st.gx][st.time%pattern.size()] = st.time;\n\n      for (int d = 0; d < 5; ++d) {\n\tsx = st.sx + dx[d];\n\tsy = st.sy + dy[d];\n\tgx = st.gx + dx[pattern[st.time%pattern.size()]-'0'];\n\tgy = st.gy + dy[pattern[st.time%pattern.size()]-'0'];\n\n\tif (sx < 0 || W <= sx || sy < 0 || H <= sy || city[sy][sx] == '#')\n\t  continue;\n\n\tif (gx < 0 || W <= gx)\n\t  gx = st.gx;\n\tif (gy < 0 || H <= gy)\n\t  gy = st.gy;\n\n\tif (dp[sy][sx][gy][gx][(st.time+1)%pattern.size()] > st.time+1)\n\t  que.push(State(sx, sy, gx, gy, st.time+1));\n      }\n\n    }\n\n    if (!found)\n      cout << \"impossible\" << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <set>\nusing namespace std;\n\nclass Node{\npublic:\n  int ax;\n  int ay;\n  int bx;\n  int by;\n  int p;\n\n  int cost;\n  Node(int ax, int ay, int bx, int by, int p, int cost)\n    : ax(ax), ay(ay), bx(bx), by(by), p(p), cost(cost) { }\n  bool operator <(const Node &N) const{\n    if(ax != N.ax) return ax < N.ax;\n    if(ay != N.ay) return ay < N.ay;\n    if(bx != N.bx) return bx < N.bx;\n    if(by != N.by) return by < N.by;\n    if(p != N.p) return p < N.p;\n    return false;\n  }\n};\n\nint main() {\n  while(1) {\n    int H, W;\n    cin >> H >> W;\n    if(H == 0 && W == 0) break;\n    char data[H][W];\n    Node N(0,0,0,0,0,0);\n    for(int i = 0; i < H; i++) {\n      for(int j = 0; j < W; j++) {\n\tcin >> data[i][j];\n\tif(data[i][j] == 'A') {\n\t  N.ax = j;\n\t  N.ay = i;\n\t  data[i][j] = '.';\n\t}\n\tif(data[i][j] == 'B') {\n\t  N.bx = j;\n\t  N.by = i;\n\t  data[i][j] = '.';\n\t}\n      }\n    }\n\n    string pat;\n    cin >> pat;\n\n    queue<Node> Q;\n    Q.push(N);\n    set<Node> visited;\n    visited.insert(N);\n    int d[5][2] = {{0,0},{0,-1},{1,0},{-1,0},{0,1}};\n\n    int ansX, ansY, ansCost;\n    ansX = ansY = ansCost = -1;\n\n    while(!Q.empty()) {\n      N = Q.front();\n      Q.pop();\n\n      if(N.ax == N.bx && N.ay == N.by) {\n\tansX = N.ax;\n\tansY = N.ay;\n\tansCost = N.cost;\n\tbreak;\n      }\n\n      Node newN(0,0,0,0, (N.p+1)%pat.length(), N.cost + 1);\n\n      int bd = -1;\n\n      switch(pat[N.p]) {\n      case '5':bd = 0; break;\n      case '8':bd = 1; break;\n      case '6':bd = 2; break;\n      case '4':bd = 3; break;\n      case '2':bd = 4; break;\n      }\n\n      newN.bx = N.bx + d[bd][0];\n      newN.by = N.by + d[bd][1];\n      if(newN.bx < 0 || newN.bx >= W) newN.bx = N.bx;\n      if(newN.by < 0 || newN.by >= H) newN.by = N.by;\n\n      for(int i = 0; i < 5; i++) {\n\tnewN.ax = N.ax + d[i][0];\n\tnewN.ay = N.ay + d[i][1];\n\tif(newN.ax < 0 || newN.ax >= W) newN.ax = N.ax;\n\tif(newN.ay < 0 || newN.ay >= H) newN.ay = N.ay;\n\tif(data[newN.ay][newN.ax] == '#') {\n\t  newN.ax = N.ax;\n\t  newN.ay = N.ay;\n\t}\n\tif(visited.find(newN) != visited.end()) continue;\n\tvisited.insert(newN);\n\tQ.push(newN);\n      }\n    }\n    if(ansX != -1 && ansY != -1 && ansCost != -1) {\n      cout << ansCost << \" \" << ansY << \" \" << ansX << endl;\n    } else {\n      cout << \"impossible\" << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MP make_pair\n#define PB push_back\n#define F first\n#define S second\n#define AY second.first.first\n#define AX second.first.second\n#define BY second.second.first\n#define BX second.second.second\n#define INF 1 << 30\n#define EPS 1e-10\n\ntypedef pair<int, int> P;\ntypedef pair<int, P> pii;\ntypedef pair<P, P>pipi;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nint dy[] = {0, -1,0,1,0}, dx[] = {0, 0,-1,0,1};\nint gdy[] = {0, 0, 1, 0, 0, 0, 0, 0, -1}, gdx[] = {0, 0, 0, 0, -1, 0, 1, 0, 0};\nint H, W;\nchar field[32][32], pattern[16];\n\nP nexta(int y, int x, int d){\n  int ny = y+dy[d], nx = x+dx[d];\n  ny = max(0, min(H-1, ny));\n  nx = max(0, min(W-1, nx));\n  if(field[ny][nx] == '#'){\n    ny = y;\n    nx = x;\n  }\n  return MP(ny, nx);\n}\n\nP nextb(int y, int x, int c){\n  int L = strlen(pattern);\n  int ny = y+gdy[pattern[c%L]-'0'], nx = x+gdx[pattern[c%L]-'0'];\n  ny = max(0, min(H-1, ny));\n  nx = max(0, min(W-1, nx));\n  return MP(ny, nx);\n}\n\nint main(){\n  while(scanf(\"%d%d\", &H, &W) && H+W){\n    rep(i, H) scanf(\"%s\", field[i]);\n    scanf(\"%s\", pattern);\n    int ay, ax, by, bx;\n    rep(i, H) rep(j, W){\n      if(field[i][j] == 'A'){ ay = i; ax = j;}\n      else if(field[i][j] == 'B'){ by = i; bx = j;}\n    }\n\n    queue<pair<int, pipi> >q;\n    map<pair<pipi, int>, int>m;\n    q.push(MP(0, MP(MP(ay, ax), MP( by, bx))));\n    m[MP(MP(MP(ay, ax), MP(by, bx)), -1)] = 1;\n\n    while(!q.empty()){\n      pair<int, pipi> now = q.front(); q.pop();\n      if(now.AY == now.BY && now.AX == now.BX){\n\tprintf(\"%d %d %d\\n\", now.F, now.AY, now.AX);\n\tgoto e;\n      }\n      //      printf(\"%d %d %d %d %d\\n\", now.F, now.AY, now.AX, now.BY, now.BX);\n      rep(d, 5){\n\tP na = nexta(now.AY, now.AX, d);\n\tP nb = nextb(now.BY, now.BX, now.F);\n\t//\tint any = now.AY+dy[d], anx = now.AX+dx[d];\n\t//\tint bny = now.BY+gdy[pattern[(now.F%strlen(pattern))]-'0'], bnx = now.BX+gdx[pattern[(now.F%strlen(pattern))]-'0'];\n\t//\tprintf(\"%d %d %d %d\\n\", any, anx, bny, bnx);\n\t//\tif(any < 0 || any >= H || anx < 0 || anx >= W || bny < 0 || bny >= H || bnx < 0 || bnx >= W ||\n\t//\t   field[any][anx] == '#' || m.count(MP(MP(any, anx), MP(bny, bnx)))) continue;\n\tif(m.count(MP(MP(na, nb), (now.F%strlen(pattern))))) continue;\n\n\tm[MP(MP(na, nb), now.F%strlen(pattern))] = 1;\n\tq.push(MP(now.F+1, MP(na, nb)));\n      }\n    }\n    puts(\"impossible\");\n  e:;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nint main(){\n\tstd::queue<int> q;\n\tint w,h,f[484],i,j,d[]={22,0,-1,0,1,0,-22},a,b,t,x,z;\n\tchar p[15];\n\tfor(;scanf(\"%d%d \",&h,&w),h;){\n\t\tfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tf[x=i*22+j]=-1;\n\t\t\t\tswitch(getchar()){\n\t\t\t\t\tcase'#':--f[x];break;\n\t\t\t\t\tcase'A':a=x;break;\n\t\t\t\t\tcase'B':b=x;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i*22]=f[i*22-~w]=-9;\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tf[a]=t=0;\n\t\tq.push(0);\n\t\tfor(q.push(a);q.size()>1;){\n\t\t\ta=q.front();\n\t\t\tq.pop();\n\t\t\tif(a){\n\t\t\t\tfor(i=0;i<7;i+=2)\n\t\t\t\t\tif(f[x=a+d[i]]==-1)\n\t\t\t\t\t\tf[x]=t,\n\t\t\t\t\t\tq.push(x);\n\t\t\telse\n\t\t\t\t++t,q.push(0);\n\t\t}\n\t\tq.pop();\n\t\tscanf(\"%s\",p);\n\t\tfor(a=t=0;!a;){\n\t\t\tx=b;\n\t\t\tz=0;\n\t\t\tfor(i=0;!a&&p[i];i++){\n\t\t\t\tt++;\n\t\t\t\tf[j=b+d[p[i]-'2']]>-3?b=j:0;\n\t\t\t\tf[b]>=0&&t>=f[b]?a=b:0;\n\t\t\t\tf[b]>=0&&++z;\n\t\t\t}\n\t\t\t!z&!a&!p[i]&b==x&f[b]<0&&--a;\n\t\t}\n\t\tprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<queue>\n#include<algorithm>\n#define INF 99999999\nusing namespace std;\nqueue <int> qy,qx,qcnt;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nint n,m,x,y,cnt,nx,ny,mini,ansx,ansy;\nint t[20][20],sx,sy,tx,ty,vd[20][20];\nstring in;\nint main(){\n  while(cin>>n>>m&&n){\n    for(int i=0;i<n;i++){\n      cin>>in;\n      for(int j=0;j<(int)in.size();j++){\n\tif(in[j]=='A')sx=j,sy=i;\n\telse if(in[j]=='B')tx=j,ty=i;\n\tt[i][j]=(in[j]=='#');\n      }\n    }\n    \n    for(int i=0;i<20;i++)for(int j=0;j<20;j++)vd[i][j]=INF;\n    vd[sy][sx]=1;\n    qx.push(sx);\n    qy.push(sy);\n    qcnt.push(1);\n    while(!qx.empty()){\n      x=qx.front();qx.pop();\n      y=qy.front();qy.pop();\n      cnt=qcnt.front();qcnt.pop();\n      for(int i=0;i<4;i++){\n\tnx=x+dx[i];ny=y+dy[i];\n\tif(!(0<=nx&&nx<m&&0<=ny&&ny<n))continue;\n\tif(vd[ny][nx]!=INF||t[ny][nx]==1)continue;\n\tvd[ny][nx]=cnt+1;\n\tqx.push(nx);\n\tqy.push(ny);\n\tqcnt.push(cnt+1);\n      }\n    }\n    \n    cin>>in;\n    cnt=0;\n    mini=INF;\n\n    for(int I=0;I<n*m;I++){\n      for(int i=0;i<(int)in.size();i++){\n\tcnt++;\n\tif(cnt>=vd[ty][tx]){\n\t  if(mini>cnt){\n\t    mini=cnt;\n\t    ansy=ty;\n\t    ansx=tx;\n\t  }\n\t}\n\tif(in[i]=='5')continue;\n\telse if(in[i]=='8'){\n\t  if(ty==0)continue;\n\t  ty--;\n\t}else if(in[i]=='6'){\n\t  if(tx==m-1)continue;\n\t  tx++;\n\t}else if(in[i]=='4'){\n\t  if(tx==0)continue;\n\t  tx--;\n\t}else{\n\t  if(ty==n-1)continue;\n\t  ty++;\n\t}\n      }//for\n    }//while\n    if(mini==INF)cout<<\"impossible\"<<endl;\n    else cout<<mini-1<<' '<<ansy<<' '<<ansx<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[0][0] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 5000000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\nint dd[]={0,1,0,-1,0};\nbool check(int a,int b){\n\tif(0<=a&&a<h&&0<=b&&b<w) return true;\n\treturn false;\n}\nvoid bfs(pii p,int x,vector<string> &v,vvint &vv){\n\tif(vv[p.F][p.S]>=0) return;\n\tvv[p.F][p.S]=x;\n\trep(i,4){\n\t\tpii ne=pii(p.F+dd[i],p.S+dd[i+1]);\n\t\tif(!check(ne.F,ne.S)||v[ne.F][ne.S]=='#') continue;\n\t\tbfs(ne,x+1,v,vv);\n\t}\n}\nvoid mainmain(){\n\tvector<pii> vec(10);\n\tvec[2]=pii(1,0);\n\tvec[4]=pii(0,-1);\n\tvec[5]=pii(0,0);\n\tvec[6]=pii(0,1);\n\tvec[8]=pii(-1,0);\n\twhile(cin>>h>>w,h||w){\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tstring s;\n\t\tcin>>s;\n\t\tvvint vv;\n\t\tinitvv(vv,h,w,-1);\n\t\tpii A,B;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='A'){\n\t\t\t\t\tA=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t\tif(v[i][j]=='B'){\n\t\t\t\t\tB=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(A,0,v,vv);\n\t\tint ans=-1;\n\t\tpii pos;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\t// printf(\"%2d \",vv[i][j]);\n\t\t\t\tif(vv[i][j]==-1) vv[i][j]=INF;\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\trep(i,1e7){\n\t\t\t// cout<<i<<\" \"<<B.F<<\" \"<<B.S<<endl;\n\t\t\tif(vv[B.F][B.S]<=i){\n\t\t\t\tans=i;\n\t\t\t\tpos=B;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint t=s[i%s.size()]-'0';\n\t\t\tpii ne=pii(B.F+vec[t].F,B.S+vec[t].S);\n\t\t\tif(check(ne.F,ne.S)){\n\t\t\t\tB=ne;\n\t\t\t}\n\t\t}\n\t\tif(ans==-1){\n\t\t\tcout<<\"impossible\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<ans<<\" \"<<pos.F<<\" \"<<pos.S<<endl;\n\t\t}\n\t\t// return;\n\t}\n}\n\n\nsigned main() {\n\t// ios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n\nvector<string> data(20);\nint dist[20][20]={};\nbool visited[20][20];\nint h,w;\n\n\nvoid dfs(int y,int x){\n\tif( y<0 || y>=h || x<0 || x>=w || visited[y][x]==true || data[y][x]=='#' )return ;\n\n\tvisited[y][x]=true;\n\n\tint a = (y+1<h )?dist[y+1][x]:999999999;\n\tint b = (y-1>=0)?dist[y-1][x]:999999999;\n\tint c = (x+1<w )?dist[y][x+1]:999999999;\n\tint d = (x-1>=0)?dist[y][x-1]:999999999;\n\n\tdist[y][x]=min( dist[y][x] , min(min(a,b) , min(c,d))+1 );\n\n\tdfs(y+1,x);\n\tdfs(y-1,x);\n\tdfs(y,x+1);\n\tdfs(y,x-1);\n}\nint main(){\n\twhile(cin>>h>>w){\n\t\tif(h==0&&w==0)break;\n\t\tdata.clear();\n\t\trep(i,20)rep(j,20){dist[i][j]=999999999;visited[i][j]=false;}\n\t\tstring move;\n\n\t\trep(i,h) cin>>data[i];\n\t\tcin>>move;\t\t\n\n\t\tint sx,sy,gx,gy;\n\t\trep(i,h)rep(j,w){\n\t\t\tif(data[i][j]=='A'){ sy=i;sx=j; }\n\t\t\tif(data[i][j]=='B'){ gy=i;gx=j;data[i][j]='.'; }\n\t\t}\n\n\t\tdist[sy][sx]=0;\n\t\tdfs(sy,sx);\n\n\t\tfor(int i=0;;i++){\n\t\t\tif(dist[gy][gx]<=i){\n\t\t\t\tcout<<i<<\" \"<<gy<<\" \"<<gx<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(move[i%move.size()]=='5'){;\t\t\t\t\t}\n\t\t\tif(move[i%move.size()]=='8'){gy=max(0,gy-1);\t}\n\t\t\tif(move[i%move.size()]=='6'){gx=min(w-1,gx+1);\t}\n\t\t\tif(move[i%move.size()]=='4'){gx=max(0,gx-1);\t}\n\t\t\tif(move[i%move.size()]=='2'){gy=min(h-1,gy+1);\t}\n\t\t\tif(i==10000000){\n\t\t\t\tcout<<\"impossible\"<<endl;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t}\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string.h>\n#include <list>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef struct {\n\tint x, y;\n} Vector;\n\ntypedef struct {\n\tint x, y;\n\tint step;\n} DATA;\n\nunsigned int data[16 + 2][16 + 2];\nchar map[16 + 2][16 + 2];\n\nint change(char move[], Vector mv[])\n{\n\tint i = 0;\n\twhile (move[i] != '\\0'){\n\t\tmv[i].x = mv[i].y = 0;\n\t\tswitch (move[i]){\n\t\t  case '5':\n\t\t  \tbreak;\n\t\t  case '8':\n\t\t  \tmv[i].y = -1;\n\t\t\tbreak;\n\t\t  case '6':\n\t\t  \tmv[i].x = 1;\n\t\t\tbreak;\n\t\t  case '4':\n\t\t  \tmv[i].x = -1;\n\t\t\tbreak;\n\t\t  case '2':\n\t\t  \tmv[i].y = 1;\n\t\t\tbreak;\n\t\t}\n\t\ti++;\n\t}\n\treturn (i);\n}\n\nunsigned int move_sml(int gx, int gy, Vector mv[], int move_count, int* ans_x, int* ans_y)\n{\n\tunsigned int ret = 0xffffffff;\n\tfor (unsigned int i = 0; i < 1000000; i++){\n\t\tint mx = mv[i % move_count].x;\n\t\tint my = mv[i % move_count].y;\n\t\t\n\t\tif (data[gx][gy] <= i && ret > i){\n\t\t\tret = max(data[gx][gy], i);\n\t\t\t*ans_x = gx;\n\t\t\t*ans_y = gy;\n\t\t}\n\t\t\n\t\tif (map[gx + mx][gy + my] != -1){\n\t\t\tgx += mx;\n\t\t\tgy += my;\n\t\t}\n\t}\n\t\n\treturn (ret);\n}\n\nint move_short_root(int sx, int sy)\n{\n\tlist<DATA> lst;\n\tDATA add;\n\t\n\tdata[sx][sy] = 0;\n\t\n\tadd.x = sx + 1;\n\tadd.y = sy;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx - 1;\n\tadd.y = sy;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx;\n\tadd.y = sy + 1;\n\tadd.step = 1;\n\tlst.push_back(add);\n\tadd.x = sx;\n\tadd.y = sy - 1;\n\tadd.step = 1;\n\tlst.push_back(add);\n\t\n\twhile (!lst.empty()){\n\t\tif (map[lst.front().x][lst.front().y] != -1 && map[lst.front().x][lst.front().y] != '#' && data[lst.front().x][lst.front().y] > lst.front().step){\n\t\t\tdata[lst.front().x][lst.front().y] = lst.front().step;\n\t\t\tadd.x = lst.front().x + 1;\n\t\t\tadd.y = lst.front().y;\n\t\t\tadd.step = lst.front().step + 1;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x - 1;\n\t\t\tadd.y = lst.front().y;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x;\n\t\t\tadd.y = lst.front().y + 1;\n\t\t\tlst.push_back(add);\n\t\t\tadd.x = lst.front().x;\n\t\t\tadd.y = lst.front().y - 1;\n\t\t\tlst.push_back(add);\n\t\t}\n\t\tlst.pop_front();\n\t}\n\t\n\treturn (0);\n}\n\nint main(void)\n{\n\tint hight, width;\n\tint ans_x, ans_y;\n\tint sx, sy, gx, gy;\n\tchar move[11];\n\tVector mv[10];\n\tint move_count;\n\tunsigned int ans;\n\t\n\twhile (1){\n\t\tmemset(data, 0xff, (18 * 18) * sizeof(int));\n\t\tmemset(map, -1, (18 * 18));\n\t\tcin >> hight >> width;\n\t\tif (hight == 0 && width == 0)break;\n\t\tfor (int y = 0; y < hight + 2; y++){\n\t\t\tchar str[16 + 1];\n\t\t\tif (y == 0 || y == hight + 1){\n\t\t\t\tfor (int x = 0; x < width + 2; x++){\n\t\t\t\t\tmap[x][y] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tcin >> str;\n\t\t\t\tmap[0][y] = map[width + 1][y] = -1;\n\t\t\t\tfor (int x = 0; x < width; x++){\n\t\t\t\t\tif (str[x] == 'A'){\n\t\t\t\t\t\tsx = x + 1;\n\t\t\t\t\t\tsy = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (str[x] == 'B'){\n\t\t\t\t\t\tgx = x + 1;\n\t\t\t\t\t\tgy = y;\n\t\t\t\t\t}\n\t\t\t\t\tmap[x + 1][y] = str[x];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> move;\n\t\t\n\t\tmove_count = change(move, mv);\n\t\t\n\t\tmove_short_root(sx, sy);\n\t\t\n\t\tans = move_sml(gx, gy, mv, move_count, &ans_x, &ans_y);\n\t\t\n\t\tif (ans == 0xffffffff){\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t\telse {\n\t\t\tcout << ans << ' ' << ans_y - 1 << ' ' << ans_x - 1 << endl;\n\t\t}\n\t\t\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<climits>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<cmath>\n#include<string.h>\n\nusing namespace std;\n\nint h,w,sx,sy,gx,gy;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\n\nchar ma[21][21];\nint co[21][21];\nbool visited[21][21];\n\nint main(){\n    while(cin>>h>>w,h){\n        for(int i=0;i<h;i++){\n            for(int j=0;j<w;j++){\n                co[i][j]=INT_MAX;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A'){\n                    sx=j,sy=i;\n                } else if(ma[i][j]=='B'){\n                    gx=j,gy=i;\n                }\n            }\n        }\n        memset(visited, 0, sizeof(visited));\n        queue<pair<pair<int,int>,int> >q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pair<pair<int,int>,int> p = q.front();\n            visited[p.first.second][p.first.first]=1;\n            co[p.first.second][p.first.first]=p.second;\n           // cout<<p.first.second<<\"  \"<<p.first.first<<\"  \"<<p.second<<endl;\n            q.pop();\n            for(int i=0;i<4;i++){\n                int nx=p.first.first+dx[i];\n                int ny=p.first.second+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==INT_MAX&&ma[ny][nx]!='A'&&!visited[ny][nx]){\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n                }\n            }\n        }\n        string pat;\n        cin>>pat;\n        int go=0;\n        for(int j=0;;j++){\n            int i=j%pat.length();\n         //   cout<<gy<<\" \"<<gx<<\" \"<<co[gy][gx]<<\" \"<<INT_MAX<<endl;\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>INT_MAX/190){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='5'){\n                \n            } else if(pat[i]=='8'){\n                gy--;\n            } else if(pat[i]=='6'){\n                gx++;\n            } else if(pat[i]=='4'){\n                gx--;\n            } else if(pat[i]=='2'){\n                gy++;\n            }\n            gy=max(0,gy);\n            gy=min(h-1,gy);\n            gx=max(0,gx);\n            gx=min(w-1,gx);\n            go++;\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\n\n#define REP(i,n) for(ll i=0;i<n;i++)\n#define FOR(i,a,b) for(ll i=a;i<b;i++)\n\nconst int dx[4] = { 1, 0, -1, 0 };\nconst int dy[4] = { 0, 1, 0, -1 };\n\nint h, w, ax, ay, bx, by, ans;\nchar field[20][20];\nchar pattern[10];\n\nint main() {\n\n\twhile(true) {\n\n\t\tscanf(\"%d%d\", &h, &w);\n\n\t\tif (h == 0 && w == 0) break;\n\n\t\tREP(y,h) {\n\t\t\tscanf(\"%s\", field[y]);\n\t\t\tREP(x,w) {\n\t\t\t\tif (field[y][x] == 'A') {\n\t\t\t\t\tax = x;\n\t\t\t\t\tay = y;\n\t\t\t\t} else if (field[y][x] == 'B') {\n\t\t\t\t\tbx = x;\n\t\t\t\t\tby = y;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%s\", pattern);\n\n\t\tint leng = strlen(pattern);\n\n\t\tans = -1;\n\n\t\tqueue<pii> q, nq;\n\t\tq.push(pii(ax,ay));\n\n\t\tREP(i,h*w) {\n\n\t\t\t// girl\n\t\t\twhile(!q.empty()) {\n\t\t\t\tpii p = q.front();\n\t\t\t\tq.pop();\n\t\t\t\tREP(j,4) {\n\t\t\t\t\tint nx = p.first + dx[j];\n\t\t\t\t\tint ny = p.second + dy[j];\n\t\t\t\t\tif (0<=nx&&nx<w && 0<=ny&&ny<h && field[ny][nx]!='#') {\n\t\t\t\t\t\tfield[ny][nx] = 'A';\n\t\t\t\t\t\tnq.push(pii(nx,ny));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(!nq.empty()) {\n\t\t\t\tq.push(nq.front());\n\t\t\t\tnq.pop();\n\t\t\t}\n\n\t\t\t// ghost\n\t\t\tswitch(pattern[i%leng]) {\n\t\t\t\tcase '5':\n\t\t\t\t\tbreak;\n\t\t\t\tcase '8':\n\t\t\t\t\tby--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6':\n\t\t\t\t\tbx++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4':\n\t\t\t\t\tbx--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2':\n\t\t\t\t\tby++;\n\t\t\t\t\tbreak;\t\n\t\t\t}\n\n\t\t\tif (field[by][bx] == 'A') break;\n\t\t}\n\n\t\tif (ans < 0) {\n\t\t\tprintf(\"impossible\\n\");\n\t\t} else {\n\t\t\tprintf(\"%d\\n\", ans);\n\t\t}\n\n\t}\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <queue>\n#include <tuple>\n#include <cstdio>\nusing namespace std;\ntypedef tuple<int, int, int> T;\n\nint h, w;\nstring s[20];\nint meY, meX;\nint gostY, gostX;\nstring moves;\n\nint minCost[20][20];\nint INF = 1000;\n\nint dy[4] = {-1, 0, 1, 0};\nint dx[4] = {0, 1, 0, -1};\n\nvoid outAns() {\n\tint y = gostY;\n\tint x = gostX;\n\t\n\tfor (int i = 0; i < INF; i++) {\n\t\tif (minCost[y][x] <= i) {\n\t\t\tcout << i << \" \" << y << \" \" << x << endl;\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tchar type = moves[i % moves.length()];\n\t\tchar *dir = \"8624\";\n\t\tint j;\n\t\tfor (j = 0; j < 4; j++) {\n\t\t\tif (dir[j] == type) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (j == 4) continue;\n\t\t\n\t\t//?????? == j??§?§????\n\t\tint ny = y + dy[j];\n\t\tint nx = x + dx[j];\n\t\tif (0 <= ny && ny < h && 0 <= nx && nx < w) {\n\t\t\ty = ny;\n\t\t\tx = nx;\n\t\t}\n\t}\n\tcout << \"impossible\" << endl;\n}\n\nint main() {\n\twhile (cin >> h >> w, h) {\n\t\tint i, j;\n\t\tfor (i = 0; i < h; i++) cin >> s[i];\n\t\tfor (i = 0; i < h; i++) {\n\t\t\tfor (j = 0; j < w; j++) {\n\t\t\t\tif (s[i][j] == 'A') {\n\t\t\t\t\tmeY = i;\n\t\t\t\t\tmeX = j;\n\t\t\t\t}\n\t\t\t\tif (s[i][j] == 'B') {\n\t\t\t\t\tgostY = i;\n\t\t\t\t\tgostX = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> moves;\n\t\t\n\t\tfor (i = 0; i < h; i++) for (j = 0; j < w; j++) minCost[i][j] = INF;\n\t\t\n\t\tqueue<T> que;\t//cst, y, x\n\t\tque.push(T(0, meY, meX));\n\t\twhile (!que.empty()) {\n\t\t\tT now = que.front(); que.pop();\n\t\t\tint cst = get<0>(now);\n\t\t\tint y = get<1>(now);\n\t\t\tint x = get<2>(now);\n\t\t\tif (minCost[y][x] <= cst) continue;\n\t\t\tminCost[y][x] = cst;\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++) {\n\t\t\t\tint ny = y + dy[i];\n\t\t\t\tint nx = x + dx[i];\n\t\t\t\tif (!(0 <= ny && ny < h && 0 <= nx && nx < w)) continue;\n\t\t\t\tif (s[ny][nx] == '#') continue;\n\t\t\t\tque.push(T(cst + 1, ny, nx));\n\t\t\t}\n\t\t}\n\t\t\n\t\toutAns();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\nint H, W;\nvoid move(int& x, int& y, char c){\n  if(c == '8' && y - 1 >= 0) y--;\n  if(c == '6' && x + 1 < W) x++;\n  if(c == '4' && x - 1 >= 0) x--;\n  if(c == '2' && y + 1 < H) y++;\n}\n\nint main(){\n  while(cin>>H>>W && H){\n    vector<string> grid(H);\n    string pattern;\n    REP(y, H) cin>>grid[y];\n    cin>>pattern;\n    int N = pattern.size();\n    int sx, sy, gx, gy;\n    REP(y, H)REP(x, W){\n      if(grid[y][x] == 'A') sx = x, sy = y;\n      if(grid[y][x] == 'B') gx = x, gy = y;\n    }\n    queue<int> qx, qy;\n    int min_arrive[20][20];\n    REP(y, H)REP(x, W) min_arrive[y][x] = INF;\n    qx.push(sx), qy.push(sy);\n    min_arrive[sy][sx] = 0;\n    int max_arrive = -INF;\n    while(!qx.empty()){\n      int x = qx.front(), y = qy.front();\n      qx.pop(); qy.pop();\n      REP(r, 4){\n        int nx = x + dx[r];\n        int ny = y + dy[r];\n        if(nx >= 0 && ny >= 0 && nx < W && ny < H && min_arrive[ny][nx] == INF && grid[ny][nx] != '#'){\n          min_arrive[ny][nx] = min_arrive[y][x] + 1;\n          max_arrive = max(max_arrive, min_arrive[ny][nx]);\n          qx.push(nx), qy.push(ny);\n        }\n      }\n    }\n    /*\n    REP(y, H){\n      REP(x, W){\n        cout<<min_arrive[y][x]<< \" \";\n      }\n      cout<<endl;\n    }\n    */\n    int ans_t = INF, ans_x = INF, ans_y = INF;\n    bool used[10][20][20] = {};\n    for(int t = 0; ; t++){\n      if(used[t % N][gy][gx] && max_arrive < t) break;\n      used[t % N][gy][gx] = true;\n      if(min_arrive[gy][gx] <= t){\n        ans_t = t, ans_x = gx, ans_y = gy;\n        break;\n      }\n      move(gx, gy, pattern[t % N]);\n    }\n    if(ans_t != INF) printf(\"%d %d %d\\n\", ans_t, ans_y, ans_x);\n    else printf(\"impossible\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()){\n    v.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t){\n    stringstream ss;\n    ss << f;\n    ss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x) \n#define debug(x) \n#endif\n#define LDcout(x,n) fixed<<setprecision(n)<<x\n\n#define MOD 1000000007LL\n#define EPS 1e-8\nstatic const int INF=1<<24;\nint h,w;\nint dd[]={0,1,0,-1,0};\nbool check(int a,int b){\n\tif(0<=a&&a<h&&0<=b&&b<w) return true;\n\treturn false;\n}\nvoid bfs(pii p,int x,vector<string> &v,vvint &vv){\n\tif(vv[p.F][p.S]>=0) return;\n\tvv[p.F][p.S]=x;\n\trep(i,4){\n\t\tpii ne=pii(p.F+dd[i],p.S+dd[i+1]);\n\t\tif(!check(ne.F,ne.S)||v[ne.F][ne.S]=='#') continue;\n\t\tbfs(ne,x+1,v,vv);\n\t}\n}\nvoid mainmain(){\n\tvector<pii> vec(10);\n\tvec[2]=pii(1,0);\n\tvec[4]=pii(0,-1);\n\tvec[5]=pii(0,0);\n\tvec[6]=pii(0,1);\n\tvec[8]=pii(-1,0);\n\twhile(cin>>h>>w,h||w){\n\t\tvector<string> v(h);\n\t\trep(i,h) cin>>v[i];\n\t\tstring s;\n\t\tcin>>s;\n\t\tvvint vv;\n\t\tinitvv(vv,h,w,-1);\n\t\tpii A,B;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\tif(v[i][j]=='A'){\n\t\t\t\t\tA=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t\tif(v[i][j]=='B'){\n\t\t\t\t\tB=pii(i,j);\n\t\t\t\t\tv[i][j]='.';\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tbfs(A,0,v,vv);\n\t\tint ans=-1;\n\t\tpii pos;\n\t\trep(i,h){\n\t\t\trep(j,w){\n\t\t\t\t// printf(\"%2d \",vv[i][j]);\n\t\t\t\tif(vv[i][j]==-1) vv[i][j]=INF;\n\t\t\t}\n\t\t\t// cout<<endl;\n\t\t}\n\t\trep(i,2*1e6){\n\t\t\t// cout<<i<<\" \"<<B.F<<\" \"<<B.S<<endl;\n\t\t\tif(vv[B.F][B.S]<=i){\n\t\t\t\tans=i;\n\t\t\t\tpos=B;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint t=s[i%s.size()]-'0';\n\t\t\tpii ne=pii(B.F+vec[t].F,B.S+vec[t].S);\n\t\t\tif(check(ne.F,ne.S)){\n\t\t\t\tB=ne;\n\t\t\t}\n\t\t}\n\t\tif(ans==-1){\n\t\t\tcout<<\"impossible\"<<endl;\n\t\t}\n\t\telse{\n\t\t\tcout<<ans<<\" \"<<pos.F<<\" \"<<pos.S<<endl;\n\t\t}\n\t\t// return;\n\t}\n}\n\n\nsigned main() {\n\t// ios_base::sync_with_stdio(false);\n  \tcout<<fixed<<setprecision(20);\n    mainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue.h>\nint main(){\n\tqueue<int> q;\n\tint w,h,f[484],i,j,d[]={22,0,-1,0,1,0,-22},a,b,t,x,z;\n\tchar p[15];\n\tfor(;scanf(\"%d%d \",&h,&w),h;){\n\t\tfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\n\t\tfor(i=1;i<=h;i++){\n\t\t\tfor(j=1;j<=w;j++){\n\t\t\t\tf[x=i*22+j]=-1;\n\t\t\t\tswitch(getchar()){\n\t\t\t\t\tcase'#':--f[x];break;\n\t\t\t\t\tcase'A':a=x;break;\n\t\t\t\t\tcase'B':b=x;break;\n\t\t\t\t}\n\t\t\t}\n\t\t\tf[i*22]=f[i*22-~w]=-9;\n\t\t\tgetchar();\n\t\t}\n\t\t\n\t\tf[a]=t=0;\n\t\tq.push(0);\n\t\tfor(q.push(a);q.size()>1;){\n\t\t\ta=q.front();\n\t\t\tq.pop();\n\t\t\tif(a){\n\t\t\t\tfor(i=0;i<7;i+=2)\n\t\t\t\t\tif(f[x=a+d[i]]==-1)\n\t\t\t\t\t\tf[x]=t,\n\t\t\t\t\t\tq.push(x);\n\t\t\telse\n\t\t\t\t++t,q.push(0);\n\t\t}\n\t\tq.pop();\n\t\tscanf(\"%s\",p);\n\t\tfor(a=t=0;!a;){\n\t\t\tx=b;\n\t\t\tz=0;\n\t\t\tfor(i=0;!a&&p[i];i++){\n\t\t\t\tt++;\n\t\t\t\tf[j=b+d[p[i]-'2']]>-3?b=j:0;\n\t\t\t\tf[b]>=0&&t>=f[b]?a=b:0;\n\t\t\t\tf[b]>=0&&++z;\n\t\t\t}\n\t\t\t!z&!a&!p[i]&b==x&f[b]<0&&--a;\n\t\t}\n\t\tprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\nusing namespace std;\ntypedef pair<pair<int,int>,int> pa;\n#define ff first.first\n#define fs first.second\n#define f(a,b) for(int a=0;a<b;a++)\n\nint h,w,sx,sy,gx,gy,i,j,go,m = 999999;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,-1,0,1};\nint co[21][21];\nchar ma[21][21];\nbool visited[21][21];\nstring pat;\n\nint main(){\n    while(cin>>h>>w,h){\n        f(i,h){\n            f(j,w){\n                co[i][j]=m;\n                cin>>ma[i][j];\n                if(ma[i][j]=='A')\n                    sx=j,sy=i;\n                else if(ma[i][j]=='B')\n                    gx=j,gy=i;\n            }\n        }\n        queue<pa>q;\n        q.push(make_pair(make_pair(sx, sy), 0));\n        while(q.size()){\n            pa p = q.front();\n            q.pop();\n            if(co[p.fs][p.ff]!=m)\n                continue;\n            co[p.fs][p.ff]=p.second;\n            f(i,4){\n                int nx=p.ff+dx[i];\n                int ny=p.fs+dy[i];\n                if(nx>=0&&nx<w&&ny>=0&ny<h&&ma[ny][nx]!='#'&&co[ny][nx]==m)\n                    q.push(make_pair(make_pair(nx, ny), p.second+1));\n            }\n        }\n        cin>>pat;\n        for(j=0,go=0;;j++,go++){\n            i=j%pat.length();\n            if(co[gy][gx]<=go){\n                cout<<go<<\" \"<<gy<<\" \"<<gx<<endl;\n                break;\n            }\n            if(go>700){\n                cout<<\"impossible\"<<endl;\n                break;\n            }\n            if(pat[i]=='8')\n                gy--;\n            else if(pat[i]=='6')\n                gx++;\n            else if(pat[i]=='4')\n                gx--;\n            else if(pat[i]=='2')\n                gy++;\n            gy=max(0,min(h-1,gy));\n            gx=max(0,min(w-1,gx));\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef vector<Int> vInt;\ntypedef pair<int,int> pint;\ntypedef pair<Int,Int> pInt;\ntypedef vector<string> vstring;\ntypedef vector<pint> vpint;\ntypedef vector<pInt> vpInt;\ntypedef stringstream SS;\n\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\n\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define repn(i,m,n) for(int i=(m);i<(n);++i)\n#define repd(i,n) for(int i=(n)-1;i>=0;--i)\n#define repnd(i,m,n) for(int i=(n)-1;i>=(m);--i)\n#define rep0(i,n) for(i=0;i<(n);++i)\n#define repn0(i,m,n) for(i=(m);i<(n);++i)\n#define repd0(i,n) for(i=(n)-1;i>=0;--i)\n#define repnd0(i,m,n) for(i=(n)-1;i>=(m);--i)\n#define repc(i,n) for(int i=0;i<=(n);++i)\n#define repcn(i,m,n) for(int i=(m);i<=(n);++i)\n#define repcd(i,n) for(int i=(n);i>=0;--i)\n#define repcnd(i,m,n) for(int i=(n);i>=(m);--i)\n#define repc0(i,n) for(i=0;i<=(n);++i)\n#define repcn0(i,m,n) for(i=(m);i<=(n);++i)\n#define repcd0(i,n) for(i=(n);i>=0;--i)\n#define repcnd0(i,m,n) for(i=(n);i>=(m);--i)\n#define all(n) n.begin(),n.end()\n#define sz(n) ((int)(n).size())\n#define IL for(;;)\n#define MP make_pair\n#define PB push_back\n#define X second\n#define Y first\n#define p_queue(n) priority_queue<n,vector<n>,greater<n> >\n#define PUTLINE cout<<\"LINE:\"<<__LINE__<<endl;\n\nconst int INF = 2147483647/3;\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\n\nconst int dx[]={1,-1,0,0,1,1,-1,-1,0};\nconst int dy[]={0,0,1,-1,1,-1,1,-1,0};\n\nstring str[30];\nint dis[30][30];\n\nint main() {\n\tint h, w;\n\tIL {\n\t\tcin >> h >> w;\n\t\tif (h == 0 && w == 0) break;\n\t\trep (i, h) cin >> str[i];\n\t\trep (i, h) rep (j, w) dis[i][j] = INF;\n\t\tint x, y;\n\t\trep0 (y, h) rep0 (x, w) if (str[y][x] == 'A') goto aaa;\n\t\taaa:;\n\t\tqueue<pint> que;\n\t\tque.push(MP(y, x));\n\t\tdis[y][x] = 0;\n\t\twhile (!que.empty()) {\n\t\t\tpint now = que.front();\n\t\t\tque.pop();\n\t\t\tint cost = dis[now.Y][now.X];\n\t\t\trep (i, 4) {\n\t\t\t\tif (now.X + dx[i] < 0 || w <= now.X + dx[i]) continue;\n\t\t\t\tif (now.Y + dy[i] < 0 || h <= now.Y + dy[i]) continue;\n\t\t\t\tif (str[now.Y + dy[i]][now.X + dx[i]] == '#') continue;\n\t\t\t\tif (dis[now.Y + dy[i]][now.X + dx[i]] <= cost + 1) continue;\n\t\t\t\tdis[now.Y + dy[i]][now.X + dx[i]] = cost + 1;\n\t\t\t\tque.push(MP(now.Y + dy[i], now.X + dx[i]));\n\t\t\t}\n\t\t}\n\t\tstring move;\n\t\tcin >> move;\n\t\trep0 (y, h) rep0 (x, w) if (str[y][x] == 'B') goto bbb;\n\t\tbbb:;\n\t\tint cost = 0;\n\t\trep (iii, 100) rep (i, sz(move)) {\n\t\t\tif (move[i] == '2' && y < h - 1) ++y;\n\t\t\tif (move[i] == '4' && x > 0) --x;\n\t\t\tif (move[i] == '6' && x < w - 1) ++x;\n\t\t\tif (move[i] == '8' && y > 0) --y;\n\t\t\t++cost;\n\t\t\tif (cost >= dis[y][x]) {\n\t\t\t\tcout << cost << \" \" << y << \" \" << x << endl;\n\t\t\t\tgoto ccc;\n\t\t\t}\n\t\t}\n\t\tcout << \"impossible\" << endl;\n\t\tccc:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nchar s[20][21];\nint d[20][20];\nint dx[]{ 0,-1,0,0,1 }, dy[]{ 0,0,1,-1,0 };\n\nint main() {\n\tint h, w;\n\twhile (scanf(\"%d%d\", &h, &w), h) {\n\t\tint ax, ay, bx, by;\n\t\trep(i, h) {\n\t\t\tscanf(\"%s\", s[i]);\n\t\t\trep(j, w) {\n\t\t\t\tif (s[i][j] == 'A')ax = i, ay = j;\n\t\t\t\tif (s[i][j] == 'B')bx = i, by = j;\n\t\t\t}\n\t\t}\n\t\tstring p; cin >> p;\n\t\tfor (char&c : p) {\n\t\t\tif (c == '5')c = 0;\n\t\t\tif (c == '8')c = 1;\n\t\t\tif (c == '6')c = 2;\n\t\t\tif (c == '4')c = 3;\n\t\t\tif (c == '2')c = 4;\n\t\t}\n\t\tqueue<P>que;\n\t\tmemset(d, -1, sizeof(d));\n\t\td[0][0] = 0; que.push(P(ax, ay));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.front(); que.pop();\n\t\t\tfor (int i = 1; i <= 4; i++) {\n\t\t\t\tint nx = p.first + dx[i], ny = p.second + dy[i];\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w&&s[nx][ny] != '#'&&d[nx][ny] == -1) {\n\t\t\t\t\td[nx][ny] = d[p.first][p.second] + 1;\n\t\t\t\t\tque.push(P(nx, ny));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint x = bx, y = by;\n\t\tint t = 0;\n\t\trep(i, 1000000) {\n\t\t\tfor (char c : p) {\n\t\t\t\tif (d[x][y] != -1 && d[x][y] <= t) {\n\t\t\t\t\tprintf(\"%d %d %d\\n\", t, x, y); goto g;\n\t\t\t\t}\n\t\t\t\tint nx = x + dx[c], ny = y + dy[c]; t++;\n\t\t\t\tif (0 <= nx&&nx < h && 0 <= ny&&ny < w)x = nx, y = ny;\n\t\t\t}\n\t\t}\n\t\tputs(\"impossible\");\n\tg:;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "/* TLE */\n\n#include <iostream>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define PTN (dp%L.size())\nint w,h;\nchar data[20][20];\nstring L;\nbool flag = false;\nint mi,mix,miy;\npair<int,int> prob[1000];\nbool done[20][20];\n\nvoid rec(int x,int y,int gx,int gy,int bx,int by,int dp){\n\tif(data[y][x] == '#' || dp > mi)return;\n\tif( x==gx && y==gy){\n\t\tflag = true;\n\t\tif(mi > dp){\n\t\t\tmi = dp;\n\t\t\tmix = x;\n\t\t\tmiy = y;\n\t\t}\n\t\treturn;\n\t}\n\t\n\t\n\tswitch(L[PTN]){\n\tcase '5':\n\t\t//rec(x,y,gx,gy,x,y,dp+1);\n\t\tbreak;\n\tcase '8':\n\t\tif(gy-1>=0)gy-=1;\n\t\tbreak;\n\tcase '6':\n\t\tif(gx+1<w)gx+=1;\n\t\tbreak;\n\tcase '4':\n\t\tif(gx-1>=0)gx-=1;\n\t\tbreak;\n\tcase '2':\n\t\tif(gy+1<h)gy+=1;\n\t\tbreak;\n\t}\n\tif(!done[y][x])rec(x,y,gx,gy,x,y,dp+1);\n\tdone[y][x]=true;\n\t\n\tif(x-1!=bx && x-1>=0){\n\t\trec(x-1,y,gx,gy,x,y,dp+1);\n\t}\n\tif(x+1!=bx && x+1<w ){\n\t\trec(x+1,y,gx,gy,x,y,dp+1);\n\t}\n\tif(y+1!=by && y+1<h ){\n\t\trec(x,y+1,gx,gy,x,y,dp+1);\n\t}\n\tif(y-1!=by && y-1>=0){\n\t\trec(x,y-1,gx,gy,x,y,dp+1);\n\t}\n\t\n}\nint main(){\n\tint sx,sy;\n\tint gx,gy;\n\twhile(cin >> h >> w && w || h){\n\t\tflag = false;\n\t\trep(i,20)rep(j,20)done[i][j] = false;\n\t\tmi = 100;\n\t\trep(i,h)rep(j,w){\n\t\t\tcin >> data[i][j];\n\t\t\tswitch(data[i][j]){\n\t\t\t\tcase 'A' :\n\t\t\t\t\tsx = j;\n\t\t\t\t\tsy = i;\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'B' :\n\t\t\t\t\tgx = j;\n\t\t\t\t\tgy = i;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tcin >> L;\n\t\t\n\t\trec(sx,sy,gx,gy,sx,sy,0);\n\t\t\n\t\tif(flag){\n\t\t\tcout << mi << \" \" << miy << \" \" << mix << endl;\n\t\t}else{\n\t\t\tcout << \"impossible\" << endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<queue>\n#include<map>\n#include<limits.h>\nint main()\n{\n\tint h,w,i,j,x,y,ax,ay,gx,gy,d[22][22],r,f,dx[]={1,0,-1,0,0},dy[]={0,1,0,-1,0};\n\tchar m[22][22],g[15],*p;\n\twhile(scanf(\"%d%d\",&h,&w),h)\n\t{\n\t\tfor(i=1;i<=h;++i)\n\t\t{\n\t\t\tscanf(\"%s\",m[i]+1);\n\t\t\tif(p=strchr(m[i]+1,'A'))ax=p-m[i],ay=i;\n\t\t\tif(p=strchr(m[i]+1,'B'))gx=p-m[i],gy=i;\n\t\t}\n\t\tscanf(\"%s\",g);\n\n\t\tfor(i=0;i<h+1;++i)m[i][0]=m[i][w+1]='#';\n\t\tfor(j=0;j<w+1;++j)m[0][j]=m[h+1][j]='#';\n\t\t//Aツつゥツづァツづ個催短ツ仰猟猟」ツづーツ出ツつキ\n\t\tfor(i=0;i<22;++i)for(j=0;j<22;++j)d[j][i]=INT_MAX;\n\t\ttypedef std::pair<int,int>P;\n\t\tstd::queue<P>q;\n\t\tP _;\n\t\tq.push(P(ax,ay));\n\t\tq.push(P(-1,-1));\n\t\tr=0;\n\t\twhile(q.size()>1)\n\t\t{\n\t\t\t_=q.front();q.pop();\n\t\t\tif(_.first<0){++r;q.push(_);continue;}\n\t\t\tif(m[_.second][_.first]=='#')continue;\n\t\t\tif(d[_.second][_.first]<=r)continue;\n\t\t\td[_.second][_.first] = r;\n\t\t\tfor(i=0;i<4;++i)q.push(P(_.first+dy[i],_.second+dx[i]));\n\t\t}int lx=-1,ly=-1;r=1;\n\t\tf=0;\n\t\tfor(;;)\n\t\t{\n\t\t\tif(lx==gx && ly==gy && !f)\n\t\t\t{\n\t\t\t\tputs(\"impossible\");\n\t\t\t\tgoto E;\n\t\t\t}\n\t\t\tlx=gx;ly=gy;\n\t\t\tfor(f=i=0;i<strlen(g);++i,++r)\n\t\t\t{\n\t\t\t\tint t[]={4,4,1,4,2,4,0,4,3};\n\t\t\t\tx=gx+dx[t[g[i]-'0']];\n\t\t\t\ty=gy+dy[t[g[i]-'0']];\n\t\t\t\tif(x>0&&x<=w&&y>0&&y<=h)gx=x,gy=y;\n\t\t\t\tif(d[gy][gx]!=INT_MAX)f=1;if(d[gy][gx]<=r)\n\t\t\t\t{\n\t\t\t\t\tprintf(\"%d %d %d\\n\",r,gy-1,gx-1);\n\t\t\t\t\tgoto E;\n\t\t\t\t}\n\t\t\t}\n\t\t}\nE:;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef complex<double> P;\nconst int INF = 1e5;\n\nint H, W;\nint my[] = {0, 0, 1, -1};\nint mx[] = {1, -1, 0, 0};\n\nvoid dfsA(int t, int y, int x, vector<string> &v, vector< vector<int> > &cnt){\n  REP(i, 4){\n    int ny = y + my[i], nx = x + mx[i];\n    if(ny >= 0 && nx >= 0 && ny < H && nx < W && v[ny][nx] != '#' && cnt[ny][nx] > t + 1){\n      cnt[ny][nx] = t + 1;\n      dfsA(t + 1, ny, nx, v, cnt);\n    }\n  }\n}\n\nint main() {\n  while(cin >>H >>W && H){\n    vector<string> v(H); REP(i, H) cin >>v[i];\n    vector< vector<int> > cntA(H, vector<int>(W, INF));\n    REP(i, H) REP(j, W) if(v[i][j] == 'A') { cntA[i][j] = 0; dfsA(0, i, j, v, cntA); }\n    string pattern; cin >>pattern;\n    int y, x, ay, ax, ans = INF, pl = pattern.length();\n    REP(i, H) REP(j, W) if(v[i][j] == 'B') { y = i; x = j; }\n    REP(i, INF){\n      if(cntA[y][x] <= i) { ans = i; ay = y; ax = x; break; }\n      //cout <<y <<\", \" <<x <<\", \" <<cntA[y][x] <<\", \" <<i <<endl;\n      if(pattern[i % pl] == '8') { y = max(0, y - 1); }\n      else if(pattern[i % pl] == '6') { x = min(W - 1, x + 1); }\n      else if(pattern[i % pl] == '4') { x = max(0, x - 1); }\n      else if(pattern[i % pl] == '2') { y = min(H - 1, y + 1); }\n    }\n    if(ans == INF) cout <<\"impossible\" <<endl;\n    else cout <<ans <<\" \" <<ay <<\" \" <<ax <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<queue>\nint main(){\nstd::queue<int>q;\nint w,h,f[484],i,j,a,b,t,x,z;\nchar p[15];\nfor(;scanf(\"%d%d \",&h,&w),h;){\nfor(j=0;j<w+2;j++)f[j]=f[j-~h*22]=-9;\nfor(i=1;i<=h;i++){\nfor(j=1;j<=w;j++)\nf[x=i*22+j]=-1,\nz=getchar(),\nz-35?z>65?b=x:z>64?a=x:1:--f[x];\nf[i*22]=f[i*22-~w]=-9;\ngetchar();\n}\n\nf[a]=t=0;\nq.push(0);\nfor(q.push(a);a=q.front(),q.size()>1;q.pop())\nif(a){\nfor(i=4;i--;)\nif(f[x=a+\" 57L\"[i]]==-1)\nf[x]=t,q.push(x);}\nelse\n++t,q.push(0);\n\nq.pop();\nscanf(\"%s\",p);\nfor(a=t=0;!a;){\nx=b;\nz=0;\nfor(i=0;!a&&p[i];i++){\nt++;\nf[j=b+\"L65676 \"[p[i]-50]-54]>-3?b=j:0;\nf[b]>=0&&t>=f[b]?a=b:0;\nf[b]>=0&&++z;\n}\n!z&!a&!p[i]&b==x&f[b]<0&&--a;\n}\nprintf(a<0?\"impossible\\n\":\"%d %d %d\\n\",t,a/22-1,a%22-1);\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<queue>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nint main(){\n  int h,w;\n  string g[30],p;\n  bool vis[30][30][30];\n  int t[30][30];\n\n  while(cin >> h >> w , h||w){\n    int ay,ax,by,bx;\n    for(int i=0;i<h;i++){\n      cin >> g[i];\n      for(int j=0;j<w;j++){\n\tif(g[i][j] == 'A'){ay = i; ax = j; g[i][j] = '.';}\n\tif(g[i][j] == 'B'){by = i; bx = j; g[i][j] = '.';}\n\tt[i][j] = -1;\n\tfor(int k=0;k<10;k++)vis[i][j][k] = false;\n      }\n    }\n\n    cin >> p;\n    int s = p.size();\n\n    t[ay][ax] = 0;\n    queue<P> q;\n    q.push(P(ay,ax));\n    int m;\n\n    while(q.size()){\n      P p = q.front();q.pop();\n      int dy[] = {-1,0,1,0}, dx[] = {0,1,0,-1};\n\n      for(int i=0;i<4;i++){\n\tint ty = p.first + dy[i], tx = p.second + dx[i];\n\tif(ty<0 || tx<0 || h<=ty || w<=tx || g[ty][tx] == '#')continue;\n\tif(t[ty][tx]<0){\n\t  m = t[ty][tx] = t[p.first][p.second] + 1;\n\t  q.push(P(ty,tx));\n\t}\n      }\n    }\n\n    int cnt = 0;\n    bool f = false;\n    for(;;){\n      if(vis[by][bx][cnt%s] && m<cnt)break;\n      vis[by][bx][cnt%s] = true;\n      if(p[cnt%s]=='8' && 0<by)by--;\n      if(p[cnt%s]=='6' && bx<w-1)bx++;\n      if(p[cnt%s]=='4' && 0<bx)bx--;\n      if(p[cnt%s]=='2' && by<h-1)by++;\n      cnt++;\n      if(0<=t[by][bx] && t[by][bx]<=cnt){\n\tcout << cnt << \" \" << by << \" \" << bx << endl;\n\tf = true;\n\tbreak;\n      }\n    }\n    if(!f)cout << \"Impossible\\n\";\n  }\n}"
  },
  {
    "language": "C",
    "code": "// Aizu 1046: Ghost Buster!\n// 2017.9.6 bal4u@uu\n\n#include <stdio.h>\n#include <string.h>\n\n#define QMAX 100000\ntypedef struct { int t, ax, ay, bx, by; } Q;\nQ q[QMAX+3], *top, *end, *qend = q + QMAX;\n\nint gm[9][2] = { {0},{0},{1,0},{0},{0,-1},{0,0},{0,1},{0},{-1,0} };\nint m[4][2] = { {1,0},{-1,0},{0,1},{0,-1} };\n\nchar map[22][22];\nunsigned char mk[22][22][22][22][11];\nchar p[12]; int plen;\nint ax, ay, bx, by;\n\nint main()\n{\n\tint h, w, i, k, x, y, t, t0, axx, ayy, bxx, byy, bx2, by2, anst, ansx, ansy;\n\tunsigned char cno = 0;\n\n\twhile (scanf(\"%d%d\", &h, &w) && h) {\n\t\tcno++;\n\t\tfor (y = 0; y < h; y++) {\n\t\t\tscanf(\"%s\", map[y]);\n\t\t\tfor (x = 0; x < w; x++) {\n\t\t\t\tif      (map[y][x] == 'A') ax = x, ay = y, map[y][x] = '.';\n\t\t\t\telse if (map[y][x] == 'B') bx = x, by = y, map[y][x] = '.';\n\t\t\t}\n\t\t}\n\t\tscanf(\"%s\", p), plen = strlen(p);\n\t\tfor (k = 0; k < plen; k++) p[k] -= '0';\n\n\t\ttop = end = q;\n\t\tend->t = 0, end->ax = ax, end->ay = ay, end->bx = bx, end->by = by, end++;\n\t\tmk[ax][ay][bx][by][0] = cno;\n\t\tanst = -1, t0 = -1, k = 0;\n\t\twhile (top < end) {\n\t\t\tt = top->t, axx = top->ax, ayy = top->ay, bxx = top->bx, byy = top->by;\n\t\t\tif (++top >= qend) top = q;\n\t\t\tif (axx == bxx && ayy == byy) { ansx = axx, ansy = ayy, anst = t; break; }\n\t\t\tif (t != t0) {\n\t\t\t\tbx2 = bxx + gm[p[k]][1], by2 = byy + gm[p[k]][0];\n\t\t\t\tif (bx2 < 0 || bx2 >= w || by2 < 0 || by2 >= h) bx2 = bxx, by2 = byy;\n\t\t\t\tt0 = t; if (++k >= plen) k = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < 4; i++) {\n\t\t\t\tx = axx + m[i][1], y = ayy + m[i][0];\n\t\t\t\tif (x < 0 || x >= w || y < 0 || y >= h || map[y][x] == '#') x = axx, y = ayy;\n\t\t\t\tif (mk[x][y][bx2][by2][k] == cno) continue;\n\t\t\t\tmk[x][y][bx2][by2][k] = cno;\n\t\t\t\tend->t = t+1, end->ax = x, end->ay = y, end->bx = bx2, end->by = by2;\n\t\t\t\tif (++end >= qend) end = q;\n\t\t\t}\n\t\t}\n\t\tif (anst < 0) puts(\"impossible\");\n\t\telse printf(\"%d %d %d\\n\", anst, ansy, ansx); \n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int h,w,i,j,gx,gy,t,r,x[400],y[400],g[10];\n  int X[]={ 0, 0,-1, 1, 0};\n  int Y[]={ 0, 1, 0, 0,-1};\n  char m[20][20],p;\n  while(scanf(\"%d %d\",&h,&w),w||h){\n    int c[20][20]={0};\n    for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tscanf(\" %c \",&m[i][j]);//printf(\"%c\",m[i][j]);\n\tif(m[i][j]=='A'){\n\t  y[0]=i;\n\t  x[0]=j;\n\t  t=0;\n\t  c[i][j]=r=1;\n\t}\n\tif(m[i][j]=='B'){\n\t  gy=i;\n\t  gx=j;\n\t}\n      }//printf(\"\\n\");\n    }\n    for(t=0;r-t;t++){\n      for(i=1;i<5;i++){\n\tif(0<=x[t]+X[i]&&x[t]+X[i]<w&&\n\t   0<=y[t]+Y[i]&&y[t]+Y[i]<h){\n\t  if(m[y[t]+Y[i]][x[t]+X[i]]!='#'&&\n\t     c[y[t]+Y[i]][x[t]+X[i]]==0){\n\t    c[y[t]+Y[i]][x[t]+X[i]]=c[y[t]][x[t]]+1;\n\t    x[r]=x[t]+X[i];\n\t    y[r]=y[t]+Y[i];\n\t    r++;\n\t  }\n\t}\n      }\n    }\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++){\n\tprintf(\"%4d\",c[i][j]);\n      }\n      printf(\"\\n\");\n      }*/\n    for(i=0;scanf(\"%c\",&p),p-10;i++){//printf(\"%c\",p);\n      if(p=='5')g[i]=0;\n      else\tg[i]=(p-'0')/2;\n    }//printf(\"\\n\");\n    for(j=0;1;j++){\n      gy+=Y[g[j%i]];\n      gx+=X[g[j%i]];\n      if(gx<0 )gx=0;\n      if(w==gx)gx--;\n      if(gy<0 )gy=0;\n      if(h==gy)gy--;\n      if(c[gy][gx]<=j+2&&c[gy][gx])break; \n      if(j==400)break;\n    }\n    if(j-400)printf(\"%d %d %d\\n\",j+1,gy,gx);\n    else     printf(\"impossible\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint map[22][22];\n\nvoid walk(int x, int y, int step)\n{\n    map[y][x] = step;\n    \n    if (map[y][x - 1] == -1 || map[y][x - 1] > step + 1){\n        walk(x - 1, y, step + 1);\n    }\n    \n    if (map[y][x + 1] == -1 || map[y][x + 1] > step + 1){\n        walk(x + 1, y, step + 1);\n    }\n\n    if (map[y - 1][x] == -1 || map[y - 1][x] > step + 1){\n        walk(x, y - 1, step + 1);\n    }\n\n    if (map[y + 1][x] == -1 || map[y + 1][x] > step + 1){\n        walk(x, y + 1, step + 1);\n    }\n}\n\n\nint main(void)\n{\n    int H, W;\n    char pattern[11];\n    char str[21];\n    int ax, ay, bx, by;\n    int x, y, minx, miny;\n    int min;\n    int len;\n    int i;\n    \n    while (1){\n        scanf(\"%d%d\", &H, &W);\n        if (H == 0 && W == 0){\n            break;\n        }\n        \n        for (y = 0; y <= H + 1; y++){\n            for (x = 0; x <= W + 1; x++){\n                map[y][x] = -2;\n            }\n        }\n\n        for (y = 1; y <= H; y++){\n            scanf(\"%s\", str);\n            for (x = 1; x <= W; x++){\n                switch (str[x - 1]){\n                  case '#':\n                    map[y][x] = -2;\n                    break;\n\n                  case '.':\n                    map[y][x] = -1;\n                    break;\n\n                  case 'A':\n                    map[y][x] = 0;\n                    ax = x;\n                    ay = y;\n                    break;\n\n                  case 'B':\n                    map[y][x] = -1;\n                    bx = x;\n                    by = y;\n                    break;\n                }\n            }\n        }\n        scanf(\"%s\", pattern);\n        \n        walk(ax, ay, 0);\n#if 0\n        for (y = 0; y <= H + 1; y++){\n            for (x = 0; x <= W + 1; x++){\n                printf(\"%2d \", map[y][x]);\n            }\n            printf(\"\\n\");\n        }\n#endif\n        \n        min = 1000;\n        i = 0;\n        len = strlen(pattern);\n        while (1){\n            switch (pattern[i % len]){\n              case '2':\n                if (by < H){\n                    by++;\n                }\n                break;\n        \n              case '4':\n                if (bx > 1){\n                    bx--;\n                }\n                break;\n        \n              case '6':\n                if (bx < W){\n                    bx++;\n                }\n                break;\n\n              case '8':\n                if (by > 1){\n                    by--;\n                }\n                break;\n            }\n// printf(\"[%c %d=%d %d, %d]\", pattern[i%len], i+ 1,bx, by, map[by][bx]);\n            if (map[by][bx] >= 0 && map[by][bx] <= i + 1){\n                if (min > i + 1){\n                    min = i + 1;\n                    minx = bx;\n                    miny = by;\n                }\n            }\n            i++;\n            if (i > 400){\n                break;\n            }\n        }\n#if 0        \n        if (map[by][bx] > 0){\n            if (min > map[by][bx]){\n                min = map[by][bx];\n                minx = bx;\n                miny = by;\n            }\n        }\n#endif\n        if (min == 1000){\n            printf(\"impossible\\n\");\n        }\n        else {\n            printf(\"%d %d %d\\n\", min, miny - 1, minx - 1);\n        }\n    }\n    return (0);\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ax, ay;\n    int bx, by;\n    int time;\n    int g_pat;\n} GHOST;\n\nGHOST queue[500000];\nint head, tail;\n\nvoid enq(GHOST t)\n{\n    queue[tail % 500000] = t;\n    tail++;\n}\n\nvoid deq(GHOST *t)\n{\n    *t = queue[head % 500000];\n    head++;\n}\n\nint main(void)\n{\n    int x, y;\n    int i, j;\n    int len;\n    char map[21][21];\n    char pattern[11];\n    static char v[21][21][21][21];\n    GHOST first, temp;\n    char flag;\n    int dx[4] ={1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int move[5][2] = {{0, 0}, {0, -1}, {1, 0}, {-1, 0}, {0, 1}};\n    while (1){\n        scanf(\"%d%*c%d\", &y, &x);\n        getchar();\n        \n        if (x + y == 0){\n            break;\n        }\n        \n        memset(map, '\\0', sizeof(map));\n        \n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%c\", &map[i][j]);\n                if (map[i][j] == 'A'){\n                    first.ax = j;\n                    first.ay = i;\n                    map[i][j] = '.';\n                }\n                else if (map[i][j] == 'B'){\n                    first.bx = j;\n                    first.by = i;\n                    map[i][j] = '.';\n                }\n            }\n            getchar();\n        }\n        scanf(\"%s\", pattern);\n        getchar();\n        len = strlen(pattern);\n        for (i = 0; i < len; i++){\n            switch (pattern[i]){\n                case '5':\n                pattern[i] = 0;\n                break;\n                \n                case '8':\n                pattern[i] = 1;\n                break;\n                \n                case '6':\n                pattern[i] = 2;\n                break;\n                \n                case '4':\n                pattern[i] = 3;\n                break;\n                \n                case '2':\n                pattern[i] = 4;\n                break;\n            }\n        }\n        first.time = first.g_pat = head = tail = 0;\n        memset(v, 0, sizeof(v));\n        v[first.ax][first.ay][first.bx][first.by] = 1;\n        enq(first);\n        flag = 0;\n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.ax == temp.bx && temp.ay == temp.by){\n                flag = 1;\n                break;\n            }\n            \n            for (i = 0; i < 4; i++){\n                if (0 <= temp.ax + dx[i] && temp.ax + dx[i] < x && 0 <= temp.ay + dy[i] && temp.ay + dy[i] < y && map[temp.ay + dy[i]][temp.ax + dx[i]] == '.'){\n                    first.ax = temp.ax + dx[i];\n                    first.ay = temp.ay + dy[i];\n                }\n                \n                if (0 <= temp.bx + move[pattern[temp.g_pat]][0] && temp.bx + move[pattern[temp.g_pat]][0] < x && 0 <= temp.by + move[pattern[temp.g_pat]][1] && temp.by + move[pattern[temp.g_pat]][1] < y){\n                    first.bx = temp.bx + move[pattern[temp.g_pat]][0];\n                    first.by = temp.by + move[pattern[temp.g_pat]][1];\n                }\n                first.g_pat = temp.g_pat + 1;\n                first.g_pat %= len;\n                first.time = temp.time + 1;\n                if (!v[first.ax][first.ay][first.bx][first.by]){\n                    v[first.ax][first.ay][first.bx][first.by] = 1;\n                    enq(first);\n                }\n            }\n        }\n        \n        if (flag == 1){\n            printf(\"%d %d %d\\n\", temp.time, temp.ay, temp.ax);\n        }\n        \n        else {\n            printf(\"impossible\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct tag_Pair{\n\tint R;\n\tint C;\n}Pair;\n\n\nint main(){\n\tint H,W;\n\tchar Map[21][21];\n\tchar Pat[11];\n\tint i,j;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(!H&&!W)break;\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\"%s\\n\",Map[i]);\n\t\t}\n\t\tscanf(\"%s\\n\",Pat);\n\t\t\n\t\tint turn =0;\n\t\tint M[H][W];\n\t\tPair P;P.R=-1;P.C=-1;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tfor(j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=0;\n\t\t\t\tif(Map[i][j]=='B'){\n\t\t\t\t\tP.R=i;\n\t\t\t\t\tP.C=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint chk=1;\n\t\tint FS[H*W+1];//ハッシュの代わり\n\t\tint FScnt=0;//ハッシュの要素の個数。H*Wが小さいのでO(N)で管理。。。\n\t\tint move;\n\t\tint k;\n\t\tint PatLength=strlen(Pat);\n\t\t\n\t\twhile(1){\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(i=0;i<H;i++){\n\t\t\t\tfor(j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmove=(turn -1)%(PatLength);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t\tif(turn>H*W){\n\t\t\t\t//ループ停止条件：\n\t\t\t\t//turn>H*Wであれば、Aが行けるところにはすべてフラグが立っている\n\t\t\t\t//Bの動きの周期点をturn>H*W以降で観察すれば、Bがループに入ったかどうかが分かる。\n\t\t\t\tif(move==0){\n*/\t\t\t\t\tfor(k=0;k<FScnt;k++){\n\t\t\t\t\t\tif(FS[k]==P.R*W+P.C){\n\t\t\t\t\t\t\tchk=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(chk==0)break;\n\t\t\t\t\tFScnt++;\n\t\t\t\t\tFS[P.R*W+P.C];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(chk==0){\n\t\t\tprintf(\"impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"%d %d %d\\n\",turn,P.R,P.C);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\nint Y[]={-1,0,1,0,0 ,0,0,0,-1,0};\nint X[]={0,1,0,-1,-1,0,1,0,0, 0};\nint main(){\n  int h,w,i,j,ny,nx,t,r,min,my,mx,y[1000],x[1000],yy,yx,l;\n  char m[20];\n  while(scanf(\"%d %d\",&h,&w),h||w){\n    char d[30][30]={0};\n    int c[30][30]={0};\n    for(i=1;i<=h;i++){\n      for(j=1;j<=w;j++){\n\tscanf(\" %c\",&d[i][j]);\n\tif(d[i][j]=='A')d[y[0]=i][x[0]=j]='.';\n\tif(d[i][j]=='B')d[yy=i][yx=j]='.';\n      }\n    }\n    c[y[t=0]][x[0]]=1;\n    for(r=1;r-t;t++){\n      for(i=0;i<4;i++){\n\tny=y[t]+Y[i];\n\tnx=x[t]+X[i];\n\tif(d[ny][nx]-'.'||c[ny][nx])continue;\n\tc[y[r]=ny][x[r]=nx]=c[y[t]][x[t]]+1;\n\tr++;\n      }\n    }\n    /*for(i=0;i<h;i++){\n      for(j=0;j<w;j++)printf(\"%2d \",c[i+1][j+1]);printf(\"\\n\");\n      }*/\n    scanf(\"%s\",m);\n    l=strlen(m);\n    min=10000;\n    for(i=0;i<10000;i++){\n      if(c[yy][yx]&&c[yy][yx]<=i+1){\n\tif(min>i){\n\t  min=i;\n\t  my=yy;\n\t  mx=yx;\n\t}\n      }\n      ny=yy+Y[m[i%l]-'0'];\n      nx=yx+X[m[i%l]-'0'];\n      if(d[ny][nx]){\n\tyy=ny;\n\tyx=nx;\n      }\n    }\n    if(min-i)printf(\"%d %d %d\\n\",min,my-1,mx-1);\n    else     printf(\"impossible\\n\");\n  }\n  return 0;\n}\n    "
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ax, ay;\n    int bx, by;\n    int time;\n    int g_pat;\n} GHOST;\n\nGHOST queue[500000];\nint head, tail;\n\nvoid enq(GHOST t)\n{\n    queue[tail % 100000] = t;\n    tail++;\n}\n\nvoid deq(GHOST *t)\n{\n    *t = queue[head % 100000];\n    head++;\n}\n\nint main(void)\n{\n    int x, y;\n    int i, j;\n    int len;\n    char map[21][21];\n    char pattern[11];\n    static char v[21][21][21][21][10];\n    GHOST first, temp;\n    char flag;\n    int dx[4] ={1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int move[5][2] = {{0, 0}, {0, -1}, {1, 0}, {-1, 0}, {0, 1}};\n    while (1){\n        scanf(\"%d%*c%d\", &y, &x);\n        getchar();\n        \n        if (x + y == 0){\n            break;\n        }\n        \n        memset(map, '\\0', sizeof(map));\n        \n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%c\", &map[i][j]);\n                if (map[i][j] == 'A'){\n                    first.ax = j;\n                    first.ay = i;\n                    map[i][j] = '.';\n                }\n                else if (map[i][j] == 'B'){\n                    first.bx = j;\n                    first.by = i;\n                    map[i][j] = '.';\n                }\n            }\n            getchar();\n        }\n        scanf(\"%s\", pattern);\n        getchar();\n        len = strlen(pattern);\n        for (i = 0; i < len; i++){\n            switch (pattern[i]){\n                case '5':\n                pattern[i] = 0;\n                break;\n                \n                case '8':\n                pattern[i] = 1;\n                break;\n                \n                case '6':\n                pattern[i] = 2;\n                break;\n                \n                case '4':\n                pattern[i] = 3;\n                break;\n                \n                case '2':\n                pattern[i] = 4;\n                break;\n            }\n        }\n        first.time = first.g_pat = head = tail = 0;\n        memset(v, 0, sizeof(v));\n        enq(first);\n        flag = 0;\n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.ax == temp.bx && temp.ay == temp.by){\n                flag = 1;\n                break;\n            }\n            \n            for (i = 0; i < 4; i++){\n                first = temp;\n                if (0 <= temp.ax + dx[i] && temp.ax + dx[i] < x && 0 <= temp.ay + dy[i] && temp.ay + dy[i] < y && map[temp.ay + dy[i]][temp.ax + dx[i]] == '.'){\n                    first.ax = temp.ax + dx[i];\n                    first.ay = temp.ay + dy[i];\n                }\n                \n                if (0 <= temp.bx + move[pattern[temp.g_pat]][0] && temp.bx + move[pattern[temp.g_pat]][0] < x && 0 <= temp.by + move[pattern[temp.g_pat]][1] && temp.by + move[pattern[temp.g_pat]][1] < y){\n                    first.bx = temp.bx + move[pattern[temp.g_pat]][0];\n                    first.by = temp.by + move[pattern[temp.g_pat]][1];\n                }\n                first.g_pat = temp.g_pat + 1;\n                first.g_pat %= len;\n                first.time = temp.time + 1;\n                if (!v[first.ax][first.ay][first.bx][first.by][first.g_pat]){\n                    v[first.ax][first.ay][first.bx][first.by][first.g_pat] = 1;\n                    enq(first);\n                }\n            }\n        }\n        \n        if (flag == 1){\n            printf(\"%d %d %d\\n\", temp.time, temp.ay, temp.ax);\n        }\n        \n        else {\n            printf(\"impossible\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 1046\n  Title:Ghost Buster!\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n#define min(x,y) (((x)<(y))?(x):(y))\nint H,W;\nchar ban[20][21];\nchar reach[20][20];\nchar reach_b[20][20];\nchar pattern[11];\n\n\nmove_b(int *yp,int *xp,char m)\n{\n  //printf(\"d=[%c]|\",m);\n\n  if(m == '8')\n    *yp = max(*yp-1,0);\n  if(m == '2')\n    *yp = min(*yp+1,H-1);\n  if(m == '4')\n    *xp = max(*xp-1,0);\n  if(m == '6')\n    *xp = min(*xp+1,W-1);\n}\n\nmove_a(int *yp,int *xp,int d)\n{\n\n  if(d == 1 && *yp > 0 )\n    *yp = *yp-1;\n  else if(d == 2 && *yp < H-1 )\n    *yp = *yp+1;\n  else if(d == 3 && *xp > 0) \n    *xp = *xp-1;\n  else if(d == 4 && *xp <W-1) \n    *xp = *xp+1;\n}\n\ndump(char ban[][21],char reach[][20],int ya,int xa,int yb,int xb)\n{\n  int i,j;\n  char ban2[20][21];\n\n  memcpy(ban2,ban,sizeof(ban2));\n  ban2[ya][xa]='A';\n  ban2[yb][xb]='B';\n  printf(\"\\n\");\n  for(i=0;i<H;i++)\n    {\n      for(j=0;j<W;j++)\n\tif(reach[i][j])\n\t  {\n\t    if(ban2[i][j]=='B')\n\t      printf(\"b\");\n\t    else if(ban2[i][j]=='A')\n\t      printf(\"A\");\n\t    else\n\t      printf(\"1\");\n\t  }\n\telse\n\t  printf(\"%c\",ban2[i][j]);\n      printf(\"\\n\");\n    }\n}\nsearch(char c,int *yp,int *xp)\n{\n  int i,j;\n\n  for(i=0;i<H;i++)\n    for(j=0;j<W;j++)\n      if(ban[i][j]==c)\n\t{\n\t  *yp=i;*xp=j;\n\t  return;\n\t}\n    \n}\nmain()\n{\n  int i,j,k,ret,flag,flag_b,ya,xa,yb,xb,xa1,ya1,time,cyc_tim,len;\n  char m,reach2[20][20];\n\n  while(scanf(\"%d %d\",&H,&W)  && (H||W))\n    {\n      for(i=0;i<H;i++)\n\tscanf(\"%s\",&ban[i][0]);\n      search('A',&ya,&xa);\n      search('B',&yb,&xb);\n      ban[ya][xa]=ban[yb][xb]='.';\n      memset(reach,0,sizeof(reach));\n      memset(reach_b,0,sizeof(reach_b));\n      scanf(\"%s\",pattern);\n      len=strlen(pattern);\n      \n      reach[ya][xa]=1;\n      reach_b[yb][xb]=1;\n\n      time=1,flag=1;\n      while(1)\n      {\n\tcyc_tim=(time-1) % len;\n\tif(cyc_tim==0)\n\t  flag_b=0;\n\tm=pattern[cyc_tim];\n\tmove_b(&yb,&xb,m);\n\tif(reach_b[yb][xb]==0)\n\t  {\n\t    reach_b[yb][xb]=1;\n\t    flag_b=1;\n\t  }\n\n\tflag=0;\n\tmemcpy(reach2,reach,sizeof(reach2));\n\tfor(i=0;i<H;i++)\n\t  for(j=0;j<W;j++)\n\t    if(reach[i][j]==1)\n\t      {\n\t\t  //printf(\"\\nreach %d %d|\",i,j);\n\t\tfor(k=1;k<=4;k++)\n\t\t  {\n\t\t    ya1=i,xa1=j;\n\t\t    move_a(&ya1,&xa1,k);\n\t\t    //printf(\"r2 %d %d|\",ya1,xa1);\n\t\t    if(reach2[ya1][xa1]==0 && ban[ya1][xa1]!='#')\n\t\t      {\n\t\t\treach2[ya1][xa1]=1;\n\t\t\t  flag=1;\n\t\t      }\n\t\t  }\n\t      }\n\n\tmemcpy(reach,reach2,sizeof(reach2));\n#ifdef DEBUG\n\tdump(ban,reach,ya,xa,yb,xb);\n#endif\t  \n\tif(reach[yb][xb]==1)\n\t  {\n\t    //printf(\"hit %d %d\\n\",yb,xb);\n\t    \n\t    flag=1;\n\t    break;\n\t  }\n\t\n\tif(flag==0 && flag_b==0 && cyc_tim==len-1)\n\t  break;\n\ttime++;\n      }\n      \n      if(flag==0)\n\tprintf(\"impossible\\n\");\n      else\n\tprintf(\"%d %d %d\\n\",time,yb,xb);\n\t\n    }\n  return(0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct tag_Pair{\n\tint R;\n\tint C;\n}Pair;\n\n\nint main(){\n\tint H,W;\n\tchar Map[21][21];\n\tchar Pat[11];\n\tint i,j;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(!H&&!W)break;\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\"%s\\n\",Map[i]);\n\t\t}\n\t\tscanf(\"%s\\n\",Pat);\n\t\t\n\t\tint turn =0;\n\t\tint M[H][W];\n\t\tPair P;P.R=-1;P.C=-1;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tfor(j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=0;\n\t\t\t\tif(Map[i][j]=='B'){\n\t\t\t\t\tP.R=i;\n\t\t\t\t\tP.C=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint chk=1;\n\t\tint FS[H*W+1];//ハッシュの代わり\n\t\tint FScnt=0;//ハッシュの要素の個数。H*Wが小さいのでO(N)で管理。。。\n\t\tint move;\n\t\tint k;\n\t\tint PatLength=strlen(Pat);\n\t\t\n\t\twhile(1){\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(i=0;i<H;i++){\n\t\t\t\tfor(j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmove=(turn -1)%(PatLength);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t\tif(turn>H*W){\n\t\t\t\t//ループ停止条件：\n\t\t\t\t//turn>H*Wであれば、Aが行けるところにはすべてフラグが立っている\n\t\t\t\t//Bの動きの周期点をturn>H*W以降で観察すれば、Bがループに入ったかどうかが分かる。\n\t\t\t\tif(move==0){\n\t\t\t\t\tfor(k=0;k<FScnt;k++){\n\t\t\t\t\t\tif(FS[k]==P.R*W+P.C){\n\t\t\t\t\t\t\tchk=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(chk==0)break;\n\t\t\t\t\tFScnt++;\n\t\t\t\t\tFS[P.R*W+P.C];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(chk==0){\n\t\t\tprintf(\"impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"%d %d %d\\n\",turn,P.R,P.C);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct tag_Pair{\n\tint R;\n\tint C;\n}Pair;\n\n\nint main(){\n\tint H,W;\n\tchar Map[21][21];\n\tchar Pat[21];\n\tint i,j;\n\t\n\twhile(1){\n\t\tscanf(\"%d %d\",&H,&W);\n\t\tif(!H&&!W)break;\n\t\tfor(i=0;i<H;i++){\n\t\t\tscanf(\"%s\\n\",Map[i]);\n\t\t}\n\t\tscanf(\"%s\\n\",Pat);\n\t\t\n\t\tint turn =0;\n\t\tint M[H][W];\n\t\tPair P;P.R=-1;P.C=-1;\n\t\t\n\t\tfor(i=0;i<H;i++){\n\t\t\tfor(j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=0;\n\t\t\t\tif(Map[i][j]=='B'){\n\t\t\t\t\tP.R=i;\n\t\t\t\t\tP.C=j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint chk=1;\n\t\tint FS[H*W+1];//ハッシュの代わり\n\t\tint FScnt=0;//ハッシュの要素の個数。H*Wが小さいのでO(N)で管理。。。\n\t\tint move;\n\t\tint k;\n\t\tint PatLength=strlen(Pat);\n\t\t\n\t\twhile(1){\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(i=0;i<H;i++){\n\t\t\t\tfor(j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmove=(turn -1)%(PatLength);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t\tif(turn>H*W){\n\t\t\t\t//ループ停止条件：\n\t\t\t\t//turn>H*Wであれば、Aが行けるところにはすべてフラグが立っている\n\t\t\t\t//Bの動きの周期点をturn>H*W以降で観察すれば、Bがループに入ったかどうかが分かる。\n\t\t\t\tif(move==0){\n\t\t\t\t\tfor(k=0;k<FScnt;k++){\n\t\t\t\t\t\tif(FS[k]==P.R*W+P.C){\n\t\t\t\t\t\t\tchk=0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(chk==0)break;\n\t\t\t\t\tFScnt++;\n\t\t\t\t\tFS[P.R*W+P.C];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(chk==0){\n\t\t\tprintf(\"impossible\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"%d %d %d\\n\",turn,P.R,P.C);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ax, ay;\n    int bx, by;\n    int time;\n    int g_pat;\n} GHOST;\n\nGHOST queue[500000];\nint head, tail;\n\nvoid enq(GHOST t)\n{\n    queue[tail % 100000] = t;\n    tail++;\n}\n\nvoid deq(GHOST *t)\n{\n    *t = queue[head % 100000];\n    head++;\n}\n\nint main(void)\n{\n    int x, y;\n    int i, j;\n    int len;\n    char map[21][21];\n    char pattern[11];\n    static char v[21][21][21][21][10];\n    GHOST first, temp;\n    char flag;\n    int dx[4] ={1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int move[5][2] = {{0, 0}, {0, -1}, {1, 0}, {-1, 0}, {0, 1}};\n    while (1){\n        scanf(\"%d%*c%d\", &y, &x);\n        getchar();\n        \n        if (x + y == 0){\n            break;\n        }\n        \n        memset(map, '\\0', sizeof(map));\n        \n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%c\", &map[i][j]);\n                if (map[i][j] == 'A'){\n                    first.ax = j;\n                    first.ay = i;\n                    map[i][j] = '.';\n                }\n                else if (map[i][j] == 'B'){\n                    first.bx = j;\n                    first.by = i;\n                    map[i][j] = '.';\n                }\n            }\n            getchar();\n        }\n        scanf(\"%s\", pattern);\n        getchar();\n        len = strlen(pattern);\n        for (i = 0; i < len; i++){\n            switch (pattern[i]){\n                case '5':\n                pattern[i] = 0;\n                break;\n                \n                case '8':\n                pattern[i] = 1;\n                break;\n                \n                case '6':\n                pattern[i] = 2;\n                break;\n                \n                case '4':\n                pattern[i] = 3;\n                break;\n                \n                case '2':\n                pattern[i] = 4;\n                break;\n            }\n        }\n        first.time = first.g_pat = head = tail = 0;\n        memset(v, 0, sizeof(v));\n        enq(first);\n        flag = 0;\n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.ax == temp.bx && temp.ay == temp.by){\n                flag = 1;\n                break;\n            }\n            \n            for (i = 0; i < 4; i++){\n                if (0 <= temp.ax + dx[i] && temp.ax + dx[i] < x && 0 <= temp.ay + dy[i] && temp.ay + dy[i] < y && map[temp.ay + dy[i]][temp.ax + dx[i]] == '.'){\n                    first.ax = temp.ax + dx[i];\n                    first.ay = temp.ay + dy[i];\n                }\n                \n                if (0 <= temp.bx + move[pattern[temp.g_pat]][0] && temp.bx + move[pattern[temp.g_pat]][0] < x && 0 <= temp.by + move[pattern[temp.g_pat]][1] && temp.by + move[pattern[temp.g_pat]][1] < y){\n                    first.bx = temp.bx + move[pattern[temp.g_pat]][0];\n                    first.by = temp.by + move[pattern[temp.g_pat]][1];\n                }\n                first.g_pat = temp.g_pat + 1;\n                first.g_pat %= len;\n                first.time = temp.time + 1;\n                if (!v[first.ax][first.ay][first.bx][first.by][first.g_pat]){\n                    v[first.ax][first.ay][first.bx][first.by][first.g_pat] = 1;\n                    enq(first);\n                }\n            }\n        }\n        \n        if (flag == 1){\n            printf(\"%d %d %d\\n\", temp.time, temp.ay, temp.ax);\n        }\n        \n        else {\n            printf(\"impossible\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\ntypedef struct {\n    int ax, ay;\n    int bx, by;\n    int time;\n    int g_pat;\n} GHOST;\n\nGHOST queue[100000];\nint head, tail;\n\nvoid enq(GHOST t)\n{\n    queue[tail % 100000] = t;\n    tail++;\n}\n\nvoid deq(GHOST *t)\n{\n    *t = queue[head % 100000];\n    head++;\n}\n\nint main(void)\n{\n    int x, y;\n    int i, j;\n    int len;\n    char map[21][21];\n    char pattern[11];\n    static char v[21][21][21][21][10];\n    GHOST first, temp;\n    char flag;\n    int dx[4] ={1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\n    int move[5][2] = {{0, 0}, {0, -1}, {1, 0}, {-1, 0}, {0, 1}};\n    while (1){\n        scanf(\"%d%*c%d\", &y, &x);\n        getchar();\n        \n        if (x + y == 0){\n            break;\n        }\n        \n        memset(map, '\\0', sizeof(map));\n        \n        for (i = 0; i < y; i++){\n            for (j = 0; j < x; j++){\n                scanf(\"%c\", &map[i][j]);\n                if (map[i][j] == 'A'){\n                    first.ax = j;\n                    first.ay = i;\n                    map[i][j] = '.';\n                }\n                else if (map[i][j] == 'B'){\n                    first.bx = j;\n                    first.by = i;\n                    map[i][j] = '.';\n                }\n            }\n            getchar();\n        }\n        scanf(\"%s\", pattern);\n        getchar();\n        len = strlen(pattern);\n        for (i = 0; i < len; i++){\n            switch (pattern[i]){\n                case '5':\n                pattern[i] = 0;\n                break;\n                \n                case '8':\n                pattern[i] = 1;\n                break;\n                \n                case '6':\n                pattern[i] = 2;\n                break;\n                \n                case '4':\n                pattern[i] = 3;\n                break;\n                \n                case '2':\n                pattern[i] = 4;\n                break;\n            }\n        }\n        first.time = first.g_pat = head = tail = 0;\n        memset(v, 0, sizeof(v));\n        enq(first);\n        flag = 0;\n        while (head != tail){\n            deq(&temp);\n            \n            if (temp.ax == temp.bx && temp.ay == temp.by){\n                flag = 1;\n                break;\n            }\n            \n            for (i = 0; i < 4; i++){\n                if (0 <= temp.ax + dx[i] && temp.ax + dx[i] < x && 0 <= temp.ay + dy[i] && temp.ay + dy[i] < y && map[temp.ay + dy[i]][temp.ax + dx[i]] == '.'){\n                    first.ax = temp.ax + dx[i];\n                    first.ay = temp.ay + dy[i];\n                }\n                \n                if (0 <= temp.bx + move[pattern[temp.g_pat]][0] && temp.bx + move[pattern[temp.g_pat]][0] < x && 0 <= temp.by + move[pattern[temp.g_pat]][1] && temp.by + move[pattern[temp.g_pat]][1] < y){\n                    first.bx = temp.bx + move[pattern[temp.g_pat]][0];\n                    first.by = temp.by + move[pattern[temp.g_pat]][1];\n                }\n                first.g_pat = temp.g_pat + 1;\n                first.g_pat %= len;\n                first.time = temp.time + 1;\n                if (!v[first.ax][first.ay][first.bx][first.by][first.g_pat]){\n                    v[first.ax][first.ay][first.bx][first.by][first.g_pat] = 1;\n                    enq(first);\n                }\n            }\n        }\n        \n        if (flag == 1){\n            printf(\"%d %d %d\\n\", temp.time, temp.ay, temp.ax);\n        }\n        \n        else {\n            printf(\"impossible\\n\");\n        }\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nconst int d[5][2] = {{1, 0}, {0, -1}, {0, 1}, {-1, 0}, {0, 0}};\n\n#define INF 99999\n\nint H, W;\nchar map[32][32];\n\nint mincost[32][32];\n\nvoid get_mincost(void) {\n\tint queue_start, queue_end;\n\tstatic int queue[32 * 32][3];\n\tint i, j;\n\tqueue_start = queue_end = 0;\n\tfor (i = 0; i < H; i++) {\n\t\tfor (j = 0; j < W; j++) {\n\t\t\tif (map[i][j] == 'A') {\n\t\t\t\tmincost[i][j] = 0;\n\t\t\t\tqueue[queue_end][0] = i;\n\t\t\t\tqueue[queue_end][1] = j;\n\t\t\t\tqueue[queue_end][2] = 0;\n\t\t\t\tqueue_end++;\n\t\t\t} else {\n\t\t\t\tmincost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t}\n\twhile (queue_start < queue_end) {\n\t\tint y = queue[queue_start][0];\n\t\tint x = queue[queue_start][1];\n\t\tint cost = queue[queue_start][2];\n\t\tqueue_start++;\n\t\tfor (i = 0; i < 4; i++) {\n\t\t\tint ny = y + d[i][0];\n\t\t\tint nx = x + d[i][1];\n\t\t\tif (0 <= ny && ny < H && 0 <= nx && nx < W && map[ny][nx] != '#' && cost + 1 < mincost[ny][nx]) {\n\t\t\t\tmincost[ny][nx] = cost + 1;\n\t\t\t\tqueue[queue_end][0] = ny;\n\t\t\t\tqueue[queue_end][1] = nx;\n\t\t\t\tqueue[queue_end][2] = cost + 1;\n\t\t\t\tqueue_end++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(void) {\n\twhile (scanf(\"%d%d\", &H, &W) == 2 && (H > 0 || W > 0)) {\n\t\tchar puttern[32];\n\t\tint i, j;\n\t\tint t;\n\t\tint gy = -1, gx = -1, gp = 0, ngy, ngx, gpid;\n\t\tfor (i = 0; i < H; i++) {\n\t\t\tif (scanf(\"%s\", map[i]) != 1) return 1;\n\t\t\tfor (j = 0; j < W; j++) {\n\t\t\t\tif (map[i][j] == 'B') {\n\t\t\t\t\tgy = i;\n\t\t\t\t\tgx = j;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (gy < 0 || gx < 0) return 1;\n\t\tif (scanf(\"%s\", puttern) != 1) return 1;\n\t\tget_mincost();\n\t\tfor (t = 0; t < INF; t++) {\n\t\t\tif (mincost[gy][gx] <= t) {\n\t\t\t\tprintf(\"%d %d %d\\n\", t, gy, gx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tgpid = (puttern[gp] == '5' ? 4 : (puttern[gp] - '2') / 2);\n\t\t\tngy = gy + d[gpid][0];\n\t\t\tngx = gx + d[gpid][1];\n\t\t\tif (0 <= ngy && ngy < H && 0 <= ngx && ngx < W) {\n\t\t\t\tgy = ngy;\n\t\t\t\tgx = ngx;\n\t\t\t}\n\t\t\tgp++;\n\t\t\tif (puttern[gp] == '\\0') gp = 0;\n\t\t}\n\t\tif (t >= INF) puts(\"impossible\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t//test for commit\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\ttry{\n\t\t\t\t\tsimulate(bx, by, pattern);\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\t// calc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\t// simulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 30);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\tdp[ay][ax] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step;\n\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[ny][nx] < step + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[ny][nx] = step + 1;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step + 1));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tint e;\n\t\t\tfor (e = 0; e < 10000; e++) {\n\t\t\t\tif (dp[by][bx] <= e)\n\t\t\t\t\tbreak;\n\t\t\t\tchar o = p[e % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out.println(e < 10000 ? e + \" \" + by + \" \" + bx\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \\t\");\n\t\t\t\tif(strs.length < 2) return;\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\tprintMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\tif(strs.length < 2) return;\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\t// calc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\t/*\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\t// simulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int w,h,ax,ay,bx,by;\n\tstatic int[][] field,already;\n\tstatic int[] v1={1,0,-1,0};\n\tstatic int[] v2={0,-1,0,1};\n\tstatic int[] vv1={0,0,1,0,0,0,0,0,-1};\n\tstatic int[] vv2={0,0,0,0,-1,0,1,0,0};\n\tpublic static void main(String[] args) {\n\t\tScanner cin=new Scanner(System.in);\n\t\twhile(true){\n\t\t\th=cin.nextInt();\n\t\t\tw=cin.nextInt();\n\t\t\tfield=new int[h][w];\n\t\t\talready=new int[h][w];\n\t\t\tif(h+w==0)break;\n\t\t\tQueue<int[]> q=new LinkedList<int[]>();\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tString s=cin.next();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(s.charAt(j)=='.'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.charAt(j)=='#'){\n\t\t\t\t\t\tfield[i][j]=1000;\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.charAt(j)=='A'){\n\t\t\t\t\t\tax=i;\n\t\t\t\t\t\tay=j;\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t\tq.add(new int[]{ax,ay});\n\t\t\t\t\t}\n\t\t\t\t\telse if(s.charAt(j)=='B'){\n\t\t\t\t\t\tfield[i][j]=-1;\n\t\t\t\t\t\tbx=i;\n\t\t\t\t\t\tby=j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString pat=cin.next();\n\t\t\tint cnt=-1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint size=q.size();\n\t\t\t\tcnt++;\n\t\t\t\tfor(int sss=0;sss<size;sss++){\n\t\t\t\t\tint[] a=q.poll();\n\t\t\t\t\tint x=a[0];\n\t\t\t\t\tint y=a[1];\n\t\t\t\t\tfield[x][y]=cnt;\n\t\t\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\t\t\tint xx=x+v1[i];\n\t\t\t\t\t\tint yy=y+v2[i];\n\t\t\t\t\t\tif(xx<0||xx>=h||yy<0||yy>=w||field[xx][yy]!=-1)continue;\n\t\t\t\t\t\tfield[xx][yy]=cnt+1;\n\t\t\t\t\t\tq.add(new int[]{xx,yy});\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}cnt=0;\n//\t\t\toutput();\n\t\t\tint nowx=bx,nowy=by,ans=10000,ansx=-1,ansy=-1;\n\t\t\twhile(true){\n\t\t\t\tint p=pat.charAt(cnt%pat.length())-'0';\n\t\t\t\tnowx+=vv1[p];\n\t\t\t\tnowy+=vv2[p];\n\t\t\t\tif(nowx<0)nowx=0;\n\t\t\t\tif(nowy<0)nowy=0;\n\t\t\t\tif(nowx>=h)nowx=h-1;\n\t\t\t\tif(nowy>=w)nowy=w-1;\n\t\t\t\tcnt++;\n\t\t\t\tif(field[nowx][nowy]!=-1&&field[nowx][nowy]<=cnt){\n//\t\t\t\t\tans=Math.min(ans, cnt);\n\t\t\t\t\tif(ans>cnt){\n\t\t\t\t\t\tans=cnt;\n\t\t\t\t\t\tansx=nowx;\n\t\t\t\t\t\tansy=nowy;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint x=cnt%pat.length();\n\t\t\t\tif((already[nowx][nowy]>>x)%2==1){\n\t\t\t\t\tif(cnt>=h*w)\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\talready[nowx][nowy]=already[nowx][nowy]|(1<<x);\n\t\t\t}\n\t\t\tif(ans==10000){\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(ans+\" \"+ansx+\" \"+ansy);\n\t\t\t}\n\t\t}\n\t}\n\tstatic void output(){\n\t\tfor(int i=0;i<h;i++){\n\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\tSystem.out.print(field[i][j]+\" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\tif(strs.length < 2) return;\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\tprintMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t//test for commit\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\ttry{\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t}catch(Exception e){\n\t\t\tcalc();\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\t// HashSet<String> hs = new HashSet<String>();\n\t\t\tint allcnt = 0;\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tboolean visit[][][][][] = new boolean[H][W][H][W][9];\n\t\t\tQueue<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW));\n\t\t\tint nowGohostH = goH;\n\t\t\tint nowGohostW = goW;\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == nowGohostH && now.girlW == nowGohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\t// hs.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t// + \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now.girlH + dy[i];\n\t\t\t\t\t\tgirl_nextW = now.girlW + dx[i];\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostH && nowGohostH < H\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostW && nowGohostW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW);\n\t\t\t\t\t\t\tif (!visit[next.girlH][next.girlW][nowGohostH][nowGohostW][Integer.valueOf(exe-'0')]) {\n\t\t\t\t\t\t\t\tvisit[next.girlH][next.girlW][nowGohostH][nowGohostW][Integer.valueOf(exe-'0')] = true;\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t\tallcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif (roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t\tif (exe == '5') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[4];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[4];\n\t\t\t\t}\n\t\t\t\tif (exe == '8') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[3];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[3];\n\t\t\t\t}\n\t\t\t\tif (exe == '6') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[0];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[0];\n\t\t\t\t}\n\t\t\t\tif (exe == '4') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[2];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[2];\n\t\t\t\t}\n\t\t\t\tif (exe == '2') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[1];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[1];\n\t\t\t\t}\n\t\t\t\tif (nowGohostH < 0) {\n\t\t\t\t\tnowGohostH = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostH == H) {\n\t\t\t\t\tnowGohostH = H - 1;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW < 0) {\n\t\t\t\t\tnowGohostW = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW == W) {\n\t\t\t\t\tnowGohostW = W - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\n\t\tpublic Info(int girlH, int girlW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew AOJ_1046().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int h, w;\n\tstatic int s[][];\n\tstatic Queue<Q> queue = new LinkedList<Q>(); \n\n\tstatic class Q {\n\t\tint x, y;\n\t\tint k;\n\n\t\tQ(int x, int y, int k) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.k = k;\n\t\t}\n\t}\n\n\tpublic static void f(int x, int y, int k) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y || s[y][x] != -1) {\n\t\t\treturn ;\n\t\t}\n\t\ts[y][x] = k;\n\t\tqueue.add(new Q(x + 1, y, k + 1));\n\t\tqueue.add(new Q(x - 1, y, k + 1));\n\t\tqueue.add(new Q(x, y + 1, k + 1));\n\t\tqueue.add(new Q(x, y - 1, k + 1));\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tQ q = queue.poll();\n\t\t\tf(q.x, q.y, q.k);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = 0, sy = 0;\n\t\tint gx = 0, gy = 0;\n\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ts[i][j] = str.charAt(j);\n\t\t\t\t\tif (s[i][j] == '.') {\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == '#') {\n\t\t\t\t\t\ts[i][j] = -2;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == 'A') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == 'B') {\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue.clear();\n\t\t\tf(sx, sy, 0);\n\n\t\t\tString k = sc.next();\n\t\t\tint min = 1 << 29;\n\t\t\tint ansx = -1, ansy = -1;\n\t\t\tfor (int i = 0; i < 25; i++) {\n\t\t\t\tfor (int j = 0; j < k.length(); j++) {\n\t\t\t\t\tif (0 <= s[gy][gx] && s[gy][gx] <= k.length() * i + j) {\n\t\t\t\t\t\tif (k.length() * i + j < min) {\n\t\t\t\t\t\t\tmin = k.length() * i + j;\n\t\t\t\t\t\t\tansx = gx;\n\t\t\t\t\t\t\tansy = gy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k.charAt(j) == '2') {\n\t\t\t\t\t\tgy++;\n\t\t\t\t\t\tgy = Math.min(gy, h - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '4') {\n\t\t\t\t\t\tgx--;\n\t\t\t\t\t\tgx = Math.max(gx, 0);\n\t\t\t\t\t} else if (k.charAt(j) == '6') {\n\t\t\t\t\t\tgx++;\n\t\t\t\t\t\tgx = Math.min(gx, w - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '8') {\n\t\t\t\t\t\tgy--;\n\t\t\t\t\t\tgy = Math.max(gy, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ansx < 0) {\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(min + \" \" + ansy + \" \" + ansx);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" 　\");\n\t\t\t\tif(strs.length < 2) continue;\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t//printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 10);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step;\n\t\t\t\tif (dp[y][x] < step)\n\t\t\t\t\tcontinue;\n\t\t\t\tdp[y][x] = step;\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step + 1));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tint e;\n\t\t\tfor (e = 0; e < 10000; e++) {\n\t\t\t\tif (dp[by][bx] <= e)\n\t\t\t\t\tbreak;\n\t\t\t\tchar o = p[e % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out.println(e < 10000 ? e + \" \" + by + \" \" + bx\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" 　\");\n\t\t\t\tif(strs.length < 2) return;\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t//printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int h, w;\n\tstatic int s[][];\n\tstatic Queue<Q> queue = new LinkedList<Q>(); \n\t\n\tstatic class Q {\n\t\tint x, y;\n\t\tint k;\n\t\t\n\t\tQ(int x, int y, int k) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.k = k;\n\t\t}\n\t}\n\n\tpublic static void f(int x, int y, int k) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y || s[y][x] != -1) {\n\t\t\treturn ;\n\t\t}\n\t\ts[y][x] = k;\n\t\tqueue.add(new Q(x + 1, y, k + 1));\n\t\tqueue.add(new Q(x - 1, y, k + 1));\n\t\tqueue.add(new Q(x, y + 1, k + 1));\n\t\tqueue.add(new Q(x, y - 1, k + 1));\n\t\t\n\t\twhile (!queue.isEmpty()) {\n\t\t\tQ q = queue.poll();\n\t\t\tf(q.x, q.y, q.k);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = 0, sy = 0;\n\t\tint gx = 0, gy = 0;\n\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ts[i][j] = str.charAt(j);\n\t\t\t\t\tif (s[i][j] == '.') {\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == '#') {\n\t\t\t\t\t\ts[i][j] = -2;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == 'A') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == 'B') {\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(sx, sy, 0);\n\n\t\t\tsc.nextLine();\n\t\t\tString k = sc.next();\n\t\t\tint min = 1 << 29;\n\t\t\tint ansx = -1, ansy = -1;\n\t\t\tfor (int i = 0; i < 25; i++) {\n\t\t\t\tfor (int j = 0; j < k.length(); j++) {\n\t\t\t\t\tif (0 <= s[gy][gx] && s[gy][gx] <= k.length() * i + j) {\n\t\t\t\t\t\tif (k.length() * i + j < min) {\n\t\t\t\t\t\t\tmin = k.length() * i + j;\n\t\t\t\t\t\t\tansx = gx;\n\t\t\t\t\t\t\tansy = gy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k.charAt(j) == '2') {\n\t\t\t\t\t\tgy++;\n\t\t\t\t\t\tgy = Math.min(gy, h - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '4') {\n\t\t\t\t\t\tgx--;\n\t\t\t\t\t\tgx = Math.max(gx, 0);\n\t\t\t\t\t} else if (k.charAt(j) == '6') {\n\t\t\t\t\t\tgx++;\n\t\t\t\t\t\tgx = Math.min(gx, w - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '8') {\n\t\t\t\t\t\tgy--;\n\t\t\t\t\t\tgy = Math.max(gy, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ansx < 0) {\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(min + \" \" + ansy + \" \" + ansx);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint h=sc.nextInt(), w=sc.nextInt();\n\t\t\tif(h==0 && w==0) break;\n\t\t\tchar[][] map = new char[h][w];\n\n\t\t\tint ax=-1, ay=-1, bx=-1, by=-1;\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tmap[i] = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tif(map[i][j] == 'A'){\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(map[i][j] == 'B'){\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tchar[] op = sc.next().toCharArray();\n\t\t\tint x = bx, y = by;\n\t\t\tint ans = -1;\n\n\t\t\tfor(int cost=0;cost<10000;cost++){\n\t\t\t\tif(map[y][x] == '.'){\n\t\t\t\t\tint costAB = getCost(ax,ay,x,y,map);\n\t\t\t\t\tif(costAB <= cost){\n\t\t\t\t\t\tans = cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tswitch(op[cost%op.length]){\n\t\t\t\tcase '8': if(y-1>=0) y--; break;\n\t\t\t\tcase '6': if(x+1<w) x++; break;\n\t\t\t\tcase '4': if(x-1>=0) x--; break;\n\t\t\t\tcase '2': if(y+1<h) y++; break;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(ans == -1) System.out.println(\"impossible\");\n\t\t\telse System.out.printf(\"%d %d %d\\n\",ans,y,x);\n\t\t}\n\t}\n\n\tstatic int[] dx = {0,0,1,-1};\n\tstatic int[] dy = {1,-1,0,0};\n\n\tprivate static int getCost(int sx,int sy,int gx,int gy,char[][] map){\n\t\tQueue<State> open = new LinkedList<State>();\n\t\tHashSet<State> closed = new HashSet<State>();\n\n\t\topen.add(new State(sx,sy,0));\n\n\t\tint ans = Integer.MAX_VALUE;\n\t\twhile(!open.isEmpty()){\n\t\t\tState st = open.poll();\n\t\t\tif(closed.contains(st)) continue;\n\t\t\tclosed.add(st);\n\t\t\tif(st.x == gx && st.y == gy){\n\t\t\t\tans = st.cost;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i=0;i<4;i++){\n\t\t\t\tint nx = st.x + dx[i];\n\t\t\t\tint ny = st.y + dy[i];\n\t\t\t\tif(nx>=0 && nx<map[0].length && ny>=0 && ny<map.length && map[ny][nx]=='.'){\n\t\t\t\t\topen.add(new State(nx,ny,st.cost+1));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tpublic static class State{\n\t\tint x,y,cost;\n\n\t\tState(int x,int y,int cost){\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\tpublic boolean equals(Object o){\n\t\t\tState st = (State)o;\n\t\t\treturn this.x == st.x && this.y == st.y;\n\t\t}\n\n\t\tpublic int hashCode(){\n\t\t\treturn this.x * 100 + this.y;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\tif(strs.length < 2) continue;\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t//printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t//test for commit\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry{\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\ttry{\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t}catch(Exception e){\n\t\t\tcalc();\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\t// HashSet<String> hs = new HashSet<String>();\n\t\t\tint allcnt = 0;\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tboolean visit[][][][][] = new boolean[H][W][H][W][9];\n\t\t\tQueue<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW));\n\t\t\tint nowGohostH = goH;\n\t\t\tint nowGohostW = goW;\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == nowGohostH && now.girlW == nowGohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\t// hs.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t// + \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now.girlH + dy[i];\n\t\t\t\t\t\tgirl_nextW = now.girlW + dx[i];\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostH && nowGohostH < H\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostW && nowGohostW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW);\n\t\t\t\t\t\t\tif (!visit[next.girlH][next.girlW][nowGohostH][nowGohostW][Integer.valueOf(exe-'0')]) {\n\t\t\t\t\t\t\t\tvisit[next.girlH][next.girlW][nowGohostH][nowGohostW][Integer.valueOf(exe-'0')] = true;\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t\tallcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif (roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t\tif (exe == '5') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[4];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[4];\n\t\t\t\t}\n\t\t\t\tif (exe == '8') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[3];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[3];\n\t\t\t\t}\n\t\t\t\tif (exe == '6') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[0];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[0];\n\t\t\t\t}\n\t\t\t\tif (exe == '4') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[2];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[2];\n\t\t\t\t}\n\t\t\t\tif (exe == '2') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[1];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[1];\n\t\t\t\t}\n\t\t\t\tif (nowGohostH < 0) {\n\t\t\t\t\tnowGohostH = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostH == H) {\n\t\t\t\t\tnowGohostH = H - 1;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW < 0) {\n\t\t\t\t\tnowGohostW = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW == W) {\n\t\t\t\t\tnowGohostW = W - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\n\t\tpublic Info(int girlH, int girlW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\tHashSet<String> hs = new HashSet<String>();\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tLinkedList<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW, goH, goW));\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == now.gohostH && now.girlW == now.gohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\ths.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t\t\t+ \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tint gohost_nextH = 0;\n\t\t\t\t\tint gohost_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now.girlH + dy[i];\n\t\t\t\t\t\tgirl_nextW = now.girlW + dx[i];\n\t\t\t\t\t\tif (exe == '5') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[4];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '8') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[3];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '6') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[0];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '4') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[2];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '2') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[1];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextH < 0) {\n\t\t\t\t\t\t\tgohost_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextH == H) {\n\t\t\t\t\t\t\tgohost_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextW < 0) {\n\t\t\t\t\t\t\tgohost_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextW == W) {\n\t\t\t\t\t\t\tgohost_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= gohost_nextH && gohost_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= gohost_nextW && gohost_nextW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW,\n\t\t\t\t\t\t\t\t\tgohost_nextH, gohost_nextW);\n\t\t\t\t\t\t\tif (!hs.contains(next.girlH + \"-\" + next.girlW\n\t\t\t\t\t\t\t\t\t+ \"-\" + next.gohostH + \"-\" + next.gohostW)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif(roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\t\tint gohostH;\n\t\tint gohostW;\n\n\t\tpublic Info(int girlH, int girlW, int gohostH, int gohostW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t\tthis.gohostH = gohostH;\n\t\t\tthis.gohostW = gohostW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\t// calc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\t/*\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\t// simulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t//test for commit\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t// e.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk> {\n\t\tint s_x_pos;\n\t\tint s_y_pos;\n\t\tint g_x_pos;\n\t\tint g_y_pos;\n\t\tint time;\n\t\t\n\t\tpublic Walk(int s_x_pos, int s_y_pos, int g_x_pos, int g_y_pos, int time) {\n\t\t\tsuper();\n\t\t\tthis.s_x_pos = s_x_pos;\n\t\t\tthis.s_y_pos = s_y_pos;\n\t\t\tthis.g_x_pos = g_x_pos;\n\t\t\tthis.g_y_pos = g_y_pos;\n\t\t\tthis.time = time;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.time - arg0.time;\n\t\t}\n\t}\n\t\n\tpublic static int[][] move_dir = new int[][]{{1,0}, {-1,0}, {0, 1}, {0, -1}, {0, 0}};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][][][] is_visited = new boolean[20][20][20][20][10];\n\t\tboolean[][] is_wall = new boolean[20][20];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\t\tfor(int l = 0; l < w; l++){\n\t\t\t\t\t\t\tArrays.fill(is_visited[i][j][k][l], false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tis_wall[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint s_x = -1, s_y = -1, g_x = -1, g_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(input[j] == 'A'){\n\t\t\t\t\t\ts_x = j;\n\t\t\t\t\t\ts_y = i;\n\t\t\t\t\t}else if(input[j] == 'B'){\n\t\t\t\t\t\tg_x = j;\n\t\t\t\t\t\tg_y = i;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(input[j] == '#'){\n\t\t\t\t\t\tis_wall[i][j] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tis_wall[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchar[] pattern = sc.next().toCharArray();\n\t\t\t\n\t\t\tLinkedList<Walk> queue = new LinkedList<Main.Walk>();\n\t\t\tqueue.add(new Walk(s_x, s_y, g_x, g_y, 0));\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tfinal int pat_time = walk.time % pattern.length;\n\t\t\t\t\n\t\t\t\tif(is_visited[walk.s_y_pos][walk.s_x_pos][walk.g_y_pos][walk.g_x_pos][pat_time]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[walk.s_y_pos][walk.s_x_pos][walk.g_y_pos][walk.g_x_pos][pat_time] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.s_x_pos == walk.g_x_pos && walk.s_y_pos == walk.g_y_pos){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tSystem.out.println(walk.time + \" \" + walk.s_y_pos + \" \" + walk.s_x_pos);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint n_g_x = walk.g_x_pos;\n\t\t\t\tint n_g_y = walk.g_y_pos;\n\t\t\t\tif(pattern[pat_time] == '8'){\n\t\t\t\t\tn_g_y--;\n\t\t\t\t}else if(pattern[pat_time] == '6'){\n\t\t\t\t\tn_g_x++;\n\t\t\t\t}else if(pattern[pat_time] == '4'){\n\t\t\t\t\tn_g_x--;\n\t\t\t\t}else if(pattern[pat_time] == '2'){\n\t\t\t\t\tn_g_y++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(n_g_y < 0 || n_g_y >= h){\n\t\t\t\t\tn_g_y = walk.g_y_pos;\n\t\t\t\t}\n\t\t\t\tif(n_g_x < 0 || n_g_x >= w){\n\t\t\t\t\tn_g_x = walk.g_x_pos;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next_pat_time = (pat_time + 1) % pattern.length;\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = walk.s_x_pos + move[0];\n\t\t\t\t\tfinal int ny = walk.s_y_pos + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(0 > ny || ny >= h ||0 > nx || nx >= w){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_wall[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_visited[ny][nx][n_g_x][n_g_y][next_pat_time]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tqueue.add(new Walk(nx, ny, n_g_x, n_g_y, walk.time + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!flag){\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int h, w;\n\tstatic int s[][];\n\n\tpublic static void f(int x, int y, int k) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y || s[y][x] != -1) {\n\t\t\treturn ;\n\t\t}\n\t\ts[y][x] = k;\n\t\tf(x + 1, y, k + 1);\n\t\tf(x - 1, y, k + 1);\n\t\tf(x, y + 1, k + 1);\n\t\tf(x, y - 1, k + 1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = 0, sy = 0;\n\t\tint gx = 0, gy = 0;\n\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ts[i][j] = str.charAt(j);\n\t\t\t\t\tif (s[i][j] == '.') {\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == '#') {\n\t\t\t\t\t\ts[i][j] = -2;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == 'A') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == 'B') {\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(sx, sy, 0);\n\n\t\t\tsc.nextLine();\n\t\t\tString k = sc.next();\n\t\t\tint min = 1 << 29;\n\t\t\tint ansx = -1, ansy = -1;\n\t\t\tfor (int i = 0; i < 25; i++) {\n\t\t\t\tfor (int j = 0; j < k.length(); j++) {\n\t\t\t\t\tif (0 <= s[gy][gx] && s[gy][gx] <= k.length() * i + j) {\n\t\t\t\t\t\tif (k.length() * i + j < min) {\n\t\t\t\t\t\t\tmin = k.length() * i + j;\n\t\t\t\t\t\t\tansx = gx;\n\t\t\t\t\t\t\tansy = gy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k.charAt(j) == '2') {\n\t\t\t\t\t\tgy++;\n\t\t\t\t\t\tgy = Math.min(gy, h - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '4') {\n\t\t\t\t\t\tgx--;\n\t\t\t\t\t\tgx = Math.max(gx, 0);\n\t\t\t\t\t} else if (k.charAt(j) == '6') {\n\t\t\t\t\t\tgx++;\n\t\t\t\t\t\tgx = Math.min(gx, w - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '8') {\n\t\t\t\t\t\tgy--;\n\t\t\t\t\t\tgy = Math.max(gy, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ansx < 0) {\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(min + \" \" + ansy + \" \" + ansx);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic int h, w;\n\tstatic int s[][];\n\tstatic Queue<Q> queue = new LinkedList<Q>();\n\n\tstatic class Q {\n\t\tint x, y;\n\t\tint k;\n\n\t\tQ(int x, int y, int k) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t\tthis.k = k;\n\t\t}\n\t}\n\n\tpublic static void f(int x, int y, int k) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y || s[y][x] != -1) {\n\t\t\treturn ;\n\t\t}\n\t\ts[y][x] = k;\n\t\tqueue.add(new Q(x + 1, y, k + 1));\n\t\tqueue.add(new Q(x - 1, y, k + 1));\n\t\tqueue.add(new Q(x, y + 1, k + 1));\n\t\tqueue.add(new Q(x, y - 1, k + 1));\n\n\t\twhile (!queue.isEmpty()) {\n\t\t\tQ q = queue.poll();\n\t\t\tf(q.x, q.y, q.k);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = 0, sy = 0;\n\t\tint gx = 0, gy = 0;\n\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ts[i][j] = str.charAt(j);\n\t\t\t\t\tif (s[i][j] == '.') {\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t} else if (s[i][j] == '#') {\n\t\t\t\t\t\ts[i][j] = -2;\n\t\t\t\t\t} else if (s[i][j] == 'A') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t} else if (s[i][j] == 'B') {\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tqueue.clear();\n\t\t\tf(sx, sy, 0);\n\n\t\t\tString k = sc.next();\n\t\t\tint min = 1 << 29;\n\t\t\tint ansx = -1, ansy = -1;\n\t\t\tfor (int i = 0; i < 25; i++) {\n\t\t\t\tfor (int j = 0; j < k.length(); j++) {\n\t\t\t\t\tif (0 <= s[gy][gx] && s[gy][gx] <= k.length() * i + j) {\n\t\t\t\t\t\tif (k.length() * i + j < min) {\n\t\t\t\t\t\t\tmin = k.length() * i + j;\n\t\t\t\t\t\t\tansx = gx;\n\t\t\t\t\t\t\tansy = gy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k.charAt(j) == '2') {\n\t\t\t\t\t\tgy++;\n\t\t\t\t\t\tgy = Math.min(gy, h - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '4') {\n\t\t\t\t\t\tgx--;\n\t\t\t\t\t\tgx = Math.max(gx, 0);\n\t\t\t\t\t} else if (k.charAt(j) == '6') {\n\t\t\t\t\t\tgx++;\n\t\t\t\t\t\tgx = Math.min(gx, w - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '8') {\n\t\t\t\t\t\tgy--;\n\t\t\t\t\t\tgy = Math.max(gy, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (ansx < 0) {\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(min + \" \" + ansy + \" \" + ansx);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t//\t\tHashSet<String> hs = new HashSet<String>();\n\t\t\tboolean visit[][][][] = new boolean[H][W][H][W];\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tLinkedList<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW, goH, goW));\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == now.gohostH && now.girlW == now.gohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\tvisit[now.girlH][now.girlW][now.gohostH][now.gohostW] = true;\n//\t\t\t\t\ths.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t//\t\t\t\t\t\t+ \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tint gohost_nextH = 0;\n\t\t\t\t\tint gohost_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now.girlH + dy[i];\n\t\t\t\t\t\tgirl_nextW = now.girlW + dx[i];\n\t\t\t\t\t\tif (exe == '5') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[4];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[4];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '8') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[3];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[3];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '6') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[0];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '4') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[2];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '2') {\n\t\t\t\t\t\t\tgohost_nextW = now.gohostW + dx[1];\n\t\t\t\t\t\t\tgohost_nextH = now.gohostH + dy[1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextH < 0) {\n\t\t\t\t\t\t\tgohost_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextH == H) {\n\t\t\t\t\t\t\tgohost_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextW < 0) {\n\t\t\t\t\t\t\tgohost_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextW == W) {\n\t\t\t\t\t\t\tgohost_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= gohost_nextH && gohost_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= gohost_nextW && gohost_nextW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW,\n\t\t\t\t\t\t\t\t\tgohost_nextH, gohost_nextW);\n\t\t\t\t\t\t\tif (!visit[next.girlH][next.girlW][next.gohostH][next.gohostW]) {\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif(roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\t\tint gohostH;\n\t\tint gohostW;\n\n\t\tpublic Info(int girlH, int girlW, int gohostH, int gohostW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t\tthis.gohostH = gohostH;\n\t\t\tthis.gohostW = gohostW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tpublic static class Walk implements Comparable<Walk> {\n\t\tint s_x_pos;\n\t\tint s_y_pos;\n\t\tint g_x_pos;\n\t\tint g_y_pos;\n\t\tint time;\n\t\t\n\t\tpublic Walk(int s_x_pos, int s_y_pos, int g_x_pos, int g_y_pos, int time) {\n\t\t\tsuper();\n\t\t\tthis.s_x_pos = s_x_pos;\n\t\t\tthis.s_y_pos = s_y_pos;\n\t\t\tthis.g_x_pos = g_x_pos;\n\t\t\tthis.g_y_pos = g_y_pos;\n\t\t\tthis.time = time;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.time - arg0.time;\n\t\t}\n\t}\n\t\n\tpublic static int[][] move_dir = new int[][]{{1,0}, {-1,0}, {0, 1}, {0, -1}, {0, 0}};\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tboolean[][][][][] is_visited = new boolean[20][20][20][20][10];\n\t\tboolean[][] is_wall = new boolean[20][20];\n\t\t\n\t\twhile(true){\n\t\t\tfinal int h = sc.nextInt();\n\t\t\tfinal int w = sc.nextInt();\n\t\t\t\n\t\t\tif(h == 0 && w == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tfor(int k = 0; k < h; k++){\n\t\t\t\t\t\tfor(int l = 0; l < w; l++){\n\t\t\t\t\t\t\tArrays.fill(is_visited[i][j][k][l], false);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tis_wall[i][j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint s_x = -1, s_y = -1, g_x = -1, g_y = -1;\n\t\t\t\n\t\t\tfor(int i = 0; i < h; i++){\n\t\t\t\tchar[] input = sc.next().toCharArray();\n\t\t\t\t\n\t\t\t\tfor(int j = 0; j < w; j++){\n\t\t\t\t\tif(input[j] == 'A'){\n\t\t\t\t\t\ts_x = j;\n\t\t\t\t\t\ts_y = i;\n\t\t\t\t\t}else if(input[j] == 'B'){\n\t\t\t\t\t\tg_x = j;\n\t\t\t\t\t\tg_y = i;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif(input[j] == '#'){\n\t\t\t\t\t\tis_wall[i][j] = true;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tis_wall[i][j] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tchar[] pattern = sc.next().toCharArray();\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Main.Walk>();\n\t\t\tqueue.add(new Walk(s_x, s_y, g_x, g_y, 0));\n\t\t\t\n\t\t\tboolean flag = false;\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tfinal int pat_time = walk.time % pattern.length;\n\t\t\t\t\n\t\t\t\tif(is_visited[walk.s_y_pos][walk.s_x_pos][walk.g_y_pos][walk.g_x_pos][pat_time]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}else{\n\t\t\t\t\tis_visited[walk.s_y_pos][walk.s_x_pos][walk.g_y_pos][walk.g_x_pos][pat_time] = true;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.s_x_pos == walk.g_x_pos && walk.s_y_pos == walk.g_y_pos){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tSystem.out.println(walk.time + \" \" + walk.s_y_pos + \" \" + walk.s_x_pos);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint n_g_x = walk.g_x_pos;\n\t\t\t\tint n_g_y = walk.g_y_pos;\n\t\t\t\tif(pattern[pat_time] == '8'){\n\t\t\t\t\tn_g_y--;\n\t\t\t\t}else if(pattern[pat_time] == '6'){\n\t\t\t\t\tn_g_x++;\n\t\t\t\t}else if(pattern[pat_time] == '4'){\n\t\t\t\t\tn_g_x--;\n\t\t\t\t}else if(pattern[pat_time] == '2'){\n\t\t\t\t\tn_g_y++;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(n_g_y < 0 || n_g_y >= h){\n\t\t\t\t\tn_g_y = walk.g_y_pos;\n\t\t\t\t}\n\t\t\t\tif(n_g_x < 0 || n_g_x >= w){\n\t\t\t\t\tn_g_x = walk.g_x_pos;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfinal int next_pat_time = (pat_time + 1) % pattern.length;\n\t\t\t\t\n\t\t\t\tfor(int[] move : move_dir){\n\t\t\t\t\tfinal int nx = walk.s_x_pos + move[0];\n\t\t\t\t\tfinal int ny = walk.s_y_pos + move[1];\n\t\t\t\t\t\n\t\t\t\t\tif(0 > ny || ny >= h ||0 > nx || nx >= w){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_wall[ny][nx]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}else if(is_visited[ny][nx][n_g_x][n_g_y][next_pat_time]){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tqueue.add(new Walk(nx, ny, n_g_x, n_g_y, walk.time + 1));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif(!flag){\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t}\n\t\t\t\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 30);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\tdp[ay][ax] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step;\n\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[ny][nx] <= step + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[ny][nx] = step + 1;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step + 1));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tint e;\n\t\t\tfor (e = 0; e < 500; e++) {\n\t\t\t\tif (dp[by][bx] <= e)\n\t\t\t\t\tbreak;\n\t\t\t\tchar o = p[e % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out.println(e < 500 ? e + \" \" + by + \" \" + bx\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 30);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\tdp[ay][ax] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step + 1;\n\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[ny][nx] <= step)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[ny][nx] = step;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tint e;\n\t\t\tfor (e = 0; e < 200; e++) {\n\t\t\t\tif (dp[by][bx] <= e)\n\t\t\t\t\tbreak;\n\t\t\t\tchar o = p[e % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out\n\t\t\t\t\t.println(e < 200 ? e + \" \" + by + \" \" + bx : \"impossible\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\t/*\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t*/\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\t// calc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\t// simulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\tif(strs.length < 2) return;\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t//printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n  int[] dx = {0,1,0,-1,0};\n  int[] dy = {0,0,1,0,-1};\n  int h,w,ay,ax,by,bx;\n  String ghostpat;\n  int patiter;\n  int[][] mp;\n  int qiter;\n  int[][][] queue;\n  int[] qsize;\n  int nowdist,ans;\n  public static void main(String[] args){\n    new Main();\n  }\n  void step(){\n    // ghost step\n    {\n      int id = 0;\n      char c = ghostpat.charAt(patiter);\n      if(c=='5')id = 0;\n      else if(c=='6')id = 1;\n      else if(c=='2')id = 2;\n      else if(c=='4')id = 3;\n      else if(c=='8')id = 4;\n      int nby = by+dy[id];\n      int nbx = bx+dx[id];\n      if(0<=nby && nby<h && 0<=nbx && nbx<w){\n        by = nby;\n        bx = nbx;\n      }\n      patiter ++;\n      if(patiter >= ghostpat.length()){\n        patiter = 0;\n      }\n    }\n    // player step\n    {\n      int now = qiter;\n      int nxt = now^1;\n      qsize[nxt] = 0;\n      for(int i=0;i<qsize[now];i++){\n        int y = queue[now][i][0];\n        int x = queue[now][i][1];\n        // System.out.println(y+\" \"+x);\n        for(int j=1;j<5;j++){\n          int ny = y+dy[j];\n          int nx = x+dx[j];\n          if(ny<0 || nx<0 || ny>=h || nx>=w)continue;\n          if(mp[ny][nx]!=0)continue;\n          mp[ny][nx] = 1;\n          int s = qsize[nxt];\n          queue[nxt][s][0] = ny;\n          queue[nxt][s][1] = nx;\n          qsize[nxt]++;\n        }\n      }\n      qiter ^= 1;\n    }\n    // check\n    if(mp[by][bx]==1){\n      ans = nowdist;\n    }\n  }\n  public Main(){\n    Scanner sc = new Scanner(System.in);\n    while(true){\n      h = sc.nextInt();\n      w = sc.nextInt();\n      if(h==0 && w==0)break;\n      mp = new int[h][w];\n      ay=0;ax=0;by=0;bx=0;\n      for(int i=0;i<h;i++){\n        String s = sc.next();\n        for(int j=0;j<w;j++){\n          char c = s.charAt(j);\n          if(c=='#'){\n            mp[i][j] = -1;\n          }else{\n            mp[i][j] = 0;\n            if(c=='A'){\n              ay = i;\n              ax = j;\n            }else if(c=='B'){\n              by = i;\n              bx = j;\n            }\n          }\n        }\n      }\n      ghostpat = sc.next();\n      patiter = 0;\n      queue = new int[2][1000][2];\n      qsize = new int[2];\n      qiter = 0;\n      queue[0][0][0]=ay;\n      queue[0][0][1]=ax;\n      qsize[0] = 1;\n      mp[ay][ax] = 1;\n      nowdist = 0;\n      ans = -1;\n      for(int i=0;i<10000;i++){\n        nowdist++;\n        step();\n        if(ans!=-1)break;\n      }\n      if(ans!=-1){\n        System.out.println(ans+\" \"+by+\" \"+bx);\n      }else{\n        System.out.println(\"impossible\");\n      }\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 30);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\tdp[ay][ax] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step + 1;\n\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[ny][nx] <= step)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[ny][nx] = step;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tString ans = \"impossible\";\n\t\t\tfor (int i = 0; i < 200; i++) {\n\t\t\t\tif (dp[by][bx] <= i) {\n\t\t\t\t\tans = i + \" \" + by + \" \" + bx;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar o = p[i % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 30);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\tdp[ay][ax] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step;\n\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[ny][nx] <= step + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[ny][nx] = step + 1;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step + 1));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tint e;\n\t\t\tfor (e = 0; e < 1000; e++) {\n\t\t\t\tif (dp[by][bx] <= e)\n\t\t\t\t\tbreak;\n\t\t\t\tchar o = p[e % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out.println(e < 1000 ? e + \" \" + by + \" \" + bx\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t//test for commit\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\t// simulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ttry{\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\t// HashSet<String> hs = new HashSet<String>();\n\t\t\tboolean visit[][][][] = new boolean[H][W][H][W];\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tLinkedList<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW));\n\t\t\tint nowGohostH = goH;\n\t\t\tint nowGohostW = goW;\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == nowGohostH && now.girlW == nowGohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\t// hs.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t// + \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now.girlH + dy[i];\n\t\t\t\t\t\tgirl_nextW = now.girlW + dx[i];\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostH && nowGohostH < H\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostW && nowGohostW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW);\n\t\t\t\t\t\t\tif (!visit[next.girlH][next.girlW][nowGohostH][nowGohostW]) {\n\t\t\t\t\t\t\t\tvisit[now.girlH][now.girlW][nowGohostH][nowGohostW] = true;\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif (roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t\tif (exe == '5') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[4];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[4];\n\t\t\t\t}\n\t\t\t\tif (exe == '8') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[3];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[3];\n\t\t\t\t}\n\t\t\t\tif (exe == '6') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[0];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[0];\n\t\t\t\t}\n\t\t\t\tif (exe == '4') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[2];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[2];\n\t\t\t\t}\n\t\t\t\tif (exe == '2') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[1];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[1];\n\t\t\t\t}\n\t\t\t\tif (nowGohostH < 0) {\n\t\t\t\t\tnowGohostH = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostH == H) {\n\t\t\t\t\tnowGohostH = H - 1;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW < 0) {\n\t\t\t\t\tnowGohostW = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW == W) {\n\t\t\t\t\tnowGohostW = W - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\n\t\tpublic Info(int girlH, int girlW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\t// HashSet<String> hs = new HashSet<String>();\n\t\t\tboolean visit[][][][] = new boolean[H][W][H][W];\n\t\t\tint allcnt = 0;\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tQueue<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW));\n\t\t\tint nowGohostH = goH;\n\t\t\tint nowGohostW = goW;\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == nowGohostH && now.girlW == nowGohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\t// hs.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t// + \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now.girlH + dy[i];\n\t\t\t\t\t\tgirl_nextW = now.girlW + dx[i];\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostH && nowGohostH < H\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostW && nowGohostW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW);\n\t\t\t\t\t\t\tif (!visit[next.girlH][next.girlW][nowGohostH][nowGohostW]) {\n\t\t\t\t\t\t\t\tvisit[next.girlH][next.girlW][nowGohostH][nowGohostW] = true;\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t\tallcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif (roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t\tif (exe == '5') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[4];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[4];\n\t\t\t\t}\n\t\t\t\tif (exe == '8') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[3];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[3];\n\t\t\t\t}\n\t\t\t\tif (exe == '6') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[0];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[0];\n\t\t\t\t}\n\t\t\t\tif (exe == '4') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[2];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[2];\n\t\t\t\t}\n\t\t\t\tif (exe == '2') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[1];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[1];\n\t\t\t\t}\n\t\t\t\tif (nowGohostH < 0) {\n\t\t\t\t\tnowGohostH = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostH == H) {\n\t\t\t\t\tnowGohostH = H - 1;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW < 0) {\n\t\t\t\t\tnowGohostW = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW == W) {\n\t\t\t\t\tnowGohostW = W - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\n\t\tpublic Info(int girlH, int girlW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\t// simulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t/*\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 30);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\tdp[ay][ax] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step;\n\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[ny][nx] < step + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[ny][nx] = step + 1;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step + 1));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tint e;\n\t\t\tfor (e = 0; e < 10000; e++) {\n\t\t\t\tif (dp[by][bx] <= e)\n\t\t\t\t\tbreak;\n\t\t\t\tchar o = p[e % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out.println(e < 10000 ? e + \" \" + by + \" \" + bx\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 30);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\tdp[ay][ax] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step;\n\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[ny][nx] <= step + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[ny][nx] = step + 1;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step + 1));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tint e;\n\t\t\tfor (e = 0; e < 10000; e++) {\n\t\t\t\tif (dp[by][bx] <= e)\n\t\t\t\t\tbreak;\n\t\t\t\tchar o = p[e % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out.println(e < 10000 ? e + \" \" + by + \" \" + bx\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\t// simulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\t/*\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t*/\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" 　\");\n\t\t\t\t// if(strs.length < 2) return;\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t//printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\t// HashSet<String> hs = new HashSet<String>();\n\t\t\tboolean visit[][][][] = new boolean[H][W][H][W];\n\t\t\tint allcnt = 0;\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tQueue<int []> queue = new LinkedList<int []>();\n\t\t\tqueue.add(new int[]{gH,gW});\n\t\t\tint nowGohostH = goH;\n\t\t\tint nowGohostW = goW;\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tint now[] = queue.poll();\n\t\t\t\t\tif (now[0] == nowGohostH && now[1] == nowGohostW) {\n\t\t\t\t\t\tansH = now[0];\n\t\t\t\t\t\tansW = now[1];\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\t// hs.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t// + \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now[0] + dy[i];\n\t\t\t\t\t\tgirl_nextW = now[1] + dx[i];\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostH && nowGohostH < H\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostW && nowGohostW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tint[] next = {girl_nextH, girl_nextW};\n\t\t\t\t\t\t\tif (!visit[next[0]][next[1]][nowGohostH][nowGohostW]) {\n\t\t\t\t\t\t\t\tvisit[next[0]][next[1]][nowGohostH][nowGohostW] = true;\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t\t//allcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif (roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t\tif (exe == '5') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[4];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[4];\n\t\t\t\t}\n\t\t\t\tif (exe == '8') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[3];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[3];\n\t\t\t\t}\n\t\t\t\tif (exe == '6') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[0];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[0];\n\t\t\t\t}\n\t\t\t\tif (exe == '4') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[2];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[2];\n\t\t\t\t}\n\t\t\t\tif (exe == '2') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[1];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[1];\n\t\t\t\t}\n\t\t\t\tif (nowGohostH < 0) {\n\t\t\t\t\tnowGohostH = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostH == H) {\n\t\t\t\t\tnowGohostH = H - 1;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW < 0) {\n\t\t\t\t\tnowGohostW = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW == W) {\n\t\t\t\t\tnowGohostW = W - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t//\t\tSystem.out.println(\" ->\" + allcnt);\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\n\t\tpublic Info(int girlH, int girlW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[] DR = { 1, 0, -1, 0 };\n\tstatic int[] DC = { 0, 1, 0, -1 };\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif (H == 0) break;\n\t\t\tboolean[][] field = new boolean[H][W];\n\t\t\tint ar = 0;\n\t\t\tint ac = 0;\n\t\t\tint br = 0;\n\t\t\tint bc = 0;\n\t\t\tfor (int i = 0; i < H; ++i) {\n\t\t\t\tString line = sc.next();\n\t\t\t\tfor (int j = 0; j < W; ++j) {\n\t\t\t\t\tif (line.charAt(j) == '#') {\n\t\t\t\t\t\tfield[i][j] = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (line.charAt(j) == 'A') {\n\t\t\t\t\t\tar = i;\n\t\t\t\t\t\tac = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (line.charAt(j) == 'B') {\n\t\t\t\t\t\tbr = i;\n\t\t\t\t\t\tbc = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString pattern = sc.next();\n\t\t\tint[][] turn = new int[H][W];\n\t\t\tfor (int[] a : turn) {\n\t\t\t\tArrays.fill(a, -1);\n\t\t\t}\n\t\t\tArrayList<Point> cur = new ArrayList<Point>();\n\t\t\tturn[ar][ac] = 0;\n\t\t\tcur.add(new Point(ar, ac));\n\t\t\tint t = 1;\n\t\t\twhile (!cur.isEmpty()) {\n\t\t\t\tArrayList<Point> next = new ArrayList<Point>();\n\t\t\t\tfor (Point p : cur) {\n\t\t\t\t\tfor (int i = 0; i < 4; ++i) {\n\t\t\t\t\t\tint nr = p.x + DR[i];\n\t\t\t\t\t\tint nc = p.y + DC[i];\n\t\t\t\t\t\tif (nr == -1 || nr == H || nc == -1 || nc == W || turn[nr][nc] != -1 || field[nr][nc]) continue;\n\t\t\t\t\t\tturn[nr][nc] = t;\n\t\t\t\t\t\tnext.add(new Point(nr, nc));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcur = next;\n\t\t\t\t++t;\n\t\t\t}\n\t\t\tint ans = Integer.MAX_VALUE;\n\t\t\tint ansR = -1;\n\t\t\tint ansC = -1;\n\t\t\tfor (int i = 0; i < 10000; ++i) {\n\t\t\t\tif (turn[br][bc] != -1 && turn[br][bc] <= i) {\n\t\t\t\t\tans = i;\n\t\t\t\t\tansR = br;\n\t\t\t\t\tansC = bc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tchar q = pattern.charAt(i % pattern.length());\n\t\t\t\tif (q == '8') {\n\t\t\t\t\tif (br != 0) --br;\n\t\t\t\t} else if (q == '6') {\n\t\t\t\t\tif (bc != W - 1) ++bc;\n\t\t\t\t} else if (q == '4') {\n\t\t\t\t\tif (bc != 0) --bc;\n\t\t\t\t} else if (q == '2') {\n\t\t\t\t\tif (br != H - 1) ++br;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (ans == Integer.MAX_VALUE) {\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(ans + \" \" + ansR + \" \" + ansC);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic int h, w;\n\tstatic int s[][];\n\n\tpublic static void f(int x, int y, int k) {\n\t\tif (x < 0 || w <= x || y < 0 || h <= y || s[y][x] != -1) {\n\t\t\treturn ;\n\t\t}\n\t\ts[y][x] = k;\n\t\tf(x + 1, y, k + 1);\n\t\tf(x - 1, y, k + 1);\n\t\tf(x, y + 1, k + 1);\n\t\tf(x, y - 1, k + 1);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint sx = 0, sy = 0;\n\t\tint gx = 0, gy = 0;\n\n\t\twhile (true) {\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif ((h | w) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\ts = new int[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tString str = sc.next();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\ts[i][j] = str.charAt(j);\n\t\t\t\t\tif (s[i][j] == '.') {\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == '#') {\n\t\t\t\t\t\ts[i][j] = -2;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == 'A') {\n\t\t\t\t\t\tsx = j;\n\t\t\t\t\t\tsy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t\tif (s[i][j] == 'B') {\n\t\t\t\t\t\tgx = j;\n\t\t\t\t\t\tgy = i;\n\t\t\t\t\t\ts[i][j] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tf(sx, sy, 0);\n\n\t\t\tsc.nextLine();\n\t\t\tString k = sc.next();\n\t\t\tint min = 1 << 29;\n\t\t\tint ansx = 0, ansy = 0;\n\t\t\tfor (int i = 0; i < 25; i++) {\n\t\t\t\tfor (int j = 0; j < k.length(); j++) {\n\t\t\t\t\tif (0 <= s[gy][gx] && s[gy][gx] <= k.length() * i + j) {\n\t\t\t\t\t\tif (k.length() * i + j < min) {\n\t\t\t\t\t\t\tmin = k.length() * i + j;\n\t\t\t\t\t\t\tansx = gx;\n\t\t\t\t\t\t\tansy = gy;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (k.charAt(j) == '2') {\n\t\t\t\t\t\tgy++;\n\t\t\t\t\t\tgy = Math.min(gy, h - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '4') {\n\t\t\t\t\t\tgx--;\n\t\t\t\t\t\tgx = Math.max(gx, 0);\n\t\t\t\t\t} else if (k.charAt(j) == '6') {\n\t\t\t\t\t\tgx++;\n\t\t\t\t\t\tgx = Math.min(gx, w - 1);\n\t\t\t\t\t} else if (k.charAt(j) == '8') {\n\t\t\t\t\t\tgy--;\n\t\t\t\t\t\tgy = Math.max(gy, 0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (min == 1 << 29) {\n\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t} else {\n\t\t\t\tSystem.out.println(min + \" \" + ansy + \" \" + ansx);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t//test for commit\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\ttry{\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t}catch(Exception e){\n\t\t\tSystem.out.println(\"impossible\");\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tbyte[] dx = { 1, 0, -1, 0, 0 };\n\tbyte[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tbyte H = (byte) sc.nextInt();\n\t\t\tbyte W = (byte) sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\t// HashSet<String> hs = new HashSet<String>();\n\t\t\tboolean visit[][][][] = new boolean[H][W][H][W];\n\t\t\tbyte gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (byte i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (byte j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tLinkedList<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW, goH, goW));\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == now.gohostH && now.girlW == now.gohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\tvisit[now.girlH][now.girlW][now.gohostH][now.gohostW] = true;\n\t\t\t\t\t// hs.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t// + \"-\" + now.gohostW);\n\t\t\t\t\tbyte girl_nextH = 0;\n\t\t\t\t\tbyte girl_nextW = 0;\n\t\t\t\t\tbyte gohost_nextH = 0;\n\t\t\t\t\tbyte gohost_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = (byte) (now.girlH + dy[i]);\n\t\t\t\t\t\tgirl_nextW = (byte) (now.girlW + dx[i]);\n\t\t\t\t\t\tif (exe == '5') {\n\t\t\t\t\t\t\tgohost_nextW = (byte) (now.gohostW + dx[4]);\n\t\t\t\t\t\t\tgohost_nextH = (byte) (now.gohostH + dy[4]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '8') {\n\t\t\t\t\t\t\tgohost_nextW = (byte) (now.gohostW + dx[3]);\n\t\t\t\t\t\t\tgohost_nextH = (byte) (now.gohostH + dy[3]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '6') {\n\t\t\t\t\t\t\tgohost_nextW = (byte) (now.gohostW + dx[0]);\n\t\t\t\t\t\t\tgohost_nextH = (byte) (now.gohostH + dy[0]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '4') {\n\t\t\t\t\t\t\tgohost_nextW = (byte) (now.gohostW + dx[2]);\n\t\t\t\t\t\t\tgohost_nextH = (byte) (now.gohostH + dy[2]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (exe == '2') {\n\t\t\t\t\t\t\tgohost_nextW = (byte) (now.gohostW + dx[1]);\n\t\t\t\t\t\t\tgohost_nextH = (byte) (now.gohostH + dy[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextH < 0) {\n\t\t\t\t\t\t\tgohost_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextH == H) {\n\t\t\t\t\t\t\tgohost_nextH = (byte) (H - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextW < 0) {\n\t\t\t\t\t\t\tgohost_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (gohost_nextW == W) {\n\t\t\t\t\t\t\tgohost_nextW = (byte) (W - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = (byte) (H - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = (byte) (W - 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= gohost_nextH && gohost_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= gohost_nextW && gohost_nextW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW,\n\t\t\t\t\t\t\t\t\tgohost_nextH, gohost_nextW);\n\t\t\t\t\t\t\tif (!visit[next.girlH][next.girlW][next.gohostH][next.gohostW]) {\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif (roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tbyte girlH;\n\t\tbyte girlW;\n\t\tbyte gohostH;\n\t\tbyte gohostW;\n\n\t\tpublic Info(byte girlH, byte girlW, byte gohostH, byte gohostW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t\tthis.gohostH = gohostH;\n\t\t\tthis.gohostW = gohostW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\t// HashSet<String> hs = new HashSet<String>();\n\t\t\tboolean visit[][][][] = new boolean[H][W][H][W];\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tQueue<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW));\n\t\t\tint nowGohostH = goH;\n\t\t\tint nowGohostW = goW;\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == nowGohostH && now.girlW == nowGohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\t// hs.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t// + \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now.girlH + dy[i];\n\t\t\t\t\t\tgirl_nextW = now.girlW + dx[i];\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostH && nowGohostH < H\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostW && nowGohostW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW);\n\t\t\t\t\t\t\tif (!visit[next.girlH][next.girlW][nowGohostH][nowGohostW]) {\n\t\t\t\t\t\t\t\tvisit[now.girlH][now.girlW][nowGohostH][nowGohostW] = true;\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif (roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t\tif (exe == '5') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[4];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[4];\n\t\t\t\t}\n\t\t\t\tif (exe == '8') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[3];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[3];\n\t\t\t\t}\n\t\t\t\tif (exe == '6') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[0];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[0];\n\t\t\t\t}\n\t\t\t\tif (exe == '4') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[2];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[2];\n\t\t\t\t}\n\t\t\t\tif (exe == '2') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[1];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[1];\n\t\t\t\t}\n\t\t\t\tif (nowGohostH < 0) {\n\t\t\t\t\tnowGohostH = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostH == H) {\n\t\t\t\t\tnowGohostH = H - 1;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW < 0) {\n\t\t\t\t\tnowGohostW = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW == W) {\n\t\t\t\t\tnowGohostW = W - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\n\t\tpublic Info(int girlH, int girlW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t//test for commit\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\tcalc();\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Scanner;\n\n//Ghost Buster!\npublic class Main{\n\n\tpublic static int h;\n\tpublic static int w;\n\tpublic static char[] pattern;\n\n\tpublic static char[][] map;\n\tpublic static int[][] opt;\n\tpublic static int[][] move = {{1,0},{0,-1},{0,1},{-1,0},{0,0}};\n\n\tpublic static int dir(char c){\n\t\treturn c=='2'?0:c=='4'?1:c=='6'?2:c=='8'?3:4;\n\t}\n\n\tpublic static int si;\n\tpublic static int sj;\n\tpublic static int ti;\n\tpublic static int tj;\n\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\th = sc.nextInt();\n\t\t\tw = sc.nextInt();\n\t\t\tif(h==0&&w==0)break;\n\t\t\tmap = new char[h][w];\n\t\t\tfor(int i=0;i<h;i++){\n\t\t\t\tchar[] s = sc.next().toCharArray();\n\t\t\t\tfor(int j=0;j<w;j++){\n\t\t\t\t\tmap[i][j] = s[j];\n\t\t\t\t\tif(s[j]=='A'){\n\t\t\t\t\t\tsi = i;\n\t\t\t\t\t\tsj = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t\tif(s[j]=='B'){\n\t\t\t\t\t\tti = i;\n\t\t\t\t\t\ttj = j;\n\t\t\t\t\t\tmap[i][j] = '.';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tpattern = sc.next().toCharArray();\n\t\t\topt = new int[h][w];\n\t\t\tfor(int[]a:opt)Arrays.fill(a, Integer.MAX_VALUE);\n\t\t\topt[si][sj] = 0;\n\t\t\tList<int[]> list = new ArrayList<int[]>();\n\t\t\tlist.add(new int[]{si,sj});\n\t\t\tint dis = 1;\n\t\t\twhile(!list.isEmpty()){\n\t\t\t\tList<int[]> next = new ArrayList<int[]>();\n\t\t\t\tfor(int[] a : list){\n\t\t\t\t\tfor(int k=0;k<4;k++){\n\t\t\t\t\t\tint i = a[0] + move[k][0];\n\t\t\t\t\t\tint j = a[1] + move[k][1];\n\t\t\t\t\t\tif(0<=i&&i<h&&0<=j&&j<w&&map[i][j]=='.'&&opt[i][j]==Integer.MAX_VALUE){\n\t\t\t\t\t\t\topt[i][j] = dis;\n\t\t\t\t\t\t\tnext.add(new int[]{i, j});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist = next;\n\t\t\t\tdis++;\n\t\t\t}\n\t\t\tint ans = 1000;\n\t\t\tint mi = 0;\n\t\t\tint mj = 0;\n\t\t\tint step = 0;\n\t\t\twhile(step <= ans){\n\t\t\t\tif(opt[ti][tj]<=step){\n\t\t\t\t\tif(step < ans){\n\t\t\t\t\t\tans = step;\n\t\t\t\t\t\tmi = ti;\n\t\t\t\t\t\tmj = tj;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint k = dir(pattern[step%pattern.length]);\n\t\t\t\tstep++;\n\t\t\t\tint ni = ti + move[k][0];\n\t\t\t\tint nj = tj + move[k][1];\n\t\t\t\tif(0<=ni&&ni<h&&0<=nj&&nj<w){\n\t\t\t\t\tti = ni;\n\t\t\t\t\ttj = nj;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans==1000?\"impossible\":(ans+\" \" + mi + \" \" + mj));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main {\n\tMyScanner sc = new MyScanner();\n\tScanner sc2 = new Scanner(System.in);\n\tint mod = 1000000007;\n\n\tint[] dx = { 1, 0, -1, 0, 0 };\n\tint[] dy = { 0, 1, 0, -1, 0 };\n\n\tvoid run() {\n\t\tfor (;;) {\n\t\t\tint H = sc.nextInt();\n\t\t\tint W = sc.nextInt();\n\t\t\tif ((H | W) == 0) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tchar[][] field = new char[H][W];\n\t\t\t// HashSet<String> hs = new HashSet<String>();\n\t\t\tint allcnt = 0;\n\t\t\tint gH = 0, gW = 0, goH = 0, goW = 0;\n\t\t\tfor (int i = 0; i < H; i++) {\n\t\t\t\tString input = sc.next();\n\t\t\t\tfor (int j = 0; j < W; j++) {\n\t\t\t\t\tfield[i][j] = input.charAt(j);\n\t\t\t\t\tif (input.charAt(j) == 'A') {\n\t\t\t\t\t\tgH = i;\n\t\t\t\t\t\tgW = j;\n\t\t\t\t\t}\n\t\t\t\t\tif (input.charAt(j) == 'B') {\n\t\t\t\t\t\tgoH = i;\n\t\t\t\t\t\tgoW = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tString direction = sc.next();\n\t\t\tboolean visit[][][][][] = new boolean[H][W][H][W][11];\n\t\t\tQueue<Info> queue = new LinkedList<Info>();\n\t\t\tqueue.add(new Info(gH, gW));\n\t\t\tint nowGohostH = goH;\n\t\t\tint nowGohostW = goW;\n\t\t\tint cnt = 0;\n\t\t\tint ansH = 0;\n\t\t\tint ansW = 0;\n\t\t\tint index = 0;\n\t\t\tboolean able = false;\n\t\t\tint roop = 0;\n\t\t\tlabel: while (!queue.isEmpty()) {\n\t\t\t\tint size = queue.size();\n\t\t\t\tchar exe = direction.charAt(index % direction.length());\n\t\t\t\tfor (int I = 0; I < size; I++) {\n\t\t\t\t\tInfo now = queue.poll();\n\t\t\t\t\tif (now.girlH == nowGohostH && now.girlW == nowGohostW) {\n\t\t\t\t\t\tansH = now.girlH;\n\t\t\t\t\t\tansW = now.girlW;\n\t\t\t\t\t\table = true;\n\t\t\t\t\t\tbreak label;\n\t\t\t\t\t}\n\t\t\t\t\t// hs.add(now.girlH + \"-\" + now.girlW + \"-\" + now.gohostH\n\t\t\t\t\t// + \"-\" + now.gohostW);\n\t\t\t\t\tint girl_nextH = 0;\n\t\t\t\t\tint girl_nextW = 0;\n\t\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\t\tgirl_nextH = now.girlH + dy[i];\n\t\t\t\t\t\tgirl_nextW = now.girlW + dx[i];\n\t\t\t\t\t\tif (girl_nextH < 0) {\n\t\t\t\t\t\t\tgirl_nextH = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextH == H) {\n\t\t\t\t\t\t\tgirl_nextH = H - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW < 0) {\n\t\t\t\t\t\t\tgirl_nextW = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (girl_nextW == W) {\n\t\t\t\t\t\t\tgirl_nextW = W - 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (0 <= girl_nextH && girl_nextH < H\n\t\t\t\t\t\t\t\t&& 0 <= girl_nextW && girl_nextW < W\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostH && nowGohostH < H\n\t\t\t\t\t\t\t\t&& 0 <= nowGohostW && nowGohostW < W\n\t\t\t\t\t\t\t\t&& field[girl_nextH][girl_nextW] != '#') {\n\t\t\t\t\t\t\tInfo next = new Info(girl_nextH, girl_nextW);\n\t\t\t\t\t\t\tif (!visit[next.girlH][next.girlW][nowGohostH][nowGohostW][index\n\t\t\t\t\t\t\t\t\t% direction.length()]) {\n\t\t\t\t\t\t\t\tvisit[next.girlH][next.girlW][nowGohostH][nowGohostW][index\n\t\t\t\t\t\t\t\t\t\t% direction.length()] = true;\n\t\t\t\t\t\t\t\troop = 0;\n\t\t\t\t\t\t\t\tqueue.add(next);\n\t\t\t\t\t\t\t\tallcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\troop++;\n\t\t\t\t\t\tif (roop <= 10) {\n\t\t\t\t\t\t\tqueue.add(now);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcnt++;\n\t\t\t\tindex++;\n\t\t\t\tif (exe == '5') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[4];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[4];\n\t\t\t\t}\n\t\t\t\tif (exe == '8') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[3];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[3];\n\t\t\t\t}\n\t\t\t\tif (exe == '6') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[0];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[0];\n\t\t\t\t}\n\t\t\t\tif (exe == '4') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[2];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[2];\n\t\t\t\t}\n\t\t\t\tif (exe == '2') {\n\t\t\t\t\tnowGohostW = nowGohostW + dx[1];\n\t\t\t\t\tnowGohostH = nowGohostH + dy[1];\n\t\t\t\t}\n\t\t\t\tif (nowGohostH < 0) {\n\t\t\t\t\tnowGohostH = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostH == H) {\n\t\t\t\t\tnowGohostH = H - 1;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW < 0) {\n\t\t\t\t\tnowGohostW = 0;\n\t\t\t\t}\n\t\t\t\tif (nowGohostW == W) {\n\t\t\t\t\tnowGohostW = W - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(able ? cnt + \" \" + ansH + \" \" + ansW\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tclass Info {\n\t\tint girlH;\n\t\tint girlW;\n\n\t\tpublic Info(int girlH, int girlW) {\n\t\t\tthis.girlH = girlH;\n\t\t\tthis.girlW = girlW;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... o) {\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\n\tvoid debug2(char[][] array) {\n\t\tfor (int i = 0; i < array.length; i++) {\n\t\t\tfor (int j = 0; j < array[i].length; j++) {\n\t\t\t\tSystem.out.print(array[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tclass MyScanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-')\n\t\t\t\t\treturn -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tString next() {\n\t\t\ttry {\n\t\t\t\tStringBuilder res = new StringBuilder(\"\");\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (Character.isWhitespace(c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tdo {\n\t\t\t\t\tres.append((char) c);\n\t\t\t\t} while (!Character.isWhitespace(c = System.in.read()));\n\t\t\t\treturn res.toString();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.IOException;\nimport java.util.ArrayDeque;\nimport java.util.Arrays;\nimport java.util.Deque;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws IOException {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() throws IOException {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\th = scanner.nextInt();\n\t\t\tw = scanner.nextInt();\n\t\t\tif ((h | w) == 0)\n\t\t\t\tbreak;\n\t\t\tchar[][] map = new char[h][w];\n\t\t\tfor (int i = 0; i < h; i++) {\n\t\t\t\tmap[i] = scanner.next().toCharArray();\n\t\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\t\tif (map[i][j] == 'A') {\n\t\t\t\t\t\tay = i;\n\t\t\t\t\t\tax = j;\n\t\t\t\t\t} else if (map[i][j] == 'B') {\n\t\t\t\t\t\tby = i;\n\t\t\t\t\t\tbx = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[][] dp = new int[h][w];\n\t\t\tfor (int[] dp1 : dp)\n\t\t\t\tArrays.fill(dp1, 1 << 30);\n\t\t\tDeque<Point> deque = new ArrayDeque<Main.Point>();\n\t\t\tdeque.push(new Point(ay, ax, 0));\n\t\t\tdp[ay][ax] = 0;\n\t\t\twhile (!deque.isEmpty()) {\n\t\t\t\tPoint p = deque.poll();\n\t\t\t\tint y = p.y;\n\t\t\t\tint x = p.x;\n\t\t\t\tint step = p.step;\n\n\t\t\t\tfor (int[] m : move) {\n\t\t\t\t\tint ny = y + m[0];\n\t\t\t\t\tint nx = x + m[1];\n\t\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (map[ny][nx] == '#')\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tif (dp[ny][nx] <= step + 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[ny][nx] = step + 1;\n\t\t\t\t\tdeque.offer(new Point(ny, nx, step + 1));\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tchar[] p = scanner.next().toCharArray();\n\t\t\tint e;\n\t\t\tfor (e = 0; e < 9000; e++) {\n\t\t\t\tif (dp[by][bx] <= e)\n\t\t\t\t\tbreak;\n\t\t\t\tchar o = p[e % p.length];\n\t\t\t\tint ny = by + (o == '2' ? 1 : 0) - (o == '8' ? 1 : 0);\n\t\t\t\tint nx = bx + (o == '6' ? 1 : 0) - (o == '4' ? 1 : 0);\n\t\t\t\tif (!isOK(ny, nx))\n\t\t\t\t\tcontinue;\n\t\t\t\tby = ny;\n\t\t\t\tbx = nx;\n\t\t\t}\n\t\t\tSystem.out.println(e < 9000 ? e + \" \" + by + \" \" + bx\n\t\t\t\t\t: \"impossible\");\n\t\t}\n\t}\n\n\tprivate boolean isOK(int ny, int nx) {\n\t\treturn 0 <= ny && ny < h && 0 <= nx && nx < w;\n\t}\n\n\tint ay, ax, by, bx, h, w;\n\tint[][] move = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\n\n\tclass Point {\n\t\tint y, x, step;\n\n\t\tpublic Point(int y, int x, int step) {\n\t\t\tsuper();\n\t\t\tthis.y = y;\n\t\t\tthis.x = x;\n\t\t\tthis.step = step;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Point [y=\" + y + \", x=\" + x + \", step=\" + step + \"]\";\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Main{\n\tstatic int tile[][];\n\tstatic Deque<Integer[]> queue;\n\tstatic int h, w;\n\tstatic int playerMaxTurn;\n\t\n\tpublic static void main(String args[]){\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\ttry {\n\t\t\twhile(true){\n\t\t\t\tString strs[] = br.readLine().split(\" \");\n\t\t\t\th = Integer.parseInt(strs[0]);\n\t\t\t\tw = Integer.parseInt(strs[1]);\n\t\t\t\tif(h == 0) return;\n\t\t\t\t\n\t\t\t\ttile = new int[h][w];\n\t\t\t\tint ax = 0, ay = 0, bx = 0 , by = 0;\n\t\t\t\t//test for commit\n\t\t\t\t\n\t\t\t\t// フィールド読み取り\n\t\t\t\tfor(int y = 0; y < h; y++){\n\t\t\t\t\tString input = br.readLine();\n\t\t\t\t\tfor(int x = 0; x < w; x++){\n\t\t\t\t\t\tchar masu = input.charAt(x);\n\t\t\t\t\t\tswitch(masu){\n\t\t\t\t\t\tcase '.':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase '#':\n\t\t\t\t\t\t\ttile[y][x] = -2;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'A':\n\t\t\t\t\t\t\ttile[y][x] = 0;\n\t\t\t\t\t\t\tax = x;\n\t\t\t\t\t\t\tay = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tcase 'B':\n\t\t\t\t\t\t\ttile[y][x] = -1;\n\t\t\t\t\t\t\tbx = x;\n\t\t\t\t\t\t\tby = y;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// フィールド読み取りここまで\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 到達ターン数の計算\n\t\t\t\tqueue = new ArrayDeque<Integer[]>();\n\t\t\t\tInteger item[] = {ax, ay, 0};\n\t\t\t\tqueue.addLast(item);\n\t\t\t\ttry{\n\t\t\t\tcalc();\n\t\t\t\t}catch(Exception e){\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t// printMatrix(tile);\n\t\t\t\t\n\t\t\t\t// 幽霊の動きをインプット\n\t\t\t\tString str = br.readLine();\n\t\t\t\tint pattern_length = str.length();\n\t\t\t\tchar pattern[] = new char[pattern_length];\n\t\t\t\tfor(int i = 0; i < pattern_length; i++){\n\t\t\t\t\tpattern[i] = str.charAt(i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// 幽霊の動きシミュレート\n\t\t\t\tsimulate(bx, by, pattern);\n\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tstatic void simulate(int x, int y, char pattern[]){\n\t\tint turn = 0;\n\t\twhile(true){\n\t\t\tint beforePositionX = x;\n\t\t\tint beforePositionY = y;\n\t\t\tfor(int i = 0; i < pattern.length; i++){\n\t\t\t\tturn++;\n\t\t\t\t// System.out.println(\"turn \" + turn + \": \" + x + \", \" + y);\n\t\t\t\tswitch(pattern[i]){\n\t\t\t\tcase '8': // 上\n\t\t\t\t\tif(y >= 1) y--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '6': // 右\n\t\t\t\t\tif(x <= w-2) x++;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '4': // 左\n\t\t\t\t\tif(x >= 1) x--;\n\t\t\t\t\tbreak;\n\t\t\t\tcase '2': // 下\n\t\t\t\t\tif(y <= h-2) y++;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(tile[y][x] >= 0 && tile[y][x] <= turn){\n\t\t\t\t\tSystem.out.println(turn + \" \" + y + \" \" + x);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(turn >= playerMaxTurn){\n\t\t\t\tif(beforePositionX == x && beforePositionY == y){\n\t\t\t\t\tSystem.out.println(\"impossible\");\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tstatic void calc(){\n\t\t// System.out.println(\"calc\");\n\t\tif(queue.size() == 0) return;\n\t\tInteger item[] = queue.removeFirst();\n\t\tint x = item[0];\n\t\tint y = item[1];\n\t\tint turn = item[2];\n\t\tturn++;\n\t\tplayerMaxTurn = turn;\n\t\t// 上\n\t\tif(y >= 1 && tile[y-1][x] == -1){\n\t\t\ttile[y-1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y-1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 下\n\t\tif(y <= h-2 && tile[y+1][x] == -1){\n\t\t\ttile[y+1][x] = turn;\n\t\t\tInteger nextItem[] = {x, y+1, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 左\n\t\tif(x >= 1 && tile[y][x-1] == -1){\n\t\t\ttile[y][x-1] = turn;\n\t\t\tInteger nextItem[] = {x-1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\t// 右\n\t\tif(x <= w-2 && tile[y][x+1] == -1){\n\t\t\ttile[y][x+1] = turn;\n\t\t\tInteger nextItem[] = {x+1, y, turn};\n\t\t\tqueue.addLast(nextItem);\n\t\t}\n\t\t\n\t\tcalc();\n\t}\n\t\n\tpublic static void printArray(int array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void printArray(boolean array[]){\n\t\tfor(int i = 0; i < array.length; i++)\n\t\t\tSystem.out.print(array[i] + \"\\t\");\n\t\tSystem.out.println();\n\t}\n\t\n\tpublic static void printMatrix(int matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n\t\n\tpublic static void printMatrix(boolean matrix[][]){\n\t\tfor(int i = 0; i < matrix.length; i++){\n\t\t\tprintArray(matrix[i]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(new char[1]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tConsole.WriteLine(\"{0} {1} {2}\",1,1,1);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=s.Split(new char[1]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tint turn=0;\n\t\tint[][] M=new int[H][];\n\t\tPair P=new Pair(-1,-1);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tM[i]=new int[W];\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=turn;\n\t\t\t\tif(Map[i][j]=='B')P=new Pair(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool chk=true;\n\t\tHashSet<Pair> HL=new HashSet<Pair>();\n\t\t\n\t\twhile(true){\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint move=(turn -1)%(Pat.Length);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t\tif(turn>H*W){\n\t\t\t\t//ループ停止条件：\n\t\t\t\t//turn>H*Wであれば、Aが行けるところにはすべてフラグが立っている\n\t\t\t\t//Bの動きの周期点をturn>H*W以降で観察すれば、Bがループに入ったかどうかが分かる。\n\t\t\t\tif(move==0){\n\t\t\t\t\tif(HL.Contains(P)){\n\t\t\t\t\t\tchk=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tHL.Add(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!chk){\n\t\t\tConsole.WriteLine(\"impossible\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"{0} {1} {2}\",turn,P.R,P.C);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(new char[1]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tW=W+1;\n\t\tchar c=Pat[0];\n\t\tc='a';\n\t\tConsole.WriteLine(c=='b'?\"{0} {1} {2}\":\"{0} {1} {1}\",1,1,1);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=s.Split(new char[1]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tfor(int i=0;i<int.Parse(d[0])+1;i++)Console.ReadLine();\n\t\t\tConsole.WriteLine(\"{0} {1} {2}\",1,1,1);\n//\t\t\tSol mySol =new Sol(d);\n//\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tW=W+1;\n\t\tchar c=Pat[0];\n\t\tc='a';\n\t\tConsole.WriteLine(c=='b'?\"{0} {1} {2}\":\"{0} {1} {1}\",1,1,1);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(' ');\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\tConsole.WriteLine(\"impossible\");\n\t\t\treturn;\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(' ');\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tint turn=0;\n\t\tint[][] M=new int[H][];\n\t\tPair P=new Pair(-1,-1);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tM[i]=new int[W];\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=turn;\n\t\t\t\tif(Map[i][j]=='B')P=new Pair(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool chk=true;\n\t\tHashSet<Pair> HL=new HashSet<Pair>();\n\t\t\n\t\twhile(true){\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint move=(turn -1)%(Pat.Length);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t\tif(turn>H*W){\n\t\t\t\t//ループ停止条件：\n\t\t\t\t//turn>H*Wであれば、Aが行けるところにはすべてフラグが立っている\n\t\t\t\t//Bの動きの周期点をturn>H*W以降で観察すれば、Bがループに入ったかどうかが分かる。\n\t\t\t\tif(move==0){\n\t\t\t\t\tif(HL.Contains(P)){\n\t\t\t\t\t\tchk=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tHL.Add(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!chk){\n\t\t\tConsole.WriteLine(\"impossible\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"{0} {1} {2}\",turn,P.R,P.C);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(new char[1]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tW=W;\n\t\tchar c=Pat[0];\n\t\tc='a';\n\t\tConsole.WriteLine(\"{0} {1} {2}\",1,1,1);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(new char[1]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tfor(int i=0;i<int.Parse(d[0])+1;i++)Console.ReadLine();\n\t\t\tConsole.WriteLine(\"{0} {1} {2}\",1,1,1);\n//\t\t\tSol mySol =new Sol(d);\n//\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tW=W+1;\n\t\tchar c=Pat[0];\n\t\tc='a';\n\t\tConsole.WriteLine(c=='b'?\"{0} {1} {2}\":\"{0} {1} {1}\",1,1,1);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(' ');\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tint turn=0;\n\t\tint[][] M=new int[H][];\n\t\tPair P=new Pair(-1,-1);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tM[i]=new int[W];\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=turn;\n\t\t\t\tif(Map[i][j]=='B')P=new Pair(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Pair> FS =new List<Pair>();\n\t\tFS.Add(P);\n\t\tbool chk=true;\n\t\tHashSet<Pair> HL=new HashSet<Pair>();\n\t\t\n\t\twhile(true){\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint move=(turn -1)%(Pat.Length);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tFS.Add(P);\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t\tif(turn>H*W){\n\t\t\t\t//ループ停止条件：\n\t\t\t\t//turn>H*Wであれば、Aが行けるところにはすべてフラグが立っている\n\t\t\t\t//Bの動きの周期点をturn>H*W以降で観察すれば、Bがループに入ったかどうかが分かる。\n\t\t\t\tif(move==0){\n\t\t\t\t\tif(HL.Contains(P)){\n\t\t\t\t\t\tchk=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tHL.Add(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!chk){\n\t\t\tConsole.WriteLine(\"impossible\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"{0} {1} {2}\",turn,P.R,P.C);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(' ');\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\tConsole.WriteLine(\"impossible\");\n\t\t\treturn;\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\n\nclass Program\n{\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var sc = new Scan();\n        int t = 0;\n        while (true)\n        {\n            ++t;\n            int h, w;\n            sc.Multi(out h, out w);\n            if (h + w == 0) break;\n            \n            var b = new string[h];\n            var dist = new int[h][];\n            int ai = 0, aj = 0, bi = 0, bj = 0;\n            for (int i = 0; i < h; i++)\n            {\n                b[i] = sc.Str;\n                dist[i] = new int[w];\n                for (int j = 0; j < w; j++)\n                {\n                    dist[i][j] = M;\n                    if (b[i][j] == 'A')\n                    {\n                        ai = i;\n                        aj = j;\n                    }\n                    if (b[i][j] == 'B')\n                    {\n                        bi = i;\n                        bj = j;\n                    }\n                }\n            }\n            dist[ai][aj] = 0;\n            var qi = new Queue<int>();\n            var qj = new Queue<int>();\n            qi.Enqueue(ai);\n            qj.Enqueue(aj);\n            while (qi.Count > 0)\n            {\n                int pi = qi.Dequeue(), pj = qj.Dequeue();\n                for (int i = 0; i < 4; i++)\n                {\n                    int ti = pi + dd[i], tj = pj + dd[i + 1];\n                    if (ti >= 0 && ti < h && tj >= 0 && tj < w && b[ti][tj] != '#' && dist[ti][tj] > dist[pi][pj] + 1)\n                    {\n                        dist[ti][tj] = dist[pi][pj] + 1;\n                        qi.Enqueue(ti);\n                        qj.Enqueue(tj);\n                    }\n                }\n            }\n            var s = sc.Str;\n            for (int i = 0; i < 1000; i++)\n            {\n                switch (s[i % s.Length])\n                {\n                    case '2':\n                        ++bi;\n                        break;\n                    case '4':\n                        --bj;\n                        break;\n                    case '6':\n                        ++bj;\n                        break;\n                    case '8':\n                        --bi;\n                        break;\n                }\n                if (bi < 0) bi = 0;\n                if (bi >= h) bi = h - 1;\n                if (bj < 0) bj = 0;\n                if (bj >= w) bj = w;\n                if (dist[bi][bj] <= i + 1)\n                {\n                    sw.WriteLine(\"{0} {1} {2}\", i + 1, bi, bj);\n                    goto A;\n                }\n            }\n            sw.WriteLine(\"impossible\");\n            A:\n            continue;\n        }\n        sw.Flush();\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n\n    static T[] copy<T>(T[] a)\n    {\n        var ret = new T[a.Length];\n        for (int i = 0; i < a.Length; i++) ret[i] = a[i];\n        return ret;\n    }\n    static T[][] copy2<T>(T[][] a)\n    {\n        var ret = new T[a.Length][];\n        for (int i = 0; i < a.Length; i++)\n        {\n            ret[i] = new T[a[0].Length];\n            for (int j = 0; j < a[0].Length; j++) ret[i][j] = a[i][j];\n        }\n        return ret;\n    }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public int[] IntArrWithSep(char sep) { return Str.Split(sep).Select(int.Parse).ToArray(); }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    public void Multi(out int a, out int b) { var arr = IntArr; a = arr[0]; b = arr[1]; }\n    public void Multi(out int a, out int b, out int c) { var arr = IntArr; a = arr[0]; b = arr[1]; c = arr[2]; }\n    public void Multi(out int a, out string b) { var arr = StrArr; a = int.Parse(arr[0]); b = arr[1]; }\n    public void Multi(out string a, out int b) { var arr = StrArr; a = arr[0]; b = int.Parse(arr[1]); }\n    public void Multi(out int a, out char b) { var arr = StrArr; a = int.Parse(arr[0]); b = arr[1][0]; }\n    public void Multi(out char a, out int b) { var arr = StrArr; a = arr[0][0]; b = int.Parse(arr[1]); }\n    public void Multi(out long a, out long b) { var arr = LongArr; a = arr[0]; b = arr[1]; }\n    public void Multi(out long a, out int b) { var arr = LongArr; a = arr[0]; b = (int)arr[1]; }\n    public void Multi(out int a, out long b) { var arr = LongArr; a = (int)arr[0]; b = arr[1]; }\n    public void Multi(out string a, out string b) { var arr = StrArr; a = arr[0]; b = arr[1]; }\n}\nclass mymath\n{\n    public bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public long[][] powmat(long[][] A, long n, int M)\n    {\n        var E = new long[A.Length][];\n        for (int i = 0; i < A.Length; i++)\n        {\n            E[i] = new long[A.Length];\n            E[i][i] = 1;\n        }\n        if (n == 0) return E;\n        var t = powmat(A, n / 2, M);\n        if ((n & 1) == 0) return mulmat(t, t, M);\n        return mulmat(mulmat(t, t, M), A, M);\n    }\n    public long[] mulmat(long[][] A, long[] x, int M)\n    {\n        var ans = new long[A.Length];\n        for (int i = 0; i < A.Length; i++) for (int j = 0; j < x.Length; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % M;\n        return ans;\n    }\n    public long[][] mulmat(long[][] A, long[][] B, int M)\n    {\n        var ans = new long[A.Length][];\n        for (int i = 0; i < A.Length; i++)\n        {\n            ans[i] = new long[B[0].Length];\n            for (int j = 0; j < B[0].Length; j++) for (int k = 0; k < B.Length; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % M;\n        }\n        return ans;\n    }\n    public long powmod(long a, long b, long M)\n    {\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = powmod(a, b / 2, M);\n        if ((b & 1) == 0) return t * t % M;\n        return t * t % M * a % M;\n    }\n    public long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n    public long Comb(int n, int r)\n    {\n        const int M = 1000000007;\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        var numerator = new int[r];\n        var denominator = new int[r];\n        for (int k = 0; k < r; k++)\n        {\n            numerator[k] = n - r + k + 1;\n            denominator[k] = k + 1;\n        }\n        for (int p = 2; p <= r; p++)\n        {\n            int pivot = denominator[p - 1];\n            if (pivot > 1)\n            {\n                int offset = (n - r) % p;\n                for (int k = p - 1; k < r; k += p)\n                {\n                    numerator[k - offset] /= pivot;\n                    denominator[k] /= pivot;\n                }\n            }\n        }\n        long result = 1;\n        for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % M;\n        return result;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(new char[1]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tint turn=0;\n\t\tint[][] M=new int[H][];\n\t\tPair P=new Pair(-1,-1);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tM[i]=new int[W];\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=turn;\n\t\t\t\tif(Map[i][j]=='B')P=new Pair(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tbool chk=true;\n\t\tHashSet<Pair> HL=new HashSet<Pair>();\n\t\t\n\t\twhile(true){\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint move=(turn -1)%(Pat.Length);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t\tif(turn>H*W){\n\t\t\t\t//ループ停止条件：\n\t\t\t\t//turn>H*Wであれば、Aが行けるところにはすべてフラグが立っている\n\t\t\t\t//Bの動きの周期点をturn>H*W以降で観察すれば、Bがループに入ったかどうかが分かる。\n\t\t\t\tif(move==0){\n\t\t\t\t\tif(HL.Contains(P)){\n\t\t\t\t\t\tchk=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tHL.Add(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!chk){\n\t\t\tConsole.WriteLine(\"impossible\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"{0} {1} {2}\",turn,P.R,P.C);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.IO;\nusing System.Text;\n\nclass Program\n{\n    const int M = 1000000007;\n    const double eps = 1e-9;\n    static int[] dd = { 0, 1, 0, -1, 0 };\n    static void Main()\n    {\n        var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n        var sc = new Scan();\n        int t = 0;\n        while (true)\n        {\n            ++t;\n            int h, w;\n            sc.Multi(out h, out w);\n            if (h + w == 0) break;\n            \n            var b = new string[h];\n            var dist = new int[h][];\n            int ai = 0, aj = 0, bi = 0, bj = 0;\n            for (int i = 0; i < h; i++)\n            {\n                b[i] = sc.Str;\n                dist[i] = new int[w];\n                for (int j = 0; j < w; j++)\n                {\n                    dist[i][j] = M;\n                    if (b[i][j] == 'A')\n                    {\n                        ai = i;\n                        aj = j;\n                    }\n                    if (b[i][j] == 'B')\n                    {\n                        bi = i;\n                        bj = j;\n                    }\n                }\n            }\n            dist[ai][aj] = 0;\n            var qi = new Queue<int>();\n            var qj = new Queue<int>();\n            qi.Enqueue(ai);\n            qj.Enqueue(aj);\n            while (qi.Count > 0)\n            {\n                int pi = qi.Dequeue(), pj = qj.Dequeue();\n                for (int i = 0; i < 4; i++)\n                {\n                    int ti = pi + dd[i], tj = pj + dd[i + 1];\n                    if (ti >= 0 && ti < h && tj >= 0 && tj < w && b[ti][tj] != '#' && dist[ti][tj] > dist[pi][pj] + 1)\n                    {\n                        dist[ti][tj] = dist[pi][pj] + 1;\n                        qi.Enqueue(ti);\n                        qj.Enqueue(tj);\n                    }\n                }\n            }\n            var s = sc.Str;\n            for (int i = 0; i < 1000; i++)\n            {\n                switch (s[i % s.Length])\n                {\n                    case '2':\n                        ++bi;\n                        break;\n                    case '4':\n                        --bj;\n                        break;\n                    case '6':\n                        ++bj;\n                        break;\n                    case '8':\n                        --bi;\n                        break;\n                }\n                if (bi < 0) bi = 0;\n                if (bi >= h) bi = h - 1;\n                if (bj < 0) bj = 0;\n                if (bj >= w) bj = w - 1;\n                if (dist[bi][bj] <= i + 1)\n                {\n                    sw.WriteLine(\"{0} {1} {2}\", i + 1, bi, bj);\n                    goto A;\n                }\n            }\n            sw.WriteLine(\"impossible\");\n            A:\n            continue;\n        }\n        sw.Flush();\n    }\n\n    static void swap<T>(ref T a, ref T b) { var t = a; a = b; b = t; }\n\n    static T[] copy<T>(T[] a)\n    {\n        var ret = new T[a.Length];\n        for (int i = 0; i < a.Length; i++) ret[i] = a[i];\n        return ret;\n    }\n    static T[][] copy2<T>(T[][] a)\n    {\n        var ret = new T[a.Length][];\n        for (int i = 0; i < a.Length; i++)\n        {\n            ret[i] = new T[a[0].Length];\n            for (int j = 0; j < a[0].Length; j++) ret[i][j] = a[i][j];\n        }\n        return ret;\n    }\n}\nclass Scan\n{\n    public int Int { get { return int.Parse(Str); } }\n    public long Long { get { return long.Parse(Str); } }\n    public string Str { get { return Console.ReadLine().Trim(); } }\n    public int[] IntArr { get { return StrArr.Select(int.Parse).ToArray(); } }\n    public int[] IntArrWithSep(char sep) { return Str.Split(sep).Select(int.Parse).ToArray(); }\n    public long[] LongArr { get { return StrArr.Select(long.Parse).ToArray(); } }\n    public double[] DoubleArr { get { return StrArr.Select(double.Parse).ToArray(); } }\n    public string[] StrArr { get { return Str.Split(); } }\n    public void Multi(out int a, out int b) { var arr = IntArr; a = arr[0]; b = arr[1]; }\n    public void Multi(out int a, out int b, out int c) { var arr = IntArr; a = arr[0]; b = arr[1]; c = arr[2]; }\n    public void Multi(out int a, out string b) { var arr = StrArr; a = int.Parse(arr[0]); b = arr[1]; }\n    public void Multi(out string a, out int b) { var arr = StrArr; a = arr[0]; b = int.Parse(arr[1]); }\n    public void Multi(out int a, out char b) { var arr = StrArr; a = int.Parse(arr[0]); b = arr[1][0]; }\n    public void Multi(out char a, out int b) { var arr = StrArr; a = arr[0][0]; b = int.Parse(arr[1]); }\n    public void Multi(out long a, out long b) { var arr = LongArr; a = arr[0]; b = arr[1]; }\n    public void Multi(out long a, out int b) { var arr = LongArr; a = arr[0]; b = (int)arr[1]; }\n    public void Multi(out int a, out long b) { var arr = LongArr; a = (int)arr[0]; b = arr[1]; }\n    public void Multi(out string a, out string b) { var arr = StrArr; a = arr[0]; b = arr[1]; }\n}\nclass mymath\n{\n    public bool isprime(long a)\n    {\n        if (a < 2) return false;\n        for (long i = 2; i * i <= a; i++) if (a % i == 0) return false;\n        return true;\n    }\n    public long[][] powmat(long[][] A, long n, int M)\n    {\n        var E = new long[A.Length][];\n        for (int i = 0; i < A.Length; i++)\n        {\n            E[i] = new long[A.Length];\n            E[i][i] = 1;\n        }\n        if (n == 0) return E;\n        var t = powmat(A, n / 2, M);\n        if ((n & 1) == 0) return mulmat(t, t, M);\n        return mulmat(mulmat(t, t, M), A, M);\n    }\n    public long[] mulmat(long[][] A, long[] x, int M)\n    {\n        var ans = new long[A.Length];\n        for (int i = 0; i < A.Length; i++) for (int j = 0; j < x.Length; j++) ans[i] = (ans[i] + x[j] * A[i][j]) % M;\n        return ans;\n    }\n    public long[][] mulmat(long[][] A, long[][] B, int M)\n    {\n        var ans = new long[A.Length][];\n        for (int i = 0; i < A.Length; i++)\n        {\n            ans[i] = new long[B[0].Length];\n            for (int j = 0; j < B[0].Length; j++) for (int k = 0; k < B.Length; k++) ans[i][j] = (ans[i][j] + A[i][k] * B[k][j]) % M;\n        }\n        return ans;\n    }\n    public long powmod(long a, long b, long M)\n    {\n        if (a == 0) return 0;\n        if (b == 0) return 1;\n        var t = powmod(a, b / 2, M);\n        if ((b & 1) == 0) return t * t % M;\n        return t * t % M * a % M;\n    }\n    public long gcd(long a, long b)\n    {\n        while (b > 0) { var t = a % b; a = b; b = t; }\n        return a;\n    }\n    public long lcm(long a, long b) { return a * (b / gcd(a, b)); }\n    public long Comb(int n, int r)\n    {\n        const int M = 1000000007;\n        if (n < 0 || r < 0 || r > n) return 0;\n        if (n - r < r) r = n - r;\n        if (r == 0) return 1;\n        if (r == 1) return n;\n        var numerator = new int[r];\n        var denominator = new int[r];\n        for (int k = 0; k < r; k++)\n        {\n            numerator[k] = n - r + k + 1;\n            denominator[k] = k + 1;\n        }\n        for (int p = 2; p <= r; p++)\n        {\n            int pivot = denominator[p - 1];\n            if (pivot > 1)\n            {\n                int offset = (n - r) % p;\n                for (int k = p - 1; k < r; k += p)\n                {\n                    numerator[k - offset] /= pivot;\n                    denominator[k] /= pivot;\n                }\n            }\n        }\n        long result = 1;\n        for (int k = 0; k < r; k++) if (numerator[k] > 1) result = result * numerator[k] % M;\n        return result;\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tint turn=0;\n\t\tint[][] M=new int[H][];\n\t\tPair P=new Pair(-1,-1);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tM[i]=new int[W];\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=turn;\n\t\t\t\tif(Map[i][j]=='B')P=new Pair(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tList<Pair> FS =new List<Pair>();\n\t\tFS.Add(P);\n\t\tbool chk=true;\n\t\tHashSet<Pair> HL=new HashSet<Pair>();\n\t\t\n\t\twhile(true){\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint move=(turn -1)%(Pat.Length);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tFS.Add(P);\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t\tif(turn>H*W){\n\t\t\t\t//ループ停止条件：\n\t\t\t\t//turn>H*Wであれば、Aが行けるところにはすべてフラグが立っている\n\t\t\t\t//Bの動きの周期点をturn>H*W以降で観察すれば、Bがループに入ったかどうかが分かる。\n\t\t\t\tif(move==0){\n\t\t\t\t\tif(HL.Contains(P)){\n\t\t\t\t\t\tchk=false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tHL.Add(P);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!chk){\n\t\t\tConsole.WriteLine(\"impossible\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"{0} {1} {2}\",turn,P.R,P.C);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(int[] d_){\n\t\tH=d_[0];W=d_[1];\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(' ');\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\tint turn=0;\n\t\tint[][] M=new int[H][];\n\t\tPair P=new Pair(-1,-1);\n\t\tfor(int i=0;i<H;i++){\n\t\t\tM[i]=new int[W];\n\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\tM[i][j]=-1;\n\t\t\t\tif(Map[i][j]=='A')M[i][j]=turn;\n\t\t\t\tif(Map[i][j]=='B')P=new Pair(i,j);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt=H*W*(Pat.Length+1)+1;\n\t\twhile(cnt>0){\n\t\t\tcnt--;\n\t\t\tturn++;\n\t\t\t//まずAを進める\n\t\t\tfor(int i=0;i<H;i++){\n\t\t\t\tfor(int j=0;j<W;j++){\n\t\t\t\t\tif(M[i][j]==turn-1){\n\t\t\t\t\t\tif(i-1>=0 && Map[i-1][j]!='#' && M[i-1][j]==-1)M[i-1][j]=turn;\n\t\t\t\t\t\tif(i+1<H  && Map[i+1][j]!='#' && M[i+1][j]==-1)M[i+1][j]=turn;\n\t\t\t\t\t\tif(j-1>=0 && Map[i][j-1]!='#' && M[i][j-1]==-1)M[i][j-1]=turn;\n\t\t\t\t\t\tif(j+1<W  && Map[i][j+1]!='#' && M[i][j+1]==-1)M[i][j+1]=turn;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint move=(turn -1)%(Pat.Length);\n\t\t\tif(Pat[move]=='8'){if(P.R-1>=0)P.R-=1;}\n\t\t\tif(Pat[move]=='4'){if(P.C-1>=0)P.C-=1;}\n\t\t\tif(Pat[move]=='5'){;}\n\t\t\tif(Pat[move]=='6'){if(P.C+1<W)P.C+=1;}\n\t\t\tif(Pat[move]=='2'){if(P.R+1<H)P.R+=1;}\n\t\t\tif(M[P.R][P.C]!=-1)break;\n\t\t}\n\t\t\n\t\tif(cnt==0){\n\t\t\tConsole.WriteLine(\"impossible\");\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tConsole.WriteLine(\"{0} {1} {2}\",turn,P.R,P.C);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using static System.Math;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class P\n{\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n\tpublic int p { get; set; }\n}\n\npublic class P2\n{\n\tpublic int step { get; set; }\n\tpublic int x { get; set; }\n\tpublic int y { get; set; }\n}\n\npublic class hello\n{\n\tstatic int[] dx, dy, d2x, d2y;\n\tstatic int h, w, ax, ay, bx, by;\n\tpublic static void Main()\n\t{\n\t\tdx = new int[] { 0, 0, 1, 0, 0, 0, 0, 0, -1 };\n\t\tdy = new int[] { 0, 0, 0, 0, -1, 0, 1, 0, 0 };\n\t\td2x = new int[] { 0, 1, 0, -1 };\n\t\td2y = new int[] { 1, 0, -1, 0 };\n\n\t\twhile (true)\n\t\t{\n\t\t\tstring[] line = Console.ReadLine().Trim().Split(' ');\n\t\t\th = int.Parse(line[0]);\n\t\t\tw = int.Parse(line[1]);\n\t\t\tif (h == 0 && w == 0) break;\n\t\t\tvar map = new bool[h, w];\n\t\t\tax = 0; ay = 0; bx = 0; by = 0;\n\t\t\tfor (int i = 0; i < h; i++)\n\t\t\t{\n\t\t\t\tvar s = Console.ReadLine().Trim();\n\t\t\t\tfor (int j = 0; j < w; j++)\n\t\t\t\t{\n\t\t\t\t\tmap[i, j] = true;\n\t\t\t\t\tif (s[j] == 'A') { ax = i; ay = j; }\n\t\t\t\t\telse if (s[j] == 'B') { bx = i; by = j; }\n\t\t\t\t\telse if (s[j] == '#') map[i, j] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ptn = Console.ReadLine().Trim();\n\t\t\tvar d = getB(ptn);\n\t\t\tvar amap = getAmap(map);\n\t\t\tgetAns(amap, d);\n\t\t}\n\t}\n\tstatic void getAns(int[,] amap, Dictionary<int, P> d)\n\t{\n\t\tvar anstime = int.MaxValue;\n\t\tvar ansx = 0; var ansy = 0;\n\t\tvar imax = Max(d.Count(), h * w);\n\t\tfor (int i = 1; i < d.Count(); i++)\n\t\t{\n\t\t\tvar bx = d[i].x;\n\t\t\tvar by = d[i].y;\n\t\t\tif (amap[bx, by] != 999999 && amap[bx, by] <= i)\n\t\t\t{\n\t\t\t\tvar abtime = Max(i, amap[bx, by]);\n\t\t\t\tif (abtime < anstime)\n\t\t\t\t{\n\t\t\t\t\tanstime = abtime;\n\t\t\t\t\tansx = bx;\n\t\t\t\t\tansy = by;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (anstime == int.MaxValue) Console.WriteLine(\"impossible\");\n\t\telse Console.WriteLine(\"{0} {1} {2}\", anstime, ansx, ansy);\n\t}\n\tstatic int[,] getAmap(bool[,] map)\n\t{\n\t\tvar amap = new int[h, w];\n\t\tfor (int i = 0; i < h; i++)\n\t\t\tfor (int j = 0; j < w; j++) amap[i, j] = 999999;\n\t\tvar q = new Queue<P2>();\n\t\tq.Enqueue(new P2 { x = ax, y = ay ,step = 0});\n\t\tamap[ax, ay] = 0;\n\t\twhile (q.Count() > 0)\n\t\t{\n\t\t\tvar t = q.Dequeue();\n\t\t\tfor (int i = 0; i < 4; i++)\n\t\t\t{\n\t\t\t\tvar nx = t.x + d2x[i];\n\t\t\t\tvar ny = t.y + d2y[i];\n\t\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w && map[nx, ny] && amap[nx, ny] == 999999)\n\t\t\t\t{\n\t\t\t\t\tq.Enqueue(new P2 { x = nx, y = ny, step = t.step + 1 });\n\t\t\t\t\tamap[nx, ny] = t.step + 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn amap;\n\t}\n\tstatic Dictionary<int, P> getB(string ptn)\n\t{\n\t\tvar x = bx;\n\t\tvar y = by;\n\t\tvar d = new Dictionary<int, P>();\n\t\tvar p = 0;\n\t\tvar L = ptn.Length;\n\t\td[0] = new P { x = x, y = y, p = -1 };\n\t\tvar step = 1;\n\t\tvar stepmax = Max(h * w, (L + 1) * (L + 1));\n\t\twhile (step < stepmax)\n\t\t{\n\t\t\tvar i = ptn[p] - '0';\n\t\t\tvar nx = x + dx[i];\n\t\t\tvar ny = y + dy[i];\n\t\t\tif (nx >= 0 && nx < h && ny >= 0 && ny < w)\n\t\t\t{\n\t\t\t\td[step] = new P { x = nx, y = ny, p = p };\n\t\t\t\tx = nx;\n\t\t\t\ty = ny;\n\t\t\t}\n\t\t\telse\n\t\t\t\td[step] = new P { x = x, y = y, p = p };\n\t\t\tp++;\n\t\t\tif (p == L) p = 0;\n\t\t\tstep++;\n\t\t}\n\t\treturn d;\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tvar d=Console.ReadLine().Split(new char[1]{' '}, StringSplitOptions.RemoveEmptyEntries);\n\t\t\tif(d[0][0]=='0' && d[1][0]=='0')break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tW=W+1;\n\t\tchar c=Pat[0];\n\t\tc='a';\n\t\tConsole.WriteLine(c=='b'?\"{0} {1} {2}\":\"{0} {1} {1}\",1,1,1);\n\t}\n\t\n\tstruct Pair{\n\t\tpublic int R;\n\t\tpublic int C;\n\t\tpublic Pair(int r,int c){\n\t\t\tR=r;C=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\tint H;\n\tint W;\n\tString[] Map;\n\tString Pat;\n\tpublic Sol(String[] d_){\n\t\tH=int.Parse(d_[0]);W=int.Parse(d_[1]);\n\t\tMap=new String[H];\n\t\tfor(int i=0;i<H;i++)Map[i]=rs();\n\t\tPat=rs();\n\t}\n\n\n\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 5000\n$h = 0\n$w = 0\n\ndef bfs(bord,a)\n\twalks = [[1,0],[-1,0],[0,1],[0,-1]]\n\tstep = bord[a[0]][a[1]]\n\tnewpos = []\n\twalks.each{|ws|\n\t\tnewpos[0] = a[0] + ws[0]\n\t\tnewpos[1] = a[1] + ws[1]\n\t\tif newpos[0].between?(0,$h-1) and newpos[1].between?(0,$w-1) then\n\t\t\tif bord[newpos[0]][newpos[1]] > (step+1) then\n\t\t\t\tbord[newpos[0]][newpos[1]] = step + 1\n\t\t\t\tbfs(bord,newpos)\n\t\t\tend\n\t\tend\n\t}\nend\n\nloop{\n\tstr = gets.split.map(&:to_i)\n    if str.size != 2\n        next\n    end\n    $h,$w = str[0],str[1]\n\n\tif ($h == 0 and $w == 0) then\n\t\texit\n\tend\n\ta = [0,0]\n\tb = [0,0]\n\tbord = Array.new($h).map{Array.new($w,0)}\n\n\t$h.times{|y|\t\n\t\tbord[y] = gets.chomp.split(//).map.with_index{|c,i|\n\t\t\tcase c\n\t\t\twhen \"A\" then\n\t\t\t\ta[0] = y\n\t\t\t\ta[1] = i\n\t\t\t\t0\n\t\t\twhen \"B\" then\n\t\t\t\tb[0] = y\n\t\t\t\tb[1] = i\n\t\t\t\tINF\n\t\t\twhen \".\" then\n\t\t\t\tINF\n\t\t\telse\n\t\t\t\t-1\n\t\t\tend\n\t\t}\n\t}\n\tbfs(bord,a)\n\tpat = gets.chomp\n\tbstep = 0\n\tflag = 0\n\tloop{\n\t\tpat.each_char{|ch|\n\t\t\tbstep += 1\n\t\t\tcase ch\n\t\t\twhen \"2\" then\n\t\t\t\tb[0] += b[0] < $h-1 ? 1:0\n\t\t\twhen \"4\" then\n\t\t\t\tb[1] -= b[1] > 0 ? 1:0\n\t\t\twhen \"6\" then\n\t\t\t\tb[1] += b[1] < $w-1 ? 1:0\n\t\t\twhen \"8\" then\n\t\t\t\tb[0] -= b[0] > 0 ? 1:0\n\t\t\twhen \"5\" then\n\t\t\tend\n\t\t\tif bord[b[0]][b[1]] != -1 and bstep >= bord[b[0]][b[1]] then\n\t\t\t\tprint(\"#{bstep} #{b[0].to_s} #{b[1]}\\n\")\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\t\tif flag == 1 then\n\t\t\tbreak;\n\t\tend\n\t\tif bstep >= 500 then\n\t\t\tprint \"impossible\\n\"\n\t\t\tbreak\n\t\tend\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nwhile true do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    str = gets.split.map(&:to_i)\n    h = str[0]\n    w = str[1]\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==500 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    if a[0]==nil || b[0]==nil\n        exit\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "def bfs(f, sy, sx, steps, q, r, c)\n    dx = [0,1,0,-1]\n    dy = [1,0,-1,0]\n    for i in 0..3\n        cy = sy + dy[i]\n        cx = sx + dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==500 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\n    loop do\n        a =0\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\nHDXYS = {\n  \"5\" => [0, 0],\n  \"8\" => [0, -1], \"6\" => [1, 0], \"4\" => [-1, 0], \"2\" => [0, 1]\n}\nDXYS = [[0, 0], [0, -1], [1, 0], [-1, 0], [0, 1]]\n\n### main\n\nloop do\n  h, w = gets.split.map(&:to_i)\n  break if h == 0 && w == 0\n\n  hw = h * w\n  mat = h.times.map{w.times.map{true}}\n  gst = hst = nil\n\n  for y in (0...h)\n    line = gets.strip\n    for x in (0...w)\n      case line[x]\n      when '#'\n        mat[y][x] = false\n      when 'A'\n        gst = [x, y]\n      when 'B'\n        hst = [x, y]\n      end\n    end\n  end\n  #p mat\n  #p [gst, hst]\n\n  hpat = gets.strip\n  nhpat = hpat.length\n  #p [nhpat, hpat]\n\n  dists = nhpat.times.map{hw.times.map{hw.times.map{MAX_INT}}}\n  dists[0][gst[0] + gst[1] * w][hst[0] + hst[1] * w] = 0\n\n  q = [[0, *gst, *hst]]\n  #p q\n\n  min_t = []\n\n  while ! q.empty?\n    u = q.min{|a, b|\n      dists[a[0]][a[1]+ a[2] * w][a[3] + a[4] * w] <=> \n      dists[b[0]][b[1]+ b[2] * w][b[3] + b[4] * w]\n    }\n    q.delete u\n\n    ut, ugx, ugy, uhx, uhy = u\n    if ugx == uhx && ugy == uhy\n      min_t = [dists[ut][ugx + ugy * w][uhx + uhy * w], ugy, ugx]\n      break\n    end\n\n    du = dists[ut][ugx + ugy * w][uhx + uhy * w]\n\n    hdx, hdy = HDXYS[hpat[ut]]\n    vhx = uhx + hdx\n    vhy = uhy + hdy\n    if vhx < 0 || vhx >= w || vhy < 0 || vhy >= h\n      vhx = uhx\n      vhy = uhy\n    end\n    vhid = vhx + vhy * w\n\n    vt = (ut + 1) % nhpat\n\n    for dxy in DXYS\n      vgx = ugx + dxy[0]\n      vgy = ugy + dxy[1]\n\n      if vgx >= 0 && vgx < w && vgy >= 0 && vgy < h && mat[vgy][vgx]\n        vgid = vgx + vgy * w\n        dv = dists[vt][vgid][vhid]\n        if dv > du + 1\n          dists[vt][vgid][vhid] = du + 1\n          if dv >= MAX_INT\n            q << [vt, vgx, vgy, vhx, vhy]\n          end\n        end\n      end\n    end\n  end\n\n  if min_t.empty?\n    puts 'impossible'\n  else\n    puts min_t.join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==Float::INFINITY && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,Float::INFINITY)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[1],a[0],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 5000\n$h = 0\n$w = 0\n\ndef bfs(bord,a)\n\twalks = [[1,0],[-1,0],[0,1],[0,-1]]\n\tstep = bord[a[0]][a[1]]\n\tnewpos = []\n\twalks.each{|ws|\n\t\tnewpos[0] = a[0] + ws[0]\n\t\tnewpos[1] = a[1] + ws[1]\n\t\tif newpos[0].between?(0,$h-1) and newpos[1].between?(0,$w-1) then\n\t\t\tif bord[newpos[0]][newpos[1]] > (step+1) then\n\t\t\t\tbord[newpos[0]][newpos[1]] = step + 1\n\t\t\t\tbfs(bord,newpos)\n\t\t\tend\n\t\tend\n\t}\nend\n\nloop{\n\tstr = gets.split.map(&:to_i)\n    if str.size != 2\n        next\n    end\n    $h,$w = str[0],str[1]\n\n\tif ($h == 0 and $w == 0) then\n\t\texit\n\tend\n\ta = [0,0]\n\tb = [0,0]\n\tbord = Array.new($h).map{Array.new($w,0)}\n\n\t$h.times{|y|\t\n\t\tbord[y] = gets.chomp.split(//).map.with_index{|c,i|\n\t\t\tcase c\n\t\t\twhen \"A\" then\n\t\t\t\ta[0] = y\n\t\t\t\ta[1] = i\n\t\t\t\t0\n\t\t\twhen \"B\" then\n\t\t\t\tb[0] = y\n\t\t\t\tb[1] = i\n\t\t\t\tINF\n\t\t\twhen \".\" then\n\t\t\t\tINF\n\t\t\telse\n\t\t\t\t-1\n\t\t\tend\n\t\t}\n\t}\n\tbfs(bord,a)\n\tpat = gets.chomp\n\tbstep = 0\n\tflag = 0\n\tloop{\n\t\tpat.each_char{|ch|\n\t\t\tbstep += 1\n\t\t\tcase ch\n\t\t\twhen \"2\" then\n\t\t\t\tb[0] += b[0] < $h-1 ? 1:0\n\t\t\twhen \"4\" then\n\t\t\t\tb[1] -= b[1] > 0 ? 1:0\n\t\t\twhen \"6\" then\n\t\t\t\tb[1] += b[1] < $w-1 ? 1:0\n\t\t\twhen \"8\" then\n\t\t\t\tb[0] -= b[0] > 0 ? 1:0\n\t\t\twhen \"5\" then\n\t\t\tend\n\t\t\tif bord[b[0]][b[1]] != -1 and bstep >= bord[b[0]][b[1]] then\n\t\t\t\tprint(\"#{bstep} #{b[0].to_s} #{b[1]}\\n\")\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\t\tif flag == 1 then\n\t\t\tbreak;\n\t\tend\n\t\tif bstep >= ([$h,$w].max + 1) * pat.length then\n\t\t\tprint \"impossible\\n\"\n\t\t\tbreak\n\t\tend\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\nHDXYS = {\n  \"5\" => [0, 0],\n  \"8\" => [0, -1], \"6\" => [1, 0], \"4\" => [-1, 0], \"2\" => [0, 1]\n}\nDXYS = [[0, 0], [0, -1], [1, 0], [-1, 0], [0, 1]]\n\n### main\n\nloop do\n  h, w = gets.split.map(&:to_i)\n  break if h == 0 && w == 0\n\n  hw = h * w\n  mat = h.times.map{w.times.map{true}}\n  gst = hst = nil\n\n  for y in (0...h)\n    line = gets.strip\n    for x in (0...w)\n      case line[x]\n      when '#'\n        mat[y][x] = false\n      when 'A'\n        gst = [x, y]\n      when 'B'\n        hst = [x, y]\n      end\n    end\n  end\n  #p mat\n  #p [gst, hst]\n\n  hpat = gets.strip\n  nhpat = hpat.length\n  #p [nhpat, hpat]\n\n  dists = nhpat.times.map{hw.times.map{hw.times.map{MAX_INT}}}\n  dists[0][gst[0] + gst[1] * w][hst[0] + hst[1] * w] = 0\n\n  q = [[0, *gst, *hst]]\n  #p q\n\n  min_t = []\n\n  while ! q.empty?\n    ut, ugx, ugy, uhx, uhy = q.shift\n    if ugx == uhx && ugy == uhy\n      min_t = [dists[ut][ugx + ugy * w][uhx + uhy * w], ugy, ugx]\n      break\n    end\n\n    du = dists[ut][ugx + ugy * w][uhx + uhy * w]\n\n    hdx, hdy = HDXYS[hpat[ut]]\n    vhx = uhx + hdx\n    vhy = uhy + hdy\n    if vhx < 0 || vhx >= w || vhy < 0 || vhy >= h\n      vhx = uhx\n      vhy = uhy\n    end\n    vhid = vhx + vhy * w\n\n    vt = (ut + 1) % nhpat\n\n    for dxy in DXYS\n      vgx = ugx + dxy[0]\n      vgy = ugy + dxy[1]\n\n      if vgx >= 0 && vgx < w && vgy >= 0 && vgy < h && mat[vgy][vgx]\n        vgid = vgx + vgy * w\n        dv = dists[vt][vgid][vhid]\n        if dv > du + 1\n          dists[vt][vgid][vhid] = du + 1\n          if dv >= MAX_INT\n            q << [vt, vgx, vgy, vhx, vhy]\n          end\n        end\n      end\n    end\n  end\n\n  if min_t.empty?\n    puts 'impossible'\n  else\n    puts min_t.join(' ')\n  end\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    index = 0\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy || index >= 100\n            break\n        else\n            prevx = cbx\n            prevy = cby\n            index += 1\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "   f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==500 ?  \"impossible\" : min * \" \"\n    break\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    if a[0]==nil || b[0]==nil\n        gets\n        exit\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n       \n            break\n    end\n    puts min[0]==500 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(20).map{Array.new(20,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new(400)\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": " steps = Array.new(20).map{Array.new(20,500)}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(20,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==500 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h+10)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h+10).map{Array.new(w+10,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h+10).map{Array.new(w+10,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n   end\nbreak\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "\n    steps = Array.new(h).map{Array.new(w,100000)}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    \n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 5000\n$h = 0\n$w = 0\n\ndef bfs(bord,a)\n\twalks = [[1,0],[-1,0],[0,1],[0,-1]]\n\t\n\tnewpos = []\n\tqueue = [a]\n\t\n\twhile (!queue.empty?) do\n\t\tq = queue.shift\n\t\twalks.each{|ws|\n\t\t\tnewpos[0] = q[0] + ws[0]\n\t\t\tnewpos[1] = q[1] + ws[1]\n\t\t\tif newpos[0].between?(0,$h-1) and newpos[1].between?(0,$w-1) then\n\t\t\t\tif bord[newpos[0]][newpos[1]] > (bord[q[0]][q[1]]+1) then\n\t\t\t\t\tbord[newpos[0]][newpos[1]] = bord[q[0]][q[1]] + 1\n\t\t\t\t\tqueue.push([newpos[0],newpos[1]])\n\t\t\t\tend\n\t\t\tend\n\t\t}\n\tend\n\t\nend\n\nloop{\n\tstr = gets.split.map(&:to_i)\n    if str.size != 2\n        next\n    end\n    $h,$w = str[0],str[1]\n\tif ($h == 0 and $w == 0) then\n\t\texit\n\tend\n\ta = [0,0]\n\tb = [0,0]\n\tbord = Array.new($h).map{Array.new($w,0)}\n\n\t$h.times{|y|\t\n\t\tbord[y] = gets.chomp.split(//).map.with_index{|c,i|\n\t\t\tcase c\n\t\t\twhen \"A\" then\n\t\t\t\ta[0] = y\n\t\t\t\ta[1] = i\n\t\t\t\t0\n\t\t\twhen \"B\" then\n\t\t\t\tb[0] = y\n\t\t\t\tb[1] = i\n\t\t\t\tINF\n\t\t\twhen \".\" then\n\t\t\t\tINF\n\t\t\telse\n\t\t\t\t-1\n\t\t\tend\n\t\t}\n\t}\n\tbfs(bord,a)\n\tpat = gets.chomp\n\tbstep = 0\n\tflag = 0\n\tloop{\n\t\tpat.each_char{|ch|\n\t\t\tbstep += 1\n\t\t\tcase ch\n\t\t\twhen \"2\" then\n\t\t\t\tb[0] += b[0] < $h-1 ? 1:0\n\t\t\twhen \"4\" then\n\t\t\t\tb[1] -= b[1] > 0 ? 1:0\n\t\t\twhen \"6\" then\n\t\t\t\tb[1] += b[1] < $w-1 ? 1:0\n\t\t\twhen \"8\" then\n\t\t\t\tb[0] -= b[0] > 0 ? 1:0\n\t\t\twhen \"5\" then\n\t\t\tend\n\t\t\tif bord[b[0]][b[1]] != -1 and bstep >= bord[b[0]][b[1]] then\n\t\t\t\tprint(\"#{bstep} #{b[0].to_s} #{b[1]}\\n\")\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\t\tif flag == 1 then\n\t\t\tbreak;\n\t\tend\n\t\tif bstep >= 500 then\n\t\t\tprint \"impossible\\n\"\n\t\t\tbreak\n\t\tend\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "INF = 5000\n$h = 0\n$w = 0\n\ndef bfs(bord,a)\n\twalks = [[1,0],[-1,0],[0,1],[0,-1]]\n\tstep = bord[a[0]][a[1]]\n\tnewpos = []\n\twalks.each{|ws|\n\t\tnewpos[0] = a[0] + ws[0]\n\t\tnewpos[1] = a[1] + ws[1]\n\t\tif newpos[0].between?(0,$h-1) and newpos[1].between?(0,$w-1) then\n\t\t\tif bord[newpos[0]][newpos[1]] > (step+1) then\n\t\t\t\tbord[newpos[0]][newpos[1]] = step + 1\n\t\t\t\tbfs(bord,newpos)\n\t\t\tend\n\t\tend\n\t}\nend\n\nloop{\n\tstr = gets.split.map(&:to_i)\n    if str.size != 2\n        next\n    end\n    $h,$w = str[0],str[1]\n\n\tif ($h == 0 and $w == 0) then\n\t\texit\n\tend\n\ta = [0,0]\n\tb = [0,0]\n\tbord = Array.new($h).map{Array.new($w,0)}\n\n\t$h.times{|y|\t\n\t\tbord[y] = gets.chomp.split(//).map.with_index{|c,i|\n\t\t\tcase c\n\t\t\twhen \"A\" then\n\t\t\t\ta[0] = y\n\t\t\t\ta[1] = i\n\t\t\t\t0\n\t\t\twhen \"B\" then\n\t\t\t\tb[0] = y\n\t\t\t\tb[1] = i\n\t\t\t\tINF\n\t\t\twhen \".\" then\n\t\t\t\tINF\n\t\t\telse\n\t\t\t\t-1\n\t\t\tend\n\t\t}\n\t}\n\tbfs(bord,a)\n\tpat = gets.chomp\n\tbstep = 0\n\tflag = 0\n\tloop{\n\t\tpat.each_char{|ch|\n\t\t\tbstep += 1\n\t\t\tcase ch\n\t\t\twhen \"2\" then\n\t\t\t\tb[0] += b[0] < $h-1 ? 1:0\n\t\t\twhen \"4\" then\n\t\t\t\tb[1] -= b[1] > 0 ? 1:0\n\t\t\twhen \"6\" then\n\t\t\t\tb[1] += b[1] < $w-1 ? 1:0\n\t\t\twhen \"8\" then\n\t\t\t\tb[0] -= b[0] > 0 ? 1:0\n\t\t\twhen \"5\" then\n\t\t\tend\n\t\t\tif bord[b[0]][b[1]] != -1 and bstep >= bord[b[0]][b[1]] then\n\t\t\t\tprint(\"#{bstep} #{b[0].to_s} #{b[1]}\\n\")\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\t\tif flag == 1 then\n\t\t\tbreak;\n\t\tend\n\t\tif bstep >= ([$h,$w].max + 5) * pat.length then\n\t\t\tprint \"impossible\\n\"\n\t\t\tbreak\n\t\tend\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(20).map{Array.new(20,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n        break\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\n    exit\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\nend"
  },
  {
    "language": "Ruby",
    "code": "    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    pat = gets.chomp"
  },
  {
    "language": "Ruby",
    "code": "INF = 5000\n$h = 0\n$w = 0\n\ndef bfs(bord,a)\n\twalks = [[1,0],[-1,0],[0,1],[0,-1]]\n\tstep = bord[a[0]][a[1]]\n\tnewpos = []\n\twalks.each{|ws|\n\t\tnewpos[0] = a[0] + ws[0]\n\t\tnewpos[1] = a[1] + ws[1]\n\t\tif newpos[0].between?(0,$h-1) and newpos[1].between?(0,$w-1) then\n\t\t\tif bord[newpos[0]][newpos[1]] > (step+1) then\n\t\t\t\tbord[newpos[0]][newpos[1]] = step + 1\n\t\t\t\tbfs(bord,newpos)\n\t\t\tend\n\t\tend\n\t}\nend\n\nloop{\n\tstr = gets.split.map(&:to_i)\n    if str.size != 2\n        next\n    end\n    $h,$w = str[0],str[1]\n\n\tif ($h == 0 and $w == 0) then\n\t\texit\n\tend\n\ta = [0,0]\n\tb = [0,0]\n\tbord = Array.new($h).map{Array.new($w,0)}\n\n\t$h.times{|y|\t\n\t\tbord[y] = gets.chomp.split(//).map.with_index{|c,i|\n\t\t\tcase c\n\t\t\twhen \"A\" then\n\t\t\t\ta[0] = y\n\t\t\t\ta[1] = i\n\t\t\t\t0\n\t\t\twhen \"B\" then\n\t\t\t\tb[0] = y\n\t\t\t\tb[1] = i\n\t\t\t\tINF\n\t\t\twhen \".\" then\n\t\t\t\tINF\n\t\t\telse\n\t\t\t\t-1\n\t\t\tend\n\t\t}\n\t}\n\tbfs(bord,a)\n\tpat = gets.chomp\n\tbstep = 0\n\tflag = 0\n\tloop{\n\t\tpat.each_char{|ch|\n\t\t\tbstep += 1\n\t\t\tcase ch\n\t\t\twhen \"2\" then\n\t\t\t\tb[0] += b[0] < $h-1 ? 1:0\n\t\t\twhen \"4\" then\n\t\t\t\tb[1] -= b[1] > 0 ? 1:0\n\t\t\twhen \"6\" then\n\t\t\t\tb[1] += b[1] < $w-1 ? 1:0\n\t\t\twhen \"8\" then\n\t\t\t\tb[0] -= b[0] > 0 ? 1:0\n\t\t\twhen \"5\" then\n\t\t\tend\n\t\t\tif bord[b[0]][b[1]] != -1 and bstep >= bord[b[0]][b[1]] then\n\t\t\t\tprint(\"#{bstep} #{b[0].to_s} #{b[1]}\\n\")\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\t\tif flag == 1 then\n\t\t\tbreak;\n\t\tend\n\t\tif bstep >= 500 then\n\t\t\tprint \"impossible\\n\"\n\t\t\tbreak\n\t\tend\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n     break\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "INF = 5000\n$h = 0\n$w = 0\n\ndef bfs(bord,a)\n\twalks = [[1,0],[-1,0],[0,1],[0,-1]]\n\tstep = bord[a[0]][a[1]]\n\tnewpos = []\n\twalks.each{|ws|\n\t\tnewpos[0] = a[0] + ws[0]\n\t\tnewpos[1] = a[1] + ws[1]\n\t\tif newpos[0].between?(0,$h-1) and newpos[1].between?(0,$w-1) then\n\t\t\tif bord[newpos[0]][newpos[1]] > (step+1) then\n\t\t\t\tbord[newpos[0]][newpos[1]] = step + 1\n\t\t\t\tbfs(bord,newpos)\n\t\t\tend\n\t\tend\n\t}\nend\n\nloop{\n\t$h,$w = gets.chomp.split.map(&:to_i)\n\n\tif ($h == 0 and $w == 0) then\n\t\tbreak\n\tend\n\ta = [0,0]\n\tb = [0,0]\n\tbord = Array.new($h).map{Array.new($w,0)}\n\n\t$h.times{|y|\t\n\t\tbord[y] = gets.chomp.split(//).map.with_index{|c,i|\n\t\t\tcase c\n\t\t\twhen \"A\" then\n\t\t\t\ta[0] = y\n\t\t\t\ta[1] = i\n\t\t\t\t0\n\t\t\twhen \"B\" then\n\t\t\t\tb[0] = y\n\t\t\t\tb[1] = i\n\t\t\t\tINF\n\t\t\twhen \".\" then\n\t\t\t\tINF\n\t\t\telse\n\t\t\t\t-1\n\t\t\tend\n\t\t}\n\t}\n\tbfs(bord,a)\n\tpat = gets.chomp\n\tbstep = 0\n\tflag = 0\n\tloop{\n\t\tpat.each_char{|ch|\n\t\t\tbstep += 1\n\t\t\tcase ch\n\t\t\twhen \"2\" then\n\t\t\t\tb[0] += b[0] < $h-1 ? 1:0\n\t\t\twhen \"4\" then\n\t\t\t\tb[1] -= b[1] > 0 ? 1:0\n\t\t\twhen \"6\" then\n\t\t\t\tb[1] += b[1] < $w-1 ? 1:0\n\t\t\twhen \"8\" then\n\t\t\t\tb[0] -= b[0] > 0 ? 1:0\n\t\t\twhen \"5\" then\n\t\t\tend\n\t\t\tif bord[b[0]][b[1]] != -1 and bstep >= bord[b[0]][b[1]] then\n\t\t\t\tprint(\"#{bstep} #{b[0].to_s} #{b[1]}\\n\")\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\t\tif flag == 1 then\n\t\t\tbreak;\n\t\tend\n\t\tif bstep >= 500 then\n\t\t\tprint \"impossible\\n\"\n\t\t\tbreak\n\t\tend\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy || true\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    str = gets.split.map(&:to_i)\n    if str.size != 2\n        next\n    end\n    h = str[0]\n    w = str[1]\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==500 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] >= 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                else\n                    while steps[cby][cbx] > bsteps[cby][cbx]\n                        if steps[cby][cbx] >= 100000\n                            break\n                        end\n                        bsteps[cby][cbx] += pat.length\n                    end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    #puts min[0]==100000 ?  \"impossible\" : min * \" \"\n    if min[0]==100000\n        puts \"impossible\"\n    else\n        puts min[0].to_s << \" \" << min[1].to_s << \" \" << min[2].to_s\n    end\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]"
  },
  {
    "language": "Ruby",
    "code": "INF = 5000\n$h = 0\n$w = 0\n\ndef bfs(bord,a)\n\twalks = [[1,0],[-1,0],[0,1],[0,-1]]\n\tstep = bord[a[0]][a[1]]\n\tnewpos = []\n\twalks.each{|ws|\n\t\tnewpos[0] = a[0] + ws[0]\n\t\tnewpos[1] = a[1] + ws[1]\n\t\tif newpos[0].between?(0,$h-1) and newpos[1].between?(0,$w-1) then\n\t\t\tif bord[newpos[0]][newpos[1]] > (step+1) then\n\t\t\t\tbord[newpos[0]][newpos[1]] = step + 1\n\t\t\t\tbfs(bord,newpos)\n\t\t\tend\n\t\tend\n\t}\nend\n\nloop{\n\tstr = gets.split.map(&:to_i)\n    if str.size != 2\n        next\n    end\n    $h,$w = str[0],str[1]\n\n\tif ($h == 0 and $w == 0) then\n\t\texit\n\tend\n\ta = [0,0]\n\tb = [0,0]\n\tbord = Array.new($h).map{Array.new($w,0)}\n\n\t$h.times{|y|\t\n\t\tbord[y] = gets.chomp.split(//).map.with_index{|c,i|\n\t\t\tcase c\n\t\t\twhen \"A\" then\n\t\t\t\ta[0] = y\n\t\t\t\ta[1] = i\n\t\t\t\t0\n\t\t\twhen \"B\" then\n\t\t\t\tb[0] = y\n\t\t\t\tb[1] = i\n\t\t\t\tINF\n\t\t\twhen \".\" then\n\t\t\t\tINF\n\t\t\telse\n\t\t\t\t-1\n\t\t\tend\n\t\t}\n\t}\n\tbfs(bord,a)\n\tpat = gets.chomp\n\tbstep = 0\n\tflag = 0\n\tloop{\n\t\tpat.each_char{|ch|\n\t\t\tbstep += 1\n\t\t\tcase ch\n\t\t\twhen \"2\" then\n\t\t\t\tb[0] += b[0] < $h-1 ? 1:0\n\t\t\twhen \"4\" then\n\t\t\t\tb[1] -= b[1] > 0 ? 1:0\n\t\t\twhen \"6\" then\n\t\t\t\tb[1] += b[1] < $w-1 ? 1:0\n\t\t\twhen \"8\" then\n\t\t\t\tb[0] -= b[0] > 0 ? 1:0\n\t\t\twhen \"5\" then\n\t\t\tend\n\t\t\tif bord[b[0]][b[1]] != -1 and bstep >= bord[b[0]][b[1]] then\n\t\t\t\tprint(\"#{bstep} #{b[0].to_s} #{b[1]}\\n\")\n\t\t\t\tflag = 1\n\t\t\t\tbreak\n\t\t\tend\n\t\t}\n\t\tif flag == 1 then\n\t\t\tbreak;\n\t\tend\n\t\tif bstep >= (([$h,$w].max + 5) * pat.length) then\n\t\t\tprint \"impossible\\n\"\n\t\t\tbreak\n\t\tend\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(20,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "   h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\n    =begin\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        end\n    end\n    =end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==Float::INFINITY && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nwhile true do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        break\n    end\n    f = Array.new(h)\n    a = Array.new(2)\n    b = Array.new(2)\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,Float::INFINITY)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[1],a[0],steps,q,h,w)\n    bsteps = Array.new(h).map{Array.new(w,100000)}\n    bsteps[b[0]][b[1]] = 0\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                    bsteps[cby][cbx] = cs\n                while steps[cby][cbx] > bsteps[cby][cbx]\n                    if steps[cby][cbx] > 100000\n                        break\n                    end\n                    bsteps[cby][cbx] += pat.length\n                end\n                    if [steps[cby][cbx],bsteps[cby][cbx]].max < min[0]\n                        min[1] = cby\n                        min[2] = cbx\n                        min[0] = [steps[cby][cbx],bsteps[cby][cbx]].max\n                    end\n                end\n            end\n        end\n        if cbx == prevx && cby == prevy\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "\n    steps = Array.new(h).map{100000}"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==100000 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    prevy = cby\n    prevx = cbx\n    min = Array.new(3,100000)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n        if cs > h*w*pat.length\n            break\n        else\n            prevx = cbx\n            prevy = cby\n        end\n    end\n    puts min[0]==100000 ?  \"impossible\" : min * \" \"\nend"
  },
  {
    "language": "Ruby",
    "code": "loop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,100000)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,100000)\nend"
  },
  {
    "language": "Ruby",
    "code": "$dx = [0,1,0,-1]\n$dy = [1,0,-1,0]\ndef bfs(f, sy, sx, steps, q, r, c)\n    for i in 0..3\n        cy = sy + $dy[i]\n        cx = sx + $dx[i]\n        if cy.between?(0,r-1) && cx.between?(0,c-1) && steps[cy][cx]==500 && f[cy][cx]!=\"#\"\n            q.push([cy,cx])\n            steps[cy][cx] = steps[sy][sx] + 1\n        end\n    end\n    while q.size > 0\n        cy, cx = q.shift\n        steps = bfs(f,cy,cx,steps,q,r,c)\n    end\n    return steps\nend\n\nloop do\n    h, w = gets.split.map(&:to_i)\n    if h==0&&w==0\n        exit\n    end\n    f = Array.new()\n    a = Array.new()\n    b = Array.new()\n    h.times do |i|\n        f[i] = gets.chomp\n        if f[i].include?(\"A\")\n            a[0] = i\n            a[1] = f[i].index(\"A\")\n        end\n        if f[i].include?(\"B\")\n            b[0] = i\n            b[1] = f[i].index(\"B\")\n        end\n    end\n    steps = Array.new(h).map{Array.new(w,500)}\n    steps[a[0]][a[1]] = 0\n    q = Array.new()\n    steps = bfs(f,a[0],a[1],steps,q,h,w)\n    pat = gets.chomp\n    cs = 0\n    cby = b[0]\n    cbx = b[1]\n    min = Array.new(3,500)\n    loop do\n        pat.each_char do |c|\n            cs += 1\n            case c\n            when '5'\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '8'\n                if cby > 0\n                    cby -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '6'\n                if cbx < w-1\n                    cbx += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '4'\n                if cbx > 0\n                    cbx -= 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            when '2'\n                if cby < h-1\n                    cby += 1\n                end\n                if steps[cby][cbx] > cs\n                    next\n                end\n                if [steps[cby][cbx],cs].max < min[0]\n                    min[1] = cby\n                    min[2] = cbx\n                    min[0] = [steps[cby][cbx],cs].max\n                end\n            end\n        end\n     end\n  end"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"math\"\n\t\"os\"\n\t\"strconv\"\n)\n\nfunc configure(scanner *bufio.Scanner) {\n\tscanner.Split(bufio.ScanWords)\n\tscanner.Buffer(make([]byte, 1000005), 1000005)\n}\nfunc getNextString(scanner *bufio.Scanner) string {\n\tscanned := scanner.Scan()\n\tif !scanned {\n\t\tpanic(\"scan failed\")\n\t}\n\treturn scanner.Text()\n}\nfunc getNextInt(scanner *bufio.Scanner) int {\n\ti, _ := strconv.Atoi(getNextString(scanner))\n\treturn i\n}\nfunc getNextInt64(scanner *bufio.Scanner) int64 {\n\ti, _ := strconv.ParseInt(getNextString(scanner), 10, 64)\n\treturn i\n}\nfunc getNextFloat64(scanner *bufio.Scanner) float64 {\n\ti, _ := strconv.ParseFloat(getNextString(scanner), 64)\n\treturn i\n}\nfunc main() {\n\tfp := os.Stdin\n\twfp := os.Stdout\n\textra := 0\n\tif os.Getenv(\"I\") == \"IronMan\" {\n\t\tfp, _ = os.Open(os.Getenv(\"END_GAME\"))\n\t\textra = 100\n\t}\n\tscanner := bufio.NewScanner(fp)\n\tconfigure(scanner)\n\twriter := bufio.NewWriter(wfp)\n\tdefer func() {\n\t\tr := recover()\n\t\tif r != nil {\n\t\t\tfmt.Fprintln(writer, r)\n\t\t}\n\t\twriter.Flush()\n\t}()\n\tsolve(scanner, writer)\n\tfor i := 0; i < extra; i++ {\n\t\tfmt.Fprintln(writer, \"-----------------------------------\")\n\t\tsolve(scanner, writer)\n\t}\n}\nfunc solve(scanner *bufio.Scanner, writer *bufio.Writer) {\n\tdy := [4]int{-1, 0, 0, 1}\n\tdx := [4]int{0, -1, 1, 0}\n\tfor {\n\t\th := getNextInt(scanner)\n\t\tw := getNextInt(scanner)\n\t\tif h == 0 {\n\t\t\tbreak\n\t\t}\n\t\tgrid := makeGrid(h, w)\n\t\ta := [2]int{}\n\t\tb := [2]int{}\n\t\tfor i := 0; i < h; i++ {\n\t\t\ts := getNextString(scanner)\n\t\t\tfor j := 0; j < w; j++ {\n\t\t\t\tif s[j] == '#' {\n\t\t\t\t\tgrid[i][j] = math.MaxInt32\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif s[j] == 'A' {\n\t\t\t\t\ta[0] = i\n\t\t\t\t\ta[1] = j\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif s[j] == 'B' {\n\t\t\t\t\tb[0] = i\n\t\t\t\t\tb[1] = j\n\t\t\t\t}\n\t\t\t\tgrid[i][j] = math.MaxInt32 - 1\n\t\t\t}\n\t\t}\n\t\tq := make([][2]int, 0)\n\t\tq = append(q, a)\n\t\tfor len(q) > 0 {\n\t\t\tp := q[0]\n\t\t\tq = q[1:]\n\t\t\tfor i := 0; i < 4; i++ {\n\t\t\t\tyy := p[0] + dy[i]\n\t\t\t\txx := p[1] + dx[i]\n\t\t\t\tif yy == a[0] && xx == a[1] {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif yy < 0 || yy >= h {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif xx < 0 || xx >= w {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif grid[yy][xx] == math.MaxInt32 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tif grid[yy][xx] <= grid[p[0]][p[1]]+1 {\n\t\t\t\t\tcontinue\n\t\t\t\t}\n\t\t\t\tgrid[yy][xx] = grid[p[0]][p[1]] + 1\n\t\t\t\tq = append(q, [2]int{yy, xx})\n\t\t\t}\n\t\t}\n\t\tmove := getNextString(scanner)\n\t\ti := 0\n\t\tm := len(move)\n\t\tfor {\n\t\t\tif i > 400 {\n\t\t\t\tfmt.Fprintln(writer, \"impossible\")\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif grid[b[0]][b[1]] <= i {\n\t\t\t\tfmt.Fprintln(writer, fmt.Sprintf(\"%d %d %d\", i, b[0], b[1]))\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tswitch move[i%m] {\n\t\t\tcase '8':\n\t\t\t\tif b[0] > 0 {\n\t\t\t\t\tb[0]--\n\t\t\t\t}\n\t\t\tcase '6':\n\t\t\t\tif b[1]+1 < w {\n\t\t\t\t\tb[1]++\n\t\t\t\t}\n\t\t\tcase '4':\n\t\t\t\tif b[1] > 0 {\n\t\t\t\t\tb[1]--\n\t\t\t\t}\n\t\t\tcase '2':\n\t\t\t\tif b[0]+1 < h {\n\t\t\t\t\tb[0]++\n\t\t\t\t}\n\t\t\t}\n\t\t\ti++\n\t\t}\n\t}\n}\nfunc makeGrid(h, w int) [][]int {\n\tindex := make([][]int, h, h)\n\tdata := make([]int, h*w, h*w)\n\tfor i := 0; i < h; i++ {\n\t\tindex[i] = data[i*w : (i+1)*w]\n\t}\n\treturn index\n}\n\n"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    alias Tuple!(int, \"x\", int, \"y\") P;\n    const id = [\n        '5': P(0, 0), \n        '8': P(0, -1),\n        '6': P(1, 0),\n        '4': P(-1, 0),\n        '2': P(0, 1),\n    ];\n    const dy = [1, 0, -1, 0],\n          dx = [0, 1, 0, -1];\n\n    void dump(int[][] A) {\n        foreach (L; A) {\n            //writeln(L.map!(\"a == int.max ? -1 : a\"));\n            writefln(\"%(%4s%)\", L.map!(\"a == int.max ? -1 : a\"));\n        }\n    }\n\n    int H, W;\n    string[] F;\n    string Pat;\n    bool input() {\n        readf(\"%d %d\\n\", &H, &W);\n        if (H == 0 && W == 0) return false;\n        F = new string[H];\n        foreach (i; 0 .. H) {\n            F[i] = readln.chomp;\n        }\n        Pat = readln.chomp;\n        return true;\n    }\n\n    void solve() {\n        int[][] X = new int[][](H, W);\n        foreach (i; 0 .. H) X[i][] = int.max;\n        \n        P find(char c) {\n            foreach (i; 0 .. H)\n                foreach (j; 0 .. W) \n                    if (F[i][j] == c) return P(j, i);\n            assert(false);\n        }\n\n        P s = find('A');\n        struct S {\n            P p;\n            int t;\n        }\n        DList!S Q;\n        Q.insert(S(s, 0));\n        X[s.y][s.x] = 0;\n        while (!Q.empty) {\n            S c = Q.front; Q.removeFront;\n            foreach (i; 0 .. 4) {\n                int ny = c.p.y + dy[i],\n                    nx = c.p.x + dx[i],\n                    nt = c.t + 1;\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (X[ny][nx] <= nt) continue;\n                X[ny][nx] = nt;\n                Q.insert(S( P(nx, ny), nt ));\n            }\n        }\n\n        //dump(X);\n\n        P g = find('B');\n        int t = 0;\n        while (true) {\n            foreach (c; Pat) {\n                //writeln(g);\n                t++;\n                if (t > H * W * Pat.length) {\n                    writeln(\"impossible\");\n                    return;\n                }\n                P d = id[c];\n                int ny = g.y + d.y,\n                    nx = g.x + d.x;\n                if (ny < 0 || ny >= H) ny = g.y;\n                if (nx < 0 || nx >= W) nx = g.x;\n                if (X[ny][nx] <= t) {\n                    writefln(\"%d %d %d\", t, ny, nx);\n                    return;\n                }\n                g.y = ny;\n                g.x = nx;\n            }\n        }\n    }\n\n    while (input()) solve();\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\n\nint INF = 1<<25;\nstruct Pos{int y, x;}\nint[] dx = [1, 0, -1,  0, 0];\nint[] dy = [0, 1,  0, -1, 0];\nvoid main() {\n    while(true) {\n        int H, W;\n        readf(\"%d %d\\n\", &H, &W);\n        if (H==0 && W==0) break;\n\n        Pos player;\n        Pos ghost;\n        bool[][] grid = H.iota.map!(i => readln.chomp.enumerate.tee!((a) {\n            if (a.value=='A') player = Pos(i.to!int, a.index.to!int);\n            if (a.value=='B') ghost = Pos(i.to!int, a.index.to!int);\n        }).map!(a => (a.value!='#')).array).array;\n\n        int[][] dist = new int[][](H, W);\n        foreach(ref e; dist) e[] = INF;\n        auto list = DList!Pos(player);\n        dist[player.y][player.x] = 0;\n        while (!list.empty) {\n            Pos p = list.front;\n            list.removeFront;\n            foreach(int i; 0..4) {\n                int _y = p.y+dy[i];\n                int _x = p.x+dx[i];\n                if (0<=_y && _y<H && 0<=_x && _x<W) {\n                    if (grid[_y][_x] && dist[_y][_x]==INF) {\n                        list.insert(Pos(_y, _x));\n                        dist[_y][_x] = dist[p.y][p.x]+1;\n                    }\n                }\n            }\n        }\n\n        int[] pattern = readln.chomp.map!(c => c=='6'?0:c=='2'?1:c=='4'?2:c=='8'?3:4).array;\n        bool flag = false;\n        int[] ans;\n        int time = 0;\n        for(int _=0; _<1000; _++) {\n            foreach(i; pattern) {\n                if (dist[ghost.y][ghost.x] <= time) {\n                    ans = [time, ghost.y, ghost.x];\n                    flag = true;\n                    break;\n                }\n                ghost = Pos(min(H-1, max(0, ghost.y+dy[i])), min(W-1, max(0, ghost.x+dx[i])));\n                time++;\n            }\n        }\n        writeln(flag ? ans.to!(string[]).join(\" \"):\"impossible\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\n\nint INF = 1<<25;\nstruct Pos{int y, x;}\nint[] dx = [1, 0, -1,  0, 0];\nint[] dy = [0, 1,  0, -1, 0];\nvoid main() {\n    while(true) {\n        int H, W;\n        readf(\"%d %d\\n\", &H, &W);\n        if (H==0 && W==0) break;\n\n        Pos player;\n        Pos[] ghost;\n        bool[][] grid = H.iota.map!(i => readln.chomp.enumerate.tee!((a) {\n            if (a.value=='A') player = Pos(i, a.index);\n            if (a.value=='B') ghost ~= Pos(i, a.index);\n        }).map!(a => (a.value!='#')).array).array;\n\n        int[][] dist = new int[][](H, W);\n        foreach(ref e; dist) e[] = INF;\n        auto list = DList!Pos(player);\n        dist[player.y][player.x] = 0;\n        while (!list.empty) {\n            Pos p = list.front;\n            list.removeFront;\n            foreach(int i; 0..4) {\n                int _y = p.y+dy[i];\n                int _x = p.x+dx[i];\n                if (0<=_y && _y<H && 0<=_x && _x<W) {\n                    if (grid[_y][_x] && dist[_y][_x]==INF) {\n                        list.insert(Pos(_y, _x));\n                        dist[_y][_x] = dist[p.y][p.x]+1;\n                    }\n                }\n            }\n        }\n\n        int[] pattern = readln.chomp.map!(c => c=='6'?0:c=='2'?1:c=='4'?2:c=='8'?3:4).array;\n        bool flag = false;\n        int[] ans;\n        int time = 0;\n        for(int _=0; _<100000; _++) {\n            foreach(i; pattern) {\n                if (dist[ghost.back.y][ghost.back.x] <= time) {\n                    ans = [time, ghost.back.y, ghost.back.x];\n                    flag = true;\n                    break;\n                }\n                ghost ~= Pos(min(H-1, max(0, ghost.back.y+dy[i])), min(W-1, max(0, ghost.back.x+dx[i])));\n                time++;\n            }\n        }\n        writeln(flag ? ans.to!(string[]).join(\" \"):\"impossible\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "module aoj;\nimport std.array;\nimport std.algorithm;\nimport std.conv;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nclass FixedQueue(T) {\n  private T[] mData;\n  private int mCapacity;\n  private int mHead;\n  private int mTail;\n\n  this(int capacity) {\n    mHead = mTail = 0;\n    mCapacity = capacity;\n    mData = new T[capacity];\n  }\n\n  void push(T x) {\n    mData[mHead] = x;\n    mHead = (mHead + 1) % mCapacity;\n  }\n\n  T pop() {\n    scope(exit) { mTail = (mTail + 1) % mCapacity; }\n    return mData[mTail];\n  }\n\n  bool empty() { return mHead == mTail; }\n}\n\nstring getLine() {\n  string ret;\n  do {\n    ret = chomp(readln());\n  } while (ret.length == 0);\n  return ret;\n}\n\nvoid main() {\n  for (;;) {\n    // Input\n    string[] input = split(getLine());\n    int H = to!int(input[0]);\n    int W = to!int(input[1]);\n    auto field = new char[][](H, W);\n    if (H == 0 && W == 0) { break; }\n    int ay = -1, ax = -1;\n    int by = -1, bx = -1;\n    foreach (y; 0 .. H) {\n      string line = readln();\n      foreach (x; 0 .. W) {\n        if (line[x] == 'A') {\n          ay = y;\n          ax = x;\n          field[y][x] = '.';\n        } else if (line[x] == 'B') {\n          by = y;\n          bx = x;\n          field[y][x] = '.';\n        } else {\n          field[y][x] = line[x];\n        }\n      }\n    }\n    string pattern = chomp(readln());\n\n    // BFS\n    immutable(int[]) dy = [-1, 0, 1, 0];\n    immutable(int[]) dx = [0, -1, 0, 1];\n    alias Tuple!(int, \"y\", int, \"x\") State;\n    auto Q = new FixedQueue!State(2 * (H + W));\n    auto cost = new int[][](H, W);\n    foreach (c; cost) { c[] = -1; }\n    Q.push(State(ay, ax));\n    cost[ay][ax] = 0;\n    while (!Q.empty()) {\n      State s = Q.pop();\n      foreach (k; 0 .. 4) {\n        int ny = s.y + dy[k];\n        int nx = s.x + dx[k];\n        if (0 <= ny && ny < H && 0 <= nx && nx < W) {\n          if (field[ny][nx] == '.' && cost[ny][nx] == -1) {\n            cost[ny][nx] = cost[s.y][s.x] + 1;\n            Q.push(State(ny, nx));\n          }\n        }\n      }\n    }\n\n    // Simulation\n    bool ok = false;\n    int limit = cast(int)pattern.length * H * W;\n    foreach (time; 0 .. limit) {\n      if (cost[by][bx] != -1 && cost[by][bx] <= time) {\n        writefln(\"%d %d %d\", time, by, bx);\n        ok = true;\n        break;\n      }\n      switch (pattern[time % pattern.length]) {\n      case '5': break;\n      case '8': by -= 1; break;\n      case '6': bx += 1; break;\n      case '4': bx -= 1; break;\n      case '2': by += 1; break;\n      default: assert(false);\n      }\n      by = max(0, min(H - 1, by));\n      bx = max(0, min(W - 1, bx));\n    }\n    if (!ok) { writeln(\"impossible\"); }\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    alias Tuple!(int, \"x\", int, \"y\") P;\n    const id = [\n        '5': P(0, 0), \n        '8': P(0, -1),\n        '6': P(1, 0),\n        '4': P(-1, 0),\n        '2': P(0, 1),\n    ];\n    const dy = [1, 0, -1, 0],\n          dx = [0, 1, 0, -1];\n\n    int H, W;\n    string[] F;\n    string Pat;\n    bool input() {\n        scanf(\"%d %d\\n\", &H, &W);\n        if (H == 0 && W == 0) return false;\n        F = new string[H];\n        foreach (i; 0 .. H) {\n            F[i] = readln.chomp;\n        }\n        Pat = readln.chomp;\n        return true;\n    }\n\n    void solve() {\n        int[][] X = new int[][](H, W);\n        foreach (i; 0 .. H) X[i][] = int.max;\n        \n        P find(char c) {\n            foreach (i; 0 .. H)\n                foreach (j; 0 .. W) \n                    if (F[i][j] == c) return P(j, i);\n            assert(false);\n        }\n\n        P s = find('A');\n        struct S {\n            P p;\n            int t;\n        }\n        DList!S Q;\n        Q.insert(S(s, 0));\n        X[s.y][s.x] = 0;\n        while (!Q.empty) {\n            S c = Q.front; Q.removeFront;\n            foreach (i; 0 .. 4) {\n                int ny = c.p.y + dy[i],\n                    nx = c.p.x + dx[i],\n                    nt = c.t + 1;\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (X[ny][nx] <= nt) continue;\n                X[ny][nx] = nt;\n                Q.insert(S( P(nx, ny), nt ));\n            }\n        }\n\n        P g = find('B');\n        int t = 0;\n        while (true) {\n            foreach (c; Pat) {\n                t++;\n                if (t > H * W * Pat.length) {\n                    writeln(\"impossible\");\n                    return;\n                }\n                P d = id[c];\n                int ny = g.y + d.y,\n                    nx = g.x + d.x;\n                if (ny < 0 || ny >= H) ny = g.y;\n                if (nx < 0 || nx >= W) nx = g.x;\n                if (X[ny][nx] <= t) {\n                    writefln(\"%d %d %d\", t, ny, nx);\n                    return;\n                }\n                g.y = ny;\n                g.x = nx;\n            }\n        }\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "module aoj;\nimport std.array;\nimport std.algorithm;\nimport std.conv;\nimport std.range;\nimport std.stdio;\nimport std.string;\nimport std.typecons;\n\nclass FixedQueue(T) {\n  private T[] mData;\n  private int mCapacity;\n  private int mHead;\n  private int mTail;\n\n  this(int capacity) {\n    mHead = mTail = 0;\n    mCapacity = capacity;\n    mData = new T[capacity];\n  }\n\n  void push(T x) {\n    mData[mHead] = x;\n    mHead = (mHead + 1) % mCapacity;\n  }\n\n  T pop() {\n    scope(exit) { mTail = (mTail + 1) % mCapacity; }\n    return mData[mTail];\n  }\n\n  bool empty() { return mHead == mTail; }\n}\n\nvoid main() {\n  for (;;) {\n    // Input\n    string[] input = split(readln());\n    int H = to!int(input[0]);\n    int W = to!int(input[1]);\n    auto field = new char[][](H, W);\n    if (H == 0 && W == 0) { break; }\n    int ay = -1, ax = -1;\n    int by = -1, bx = -1;\n    foreach (y; 0 .. H) {\n      string line = readln();\n      foreach (x; 0 .. W) {\n        if (line[x] == 'A') {\n          ay = y;\n          ax = x;\n          field[y][x] = '.';\n        } else if (line[x] == 'B') {\n          by = y;\n          bx = x;\n          field[y][x] = '.';\n        } else {\n          field[y][x] = line[x];\n        }\n      }\n    }\n    string pattern = chomp(readln());\n\n    // BFS\n    immutable(int[]) dy = [-1, 0, 1, 0];\n    immutable(int[]) dx = [0, -1, 0, 1];\n    alias Tuple!(int, \"y\", int, \"x\") State;\n    auto Q = new FixedQueue!State(2 * (H + W));\n    auto cost = new int[][](H, W);\n    foreach (c; cost) { c[] = -1; }\n    Q.push(State(ay, ax));\n    cost[ay][ax] = 0;\n    while (!Q.empty()) {\n      State s = Q.pop();\n      foreach (k; 0 .. 4) {\n        int ny = s.y + dy[k];\n        int nx = s.x + dx[k];\n        if (0 <= ny && ny < H && 0 <= nx && nx < W) {\n          if (field[ny][nx] == '.' && cost[ny][nx] == -1) {\n            cost[ny][nx] = cost[s.y][s.x] + 1;\n            Q.push(State(ny, nx));\n          }\n        }\n      }\n    }\n\n    // Simulation\n    bool ok = false;\n    int limit = cast(int)pattern.length * H * W;\n    foreach (time; 0 .. limit) {\n      if (cost[by][bx] != -1 && cost[by][bx] <= time) {\n        writefln(\"%d %d %d\", time, by, bx);\n        ok = true;\n        break;\n      }\n      switch (pattern[time % pattern.length]) {\n      case '5': break;\n      case '8': by -= 1; break;\n      case '6': bx += 1; break;\n      case '4': bx -= 1; break;\n      case '2': by += 1; break;\n      default: assert(false);\n      }\n      by = max(0, min(H - 1, by));\n      bx = max(0, min(W - 1, bx));\n    }\n    if (!ok) { writeln(\"impossible\"); }\n  }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    alias Tuple!(int, \"x\", int, \"y\") P;\n    const id = [\n        '5': P(0, 0), \n        '8': P(0, -1),\n        '6': P(1, 0),\n        '4': P(-1, 0),\n        '2': P(0, 1),\n    ];\n    const dy = [1, 0, -1, 0],\n          dx = [0, 1, 0, -1];\n\n    void dump(int[][] A) {\n        foreach (L; A) {\n            //writeln(L.map!(\"a == int.max ? -1 : a\"));\n            writefln(\"%(%4s%)\", L.map!(\"a == int.max ? -1 : a\"));\n        }\n    }\n\n    int H, W;\n    string[] F;\n    string Pat;\n    bool input() {\n        readf(\"%d %d\\n\", &H, &W);\n        if (H == 0 && W == 0) return false;\n        F = new string[H];\n        foreach (i; 0 .. H) {\n            F[i] = readln.chomp;\n        }\n        Pat = readln.chomp;\n        return true;\n    }\n\n    void solve() {\n        int[][] X = new int[][](H, W);\n        foreach (i; 0 .. H) X[i][] = int.max;\n        \n        P find(char c) {\n            foreach (i; 0 .. H)\n                foreach (j; 0 .. W) \n                    if (F[i][j] == c) return P(j, i);\n            assert(false);\n        }\n\n        P s = find('A');\n        alias Tuple!(P, \"p\", int, \"t\") S;\n        DList!S Q;\n        Q.insert(S(s, 0));\n        X[s.y][s.x] = 0;\n        while (!Q.empty) {\n            S c = Q.front; Q.removeFront;\n            foreach (i; 0 .. 4) {\n                int ny = c.p.y + dy[i],\n                    nx = c.p.x + dx[i],\n                    nt = c.t + 1;\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (X[ny][nx] <= nt) continue;\n                X[ny][nx] = nt;\n                Q.insert(S( P(nx, ny), nt ));\n            }\n        }\n\n        //dump(X);\n\n        P g = find('B');\n        int t = 0;\n        while (true) {\n            foreach (c; Pat) {\n                //writeln(g);\n                t++;\n                if (t > H * W * Pat.length) {\n                    writeln(\"impossible\");\n                    return;\n                }\n                P d = id[c];\n                int ny = g.y + d.y,\n                    nx = g.x + d.x;\n                if (ny < 0 || ny >= H) ny = g.y;\n                if (nx < 0 || nx >= W) nx = g.x;\n                if (X[ny][nx] <= t) {\n                    writefln(\"%d %d %d\", t, ny, nx);\n                    return;\n                }\n                g.y = ny;\n                g.x = nx;\n            }\n        }\n    }\n\n    while (input()) solve();\n\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.string;\nimport std.conv;\nimport std.typecons;\nimport std.algorithm;\nimport std.functional;\nimport std.bigint;\nimport std.numeric;\nimport std.array;\nimport std.math;\nimport std.range;\nimport std.container;\nimport std.ascii;\n\nint INF = 1<<25;\nstruct Pos{int y, x;}\nint[] dx = [1, 0, -1,  0, 0];\nint[] dy = [0, 1,  0, -1, 0];\nvoid main() {\n    while(true) {\n        int H, W;\n        readf(\"%d %d\\n\", &H, &W);\n        if (H==0 && W==0) break;\n\n        Pos player;\n        Pos[] ghost;\n        bool[][] grid = H.iota.map!(i => readln.chomp.enumerate.tee!((a) {\n            if (a.value=='A') player = Pos(i.to!int, a.index.to!int);\n            if (a.value=='B') ghost ~= Pos(i.to!int, a.index.to!int);\n        }).map!(a => (a.value!='#')).array).array;\n\n        int[][] dist = new int[][](H, W);\n        foreach(ref e; dist) e[] = INF;\n        auto list = DList!Pos(player);\n        dist[player.y][player.x] = 0;\n        while (!list.empty) {\n            Pos p = list.front;\n            list.removeFront;\n            foreach(int i; 0..4) {\n                int _y = p.y+dy[i];\n                int _x = p.x+dx[i];\n                if (0<=_y && _y<H && 0<=_x && _x<W) {\n                    if (grid[_y][_x] && dist[_y][_x]==INF) {\n                        list.insert(Pos(_y, _x));\n                        dist[_y][_x] = dist[p.y][p.x]+1;\n                    }\n                }\n            }\n        }\n\n        int[] pattern = readln.chomp.map!(c => c=='6'?0:c=='2'?1:c=='4'?2:c=='8'?3:4).array;\n        bool flag = false;\n        int[] ans;\n        int time = 0;\n        for(int _=0; _<100000; _++) {\n            foreach(i; pattern) {\n                if (dist[ghost.back.y][ghost.back.x] <= time) {\n                    ans = [time, ghost.back.y, ghost.back.x];\n                    flag = true;\n                    break;\n                }\n                ghost ~= Pos(min(H-1, max(0, ghost.back.y+dy[i])), min(W-1, max(0, ghost.back.x+dx[i])));\n                time++;\n            }\n        }\n        writeln(flag ? ans.to!(string[]).join(\" \"):\"impossible\");\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    alias Tuple!(int, \"x\", int, \"y\") P;\n    const id = [\n        '5': P(0, 0), \n        '8': P(0, -1),\n        '6': P(1, 0),\n        '4': P(-1, 0),\n        '2': P(0, 1),\n    ];\n    const dy = [1, 0, -1, 0],\n          dx = [0, 1, 0, -1];\n\n    int H, W;\n    string[] F;\n    string Pat;\n    bool input() {\n        readf(\"%d %d\\n\", &H, &W);\n        if (H == 0 && W == 0) return false;\n        F = new string[H];\n        foreach (i; 0 .. H) {\n            F[i] = readln.chomp;\n        }\n        Pat = readln.chomp;\n        return true;\n    }\n\n    void solve() {\n        int[][] X = new int[][](H, W);\n        foreach (i; 0 .. H) X[i][] = int.max;\n        \n        P find(char c) {\n            foreach (i; 0 .. H)\n                foreach (j; 0 .. W) \n                    if (F[i][j] == c) return P(j, i);\n            assert(false);\n        }\n\n        P s = find('A');\n        struct S {\n            P p;\n            int t;\n        }\n        DList!S Q;\n        Q.insert(S(s, 0));\n        X[s.y][s.x] = 0;\n        while (!Q.empty) {\n            S c = Q.front; Q.removeFront;\n            foreach (i; 0 .. 4) {\n                int ny = c.p.y + dy[i],\n                    nx = c.p.x + dx[i],\n                    nt = c.t + 1;\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (X[ny][nx] <= nt) continue;\n                X[ny][nx] = nt;\n                Q.insert(S( P(nx, ny), nt ));\n            }\n        }\n\n        P g = find('B');\n        int t = 0;\n        while (true) {\n            foreach (c; Pat) {\n                t++;\n                if (t > H * W * Pat.length) {\n                    writeln(\"impossible\");\n                    return;\n                }\n                P d = id[c];\n                int ny = g.y + d.y,\n                    nx = g.x + d.x;\n                if (ny < 0 || ny >= H) ny = g.y;\n                if (nx < 0 || nx >= W) nx = g.x;\n                if (X[ny][nx] <= t) {\n                    writefln(\"%d %d %d\", t, ny, nx);\n                    return;\n                }\n                g.y = ny;\n                g.x = nx;\n            }\n        }\n    }\n\n    while (input()) solve();\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n \nvoid main() {\n    alias Tuple!(int, \"x\", int, \"y\") P;\n    const id = [\n        '5': P(0, 0), \n        '8': P(0, -1),\n        '6': P(1, 0),\n        '4': P(-1, 0),\n        '2': P(0, 1),\n    ];\n    const dy = [1, 0, -1, 0],\n          dx = [0, 1, 0, -1];\n\n    void dump(int[][] A) {\n        foreach (L; A) {\n            //writeln(L.map!(\"a == int.max ? -1 : a\"));\n            writefln(\"%(%4s%)\", L.map!(\"a == int.max ? -1 : a\"));\n        }\n    }\n\n    int H, W;\n    string[] F;\n    string Pat;\n    bool input() {\n        readf(\"%d %d\\n\", &H, &W);\n        if (H == 0 && W == 0) return false;\n        F = new string[H];\n        foreach (i; 0 .. H) {\n            F[i] = readln.chomp;\n        }\n        Pat = readln.chomp;\n        return true;\n    }\n\n    void solve() {\n        int[][] X = new int[][](H, W);\n        foreach (i; 0 .. H) X[i][] = int.max;\n        \n        P find(char c) {\n            foreach (i; 0 .. H)\n                foreach (j; 0 .. W) \n                    if (F[i][j] == c) return P(j, i);\n            assert(false);\n        }\n\n        P s = find('A');\n        alias Tuple!(const P, \"p\", int, \"t\") S;\n        DList!S Q;\n        Q.insert(S(s, 0));\n        X[s.y][s.x] = 0;\n        while (!Q.empty) {\n            S c = Q.front; Q.removeFront;\n            foreach (i; 0 .. 4) {\n                int ny = c.p.y + dy[i],\n                    nx = c.p.x + dx[i],\n                    nt = c.t + 1;\n                if (ny < 0 || ny >= H) continue;\n                if (nx < 0 || nx >= W) continue;\n                if (F[ny][nx] == '#') continue;\n                if (X[ny][nx] <= nt) continue;\n                X[ny][nx] = nt;\n                Q.insert(S( P(nx, ny), nt ));\n            }\n        }\n\n        //dump(X);\n\n        P g = find('B');\n        int t = 0;\n        while (true) {\n            foreach (c; Pat) {\n                //writeln(g);\n                t++;\n                if (t > H * W * Pat.length) {\n                    writeln(\"impossible\");\n                    return;\n                }\n                P d = id[c];\n                int ny = g.y + d.y,\n                    nx = g.x + d.x;\n                if (ny < 0 || ny >= H) ny = g.y;\n                if (nx < 0 || nx >= W) nx = g.x;\n                if (X[ny][nx] <= t) {\n                    writefln(\"%d %d %d\", t, ny, nx);\n                    return;\n                }\n                g.y = ny;\n                g.x = nx;\n            }\n        }\n    }\n\n    while (input()) solve();\n\n}"
  },
  {
    "language": "Python",
    "code": "from collections import deque\nwhile True:\n  h, w = map(int, input().split())\n  if h == 0:\n    break\n  mp = [list(\"X\" + input() + \"X\") for _ in range(h)]\n  mp.insert(0, [\"X\"] * (w + 2))\n  mp.append([\"X\"] * (w + 2))\n  \n  for y in range(h + 2):\n    for x in range(w + 2):\n      if mp[y][x] == \"A\":\n        ax, ay = x, y\n        mp[y][x] = \".\"\n      if mp[y][x] == \"B\":\n        bx, by = x, y\n        mp[y][x] = \".\"\n  INF = 1000\n  dist_mp = [[INF] * (w + 2) for _ in range(h + 2)]\n  dist_mp[ay][ax] = 0\n  que = deque()\n  que.append((0, ax, ay))\n  vec = ((1, 0), (0, -1), (-1, 0), (0, 1))\n  while que:\n    d, x, y = que.popleft()\n    for dx, dy in vec:\n      nx, ny = x + dx, y + dy\n      if mp[ny][nx] == \".\" and dist_mp[ny][nx] == INF:\n        que.append((d + 1, nx, ny))\n        dist_mp[ny][nx] = d + 1\n  \n  limit = d\n  pattern = input()\n  length = len(pattern)\n  t = 0\n  dic = {}\n  while True:\n    if t >= dist_mp[by][bx]:\n      print(t, by - 1, bx - 1)\n      break\n    if t > limit:\n      if (t % length, bx, by) in dic:\n        print(\"impossible\")\n        break\n      else:\n        dic[(t % length, bx, by)] = True\n    c = pattern[t % length]\n    if c == \"5\": pass\n    elif c == \"8\" and mp[by - 1][bx] != \"X\": by -= 1\n    elif c == \"6\" and mp[by][bx + 1] != \"X\": bx += 1\n    elif c == \"4\" and mp[by][bx - 1] != \"X\": bx -= 1\n    elif c == \"2\" and mp[by + 1][bx] != \"X\": by += 1\n    t += 1\n  else:\n    print(\"impossible\")\n"
  },
  {
    "language": "Python",
    "code": "bignum=1000000000000\ndir=[[1,0],[-1,0],[0,1],[0,-1],[0,0]]\n\ndef movable(loc,d,H,W):\n    if (loc[0]+d[0]>=0 and loc[0]+d[0]<H and loc[1]+d[1]>=0 and loc[1]+d[1]<W):\n        return 1\n    else:\n        return 0\ndef vecsum(loc,d):\n    return [loc[0]+d[0],loc[1]+d[1]]\n\ndef decodeghost(cn):\n    if cn==5:\n        return dir[4]\n    if cn==2:\n        return dir[0]\n    if cn==4:\n        return dir[3]\n    if cn==6:\n        return dir[2]\n    if cn==8:\n        return dir[1]\n\nwhile(1):\n    H,W=map(int,raw_input().split())\n    if H==0:    break\n    L=[]\n    F=[[bignum for i in range(W)] for j in range(H)]\n    Aloc=[0,0]\n    Bloc=[0,0]\n    for h in range(H):\n        L.append(raw_input())\n        if 'A' in L[-1]:\n            Aloc=[h,L[-1].index('A')]\n        if 'B' in L[-1]:\n            Bloc=[h,L[-1].index('B')]\n    F[Aloc[0]][Aloc[1]]=0\n    nf=[Aloc[:]]\n    ac=1\n    while(len(nf)>0):\n        nnf=[]\n        for loc in nf:\n            for d in dir:\n                if movable(loc,d,H,W):\n                    v=vecsum(loc,d)\n                    if F[v[0]][v[1]]>ac and L[v[0]][v[1]]!='#':\n                        F[v[0]][v[1]]=ac\n                        nnf.append(v)\n        nf=nnf[:]\n        ac+=1\n    \n    cmd=raw_input()\n    C=[[[0 for i in range(W)] for j in range(H)] for k in range(len(cmd))]\n    cm=0\n    ans=1\n    while(1):\n        if C[cm][Bloc[0]][Bloc[1]]==1 and ans>H*W:\n            print 'impossible'\n            break\n        C[cm][Bloc[0]][Bloc[1]]=1\n        cn=int(cmd[cm])\n        d=decodeghost(cn)\n        if movable(Bloc,d,H,W):\n            v=vecsum(Bloc,d)\n            Bloc=v[:]\n        if F[Bloc[0]][Bloc[1]]<=ans:\n            print ans,' '.join([str(b) for b in Bloc])\n            break\n        cm+=1\n        if cm>=len(cmd):\n            cm=0\n        ans+=1\n                "
  }
]