[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\ntypedef struct {\n    Point pos;\n    int time;\n} State;\n\nchar grid[20][20];\nint rows, cols;\nchar pattern[100];\nint pattern_len;\nPoint ghost_start;\nPoint girl_start;\nint visited[20][20][100];\nint directions[5][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}, {0, 0}};\n\nPoint move_ghost(Point pos, int time) {\n    char cmd = pattern[time % pattern_len];\n    Point new_pos = pos;\n    switch (cmd) {\n        case 'N': new_pos.x--; break;\n        case 'S': new_pos.x++; break;\n        case 'E': new_pos.y++; break;\n        case 'W': new_pos.y--; break;\n    }\n    if (new_pos.x < 0 || new_pos.x >= rows || new_pos.y < 0 || new_pos.y >= cols || grid[new_pos.x][new_pos.y] == '#') {\n        return pos;\n    }\n    return new_pos;\n}\n\nint is_valid(Point pos) {\n    return pos.x >= 0 && pos.x < rows && pos.y >= 0 && pos.y < cols && grid[pos.x][pos.y] == '.';\n}\n\nvoid bfs() {\n    State queue[20 * 20 * 100];\n    int front = 0, rear = 0;\n    memset(visited, 0, sizeof(visited));\n\n    queue[rear++] = (State){girl_start, 0};\n    visited[girl_start.x][girl_start.y][0] = 1;\n\n    while (front < rear) {\n        State current = queue[front++];\n        Point ghost_pos = ghost_start;\n        for (int t = 0; t < current.time; t++) {\n            ghost_pos = move_ghost(ghost_pos, t);\n        }\n\n        if (current.pos.x == ghost_pos.x && current.pos.y == ghost_pos.y) {\n            printf(\"%d %d %d\\n\", current.time, current.pos.x + 1, current.pos.y + 1);\n            return;\n        }\n\n        for (int i = 0; i < 5; i++) {\n            Point new_pos = {\n                current.pos.x + directions[i][0],\n                current.pos.y + directions[i][1]\n            };\n            int new_time = (current.time + 1) % pattern_len;\n\n            if (is_valid(new_pos) && !visited[new_pos.x][new_pos.y][new_time]) {\n                visited[new_pos.x][new_pos.y][new_time] = 1;\n                queue[rear++] = (State){new_pos, current.time + 1};\n            }\n        }\n    }\n    printf(\"impossible\\n\");\n}\n\nint main() {\n    int dataset = 1;\n    while (1) {\n        scanf(\"%d %d\", &rows, &cols);\n        if (rows == 0 && cols == 0) break;\n\n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 'G') {\n                    girl_start.x = i;\n                    girl_start.y = j;\n                    grid[i][j] = '.';\n                } else if (grid[i][j] == 'P') {\n                    ghost_start.x = i;\n                    ghost_start.y = j;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        scanf(\"%s\", pattern);\n        pattern_len = strlen(pattern);\n\n        printf(\"Dataset %d: \", dataset++);\n        bfs();\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 18:59:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class GhostEncounter {\n    static final int[] dx = {0, 0, 1, -1, 0};\n    static final int[] dy = {-1, 1, 0, 0, 0};\n    \n    public static void solve(int testCase, char[][] grid, String ghostPath) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        for (int time = 0; time <= rows * cols * ghostPath.length(); time++) {\n            for (int x = 0; x < rows; x++) {\n                for (int y = 0; y < cols; y++) {\n                    if (grid[x][y] == '#') continue;\n                    \n                    for (int dir = 0; dir < 5; dir++) {\n                        int nx = x + dx[dir];\n                        int ny = y + dy[dir];\n                        \n                        if (nx < 0 || nx >= rows || ny < 0 || ny >= cols || grid[nx][ny] == '#') \n                            continue;\n                        \n                        int ghostPos = (time % ghostPath.length());\n                        char ghostMove = ghostPath.charAt(ghostPos);\n                        \n                        int gx = findGhostX(ghostMove, time / ghostPath.length(), rows);\n                        int gy = findGhostY(ghostMove, time / ghostPath.length(), cols);\n                        \n                        if (nx == gx && ny == gy) {\n                            System.out.println(\"Case \" + testCase + \": \" + time);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n        \n        System.out.println(\"Case \" + testCase + \": impossible\");\n    }\n    \n    static int findGhostX(char move, int cycles, int rows) {\n        switch(move) {\n            case 'N': return Math.max(0, rows - 1 - cycles);\n            case 'S': return Math.min(rows - 1, cycles);\n            default: return cycles % rows;\n        }\n    }\n    \n    static int findGhostY(char move, int cycles, int cols) {\n        switch(move) {\n            case 'E': return Math.min(cols - 1, cycles);\n            case 'W': return Math.max(0, cols - 1 - cycles);\n            default: return cycles % cols;\n        }\n    }\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int testCases = scanner.nextInt();\n        \n        for (int t = 1; t <= testCases; t++) {\n            int rows = scanner.nextInt();\n            int cols = scanner.nextInt();\n            \n            char[][] grid = new char[rows][cols];\n            for (int i = 0; i < rows; i++) {\n                grid[i] = scanner.next().toCharArray();\n            }\n            \n            String ghostPath = scanner.next();\n            solve(t, grid, ghostPath);\n        }\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-05 18:59:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <tuple>\n#include <climits>\n#include <cstring>\nusing namespace std;\n\nconst int dx[] = {0, 1, 0, -1, 0};\nconst int dy[] = {1, 0, -1, 0, 0};\n\nstruct State {\n    int x, y, t;\n    State(int x, int y, int t) : x(x), y(y), t(t) {}\n};\n\nbool is_valid(int x, int y, int H, int W, const vector<string>& grid) {\n    return x >= 0 && x < H && y >= 0 && y < W && grid[x][y] == '.';\n}\n\nvoid solve() {\n    int H, W;\n    while (cin >> H >> W) {\n        vector<string> grid(H);\n        int gx = -1, gy = -1, sx = -1, sy = -1;\n        for (int i = 0; i < H; ++i) {\n            cin >> grid[i];\n            for (int j = 0; j < W; ++j) {\n                if (grid[i][j] == 'G') {\n                    gx = i; gy = j;\n                    grid[i][j] = '.';\n                } else if (grid[i][j] == 'S') {\n                    sx = i; sy = j;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        string pattern;\n        cin >> pattern;\n        int L = pattern.size();\n\n        vector<vector<vector<int>>> dist(H, vector<vector<int>>(W, vector<int>(L, INT_MAX)));\n        queue<State> q;\n        q.emplace(sx, sy, 0);\n        dist[sx][sy][0] = 0;\n\n        bool found = false;\n        int res_time = INT_MAX;\n        int res_x = -1, res_y = -1;\n\n        while (!q.empty()) {\n            State s = q.front();\n            q.pop();\n            int current_dist = dist[s.x][s.y][s.t];\n            if (s.x == gx && s.y == gy) {\n                found = true;\n                res_time = current_dist;\n                res_x = s.x;\n                res_y = s.y;\n                break;\n            }\n\n            int next_ghost_t = (s.t + 1) % L;\n            char cmd = pattern[s.t];\n            int ngx = gx, ngy = gy;\n            if (cmd == 'U') ngx--;\n            else if (cmd == 'D') ngx++;\n            else if (cmd == 'L') ngy--;\n            else if (cmd == 'R') ngy++;\n\n            if (is_valid(ngx, ngy, H, W, grid)) {\n                gx = ngx;\n                gy = ngy;\n            }\n\n            for (int d = 0; d < 5; ++d) {\n                int nx = s.x + dx[d];\n                int ny = s.y + dy[d];\n                if (is_valid(nx, ny, H, W, grid)) {\n                    if (nx == gx && ny == gy) {\n                        found = true;\n                        res_time = current_dist + 1;\n                        res_x = nx;\n                        res_y = ny;\n                        break;\n                    }\n                    if (dist[nx][ny][next_ghost_t] > current_dist + 1) {\n                        dist[nx][ny][next_ghost_t] = current_dist + 1;\n                        q.emplace(nx, ny, next_ghost_t);\n                    }\n                }\n            }\n            if (found) break;\n        }\n\n        if (found) {\n            cout << res_time << \" \" << res_x << \" \" << res_y << \"\\n\";\n        } else {\n            cout << \"impossible\\n\";\n        }\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    solve();\n    return 0;\n}",
    "timestamp": "2025-08-05 18:59:46"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <limits.h>\n\n#define MAX_GRID 50\n#define MAX_PATTERN 100\n\ntypedef struct {\n    int x, y;\n} Point;\n\nint rows, cols, patternLen;\nchar grid[MAX_GRID][MAX_GRID];\nchar ghostPattern[MAX_PATTERN];\n\nint dx[] = {0, 0, 1, -1, 0};  // stay, E, S, W, N\nint dy[] = {0, 1, 0, -1, 0};\n\nint isValid(int x, int y) {\n    return x >= 0 && x < rows && y >= 0 && y < cols && \n           (grid[x][y] == '.' || grid[x][y] == 'G');\n}\n\nint solve(Point girl, Point ghost) {\n    int visited[MAX_GRID][MAX_GRID][MAX_PATTERN][2] = {0};\n    \n    int queue[MAX_GRID * MAX_GRID * MAX_PATTERN][4];\n    int front = 0, rear = 0;\n    \n    queue[rear][0] = girl.x;\n    queue[rear][1] = girl.y;\n    queue[rear][2] = ghost.x;\n    queue[rear][3] = ghost.y;\n    rear++;\n    \n    visited[girl.x][girl.y][ghost.x % patternLen][ghost.y % patternLen] = 1;\n    \n    while (front < rear) {\n        int x1 = queue[front][0];\n        int y1 = queue[front][1];\n        int x2 = queue[front][2];\n        int y2 = queue[front][3];\n        int time = visited[x1][y1][x2 % patternLen][y2 % patternLen] - 1;\n        front++;\n        \n        if (x1 == x2 && y1 == y2) return time;\n        \n        // Girl moves\n        for (int d = 0; d < 5; d++) {\n            int nx1 = x1 + dx[d];\n            int ny1 = y1 + dy[d];\n            \n            // Ghost moves according to pattern\n            int ghostMove = ghostPattern[time % patternLen] - '0';\n            int nx2 = x2 + dx[ghostMove];\n            int ny2 = y2 + dy[ghostMove];\n            \n            if (isValid(nx1, ny1) && isValid(nx2, ny2) && \n                !visited[nx1][ny1][nx2 % patternLen][ny2 % patternLen]) {\n                queue[rear][0] = nx1;\n                queue[rear][1] = ny1;\n                queue[rear][2] = nx2;\n                queue[rear][3] = ny2;\n                visited[nx1][ny1][nx2 % patternLen][ny2 % patternLen] = time + 2;\n                rear++;\n            }\n        }\n    }\n    \n    return -1;\n}\n\nint main() {\n    int T;\n    scanf(\"%d\", &T);\n    \n    while (T--) {\n        scanf(\"%d %d\", &rows, &cols);\n        \n        Point girl = {-1, -1}, ghost = {-1, -1};\n        \n        for (int i = 0; i < rows; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 'P') {\n                    girl.x = i;\n                    girl.y = j;\n                    grid[i][j] = '.';\n                }\n                if (grid[i][j] == 'G') {\n                    ghost.x = i;\n                    ghost.y = j;\n                    grid[i][j] = '.';\n                }\n            }\n        }\n        \n        scanf(\"%s\", ghostPattern);\n        patternLen = strlen(ghostPattern);\n        \n        int result = solve(girl, ghost);\n        \n        if (result == -1) \n            printf(\"impossible\\n\");\n        else \n            printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:00:01"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <climits>\n\nusing namespace std;\n\nstruct State {\n    int x, y, time;\n    State(int _x, _y, _t) : x(_x), y(_y), time(_t) {}\n};\n\nint main() {\n    int T;\n    cin >> T;\n    \n    while (T--) {\n        int H, W, N;\n        cin >> H >> W >> N;\n        \n        vector<string> grid(H);\n        for (int i = 0; i < H; i++) {\n            cin >> grid[i];\n        }\n        \n        string ghostPath;\n        cin >> ghostPath;\n        \n        int startX = -1, startY = -1;\n        for (int i = 0; i < H; i++) {\n            for (int j = 0; j < W; j++) {\n                if (grid[i][j] == 'S') {\n                    startX = i;\n                    startY = j;\n                    break;\n                }\n            }\n            if (startX != -1) break;\n        }\n        \n        vector<pair<int, int>> dirs = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}, {0, 0}};\n        int minTime = INT_MAX;\n        \n        queue<State> q;\n        vector<vector<vector<bool>>> visited(H, vector<vector<bool>>(W, vector<bool>(ghostPath.length(), false)));\n        \n        q.push(State(startX, startY, 0));\n        visited[startX][startY][0] = true;\n        \n        while (!q.empty()) {\n            State curr = q.front();\n            q.pop();\n            \n            int ghostIdx = curr.time % ghostPath.length();\n            int ghostX = curr.x, ghostY = curr.y;\n            \n            switch (ghostPath[ghostIdx]) {\n                case 'N': ghostX--; break;\n                case 'S': ghostX++; break;\n                case 'E': ghostY++; break;\n                case 'W': ghostY--; break;\n            }\n            \n            if (ghostX < 0 || ghostX >= H || ghostY < 0 || ghostY >= W || \n                grid[ghostX][ghostY] == '#') continue;\n            \n            if (grid[curr.x][curr.y] == 'G') {\n                minTime = min(minTime, curr.time);\n                break;\n            }\n            \n            for (auto& dir : dirs) {\n                int newX = curr.x + dir.first;\n                int newY = curr.y + dir.second;\n                int newTime = curr.time + 1;\n                int newGhostIdx = newTime % ghostPath.length();\n                \n                if (newX >= 0 && newX < H && newY >= 0 && newY < W &&\n                    grid[newX][newY] != '#' && \n                    !visited[newX][newY][newGhostIdx]) {\n                    q.push(State(newX, newY, newTime));\n                    visited[newX][newY][newGhostIdx] = true;\n                }\n            }\n        }\n        \n        if (minTime == INT_MAX) {\n            cout << \"impossible\" << endl;\n        } else {\n            cout << minTime << endl;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 19:00:13"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n    static class State {\n        int gx, gy, px, py, time;\n\n        State(int gx, int gy, int px, int py, int time) {\n            this.gx = gx;\n            this.gy = gy;\n            this.px = px;\n            this.py = py;\n            this.time = time;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(gx, gy, px, py, time);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (this == obj) return true;\n            if (obj == null || getClass() != obj.getClass()) return false;\n            State other = (State) obj;\n            return gx == other.gx && gy == other.gy && px == other.px && py == other.py && time == other.time;\n        }\n    }\n\n    static final int[] dx = {0, 1, 0, -1, 0};\n    static final int[] dy = {1, 0, -1, 0, 0};\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNext()) {\n            int R = sc.nextInt();\n            int C = sc.nextInt();\n            sc.nextLine();\n            char[][] grid = new char[R][C];\n            int px = -1, py = -1, gx = -1, gy = -1;\n            for (int i = 0; i < R; i++) {\n                String line = sc.nextLine();\n                for (int j = 0; j < C; j++) {\n                    grid[i][j] = line.charAt(j);\n                    if (grid[i][j] == 'P') {\n                        px = i;\n                        py = j;\n                        grid[i][j] = '.';\n                    } else if (grid[i][j] == 'G') {\n                        gx = i;\n                        gy = j;\n                        grid[i][j] = '.';\n                    }\n                }\n            }\n            String pattern = sc.nextLine();\n            solve(R, C, grid, px, py, gx, gy, pattern);\n        }\n        sc.close();\n    }\n\n    static void solve(int R, int C, char[][] grid, int px, int py, int gx, int gy, String pattern) {\n        Queue<State> queue = new LinkedList<>();\n        Set<State> visited = new HashSet<>();\n        State initial = new State(gx, gy, px, py, 0);\n        queue.add(initial);\n        visited.add(initial);\n\n        while (!queue.isEmpty()) {\n            State current = queue.poll();\n            if (current.gx == current.px && current.gy == current.py) {\n                System.out.println(current.time + \" \" + current.px + \" \" + current.py);\n                return;\n            }\n\n            int nextTime = current.time + 1;\n            int patternIndex = current.time % pattern.length();\n            char move = pattern.charAt(patternIndex);\n\n            int ngx = current.gx, ngy = current.gy;\n            switch (move) {\n                case 'U': ngx--; break;\n                case 'D': ngx++; break;\n                case 'L': ngy--; break;\n                case 'R': ngy++; break;\n            }\n            if (ngx < 0 || ngx >= R || ngy < 0 || ngy >= C || grid[ngx][ngy] == '#') {\n                ngx = current.gx;\n                ngy = current.gy;\n            }\n\n            for (int i = 0; i < 5; i++) {\n                int npx = current.px + dx[i];\n                int npy = current.py + dy[i];\n                if (npx < 0 || npx >= R || npy < 0 || npy >= C || grid[npx][npy] != '.') {\n                    continue;\n                }\n                State next = new State(ngx, ngy, npx, npy, nextTime);\n                if (!visited.contains(next)) {\n                    visited.add(next);\n                    queue.add(next);\n                }\n            }\n        }\n        System.out.println(\"impossible\");\n    }\n}",
    "timestamp": "2025-08-05 19:01:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import deque\n\ndef parse_input_and_solve(n, m, grid, ghost_moves):\n    move_delta = {'N': (-1, 0), 'S': (1, 0), 'E': (0, 1), 'W': (0, -1), '.': (0, 0)}\n    directions = [(0, 0), (-1, 0), (1, 0), (0, 1), (0, -1)]  # stay, north, south, east, west\n    grid = [list(row) for row in grid]\n    \n    def is_position_valid(x, y):\n        return 0 <= x < n and 0 <= y < m and grid[x][y] == '.'\n\n    queue = deque([(0, 0, 0, 0)])  # (time, girl_x, girl_y, ghost_index)\n    visited = set((0, 0, 0))  # (girl_x, girl_y, ghost_index)\n\n    while queue:\n        time, girl_x, girl_y, ghost_index = queue.popleft()\n        ghost_x, ghost_y = move_delta[ghost_moves[ghost_index]]\n        new_ghost_x, new_ghost_y = girl_x + ghost_x, girl_y + ghost_y\n        \n        ghost_index = (ghost_index + 1) % len(ghost_moves)\n        \n        for dx, dy in directions:\n            new_girl_x, new_girl_y = girl_x + dx, girl_y + dy\n            if is_position_valid(new_girl_x, new_girl_y) and (new_girl_x, new_girl_y, ghost_index) not in visited:\n                queue.append((time + 1, new_girl_x, new_girl_y, ghost_index))\n                visited.add((new_girl_x, new_girl_y, ghost_index))\n                if new_girl_x == new_ghost_x and new_girl_y == new_ghost_y:\n                    return time + 1, new_girl_x, new_girl_y\n    \n    return \"impossible\"\n\ndatasets = [\n    (3, 3, [\"...\", \"...\", \"...\"], \"NESW\"),\n    (3, 3, [\"...\", \"...\", \"...\"], \"SSSE\"),\n]\n\nfor data in datasets:\n    n, m, grid, ghost_moves = data\n    result = parse_input_and_solve(n, m, grid, ghost_moves)\n    print(result)",
    "timestamp": "2025-08-13 01:44:21"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class GhostEncounter {\n    static class Position {\n        int x, y;\n        Position(int x, int y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static final int[] dx = {-1, 1, 0, 0, 0}; // North, South, East, West, Stay\n    static final int[] dy = {0, 0, 1, -1, 0};\n\n    static final Map<Character, Integer> ghostMotion = Map.of(\n            'N', 0,\n            'S', 1,\n            'E', 2,\n            'W', 3,\n            'X', 4\n    );\n\n    static boolean isValidGridPosition(Position pos, int numRows, int numCols) {\n        return pos.x >= 0 && pos.x < numRows && pos.y >= 0 && pos.y < numCols;\n    }\n\n    public static String earliestEncounter(char[][] grid, String ghostPattern) {\n        int numRows = grid.length;\n        int numCols = grid[0].length;\n        int patternLength = ghostPattern.length();\n        \n        Queue<int[]> queue = new LinkedList<>();\n        Set<String> visited = new HashSet<>();\n        \n        // Initial positions: all '.' positions where girl can start\n        for (int i = 0; i < numRows; i++) {\n            for (int j = 0; j < numCols; j++) {\n                if (grid[i][j] == '.') {\n                    queue.add(new int[]{i, j, -1}); // Start before ghost moves\n                    visited.add(i + \",\" + j + \",\" + -1);\n                }\n            }\n        }\n        \n        // BFS for earliest encounter\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int girlX = current[0];\n            int girlY = current[1];\n            int time = current[2];\n            \n            Position ghostPosition = simulateGhost(grid, ghostPattern, time);\n            \n            if (girlX == ghostPosition.x && girlY == ghostPosition.y) {\n                return \"Encounters Ghost at (\" + girlX + \",\" + girlY + \") at time \" + (time + 1);\n            }\n            \n            // Explore all possible moves for the girl\n            for (int i = 0; i < 5; i++) {\n                int newX = girlX + dx[i];\n                int newY = girlY + dy[i];\n                int nextTime = time + 1;\n                \n                Position newPos = new Position(newX, newY);\n                if (isValidGridPosition(newPos, numRows, numCols) && grid[newX][newY] == '.') {\n                    String state = newX + \",\" + newY + \",\" + nextTime;\n                    if (!visited.contains(state)) {\n                        queue.add(new int[]{newX, newY, nextTime});\n                        visited.add(state);\n                    }\n                }\n            }\n        }\n        \n        return \"impossible\";\n    }\n\n    static Position simulateGhost(char[][] grid, String ghostPattern, int time) {\n        int numRows = grid.length;\n        int numCols = grid[0].length;\n        int patternLength = ghostPattern.length();\n        \n        int ghostX = 0, ghostY = 0;\n        boolean foundGhostStart = false;\n        \n        // Find starting point of the ghost\n        for (int i = 0; i < numRows && !foundGhostStart; i++) {\n            for (int j = 0; j < numCols && !foundGhostStart; j++) {\n                if (grid[i][j] == '#') {\n                    ghostX = i;\n                    ghostY = j;\n                    foundGhostStart = true;\n                }\n            }\n        }\n        \n        if (!foundGhostStart) {\n            return new Position(-1, -1); // ghost does not exist\n        }\n        \n        for (int t = 0; t <= time; t++) {\n            int moveIdx = ghostMotion.get(ghostPattern.charAt(t % patternLength));\n            int newGhostX = ghostX + dx[moveIdx];\n            int newGhostY = ghostY + dy[moveIdx];\n            Position newGhostPos = new Position(newGhostX, newGhostY);\n            if (isValidGridPosition(newGhostPos, numRows, numCols) && grid[newGhostX][newGhostY] == '#') {\n                ghostX = newGhostX;\n                ghostY = newGhostY;\n            }\n        }\n        \n        return new Position(ghostX, ghostY);\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int datasets = scanner.nextInt();\n        scanner.nextLine();\n\n        for (int dataset = 0; dataset < datasets; dataset++) {\n            int numRows = scanner.nextInt();\n            int numCols = scanner.nextInt();\n            scanner.nextLine();\n\n            char[][] grid = new char[numRows][numCols];\n            for (int i = 0; i < numRows; i++) {\n                grid[i] = scanner.nextLine().toCharArray();\n            }\n\n            String ghostPattern = scanner.nextLine();\n            System.out.println(earliestEncounter(grid, ghostPattern));\n        }\n\n        scanner.close();\n    }\n}",
    "timestamp": "2025-08-13 01:44:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_N 100\n#define MAX_MOVES 1000\n\ntypedef struct {\n    int x, y;\n} Position;\n\ntypedef struct {\n    Position pos;\n    int move_index;\n} State;\n\nint dx[5] = {0, -1, 1, 0, 0};   // Stay, North, South, West, East\nint dy[5] = {0, 0, 0, -1, 1};\n\nint ghost_moves_dx[256];\nint ghost_moves_dy[256];\n\nint n, m, ghost_pattern_len;\nchar grid[MAX_N][MAX_N];\nchar ghost_pattern[MAX_MOVES];\n\nbool visited[MAX_N][MAX_N][MAX_MOVES];\n\nPosition girl_start, ghost_start;\n\nbool is_valid(Position pos) {\n    return pos.x >= 0 && pos.x < n && pos.y >= 0 && pos.y < m && grid[pos.x][pos.y] == '.';\n}\n\nState next_state(State st, int girl_move) {\n    State next;\n    next.pos.x = st.pos.x + dx[girl_move];\n    next.pos.y = st.pos.y + dy[girl_move];\n    next.move_index = (st.move_index + 1) % ghost_pattern_len;\n    return next;\n}\n\nState ghost_next_state(State st) {\n    State next;\n    int move_idx = (st.move_index + 1) % ghost_pattern_len;\n    next.pos.x = st.pos.x + ghost_moves_dx[(int)ghost_pattern[move_idx]];\n    next.pos.y = st.pos.y + ghost_moves_dy[(int)ghost_pattern[move_idx]];\n    next.move_index = move_idx;\n    return next;\n}\n\nbool can_encounter(Position girl_pos, Position ghost_pos) {\n    return girl_pos.x == ghost_pos.x && girl_pos.y == ghost_pos.y;\n}\n\nint bfs() {\n    memset(visited, 0, sizeof(visited));\n    State queue[MAX_N * MAX_N * MAX_MOVES];\n    int front = 0, back = 0;\n\n    State start = {girl_start, 0};\n    queue[back++] = start;\n    visited[start.pos.x][start.pos.y][start.move_index] = true;\n\n    for (int time = 0; front < back; time++) {\n        int size = back - front;\n        for (int i = 0; i < size; i++) {\n            State current = queue[front++];\n            \n            Position ghost_pos = ghost_next_state((State){ghost_start, current.move_index}).pos;\n            if (can_encounter(current.pos, ghost_pos)) {\n                return time;\n            }\n\n            for (int move = 0; move < 5; move++) {\n                State next = next_state(current, move);\n                if (is_valid(next.pos) && !visited[next.pos.x][next.pos.y][next.move_index]) {\n                    visited[next.pos.x][next.pos.y][next.move_index] = true;\n                    queue[back++] = next;\n                }\n            }\n        }\n    }\n    return -1;\n}\n\nint main() {\n    ghost_moves_dx['N'] = -1; ghost_moves_dy['N'] = 0;\n    ghost_moves_dx['S'] = 1; ghost_moves_dy['S'] = 0;\n    ghost_moves_dx['E'] = 0; ghost_moves_dy['E'] = 1;\n    ghost_moves_dx['W'] = 0; ghost_moves_dy['W'] = -1;\n    ghost_moves_dx['.'] = 0; ghost_moves_dy['.'] = 0;\n\n    while (scanf(\"%d %d\", &n, &m) != EOF) {\n        for (int i = 0; i < n; i++) {\n            scanf(\"%s\", grid[i]);\n            for (int j = 0; j < m; j++) {\n                if (grid[i][j] == 'G') {\n                    girl_start = (Position){i, j};\n                } else if (grid[i][j] == 'F') {\n                    ghost_start = (Position){i, j};\n                }\n            }\n        }\n        scanf(\"%s\", ghost_pattern);\n        ghost_pattern_len = strlen(ghost_pattern);\n\n        int result = bfs();\n        if (result == -1) {\n            printf(\"impossible\\n\");\n        } else {\n            printf(\"%d\\n\", result);\n        }\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:46:03"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from typing import List, Tuple\n\ndef can_meet_ghost(grid: List[str], ghost_pattern: str) -> str:\n    rows, cols = len(grid), len(grid[0])\n    girl_start = next((\n        (r, c) for r in range(rows) for c in range(cols) \n        if grid[r][c] == 'G'\n    ), None)\n    \n    ghost_start = next((\n        (r, c) for r in range(rows) for c in range(cols) \n        if grid[r][c] == 'E'\n    ), None)\n    \n    if not girl_start or not ghost_start:\n        return 'impossible'\n    \n    moves = {\n        'N': (-1, 0),\n        'S': (1, 0),\n        'E': (0, 1),\n        'W': (0, -1),\n        'O': (0, 0)\n    }\n    \n    visited = set()\n    queue = [(girl_start[0], girl_start[1], ghost_start[0], ghost_start[1], 0)]\n    \n    while queue:\n        girl_r, girl_c, ghost_r, ghost_c, time = queue.pop(0)\n        \n        if (girl_r, girl_c) == (ghost_r, ghost_c):\n            return str(time)\n        \n        state = (girl_r, girl_c, ghost_r, ghost_c, time % len(ghost_pattern))\n        if state in visited:\n            continue\n        visited.add(state)\n        \n        ghost_move = moves[ghost_pattern[time % len(ghost_pattern)]]\n        next_ghost_r = ghost_r + ghost_move[0]\n        next_ghost_c = ghost_c + ghost_move[1]\n        \n        if (0 <= next_ghost_r < rows and 0 <= next_ghost_c < cols and \n            grid[next_ghost_r][next_ghost_c] != '#'):\n            ghost_r, ghost_c = next_ghost_r, next_ghost_c\n        \n        for move_name, (dr, dc) in moves.items():\n            next_girl_r = girl_r + dr\n            next_girl_c = girl_c + dc\n            \n            if (0 <= next_girl_r < rows and 0 <= next_girl_c < cols and\n                grid[next_girl_r][next_girl_c] != '#' and \n                grid[next_girl_r][next_girl_c] != 'E'):\n                queue.append((next_girl_r, next_girl_c, ghost_r, ghost_c, time + 1))\n    \n    return 'impossible'\n\ndef main():\n    while True:\n        try:\n            rows, cols = map(int, input().split())\n            if rows == 0 and cols == 0:\n                break\n            \n            grid = [input().strip() for _ in range(rows)]\n            ghost_pattern = input().strip()\n            \n            result = can_meet_ghost(grid, ghost_pattern)\n            print(result)\n        \n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 01:46:19"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    input = sys.stdin.read().split()\n    ptr = 0\n    while ptr < len(input):\n        H = int(input[ptr])\n        W = int(input[ptr+1])\n        ptr +=2\n        grid = []\n        girl_pos = None\n        ghost_pos = None\n        for i in range(H):\n            row = input[ptr+i]\n            grid.append(row)\n            if 'A' in row:\n                girl_pos = (i, row.index('A'))\n            if 'B' in row:\n                ghost_pos = (i, row.index('B'))\n        ptr += H\n        ghost_pattern = input[ptr]\n        ptr +=1\n        \n        # Directions: 0=stay, 1=north, 2=south, 3=west, 4=east\n        dirs = [(0,0), (-1,0), (1,0), (0,-1), (0,1)]\n        \n        # Precompute ghost positions at each time step\n        max_steps = 1000  # To prevent infinite loop\n        ghost_path = []\n        current_ghost_pos = ghost_pos\n        ghost_path.append(current_ghost_pos)\n        pattern_len = len(ghost_pattern)\n        \n        for t in range(1, max_steps +1):\n            cmd = ghost_pattern[(t-1) % pattern_len]\n            dr, dc = 0, 0\n            if cmd == 'U':\n                dr, dc = -1, 0\n            elif cmd == 'D':\n                dr, dc = 1, 0\n            elif cmd == 'L':\n                dr, dc = 0, -1\n            elif cmd == 'R':\n                dr, dc = 0, 1\n            \n            nr, nc = current_ghost_pos[0] + dr, current_ghost_pos[1] + dc\n            if 0 <= nr < H and 0 <= nc < W and (grid[nr][nc] == '.' or grid[nr][nc] == 'B' or grid[nr][nc] == '#'):\n                current_ghost_pos = (nr, nc)\n            ghost_path.append(current_ghost_pos)\n        \n        # BFS setup\n        visited = [[[False for _ in range(W)] for __ in range(H)] for ___ in range(max_steps +2)]\n        q = deque()\n        q.append((girl_pos[0], girl_pos[1], 0))\n        visited[0][girl_pos[0]][girl_pos[1]] = True\n        found = False\n        \n        while q:\n            r, c, t = q.popleft()\n            ghost_r, ghost_c = ghost_path[t][0], ghost_path[t][1]\n            \n            if (r, c) == (ghost_r, ghost_c):\n                print(t, r+1, c+1)\n                found = True\n                break\n            \n            if t >= max_steps:\n                continue\n            \n            for dr, dc in dirs:\n                nr = r + dr\n                nc = c + dc\n                if 0 <= nr < H and 0 <= nc < W:\n                    if grid[nr][nc] == '.' or grid[nr][nc] == 'A' or grid[nr][nc] == 'B':\n                        next_ghost_r, next_ghost_c = ghost_path[t+1][0], ghost_path[t+1][1]\n                        if (nr, nc) == (next_ghost_r, next_ghost_c):\n                            print(t+1, nr+1, nc+1)\n                            found = True\n                            break\n                        if not visited[t+1][nr][nc]:\n                            visited[t+1][nr][nc] = True\n                            q.append((nr, nc, t+1))\n                if found:\n                    break\n            if found:\n                break\n        \n        if not found:\n            print(\"impossible\")\n\nsolve()",
    "timestamp": "2025-08-13 01:46:53"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <string>\n#include <unordered_map>\n#include <tuple>\n#include <algorithm>\n\nusing namespace std;\n\nstruct State {\n    int girl_x, girl_y, ghost_x, ghost_y, time;\n};\n\nbool canMove(int x, int y, const vector<string>& grid) {\n    return grid[x][y] == '.';\n}\n\npair<int, int> moveGhost(int x, int y, char direction) {\n    switch (direction) {\n        case 'N': return {x - 1, y};\n        case 'S': return {x + 1, y};\n        case 'E': return {x, y + 1};\n        case 'W': return {x, y - 1};\n        default: return {x, y};\n    }\n}\n\npair<int, int> moveGirl(int x, int y, char direction) {\n    switch (direction) {\n        case 'N': return {x - 1, y};\n        case 'S': return {x + 1, y};\n        case 'E': return {x, y + 1};\n        case 'W': return {x, y - 1};\n        default: return {x, y};\n    }\n}\n\nvoid solve(const vector<string>& grid, const string& ghostPattern) {\n    int n = grid.size();\n    int m = grid[0].size();\n\n    // Find starting positions of girl and ghost\n    int girl_x = -1, girl_y = -1, ghost_x = -1, ghost_y = -1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 'G') {\n                girl_x = i;\n                girl_y = j;\n            } else if (grid[i][j] == 'H') {\n                ghost_x = i;\n                ghost_y = j;\n            }\n        }\n    }\n\n    int period = ghostPattern.size();\n    unordered_map<int, unordered_map<int, unordered_map<int, unordered_map<int, bool>>>> visited;\n\n    queue<State> q;\n    q.push({girl_x, girl_y, ghost_x, ghost_y, 0});\n\n    while (!q.empty()) {\n        State cur = q.front();\n        q.pop();\n\n        if (cur.girl_x == cur.ghost_x && cur.girl_y == cur.ghost_y) {\n            cout << \"Time: \" << cur.time << \" Location: (\" << cur.girl_x << \", \" << cur.girl_y << \")\\n\";\n            return;\n        }\n\n        if (visited[cur.girl_x][cur.girl_y][cur.ghost_x][cur.ghost_y]) continue;\n        visited[cur.girl_x][cur.girl_y][cur.ghost_x][cur.ghost_y] = true;\n\n        vector<char> girlMoves = {'N', 'S', 'E', 'W', 'P'};\n        char ghostMove = ghostPattern[cur.time % period];\n\n        for (char gm : girlMoves) {\n            auto [ngx, ngy] = moveGirl(cur.girl_x, cur.girl_y, gm);\n\n            if (ngx >= 0 && ngx < n && ngy >= 0 && ngy < m && canMove(ngx, ngy, grid)) {\n                auto [nfx, nfy] = moveGhost(cur.ghost_x, cur.ghost_y, ghostMove);\n\n                if (nfx >= 0 && nfx < n && nfy >= 0 && nfy < m && grid[nfx][nfy] == '#') {\n                    q.push({ngx, ngy, nfx, nfy, cur.time + 1});\n                }\n            }\n        }\n    }\n\n    cout << \"impossible\\n\";\n}\n\nint main() {\n    int testCases;\n    cin >> testCases;\n\n    while (testCases--) {\n        int n, m;\n        cin >> n >> m;\n\n        vector<string> grid(n);\n        for (int i = 0; i < n; ++i) {\n            cin >> grid[i];\n        }\n\n        string ghostPattern;\n        cin >> ghostPattern;\n\n        solve(grid, ghostPattern);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:02:12"
  }
]