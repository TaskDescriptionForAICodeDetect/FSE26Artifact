[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAXN 100005\n\nint N, A, B;\ndouble v[MAXN];\n\nint compare(const void* a, const void* b) {\n    double x = *(double*)a;\n    double y = *(double*)b;\n    return (x < y) ? 1 : (x > y) ? -1 : 0;\n}\n\nint main() {\n    scanf(\"%d %d %d\", &N, &A, &B);\n    \n    for (int i = 0; i < N; i++) {\n        scanf(\"%lf\", &v[i]);\n    }\n    \n    qsort(v, N, sizeof(double), compare);\n    \n    double maxMean = 0;\n    int ways = 0;\n    \n    for (int k = A; k <= B; k++) {\n        double sum = 0;\n        for (int i = 0; i < k; i++) {\n            sum += v[i];\n        }\n        \n        double mean = sum / k;\n        \n        if (mean > maxMean) {\n            maxMean = mean;\n            ways = 1;\n        } else if (mean == maxMean) {\n            int equal = 1;\n            for (int i = 0; i < k; i++) {\n                if (v[i] != v[i]) {\n                    equal = 0;\n                    break;\n                }\n            }\n            if (equal) {\n                ways++;\n            }\n        }\n    }\n    \n    printf(\"%.10lf %d\\n\", maxMean, ways);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:23:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef long long ll;\n\ntypedef struct {\n    ll sum;\n    int count;\n} State;\n\nint compare(const void *a, const void *b) {\n    ll va = *(const ll *)a;\n    ll vb = *(const ll *)b;\n    if (va > vb) return -1;\n    if (va < vb) return 1;\n    return 0;\n}\n\nll comb[51][51];\n\nvoid precompute_comb() {\n    comb[0][0] = 1;\n    for (int n = 1; n <= 50; n++) {\n        comb[n][0] = 1;\n        for (int k = 1; k <= n; k++) {\n            comb[n][k] = comb[n-1][k-1] + comb[n-1][k];\n        }\n    }\n}\n\nint main() {\n    precompute_comb();\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n    ll v[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%lld\", &v[i]);\n    }\n    qsort(v, N, sizeof(ll), compare);\n\n    State dp[N+1][B+1];\n    memset(dp, 0, sizeof(dp));\n    dp[0][0].sum = 0;\n    dp[0][0].count = 1;\n\n    for (int i = 0; i < N; i++) {\n        for (int j = 0; j <= B; j++) {\n            if (dp[i][j].count == 0) continue;\n            // Not taking the i-th item\n            if (dp[i+1][j].sum < dp[i][j].sum) {\n                dp[i+1][j].sum = dp[i][j].sum;\n                dp[i+1][j].count = dp[i][j].count;\n            } else if (dp[i+1][j].sum == dp[i][j].sum) {\n                dp[i+1][j].count += dp[i][j].count;\n            }\n            // Taking the i-th item\n            if (j < B) {\n                ll new_sum = dp[i][j].sum + v[i];\n                if (dp[i+1][j+1].sum < new_sum) {\n                    dp[i+1][j+1].sum = new_sum;\n                    dp[i+1][j+1].count = dp[i][j].count;\n                } else if (dp[i+1][j+1].sum == new_sum) {\n                    dp[i+1][j+1].count += dp[i][j].count;\n                }\n            }\n        }\n    }\n\n    double max_avg = 0.0;\n    ll total_ways = 0;\n    for (int k = A; k <= B; k++) {\n        if (dp[N][k].count == 0) continue;\n        double avg = (double)dp[N][k].sum / k;\n        if (avg > max_avg) {\n            max_avg = avg;\n            total_ways = dp[N][k].count;\n        } else if (avg == max_avg) {\n            total_ways += dp[N][k].count;\n        }\n    }\n\n    printf(\"%.6f\\n\", max_avg);\n\n    ll v0 = v[0];\n    int cnt = 0;\n    for (int i = 0; i < N; i++) {\n        if (v[i] == v0) cnt++;\n    }\n\n    if (v[0] != v[A-1]) {\n        int m = 0;\n        for (int i = 0; i < A; i++) {\n            if (v[i] == v[A-1]) m++;\n        }\n        int total = 0;\n        for (int i = 0; i < N; i++) {\n            if (v[i] == v[A-1]) total++;\n        }\n        total_ways = comb[total][m];\n    } else {\n        total_ways = 0;\n        int total = cnt;\n        for (int k = A; k <= B; k++) {\n            if (k > total) break;\n            total_ways += comb[total][k];\n        }\n    }\n\n    printf(\"%lld\\n\", total_ways);\n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    vector<int> v(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> v[i];\n    }\n    sort(v.rbegin(), v.rend());\n\n    double max_mean = 0.0;\n    for (int k = A; k <= B; ++k) {\n        double sum = accumulate(v.begin(), v.begin() + k, 0.0);\n        double mean = sum / k;\n        if (mean > max_mean) {\n            max_mean = mean;\n        }\n    }\n\n    vector<vector<long long>> comb(N + 1, vector<long long>(N + 1, 0));\n    comb[0][0] = 1;\n    for (int i = 1; i <= N; ++i) {\n        comb[i][0] = 1;\n        for (int j = 1; j <= i; ++j) {\n            comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n        }\n    }\n\n    long long total_ways = 0;\n    for (int k = A; k <= B; ++k) {\n        double sum = accumulate(v.begin(), v.begin() + k, 0.0);\n        double mean = sum / k;\n        if (mean == max_mean) {\n            int cnt_total = 0, cnt_select = 0;\n            for (int i = 0; i < N; ++i) {\n                if (v[i] == v[k - 1]) {\n                    cnt_total++;\n                    if (i < k) {\n                        cnt_select++;\n                    }\n                }\n            }\n            total_ways += comb[cnt_total][cnt_select];\n        }\n    }\n\n    cout.precision(10);\n    cout << fixed << max_mean << endl;\n    cout << total_ways << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 23:24:48"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int N = scanner.nextInt();\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        int[] v = new int[N];\n        for (int i = 0; i < N; i++) {\n            v[i] = scanner.nextInt();\n        }\n        Arrays.sort(v);\n        reverseArray(v);\n\n        double maxMean = 0.0;\n        for (int k = A; k <= B; k++) {\n            double sum = 0;\n            for (int i = 0; i < k; i++) {\n                sum += v[i];\n            }\n            double mean = sum / k;\n            if (mean > maxMean) {\n                maxMean = mean;\n            }\n        }\n\n        long[][] comb = new long[N + 1][N + 1];\n        comb[0][0] = 1;\n        for (int i = 1; i <= N; i++) {\n            comb[i][0] = 1;\n            for (int j = 1; j <= i; j++) {\n                comb[i][j] = comb[i - 1][j - 1] + comb[i - 1][j];\n            }\n        }\n\n        long totalWays = 0;\n        for (int k = A; k <= B; k++) {\n            double sum = 0;\n            for (int i = 0; i < k; i++) {\n                sum += v[i];\n            }\n            double mean = sum / k;\n            if (Math.abs(mean - maxMean) < 1e-9) {\n                int lastVal = v[k - 1];\n                int cntLast = 0;\n                int cntTotal = 0;\n                for (int i = 0; i < N; i++) {\n                    if (v[i] == lastVal) {\n                        cntTotal++;\n                        if (i < k) {\n                            cntLast++;\n                        }\n                    }\n                }\n                totalWays += comb[cntTotal][cntLast];\n            }\n        }\n\n        System.out.printf(\"%.6f\\n\", maxMean);\n        System.out.println(totalWays);\n    }\n\n    private static void reverseArray(int[] arr) {\n        int i = 0, j = arr.length - 1;\n        while (i < j) {\n            int temp = arr[i];\n            arr[i] = arr[j];\n            arr[j] = temp;\n            i++;\n            j--;\n        }\n    }\n}",
    "timestamp": "2025-08-05 23:25:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class MaxMeanSelection {\n    public static void solve(int N, int A, int B, int[] values) {\n        Arrays.sort(values);\n        \n        double maxMean = 0;\n        int ways = 0;\n        \n        for (int count = A; count <= B; count++) {\n            double[] prefixSum = new double[N + 1];\n            for (int i = 1; i <= N; i++) {\n                prefixSum[i] = prefixSum[i-1] + values[N-i];\n            }\n            \n            double currentMean = prefixSum[count] / count;\n            \n            if (currentMean > maxMean) {\n                maxMean = currentMean;\n                ways = 1;\n            } else if (currentMean == maxMean) {\n                ways++;\n            }\n        }\n        \n        System.out.printf(\"%.6f %d\\n\", maxMean, ways);\n    }\n    \n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int N = sc.nextInt();\n        int A = sc.nextInt();\n        int B = sc.nextInt();\n        \n        int[] values = new int[N];\n        for (int i = 0; i < N; i++) {\n            values[i] = sc.nextInt();\n        }\n        \n        solve(N, A, B, values);\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 23:25:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n\nusing namespace std;\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    \n    vector<int> values(N);\n    for (int i = 0; i < N; i++) {\n        cin >> values[i];\n    }\n    \n    sort(values.begin(), values.end(), greater<int>());\n    \n    double maxMean = 0.0;\n    int ways = 0;\n    \n    for (int k = A; k <= B; k++) {\n        double currentSum = 0.0;\n        for (int i = 0; i < k; i++) {\n            currentSum += values[i];\n        }\n        \n        double currentMean = currentSum / k;\n        \n        if (currentMean > maxMean) {\n            maxMean = currentMean;\n            ways = 1;\n        } else if (currentMean == maxMean) {\n            ways++;\n        }\n    }\n    \n    for (int k = A; k <= B; k++) {\n        double currentSum = 0.0;\n        for (int i = 0; i < k; i++) {\n            currentSum += values[i];\n        }\n        \n        double currentMean = currentSum / k;\n        \n        if (currentMean == maxMean) {\n            cout << fixed << setprecision(10) << maxMean << \" \" << ways << endl;\n            return 0;\n        }\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 23:25:24"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from itertools import combinations\n\ndef max_mean_and_count(values, A, B):\n    N = len(values)\n    values.sort(reverse=True)\n    best_mean = 0\n    best_count = 0\n\n    for size in range(A, B + 1):\n        current_sum = sum(values[:size])\n        current_mean = current_sum / size\n\n        if current_mean > best_mean:\n            best_mean = current_mean\n            best_count = 1\n        elif current_mean == best_mean:\n            best_count += 1\n\n    return best_mean, best_count\n\n# Example usage:\nN = 5\nvalues = [10, 20, 30, 40, 50]\nA = 2\nB = 3\nbest_mean, best_count = max_mean_and_count(values, A, B)\nprint(best_mean, best_count)",
    "timestamp": "2025-08-13 15:09:31"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MaximumMeanSelection {\n    \n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int N = scanner.nextInt();\n        int A = scanner.nextInt();\n        int B = scanner.nextInt();\n        \n        int[] values = new int[N];\n        for (int i = 0; i < N; i++) {\n            values[i] = scanner.nextInt();\n        }\n        \n        Arrays.sort(values);\n        \n        double maxMean = 0;\n        int numberOfWays = 0;\n        \n        for (int k = A; k <= B; k++) {\n            long sum = 0;\n            for (int i = N - 1; i >= N - k; i--) {\n                sum += values[i];\n            }\n            \n            double mean = sum / (double) k;\n            \n            if (mean > maxMean) {\n                maxMean = mean;\n                numberOfWays = 1;\n                int count = 1;\n                for (int i = N - 2; i >= N - k && values[i + 1] == values[i]; i--) {\n                    count++;\n                }\n                for (int i = N - k - 1; i >= 0 && values[i] == values[N - k]; i--) {\n                    count++;\n                }\n                numberOfWays = count;\n            } else if (mean == maxMean) {\n                int count = 1;\n                for (int i = N - 2; i >= N - k && values[i + 1] == values[i]; i--) {\n                    count++;\n                }\n                for (int i = N - k - 1; i >= 0 && values[i] == values[N - k]; i--) {\n                    count++;\n                }\n                numberOfWays += count;\n            }\n        }\n        \n        System.out.println(maxMean);\n        System.out.println(numberOfWays);\n    }\n}",
    "timestamp": "2025-08-13 15:09:36"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\nint compareDesc(const void *a, const void *b) {\n    return *(int*)b - *(int*)a;\n}\n\nint main() {\n    int N, A, B;\n    scanf(\"%d %d %d\", &N, &A, &B);\n\n    int v[N];\n    for (int i = 0; i < N; i++) {\n        scanf(\"%d\", &v[i]);\n    }\n\n    qsort(v, N, sizeof(int), compareDesc);\n\n    // Compute prefix sums for easier calculation of averages\n    long long prefixSum[N + 1];\n    prefixSum[0] = 0;\n    for (int i = 1; i <= N; i++) {\n        prefixSum[i] = prefixSum[i - 1] + v[i - 1];\n    }\n\n    double maxMean = -1;\n    int maxCount = 0;\n\n    for (int k = A; k <= B; k++) {\n        double currentMean = (double)prefixSum[k] / k;\n        if (currentMean > maxMean) {\n            maxMean = currentMean;\n            maxCount = 1;\n        } else if (currentMean == maxMean) {\n            maxCount++;\n        }\n    }\n\n    printf(\"%.10lf\\n\", maxMean);\n    printf(\"%d\\n\", maxCount);\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:09:42"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nint main() {\n    int N, A, B;\n    cin >> N >> A >> B;\n    vector<int> values(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> values[i];\n    }\n\n    sort(values.rbegin(), values.rend());  // Sort values in descending order\n\n    double maxMean = 0;\n    int maxMeanCount = 0;\n\n    for (int k = A; k <= B; ++k) {\n        double currentMean = accumulate(values.begin(), values.begin() + k, 0.0) / k;\n        if (currentMean > maxMean) {\n            maxMean = currentMean;\n            maxMeanCount = 1;\n        } else if (currentMean == maxMean) {\n            maxMeanCount++;\n        }\n    }\n\n    cout << maxMean << endl;\n    cout << maxMeanCount << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-13 15:09:45"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def solve(N, A, B, values):\n    values.sort(reverse=True)\n    \n    def calculate_mean(k):\n        return sum(values[:k]) / k\n    \n    best_mean = float('-inf')\n    best_count = 0\n    \n    for count in range(A, B + 1):\n        current_mean = calculate_mean(count)\n        \n        if current_mean > best_mean:\n            best_mean = current_mean\n            best_count = 1\n        elif current_mean == best_mean:\n            best_count += 1\n    \n    return best_mean, best_count\n\n# Read input\nN, A, B = map(int, input().split())\nvalues = list(map(int, input().split()))\n\n# Solve and print results\nmax_mean, ways = solve(N, A, B, values)\nprint(f\"{max_mean:.7f}\")\nprint(ways)",
    "timestamp": "2025-08-13 15:09:50"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\nfrom collections import defaultdict\n\ndef solve():\n    N, A, B = map(int, sys.stdin.readline().split())\n    v = list(map(int, sys.stdin.readline().split()))\n    v.sort(reverse=True)\n    \n    # Calculate maximum average\n    max_avg = 0.0\n    best_k = 0\n    prefix = [0] * (N + 1)\n    for i in range(N):\n        prefix[i+1] = prefix[i] + v[i]\n    \n    for k in range(A, B+1):\n        current_sum = prefix[k]\n        current_avg = current_sum / k\n        if current_avg > max_avg:\n            max_avg = current_avg\n            best_k = k\n    \n    # Now find all k in [A, B] that achieve max_avg\n    # Recompute best_k in case multiple k's have the same average\n    best_ks = []\n    for k in range(A, B+1):\n        current_sum = prefix[k]\n        current_avg = current_sum / k\n        if abs(current_avg - max_avg) < 1e-9:\n            best_ks.append(k)\n    \n    # Now compute the number of ways\n    count = defaultdict(int)\n    for num in v:\n        count[num] += 1\n    \n    total_ways = 0\n    for k in best_ks:\n        # The selected items are the top k elements, but there might be duplicates\n        # So need to find how many ways to choose elements equal to v[k-1] in the selection\n        selected = v[:k]\n        min_selected = selected[-1]\n        total_in_list = v.count(min_selected)\n        needed_in_selected = selected.count(min_selected)\n        \n        # Compute combination C(total_in_list, needed_in_selected)\n        # Precompute factorial up to 50\n        comb = [[0]*(51) for _ in range(51)]\n        comb[0][0] = 1\n        for n in range(1, 51):\n            comb[n][0] = 1\n            for r in range(1, n+1):\n                comb[n][r] = comb[n-1][r-1] + comb[n-1][r]\n        \n        total_ways += comb[total_in_list][needed_in_selected]\n    \n    print(\"{0:.6f}\".format(max_avg))\n    print(total_ways)\n\nsolve()",
    "timestamp": "2025-08-13 15:10:04"
  }
]