[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tpa2 operator * (int a) {return pa2(x*a,y*a);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n             /*               \n            int pr[1000010];\n            int inv[1000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<=ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n           \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n            */ \n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n\nint dp[200][60][20]={0};\n \nsigned main(){\nstring s;\n\tcin>>s;\n\t\n\tint l=s.length();\n\t\n\tfor(char i='0';i<=s[0];i++){\n\t\tif(i!='5' && i<s[0])dp[0][0][0]++;\n\t\tif(i=='5' && i<s[0])dp[0][1][0]++;\n\t\tif(i!='5' && i==s[0])dp[0][0][1]++;\n\t\tif(i=='5' && i==s[0])dp[0][1][1]++;\n\t}\n\t\n\tfor(int i=0;i<l-1;i++){\n\t\n\t\tfor(int j=0;j<10;j++)if(j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][0][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][0][0];\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=1 && j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][1][0];\n\t\t}\n\t\tdp[i+1][2][0]+=dp[i][1][0];\n\t\tdp[i+1][1][0]+=dp[i][1][0];\n\t\t\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(j!=5)\tdp[i+1][3][0]+=dp[i][2][0];\n\t\t\telse dp[i+1][5][0]+=dp[i][2][0];\n\t\t}\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=3&&j!=5){\n\t\tdp[i+1][0][0]+=dp[i][3][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][3][0];\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=3&&j!=5){\n\t\t\tif(j!=1)dp[i+1][0][0]+=dp[i][5][0];\n\t\t\telse dp[i+1][2][0]+=dp[i][5][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][5][0];\n\t\t\n\t\tint h=s[i+1]-'0';\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][0][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][0][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=1 && j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][1][1];\n\t\t}\n\t\tif(h>1)dp[i+1][2][0]+=dp[i][1][1];\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][1][1];\n\t\t\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=5){\n\t\t\tdp[i+1][3][0]+=dp[i][2][1];\n\t\t}\n\t\tif(h>5) dp[i+1][5][0]+=dp[i][2][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=3 && j!=5){\n\t\tdp[i+1][0][0]+=dp[i][3][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][3][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=3 &&j!=5){\n\t\t\tif(j!=1)dp[i+1][0][0]+=dp[i][5][1];\n\t\t\telse dp[i+1][2][0]+=dp[i][5][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][5][1];\n\t\t\n\t\tif(h==5){\n\t\tdp[i+1][1][1]+=dp[i][0][1];\n\t\tdp[i+1][1][1]+=dp[i][1][1];\t\n\t\tdp[i+1][5][1]+=dp[i][2][1];\n\t\tdp[i+1][1][1]+=dp[i][3][1];\n\t\tdp[i+1][1][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t\telse if(h==1){\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][2][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t\tdp[i+1][0][1]+=dp[i][3][1];\n\t\tdp[i+1][2][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t\telse if(h==3){\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][0][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t//\tdp[i+1][0][1]+=dp[i][3][1];\n\t\t}\n\t\telse{\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][0][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t\tdp[i+1][0][1]+=dp[i][3][1];\n\t\tdp[i+1][0][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t}\n\tint n=stoi(s);\n\tint ans=0;\n\tfor(int i=0;i<6;i++)for(int j=0;j<2;j++)ans+=dp[l-1][i][j];\n\tcout<<n-ans+1<<endl;\n\t\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nstring str;\nstring num = \"51?3\";\nint sum[10];\n\nint mem[20][2][5][5][5];\nint used[20][2][5][5][5];\nint dfs(int pos,int less,int cnt,string s,int target){\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt == target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  int sum[5]={};\n  for(int i=1;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n  \n  int ans = 0;\n  for(int i=1;i<5;i++) ans += (i%2? 1:-1) * sum[i];\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nstring s;\nint64 dp[20][2][1000][2] = {};\n\nint64 dfs(int32 k = 0, bool tight = 1, int32 lst = 0, int32 ok = 0){\n\tif(k == s.size()) return ok;\n\tint32 lim = (tight ? s[k]+1 : 10);\n\tint64 &res = dp[k][tight][lst][ok];\n\tif(~res) return res;\n\tres = 0;\n\tREP(i, lim){\n\t\tint32 nxt = (lst*10+i)%1000;\n\t\tif(!ok && 510 <= lst && lst < 520 && i == 3)\n\t\t\tres += dfs(k+1, tight && i == (lim-1), nxt, 1);\n\t\telse\n\t\t\tres += dfs(k+1, tight && i == (lim-1), nxt, ok);\n\t}\n\treturn res;\n}\n\nint main(void){\n\tcin >> s;\n\tREP(i, s.size()) s[i] -= '0';\n\tmemset(dp, -1, sizeof dp);\n\tcout << dfs() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\nsigned main(){\n    string s;\n    cin>>s;\n    \n    int dp[19][2][2][1000]={};\n    dp[0][0][0][999] = 1;\n    rep(i,s.size()){\n        rep(j,2){\n            rep(k,2){\n                rep(l,1000){\n                    int D = s[i]-'0';\n                    for(int d=0;d<=(j?9:D);d++){\n                        dp[i+1][j or d!=D][k or (l/10==51 and d==3)][l%100*10+d] += dp[i][j][k][l];\n                    }\n                }\n                \n            }\n        }\n    }\n    \n    int ans = 0;\n    rep(i,1000){\n        ans += dp[s.size()][0][1][i];\n        ans += dp[s.size()][1][1][i];\n    }\n    cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nlong long dp[20][10][10][10][2][2];\n\nint main(){\n  string S;\n  cin >> S;\n  int N = S.length();\n  //dp[i][j][k][l][m][n]\n  ++dp[0][0][0][0][0][1];\n  for(int i = 0; i < N; ++i){\n    for(int j = 0; j < 10; ++j){\n      for(int k = 0; k < 10; ++k){\n        for(int l = 0; l < 10; ++l){\n          for(int m = 0; m < 2; ++m){\n            for(int n = 0; n < 2; ++n){\n              for(int o = 0; o < 10; ++o){\n                if(n and o > S[i]-'0') break;\n                int m_ = (m or (j == 5 and k == 1 and o == 3));\n                int n_ = (n and (S[i]-'0' == o));\n                dp[i+1][k][l][o][m_][n_] += dp[i][j][k][l][m][n];\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n  long long ans = 0;\n  for(int i = 0; i < 10; ++i)\n    for(int j = 0; j < 10; ++j)\n      for(int k = 0; k < 10; ++k)\n        for(int l = 0; l < 2; ++l)\n          ans += dp[N][i][j][k][1][l];\n  cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n#define dbg(x) cout<<#x\" = \"<<((x))<<endl\ntemplate<class T,class U> ostream& operator<<(ostream& o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream& o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\nconst int N = 20;\nint a[N];\n\nll dp[N][2][5][2];\n// no, 5, 51, 51(5以外), 515,\nll dfs(int d, int small, int state, int g){\n    if(d==N){\n        return g;\n    }\n    if(dp[d][small][state][g]>=0) return dp[d][small][state][g];\n\n    int lim = 9;\n    if(small==0) lim = a[d];\n\n    ll ret = 0;\n    for(int i=0; i<=lim; ++i){\n        int ns = small|(i<a[d]);\n        int nx = 0;\n        int ng = g;\n        if(i==1){\n            if(state==1 || state==4) nx = 2;\n            if(state==2) nx = 3;\n        }\n        else if(i==3){\n            if(state==2) nx = 3;\n            if(state==3 || state==4) ng = 1;\n        }\n        else if(i==5){\n            if(state==2) nx = 4;\n            else nx = 1;\n        }\n        else{\n            if(state==2) nx = 3;\n        }\n\n        ret += dfs(d+1, ns, nx, ng);\n    }\n\n    return dp[d][small][state][g] = ret;\n}\n\nint main(){\n    ll n;\n    cin >>n;\n\n    for(int i=N-1; i>=0; --i){\n        a[i] = n%10;\n        n/=10;\n    }\n\n    memset(dp,-1,sizeof(dp));\n    cout << dfs(0,0,0,0) << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][2][10][10][10];\n\nstring num;\n\nint Stoll(string s){\n  \n  int res = 0;\n  \n  for(int i=0;i<s.size();i++) res = res * 10 + s[i] - '0';\n\n  return res;\n}\n\nint dfs(int x, int y, int p3, int p2, int p1 ){\n  \n  if( num.size() <= x ) return 0;\n  \n  if( dp[x][y][p3][p2][p1] != -1 ) return dp[x][y][p3][p2][p1];\n  \n  int res = 0;\n  \n  if( y == 0 ){\n    \n    int p = num[x] - '0';\n    \n    if( p3 == 5 && p2 == 1 && p == 3 ){\n      if( x != (int)num.size() - 1 ) res += Stoll(num.substr(x+1));\n      res++;\n    }\n    else res += dfs( x+1, 0, p2, p1, p );\n    \n    for(int i=0;i<num[x]-'0';i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\t\n\tint X = 1;\n\t\n       \tfor(int j=0;j<(int)num.size()-x-1;j++) X *= 10;\n\t\n\tres += X;\n\t\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n  \n  if( y == 1 ){\n    \n    for(int i=0;i<10;i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\t\n\tint X = 1;\n\t\n\tfor(int j=0;j<(int)num.size()-x-1;j++) X *= 10;\n\t\n\tres += X;\n\t\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n\n  return dp[x][y][p3][p2][p1] = res;\n}\n\nsigned main(){\n  \n  cin>>num;\n  \n  memset( dp, -1, sizeof(dp) );\n  \n  cout<<dfs(0,0,0,0,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1e18 : 1e9;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nstring n;\nlong long dp[20][2][1000][2];\n\nlong long rec(int k = 0, bool tight = true, int uesan = 0, bool flag = false) {\n\tif (k == n.size()) {\n\t\treturn flag;\n\t}\n\n\tif (dp[k][tight][uesan][flag] != -1) {\n\t\treturn dp[k][tight][uesan][flag];\n\t}\n\n\tint x = n[k] - '0';\n\tint r = (tight ? x : 9);\n\tlong long res = 0;\n\trep (i, r + 1) {\n\t\tres += rec(k + 1, tight && i == r, uesan / 10 % 10 * 100 + uesan % 10 * 10 + i,\n\t\t\t\t\t\t\t flag || uesan / 100 == 5 && uesan /10 % 10 == 1 && i == 3);\n\t}\n\treturn dp[k][tight][uesan][flag] = res;\n}\n\nsigned main() {\n\tcin >> n;\n\tmemset(dp, -1, sizeof(dp));\n\tcout << rec() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][2][10][10][10];\n\nstring num;\n\nint Stoll(string s){\n  \n  int res = 0;\n  \n  for(int i=0;i<s.size();i++) res = res * 10 + s[i] - '0';\n\n  return res;\n}\n\nint dfs(int x, int y, int p3, int p2, int p1 ){\n  \n  if( num.size() <= x ) return 0;\n  \n  if( dp[x][y][p3][p2][p1] != -1 ) return dp[x][y][p3][p2][p1];\n  \n  int res = 0;\n  \n  if( y == 0 ){\n    \n    int p = num[x] - '0';\n    \n    if( p3 == 5 && p2 == 1 && p == 3 ){\n      if( x != num.size() - 1 ) res += Stoll(num.substr(x+1));\n      res++;\n    }\n    else res += dfs( x+1, 0, p2, p1, p );\n    \n    for(int i=0;i<num[x]-'0';i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\tif( x != num.size() - 1 ) res += Stoll(num.substr(x+1));\n\tres++;\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n  \n  if( y == 1 ){\n    \n    for(int i=0;i<10;i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\t\n\tint X = 1;\n\t\n\tfor(int j=0;j<num.size()-x-1;j++) X *= 10;\n\t\n\tres += X;\n\t\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n\n  return dp[x][y][p3][p2][p1] = res;\n}\n\nsigned main(){\n  \n  cin>>num;\n  \n  memset( dp, -1, sizeof(dp) );\n  \n  cout<<dfs(0,0,0,0,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll Stoi(string s){\n  ll res=0;\n  for(ll i=0;i<(int)s.size();i++)res=res*10+s[i]-'0';\n  return res;\n}\n\nll Pow(ll a,ll b){\n  ll res=1;\n  while(b--)res*=a;\n  return res;\n}\n\nstring n;\nll dp[20][2][10][10][10];\nll dfs(ll id,ll f,ll a,ll b,ll c){\n  if(dp[id][f][a][b][c]!=-1)return dp[id][f][a][b][c];\n  if(id==(int)n.size())return 0;\n  ll r=9,res=0;\n  if(!f)r=n[id]-'0';\n  for(ll d=0;d<=r;d++){\n    ll nf=f;\n    if(d<r)nf=1;\n    if(a==5&&b==1&&d==3)\n      if(nf) res+=Pow(10,n.size()-id-1);\n      else res+=Stoi(n.substr(id+1))+1;\n    else res+=dfs(id+1,nf,b,c,d);\n  }\n  return dp[id][f][a][b][c]=res;\n}\n\nint main(){\n  cin>>n;\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][2][10][10][10];\n\nstring num;\n\nint dfs(int x, int y, int p3, int p2, int p1 ){\n  \n  if( num.size() <= x ) return 0;\n  \n  if( dp[x][y][p3][p2][p1] != -1 ) return dp[x][y][p3][p2][p1];\n  \n  int res = 0;\n  \n  if( y == 0 ){\n    \n    int p = num[x] - '0';\n    \n    if( p3 == 5 && p2 == 1 && p == 3 ){\n      if( x != num.size() - 1 ) res += stoi(num.substr(x+1));\n      res++;\n    }\n    else res += dfs( x+1, 0, p2, p1, p );\n    \n    for(int i=0;i<num[x]-'0';i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\tif( x != num.size() - 1 ) res += stoi(num.substr(x+1));\n\tres++;\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n  \n  if( y == 1 ){\n    \n    for(int i=0;i<10;i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\t\n\tif( x != num.size() - 1 ){\n\t  \n\t  int X = 1;\n\t  \n\t  for(int j=0;j<num.size()-x-1;j++) X *= 10;\n\t  \n\t  res += X;\n\t}\n\telse res++;\n\t\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n\n  return dp[x][y][p3][p2][p1] = res;\n}\n\nsigned main(){\n  \n  cin>>num;\n  \n  memset( dp, -1, sizeof(dp) );\n  \n  cout<<dfs(0,0,0,0,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long dp[20][32][2] = {};\n\nint main() {\n    string s;\n    cin >> s;\n    int g[4] = { 5, 1, -1, 3 };\n    int n = s.size();\n    dp[0][0][1] = 1;\n    for (int i = 0; i < n + 1; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            for (int k = 0; k < 16; ++k) {\n                int nex = k & 8;\n                if (j == g[0]) {\n                    nex |= 1;\n                }\n                for (int l = 0; l < 3; ++l) {\n                    if ((k >> l) & 1) {\n                        if (j == g[l] || l == 2) {\n                            nex |= 1 << (l + 1);\n                        }\n                    }\n                }\n                dp[i + 1][nex][0] += dp[i][k][0];\n            }\n        }\n        for (int j = 0; j < s[i] - '0'; ++j) {\n            for (int k = 0; k < 16; ++k) {\n                int nex = k & 8;\n                if (j == g[0]) {\n                    nex |= 1;\n                }\n                for (int l = 0; l < 3; ++l) {\n                    if ((k >> l) & 1) {\n                        if (j == g[l] || l == 2) {\n                            nex |= 1 << (l + 1);\n                        }\n                    }\n                }\n                dp[i + 1][nex][0] += dp[i][k][1];\n            }\n        }\n        for (int j = s[i] - '0'; j <= s[i] - '0'; ++j) {\n            for (int k = 0; k < 16; ++k) {\n                int nex = k & 8;\n                if (j == g[0]) {\n                    nex |= 1;\n                }\n                for (int l = 0; l < 3; ++l) {\n                    if ((k >> l) & 1) {\n                        if (j == g[l] || l == 2) {\n                            nex |= 1 << (l + 1);\n                        }\n                    }\n                }\n                dp[i + 1][nex][1] += dp[i][k][1];\n            }\n        }\n    }\n    long long ans = 0;\n    for (int i = 8; i < 16; ++i) {\n        ans += dp[n][i][0] + dp[n][i][1];\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Int{\npublic:\n  string val;\n  Int():val(\"0\"){}\n  Int(string num,bool reversed=0){if(!reversed)R(num); val = num;}\n  Int(int num){val = to_string(num); R(val);}\n  \n  void R(string &a){reverse(a.begin(),a.end());}\n  bool neg(const string &a)const{return a.back() == '-';}\n  char& operator [] (int i){assert(i<(int)val.size());return val[i];}\n\n  bool operator ==  (Int b) {R(b.val); return *this == b.val;}\n  bool operator ==  (string b) {R(b);return val == b;}\n  template<class T> bool operator == (T b){return *this == Int(b);}\n  \n  bool operator !=  (Int b) {R(b.val); return *this != b.val;}\n  bool operator !=  (string b) {R(b);return !(val == b);}\n  template<class T> bool operator != (T b){return *this != Int(b);}\n  \n  bool operator >=  (Int b) {R(b.val); return *this >= b.val;}\n  bool operator >=  (string b) {return !(*this < b);}\n  template<class T> bool operator >= (T b){return *this >= Int(b);}\n\n  bool operator >   (Int b) {R(b.val); return *this > b.val;}\n  bool operator >   (string b) {return *this>=b && *this != b;}\n  template<class T> bool operator > (T b){return *this > Int(b);}\n\n  bool operator <=  (Int b) {R(b.val); return *this <= b.val;}\n  bool operator <=  (string b) {return *this<b || *this == b;}\n  template<class T> bool operator <= (T b){return *this <= Int(b);}\n\n  bool operator <   (Int b) {R(b.val); return *this < b.val;}\n  template<class T> bool operator < (T b){return *this < Int(b);}\n \n   bool operator <   (string b) {\n    R(b);\n    const string &a = val;\n    if(neg(a) != neg(b)) return neg(a)? 1:0;\n    if(a.size() != b.size()) return !neg(a)? (a.size()<b.size()):(a.size()>b.size());\n    for(int i=a.size()-1;i>=0;i--)if(a[i] != b[i]) return !neg(a)? a[i] < b[i]: a[i] > b[i];\n    return 0;\n  }\n  \n  Int operator + (string b){\n    R(b);\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(Int(a,1) < Int(b,1)) swap(a,b),swap(fa,fb);\n    \n    if(fa == fb){\n      a += '0';\n      for(int i=0;i<(int)a.size()-1;i++){\n        if(i < (int)b.size()) a[i] += b[i]-'0';\n        a[i+1] += (a[i]-'0')/10;\n        a[i] = (a[i]-'0')%10 + '0';\n      }\n      if(a.size() > 1 && a.back() == '0') a.pop_back();\n      if((int)a.size() > 1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    else {\n      for(int i=0;i<(int)a.size();i++){\n        if(i < (int)b.size()) a[i] -= b[i]-'0';\n        if(a[i]-'0' < 0) a[i]+=10, a[i+1]--; \n      }\n      while((int)a.size()>1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    return Int(a,1);\n  }\n\n  Int operator * (string b){\n    R(b);\n    vector<int> res;\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(a.size() < b.size()) swap(a,b), swap(fa,fb);\n    if(a == \"0\" || b == \"0\") return Int(\"0\");\n    \n    for(int j=0;j<(int)b.size();j++)\n      for(int i=0;i<(int)a.size();i++){\n        if(i+j >= (int)res.size()) res.push_back(0);\n        res[i+j] += (a[i]-'0') * (b[j]-'0');\n      }\n    for(int i=0; i <(int)res.size(); i++) {\n      if(res[i]/10 == 0) continue;\n      if(i + 1 >= (int)res.size()) res.push_back(0);\n      res[i+1] += res[i]/10, res[i]=res[i]%10;\n    }\n    string sres;\n    for(int i:res) sres += char(i + '0');\n    if(fa != fb) sres += '-';\n    return Int(sres,1);\n  }\n\n  Int div(string b,int flg){\n    assert(b != \"0\");\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = b[0]=='-'? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(b[0]=='-') b.erase(b.begin());\n    Int mod(\"0\");\n    string d=\"0\";\n    for(int i=(int)a.size()-1;i>=0;i--){\n      mod = mod * 10 + (a[i] - '0');\n      while(mod >= b) mod -= b, d.back()+=1;\n      if(i && d != \"0\") d += '0'; \n    }\n    if(flg == 0 && d != \"0\" && (fa != fb)) d = \"-\" + d;\n    if(flg == 1 && mod != \"0\" && (fa == \"-\")) mod *= -1;\n    return flg==0? d:mod;\n  }\n  \n  Int operator + (Int b){R(b.val); return *this + b.val;}\n  template<class T> Int operator + (T b){return *this + Int(b);}\n  \n  Int operator * (Int b){R(b.val); return *this * b.val;}\n  template<class T> Int operator * (T b){return *this * Int(b);}\n\n  Int operator - (string b){b = (b[0] == '-')? b.substr(1):\"-\" + b;return *this + b;}\n  Int operator - (Int b){R(b.val); return *this - b.val;} \n  template<class T> Int operator - (T b){return *this - Int(b);}\n  \n  Int operator / (string b){return div(b,0);}\n  Int operator / (Int b){R(b.val);return div(b.val,0);}\n  template<class T> Int operator / (T b){return *this / Int(b);}\n  \n  Int operator % (string b){return div(b,1);}\n  Int operator % (Int b){R(b.val);return div(b.val,1);}\n  template<class T> Int operator % (T b){return *this % Int(b);}\n  \n  Int operator += (Int b){return *this = *this+b;}\n  Int operator += (string b){return *this = *this+b;}\n  template<class T> Int operator += (T b){return *this += Int(b);}\n  \n  Int operator -= (Int b){return *this = *this-b;}\n  Int operator -= (string b){return *this = *this-b;}\n  template<class T> Int operator -= (T b){return *this -= Int(b);}\n  \n  Int operator *= (Int b){return *this = *this*b;}\n  Int operator *= (string b){return *this = *this*b;}\n  template<class T> Int operator *= (T b){return *this *= Int(b);}\n  \n  Int operator /= (string b){return *this = *this/b;}\n  Int operator /= (Int b){return *this = *this/b;}\n  template<class T> Int operator /= (T b){return *this /= Int(b);}\n  \n  Int operator %= (string b){return *this = *this % b;}\n  Int operator %= (Int b){return *this=*this%b;}\n  template<class T> Int operator %= (T b){return *this %= Int(b);}\n  \n  Int operator ++(){return *this += 1;}\n  Int operator --(){return *this -= 1;}\n\n#ifdef int\n#undef int\n#define eraseIntDefine\n#endif\n  Int operator ++(int){\n    Int tmp = *this;\n    *this += 1;\n    return tmp;\n  }\n  \n  Int operator --(int){\n    Int tmp = *this;\n    *this -= 1;\n    return tmp;\n  }\n#ifdef eraseIntDefine\n#define int long long\n#endif\n\n  friend ostream& operator << (ostream& os,const Int a){\n    for(int i=(int)a.val.size()-1;i>=0;i--) os<<a.val[i];\n    return os;\n  }\n\n  friend istream& operator >> (istream& is,Int &a){\n    string num;\n    is>>num;\n    a = Int(num);\n    return is;\n  }\n  friend string to_string(Int a){reverse(a.val.begin(),a.val.end());return a.val;}\n};\n\n\nstring str;\nstring num = \"51?3\";\n\nInt mem[20][2][5][5][5];\nint used[20][2][5][5][5];\nInt dfs(int pos,int less,int cnt,string s,int target){\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt == target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  Int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  Int sum[5]={};\n  for(int i=1;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n  \n  Int ans = 0;\n  for(int i=1;i<5;i++) ans += (i%2? 1:-1) * sum[i];\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing i64 = int64_t;\n\nconst i64 MOD = 1e9 + 7;\nconst i64 INF = 1e18 + 7;\n\nsigned main(){\n    string s;\n    cin >> s;\n    vector<vector<vector<vector<vector<vector<i64>>>>>> dp;\n    dp.resize(s.size()+1);\n    for(i64 i = 0;i < s.size() + 1;i++){\n        dp.at(i).resize(10);\n        for(i64 j = 0;j < 10;j++){\n            dp.at(i).at(j).resize(10);\n            for(i64 k = 0;k < 10;k++){\n                dp.at(i).at(j).at(k).resize(10);\n                for(i64 l = 0;l < 10;l++){\n                    dp.at(i).at(j).at(k).at(l).resize(2);\n                    for(i64 m = 0;m < 2;m++){\n                        dp.at(i).at(j).at(k).at(l).at(m).resize(2, 0);\n                    }\n                }\n            }\n        }\n    }\n\n    dp[0][0][0][0][0][1] = 1;\n\n    for(i64 i = 0; i < s.size(); ++i){\n        for(i64 j = 0; j < 10; ++j){\n            for(i64 k = 0; k < 10; ++k){\n                for(i64 l = 0; l < 10; ++l){\n                    for(i64 mit = 0; mit < 2; ++mit){\n                        if(!dp[i][j][k][l][mit][0] && !dp[i][j][k][l][mit][1])\n                            continue;\n                        for(i64 nex = 0; nex < 10; ++nex){\n                            bool fl = mit | (j == 5 && k == 1 && nex == 3);\n                            if(s[i] - '0' > nex){\n                                dp[i + 1][k][l][nex][fl][0] += dp[i][j][k][l][mit][1];\n                            }else if(s[i] - '0' == nex){\n                                dp[i + 1][k][l][nex][fl][1] += dp[i][j][k][l][mit][1];\n                            }else{\n                            }\n                            dp[i + 1][k][l][nex][fl][0] += dp[i][j][k][l][mit][0];\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    i64 ans = 0;\n    for(i64 j = 0; j < 10; ++j)\n        for(i64 k = 0; k < 10; ++k)\n            for(i64 l = 0; l < 10; ++l)\n                for(i64 fl = 0; fl < 2; ++fl){\n                    ans += dp[s.size()][j][k][l][1][fl];\n                    // ans += dp[s.size()][j][k][l][0][fl];\n                }\n\n    cout << ans << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst int A=18;\nlint p10[A];\n\n\nlint dp[A+1][2][6];\nint dig[A];\n\nint nxt[6][10];\n\nint main(){\n  rep(i,A){\n    if(i==0)p10[i]=1;\n    else p10[i]=10*p10[i-1];\n  }\n  lint n;\n  cin>>n;\n  rep(i,A){\n    dig[i]=n%10;\n    n/=10;\n  }\n  dp[A][1][0]=1;\n  //states\n  nxt[0][5]=1;\n  nxt[1][1]=2;\n  nxt[1][5]=1;\n  rep(i,10)nxt[2][i]=3;\n  nxt[2][5]=4;\n  nxt[3][3]=5;\n  nxt[3][5]=1;\n  nxt[4][1]=2;\n  nxt[4][3]=5;\n  nxt[4][5]=1;\n  rep(i,10)nxt[5][i]=5;\n  for (int i=A-1;i>=0;--i){\n    rep(j,10){\n      rep(k,6){\n\tdp[i][0][nxt[k][j]]+=dp[i+1][0][k];\n      }\n    }\n    rep(j,dig[i]){\n      rep(k,6){\n\tdp[i][0][nxt[k][j]]+=dp[i+1][1][k];\n      }\n    }\n    rep(k,6)\n      dp[i][1][nxt[k][dig[i]]]+=dp[i+1][1][k];\n    if(0){\n      rep(j,2){\n\trep(k,6)cerr<<\" \"<<dp[i][j][k];\n\tcerr<<\"|\";\n      }\n      cerr<<endl;\n    }\n  }\n  cout<< dp[0][0][5]+dp[0][1][5]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint len[5] = {5, 7, 5, 7, 7};\nstring N;\nlong long dp[21][10010][3][3]; // digit, last4, clear, smaller\n\nbool judge(int n) {\n  if ( (n/100) != 51) return false;\n  if (n % 10 != 3) return false;\n  return true;\n}\n\nint main() {\n  while (cin >> N) {\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0][0] = 1;\n    for (int i = 0; i <= N.size(); ++i) {\n      for (int j = 0; j <= 9999; ++j) {\n        for (int k = 0; k < 10; ++k) {\n          int nj = (j % 1000) * 10 + k;\n\n          // smaller -> smaller\n          {\n            // clear -> clear\n            dp[i+1][nj][1][1] += dp[i][j][1][1];\n\n            // nonclear -> \n            if (judge(nj)) dp[i+1][nj][1][1] += dp[i][j][0][1];\n            else dp[i+1][nj][0][1] += dp[i][j][0][1];\n          }\n\n          // same -> smaller\n          if (k < (int)(N[i] - '0')) {\n            // clear -> clear\n            dp[i+1][nj][1][1] += dp[i][j][1][0];\n\n            // nonclear ->\n            if (judge(nj)) dp[i+1][nj][1][1] += dp[i][j][0][0];\n            else dp[i+1][nj][0][1] += dp[i][j][0][0];\n          }\n\n          // same -> same\n          if (k == (int)(N[i] - '0')) {\n            // clear -> clear\n            dp[i+1][nj][1][0] += dp[i][j][1][0];\n\n            // nonclear ->\n            if (judge(nj)) dp[i+1][nj][1][0] += dp[i][j][0][0];\n            else dp[i+1][nj][0][0] += dp[i][j][0][0];\n          }\n          \n        }\n      }\n    }\n\n    long long res = 0;\n    for (int j = 0; j <= 9999; ++j) {\n      for (int smaller = 0; smaller < 2; ++smaller) {\n        res += dp[N.size()][j][1][smaller];\n      }\n    }\n\n    cout << res << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Int{\npublic:\n  string val;\n  Int():val(\"0\"){}\n  Int(string num,bool reversed=0){if(!reversed)R(num); val = num;}\n  Int(int num){val = to_string(num); R(val);}\n  \n  void R(string &a){reverse(a.begin(),a.end());}\n  bool neg(const string &a)const{return a.back() == '-';}\n  char& operator [] (int i){assert(i<(int)val.size());return val[i];}\n\n  bool operator ==  (Int b) {R(b.val); return *this == b.val;}\n  bool operator ==  (string b) {R(b);return val == b;}\n  template<class T> bool operator == (T b){return *this == Int(b);}\n  \n  bool operator !=  (Int b) {R(b.val); return *this != b.val;}\n  bool operator !=  (string b) {R(b);return !(val == b);}\n  template<class T> bool operator != (T b){return *this != Int(b);}\n  \n  bool operator >=  (Int b) {R(b.val); return *this >= b.val;}\n  bool operator >=  (string b) {return !(*this < b);}\n  template<class T> bool operator >= (T b){return *this >= Int(b);}\n\n  bool operator >   (Int b) {R(b.val); return *this > b.val;}\n  bool operator >   (string b) {return *this>=b && *this != b;}\n  template<class T> bool operator > (T b){return *this > Int(b);}\n\n  bool operator <=  (Int b) {R(b.val); return *this <= b.val;}\n  bool operator <=  (string b) {return *this<b || *this == b;}\n  template<class T> bool operator <= (T b){return *this <= Int(b);}\n\n  bool operator <   (Int b) {R(b.val); return *this < b.val;}\n  template<class T> bool operator < (T b){return *this < Int(b);}\n \n   bool operator <   (string b) {\n    R(b);\n    const string &a = val;\n    if(neg(a) != neg(b)) return neg(a)? 1:0;\n    if(a.size() != b.size()) return !neg(a)? (a.size()<b.size()):(a.size()>b.size());\n    for(int i=a.size()-1;i>=0;i--)if(a[i] != b[i]) return !neg(a)? a[i] < b[i]: a[i] > b[i];\n    return 0;\n  }\n  \n  Int operator + (string b){\n    R(b);\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(Int(a,1) < Int(b,1)) swap(a,b),swap(fa,fb);\n    \n    if(fa == fb){\n      a += '0';\n      for(int i=0;i<(int)a.size()-1;i++){\n        if(i < (int)b.size()) a[i] += b[i]-'0';\n        a[i+1] += (a[i]-'0')/10;\n        a[i] = (a[i]-'0')%10 + '0';\n      }\n      if(a.size() > 1 && a.back() == '0') a.pop_back();\n      if((int)a.size() > 1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    else {\n      for(int i=0;i<(int)a.size();i++){\n        if(i < (int)b.size()) a[i] -= b[i]-'0';\n        if(a[i]-'0' < 0) a[i]+=10, a[i+1]--; \n      }\n      while((int)a.size()>1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    return Int(a,1);\n  }\n\n  Int operator * (string b){\n    R(b);\n    vector<int> res;\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(a.size() < b.size()) swap(a,b), swap(fa,fb);\n    if(a == \"0\" || b == \"0\") return Int(\"0\");\n    \n    for(int j=0;j<(int)b.size();j++)\n      for(int i=0;i<(int)a.size();i++){\n        if(i+j >= (int)res.size()) res.push_back(0);\n        res[i+j] += (a[i]-'0') * (b[j]-'0');\n      }\n    for(int i=0; i <(int)res.size(); i++) {\n      if(res[i]/10 == 0) continue;\n      if(i + 1 >= (int)res.size()) res.push_back(0);\n      res[i+1] += res[i]/10, res[i]=res[i]%10;\n    }\n    string sres;\n    for(int i:res) sres += char(i + '0');\n    if(fa != fb) sres += '-';\n    return Int(sres,1);\n  }\n\n  Int div(string b,int flg){\n    assert(b != \"0\");\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = b[0]=='-'? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(b[0]=='-') b.erase(b.begin());\n    Int mod(\"0\");\n    string d=\"0\";\n    for(int i=(int)a.size()-1;i>=0;i--){\n      mod = mod * 10 + (a[i] - '0');\n      while(mod >= b) mod -= b, d.back()+=1;\n      if(i && d != \"0\") d += '0'; \n    }\n    if(flg == 0 && d != \"0\" && (fa != fb)) d = \"-\" + d;\n    if(flg == 1 && mod != \"0\" && (fa == \"-\")) mod *= -1;\n    return flg==0? d:mod;\n  }\n  \n  Int operator + (Int b){R(b.val); return *this + b.val;}\n  template<class T> Int operator + (T b){return *this + Int(b);}\n  \n  Int operator * (Int b){R(b.val); return *this * b.val;}\n  template<class T> Int operator * (T b){return *this * Int(b);}\n\n  Int operator - (string b){b = (b[0] == '-')? b.substr(1):\"-\" + b;return *this + b;}\n  Int operator - (Int b){R(b.val); return *this - b.val;} \n  template<class T> Int operator - (T b){return *this - Int(b);}\n  \n  Int operator / (string b){return div(b,0);}\n  Int operator / (Int b){R(b.val);return div(b.val,0);}\n  template<class T> Int operator / (T b){return *this / Int(b);}\n  \n  Int operator % (string b){return div(b,1);}\n  Int operator % (Int b){R(b.val);return div(b.val,1);}\n  template<class T> Int operator % (T b){return *this % Int(b);}\n  \n  Int operator += (Int b){return *this = *this+b;}\n  Int operator += (string b){return *this = *this+b;}\n  template<class T> Int operator += (T b){return *this += Int(b);}\n  \n  Int operator -= (Int b){return *this = *this-b;}\n  Int operator -= (string b){return *this = *this-b;}\n  template<class T> Int operator -= (T b){return *this -= Int(b);}\n  \n  Int operator *= (Int b){return *this = *this*b;}\n  Int operator *= (string b){return *this = *this*b;}\n  template<class T> Int operator *= (T b){return *this *= Int(b);}\n  \n  Int operator /= (string b){return *this = *this/b;}\n  Int operator /= (Int b){return *this = *this/b;}\n  template<class T> Int operator /= (T b){return *this /= Int(b);}\n  \n  Int operator %= (string b){return *this = *this % b;}\n  Int operator %= (Int b){return *this=*this%b;}\n  template<class T> Int operator %= (T b){return *this %= Int(b);}\n  \n  Int operator ++(){return *this += 1;}\n  Int operator --(){return *this -= 1;}\n\n#ifdef int\n#undef int\n#define eraseIntDefine\n#endif\n  Int operator ++(int){\n    Int tmp = *this;\n    *this += 1;\n    return tmp;\n  }\n  \n  Int operator --(int){\n    Int tmp = *this;\n    *this -= 1;\n    return tmp;\n  }\n#ifdef eraseIntDefine\n#define int long long\n#endif\n\n  friend ostream& operator << (ostream& os,const Int a){\n    for(int i=(int)a.val.size()-1;i>=0;i--) os<<a.val[i];\n    return os;\n  }\n\n  friend istream& operator >> (istream& is,Int &a){\n    string num;\n    is>>num;\n    a = Int(num);\n    return is;\n  }\n  friend string to_string(Int a){reverse(a.val.begin(),a.val.end());return a.val;}\n};\n\n\nstring str;\nstring num = \"51?3\";\n\nInt mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nInt dfs(int pos,int less,int cnt,string s,int target){\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt != 0;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  Int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  cout<<dfs(0,0,0,\"\",0)<<endl;\n  Int sum[10]={};\n  for(int i=0;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n\n  Int a = stoi(str);\n  Int ans(0);\n  for(int i=1;i<5;i++) ans += Int(i%2? 1:-1) * sum[i];\n  //cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define MOD 1000000007LL\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstring str;\nll dp[21][2][2][10000];\n\nint nextl(int a,int l){\n\tl*=10;\n\tl+=a;\n\tl%=10000;\n\treturn l;\n}\n\nbool istrue(int l){\n\tif(l%10!=3)return false;\n\tl/=100;\n\tif(l%10!=1)return false;\n\tl/=10;\n\tif(l%10!=5)return false;\n\treturn true;\n}\n\nint main(void){\n\tcin >> str;\n\tint n=str.size();\n\tmemset(dp,0,sizeof(dp));\n\tdp[0][0][0][0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\tfor(int l=0;l<10000;l++){\n\t\t\t\t\tint nj,nk,nl;\n\t\t\t\t\tif(j==0){\n\t\t\t\t\t\tfor(int a=0;a<=(str[i]-'0');a++){\n\t\t\t\t\t\t\tif(a!=(str[i]-'0'))nj=j+1;\n\t\t\t\t\t\t\telse nj=j;\n\t\t\t\t\t\t\tnl=nextl(a,l);\n\t\t\t\t\t\t\tif(istrue(nl)){\n\t\t\t\t\t\t\t\tnk=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tnk=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[i+1][nj][nk][nl]+=dp[i][j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfor(int a=0;a<=9;a++){\n\t\t\t\t\t\t\tnj=j;\n\t\t\t\t\t\t\tnl=nextl(a,l);\n\t\t\t\t\t\t\tif(istrue(nl)){\n\t\t\t\t\t\t\t\tnk=1;\n\t\t\t\t\t\t\t}else{\n\t\t\t\t\t\t\t\tnk=k;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[i+1][nj][nk][nl]+=dp[i][j][k][l];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tll ans=0;\n\tfor(int i=0;i<2;i++){\n\t\tfor(int j=0;j<10000;j++){\n\t\t\tans+=dp[n][i][1][j];\n\t\t}\n\t}\n\tprintf(\"%lld\\n\",ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long dp[20][2][5];\nstring N;\nlong long rec(int k,bool tight,int cnt)\n{\n\tif(k==N.size())\n\t{\n\t\treturn cnt==4;\n\t}\n\telse if(~dp[k][tight][cnt])\n\t{\n\t\treturn dp[k][tight][cnt];\n\t}\n\tint r=(tight?N[k]-'0':9);\n\tlong long ans=0;\n\tfor(int i=0;i<=r;i++)\n\t{\n\t\tif(cnt==4||cnt==2)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,cnt+(cnt==2));\n\t\t\tif(cnt==2&&i==5)\n\t\t\t{\n\t\t\t\tans+=rec(k+1,tight&&r==i,1);\n\t\t\t}\n\t\t}\n\t\telse if(i==5)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,1);\n\t\t}\n\t\telse if(cnt==1&&i==1)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,2);\n\t\t}\n\t\telse if(cnt==3&&i==3)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,0);\n\t\t}\n\t}\n\treturn dp[k][tight][cnt]=ans;\n}\nint main()\n{\n\tcin>>N;\n\tfor(int i=0;i<20;i++)\n\t{\n\t\tfor(int j=0;j<2;j++)\n\t\t{\n\t\t\tfor(int k=0;k<5;k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<rec(0,1,0)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[20][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[20][10][5][2][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num,bool completed){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\tcompleted = true;\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type][completed] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type][completed]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1,completed);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0,completed);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2,completed);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1,completed);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0,completed);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3,completed);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4,completed);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1,completed);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2,completed);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0,completed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1,completed);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0,completed);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2,completed);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1,completed);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0,completed);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3,completed);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4,completed);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1,completed);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2,completed);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0,completed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type][completed] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++){\n\t\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\t\tdp[digit][pre_num][match_num][p][k] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0,false));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\n#define REP(i,n) for (ll i = 0, i##_len = (n); i < i##_len; i++)\n#define ALL_OF(v) (v).begin(), (v).end()\nconstexpr ll LINF = numeric_limits<ll>::max();\nconstexpr ll  INF = numeric_limits<int>::max();\n\nint main() {\n\n    string s; cin >> s;\n    ll n = s.size();\n\n    // dp[i][j][k] := i桁見て状態jの数がNを下回って(k ? ない : いる)\n    vector<vector<vector<ll>>> dp(n+1, vector<vector<ll>>(6, vector<ll>(2, 0)));\n    dp[0][0][1] = 1;\n    REP(i, n) {\n        ll d = s[i] - '0';\n        REP(j, 10) {\n            switch (j) {\n                case 5:\n                    {\n                        ll dist[6] = {1, 1, 3, 1, 1, 5};\n                        REP(k, 6) dp[i+1][dist[k]][0] += dp[i][k][0];\n                        if (j <= d) {\n                            REP(k, 6) dp[i+1][dist[k]][j==d] += dp[i][k][1];\n                        }\n                    }\n                    break;\n                case 1:\n                    {\n                        ll dist[6] = {0, 2, 4, 2, 0, 5};\n                        REP(k, 6) dp[i+1][dist[k]][0] += dp[i][k][0];\n                        if (j <= d) {\n                            REP(k, 6) dp[i+1][dist[k]][j==d] += dp[i][k][1];\n                        }\n                    }\n                    break;\n                case 3:\n                    {\n                        ll dist[6] = {0, 0, 4, 5, 5, 5};\n                        REP(k, 6) dp[i+1][dist[k]][0] += dp[i][k][0];\n                        if (j <= d) {\n                            REP(k, 6) dp[i+1][dist[k]][j==d] += dp[i][k][1];\n                        }\n                    }\n                    break;\n                default:\n                    {\n                        ll dist[6] = {0, 0, 4, 0, 0, 5};\n                        REP(k, 6) dp[i+1][dist[k]][0] += dp[i][k][0];\n                        if (j <= d) {\n                            REP(k, 6) dp[i+1][dist[k]][j==d] += dp[i][k][1];\n                        }\n                    }\n            }\n        }\n    }\n\n    // REP(j, 6) REP(i, n+1) cerr << setw(4) << dp[i][j][0] + dp[i][j][1] << \" \\n\"[i==n];\n\n    cout << dp[n][5][0] + dp[n][5][1] << endl;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][5][2][2];\nstring s,t=\"51?3@\";\n\nint dfs(int idx,int mat,bool tight=true,bool ok=false){\n    if(idx==s.size())return ok;\n    int res=dp[idx][mat][tight][ok];\n    if(~res)return res;\n    res=0;\n    int x=s[idx]-'0';\n    int r=(tight?x:9);\n    for(int i=0;i<=r;i++){\n        int nxt=(i+'0'==t[mat])||(t[mat]=='?');\n        if(nxt&&(!ok))res+=dfs(idx+1,mat+nxt,tight&&i==r,nxt+mat==4 );\n        else if(ok)res+=dfs(idx+1,4,tight&&i==r,ok);\n        else{\n            if(i==5)res+=dfs(idx+1,1,tight&&i==r,ok);\n            else res+=dfs(idx+1,0,tight&&i==r,ok);\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    memset(dp,-1,sizeof(dp));\n    cin>>s;\n    cout<<dfs(0,0)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint dp[20][5][2];\n\nvoid print_debug(int a, int b, int c, int x, int y, int z, int val) {\n    /*\n    if(dp[x][y][z]) {\n        printf(\"move: %lld, %lld, %lld <- %lld, %lld, %lld (value = %lld, digit = %lld)\\n\", a, b, c, x, y, z, dp[x][y][z], val);\n    }\n    */\n}\n \nsigned main() {\n    string s; cin >> s;\n    int N = s.length();\n\n    dp[0][0][0] = 1;\n    string pat = \"51?3\";\n    for(int i=0; i<N; i++) {\n        for(int k=0; k<4; k++) {\n            for(int f=0; f<2; f++) {\n                int lim = f ? 9 : s[i] - '0';\n                for(int x=0; x<lim+1; x++) {\n                    bool is_match = (pat[k] == '?' || pat[k] - '0' == x);\n                    if(is_match) {\n                        if(k+1 != 4) {\n                            dp[i+1][k+1][f || x<lim] += dp[i][k][f];\n                            print_debug(i+1, k+1, f||x<lim, i, k, f, x);\n                        }\n                    }\n                    else {\n                        dp[i+1][x == 5][f || x < lim] += dp[i][k][f];\n                        print_debug(i+1, 0, f||x<lim, i, k, f, x);\n                    }\n                }\n            }\n        }\n    }\n\n    int sum = -1;\n    for(int i=0; i<4; i++) {\n        for(int j=0; j<2; j++) {\n            sum += dp[N][i][j];\n            // printf(\"dp[%lld][%lld][%lld] = %lld\\n\", N, i, j, dp[N][i][j]);\n        }\n    }\n\n    int init_val = atoll(s.c_str());\n    cout << init_val - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long dp[20][2][5];\nstring N;\nlong long rec(int k,bool tight,int cnt)\n{\n\tif(k==N.size())\n\t{\n\t\treturn cnt==4;\n\t}\n\telse if(~dp[k][tight][cnt])\n\t{\n\t\treturn dp[k][tight][cnt];\n\t}\n\tint r=(tight?N[k]-'0':9);\n\tlong long ans=0;\n\tif(cnt==2)\n\t{\n\t\tif(k+1>=N.size())return dp[k][tight][cnt]=0;\n\t\tr=tight?(N[k]-'0')*10+(N[k+1]-'0'):99;\n\t\tfor(int i=0;i<=r;i++)\n\t\t{\n\t\t\tif(i%10==3)ans+=rec(k+2,tight&&i==r,4);\n\t\t\telse if(i==51)ans+=rec(k+2,tight&&i==r,2);\n\t\t\telse ans+=rec(k+2,tight&&i==r,i%10==5);\n\t\t}\n\t}\n\telse\n\t{\n\t\tfor(int i=0;i<=r;i++)\n\t\t{\n\t\t\tif(cnt==4)\n\t\t\t{\n\t\t\t\tans+=rec(k+1,tight&&r==i,4);\n\t\t\t}\n\t\t\telse if(i==5)\n\t\t\t{\n\t\t\t\tans+=rec(k+1,tight&&r==i,1);\n\t\t\t}\n\t\t\telse if(cnt==1&&i==1)\n\t\t\t{\n\t\t\t\tans+=rec(k+1,tight&&r==i,2);\n\t\t\t}\n\t\t\telse if(cnt==3&&i==3)\n\t\t\t{\n\t\t\t\tans+=rec(k+1,tight&&r==i,4);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tans+=rec(k+1,tight&&r==i,0);\n\t\t\t}\n\t\t}\n\t}\n\treturn dp[k][tight][cnt]=ans;\n}\nint main()\n{\n\tcin>>N;\n\tfor(int i=0;i<20;i++)\n\t{\n\t\tfor(int j=0;j<2;j++)\n\t\t{\n\t\t\tfor(int k=0;k<5;k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<rec(0,1,0)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; i++)\n\ntemplate<class T>\nvector<T> make_v(size_t size, const T &init) {\n    return vector<T>(size, init);\n}\ntemplate<class... Ts>\nauto make_v(size_t size, Ts... rest) {\n    return vector<decltype(make_v(rest...))>(size, make_v(rest...));\n}\n\nint main() {\n    string s; cin >> s;\n    int n = s.size();\n    auto dp = make_v(n + 1, 2, 6, 0LL);\n    dp[0][0][0] = 1;\n    rep(i, n) rep(less, 2) rep(state, 6) rep(d, 10) {\n        if (!less && s[i] - '0' < d) break;\n        int nless = less | (d < s[i] - '0');\n        int nstate = d == 5;\n        if (state == 1 && d == 1) nstate = 2;\n        if (state == 2) nstate = (d == 5 ? 3 : 4);\n        if (state == 3 && d == 1) nstate = 2;\n        if (state == 3 && d == 3) nstate = 5;\n        if (state == 4 && d == 3) nstate = 5;\n        if (state == 5) nstate = 5;\n        dp[i + 1][nless][nstate] += dp[i][less][state];\n    }\n    cout << dp[n][0][5] + dp[n][1][5] << endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Int{\npublic:\n  string val;\n  Int():val(\"0\"){}\n  Int(string num,bool reversed=0){if(!reversed)R(num); val = num;}\n  Int(int num){val = to_string(num); R(val);}\n  \n  void R(string &a){reverse(a.begin(),a.end());}\n  bool neg(const string &a)const{return a.back() == '-';}\n  char& operator [] (int i){assert(i<(int)val.size());return val[i];}\n\n  bool operator ==  (Int b) {R(b.val); return *this == b.val;}\n  bool operator ==  (string b) {R(b);return val == b;}\n  template<class T> bool operator == (T b){return *this == Int(b);}\n  \n  bool operator !=  (Int b) {R(b.val); return *this != b.val;}\n  bool operator !=  (string b) {R(b);return !(val == b);}\n  template<class T> bool operator != (T b){return *this != Int(b);}\n  \n  bool operator >=  (Int b) {R(b.val); return *this >= b.val;}\n  bool operator >=  (string b) {return !(*this < b);}\n  template<class T> bool operator >= (T b){return *this >= Int(b);}\n\n  bool operator >   (Int b) {R(b.val); return *this > b.val;}\n  bool operator >   (string b) {return *this>=b && *this != b;}\n  template<class T> bool operator > (T b){return *this > Int(b);}\n\n  bool operator <=  (Int b) {R(b.val); return *this <= b.val;}\n  bool operator <=  (string b) {return *this<b || *this == b;}\n  template<class T> bool operator <= (T b){return *this <= Int(b);}\n\n  bool operator <   (Int b) {R(b.val); return *this < b.val;}\n  template<class T> bool operator < (T b){return *this < Int(b);}\n \n   bool operator <   (string b) {\n    R(b);\n    const string &a = val;\n    if(neg(a) != neg(b)) return neg(a)? 1:0;\n    if(a.size() != b.size()) return !neg(a)? (a.size()<b.size()):(a.size()>b.size());\n    for(int i=a.size()-1;i>=0;i--)if(a[i] != b[i]) return !neg(a)? a[i] < b[i]: a[i] > b[i];\n    return 0;\n  }\n  \n  Int operator + (string b){\n    R(b);\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(Int(a,1) < Int(b,1)) swap(a,b),swap(fa,fb);\n    \n    if(fa == fb){\n      a += '0';\n      for(int i=0;i<(int)a.size()-1;i++){\n        if(i < (int)b.size()) a[i] += b[i]-'0';\n        a[i+1] += (a[i]-'0')/10;\n        a[i] = (a[i]-'0')%10 + '0';\n      }\n      if(a.size() > 1 && a.back() == '0') a.pop_back();\n      if((int)a.size() > 1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    else {\n      for(int i=0;i<(int)a.size();i++){\n        if(i < (int)b.size()) a[i] -= b[i]-'0';\n        if(a[i]-'0' < 0) a[i]+=10, a[i+1]--; \n      }\n      while((int)a.size()>1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    return Int(a,1);\n  }\n\n  Int operator * (string b){\n    R(b);\n    vector<int> res;\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(a.size() < b.size()) swap(a,b), swap(fa,fb);\n    if(a == \"0\" || b == \"0\") return Int(\"0\");\n    \n    for(int j=0;j<(int)b.size();j++)\n      for(int i=0;i<(int)a.size();i++){\n        if(i+j >= (int)res.size()) res.push_back(0);\n        res[i+j] += (a[i]-'0') * (b[j]-'0');\n      }\n    for(int i=0; i <(int)res.size(); i++) {\n      if(res[i]/10 == 0) continue;\n      if(i + 1 >= (int)res.size()) res.push_back(0);\n      res[i+1] += res[i]/10, res[i]=res[i]%10;\n    }\n    string sres;\n    for(int i:res) sres += char(i + '0');\n    if(fa != fb) sres += '-';\n    return Int(sres,1);\n  }\n\n  Int div(string b,int flg){\n    assert(b != \"0\");\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = b[0]=='-'? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(b[0]=='-') b.erase(b.begin());\n    Int mod(\"0\");\n    string d=\"0\";\n    for(int i=(int)a.size()-1;i>=0;i--){\n      mod = mod * 10 + (a[i] - '0');\n      while(mod >= b) mod -= b, d.back()+=1;\n      if(i && d != \"0\") d += '0'; \n    }\n    if(flg == 0 && d != \"0\" && (fa != fb)) d = \"-\" + d;\n    if(flg == 1 && mod != \"0\" && (fa == \"-\")) mod *= -1;\n    return flg==0? d:mod;\n  }\n  \n  Int operator + (Int b){R(b.val); return *this + b.val;}\n  template<class T> Int operator + (T b){return *this + Int(b);}\n  \n  Int operator * (Int b){R(b.val); return *this * b.val;}\n  template<class T> Int operator * (T b){return *this * Int(b);}\n\n  Int operator - (string b){b = (b[0] == '-')? b.substr(1):\"-\" + b;return *this + b;}\n  Int operator - (Int b){R(b.val); return *this - b.val;} \n  template<class T> Int operator - (T b){return *this - Int(b);}\n  \n  Int operator / (string b){return div(b,0);}\n  Int operator / (Int b){R(b.val);return div(b.val,0);}\n  template<class T> Int operator / (T b){return *this / Int(b);}\n  \n  Int operator % (string b){return div(b,1);}\n  Int operator % (Int b){R(b.val);return div(b.val,1);}\n  template<class T> Int operator % (T b){return *this % Int(b);}\n  \n  Int operator += (Int b){return *this = *this+b;}\n  Int operator += (string b){return *this = *this+b;}\n  template<class T> Int operator += (T b){return *this += Int(b);}\n  \n  Int operator -= (Int b){return *this = *this-b;}\n  Int operator -= (string b){return *this = *this-b;}\n  template<class T> Int operator -= (T b){return *this -= Int(b);}\n  \n  Int operator *= (Int b){return *this = *this*b;}\n  Int operator *= (string b){return *this = *this*b;}\n  template<class T> Int operator *= (T b){return *this *= Int(b);}\n  \n  Int operator /= (string b){return *this = *this/b;}\n  Int operator /= (Int b){return *this = *this/b;}\n  template<class T> Int operator /= (T b){return *this /= Int(b);}\n  \n  Int operator %= (string b){return *this = *this % b;}\n  Int operator %= (Int b){return *this=*this%b;}\n  template<class T> Int operator %= (T b){return *this %= Int(b);}\n  \n  Int operator ++(){return *this += 1;}\n  Int operator --(){return *this -= 1;}\n\n#ifdef int\n#undef int\n#define eraseIntDefine\n#endif\n  Int operator ++(int){\n    Int tmp = *this;\n    *this += 1;\n    return tmp;\n  }\n  \n  Int operator --(int){\n    Int tmp = *this;\n    *this -= 1;\n    return tmp;\n  }\n#ifdef eraseIntDefine\n#define int long long\n#endif\n\n  friend ostream& operator << (ostream& os,const Int a){\n    for(int i=(int)a.val.size()-1;i>=0;i--) os<<a.val[i];\n    return os;\n  }\n\n  friend istream& operator >> (istream& is,Int &a){\n    string num;\n    is>>num;\n    a = Int(num);\n    return is;\n  }\n  friend string to_string(Int a){reverse(a.val.begin(),a.val.end());return a.val;}\n};\n\n\nstring str;\nstring num = \"51?3\";\n\nInt mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nInt dfs(int pos,int less,int cnt,string s,int target){\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt == target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  Int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  Int sum[10]={};\n  for(int i=0;i<10;i++) sum[i] += dfs(0,0,0,\"\",i);\n\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n\n  Int a = stoi(str);\n  Int ans(a);\n  for(int i=1;i<10;i++) ans -= Int(i%2? 1:-1) * sum[i];\n  cout<<(a-ans)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,a,b) for(int i=a;i<b;i++)\n#define rrep(i,a,b) for(int i=a;i>=b;i--)\n#define fore(i,a) for(auto &i:a)\n#define all(x) (x).begin(),(x).end()\n#pragma GCC optimize (\"-O3\")\nusing namespace std; void _main(); int main() { cin.tie(0); ios::sync_with_stdio(false); _main(); }\ntypedef long long ll; const int inf = INT_MAX / 2; const ll infl = 1LL << 60;\ntemplate<class T>bool chmax(T &a, const T &b) { if (a<b) { a = b; return 1; } return 0; }\ntemplate<class T>bool chmin(T &a, const T &b) { if (b<a) { a = b; return 1; } return 0; }\n//---------------------------------------------------------------------------------------------------\n/*---------------------------------------------------------------------------------------------------\n　　　　　　　　　　　 ∧＿∧  \n　　　　　 ∧＿∧ 　（´<_｀ ）　 Welcome to My Coding Space!\n　　　　 （ ´_ゝ`）　/　 ⌒i     \n　　　　／　　　＼　 　  |　|     \n　　　 /　　 /￣￣￣￣/　　|  \n　 ＿_(__ﾆつ/　    ＿/ .| .|＿＿＿＿  \n　 　　　＼/＿＿＿＿/　（u　⊃  \n---------------------------------------------------------------------------------------------------*/\n\n\n\n\n\n\nstring S;\nint N;\n//---------------------------------------------------------------------------------------------------\n// state\n// =0:none\n// =1:5\n// =2:51\n// =3:51? (?!=5)\n// =4:515\n// =5:51?3達成済み\nll memo[20][6][2];\nll f(int cu, int state, int isless) {\n    if (cu == N) {\n        if (state == 5) return 1;\n        else return 0;\n    }\n    if (0 <= memo[cu][state][isless]) return memo[cu][state][isless];\n\n    int c = S[cu] - '0';\n    ll res = 0;\n    rep(i, 0, 10) {\n        if (!isless and c < i) continue;\n        int nxisless = isless;\n        if (i < c) nxisless = 1;\n\n        if (state == 0) {\n            if (i == 5) res += f(cu + 1, 1, nxisless);\n            else res += f(cu + 1, 0, nxisless);\n        }\n        else if (state == 1) {\n            if (i == 1) res += f(cu + 1, 2, nxisless);\n            else if (i == 5) res += f(cu + 1, 1, nxisless);\n            else res += f(cu + 1, 0, nxisless);\n        }\n        else if (state == 2) {\n            if (i == 5) res += f(cu + 1, 4, nxisless);\n            else res += f(cu + 1, 3, nxisless);\n        }\n        else if (state == 3) {\n            if (i == 3) res += f(cu + 1, 5, nxisless);\n            else if (i == 5) res += f(cu + 1, 1, nxisless);\n            else res += f(cu + 1, 0, nxisless);\n        }\n        else if (state == 4) {\n            if(i == 3) res += f(cu + 1, 5, nxisless);\n            else if(i == 1) res += f(cu + 1, 2, nxisless);\n            else if(i == 5) res += f(cu + 1, 1, nxisless);\n            else res += f(cu + 1, 0, nxisless);\n        }\n        else if (state == 5) {\n            res += f(cu + 1, 5, nxisless);\n        }\n    }\n\n    return memo[cu][state][isless] = res;\n}\n//---------------------------------------------------------------------------------------------------\nvoid _main() {\n    cin >> S;\n    N = S.length();\n    rep(cu, 0, N + 1) rep(state, 0, 6) rep(isless, 0, 2) memo[cu][state][isless] = -1;\n    cout << f(0, 0, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\nusing namespace std;\ntypedef long long ll;\nconst ll mod = 1000000007;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define stop char nyaa;cin>>nyaa;\n\n//keta,Nより小さい,51?3の回数\nll dp[19][2][5];\n\n\n\nvoid solve() {\n\tll n; cin >> n;\n\tdp[0][0][0] = 1;\n\tvector<ll> v;\n\tll cop = n;\n\trep(i, 18) {\n\t\tv.push_back(n % 10); n /= 10;\n\t}\n\trep(i, 18) {\n\t\tint z = v[17 - i];\n\t\tif (i <= 14) {\n\t\t\t//51?3を追加\n\n\t\t\t//Case <N\n\t\t\trep(k, 4) {\n\t\t\t\tdp[i + 4][1][k + 1] += dp[i][1][k] * 10;\n\t\t\t}\n\n\t\t\t//Case ==N\n\n\t\t\t//既に小さい\n\t\t\tif (v[17 - i] > 5||(v[17-i]==5&&v[16-i]>1)) {\n\t\t\t\trep(k, 4) {\n\t\t\t\t\tdp[i + 4][1][k + 1] += dp[i][0][k] * 10;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//一緒、?に依存\n\t\t\telse if (v[17 - i] == 5 && v[16 - i] == 1) {\n\t\t\t\tif (v[14 - i] < 3) {\n\t\t\t\t\tint num = v[15 - i];\n\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\tdp[i + 4][1][k + 1] += dp[i][0][k] * num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if(v[14-i]>3){\n\t\t\t\t\tint num = v[15 - i]+1;\n\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\tdp[i + 4][1][k + 1] += dp[i][0][k] * num;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tint num = v[15 - i]+1;\n\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\tdp[i + 4][1][k + 1] += dp[i][0][k] * num;\n\t\t\t\t\t}\n\t\t\t\t\trep(k, 4) {\n\t\t\t\t\t\tdp[i + 4][1][k + 1] -= dp[i][0][k];\n\t\t\t\t\t\tdp[i + 4][0][k + 1] += dp[i][0][k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//既に大きい\n\t\t\telse {\n\t\t\t\t//することない\n\t\t\t}\n\n\t\t}\n\t\t//自由に追加\n\n\t\t//Case <N\n\t\trep(k, 5) {\n\t\t\tdp[i + 1][1][k] += dp[i][1][k] * 10;\n\t\t}\n\t\t//Case ==N\n\t\tint num = v[17 - i];\n\t\trep(k, 5) {\n\t\t\tdp[i + 1][1][k] += dp[i][0][k] * num;\n\t\t\tdp[i + 1][0][k] += dp[i][0][k];\n\t\t}\n\t}\n\tll ans = 0;\n\trep1(i, 4) {\n\t\tll s = -1;\n\t\tif (i % 2)s = 1;\n\t\tll sum = dp[18][0][i] + dp[18][1][i];\n\t\tans += sum * s;\n\t}\n\tcout << ans << endl;\n}\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\tsolve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n// #define mt make_tuple\n//typedef tuple<pii,int,int> tp;\n//typedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-7;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\nll dp[20][1000][2][2];\nint main(){\n\tdp[0][0][0][0]=1;\n\t\n\tstring s;\n\tcin>>s;\n\tint n=s.size();\n\t\n\trep(i,n)rep(j,1000)rep(k,2)rep(l,2)rep(x,10){\n\t\tif(!k&&s[i]-'0'<x)continue;\n\t\tint I=i+1,J=j*10+x,K=k||(x<s[i]-'0'),L=l;\n\t\tif(J/100==51&&J%10==3)L=true;\n\t\tdp[I][J%1000][K][L]+=dp[i][j][k][l];\n\t}\n\tll out=0;\n\trep(i,1000)rep(j,2)out+=dp[n][i][j][1];\n\tcout<<out<<endl;\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<bits/stdc++.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\nconstexpr int MAX_LEN = 25;\n\nLL dp_N[MAX_LEN][1000][2]; bool vis_N[MAX_LEN];\nLL dp_all[MAX_LEN][1000][2]; bool vis_all[MAX_LEN];\nvoid f(int d);\nvoid g(int d);\n\nvector<int> in;\nint len;\nbool usa[10000];\nvoid f(int d) {\n\tif (vis_N[d])return;\n\tvis_N[d] = true;\n\tfor (int i : range(1000)) {\n\t\tdp_N[d][i][0] = dp_N[d][i][1] = 0;\n\t}\n\tif (d == 0) {\n\t\tdp_N[d][0][0] = 1; return;\n\t}\n\tf(d - 1); g(d - 1);\n\t{\n\t\tint p = in[d - 1];\n\t\tfor (int i : range(1000)) {\n\t\t\tint nxt = p * 1000 + i;\n\t\t\tdp_N[d][nxt / 10][1] += dp_N[d - 1][i][1];\n\t\t\tif (usa[nxt]) {\n\t\t\t\tdp_N[d][nxt / 10][1] += dp_N[d - 1][i][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp_N[d][nxt / 10][0] += dp_N[d - 1][i][0];\n\t\t\t}\n\t\t}\n\t}\n\tfor(int p:range(in[d-1])){\n\t\tfor (int i : range(1000)) {\n\t\t\tint nxt = p * 1000 + i;\n\t\t\tdp_N[d][nxt / 10][1] += dp_all[d - 1][i][1];\n\t\t\tif (usa[nxt]) {\n\t\t\t\tdp_N[d][nxt / 10][1] += dp_all[d - 1][i][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp_N[d][nxt / 10][0] += dp_all[d - 1][i][0];\n\t\t\t}\n\t\t}\n\t}\n}\nvoid g(int d) {\n\tif (vis_all[d])return;\n\tvis_all[d] = true;\n\tfor (int i : range(1000)) {\n\t\tdp_all[d][i][0] = dp_all[d][i][1] = 0;\n\t}\n\tif (d == 0) {\n\t\tdp_all[d][0][0] = 1; return;\n\t}\n\tf(d - 1); g(d - 1);\n\tfor (int p : range(10)) {\n\t\tfor (int i : range(1000)) {\n\t\t\tint nxt = p * 1000 + i;\n\t\t\tdp_all[d][nxt / 10][1] += dp_all[d - 1][i][1];\n\t\t\tif (usa[nxt]) {\n\t\t\t\tdp_all[d][nxt / 10][1] += dp_all[d - 1][i][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp_all[d][nxt / 10][0] += dp_all[d - 1][i][0];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tfor (int i : range(10000))usa[i] = false;\n\tfor (int i : range(10))usa[5103 + i * 10] = true;\n\tstring s;\n\tcin >> s;\n\treverse(ALL(s));\n\tfor (auto &it : s)in.push_back(it - '0');\n\tfor(int i:range(3))in.push_back(0);\n\tlen = in.size();\n\tf(len);\n\tLL ret = 0;\n\tret+=dp_N[len][0][1];\n\tcout << ret << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint pow10(int x){\n  if(x == 0) return 1;\n  return 10 * pow10(x-1);\n}\n\nint cnt(int x,int less){\n  if(x == n) return 1;\n  if(less) return pow10(n - x);\n  int a =  cnt(x+1,0);\n  int b = (str[x] - '0') * cnt(x+1,1);\n  return a + b;\n}\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += cnt(nidx,nless);\n    else res += dfs(nidx,nless,b ,c ,i);\n    \n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\nll dp[18][10000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\n//ll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%10000;\n\t//return next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9999; pre_num++){\n\t\t//for(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nstring s;\nint64 gochi[4] = {5, 1, -1, 3};\nint64 dp[20][2][5] = {};\n\nint64 dfs(int32 k = 0, bool tight = 1, int32 suc = 0){\n\tif(k == s.size()) return suc == 4;\n\tint32 lim = (tight ? s[k]+1 : 10);\n\tint64 &res = dp[k][tight][suc];\n\tif(~res) return res;\n\tres = 0;\n\tREP(i, lim){\n\t\tif(suc < 4 && (gochi[suc] == -1 || gochi[suc] == i)){\n\t\t\tres += dfs(k+1, tight && i == (lim-1), suc+1);\n\t\t}else if(suc == 4){\n\t\t\tres += dfs(k+1, tight && i == (lim-1), suc);\n\t\t}else{\n\t\t\tres += dfs(k+1, tight && i == (lim-1), gochi[0] == i);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tcin >> s;\n\tREP(i, s.size()) s[i] -= '0';\n\tmemset(dp, -1, sizeof dp);\n\tcout << dfs() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = __int128;\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n\tauto val = table(args...);\n\treturn std::vector<decltype(val)>(n, std::move(val));\n}\n\n\nll solve(ll n) {\n\tconst auto s = to_string((long long)n);\n\tconst int m = s.size();\n\t// [pos][i - 3][i - 2][i - 1][already ok][strictly less]\n\tauto dp = table<ll>(m + 1, 10, 10, 10, 2, 2, 0);\n\tdp[0][0][0][0][0][0] = 1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int i3 = 0; i3 <= 9; ++i3) for (int i2 = 0; i2 <= 9; ++i2) for (int i1 = 0; i1 <= 9; ++i1) {\n\t\t\tfor (int aok = 0; aok <= 1; ++aok) {\n\t\t\t\tfor (int le = 0; le <= 1; ++le) {\n\t\t\t\t\tconst int lim = le ? 9 : s[i] - '0';\n\t\t\t\t\tfor (int add = 0; add <= lim; ++add) {\n\t\t\t\t\t\tint nok = aok || (i3 == 5 && i2 == 1 && add == 3);\n\t\t\t\t\t\tint nle = le || s[i] - '0' > add;\n\t\t\t\t\t\tdp[i + 1][i2][i1][add][nok][nle] += dp[i][i3][i2][i1][aok][le];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i <= 9; ++i) {\n\t\tfor (int j = 0; j <= 9; ++j) {\n\t\t\tfor (int k = 0; k <= 9; ++k) {\n\t\t\t\tans += dp[m][i][j][k][1][0] + dp[m][i][j][k][1][1];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tlong long N;\n\tcin >> N;\n\tcout << (long long)solve(N) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(ll i=(ll)(a);i<(ll)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define mmax(x,y) (x>y?x:y)\n#define mmin(x,y) (x<y?x:y)\n#define maxch(x,y) x=mmax(x,y)\n#define minch(x,y) x=mmin(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt __builtin_popcount\n\n#define INF 1e16\n#define mod 1000000007\n\nstring s;\nll a[22];\nll dp[22][5][2][10];\n\nint main(){\n  cin>>s;\n  ll n=s.size();\n  rep(i,n)a[i]=s[i]-'0';\n  dp[0][0][0][0]=1;\n  rep(i,n){\n    rep(j,5){\n      rep(k,2){\n        rep(l,10){\n          rep(d,k==0?(a[i]+1):10){\n            if(j==0){\n              if(d==5){\n                dp[i+1][j+1][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n              }else{\n                dp[i+1][0][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n              }\n            }else if(j==1){\n              if(d==1){\n                dp[i+1][j+1][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n              }else{\n                dp[i+1][d==5][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n              }\n            }else if(j==2){\n              dp[i+1][j+1][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n            }else if(j==3){\n              if(d==3){\n                dp[i+1][j+1][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n              }else if(l==5&&d==1){\n                dp[i+1][2][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n              }else{\n                dp[i+1][d==5][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n              }\n            }else if(j==4){\n              dp[i+1][j][!(k==0&&(d==a[i]))][d]+=dp[i][j][k][l];\n            }\n          }\n        }\n      }\n    }\n  }\n  ll res=0;\n  rep(i,10)res+=(dp[n][4][0][i]+dp[n][4][1][i]);\n  cout<<res<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint pow10(int x){\n  if(x == 0) return 1;\n  return 10 * pow10(x-1);\n}\n\nint cnt(int x,int less){\n  if(x == n) return 1;\n  if(less) return pow10(n - x);\n  int a =  cnt(x+1,0);\n  int b = (n - x - 1) * cnt(x+1,1);\n  return a + b;\n}\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += cnt(nidx,nless);\n    else res += dfs(nidx,nless,b ,c ,i);\n    \n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\ntemplate<class S,class T> ostream& operator<<(ostream& o,const pair<S,T> &p){return o<<\"(\"<<p.fs<<\",\"<<p.sc<<\")\";}\ntemplate<class T> ostream& operator<<(ostream& o,const vector<T> &vc){o<<\"sz = \"<<vc.size()<<endl<<\"[\";for(const T& v:vc) o<<v<<\",\";o<<\"]\";return o;}\nusing ll = long long;\nll dp[20][2][6];\t//d,just=1,type\t5 = ok\n\nint main(){\n\tstring s;\n\tcin>>s;\n\tint N = s.size();\n\tdp[0][1][0] = 1;\n\trep(i,N) rep(just,2) rep(t,6){\n\t\trep(c,10){\n\t\t\tif(just && c>s[i]-'0') break;\n\t\t\tint ni = i+1;\n\t\t\tint njust = (just && c==s[i]-'0');\n\t\t\tint nt = 0;\n\t\t\tif(t==0 && c==5) nt = 1;\n\t\t\telse if(t==1 && c==1) nt = 2;\n\t\t\telse if(t==2 && c==5) nt = 3;\n\t\t\telse if(t==2 && c!=5) nt = 4;\n\t\t\telse if(t==3 && c==3) nt = 5;\n\t\t\telse if(t==4 && c==3) nt = 5;\n\t\t\telse if(t==5) nt = 5;\n\t\t\telse{\n\t\t\t\tif(t==3 && c==1) nt = 2;\n\t\t\t\tif(c==5) nt = 1;\n\t\t\t}\n\t\t\tdp[ni][njust][nt] += dp[i][just][t];\n\t\t}\n\t}\n\tcout<<dp[N][0][5]+dp[N][1][5]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\n\nstring str;\nstring num = \"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nint dfs(int pos,int less,int cnt,string s,int target){\n  cnt = min(1LL,cnt);\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt >= target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  int sum[10]={};\n  for(int i=0;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n\n  int ans = 0;\n  for(int i=1;i<5;i++) ans += (i%2? 1:-1) * sum[i];\n  cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll mypow(ll a,ll b){\n  ll res=1;\n  for(ll i=0;i<b;i++)\n    res*=a;\n  return res;\n}\n\nstring s;\nint len;\nll dp[20][10][10][10][2];\n\nll rec(int d,int x,int y,int z,int f){\n  if( d== len )return 0;\n\n  if( dp[d][x][y][z][f]!=-1 )return dp[d][x][y][z][f];\n  \n  int left=0,right=9;\n  if(f)right=s[d]-'0';\n\n  ll res=0;\n  for(ll i=left;i<=right;i++){\n    int nf=f;\n    if(i < right)nf=0;\n    if( x==5 && y==1 && i==3 ){\n      ll last=len-d-1;\n      res+= mypow(10,last);\n    }\n      res+=rec(d+1,y,z,i,nf);\n\n  }\n  \n  return dp[d][x][y][z][f]=res;\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  \n  cin>>s;\n  len=s.size();\n  cout<< rec(0,0,0,0,1) <<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate <typename T> constexpr T inf;\ntemplate <> constexpr int inf<int> = 1e9;\ntemplate <> constexpr ll inf<ll> = 1e18;\ntemplate <> constexpr double inf<double> = 1e18;\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n \ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return std::vector<decltype(val)>(n, std::move(val));\n}\n\n\nll solve(ll n) {\n    const auto s = to_string(n);\n    const int m = s.size();\n    // [pos][i - 3][i - 2][i - 1][already ok][strictly less]\n    auto dp = table<ll>(m + 1, 10, 10, 10, 2, 2, 0LL);\n    dp[0][0][0][0][0][0] = 1;\n    for(int i = 0; i < m; ++i) {\n        for(int i3 = 0; i3 <= 9; ++i3) for(int i2 = 0; i2 <= 9; ++i2) for(int i1 = 0; i1 <= 9; ++i1) {\n            for(int aok = 0; aok <= 1; ++aok) {\n                for(int le = 0; le <= 1; ++le) {\n                    const int lim = le ? 9 : s[i] - '0';\n                    for(int add = 0; add <= lim; ++add) {\n                        int nok = aok || (i3 == 5 && i2 == 1 && add == 3);\n                        int nle = le || s[i] - '0' > add;\n                        dp[i + 1][i2][i1][add][nok][nle] += dp[i][i3][i2][i1][aok][le];\n                    }\n                }\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i <= 9; ++i) {\n        for(int j = 0; j <= 9; ++j) {\n            for(int k = 0; k <= 9; ++k) {\n                ans += dp[m][i][j][k][1][0] + dp[m][i][j][k][1][1];\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    cout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring s;\nint dp[20][1000][2][2];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> s;\n  int n = s.size();\n  //memset(dp, -1, sizeof(dp));\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0] = 1;\n  for(int i = 0; i < n; ++i) {\n    for(int j = 0; j < 1000; ++j) {\n      for(int k = 0; k < 2; ++k) {\n\tfor(int l = 0; l < 2; ++l) {\n\t  //if(dp[i][j][k][l] == -1) continue;\n\t  int lim = l ? 9 : s[i]-'0';\n\t  for(int d = 0; d <= lim; ++d) {\n\t    int nj = j%100*10+d;\n\t    int nk = j/10*100+d == 5103;\n\t    /*\n\t    if(!k && nk) {\n\t      //cout<<i<<\" \"<<j<<\" \"<<nj<<\" \"<<j*10+d<<endl;\n\t      if(dp[i+1][nj][k||nk][l||d<lim] == -1) dp[i+1][nj][k||nk][l||d<lim] = 0;\n\t      dp[i+1][nj][k||nk][l||d<lim] += dp[i][j][k][l];\n\t    } else {\n\t    */\n\t    //if(dp[i+1][nj][k||nk][l||d<lim] == -1) dp[i+1][nj][k||nk][l||d<lim] = 0;\n\t      dp[i+1][nj][k||nk][l||d<lim] += dp[i][j][k][l];\n\t      //}\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ans = 0;\n  rep(i, 1000) {\n    rep(j, 2) {\n      if(~dp[n][i][1][j]) ans += dp[n][i][1][j];\n    }\n    //cout<<dp[n][i][1][0]<<\" \"<<dp[n][i][1][1]<<endl;\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstring N;\nint rec(int i, bool less, int state) {\n    if (i == SZ(N)) {\n        return (state >= 4) ? 1 : 0;\n    }\n\n    int ret = 0;\n    if (less) {\n        REP(j, 10) {\n            int next_state = state;\n            if ((state == 0 && j == 5)\n             || (state == 1 && j == 1)\n             || (state == 2)\n             || (state == 3 && j == 3)\n             || (state >= 4)) next_state++;\n            else {\n                if (j == 5) next_state = 1;\n                else {\n                    if (state == 3 && j == 1) next_state = 2;\n                    else next_state = 0;\n                }\n            }\n            ret += rec(i+1, true, next_state);\n        }\n    } else {\n        REP(j, N[i]-'0'+1) {\n            int next_state = state;\n            if ((state == 0 && j == 5)\n             || (state == 1 && j == 1)\n             || (state == 2)\n             || (state == 3 && j == 3)\n             || (state >= 4)) next_state++;\n            else {\n                if (j == 5) next_state = 1;\n                else {\n                    if (state == 3 && j == 1) next_state = 2;\n                    else next_state = 0;\n                }\n            }\n            ret += rec(i+1, j!=(N[i]-'0'), next_state);\n        }\n    }\n    return ret;\n}\nsigned main() {\n    cin >> N;\n    cout << rec(0, 0, 0) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][2][10][10][10];\n\nstring num;\n\nint Stoll(string s){\n  \n  int res = 0;\n  \n  for(int i=0;i<s.size();i++) res = res * 10 + s[i] - '0';\n\n  return res;\n}\n\nint dfs(int x, int y, int p3, int p2, int p1 ){\n  \n  if( num.size() <= x ) return 0;\n  \n  if( dp[x][y][p3][p2][p1] != -1 ) return dp[x][y][p3][p2][p1];\n  \n  int res = 0;\n  \n  if( y == 0 ){\n    \n    int p = num[x] - '0';\n    \n    if( p3 == 5 && p2 == 1 && p == 3 ){\n      if( x != (int)num.size() - 1 ) res += Stoll(num.substr(x+1));\n      res++;\n    }\n    else res += dfs( x+1, 0, p2, p1, p );\n    \n    for(int i=0;i<num[x]-'0';i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\tif( x != (int)num.size() - 1 ) res += Stoll(num.substr(x+1));\n\tres++;\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n  \n  if( y == 1 ){\n    \n    for(int i=0;i<10;i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\t\n\tint X = 1;\n\t\n\tfor(int j=0;j<(int)num.size()-x-1;j++) X *= 10;\n\t\n\tres += X;\n\t\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n\n  return dp[x][y][p3][p2][p1] = res;\n}\n\nsigned main(){\n  \n  cin>>num;\n  \n  memset( dp, -1, sizeof(dp) );\n  \n  cout<<dfs(0,0,0,0,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][1000][2][2];\nstring s;\n\nint dfs(int idx,int p,bool tight=true,bool ok=false){\n    if(idx==s.size())return ok;\n    int &res=dp[idx][p][tight][ok];\n    if(~res)return res;\n    res=0;\n    int x=s[idx]-'0';\n    int r=(tight?x:9);\n    for(int i=0;i<=r;i++){\n        int nxt=(p*10+i)%1000;\n        res+=dfs(idx+1,nxt,tight&&i==r,ok||((p/10)==51&&i==3));\n    }\n    return res;\n}\n\nsigned main(){\n    memset(dp,-1,sizeof(dp));\n    cin>>s;\n    cout<<dfs(0,0)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string> \n#include <cstring>\n#include <cmath>  \n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n#include <cctype>\n#include <list>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n#define BIT(a) (1 << (a))\n#define EPS (1e-10)\n\nusing namespace std;\n//using namespace boost::multiprecision;\n\nconst long long MOD = 1000000007;\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nclass Point{\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n    \n    Point operator+(Point p){return Point(x + p.x, y + p.y);}\n    Point operator-(Point p){return Point(x - p.x, y - p.y);}\n    Point operator*(double a){return Point(a * x, a * y);}\n    Point operator/(double a){return Point(x / a, y / a);}\n\n    bool operator < (const Point &p) const {\n        return y != p.y ? y < p.y : x < p.x;\n    }\n\n    double norm(){return x * x + y * y;}\n};\ntypedef Point Vector;\ntypedef vector<Vector> Polygon;\n\ndouble cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n    if (cross(a, b) > -EPS)return CLOCKWISE;\n    if (dot(a, b) < -EPS)return ONLINE_BACK;\n    if (a.norm() < b.norm())return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s){\n    Polygon u, l;\n    if (s.size() < 3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    \n    for (size_t i = 2; i < s.size(); i++){\n        for (size_t n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for (int i = (int)s.size() - 3; i >= 0; i--){\n        for (size_t n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (size_t i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\nlong long mod_pow(long long x, long long n){\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\nlong long dp[20][2][2][2][2][2];\n\nlong long digit_dp(string A){\n    int N = A.length();\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0][0][0][0] = 1;\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < 2; j++){\n            for (int k = 0; k < 2; k++){\n                for (int l = 0; l < 2; l++){\n                    for (int m = 0; m < 2; m++){\n                        for (int n = 0; n < 2; n++){\n                            int lim = j ? 9 : A[i] - '0';\n                            for (int d = 0; d < lim + 1; d++){\n                                dp[i+1][j || d < lim][d == 5][k && (d == 1)][l][(m && d == 3) || n] += dp[i][j][k][l][m][n];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    long long ret = 0;\n\n    for (int i = 0; i < 2; i++){\n        for (int j = 0; j < 2; j++){\n            for (int k = 0; k < 2; k++){\n                for (int l = 0; l < 2; l++){\n                    ret += dp[N][i][j][k][l][1];\n                }\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main(void){\n    string N;\n    cin >> N;\n\n    cout << digit_dp(N) << endl;\n    return 0;\n}   \n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\nusing namespace std;\n\nistream &operator>>(istream &is, vector<int> &v) {\n  string s;\n  is >> s;\n  v.reserve(s.size());\n  for (char c : s) v.emplace_back(c - '0');\n  return is;\n}\n\ntemplate <typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate <typename Head, typename... Tail> auto vectors(Head x, Tail... tail) {\n  auto inner = vectors(tail...);\n  return vector<decltype(inner)>(x, inner);\n}\n\nsigned main() {\n  vector<int> s;\n  cin >> s;\n  int n = static_cast<int>(s.size());\n\n  auto dp = vectors(n + 1, 2, 5, 2, 0LL);\n  dp[0][0][0][0] = 1;\n\n  auto f = [](int k, int l, int m) -> int {\n    if ( k == 4                ) return 4;\n    if ( k == 3       && m == 3) return 4;\n    if ( k == 2                ) return 3;\n    if ((k == 1 || l) && m == 1) return 2;\n    if (                 m == 5) return 1;\n    return 0;\n  };\n\n  rep(i, n) rep(j, 2) rep(k, 5) rep(l, 2) rep(m, (j ? 9 : s[i]) + 1) {\n    dp[i + 1][j || m < s[i]][f(k, l, m)][k == 2 && m == 5] += dp[i][j][k][l];\n  }\n\n  cout << dp[n][0][4][0] + dp[n][1][4][0] << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Int{\npublic:\n  string val;\n  Int():val(\"0\"){}\n  Int(string num,bool reversed=0){if(!reversed)R(num); val = num;}\n  Int(int num){val = to_string(num); R(val);}\n  \n  void R(string &a){reverse(a.begin(),a.end());}\n  bool neg(const string &a)const{return a.back() == '-';}\n  char& operator [] (int i){assert(i<(int)val.size());return val[i];}\n\n  bool operator ==  (Int b) {R(b.val); return *this == b.val;}\n  bool operator ==  (string b) {R(b);return val == b;}\n  template<class T> bool operator == (T b){return *this == Int(b);}\n  \n  bool operator !=  (Int b) {R(b.val); return *this != b.val;}\n  bool operator !=  (string b) {R(b);return !(val == b);}\n  template<class T> bool operator != (T b){return *this != Int(b);}\n  \n  bool operator >=  (Int b) {R(b.val); return *this >= b.val;}\n  bool operator >=  (string b) {return !(*this < b);}\n  template<class T> bool operator >= (T b){return *this >= Int(b);}\n\n  bool operator >   (Int b) {R(b.val); return *this > b.val;}\n  bool operator >   (string b) {return *this>=b && *this != b;}\n  template<class T> bool operator > (T b){return *this > Int(b);}\n\n  bool operator <=  (Int b) {R(b.val); return *this <= b.val;}\n  bool operator <=  (string b) {return *this<b || *this == b;}\n  template<class T> bool operator <= (T b){return *this <= Int(b);}\n\n  bool operator <   (Int b) {R(b.val); return *this < b.val;}\n  template<class T> bool operator < (T b){return *this < Int(b);}\n \n   bool operator <   (string b) {\n    R(b);\n    const string &a = val;\n    if(neg(a) != neg(b)) return neg(a)? 1:0;\n    if(a.size() != b.size()) return !neg(a)? (a.size()<b.size()):(a.size()>b.size());\n    for(int i=a.size()-1;i>=0;i--)if(a[i] != b[i]) return !neg(a)? a[i] < b[i]: a[i] > b[i];\n    return 0;\n  }\n  \n  Int operator + (string b){\n    R(b);\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(Int(a,1) < Int(b,1)) swap(a,b),swap(fa,fb);\n    \n    if(fa == fb){\n      a += '0';\n      for(int i=0;i<(int)a.size()-1;i++){\n        if(i < (int)b.size()) a[i] += b[i]-'0';\n        a[i+1] += (a[i]-'0')/10;\n        a[i] = (a[i]-'0')%10 + '0';\n      }\n      if(a.size() > 1 && a.back() == '0') a.pop_back();\n      if((int)a.size() > 1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    else {\n      for(int i=0;i<(int)a.size();i++){\n        if(i < (int)b.size()) a[i] -= b[i]-'0';\n        if(a[i]-'0' < 0) a[i]+=10, a[i+1]--; \n      }\n      while((int)a.size()>1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    return Int(a,1);\n  }\n\n  Int operator * (string b){\n    R(b);\n    vector<int> res;\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(a.size() < b.size()) swap(a,b), swap(fa,fb);\n    if(a == \"0\" || b == \"0\") return Int(\"0\");\n    \n    for(int j=0;j<(int)b.size();j++)\n      for(int i=0;i<(int)a.size();i++){\n        if(i+j >= (int)res.size()) res.push_back(0);\n        res[i+j] += (a[i]-'0') * (b[j]-'0');\n      }\n    for(int i=0; i <(int)res.size(); i++) {\n      if(res[i]/10 == 0) continue;\n      if(i + 1 >= (int)res.size()) res.push_back(0);\n      res[i+1] += res[i]/10, res[i]=res[i]%10;\n    }\n    string sres;\n    for(int i:res) sres += char(i + '0');\n    if(fa != fb) sres += '-';\n    return Int(sres,1);\n  }\n\n  Int div(string b,int flg){\n    assert(b != \"0\");\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = b[0]=='-'? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(b[0]=='-') b.erase(b.begin());\n    Int mod(\"0\");\n    string d=\"0\";\n    for(int i=(int)a.size()-1;i>=0;i--){\n      mod = mod * 10 + (a[i] - '0');\n      while(mod >= b) mod -= b, d.back()+=1;\n      if(i && d != \"0\") d += '0'; \n    }\n    if(flg == 0 && d != \"0\" && (fa != fb)) d = \"-\" + d;\n    if(flg == 1 && mod != \"0\" && (fa == \"-\")) mod *= -1;\n    return flg==0? d:mod;\n  }\n  \n  Int operator + (Int b){R(b.val); return *this + b.val;}\n  template<class T> Int operator + (T b){return *this + Int(b);}\n  \n  Int operator * (Int b){R(b.val); return *this * b.val;}\n  template<class T> Int operator * (T b){return *this * Int(b);}\n\n  Int operator - (string b){b = (b[0] == '-')? b.substr(1):\"-\" + b;return *this + b;}\n  Int operator - (Int b){R(b.val); return *this - b.val;} \n  template<class T> Int operator - (T b){return *this - Int(b);}\n  \n  Int operator / (string b){return div(b,0);}\n  Int operator / (Int b){R(b.val);return div(b.val,0);}\n  template<class T> Int operator / (T b){return *this / Int(b);}\n  \n  Int operator % (string b){return div(b,1);}\n  Int operator % (Int b){R(b.val);return div(b.val,1);}\n  template<class T> Int operator % (T b){return *this % Int(b);}\n  \n  Int operator += (Int b){return *this = *this+b;}\n  Int operator += (string b){return *this = *this+b;}\n  template<class T> Int operator += (T b){return *this += Int(b);}\n  \n  Int operator -= (Int b){return *this = *this-b;}\n  Int operator -= (string b){return *this = *this-b;}\n  template<class T> Int operator -= (T b){return *this -= Int(b);}\n  \n  Int operator *= (Int b){return *this = *this*b;}\n  Int operator *= (string b){return *this = *this*b;}\n  template<class T> Int operator *= (T b){return *this *= Int(b);}\n  \n  Int operator /= (string b){return *this = *this/b;}\n  Int operator /= (Int b){return *this = *this/b;}\n  template<class T> Int operator /= (T b){return *this /= Int(b);}\n  \n  Int operator %= (string b){return *this = *this % b;}\n  Int operator %= (Int b){return *this=*this%b;}\n  template<class T> Int operator %= (T b){return *this %= Int(b);}\n  \n  Int operator ++(){return *this += 1;}\n  Int operator --(){return *this -= 1;}\n\n#ifdef int\n#undef int\n#define eraseIntDefine\n#endif\n  Int operator ++(int){\n    Int tmp = *this;\n    *this += 1;\n    return tmp;\n  }\n  \n  Int operator --(int){\n    Int tmp = *this;\n    *this -= 1;\n    return tmp;\n  }\n#ifdef eraseIntDefine\n#define int long long\n#endif\n\n  friend ostream& operator << (ostream& os,const Int a){\n    for(int i=(int)a.val.size()-1;i>=0;i--) os<<a.val[i];\n    return os;\n  }\n\n  friend istream& operator >> (istream& is,Int &a){\n    string num;\n    is>>num;\n    a = Int(num);\n    return is;\n  }\n  friend string to_string(Int a){reverse(a.val.begin(),a.val.end());return a.val;}\n};\n\n\nstring str;\nstring num = \"51?3\";\n\nInt mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nInt dfs(int pos,int less,int cnt,string s,int target){\n  cnt = min(1LL,cnt);\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt != 0;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  Int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  cout<<dfs(0,0,0,\"\",0)<<endl;\n  Int sum[10]={};\n  for(int i=0;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n\n  Int a = stoi(str);\n  Int ans(0);\n  for(int i=1;i<5;i++) ans += Int(i%2? 1:-1) * sum[i];\n  //cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[20][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[20][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; ++i)\ntypedef long long ll;\n\nbool gochi(int k, int d) { return (k / 10 == 51) && d == 3; }\n\nll dp[20][2][1005][2];\nint main() {\n  string N;\n  cin >> N;\n  int len = N.size();\n  dp[0][0][0][0] = 1;\n  rep(i, len) rep(j, 2) rep(k, 1000) rep(l, 2) {\n    int x = j ? 9 : N[i] - '0';\n    rep(d, x + 1) dp[i + 1][j || d < x][k % 100 * 10 + d][l || gochi(k, d)] +=\n        dp[i][j][k][l];\n  }\n  ll ans = 0;\n  rep(j, 2) rep(k, 1000) ans += dp[len][j][k][1];\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tpa2 operator * (int a) {return pa2(x*a,y*a);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n             /*               \n            int pr[1000010];\n            int inv[1000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<=ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n           \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n            */ \n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n\nint dp[20][6][2]={0};\n \nsigned main(){\nstring s;\n\tcin>>s;\n\t\n\tint l=s.length();\n\t\n\tfor(char i='0';i<=s[0];i++){\n\t\tif(i!='5' && i<s[0])dp[0][0][0]++;\n\t\tif(i=='5' && i<s[0])dp[0][1][0]++;\n\t\tif(i!='5' && i==s[0])dp[0][0][1]++;\n\t\tif(i=='5' && i==s[0])dp[0][1][1]++;\n\t}\n\t\n\tfor(int i=0;i<l-1;i++){\n\t\n\t\tfor(int j=0;j<10;j++)if(j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][0][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][0][0];\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=1 && j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][1][0];\n\t\t}\n\t\tdp[i+1][2][0]+=dp[i][1][0];\n\t\tdp[i+1][1][0]+=dp[i][1][0];\n\t\t\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(j!=5)\tdp[i+1][3][0]+=dp[i][2][0];\n\t\t\telse dp[i+1][5][0]+=dp[i][2][0];\n\t\t}\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=3&&j!=5){\n\t\tdp[i+1][0][0]+=dp[i][3][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][3][0];\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=3&&j!=5){\n\t\t\tif(j!=1)dp[i+1][0][0]+=dp[i][5][0];\n\t\t\telse dp[i+1][2][0]+=dp[i][5][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][5][0];\n\t\t\n\t\tint h=s[i+1]-'0';\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][0][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][0][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=1 && j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][1][1];\n\t\t}\n\t\tif(h>1)dp[i+1][2][0]+=dp[i][1][1];\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][1][1];\n\t\t\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=5){\n\t\t\tdp[i+1][3][0]+=dp[i][2][1];\n\t\t}\n\t\tif(h>5) dp[i+1][5][0]+=dp[i][2][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=3 && j!=5){\n\t\tdp[i+1][0][0]+=dp[i][3][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][3][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=3 &&j!=5){\n\t\t\tif(j!=1)dp[i+1][0][0]+=dp[i][5][1];\n\t\t\telse dp[i+1][2][0]+=dp[i][5][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][5][1];\n\t\t\n\t\tif(h==5){\n\t\tdp[i+1][1][1]+=dp[i][0][1];\n\t\tdp[i+1][1][1]+=dp[i][1][1];\t\n\t\tdp[i+1][5][1]+=dp[i][2][1];\n\t\tdp[i+1][1][1]+=dp[i][3][1];\n\t\tdp[i+1][1][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t\telse if(h==1){\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][2][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t\tdp[i+1][0][1]+=dp[i][3][1];\n\t\tdp[i+1][2][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t\telse if(h==3){\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][0][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t//\tdp[i+1][0][1]+=dp[i][3][1];\n\t\t}\n\t\telse{\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][0][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t\tdp[i+1][0][1]+=dp[i][3][1];\n\t\tdp[i+1][0][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t}\n\tint n=stoi(s);\n\tint ans=0;\n\tfor(int i=0;i<6;i++)for(int j=0;j<2;j++)ans+=dp[l-1][i][j];\n\tcout<<n-ans+1<<endl;\n\t\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll dp[20][10000][2][2];\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%10000;\n}\n\nbool is_OK(ll number){\n\tif((number/1000)%10 != 5)return false;\n\tif(number-5000 <= 99 || number-500 >= 200)return false;\n\tif(number%10 != 3)return false;\n\treturn true;\n}\n\nll recursive(ll pre_num,ll digit,Type type,bool is_completed){\n\n\tif(digit == length){\n\t\tif(is_completed)return 1;\n\t\telse{\n\t\t\treturn 0; //G数が成立しないならreturn 0;\n\t\t}\n\t}\n\n\tif(dp[digit][pre_num][type][is_completed] != -1){\n\t\treturn dp[digit][pre_num][type][is_completed]; //計算済ならreturn\n\t}\n\n\tif(is_completed == true && type == ELSE){\n\t\treturn dp[digit][pre_num][type][is_completed] = POW[length-digit];\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tll tmp;\n\n\tfor(int next = 0; next <= limit; next++){\n\t\ttmp =  getNUM(pre_num,next);\n\t\tret += recursive(tmp,digit+1,ELSE,is_completed||is_OK(tmp));\n\t}\n\n\tif(type == FULL_MATCH){\n\t\ttmp = getNUM(pre_num,num_array[digit]);\n\t\tret += recursive(tmp,digit+1,FULL_MATCH,is_completed||is_OK(tmp));\n\t}\n\n\treturn dp[digit][pre_num][type][is_completed] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9999; pre_num++){\n\t\t\tfor(int p = 0; p <= 1; p++){\n\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\tdp[digit][pre_num][p][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,false));\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\n\n// [pos][i - 3][i - 2][i - 1][already ok][strictly less]\nll dp[20][10][10][10][2][2];\n\nll solve(ll n) {\n\tdp[0][0][0][0][0][0] = 1;\n\tconst auto s = to_string(n);\n\tconst int m = s.size();\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int i3 = 0; i3 <= 9; ++i3) for (int i2 = 0; i2 <= 9; ++i2) for (int i1 = 0; i1 <= 9; ++i1) {\n\t\t\tfor (int aok = 0; aok <= 1; aok++) {\n\t\t\t\tfor (int le = 0; le <= 1; ++le) {\n\t\t\t\t\tconst int lim = le ? 9 : s[i] - '0';\n\t\t\t\t\tfor (int add = 0; add <= lim; ++add) {\n\t\t\t\t\t\tint nok = aok || (i3 == 5 && i2 == 1 && add == 3);\n\t\t\t\t\t\tint nle = le || s[i] - '0' > add;\n\t\t\t\t\t\tdp[i + 1][i2][i1][add][nok][nle] += dp[i][i3][i2][i1][aok][le];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i <= 9; ++i) {\n\t\tfor (int j = 0; j <= 9; ++j) {\n\t\t\tfor (int k = 0; k <= 9; ++k) {\n\t\t\t\tans += dp[m][i][j][k][1][0] + dp[m][i][j][k][1][1];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\tcout << solve(N) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n/*\n<url:https://onlinejudge.u-aizu.ac.jp/services/room.html#RitsCamp18Day1/problems/F>\n問題文============================================================\n\n ごちうさが大好きなAORイカちゃんは「ごちうさ数」を定義した。\n ごちうさ数とは、 10 進表記において「 51?3 」を含む自然数のことである。\n ? は 0 〜 9 のどの数字であってもよい。\n \n N 以下の自然数のうち、ごちうさ数の個数を求めよ。\n \n=================================================================\n\n解説=============================================================\n\n================================================================\n*/\n\nstring S;\n// dp[i桁目][下3桁][超えうるか][出現済]\nll dp[20][1000][2][2];\nll rec(int idx,int thdigit,bool tight = true,bool ok = false){\n    if(idx == S.length()) return ok;\n    ll& ret = dp[idx][thdigit][tight][ok];\n    if(~ret) return ret;\n    ret = 0;\n    int x = S[idx] - '0';\n    int r = (tight?x:9);\n    for(int i = 0; i <= r; i++){\n        int next_thdigit = (10*thdigit+i)%1000;\n        ret += rec(idx+1,next_thdigit,(tight?!(i<r):tight),ok||((thdigit/10)==51 && i == 3));\n    }\n    return ret;\n}\nint main(void) {\n\tcin.tie(0); ios::sync_with_stdio(false);\n    cin >> S;\n    fill(***dp,***dp + 20*1000*2*2,-1);\n    cout << rec(0,0) << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long dp[20][5][2] = {};\n\nint main() {\n    string s;\n    cin >> s;\n    int g[4] = { 5, 1, -1, 3 };\n    int n = s.size();\n    dp[0][0][1] = 1;\n    for (int i = 0; i < n + 1; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            for (int k = 0; k < 4; ++k) {\n                int f = 1;\n                if (j == g[k] || k == 2) {\n                    f = 0;\n                    dp[i + 1][k + 1][0] += dp[i][k][0];\n                }\n                if (j != g[k] && j == g[0]) {\n                    f = 0;\n                    dp[i + 1][1][0] += dp[i][k][0];\n                }\n                if (f)\n                    dp[i + 1][0][0] += dp[i][k][0];\n            }\n            dp[i + 1][4][0] += dp[i][4][0];\n        }\n        for (int j = 0; j < s[i] - '0'; ++j) {\n            for (int k = 0; k < 4; ++k) {\n                int f = 1;\n                if (j == g[k] || k == 2) {\n                    f = 0;\n                    dp[i + 1][k + 1][0] += dp[i][k][1];\n                }\n                if (j != g[k] && j == g[0]) {\n                    f = 0;\n                    dp[i + 1][1][0] += dp[i][k][1];\n                }\n                if (f)\n                    dp[i + 1][0][0] += dp[i][k][1];\n            }\n            dp[i + 1][4][0] += dp[i][4][1];\n        }\n        for (int j = s[i] - '0'; j <= s[i] - '0'; ++j) {\n            for (int k = 0; k < 4; ++k) {\n                int f = 1;\n                if (j == g[k] || k == 2) {\n                    f = 0;\n                    dp[i + 1][k + 1][1] += dp[i][k][1];\n                }\n                if (j != g[k] && j == g[0]) {\n                    f = 0;\n                    dp[i + 1][1][1] += dp[i][k][1];\n                }\n                if (f)\n                    dp[i + 1][0][1] += dp[i][k][1];\n            }\n            dp[i + 1][4][1] += dp[i][4][1];\n        }\n    }\n    cout << dp[n][4][0] + dp[n][4][1] << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstring N;\nint rec(int i, bool less, int state) {\n    if (i == SZ(N)) {\n        return (state == 4);\n    }\n\n    int ret = 0;\n    if (less) {\n        REP(j, 10) {\n            int next_state = state;\n            if (state == 0 && j == 5) next_state++;\n            else if (state == 1 && j == 1) next_state++;\n            else if (state == 2 && j == 5) next_state = 10;\n            else if (state == 2 && j != 5) next_state = 11;\n            else if ((state == 10 || state == 11) && j == 3) next_state = 4;\n            else if (state == 4);\n            else {\n                if (state == 10 && j == 1) {\n                    next_state = 2;\n                } else if (j == 5) {\n                    next_state = 1;\n                } else {\n                    next_state = 0;\n                }\n            }\n            ret += rec(i+1, true, next_state);\n        }\n    } else {\n        REP(j, N[i]-'0'+1) {\n            int next_state = state;\n            if (state == 0 && j == 5) next_state++;\n            else if (state == 1 && j == 1) next_state++;\n            else if (state == 2 && j == 5) next_state = 10;\n            else if (state == 2 && j != 5) next_state = 11;\n            else if ((state == 10 || state == 11) && j == 3) next_state = 4;\n            else if (state == 4);\n            else {\n                if (state == 10 && j == 1) {\n                    next_state = 2;\n                } else if (j == 5) {\n                    next_state = 1;\n                } else {\n                    next_state = 0;\n                }\n            }\n            ret += rec(i+1, j!=(N[i]-'0'), next_state);\n        }\n    }\n    return ret;\n}\nsigned main() {\n    cin >> N;\n    cout << rec(0, 0, 0) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2];\nll dp[18][10][5][2];\n\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){\n\n\t\treturn memo[digit-1][type];\n\t}\n\n\tif(digit == length)return 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type];\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(next,digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(next,digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(next,digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){\n\t\t\t\t\t\tret += recursive(next,digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){\n\t\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\tll tmp = N;\n\n\twhile(tmp > 0){\n\t\tS.push(tmp%10);\n\t\ttmp /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1;\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\nll dp[18][10][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(next,digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(next,digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(next,digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(next,digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,3);\n\t\t\t//printf(\"FULL digit:%d next:%d マッチ3 ret:%lld\\n\",digit,num_array[digit],ret);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)   FOR(i,0,n)\n#define pb emplace_back\ntypedef long long ll;\ntypedef pair<int,int> pint;\n\nll dp[19][10000][2][2];\nbool ck(int c){\n    if(c/1000==5&&c/100%10==1&&c%10==3) return true;\n    return false;\n}\nint main(){\n    string s;\n    cin>>s;\n    int n=s.size();\n    dp[0][0][0][0]=1;\n    rep(i,n)rep(j,10000)rep(k,2)rep(l,2){\n        int ulim=l?9:s[i]-'0';\n        rep(p,ulim+1){\n            dp[i+1][(j*10+p)%10000][k||ck((j*10+p)%10000)][l||p<ulim]+=dp[i][j][k][l];\n        }\n    }\n    ll ans=0;\n    rep(i,10000)rep(k,2) ans+=dp[n][i][1][k];\n    cout<<ans<<endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll mypow(ll a,ll b){\n  ll res=1;\n  for(ll i=0;i<b;i++)\n    res*=a;\n  return res;\n}\n\nstring s;\nint len;\nll dp[20][10][10][10][2];\n\nll rec(int d,int x,int y,int z,int f){\n  if( d== len )return 0;\n\n  if( dp[d][x][y][z][f]!=-1 )return dp[d][x][y][z][f];\n  \n  int left=0,right=9;\n  if(f)right=s[d]-'0';\n\n  ll res=0;\n  for(ll i=left;i<=right;i++){\n    int nf=f;\n    if(i < right)nf=0;\n    if( x==5 && y==1 && i==3 ){\n      ll last=len-d-1;\n      res+= mypow(10,last);\n    }else{\n      res+=rec(d+1,y,z,i,nf);\n    }\n  }\n  \n  return dp[d][x][y][z][f]=res;\n}\n\nint main(){\n  memset(dp,-1,sizeof(dp));\n  \n  cin>>s;\n  len=s.size();\n  cout<< rec(0,0,0,0,1) <<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1e18 : 1e9;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nstring n;\nint dp[19][2][1000][2];\n\nint rec(int k = 0, bool tight = true, int uesan = 0, bool flag = false) {\n\tif (k == n.size()) {\n\t\treturn flag;\n\t}\n\n\tif (dp[k][tight][uesan][flag] != -1) {\n\t\treturn dp[k][tight][uesan][flag];\n\t}\n\n\tint x = n[k] - '0';\n\tint r = (tight ? x : 9);\n\tint res = 0;\n\trep (i, r + 1) {\n\t\tint one = uesan / 100,\n\t\t\t\ttwo = uesan % 100 / 10,\n\t\t\t\tthr = uesan % 10,\n\t\t\t\tfou = i;\n\t\tres += rec(k + 1, tight && i == r, two * 100 + thr * 10 + fou, flag || one == 5 && two == 1 && fou == 3);\n\t}\n\treturn dp[k][tight][uesan][flag] = res;\n}\n\nsigned main() {\n\tcin >> n;\n\tmemset(dp, -1, sizeof(dp));\n\tcout << rec() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst int DEBUG=0;\n\nconst int A=18;\n\nbool inc(vi &a,int lim){\n  int i=0;\n  while(i<(int)a.size()){\n    a[i]++;\n    if(a[i]<lim)return true;\n    a[i]-=lim;\n    i++;\n  }\n  return false;\n}\n\nlint p10[A];\n\nbool match(lint n,lint pat,lint msk){\n  while(msk>0){\n    if(msk%10!=0){\n      if(n%10!=pat%10)return false;\n    }\n    msk/=10;\n    n/=10;\n    pat/=10;\n  }\n  return true;\n}\n\nlint calc(lint n,const vi &t){\n  int m=t.size();\n  rep(i,m-1){\n    if(t[i]+4>t[i+1])return 0;\n  }\n  if(t[m-1]>A-4)return 0;\n  lint pat=0,msk=0;\n  rep(i,m){\n    pat+=5103*p10[t[i]];\n    msk+=1101*p10[t[i]];\n  }\n  lint ans=0;\n  lint cur=1;\n  n++;\n  while(n>0){\n    if(msk%10==0){\n      if(match(n/10,pat/10,msk/10))ans+=cur*(n%10);\n      n/=10;\n      pat/=10;\n      msk/=10;\n      cur*=10;\n      continue;\n    }\n    if(match(n/10,pat/10,msk/10)&&n%10>pat%10)ans+=cur;\n    n/=10;\n    pat/=10;\n    msk/=10;\n  }\n  if(DEBUG&&ans!=0){\n    cerr<<\"t=\";\n    rep(i,m)cerr<<\" \"<<t[i];\n    cerr<<endl;\n    cerr<<\"ret=\"<<ans<<endl;\n  }\n  return ans;\n}\n\nint main(){\n  rep(i,A){\n    if(i==0)p10[i]=1;\n    else p10[i]=10*p10[i-1];\n  }\n  lint n;\n  cin>>n;\n  lint ans=0;\n  rep(i,5){\n    if(i==0)continue;\n    vi t(i,0);\n    do{\n      ans+=(i%2==0?-1:1)*calc(n,t);\n    }while(inc(t,A));\n  }\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring N;\n\nint64_t dp[20][1000][2][2];\n\nint64_t rec(int idx = 0, int pre = 0, bool tight = true, bool gochiusa = false) {\n  if (idx == N.size()) {\n    return gochiusa;\n  }\n\n  int64_t &res = dp[idx][pre][tight][gochiusa];\n  if (~res) return res;\n  res = 0;\n\n  int x = N[idx] - '0';\n  int r = (tight ? x : 9);\n  for (int i = 0; i <= r; ++i) {\n    int now = 10 * pre + i;\n    res += rec(idx + 1, now % 1000, tight && i == r, gochiusa || (i == 3 && pre / 10 == 51));\n  }\n\n  return res;\n}\n\nint main() {\n  memset(dp, -1, sizeof(dp));\n  cin >> N;\n\n  cout << rec() << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\n\nchar s[25];\nll dp[25][2][2][4];\n\nint main(){\n  scanf(\"%s\",s);\n  int n = strlen(s);\n  dp[0][0][0][0] = 1;\n  REP(keta,n)REP(gochiusa,2)REP(less,2)REP(state,4){\n    int c = s[keta]-'0';\n    REP(d,10){\n      if(!less && (d>c))continue;\n      int nless = less || (d<c);\n      int nstate = 0;\n      if(state==0 && d==5)nstate = 1;\n      if(state==1 && d==1)nstate = 2;\n      if(state==2)nstate = 3;\n      if(state==3 && d==3)nstate = 4;\n      int ngo = gochiusa || (nstate==4);\n      nstate %= 4;\n      if(nstate==0 && d==5)nstate = 1;\n      dp[keta+1][ngo][nless][nstate] += dp[keta][gochiusa][less][state];\n    }\n  }\n  ll ans = 0;\n  REP(less,2)REP(state,4)ans += dp[n][1][less][state];\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2];\nll dp[18][5][2];\n\nll recursive(ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){\n\t\treturn memo[digit-1][type];\n\t}\n\n\tif(digit == length)return 0;\n\n\tif(dp[digit][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pattern_match_num][type];\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(digit+1,ELSE,4);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1;\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][match_num][p] = -1;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll dp[20][2][10][10][10],z;\n\nll Stoi(string s){\n  ll res=0;\n  for(ll i=0;i<(int)s.size();i++)res=res*10+s[i]-'0';\n  return res;\n}\n\nll Pow(ll a,ll b){\n  ll res=1;\n  while(b--)res*=a;\n  return res;\n}\n\nstring n;\n\nll dfs(ll id,ll f,ll a,ll b,ll c){\n  if(dp[id][f][a][b][c]!=-1)return dp[id][f][a][b][c];\n  if(id==(int)n.size())return 0;\n  ll r=9,res=0;\n  if(!f)r=n[id]-'0';\n  for(ll d=0;d<=r;d++){\n    ll nf=f;\n    if(d<r)nf=1;\n    if(a==5&&b==1&&d==3){\n      if(nf) res+=Pow(10,n.size()-id-1);\n      else res+=Stoi(n.substr(id+1))+1;\n    }\n    else{\n      res+=dfs(id+1,nf,b,c,d);\n    }\n  }\n  return dp[id][f][a][b][c]=res;\n}\n\nint main(){\n  cin>>n;\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\nll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%1000;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\t//printf(\"FULL digit:%d next:%d マッチ3 ret:%lld\\n\",digit,num_array[digit],ret);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll mypow(ll a,ll b){\n  ll res=1;\n  for(ll i=0;i<b;i++)\n    res*=a;\n  return res;\n}\n\nstring s;\nint len;\nll dp[20][10][10][10][2];\n\nll rec(int d,int x,int y,int z,int f){\n  if( d== len )return 0;\n\n  if( dp[d][x][y][z][f]!=-1 )return dp[d][x][y][z][f];\n  \n  int left=0,right=9;\n  if(f)right=s[d]-'0';\n\n  ll res=0;\n  for(ll i=left;i<=right;i++){\n    int nf=f;\n    if(i < right)nf=0;\n    if( x==5 && y==1 && i==3 ){\n      ll last=len-d-1;\n      if(f==1){\n        ll num=0;\n        for(int j=d+1;j<len;j++)num=num*10LL + ( s[j]-'0');\n        res+=(num+1);\n      }else{\n        res+= mypow(10,last);\n      }\n    }else{\n      res+=rec(d+1,y,z,i,nf);\n    }\n  }\n  \n  return dp[d][x][y][z][f]=res;\n}\n\nint main(){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<10;j++)\n      for(int k=0;k<10;k++)\n        for(int l=0;l<10;l++)\n          for(int m=0;m<2;m++)\n            dp[i][j][k][l][m]=-1;\n  \n  cin>>s;\n  len=s.size();\n  cout<< rec(0,0,0,0,1) <<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nll dp[20][6][2];\n\nint main() {\n    ll s = lin();\n\n    ll tmp = s;\n    VI a;\n    while (tmp){\n        a.push_back(tmp % 10);\n        tmp /= 10;\n    }\n    reverse(ALL(a));\n    int n = a.size();\n\n    dp[0][0][0] = 1;\n    REP(i,n) REP(j,5) REP(f,2){\n        int lim = f ? 9 : a[i];\n        REP(k,lim+1){\n            int c = 0;\n            if (j == 0 && k == 5) c = 1;\n            if (j == 1 && k == 1) c = 2;\n            if (j == 1 && k == 5) c = 1;\n            if (j == 2) c = 3;\n            if (j == 2 && k == 5) c = 4;\n            if (j == 3 && k == 3) c = 5;\n            if (j == 3 && k == 5) c = 1;\n            if (j == 4 && k == 3) c = 5;\n            if (j == 4 && k == 1) c = 2;\n            if (j == 4 && k == 5) c = 1;\n            if (j == 5) c = 5;\n            dp[i+1][c][f | (k < a[i])] += dp[i][j][f];\n        }\n    }\n\n    // REP(j,5){\n    //     FOR(i,1,n) cout << dp[i][j][1] << \" \";\n    //     cout << endl;\n    // }\n\n    ll sum = 0;\n    REP(j,5) REP(f,2) sum += dp[n][j][f];\n    cout << s - sum + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1e18 : 1e9;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\n\nstring n;\nint dp[20][2][1000][2];\n\nint rec(int k = 0, bool tight = true, int uesan = 0, bool flag = false) {\n\tif (k == n.size()) {\n\t\treturn flag;\n\t}\n\n\tif (dp[k][tight][uesan][flag] != -1) {\n\t\treturn dp[k][tight][uesan][flag];\n\t}\n\n\tint x = n[k] - '0';\n\tint r = (tight ? x : 9);\n\tint res = 0;\n\trep (i, r + 1) {\n\t\tint one = uesan / 100,\n\t\t\t\ttwo = uesan % 100 / 10,\n\t\t\t\tthr = uesan % 10,\n\t\t\t\tfou = i;\n\t\tres += rec(k + 1, tight && i == r, two * 100 + thr * 10 + fou, flag || one == 5 && two == 1 && fou == 3);\n\t}\n\treturn dp[k][tight][uesan][flag] = res;\n}\n\nsigned main() {\n\tcin >> n;\n\tmemset(dp, -1, sizeof(dp));\n\tcout << rec() << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n#ifdef _DEBUG\n#include \"dump.hpp\"\n#else\n#define dump(...)\n#endif\n\n#define int long long\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(c) begin(c),end(c)\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9) + 7;\ntemplate<class T> bool chmax(T &a, const T &b) { if (a < b) { a = b; return true; } return false; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (b < a) { a = b; return true; } return false; }\n\n//N以下のごちうさ数\nvoid gotiusa() {\n\t//i桁目\n\t//N未満確定か\n\t//前5\n\t//前51\n\t//前51?\n\t//51?3を含む\n\tint dp[20][2][2][2][2][2] = {};\n\tstring S; cin >> S;\n\tdp[0][0][0][0][0][0] = 1;\n\trep(i, 0, S.size()) rep(j, 0, 2) rep(k, 0, 2) rep(p, 0, 2)rep(q, 0, 2)rep(r, 0, 2) {\n\t\tint lim = j ? 9 : S[i] - '0';\n\t\t//dump(i, j, k, p, q, r, dp[i][j][k][p][q][r]);\n\t\trep(d, 0, lim + 1) {\n\t\t\tdp[i + 1][j || d < lim][d == 5][k && d == 1][p][(q&&d == 3) || r] += dp[i][j][k][p][q][r];\n\t\t\t//dump(i + 1, j || d < lim, d == 5, k && d == 1, p, (q&&d == 3) || r);\n\t\t\t//dump(dp[i + 1][j || d < lim][d == 5][k && d == 1][p][(q&&d == 3) || r]);\n\t\t}\n\t}\n\tint ans = 0;\n\trep(j, 0, 2)rep(k, 0, 2)rep(p, 0, 2)rep(q, 0, 2)ans += dp[S.size()][j][k][p][q][1];\n\tcout << ans << endl;\n}\n\nsigned main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tgotiusa();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nstring N;\nLL dp[20][1 << 4][2];\n\nint change(int state, int d) {\n\tint nxt = 0;\n\tfor (int b = 0; b < 5; ++b) {\n\t\tif (state & (1 << b)) {\n\t\t\t/*if (b == 0 && d == 5) {\n\t\t\t\tnxt |= (1 << 1);\n\t\t\t}\n\t\t\tif (b == 1 && d == 1) {\n\t\t\t\tnxt |= (1 << 2);\n\t\t\t}\n\t\t\tif (b == 2) {\n\t\t\t\tnxt |= (1 << 3);\n\t\t\t}\n\t\t\tif (b == 3 && d == 3) {\n\t\t\t\tnxt |= (1 << 4);\n\t\t\t}\n\t\t\tif (b == 4) {\n\t\t\t\tnxt |= (1 << 4);\n\t\t\t}*/\n\t\t}\n\t}\n\tif (d == 5) {\n\t\tnxt |= (1 << 0);\n\t}\n\telse if (d == 1) {\n\t\tif (state & (1 << 0)) {\n\t\t\tnxt |= (1 << 1);\n\t\t}\n\t}\n\telse if (d == 3) {\n\t\tif (state & (1 << 2)) {\n\t\t\tnxt |= (1 << 3);\n\t\t}\n\t}\n\telse {}\n\tif (state & (1 << 1)) {\n\t\tnxt |= (1 << 2);\n\t}\n\treturn nxt;\n}\n\nint main(void)\n{\n\tcin >> N;\n\tLL num = stoll(N);\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < N.size(); ++i) {\n\t\tfor (int j = 0; j < (1 << 3); ++j) {\n\t\t\t//dp[i][j][0]\n\t\t\t//set<int>ok, nx, tk;\n\t\t\tmap<int, LL>nextmap;\n\t\t\tfor (int d = 0; d < N[i] - '0'; ++d) {\n\t\t\t\tnextmap[change(j, d)]++;\n\t\t\t}\n\t\t\t//dp[i + 1][0][1] += dp[i][j][0] * (LL)ok.size();\n\t\t\t//dp[i + 1][1][1] += dp[i][j][0] * (LL)tk.size();\n\t\t\t//dp[i + 1][j + 1][1] += dp[i][j][0] * (LL)nx.size();\n\t\t\tfor (auto&p : nextmap) {\n\t\t\t\tdp[i + 1][p.first][1] += dp[i][j][0] * p.second;\n\t\t\t}\n\t\t\tnextmap.clear();\n\t\t\tfor (int d = N[i] - '0'; d == N[i] - '0'; ++d) {\n\t\t\t\tnextmap[change(j, d)]++;\n\t\t\t}\n\t\t\t//dp[i + 1][0][0] += dp[i][j][0] * (LL)ok.size();\n\t\t\t//dp[i + 1][1][0] += dp[i][j][0] * (LL)tk.size();\n\t\t\t//dp[i + 1][j + 1][0] += dp[i][j][0] * (LL)nx.size();\n\t\t\t//dp[i][j][1]\n\t\t\t//set<int>ok, nx;\n\t\t\tfor (auto&p : nextmap) {\n\t\t\t\tdp[i + 1][p.first][0] += dp[i][j][0] * p.second;\n\t\t\t}\n\t\t\tnextmap.clear();\n\t\t\tfor (int d = 0; d < 10; ++d) {\n\t\t\t\tnextmap[change(j, d)]++;\n\t\t\t}\n\t\t\t//dp[i + 1][0][1] += dp[i][j][1] * (LL)ok.size();\n\t\t\t//dp[i + 1][1][1] += dp[i][j][1] * (LL)tk.size();\n\t\t\t//dp[i + 1][j + 1][1] += dp[i][j][1] * (LL)nx.size();\n\t\t\tfor (auto&p : nextmap) {\n\t\t\t\tdp[i + 1][p.first][1] += dp[i][j][1] * p.second;\n\t\t\t}\n\t\t}\n\t}\n\tLL sum = 0;\n\tfor (int j = 0; j < (1 << 3); ++j) {\n\t\tsum += dp[N.size()][j][0] + dp[N.size()][j][1];\n\t}\n\tcout << num - sum + 1 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nstring str;\nstring num = \"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nint dfs(int pos,int less,int cnt,string s,int target){\n  if(pos == (int)str.size()) return cnt >= target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    if(ns.size() == 3 && i == 5) res += dfs(npos,nless,ncnt,\"5\",target);\n    res += dfs(npos,nless,ncnt,ns,target);\n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  int sum[10]={};\n  for(int i=0;i<5;i++) sum[i] = dfs(0,0,0,\"\",i);\n\n  int ans = 0;\n  for(int i=1;i<5;i++) ans += (i%2? 1:-1) * sum[i];\n  cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\n\nstring str;\nstring num = \"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nint dfs(int pos,int less,int cnt,string s,int target){\n  if(pos == (int)str.size()) return cnt >= target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  int sum[10]={};\n  for(int i=0;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n\n  int ans = 0;\n  for(int i=1;i<5;i++) ans += (i%2? 1:-1) * sum[i];\n  cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <array>\n#include <bitset>\n#include <assert.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef vector<VL> VVL;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint in() { int x; scanf(\"%d\", &x); return x; }\nll lin() { ll x; scanf(\"%lld\", &x); return x; }\n\nll dp[20][6][2];\n\nint main() {\n    ll s = lin();\n\n    ll tmp = s;\n    VI a;\n    while (tmp){\n        a.push_back(tmp % 10);\n        tmp /= 10;\n    }\n    reverse(ALL(a));\n    int n = a.size();\n\n    dp[0][0][0] = 1;\n    REP(i,n) REP(j,5) REP(f,2){\n        int lim = f ? 9 : a[i];\n        REP(k,lim+1){\n            int c = 0;\n            if (j == 0 && k == 5) c = 1;\n            if (j == 1 && k == 1) c = 2;\n            if (j == 1 && k == 5) c = 1;\n            if (j == 2) c = 3;\n            if (j == 2 && k == 5) c = 4;\n            if (j == 3 && k == 3) c = 5;\n            if (j == 3 && k == 5) c = 1;\n            if (j == 4 && k == 3) c = 5;\n            if (j == 4 && k == 1) c = 2;\n            if (j == 5) c = 5;\n            dp[i+1][c][f | (k < a[i])] += dp[i][j][f];\n        }\n    }\n\n    // REP(j,5){\n    //     FOR(i,1,n) cout << dp[i][j][1] << \" \";\n    //     cout << endl;\n    // }\n\n    ll sum = 0;\n    REP(j,5) REP(f,2) sum += dp[n][j][f];\n    cout << s - sum + 1 << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef VS\n#include<bits/stdc++.h>\n#endif\n\nusing namespace std;\ntypedef long long LL;\n\n#ifdef BTK\n#define DEBUG if(1)\n#else\n#define CIN_ONLY if(1)\nstruct cww {cww() {CIN_ONLY{ios::sync_with_stdio(false); cin.tie(0);}}\n}star;\n#define DEBUG if(0)\n#endif\n\n#define ALL(v) (v).begin(),(v).end()\n#define REC(ret, ...) std::function<ret (__VA_ARGS__)>\ntemplate <typename T>inline bool chmin(T &l, T r){bool a = l>r; if (a)l = r; return a;}\ntemplate <typename T>inline bool chmax(T &l, T r){bool a = l<r; if (a)l = r; return a;}\ntemplate <typename T>istream& operator>>(istream &is, vector<T> &v){for (auto &it : v)is >> it;return is;}\n\nclass range {private: struct I { int x; int operator*() { return x; }bool operator!=(I& lhs) { return x<lhs.x; }void operator++() { ++x; } }; I i, n;public:range(int n) :i({ 0 }), n({ n }) {}range(int i, int n) :i({ i }), n({ n }) {}I& begin() { return i; }I& end() { return n; }};\nconstexpr int MAX_LEN = 20;\n\nLL dp_N[MAX_LEN][5][10]; bool vis_N[MAX_LEN];\nLL dp_all[MAX_LEN][5][10]; bool vis_all[MAX_LEN];\nvoid f(int d);\nvoid g(int d);\n\nvector<int> in;\nvector<int> usa = {-1, 3,-1,1,5 };\nint len;\nvoid f(int d) {\n\tif (vis_N[d])return;\n\tvis_N[d] = true;\n\tfor (int i : range(5))for(int c:range(10))dp_N[d][i][c] = 0;\n\tif (d == 0) {\n\t\tdp_N[d][0][0] = 1;\n\t\treturn;\n\t}\n\tf(d - 1);g(d - 1);\n\t{ \n\t\tint i = 0;\n\t\tfor (int a : range(in[d - 1], in[d - 1] + 1)) {\n\t\t\tfor (int b : {1, 3, 4}) {\n\t\t\t\tif (usa[i] != a) {\n\t\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\t\tif (a != 3)dp_N[d][0][a] += dp_N[d-1][b - 1][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int a : range(in[d - 1])) {\n\t\t\tfor (int b : {1, 3, 4}) {\n\t\t\t\tif (usa[i] != a) {\n\t\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\t\tif (a != 3)dp_N[d][0][a] += dp_N[d-1][b - 1][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint i = 1;\n\t\tfor (int a : range(in[d - 1], in[d - 1] + 1)) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int j : {0, 2, 3}) {\n\t\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\t\tdp_N[d][i][a] += dp_N[d-1][j][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int a : range(0, in[d - 1])) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int j : {0, 2, 3}) {\n\t\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\t\tdp_N[d][i][a] += dp_N[d-1][j][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{   \n\t\tint  i = 2;\n\t\tfor (int a : range(in[d - 1], in[d - 1] + 1)) {\n\t\t\tfor (int c : range(10)) {\n\t\t\t\tdp_N[d][i][a] += dp_N[d-1][i - 1][c];\n\t\t\t}\n\t\t\tif (a != 1)dp_N[d][i][a] += dp_N[d-1][2][3];\n\t\t}\n\t\tfor (int a : range(in[d - 1])) {\n\t\t\tfor (int c : range(10)) {\n\t\t\t\tdp_N[d][i][a] += dp_all[d - 1][i - 1][c];\n\t\t\t}\n\t\t\tif (a != 1)dp_N[d][i][a] += dp_all[d - 1][2][3];\n\t\t}\n\n\t}\n\t{\n\t\tint i = 3;\n\t\tfor (int a : range(in[d - 1], in[d - 1] + 1)) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\tdp_N[d][i][a] += dp_N[d-1][i - 1][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor (int a : range(in[d - 1])) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\tdp_N[d][i][a] += dp_all[d - 1][i - 1][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\n\t{ \n\t\tint i = 4;\n\t\tfor (int a : range(in[d - 1], in[d - 1] + 1)) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\tdp_N[d][i][a] += dp_N[d-1][i - 1][c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int c : range(10)) {\n\t\t\t\tdp_N[d][i][a] += dp_N[d-1][i][c];\n\t\t\t}\n\t\t}\n\t\tfor (int a : range(in[d - 1])) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\tdp_N[d][i][a] += dp_all[d - 1][i - 1][c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int c : range(10)) {\n\t\t\t\tdp_N[d][i][a] += dp_all[d - 1][i][c];\n\t\t\t}\n\t\t}\n\n\t}\n}\nvoid g(int d) {\n\tif (vis_all[d])return;\n\tvis_all[d] = true;\n\tfor (int i : range(5))for (int c : range(10))dp_all[d][i][c] = 0;\n\tif (d == 0) {\n\t\tdp_all[d][0][0] = 1;\n\t\treturn;\n\t}\n\tf(d - 1); g(d - 1);\n\t{\n\t\tint i = 0;\n\t\tfor (int a : range(10)) {\n\t\t\tfor (int b : {1, 3, 4}) {\n\t\t\t\tif (usa[i] != a) {\n\t\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\t\tif (a != 3)dp_all[d][0][a] += dp_all[d - 1][b - 1][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint i = 1;\n\t\tfor (int a : range(10)) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int j : {0, 2, 3}) {\n\t\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\t\tdp_all[d][i][a] += dp_all[d - 1][j][c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t{\n\t\tint  i = 2;\n\t\tfor (int a : range(10)) {\n\t\t\tfor (int c : range(10)) {\n\t\t\t\tdp_all[d][i][a] += dp_all[d - 1][i - 1][c];\n\t\t\t}\n\t\t\tif (a != 1)dp_all[d][i][a] += dp_all[d - 1][2][3];\n\t\t}\n\t}\n\t{\n\t\tint i = 3;\n\t\tfor (int a : range(10)) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\tdp_all[d][i][a] += dp_all[d - 1][i - 1][c];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t{\n\t\tint i = 4;\n\t\tfor (int a : range(10)) {\n\t\t\tif (usa[i] == a) {\n\t\t\t\tfor (int c : range(10)) {\n\t\t\t\t\tdp_all[d][i][a] += dp_all[d - 1][i - 1][c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (int c : range(10)) {\n\t\t\t\tdp_all[d][i][a] += dp_all[d - 1][i][c];\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main() {\n\tstring s;\n\tcin >> s;\n\treverse(ALL(s));\n\tfor (auto &it : s)in.push_back(it - '0');\n\tlen = in.size();\n\tf(len);\n\tLL ret = 0;\n\tfor(int i:range(10))ret+=dp_N[len][4][i];\n\tcout << ret << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nstring s;\nint64 gochi[4] = {5, 1, -1, 3};\nint64 dp[20][2][5] = {};\n\nint64 dfs(int32 k = 0, bool tight = 1, int32 suc = 0){\n\tif(k == s.size()) return suc == 4;\n\tint32 lim = (tight ? s[k]+1 : 10);\n\tint64 &res = dp[k][tight][suc];\n\tif(~res) return res;\n\tres = 0;\n\tREP(i, lim){\n\t\tif(suc < 4 && (gochi[suc] == -1 || gochi[suc] == i)){\n\t\t\tif(suc == 2 && i == 5)\n\t\t\t\tres += dfs(k+1, tight && i== (lim-1), 1);\n\t\t\tres += dfs(k+1, tight && i == (lim-1), suc+1);\n\t\t}else if(suc == 4){\n\t\t\tres += dfs(k+1, tight && i == (lim-1), suc);\n\t\t}else{\n\t\t\tres += dfs(k+1, tight && i == (lim-1), gochi[0] == i);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tcin >> s;\n\tREP(i, s.size()) s[i] -= '0';\n\tmemset(dp, -1, sizeof dp);\n\tcout << dfs() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#include<unordered_set>\n#include<unordered_map>\n#include <algorithm> \n#include <iostream>\n#include <string>\n#include <cmath>\nusing namespace std;\n#define ll long long\n#define rep(i, n) for (ll i = 0; i < (n); i++)\n#define FOR(i,a,b) for(ll i=(a);i<(b);i++)\n#define FORR(i,a,b)for(ll i=(a);i<=(b);i++)\n#define repR(i,n) for(ll i=n;i>=0;i--)\n#define all(v)(v).begin(),(v).end()\n#define rall(v)(v).rbegin(),(v).rend()\n#define F first\n#define S second\n#define pb push_back\n#define pu push\n#define COUT(x) cout<<(x)<<endl\n#define PQ priority_queue<ll>\n#define PQR priority_queue<ll,vector<ll>,greater<ll>>\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n#define mp make_pair\n#define maxs(x,y) (x = max(x,y))\n#define mins(x,y) (x = min(x,y))\n#define sz(x) (ll)(x).size()\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll MOD = 1000000007LL;\nconst ll INF = 1LL << 60;\nusing vll = vector<ll>;\nusing vb = vector<bool>;\nusing vvb = vector<vb>;\nusing vvll = vector<vll>;\nusing vstr = vector<string>;\nusing pll = pair<ll, ll>;\nusing vc = vector<char>;\nusing vvc = vector<vc>;\ntemplate<class T> inline bool chmax(T& a, T b) { \nif (a < b) { a = b; return true; } return false; \n}\ntemplate<class T> inline bool chmin(T& a, T b) {\n if (a > b) { a = b; return true; } return false; \n }\nll dx[4]={0,1,0,-1};\nll dy[4]={1,0,-1,0};\nll dp[20][10000][2][2];\nbool ju(ll n){\n  if((n/100)!=51) return false;\n  if((n%10)!=3) return  false;\n  return true;\n}\nint main(){\n  string s;\n  cin>>s;\n  ll n=sz(s);\n  memset(dp,0,sizeof(dp));\n  dp[0][0][0][0]=1;\n  rep(i,n){\n    rep(j,10000)rep(k,10){\n      ll nj=(j%1000)*10+k;\n      {\n        dp[i+1][nj][1][1]+=dp[i][j][1][1];\n        if(ju(nj)){\n          dp[i+1][nj][1][1]+=dp[i][j][0][1];\n        }\n        else dp[i+1][nj][0][1]+=dp[i][j][0][1];\n      }\n      if(k<(s[i]-'0')){\n        dp[i+1][nj][1][1]+=dp[i][j][1][0];\n        if(ju(nj)) dp[i+1][nj][1][1]+=dp[i][j][0][0];\n        else dp[i+1][nj][0][1]+=dp[i][j][0][0];\n      }\n      if(k==(s[i]-'0')){\n        dp[i+1][nj][1][0]+=dp[i][j][1][0];\n        if(ju(nj)) dp[i+1][nj][1][0]+=dp[i][j][0][0];\n        else dp[i+1][nj][0][0]+=dp[i][j][0][0];\n      }\n    }\n  }\n  ll ans=0;\n  rep(i,10000){\n    ans+=dp[n][i][1][0]+dp[n][i][1][1];\n  }\n  COUT(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += pow(10,n - idx - 1);\n    else res += dfs(nidx,nless,b ,c ,i);\n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nint64 dp[20][4][2][2][10];\nstring S;\n\nint64 rec(int idx, int match, bool matched, bool lim, int pv) {\n  if(idx == S.size()) return matched;\n  if(~dp[idx][match][matched][lim][pv]) return dp[idx][match][matched][lim][pv];\n  int64 ret = 0;\n  for(int i = lim ? S[idx] - '0' : 9; i >= 0; i--) {\n    bool next_lim = lim & (S[idx] - '0' == i);\n    if(matched) {\n      ret += rec(idx + 1, match, matched, next_lim, 0);\n    } else if(match == 0 && i == 5) {\n      ret += rec(idx + 1, 1, matched, next_lim, i);\n    } else if(match == 1 && i == 1) {\n      ret += rec(idx + 1, 2, matched, next_lim, i);\n    } else if(match == 2) {\n      ret += rec(idx + 1, 3, matched, next_lim, i);\n    } else if(match == 3) {\n      if(i == 3) ret += rec(idx + 1, 0, true, next_lim, i);\n      else if(pv == 5 && i == 1) ret += rec(idx + 1, 2, matched, next_lim, i);\n      else ret += rec(idx + 1, i == 5, matched, next_lim, i);\n    } else {\n      ret += rec(idx + 1, i == 5, matched, next_lim, i);\n    }\n  }\n  return dp[idx][match][matched][lim][pv] = ret;\n}\n\nint main() {\n  cin >> S;\n  memset(dp, -1, sizeof(dp));\n  cout << rec(0, 0, 0, true, 0) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate <typename T> constexpr T inf;\ntemplate <> constexpr int inf<int> = 1e9;\ntemplate <> constexpr ll inf<ll> = 1e18;\ntemplate <> constexpr double inf<double> = 1e18;\n\n// [pos][i - 3][i - 2][i - 1][already ok][strictly less]\nll dp[20][10][10][10][2][2];\n\nll solve(ll n) {\n    //dp[0][0][0][0][0][0] = 1;\n    const auto s = to_string(n);\n    const int m = s.size();\n    for(int i = 0; i < m; ++i) {\n        dp[i][0][0][0][0][0] += 1;\n        for(int i3 = 0; i3 <= 9; ++i3) for(int i2 = 0; i2 <= 9; ++i2) for(int i1 = 0; i1 <= 9; ++i1) {\n            for(int aok = 0; aok <= 1; aok++) {\n                for(int le = 0; le <= 1; ++le) {\n                    const int lim = le ? 9 : s[i] - '0';\n                    for(int add = 0; add <= lim; ++add) {\n                        int nok = aok || (i3 == 5 && i2 == 1 && add == 3);\n                        int nle = le || s[i] - '0' > add;\n                        dp[i + 1][i2][i1][add][nok][nle] += dp[i][i3][i2][i1][aok][le];\n                    }\n                }\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i <= 9; ++i) {\n        for(int j = 0; j <= 9; ++j) {\n            for(int k = 0; k <= 9; ++k) {\n                ans += dp[m][i][j][k][1][0] + dp[m][i][j][k][1][1];\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    cout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <numeric>\n#include <vector>\n#include <map>\n#define int long long\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\nstring s;\nint len;\n\nenum Ord {\n    Less, Eq\n};\n\nint dp[20][2][2][10000];\n\nbool is_gochiusa(int x) {\n    if (x / 1000 % 10 != 5) return false;\n    if (x / 100 % 10 != 1) return false;\n    if (x / 1 % 10 != 3) return false;\n    return true;\n}\n\nint rec(int k, Ord ord, bool done, int tail) {\n    int &ans = dp[k][ord][done][tail];\n    if (ans != -1) return ans;\n\n    ans = 0;\n    if (k == len) {\n        ans = done ? 1 : 0;\n    } else {\n        int d = s[k] - '0';\n        rep(nd, 10) {\n            Ord nord;\n            if (ord == Less) {\n                nord = Less;\n            } else if (nd <= d) {\n                nord = nd < d ? Less : Eq;\n            } else {\n                continue;\n            }\n            int ntail = (tail * 10 + nd) % 10000;\n            bool ndone = done || is_gochiusa(ntail);\n            ans += rec(k + 1, nord, ndone, ntail);\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    cin >> s;\n    len = s.size();\n    memset(dp, -1, sizeof dp);\n    cout << rec(0, Eq, false, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint dp[20][1000][2];\n\nsigned main() {\n    int init_val; cin >> init_val;\n    string s = to_string(init_val);\n    int N = s.length();\n\n    dp[0][0][0] = 1;\n    for(int i=0; i<N; i++) {\n        for(int k=0; k<1000; k++) {\n            for(int f=0; f<2; f++) {\n                int lim = f ? 9 : s[i] - '0';\n                for(int x=0; x<lim+1; x++) {\n                    if(x == 3 && k/10 == 51) continue;\n                    dp[i+1][(k*10+x)%1000][f || x < lim] += dp[i][k][f];\n                }\n            }\n        }\n    }\n\n    int sum = 0;\n    for(int k=0; k<1000; k++) {\n        for(int f=0; f<2; f++) {\n            sum += dp[N][k][f];\n        }\n    }\n\n    cout << init_val - sum + 1 << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Int{\npublic:\n  string val;\n  Int():val(\"0\"){}\n  Int(string num,bool reversed=0){if(!reversed)R(num); val = num;}\n  Int(int num){val = to_string(num); R(val);}\n  \n  void R(string &a){reverse(a.begin(),a.end());}\n  bool neg(const string &a)const{return a.back() == '-';}\n  char& operator [] (int i){assert(i<(int)val.size());return val[i];}\n\n  bool operator ==  (Int b) {R(b.val); return *this == b.val;}\n  bool operator ==  (string b) {R(b);return val == b;}\n  template<class T> bool operator == (T b){return *this == Int(b);}\n  \n  bool operator !=  (Int b) {R(b.val); return *this != b.val;}\n  bool operator !=  (string b) {R(b);return !(val == b);}\n  template<class T> bool operator != (T b){return *this != Int(b);}\n  \n  bool operator >=  (Int b) {R(b.val); return *this >= b.val;}\n  bool operator >=  (string b) {return !(*this < b);}\n  template<class T> bool operator >= (T b){return *this >= Int(b);}\n\n  bool operator >   (Int b) {R(b.val); return *this > b.val;}\n  bool operator >   (string b) {return *this>=b && *this != b;}\n  template<class T> bool operator > (T b){return *this > Int(b);}\n\n  bool operator <=  (Int b) {R(b.val); return *this <= b.val;}\n  bool operator <=  (string b) {return *this<b || *this == b;}\n  template<class T> bool operator <= (T b){return *this <= Int(b);}\n\n  bool operator <   (Int b) {R(b.val); return *this < b.val;}\n  template<class T> bool operator < (T b){return *this < Int(b);}\n \n   bool operator <   (string b) {\n    R(b);\n    const string &a = val;\n    if(neg(a) != neg(b)) return neg(a)? 1:0;\n    if(a.size() != b.size()) return !neg(a)? (a.size()<b.size()):(a.size()>b.size());\n    for(int i=a.size()-1;i>=0;i--)if(a[i] != b[i]) return !neg(a)? a[i] < b[i]: a[i] > b[i];\n    return 0;\n  }\n  \n  Int operator + (string b){\n    R(b);\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(Int(a,1) < Int(b,1)) swap(a,b),swap(fa,fb);\n    \n    if(fa == fb){\n      a += '0';\n      for(int i=0;i<(int)a.size()-1;i++){\n        if(i < (int)b.size()) a[i] += b[i]-'0';\n        a[i+1] += (a[i]-'0')/10;\n        a[i] = (a[i]-'0')%10 + '0';\n      }\n      if(a.size() > 1 && a.back() == '0') a.pop_back();\n      if((int)a.size() > 1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    else {\n      for(int i=0;i<(int)a.size();i++){\n        if(i < (int)b.size()) a[i] -= b[i]-'0';\n        if(a[i]-'0' < 0) a[i]+=10, a[i+1]--; \n      }\n      while((int)a.size()>1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    return Int(a,1);\n  }\n\n  Int operator * (string b){\n    R(b);\n    vector<int> res;\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(a.size() < b.size()) swap(a,b), swap(fa,fb);\n    if(a == \"0\" || b == \"0\") return Int(\"0\");\n    \n    for(int j=0;j<(int)b.size();j++)\n      for(int i=0;i<(int)a.size();i++){\n        if(i+j >= (int)res.size()) res.push_back(0);\n        res[i+j] += (a[i]-'0') * (b[j]-'0');\n      }\n    for(int i=0; i <(int)res.size(); i++) {\n      if(res[i]/10 == 0) continue;\n      if(i + 1 >= (int)res.size()) res.push_back(0);\n      res[i+1] += res[i]/10, res[i]=res[i]%10;\n    }\n    string sres;\n    for(int i:res) sres += char(i + '0');\n    if(fa != fb) sres += '-';\n    return Int(sres,1);\n  }\n\n  Int div(string b,int flg){\n    assert(b != \"0\");\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = b[0]=='-'? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(b[0]=='-') b.erase(b.begin());\n    Int mod(\"0\");\n    string d=\"0\";\n    for(int i=(int)a.size()-1;i>=0;i--){\n      mod = mod * 10 + (a[i] - '0');\n      while(mod >= b) mod -= b, d.back()+=1;\n      if(i && d != \"0\") d += '0'; \n    }\n    if(flg == 0 && d != \"0\" && (fa != fb)) d = \"-\" + d;\n    if(flg == 1 && mod != \"0\" && (fa == \"-\")) mod *= -1;\n    return flg==0? d:mod;\n  }\n  \n  Int operator + (Int b){R(b.val); return *this + b.val;}\n  template<class T> Int operator + (T b){return *this + Int(b);}\n  \n  Int operator * (Int b){R(b.val); return *this * b.val;}\n  template<class T> Int operator * (T b){return *this * Int(b);}\n\n  Int operator - (string b){b = (b[0] == '-')? b.substr(1):\"-\" + b;return *this + b;}\n  Int operator - (Int b){R(b.val); return *this - b.val;} \n  template<class T> Int operator - (T b){return *this - Int(b);}\n  \n  Int operator / (string b){return div(b,0);}\n  Int operator / (Int b){R(b.val);return div(b.val,0);}\n  template<class T> Int operator / (T b){return *this / Int(b);}\n  \n  Int operator % (string b){return div(b,1);}\n  Int operator % (Int b){R(b.val);return div(b.val,1);}\n  template<class T> Int operator % (T b){return *this % Int(b);}\n  \n  Int operator += (Int b){return *this = *this+b;}\n  Int operator += (string b){return *this = *this+b;}\n  template<class T> Int operator += (T b){return *this += Int(b);}\n  \n  Int operator -= (Int b){return *this = *this-b;}\n  Int operator -= (string b){return *this = *this-b;}\n  template<class T> Int operator -= (T b){return *this -= Int(b);}\n  \n  Int operator *= (Int b){return *this = *this*b;}\n  Int operator *= (string b){return *this = *this*b;}\n  template<class T> Int operator *= (T b){return *this *= Int(b);}\n  \n  Int operator /= (string b){return *this = *this/b;}\n  Int operator /= (Int b){return *this = *this/b;}\n  template<class T> Int operator /= (T b){return *this /= Int(b);}\n  \n  Int operator %= (string b){return *this = *this % b;}\n  Int operator %= (Int b){return *this=*this%b;}\n  template<class T> Int operator %= (T b){return *this %= Int(b);}\n  \n  Int operator ++(){return *this += 1;}\n  Int operator --(){return *this -= 1;}\n\n#ifdef int\n#undef int\n#define eraseIntDefine\n#endif\n  Int operator ++(int){\n    Int tmp = *this;\n    *this += 1;\n    return tmp;\n  }\n  \n  Int operator --(int){\n    Int tmp = *this;\n    *this -= 1;\n    return tmp;\n  }\n#ifdef eraseIntDefine\n#define int long long\n#endif\n\n  friend ostream& operator << (ostream& os,const Int a){\n    for(int i=(int)a.val.size()-1;i>=0;i--) os<<a.val[i];\n    return os;\n  }\n\n  friend istream& operator >> (istream& is,Int &a){\n    string num;\n    is>>num;\n    a = Int(num);\n    return is;\n  }\n  friend string to_string(Int a){reverse(a.val.begin(),a.val.end());return a.val;}\n};\n\n\nstring str;\nstring num = \"51?3\";\n\nInt mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nInt dfs(int pos,int less,int cnt,string s,int target){\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt >= target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  Int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  Int sum[10]={};\n  for(int i=0;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n\n  Int a = stoi(str);\n  Int ans(0);\n  for(int i=1;i<5;i++) ans += Int(i%2? 1:-1) * sum[i];\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][2][10][10][10];\n\nstring num;\n\nint dfs(int x, int y, int p3, int p2, int p1 ){\n  \n  if( num.size() <= x ) return 0;\n  \n  if( dp[x][y][p3][p2][p1] != -1 ) return dp[x][y][p3][p2][p1];\n  \n  int res = 0;\n  \n  if( y == 0 ){\n    \n    int p = num[x] - '0';\n    \n    if( p3 == 5 && p2 == 1 && p == 3 ){\n      if( x != num.size() - 1 ) res += stoll(num.substr(x+1));\n      res++;\n    }\n    else res += dfs( x+1, 0, p2, p1, p );\n    \n    for(int i=0;i<num[x]-'0';i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\tif( x != num.size() - 1 ) res += stoll(num.substr(x+1));\n\tres++;\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n  \n  if( y == 1 ){\n    \n    for(int i=0;i<10;i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\t\n\tint X = 1;\n\t  \n\tfor(int j=0;j<num.size()-x-1;j++) X *= 10;\n\t  \n\tres += X;\n\t\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n\n  return dp[x][y][p3][p2][p1] = res;\n}\n\nsigned main(){\n  \n  cin>>num;\n  \n  memset( dp, -1, sizeof(dp) );\n  \n  cout<<dfs(0,0,0,0,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint pow10(int x){\n  if(x == 0) return 1;\n  return 10 * pow10(x-1);\n}\n\nint cnt(int x,int less){\n  if(x == n) return 1;\n  if(less) return pow10(n - x);\n  int a =  cnt(x+1,0);\n  int b = (num[x] - '0') * cnt(x+1,1);\n  return a + b;\n}\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += cnt(nidx,nless);\n    else res += dfs(nidx,nless,b ,c ,i);\n    \n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long dp[20][5][2] = {};\n\nint main() {\n    string s;\n    cin >> s;\n    int g[4] = { 5, 1, -1, 3 };\n    int n = s.size();\n    dp[0][0][1] = 1;\n    for (int i = 0; i < n + 1; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            for (int k = 0; k < 4; ++k) {\n                if (j == g[k] || k == 2) {\n                    dp[i + 1][k + 1][0] += dp[i][k][0];\n                }\n                else if (j == g[0]) {\n                    dp[i + 1][1][0] += dp[i][k][0];\n                }\n                else\n                    dp[i + 1][0][0] += dp[i][k][0];\n            }\n            dp[i + 1][4][0] += dp[i][4][0];\n        }\n        for (int j = 0; j < s[i] - '0'; ++j) {\n            for (int k = 0; k < 4; ++k) {\n                if (j == g[k] || k == 2) {\n                    dp[i + 1][k + 1][0] += dp[i][k][1];\n                }\n                else if (j == g[0]) {\n                    dp[i + 1][1][0] += dp[i][k][1];\n                }\n                else\n                    dp[i + 1][0][0] += dp[i][k][1];\n            }\n            dp[i + 1][4][0] += dp[i][4][1];\n        }\n        for (int j = s[i] - '0'; j <= s[i] - '0'; ++j) {\n            for (int k = 0; k < 4; ++k) {\n                if (j == g[k] || k == 2) {\n                    dp[i + 1][k + 1][1] += dp[i][k][1];\n                }\n                else if (j == g[0]) {\n                    dp[i + 1][1][1] += dp[i][k][1];\n                }\n                else\n                    dp[i + 1][0][1] += dp[i][k][1];\n            }\n            dp[i + 1][4][1] += dp[i][4][1];\n        }\n    }\n    cout << dp[n][4][0] + dp[n][4][1] << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\nll dp[18][100][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\n//ll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%100;\n\t//return next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 99; pre_num++){\n\t\t//for(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Int{\npublic:\n  string val;\n  Int():val(\"0\"){}\n  Int(string num,bool reversed=0){if(!reversed)R(num); val = num;}\n  Int(int num){val = to_string(num); R(val);}\n  \n  void R(string &a){reverse(a.begin(),a.end());}\n  bool neg(const string &a)const{return a.back() == '-';}\n  char& operator [] (int i){assert(i<(int)val.size());return val[i];}\n\n  bool operator ==  (Int b) {R(b.val); return *this == b.val;}\n  bool operator ==  (string b) {R(b);return val == b;}\n  template<class T> bool operator == (T b){return *this == Int(b);}\n  \n  bool operator !=  (Int b) {R(b.val); return *this != b.val;}\n  bool operator !=  (string b) {R(b);return !(val == b);}\n  template<class T> bool operator != (T b){return *this != Int(b);}\n  \n  bool operator >=  (Int b) {R(b.val); return *this >= b.val;}\n  bool operator >=  (string b) {return !(*this < b);}\n  template<class T> bool operator >= (T b){return *this >= Int(b);}\n\n  bool operator >   (Int b) {R(b.val); return *this > b.val;}\n  bool operator >   (string b) {return *this>=b && *this != b;}\n  template<class T> bool operator > (T b){return *this > Int(b);}\n\n  bool operator <=  (Int b) {R(b.val); return *this <= b.val;}\n  bool operator <=  (string b) {return *this<b || *this == b;}\n  template<class T> bool operator <= (T b){return *this <= Int(b);}\n\n  bool operator <   (Int b) {R(b.val); return *this < b.val;}\n  template<class T> bool operator < (T b){return *this < Int(b);}\n \n   bool operator <   (string b) {\n    R(b);\n    const string &a = val;\n    if(neg(a) != neg(b)) return neg(a)? 1:0;\n    if(a.size() != b.size()) return !neg(a)? (a.size()<b.size()):(a.size()>b.size());\n    for(int i=a.size()-1;i>=0;i--)if(a[i] != b[i]) return !neg(a)? a[i] < b[i]: a[i] > b[i];\n    return 0;\n  }\n  \n  Int operator + (string b){\n    R(b);\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(Int(a,1) < Int(b,1)) swap(a,b),swap(fa,fb);\n    \n    if(fa == fb){\n      a += '0';\n      for(int i=0;i<(int)a.size()-1;i++){\n        if(i < (int)b.size()) a[i] += b[i]-'0';\n        a[i+1] += (a[i]-'0')/10;\n        a[i] = (a[i]-'0')%10 + '0';\n      }\n      if(a.size() > 1 && a.back() == '0') a.pop_back();\n      if((int)a.size() > 1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    else {\n      for(int i=0;i<(int)a.size();i++){\n        if(i < (int)b.size()) a[i] -= b[i]-'0';\n        if(a[i]-'0' < 0) a[i]+=10, a[i+1]--; \n      }\n      while((int)a.size()>1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    return Int(a,1);\n  }\n\n  Int operator * (string b){\n    R(b);\n    vector<int> res;\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(a.size() < b.size()) swap(a,b), swap(fa,fb);\n    if(a == \"0\" || b == \"0\") return Int(\"0\");\n    \n    for(int j=0;j<(int)b.size();j++)\n      for(int i=0;i<(int)a.size();i++){\n        if(i+j >= (int)res.size()) res.push_back(0);\n        res[i+j] += (a[i]-'0') * (b[j]-'0');\n      }\n    for(int i=0; i <(int)res.size(); i++) {\n      if(res[i]/10 == 0) continue;\n      if(i + 1 >= (int)res.size()) res.push_back(0);\n      res[i+1] += res[i]/10, res[i]=res[i]%10;\n    }\n    string sres;\n    for(int i:res) sres += char(i + '0');\n    if(fa != fb) sres += '-';\n    return Int(sres,1);\n  }\n\n  Int div(string b,int flg){\n    assert(b != \"0\");\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = b[0]=='-'? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(b[0]=='-') b.erase(b.begin());\n    Int mod(\"0\");\n    string d=\"0\";\n    for(int i=(int)a.size()-1;i>=0;i--){\n      mod = mod * 10 + (a[i] - '0');\n      while(mod >= b) mod -= b, d.back()+=1;\n      if(i && d != \"0\") d += '0'; \n    }\n    if(flg == 0 && d != \"0\" && (fa != fb)) d = \"-\" + d;\n    if(flg == 1 && mod != \"0\" && (fa == \"-\")) mod *= -1;\n    return flg==0? d:mod;\n  }\n  \n  Int operator + (Int b){R(b.val); return *this + b.val;}\n  template<class T> Int operator + (T b){return *this + Int(b);}\n  \n  Int operator * (Int b){R(b.val); return *this * b.val;}\n  template<class T> Int operator * (T b){return *this * Int(b);}\n\n  Int operator - (string b){b = (b[0] == '-')? b.substr(1):\"-\" + b;return *this + b;}\n  Int operator - (Int b){R(b.val); return *this - b.val;} \n  template<class T> Int operator - (T b){return *this - Int(b);}\n  \n  Int operator / (string b){return div(b,0);}\n  Int operator / (Int b){R(b.val);return div(b.val,0);}\n  template<class T> Int operator / (T b){return *this / Int(b);}\n  \n  Int operator % (string b){return div(b,1);}\n  Int operator % (Int b){R(b.val);return div(b.val,1);}\n  template<class T> Int operator % (T b){return *this % Int(b);}\n  \n  Int operator += (Int b){return *this = *this+b;}\n  Int operator += (string b){return *this = *this+b;}\n  template<class T> Int operator += (T b){return *this += Int(b);}\n  \n  Int operator -= (Int b){return *this = *this-b;}\n  Int operator -= (string b){return *this = *this-b;}\n  template<class T> Int operator -= (T b){return *this -= Int(b);}\n  \n  Int operator *= (Int b){return *this = *this*b;}\n  Int operator *= (string b){return *this = *this*b;}\n  template<class T> Int operator *= (T b){return *this *= Int(b);}\n  \n  Int operator /= (string b){return *this = *this/b;}\n  Int operator /= (Int b){return *this = *this/b;}\n  template<class T> Int operator /= (T b){return *this /= Int(b);}\n  \n  Int operator %= (string b){return *this = *this % b;}\n  Int operator %= (Int b){return *this=*this%b;}\n  template<class T> Int operator %= (T b){return *this %= Int(b);}\n  \n  Int operator ++(){return *this += 1;}\n  Int operator --(){return *this -= 1;}\n\n#ifdef int\n#undef int\n#define eraseIntDefine\n#endif\n  Int operator ++(int){\n    Int tmp = *this;\n    *this += 1;\n    return tmp;\n  }\n  \n  Int operator --(int){\n    Int tmp = *this;\n    *this -= 1;\n    return tmp;\n  }\n#ifdef eraseIntDefine\n#define int long long\n#endif\n\n  friend ostream& operator << (ostream& os,const Int a){\n    for(int i=(int)a.val.size()-1;i>=0;i--) os<<a.val[i];\n    return os;\n  }\n\n  friend istream& operator >> (istream& is,Int &a){\n    string num;\n    is>>num;\n    a = Int(num);\n    return is;\n  }\n  friend string to_string(Int a){reverse(a.val.begin(),a.val.end());return a.val;}\n};\n\n\nstring str;\nstring num = \"51?3\";\n\nInt mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nInt dfs(int pos,int less,int cnt,string s,int target){\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt >= target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  Int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  Int sum[10]={};\n  for(int i=0;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n\n  Int a = stoi(str);\n  Int ans(a);\n  for(int i=1;i<5;i++) ans -= Int(i%2? 1:-1) * sum[i];\n  cout<<(a-ans)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Int{\npublic:\n  string val;\n  Int():val(\"0\"){}\n  Int(string num,bool reversed=0){if(!reversed)R(num); val = num;}\n  Int(int num){val = to_string(num); R(val);}\n  \n  void R(string &a){reverse(a.begin(),a.end());}\n  bool neg(const string &a)const{return a.back() == '-';}\n  char& operator [] (int i){assert(i<(int)val.size());return val[i];}\n\n  bool operator ==  (Int b) {R(b.val); return *this == b.val;}\n  bool operator ==  (string b) {R(b);return val == b;}\n  template<class T> bool operator == (T b){return *this == Int(b);}\n  \n  bool operator !=  (Int b) {R(b.val); return *this != b.val;}\n  bool operator !=  (string b) {R(b);return !(val == b);}\n  template<class T> bool operator != (T b){return *this != Int(b);}\n  \n  bool operator >=  (Int b) {R(b.val); return *this >= b.val;}\n  bool operator >=  (string b) {return !(*this < b);}\n  template<class T> bool operator >= (T b){return *this >= Int(b);}\n\n  bool operator >   (Int b) {R(b.val); return *this > b.val;}\n  bool operator >   (string b) {return *this>=b && *this != b;}\n  template<class T> bool operator > (T b){return *this > Int(b);}\n\n  bool operator <=  (Int b) {R(b.val); return *this <= b.val;}\n  bool operator <=  (string b) {return *this<b || *this == b;}\n  template<class T> bool operator <= (T b){return *this <= Int(b);}\n\n  bool operator <   (Int b) {R(b.val); return *this < b.val;}\n  template<class T> bool operator < (T b){return *this < Int(b);}\n \n   bool operator <   (string b) {\n    R(b);\n    const string &a = val;\n    if(neg(a) != neg(b)) return neg(a)? 1:0;\n    if(a.size() != b.size()) return !neg(a)? (a.size()<b.size()):(a.size()>b.size());\n    for(int i=a.size()-1;i>=0;i--)if(a[i] != b[i]) return !neg(a)? a[i] < b[i]: a[i] > b[i];\n    return 0;\n  }\n  \n  Int operator + (string b){\n    R(b);\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(Int(a,1) < Int(b,1)) swap(a,b),swap(fa,fb);\n    \n    if(fa == fb){\n      a += '0';\n      for(int i=0;i<(int)a.size()-1;i++){\n        if(i < (int)b.size()) a[i] += b[i]-'0';\n        a[i+1] += (a[i]-'0')/10;\n        a[i] = (a[i]-'0')%10 + '0';\n      }\n      if(a.size() > 1 && a.back() == '0') a.pop_back();\n      if((int)a.size() > 1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    else {\n      for(int i=0;i<(int)a.size();i++){\n        if(i < (int)b.size()) a[i] -= b[i]-'0';\n        if(a[i]-'0' < 0) a[i]+=10, a[i+1]--; \n      }\n      while((int)a.size()>1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    return Int(a,1);\n  }\n\n  Int operator * (string b){\n    R(b);\n    vector<int> res;\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(a.size() < b.size()) swap(a,b), swap(fa,fb);\n    if(a == \"0\" || b == \"0\") return Int(\"0\");\n    \n    for(int j=0;j<(int)b.size();j++)\n      for(int i=0;i<(int)a.size();i++){\n        if(i+j >= (int)res.size()) res.push_back(0);\n        res[i+j] += (a[i]-'0') * (b[j]-'0');\n      }\n    for(int i=0; i <(int)res.size(); i++) {\n      if(res[i]/10 == 0) continue;\n      if(i + 1 >= (int)res.size()) res.push_back(0);\n      res[i+1] += res[i]/10, res[i]=res[i]%10;\n    }\n    string sres;\n    for(int i:res) sres += char(i + '0');\n    if(fa != fb) sres += '-';\n    return Int(sres,1);\n  }\n\n  Int div(string b,int flg){\n    assert(b != \"0\");\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = b[0]=='-'? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(b[0]=='-') b.erase(b.begin());\n    Int mod(\"0\");\n    string d=\"0\";\n    for(int i=(int)a.size()-1;i>=0;i--){\n      mod = mod * 10 + (a[i] - '0');\n      while(mod >= b) mod -= b, d.back()+=1;\n      if(i && d != \"0\") d += '0'; \n    }\n    if(flg == 0 && d != \"0\" && (fa != fb)) d = \"-\" + d;\n    if(flg == 1 && mod != \"0\" && (fa == \"-\")) mod *= -1;\n    return flg==0? d:mod;\n  }\n  \n  Int operator + (Int b){R(b.val); return *this + b.val;}\n  template<class T> Int operator + (T b){return *this + Int(b);}\n  \n  Int operator * (Int b){R(b.val); return *this * b.val;}\n  template<class T> Int operator * (T b){return *this * Int(b);}\n\n  Int operator - (string b){b = (b[0] == '-')? b.substr(1):\"-\" + b;return *this + b;}\n  Int operator - (Int b){R(b.val); return *this - b.val;} \n  template<class T> Int operator - (T b){return *this - Int(b);}\n  \n  Int operator / (string b){return div(b,0);}\n  Int operator / (Int b){R(b.val);return div(b.val,0);}\n  template<class T> Int operator / (T b){return *this / Int(b);}\n  \n  Int operator % (string b){return div(b,1);}\n  Int operator % (Int b){R(b.val);return div(b.val,1);}\n  template<class T> Int operator % (T b){return *this % Int(b);}\n  \n  Int operator += (Int b){return *this = *this+b;}\n  Int operator += (string b){return *this = *this+b;}\n  template<class T> Int operator += (T b){return *this += Int(b);}\n  \n  Int operator -= (Int b){return *this = *this-b;}\n  Int operator -= (string b){return *this = *this-b;}\n  template<class T> Int operator -= (T b){return *this -= Int(b);}\n  \n  Int operator *= (Int b){return *this = *this*b;}\n  Int operator *= (string b){return *this = *this*b;}\n  template<class T> Int operator *= (T b){return *this *= Int(b);}\n  \n  Int operator /= (string b){return *this = *this/b;}\n  Int operator /= (Int b){return *this = *this/b;}\n  template<class T> Int operator /= (T b){return *this /= Int(b);}\n  \n  Int operator %= (string b){return *this = *this % b;}\n  Int operator %= (Int b){return *this=*this%b;}\n  template<class T> Int operator %= (T b){return *this %= Int(b);}\n  \n  Int operator ++(){return *this += 1;}\n  Int operator --(){return *this -= 1;}\n\n#ifdef int\n#undef int\n#define eraseIntDefine\n#endif\n  Int operator ++(int){\n    Int tmp = *this;\n    *this += 1;\n    return tmp;\n  }\n  \n  Int operator --(int){\n    Int tmp = *this;\n    *this -= 1;\n    return tmp;\n  }\n#ifdef eraseIntDefine\n#define int long long\n#endif\n\n  friend ostream& operator << (ostream& os,const Int a){\n    for(int i=(int)a.val.size()-1;i>=0;i--) os<<a.val[i];\n    return os;\n  }\n\n  friend istream& operator >> (istream& is,Int &a){\n    string num;\n    is>>num;\n    a = Int(num);\n    return is;\n  }\n  friend string to_string(Int a){reverse(a.val.begin(),a.val.end());return a.val;}\n};\n\n\nstring str;\nstring num = \"51?3\";\n\nInt mem[20][2][5][5][5];\nint used[20][2][5][5][5];\nInt dfs(int pos,int less,int cnt,string s,int target){\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt == target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  Int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  Int sum[5]={};\n  for(int i=0;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n\n  Int a = stoi(str);\n  Int ans(a);\n  for(int i=1;i<5;i++) ans -= Int(i%2? 1:-1) * sum[i];\n  cout<<(a-ans)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\n#define rep(i, n) for (long long i = (long long)(0); i < (long long)(n); ++i)\n#define reps(i, n) for (long long i = (long long)(1); i <= (long long)(n); ++i)\n#define rrep(i, n) for (long long i = ((long long)(n)-1); i >= 0; i--)\n#define rreps(i, n) for (long long i = ((long long)(n)); i > 0; i--)\n#define irep(i, m, n) for (long long i = (long long)(m); i < (long long)(n); ++i)\n#define ireps(i, m, n) for (long long i = (long long)(m); i <= (long long)(n); ++i)\n#define SORT(v, n) sort(v, v + n);\n#define REVERSE(v, n) reverse(v, v+n);\n#define vsort(v) sort(v.begin(), v.end());\n#define all(v) v.begin(), v.end()\n#define mp(n, m) make_pair(n, m);\n#define cout(d) cout<<d<<endl;\n#define coutd(d) cout<<std::setprecision(10)<<d<<endl;\n#define cinline(n) getline(cin,n);\n#define replace_all(s, b, a) replace(s.begin(),s.end(), b, a);\n#define PI (acos(-1))\n#define FILL(v, n, x) fill(v, v + n, x);\n#define sz(x) long long(x.size())\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\nusing vs = vector<string>;\nusing vpll = vector<pair<ll, ll>>;\nusing tll = tuple<ll,ll,ll>;\nusing vtll = vector<tuple<ll,ll,ll>>;\nusing vb = vector<bool>;\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n\nconst ll INF = 1e9;\nconst ll MOD = 1e9+7;\nconst ll LINF = 1e18;\n\nll dp[20][2][1000][2];\n\nsigned main()\n{\n  cin.tie( 0 ); ios::sync_with_stdio( false );\n  string s; cin>>s;\n  ll n=s.size();\n  \n  dp[0][0][0][0]=1;\n  rep(i,n) rep(j,2) rep(k,1000) rep(l,2){\n    ll now=s[i]-'0';\n    rep(nxt,10){\n      if(nxt>now&&j==0) continue;\n      ll nj=j,nl=l;\n      if(nxt<now) nj=1;\n      ll nk=k%100*10+nxt;\n      if(k/100==5&&k%100/10==1&&nxt==3) nl=1;\n      dp[i+1][nj][nk][nl]+=dp[i][j][k][l];\n    }\n  }\n  \n  ll ans=0;\n  rep(j,2) rep(k,1000) ans+=dp[n][j][k][1];\n  cout<<ans<<endl;\n  \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\nll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%1000;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstring N;\nint rec(int i, bool less, int state) {\n    if (i == SZ(N)) {\n        return state >= 4;\n    }\n\n    int ret = 0;\n    if (less) {\n        REP(j, 10) {\n            int next_state = state;\n            if ((state == 0 && j == 5)\n             || (state == 1 && j == 1)\n             || (state == 2)\n             || (state == 3 && j == 3)\n             || (state >= 4)) next_state++;\n            else {\n                if (j == 5) next_state = 1;\n                else next_state = 0;\n            }\n            ret += rec(i+1, true, next_state);\n        }\n    } else {\n        REP(j, N[i]-'0'+1) {\n            int next_state = state;\n            if ((state == 0 && j == 5)\n             || (state == 1 && j == 1)\n             || (state == 2)\n             || (state == 3 && j == 3)\n             || (state >= 4)) next_state++;\n            else {\n                if (j == 5) next_state = 1;\n                else next_state = 0;\n            }\n            ret += rec(i+1, j!=(N[i]-'0'), next_state);\n        }\n    }\n    return ret;\n}\nsigned main() {\n    cin >> N;\n    cout << rec(0, 0, 0) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][5][2][2];\nstring s,t=\"51?3\";\n\nint dfs(int idx,int mat,bool tight=true,bool ok=false){\n    if(idx==s.size())return ok;\n    int res=dp[idx][mat][tight][ok];\n    if(~res)return res;\n    res=0;\n    int x=s[idx]-'0';\n    int r=(tight?x:9);\n    for(int i=0;i<=r;i++){\n        int nxt=(i+'0'==t[mat])||(t[mat]=='?');\n        if(nxt&&!ok)res+=dfs(idx+1,mat+nxt,tight&&i==r,nxt+mat==4);\n        if(ok)res+=dfs(idx+1,4,tight&&i==r,ok);\n        else res+=dfs(idx+1,0,tight&&i==r,ok);\n    }\n    return res;\n}\n\nsigned main(){\n    memset(dp,-1,sizeof(dp));\n    cin>>s;\n    cout<<dfs(0,0)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing PII = pair<ll, ll>;\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\ntemplate<typename T> void chmin(T &a, const T &b) { a = min(a, b); }\ntemplate<typename T> void chmax(T &a, const T &b) { a = max(a, b); }\nstruct FastIO {FastIO() { cin.tie(0); ios::sync_with_stdio(0); }}fastiofastio;\n#ifdef DEBUG_ \n#include \"../program_contest_library/memo/dump.hpp\"\n#else\n#define dump(...)\n#endif\nconst ll INF = 1LL<<60;\n\nll dp[20][10010][2][2];\nint main(void) {\n    string s;\n    cin >> s;\n    const ll n = s.size();\n\n    dp[0][0][0][0] = 1;\n    REP(i, n) REP(j, 10000) REP(k, 2) REP(l, 2) {\n        ll lim = k==0 ? s[i]-'0' : 9;\n        REP(d, lim+1) {\n            ll nj = (j*10 + d) % 10000, nk = k || d<lim, nl = l;\n            if(nj/100 == 51 && nj%10 == 3) nl |= 1;\n            dp[i+1][nj][nk][nl] += dp[i][j][k][l];\n        }\n    }\n\n    ll ret = 0;\n    REP(i, 10000) REP(j, 2) ret += dp[n][i][j][1];\n    cout << ret << endl;\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,double>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,-1,0,1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               \t\t\tclass pa3{\n                                        \tpublic:\n                                        \tint x,y,z;\n                                        \tpa3(int x=0,int y=0,int z=0):x(x),y(y),z(z) {}\n                                        \tbool operator < (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\t return z<p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                               \t\t\t\tbool operator > (const pa3 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\t return z>p.z;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa3 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z;\n                                        \t}\n                                        \t\tbool operator != (const pa3 &p) const{\n                                        \t\t\treturn !( x==p.x && y==p.y && z==p.z);\n                                        \t}\n                                        \n                                        };\n                                        \n                                        class pa4{\n                                        \tpublic:\n                                        \tdouble x;\n                                        \tint y,z,w;\n                                        \tpa4(double x=0,int y=0,int z=0,int w=0):x(x),y(y),z(z),w(w) {}\n                                        \tbool operator < (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x<p.x;\n                                        \t\tif(y!=p.y) return y<p.y;\n                                        \t\tif(z!=p.z)return z<p.z;\n                                        \t\treturn w<p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa4 &p) const{\n                                        \t\tif(x!=p.x) return x>p.x;\n                                        \t\tif(y!=p.y) return y>p.y;\n                                        \t\tif(z!=p.z)return z>p.z;\n                                        \t\treturn w>p.w;\n                                        \t\t//return x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa4 &p) const{\n                                        \t\treturn x==p.x && y==p.y && z==p.z &&w==p.w;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tpa2 operator - (pa2 p) {return pa2(x-p.x,y-p.y);}\n                                        \tpa2 operator * (int a) {return pa2(x*a,y*a);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator > (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x>p.x: y>p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \tbool operator != (const pa2 &p) const{\n                                        \t\treturn !(abs(x-p.x)==0 && abs(y-p.y)==0);\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n             /*               \n            int pr[1000010];\n            int inv[1000010];\n            \n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1%warukazu;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\ndouble bekid(double w,int r){\n\tif(r==0) return 1.0;\n\tif(r==1) return w;\n\tif(r%2) return bekid(w,r-1)*w;\n\tdouble f=bekid(w,r/2);\n\treturn f*f;\n}\n\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<=ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n           \tfor(int i=0;i<=ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n            */ \n\t\t\t//priority_queue<pa3,vector<pa3>,greater<pa3>> pq;            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000)\n\nint dp[200][60][20]={0};\n \nsigned main(){\nstring s;\n\tint n;\n\tcin>>n;\n\ts=itos(n);\n\tint l=s.length();\n\t\n\tfor(char i='0';i<=s[0];i++){\n\t\tif(i!='5' && i<s[0])dp[0][0][0]++;\n\t\tif(i=='5' && i<s[0])dp[0][1][0]++;\n\t\tif(i!='5' && i==s[0])dp[0][0][1]++;\n\t\tif(i=='5' && i==s[0])dp[0][1][1]++;\n\t}\n\t\n\tfor(int i=0;i<l-1;i++){\n\t//cout<<i<<endl;\n\t\tfor(int j=0;j<10;j++)if(j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][0][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][0][0];\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=1 && j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][1][0];\n\t\t}\n\t\tdp[i+1][2][0]+=dp[i][1][0];\n\t\tdp[i+1][1][0]+=dp[i][1][0];\n\t\t\n\t\tfor(int j=0;j<10;j++){\n\t\t\tif(j!=5)\tdp[i+1][3][0]+=dp[i][2][0];\n\t\t\telse dp[i+1][5][0]+=dp[i][2][0];\n\t\t}\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=3&&j!=5){\n\t\tdp[i+1][0][0]+=dp[i][3][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][3][0];\n\t\t\n\t\tfor(int j=0;j<10;j++)if(j!=3&&j!=5){\n\t\t\tif(j!=1)dp[i+1][0][0]+=dp[i][5][0];\n\t\t\telse dp[i+1][2][0]+=dp[i][5][0];\n\t\t}\n\t\tdp[i+1][1][0]+=dp[i][5][0];\n\t\t\n\t\tint h=s[i+1]-'0';\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][0][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][0][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=1 && j!=5){\n\t\t\tdp[i+1][0][0]+=dp[i][1][1];\n\t\t}\n\t\tif(h>1)dp[i+1][2][0]+=dp[i][1][1];\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][1][1];\n\t\t\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=5){\n\t\t\tdp[i+1][3][0]+=dp[i][2][1];\n\t\t}\n\t\tif(h>5) dp[i+1][5][0]+=dp[i][2][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=3 && j!=5){\n\t\tdp[i+1][0][0]+=dp[i][3][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][3][1];\n\t\t\n\t\tfor(int j=0;j<h;j++)if(j!=3 &&j!=5){\n\t\t\tif(j!=1)dp[i+1][0][0]+=dp[i][5][1];\n\t\t\telse dp[i+1][2][0]+=dp[i][5][1];\n\t\t}\n\t\tif(h>5)dp[i+1][1][0]+=dp[i][5][1];\n\t\t\n\t\tif(h==5){\n\t\tdp[i+1][1][1]+=dp[i][0][1];\n\t\tdp[i+1][1][1]+=dp[i][1][1];\t\n\t\tdp[i+1][5][1]+=dp[i][2][1];\n\t\tdp[i+1][1][1]+=dp[i][3][1];\n\t\tdp[i+1][1][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t\telse if(h==1){\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][2][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t\tdp[i+1][0][1]+=dp[i][3][1];\n\t\tdp[i+1][2][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t\telse if(h==3){\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][0][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t//\tdp[i+1][0][1]+=dp[i][3][1];\n\t\t}\n\t\telse{\n\t\tdp[i+1][0][1]+=dp[i][0][1];\n\t\tdp[i+1][0][1]+=dp[i][1][1];\t\n\t\tdp[i+1][3][1]+=dp[i][2][1];\n\t\tdp[i+1][0][1]+=dp[i][3][1];\n\t\tdp[i+1][0][1]+=dp[i][5][1];\n\t\t}\n\t\t\n\t}\n//\tcout<<\"s\"<<endl;\n//\tint n=stoi(s);\n//\tcout<<n<<endl;\n\tint ans=0;\n\tfor(int i=0;i<6;i++)for(int j=0;j<2;j++)ans+=dp[l-1][i][j];\n\tcout<<n-ans+1<<endl;\n\t\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll Stoi(string s){\n  ll res=0;\n  for(ll i=0;i<(int)s.size();i++)res=res*10+s[i]-'0';\n  return res;\n}\n\nll Pow(ll a,ll b){\n  ll res=1;\n  while(b--)res*=a;\n  return res;\n}\n\nstring n;\nll dp[20][2][10][10][10];\n\nll dfs(ll id,ll f,ll a,ll b,ll c){\n  if(dp[id][f][a][b][c]!=-1)return dp[id][f][a][b][c];\n  if(id==(int)n.size())return 0;\n  ll r=9,res=0;\n  if(!f)r=n[id]-'0';\n  for(ll d=0;d<=r;d++){\n    ll nf=f;\n    if(d<r)nf=1;\n    if(a==5&&b==1&&d==3){\n      if(nf) res+=Pow(10,n.size()-id-1);\n      else res+=Stoi(n.substr(id+1))+1;\n    }\n    else{\n      res+=dfs(id+1,nf,b,c,d);\n    }\n  }\n  return dp[id][f][a][b][c]=res;\n}\n\nint main(){\n  cin>>n;\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <list>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <unordered_set>\n#include <unordered_map>\n#include <array>\n#include <cassert>\n#include <bitset>\nusing namespace std;\nusing LL = long long;\n\nstring N;\nLL dp[20][5][2];\n\nint main(void)\n{\n\tcin >> N;\n\tLL num = stoll(N);\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i < N.size(); ++i) {\n\t\tfor (int j = 0; j < 4; ++j) {\n\t\t\t//dp[i][j][0]\n\t\t\tset<int>ok, nx, tk;\n\t\t\tfor (int d = 0; d < N[i] - '0'; ++d) {\n\t\t\t\tbool f = true;\n\t\t\t\tif (j == 0 && d == 5)f = false;\n\t\t\t\tif (j == 1 && d == 1)f = false;\n\t\t\t\tif (j == 2)f = false;\n\t\t\t\tif (j == 3 && d == 3)f = false;\n\t\t\t\tif (f) {\n\t\t\t\t\tif (d == 5)tk.insert(d);\n\t\t\t\t\telse ok.insert(d);\n\t\t\t\t}\n\t\t\t\telse nx.insert(d);\n\t\t\t}\n\t\t\tdp[i + 1][0][1] += dp[i][j][0] * (LL)ok.size();\n\t\t\tdp[i + 1][1][1] += dp[i][j][0] * (LL)tk.size();\n\t\t\tdp[i + 1][j + 1][1] += dp[i][j][0] * (LL)nx.size();\n\t\t\tok.clear(); nx.clear(); tk.clear();\n\t\t\tfor (int d = N[i] - '0'; d == N[i] - '0'; ++d) {\n\t\t\t\tbool f = true;\n\t\t\t\tif (j == 0 && d == 5)f = false;\n\t\t\t\tif (j == 1 && d == 1)f = false;\n\t\t\t\tif (j == 2)f = false;\n\t\t\t\tif (j == 3 && d == 3)f = false;\n\t\t\t\tif (f) {\n\t\t\t\t\tif (d == 5)tk.insert(d);\n\t\t\t\t\telse ok.insert(d);\n\t\t\t\t}\n\t\t\t\telse nx.insert(d);\n\t\t\t}\n\t\t\tdp[i + 1][0][0] += dp[i][j][0] * (LL)ok.size();\n\t\t\tdp[i + 1][1][0] += dp[i][j][0] * (LL)tk.size();\n\t\t\tdp[i + 1][j + 1][0] += dp[i][j][0] * (LL)nx.size();\n\t\t\t//dp[i][j][1]\n\t\t\t//set<int>ok, nx;\n\t\t\tok.clear(); nx.clear(); tk.clear();\n\t\t\tfor (int d = 0; d < 10; ++d) {\n\t\t\t\tbool f = true;\n\t\t\t\tif (j == 0 && d == 5)f = false;\n\t\t\t\tif (j == 1 && d == 1)f = false;\n\t\t\t\tif (j == 2)f = false;\n\t\t\t\tif (j == 3 && d == 3)f = false;\n\t\t\t\tif (f) {\n\t\t\t\t\tif (d == 5)tk.insert(d);\n\t\t\t\t\telse ok.insert(d);\n\t\t\t\t}\n\t\t\t\telse nx.insert(d);\n\t\t\t}\n\t\t\tdp[i + 1][0][1] += dp[i][j][1] * (LL)ok.size();\n\t\t\tdp[i + 1][1][1] += dp[i][j][1] * (LL)tk.size();\n\t\t\tdp[i + 1][j + 1][1] += dp[i][j][1] * (LL)nx.size();\n\t\t}\n\t}\n\tLL sum = 0;\n\tfor (int j = 0; j < 4; ++j) {\n\t\tsum += dp[N.size()][j][0] + dp[N.size()][j][1];\n\t}\n\tcout << num - sum + 1 << endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  string s;\n  cin>>s;\n  Int n=s.size();\n  Int dp[20][4][2][2][10];\n  memset(dp,-1,sizeof(dp));\n  function<Int(Int,Int,Int,Int,Int)> dfs=\n    [&](Int pos,Int st,Int ok,Int lim,Int pre){\n    if(pos==n) return ok;\n    Int &res=dp[pos][st][ok][lim][pre];\n    if(~res) return res;\n    res=0;\n    for(Int i=0;i<=(lim?s[pos]-'0':9);i++){\n      Int nlim=lim&&(i==s[pos]-'0');\n      if(st==0&&i==5){\n\tres+=dfs(pos+1,1,ok,nlim,i);\n      }else if(st==1&&i==1){\n\tres+=dfs(pos+1,2,ok,nlim,i);\n      }else if(st==2){\n\tres+=dfs(pos+1,3,ok,nlim,i);\n      }else if(st==3){\n\tif(i==3) res+=dfs(pos+1,0,1,nlim,i);\n\telse if(pre==5&&i==1) res+=dfs(pos+1,2,ok,nlim,i);\n\telse if(i==5) res+=dfs(pos+1,1,ok,nlim,i);\n      }else if(i==5){\n\tres+=dfs(pos+1,1,ok,nlim,i);\n      }else res+=dfs(pos+1,0,ok,nlim,i);\n    }\n    //cout<<pos<<\" \"<<st<<\" \"<<ok<<\" \"<<lim<<\" \"<<pre<<\":\"<<res<<endl;\n    return res;\n  };\n  cout<<dfs(0,0,0,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nlong long dp[20][2][5];\nstring N;\nlong long rec(int k,bool tight,int cnt)\n{\n\tif(k==N.size())\n\t{\n\t\treturn cnt==4;\n\t}\n\telse if(~dp[k][tight][cnt])\n\t{\n\t\treturn dp[k][tight][cnt];\n\t}\n\tint r=(tight?N[k]-'0':9);\n\tlong long ans=0;\n\tfor(int i=0;i<=r;i++)\n\t{\n\t\tif(cnt==4)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,4);\n\t\t}\n\t\telse if(cnt!=2&&i==5)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,1);\n\t\t}\n\t\telse if(cnt==1&&i==1)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,2);\n\t\t}\n\t\telse if(cnt==2)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,3);\n\t\t}\n\t\telse if(cnt==3&&i==3)\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,4);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tans+=rec(k+1,tight&&r==i,0);\n\t\t}\n\t}\n\treturn dp[k][tight][cnt]=ans;\n}\nint main()\n{\n\tcin>>N;\n\tfor(int i=0;i<20;i++)\n\t{\n\t\tfor(int j=0;j<2;j++)\n\t\t{\n\t\t\tfor(int k=0;k<5;k++)\n\t\t\t{\n\t\t\t\tdp[i][j][k]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tcout<<rec(0,1,0)<<endl;\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\nusing Pi = pair<int, int>;\nusing Tapris = tuple<int, int, int>;\nusing vint = vector<int>;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstring s;\nint dp[20][1000][2][2];\n\nsigned main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  cin >> s;\n  int n = s.size();\n  memset(dp, 0, sizeof(dp));\n  dp[0][0][0][0] = 1;\n  for(int i = 0; i < n; ++i) {\n    for(int j = 0; j < 1000; ++j) {\n      for(int k = 0; k < 2; ++k) {\n\tfor(int l = 0; l < 2; ++l) {\n\t  int lim = l ? 9 : s[i]-'0';\n\t  for(int d = 0; d <= lim; ++d) {\n\t    int nj = j%100*10+d;\n\t    int nk = j/10*100+d == 5103;\n\t    dp[i+1][nj][k||nk][l||d<lim] += dp[i][j][k][l];\n\t  }\n\t}\n      }\n    }\n  }\n\n  int ans = 0;\n  rep(i, 1000) {\n    rep(j, 2) {\n      if(~dp[n][i][1][j]) ans += dp[n][i][1][j];\n    }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring n;\nll dp[20][2][10][10][10];\n\nll dfs(ll id,ll f,ll a,ll b,ll c){\n  if(dp[id][f][a][b][c]!=-1)return dp[id][f][a][b][c];\n  if(id==(int)n.size())return 0;\n  ll r=9,res=0;\n  if(!f)r=n[id]-'0';\n  for(ll d=0;d<=r;d++){\n    ll nf=f;\n    if(d<r)nf=1;\n    if(a==5&&b==1&&d==3)\n      if(nf) res+=pow(10,n.size()-id-1);\n      else res+=stoi(n.substr(id+1))+1;\n    else res+=dfs(id+1,nf,b,c,d);\n  }\n  return dp[id][f][a][b][c]=res;\n}\n\nint main(){\n  cin>>n;\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<bits/stdc++.h>\nusing namespace std;\n#define inf INT_MAX\n#define INF LLONG_MAX\n#define ll long long\n#define ull unsigned long long\n#define M (int)(1e9+7)\n#define P pair<int,int>\n#define PLL pair<ll,ll>\n#define FOR(i,m,n) for(int i=(int)m;i<(int)n;i++)\n#define RFOR(i,m,n) for(int i=(int)m;i>=(int)n;i--)\n#define rep(i,n) FOR(i,0,n)\n#define rrep(i,n) RFOR(i,n,0)\n#define all(a) a.begin(),a.end()\n#define IN(a,n) rep(i,n){ cin>>a[i]; }\nconst int vx[4] = {0,1,0,-1};\nconst int vy[4] = {1,0,-1,0};\n#define PI 3.14159265\n#define F first\n#define S second\n#define PB push_back\n#define EB emplace_back\n#define int ll\n#define vi vector<int>\n#define IP pair<int,P>\n#define PP pair<P,P>\n#define Yes(f){cout<<(f?\"Yes\":\"No\")<<endl;}\n#define YES(f){cout<<(f?\"YES\":\"NO\")<<endl;}\n\n\nstring n;\nint dp[21][10010][3][3];\n\nbool judge(int n){\n  if((n/100)!=51) return false;\n  if(n%10!=3) return false;\n  return true;\n}\n\n\nsigned main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout<<fixed<<setprecision(20);\n  cin>>n;\n\n  dp[0][0][0][0]=1;\n  rep(i,n.size()+1){\n    rep(j,10000){\n      rep(k,10){\n        int nj=(j%1000*10+k);\n\n        dp[i+1][nj][1][1]+=dp[i][j][1][1];\n\n        if(judge(nj)) dp[i+1][nj][1][1]+=dp[i][j][0][1];\n        else dp[i+1][nj][0][1]+=dp[i][j][0][1];\n\n        if(k<n[i]-'0'){\n          dp[i+1][nj][1][1]+=dp[i][j][1][0];\n\n          if(judge(nj)) dp[i+1][nj][1][1]+=dp[i][j][0][0];\n          else dp[i+1][nj][0][1]+=dp[i][j][0][0];\n        }\n\n        if(k==n[i]-'0'){\n          dp[i+1][nj][1][0]+=dp[i][j][1][0];\n\n          if(judge(nj)) dp[i+1][nj][1][0]+=dp[i][j][0][0];\n          else dp[i+1][nj][0][0]+=dp[i][j][0][0];\n        }\n      }\n    }\n  }\n\n  int ans=0;\n  rep(j,10000){\n    rep(s,2){\n      ans+=dp[n.size()][j][1][s];\n    }\n  }\n\n  cout<<ans<<endl;\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  string s;\n  cin>>s;\n  Int n=s.size();\n  Int dp[20][4][2][2][10];\n  memset(dp,-1,sizeof(dp));\n  function<Int(Int,Int,Int,Int,Int)> dfs=\n    [&](Int pos,Int st,Int ok,Int lim,Int pre){\n    if(pos==n) return ok;\n    Int &res=dp[pos][st][ok][lim][pre];\n    if(~res) return res;\n    res=0;\n    for(Int i=0;i<=(lim?s[pos]-'0':9);i++){\n      Int nlim=lim&&(i==s[pos]-'0');\n      if(st==0&&i==5){\n\tres+=dfs(pos+1,1,ok,nlim,i);\n      }else if(st==1&&i==1){\n\tres+=dfs(pos+1,2,ok,nlim,i);\n      }else if(st==2){\n\tres+=dfs(pos+1,3,ok,nlim,i);\n      }else if(st==3){\n\tif(i==3) res+=dfs(pos+1,0,1,nlim,i);\n\telse if(pre==5&&i==1) res+=dfs(pos+1,2,ok,nlim,i);\n\telse res+=dfs(pos+1,i==5,ok,nlim,i);\n      }else res+=dfs(pos+1,i==5,ok,nlim,i);\n    }\n    //cout<<pos<<\" \"<<st<<\" \"<<ok<<\" \"<<lim<<\" \"<<pre<<\":\"<<res<<endl;\n    return res;\n  };\n  cout<<dfs(0,0,0,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst int DEBUG=0;\n\nconst int A=18;\n\nbool inc(vi &a,int lim){\n  int i=0;\n  while(i<(int)a.size()){\n    a[i]++;\n    if(a[i]<lim)return true;\n    a[i]-=lim;\n    i++;\n  }\n  return false;\n}\n\nlint pow10[A];\n\nbool match(lint n,lint pat,lint msk){\n  while(msk>0){\n    if(msk%10!=0){\n      if(n%10!=pat%10)return false;\n    }\n    msk/=10;\n    n/=10;\n    pat/=10;\n  }\n  return true;\n}\n\nlint calc(lint n,const vi &t){\n  int m=t.size();\n  rep(i,m-1){\n    if(t[i]+4>t[i+1])return 0;\n  }\n  if(t[m-1]>A-4)return 0;\n  lint pat=0,msk=0;\n  rep(i,m){\n    pat+=5103*pow10[t[i]];\n    msk+=1101*pow10[t[i]];\n  }\n  lint ans=0;\n  lint cur=1;\n  n++;\n  while(n>0){\n    if(msk%10==0){\n      if(match(n/10,pat/10,msk/10))ans+=cur*(n%10);\n      n/=10;\n      pat/=10;\n      msk/=10;\n      cur*=10;\n      continue;\n    }\n    if(match(n/10,pat/10,msk/10)&&n%10>pat%10)ans+=cur;\n    n/=10;\n    pat/=10;\n    msk/=10;\n  }\n  if(DEBUG&&ans!=0){\n    cerr<<\"t=\";\n    rep(i,m)cerr<<\" \"<<t[i];\n    cerr<<endl;\n    cerr<<\"ret=\"<<ans<<endl;\n  }\n  return ans;\n}\n\nint main(){\n  rep(i,A){\n    if(i==0)pow10[i]=1;\n    else pow10[i]=10*pow10[i-1];\n  }\n  lint n;\n  cin>>n;\n  lint ans=0;\n  rep(i,5){\n    if(i==0)continue;\n    vi t(i,0);\n    do{\n      ans+=(i%2==0?-1:1)*calc(n,t);\n    }while(inc(t,A));\n  }\n  cout<<ans<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n#define int ll\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define PB push_back\n\nconst ll LLINF = (1LL<<60);\nconst int INF = (1LL<<30);\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate <typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n  out<<'('<<a.first<<','<<a.second<<')';\n  return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n  out<<'[';\n  REP(i, a.size()) {out<<a[i];if(i!=a.size()-1)out<<',';}\n  out<<']';\n  return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\nint dp[20][1005][2][2];\nsigned main(void)\n{\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  string s;\n  cin >> s;\n  int n = s.size();\n\n  dp[0][0][0][0] = 1;\n  REP(i, n) REP(j, 1000) REP(k, 2) REP(l, 2) {\n    int lim = k ? 9 : s[i]-'0';\n    REP(nxt, lim+1) {\n      int cond = l || (j/100 == 5 && j%100/10 == 1 && nxt == 3);\n      dp[i+1][j%100*10 + nxt][k || nxt < lim][cond] += dp[i][j][k][l];\n      // if(cond==1) {\n      //   cout << i << \" \" << j << \" \" << k << \" \" << l << \" \" << nxt << endl;\n      //   cout << dp[i+1][j%100*10 + nxt][k || nxt < lim][cond] << \" \" << dp[i][j][k][l] << endl;\n      // }\n    }\n  }\n\n  int ans = 0;\n  REP(i, 1000) REP(j, 2) {\n    ans += dp[n][i][j][1];\n    // if(dp[n][i][j][1]) {\n    //   cout << i << \" \" << j << \" \" << dp[n][i][j][1] << endl;\n    // }\n  }\n  cout << ans << endl;\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];;\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\nll num_array[20];\nll dp[20][10000][2][2];\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%10000;\n}\n\nbool is_OK(ll number){\n\tstack<ll> S;\n\twhile(number > 0){\n\t\tS.push(number%10);\n\t\tnumber /= 10;\n\t}\n\tint index = 0;\n\tll work[4];\n\n\twhile(!S.empty()){\n\t\twork[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\treturn (work[0] == 5 && work[1] == 1 && work[3] == 3);\n}\n\nll recursive(ll pre_num,ll digit,Type type,bool is_completed){\n\n\tif(is_completed){\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0;\n\n\tif(dp[digit][pre_num][type][is_completed] != -1){\n\t\treturn dp[digit][pre_num][type][is_completed]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tll tmp;\n\n\tfor(int next = 0; next <= limit; next++){\n\t\ttmp =  getNUM(pre_num,next);\n\t\tret += recursive(tmp,digit+1,ELSE,is_completed||is_OK(tmp));\n\t}\n\n\tif(type == FULL_MATCH){\n\t\ttmp = getNUM(pre_num,num_array[digit]);\n\t\tret += recursive(tmp,digit+1,FULL_MATCH,is_completed||is_OK(tmp));\n\t}\n\n\treturn dp[digit][pre_num][type][is_completed] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9999; pre_num++){\n\t\t\tfor(int p = 0; p <= 1; p++){\n\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\tdp[digit][pre_num][p][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,false));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define REP(i,n) for(int i = 0;i < (int)(n);i++)\n#define RREP(i,n) for(int i = (int)n-1;i >= 0;i--)\n#define FOR(i,s,n) for(int i = s;i < (int)n;i++)\n#define RFOR(i,s,n) for(int i = (int)n-1;i >= s;i--)\n#define ALL(a) a.begin(),a.end()\n#define IN(a, x, b) (a<=x && x<b)\ntemplate<class T>inline bool CHMAX(T&a,T b){if(a<b){a = b;return true;}return false;}\ntemplate<class T>inline bool CHMIN(T&a,T b){if(a>b){a = b;return true;}return false;}\ntemplate<class T>inline void OUT(T t){cout<<t<<endl;}\ntemplate<class T,class... Ts>inline void OUT(T t,Ts... ts){cout<<t<<\" \";OUT(ts...);}\ntemplate<class T>istream&operator >>(istream&is,vector<T>&vec){for(T&x:vec)is>>x;return is;}\ntemplate<typename T=int>vector<T>mv(size_t a){return vector<T>(a);}\ntemplate<typename T=int,typename... Ts>auto mv(size_t a,Ts... ts){return vector<decltype(mv<T>(ts...))>(a,mv<T>(ts...));}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value==0>::type FILL(T&t,const V&v){t=v;}\ntemplate<typename T,typename V>typename enable_if<is_class<T>::value!=0>::type FILL(T&t,const V&v){for(auto &e:t)FILL(e,v);}\nconstexpr long long INF = 1e18;\n\nint dp[20][2][2][2][2][2];\n\nsigned main(){\n\tstring s;\n\tcin>>s;\n\tdp[0][1][0][0][0][0] = 1;\n\tREP(i,s.size()){\n\t\tREP(j,2){\n\t\t\tint lim = j ? s[i]-'0' : 9;\n\t\t\tREP(k,lim+1)REP(l,2)REP(m,2)REP(n,2)REP(o,2){\n\t\t\t\tdp[i+1][j&(k==lim)][k==5][l&(k==1)][m][(n&(k==3))|o]\n\t\t\t\t\t+= dp[i][j][l][m][n][o];\n\t\t\t}\n\t\t}\n\t}\n\tint ans = 0;\n\tREP(j,2)REP(l,2)REP(m,2)REP(n,2)ans += dp[s.size()][j][l][m][n][1];\n\tOUT(ans);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nstring N;\nlong long dp[21][10010][3][3]; // digit, last4, clear, smaller\n\nbool judge(int n) {\n  if ( (n/100) != 51) return false;\n  if (n % 10 != 3) return false;\n  return true;\n}\n\nint main() {\n  while (cin >> N) {\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0][0][0] = 1;\n\tfor (int i = 0; i <= N.size(); ++i) {\n\t  for (int j = 0; j <= 9999; ++j) {\n\t\tfor (int k = 0; k < 10; ++k) {\n\t\t  int nj = (j % 1000) * 10 + k;\n\n\t\t  // smaller -> smaller\n\t\t  {\n\t\t\t// clear -> clear\n\t\t\tdp[i+1][nj][1][1] += dp[i][j][1][1];\n\n\t\t\t// nonclear -> \n\t\t\tif (judge(nj)) dp[i+1][nj][1][1] += dp[i][j][0][1];\n\t\t\telse dp[i+1][nj][0][1] += dp[i][j][0][1];\n\t\t  }\n\n\t\t  // same -> smaller\n\t\t  if (k < (int)(N[i] - '0')) {\n\t\t\t// clear -> clear\n\t\t\tdp[i+1][nj][1][1] += dp[i][j][1][0];\n\n\t\t\t// nonclear ->\n\t\t\tif (judge(nj)) dp[i+1][nj][1][1] += dp[i][j][0][0];\n\t\t\telse dp[i+1][nj][0][1] += dp[i][j][0][0];\n\t\t  }\n\n\t\t  // same -> same\n\t\t  if (k == (int)(N[i] - '0')) {\n\t\t\t// clear -> clear\n\t\t\tdp[i+1][nj][1][0] += dp[i][j][1][0];\n\n\t\t\t// nonclear ->\n\t\t\tif (judge(nj)) dp[i+1][nj][1][0] += dp[i][j][0][0];\n\t\t\telse dp[i+1][nj][0][0] += dp[i][j][0][0];\n\t\t  }\n\t\t  \n\t\t}\n\t  }\n\t}\n\n\tlong long res = 0;\n\tfor (int j = 0; j <= 9999; ++j) {\n\t  for (int smaller = 0; smaller < 2; ++smaller) {\n\t\tres += dp[N.size()][j][1][smaller];\n\t  }\n\t}\n\n\tcout << res << endl;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <string> \n#include <cmath>  \n#include <cstdlib>\n#include <ctime>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n#include <cctype>\n#include <list>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n#define BIT(a) (1 << (a))\n#define EPS (1e-10)\n\nusing namespace std;\n//using namespace boost::multiprecision;\n\nconst long long MOD = 1000000007;\nconst int COUNTER_CLOCKWISE = 1;\nconst int CLOCKWISE = -1;\nconst int ONLINE_BACK = 2;\nconst int ONLINE_FRONT = -2;\nconst int ON_SEGMENT = 0;\n\nclass Point{\n    public:\n    double x, y;\n\n    Point(double x = 0, double y = 0): x(x), y(y) {}\n    \n    Point operator+(Point p){return Point(x + p.x, y + p.y);}\n    Point operator-(Point p){return Point(x - p.x, y - p.y);}\n    Point operator*(double a){return Point(a * x, a * y);}\n    Point operator/(double a){return Point(x / a, y / a);}\n\n    bool operator < (const Point &p) const {\n        return y != p.y ? y < p.y : x < p.x;\n    }\n\n    double norm(){return x * x + y * y;}\n};\ntypedef Point Vector;\ntypedef vector<Vector> Polygon;\n\ndouble cross(Vector a, Vector b){\n    return a.x*b.y - a.y*b.x;\n}\n\ndouble dot(Vector a, Vector b){\n    return a.x * b.x + a.y * b.y;\n}\n\nint ccw(Point p0, Point p1, Point p2){\n    Vector a = p1 - p0;\n    Vector b = p2 - p0;\n    if (cross(a, b) > EPS)return COUNTER_CLOCKWISE;\n    if (cross(a, b) > -EPS)return CLOCKWISE;\n    if (dot(a, b) < -EPS)return ONLINE_BACK;\n    if (a.norm() < b.norm())return ONLINE_FRONT;\n\n    return ON_SEGMENT;\n}\n\nPolygon andrewScan(Polygon s){\n    Polygon u, l;\n    if (s.size() < 3) return s;\n    sort(s.begin(), s.end());\n    u.push_back(s[0]);\n    u.push_back(s[1]);\n    l.push_back(s[s.size()-1]);\n    l.push_back(s[s.size()-2]);\n    \n    for (size_t i = 2; i < s.size(); i++){\n        for (size_t n = u.size(); n >= 2 && ccw(u[n-2], u[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            u.pop_back();\n        }\n        u.push_back(s[i]);\n    }\n\n    for (int i = (int)s.size() - 3; i >= 0; i--){\n        for (size_t n = l.size(); n >= 2 && ccw(l[n-2], l[n-1], s[i]) == COUNTER_CLOCKWISE; n--){\n            l.pop_back();\n        }\n        l.push_back(s[i]);\n    }\n\n    reverse(l.begin(), l.end());\n    for (size_t i = u.size() - 2; i >= 1; i--) l.push_back(u[i]);\n\n    return l;\n}\n\nlong long mod_pow(long long x, long long n){\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\nlong long dp[20][2][2][2][2][2];\n\nlong long digit_dp(string A){\n    int N = A.length();\n    memset(dp, 0, sizeof(dp));\n    dp[0][0][0][0][0][0] = 1;\n\n    for (int i = 0; i < N; i++){\n        for (int j = 0; j < 2; j++){\n            for (int k = 0; k < 2; k++){\n                for (int l = 0; l < 2; l++){\n                    for (int m = 0; m < 2; m++){\n                        for (int n = 0; n < 2; n++){\n                            int lim = j ? 9 : A[i] - '0';\n                            for (int d = 0; d < lim + 1; d++){\n                                dp[i+1][j || d < lim][d == 5][k && (d == 1)][l][(m && d == 3) || n] += dp[i][j][k][l][m][n];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    long long ret = 0;\n\n    for (int i = 0; i < 2; i++){\n        for (int j = 0; j < 2; j++){\n            for (int k = 0; k < 2; k++){\n                for (int l = 0; l < 2; l++){\n                    ret += dp[N][i][j][k][l][1];\n                }\n            }\n        }\n    }\n\n    return ret;\n}\n\nint main(void){\n    string N;\n    cin >> N;\n\n    cout << digit_dp(N) << endl;\n}   \n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll SHISHIMARU;\nll length,POW[16];\nll num_array[20];\nll dp[20][10000][2][2];\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%10000;\n}\n\nbool is_OK(ll number){\n\tif((number/1000)%10 != 5)return false;\n\tif(number-5000 <= 99 || number-5000 >= 200)return false;\n\tif(number%10 != 3)return false;\n\treturn true;\n}\n\nll recursive(ll pre_num,ll digit,Type type,bool is_completed){\n\n\tif(digit == length){\n\t\tif(is_completed)return 1;\n\t\telse{\n\t\t\treturn 0; //G数が成立しないならreturn 0;\n\t\t}\n\t}\n\n\tif(dp[digit][pre_num][type][is_completed] != -1){\n\t\treturn dp[digit][pre_num][type][is_completed]; //計算済ならreturn\n\t}\n\n\tif(is_completed == true && type == ELSE){\n\t\treturn dp[digit][pre_num][type][is_completed] = POW[length-digit];\n\t}else if(is_completed == true && type == FULL_MATCH){\n\t\treturn dp[digit][pre_num][type][is_completed] = (SHISHIMARU%POW[length-digit])+1;\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tll tmp;\n\n\tfor(int next = 0; next <= limit; next++){\n\t\ttmp =  getNUM(pre_num,next);\n\t\tret += recursive(tmp,digit+1,ELSE,is_completed||is_OK(tmp));\n\t}\n\n\tif(type == FULL_MATCH){\n\t\ttmp = getNUM(pre_num,num_array[digit]);\n\t\tret += recursive(tmp,digit+1,FULL_MATCH,is_completed||is_OK(tmp));\n\t}\n\n\treturn dp[digit][pre_num][type][is_completed] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tSHISHIMARU = N;\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9999; pre_num++){\n\t\t\tfor(int p = 0; p <= 1; p++){\n\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\tdp[digit][pre_num][p][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,false));\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n\tauto val = table(args...);\n\treturn std::vector<decltype(val)>(n, std::move(val));\n}\n\n\nll solve(ll n) {\n\tconst auto s = to_string(n);\n\tconst int m = s.size();\n\t// [pos][i - 3][i - 2][i - 1][already ok][strictly less]\n\tauto dp = table<ll>(m + 1, 10, 10, 10, 2, 2, 0);\n\tdp[0][0][0][0][0][0] = 1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int i3 = 0; i3 <= 9; ++i3) for (int i2 = 0; i2 <= 9; ++i2) for (int i1 = 0; i1 <= 9; ++i1) {\n\t\t\tfor (int aok = 0; aok <= 1; ++aok) {\n\t\t\t\tfor (int le = 0; le <= 1; ++le) {\n\t\t\t\t\tconst int lim = le ? 9 : s[i] - '0';\n\t\t\t\t\tfor (int add = 0; add <= lim; ++add) {\n\t\t\t\t\t\tint nok = aok || (i3 == 5 && i2 == 1 && add == 3);\n\t\t\t\t\t\tint nle = le || lim > add;\n\t\t\t\t\t\tdp[i + 1][i2][i1][add][nok][nle] += dp[i][i3][i2][i1][aok][le];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i <= 9; ++i) {\n\t\tfor (int j = 0; j <= 9; ++j) {\n\t\t\tfor (int k = 0; k <= 9; ++k) {\n\t\t\t\tans += dp[m][i][j][k][1][0] + dp[m][i][j][k][1][1];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tll N;\n\tcin >> N;\n\tcout << solve(N) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\n\n\nstring str;\nstring num = \"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\nint dfs(int pos,int less,int cnt,string s,int target){\n  cnt = min(1LL,cnt);\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt >= target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  int sum[10]={};\n  for(int i=0;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n\n  int ans = 0;\n  for(int i=1;i<5;i++) sum[i] += (i%2? 1:-1) * sum[i];\n  cout<<ans<<endl;\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstring N;\n\nlong dp[20][1000][2][2];\n\nlong gochiusa(int now, int back_three, bool if_gochiusa, bool if_less){\n    if(dp[now][back_three][if_gochiusa][if_less] != -1){\n        return dp[now][back_three][if_gochiusa][if_less];\n    }else if(now == N.size()){\n        return dp[now][back_three][if_gochiusa][if_less] = if_gochiusa;\n    }else if(if_gochiusa && if_less){\n        return dp[now][back_three][if_gochiusa][if_less] = gochiusa(now + 1, 0, true, true) * 10;\n    }else if(if_gochiusa){\n        return dp[now][back_three][if_gochiusa][if_less] = gochiusa(now + 1, 0, true, true) * (N[now] - '0') + gochiusa(now + 1, 0, true, false);\n    }else if(back_three / 10 == 51 && if_less){\n        long ans = 0;\n        for(int i = 0; i < 10; i++){\n            if(i == 3){\n                ans += gochiusa(now + 1, 0, true, true);\n            }else{\n                ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n            }\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans;\n    }else if(back_three / 10 == 51 && N[now] == '3'){\n        long ans = 0;\n        for(int i = 0; i < 3; i++){\n            ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans + gochiusa(now + 1, 0, true, true);\n    }else if(back_three / 10 == 51){\n        long ans = 0;\n        for(int i = 0; i < N[now] - '0'; i++){\n            if(i == 3){\n                ans += gochiusa(now + 1, 0, true, true);\n            }else{\n                ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n            }\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans + gochiusa(now + 1, back_three % 100 * 10 + N[now] - '0', false, false);\n    }else if(if_less){\n        long ans = 0;\n        for(int i = 0; i < 10; i++){\n            ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans;\n    }else{\n        long ans = 0;\n        for(int i = 0; i < N[now] - '0'; i++){\n            ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans + gochiusa(now + 1, back_three % 100 * 10 + N[now] - '0', false, false);\n    }\n}\n\nint main(){\n    cin >> N;\n    for(int i = 0; i < 20; i++){\n        for(int j = 0; j < 1000; j++){\n            for(int k = 0; k < 2; k++){\n                for(int l = 0; l < 2; l++){\n                    dp[i][j][k][l] = -1;\n                }\n            }\n        }\n    }\n    cout << gochiusa(0, 0, false, false) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll Stoi(string s){\n  ll res=0;\n  for(ll i=0;i<(int)s.size();i++)res=res*10+s[i]-'0';\n  return res;\n}\n\nstring n;\nll dp[20][2][10][10][10];\nll dfs(ll id,ll f,ll a,ll b,ll c){\n  if(dp[id][f][a][b][c]!=-1)return dp[id][f][a][b][c];\n  if(id==(int)n.size())return 0;\n  ll r=9,res=0;\n  if(!f)r=n[id]-'0';\n  for(ll d=0;d<=r;d++){\n    ll nf=f;\n    if(d<r)nf=1;\n    if(a==5&&b==1&&d==3)\n      if(nf) res+=pow(10,n.size()-id-1);\n      else res+=stoi(n.substr(id+1))+1;\n    else res+=dfs(id+1,nf,b,c,d);\n  }\n  return dp[id][f][a][b][c]=res;\n}\n\nint main(){\n  cin>>n;\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nstring s;\nint64 gochi[4] = {5, 1, -1, 3};\nint64 dp[20][2][5][10] = {};\n\nint64 dfs(int32 k = 0, bool tight = 1, int32 suc = 0, int32 lst = 0){\n\tif(k == s.size()) return suc == 4;\n\tint32 lim = (tight ? s[k]+1 : 10);\n\tint64 &res = dp[k][tight][suc][lst];\n\tif(~res) return res;\n\tres = 0;\n\tREP(i, lim){\n\t\tif(suc == 3 && lst == 5 && i == 1){\n\t\t\tres += dfs(k+1, tight && i == (lim-1), 2, i);\n\t\t}\n\t\tif(suc < 4 && (gochi[suc] == -1 || gochi[suc] == i)){\n\t\t\tres += dfs(k+1, tight && i == (lim-1), suc+1, i);\n\t\t}else if(suc == 4){\n\t\t\tres += dfs(k+1, tight && i == (lim-1), suc, i);\n\t\t}else{\n\t\t\tres += dfs(k+1, tight && i == (lim-1), gochi[0] == i, i);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tcin >> s;\n\tREP(i, s.size()) s[i] -= '0';\n\tmemset(dp, -1, sizeof dp);\n\tcout << dfs() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll Stoi(string s){\n  ll res=0;\n  for(ll i=0;i<(int)s.size();i++)res=res*10+s[i]-'0';\n  return res;\n}\n\nstring n;\nll dp[20][2][10][10][10];\nll dfs(ll id,ll f,ll a,ll b,ll c){\n  if(dp[id][f][a][b][c]!=-1)return dp[id][f][a][b][c];\n  if(id==(int)n.size())return 0;\n  ll r=9,res=0;\n  if(!f)r=n[id]-'0';\n  for(ll d=0;d<=r;d++){\n    ll nf=f;\n    if(d<r)nf=1;\n    if(a==5&&b==1&&d==3)\n      if(nf) res+=pow(10,n.size()-id-1);\n      else res+=stoi(n.substr(id+1))+1;\n    else res+=dfs(id+1,nf,b,c,d);\n  }\n  return dp[id][f][a][b][c]=res;\n}\n\nint main(){\n  cin>>n;\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n#include <climits>\n#include <cstring>\n\n#define rep(i, m, n) for(int i=int(m);i<int(n);i++)\n#define all(c) begin(c),end(c)\n\ntemplate<typename T1, typename T2>\ninline void chmin(T1 &a, T2 b) { if (a > b) a = b; }\n\ntemplate<typename T1, typename T2>\ninline void chmax(T1 &a, T2 b) { if (a < b) a = b; }\n\n//改造\ntypedef long long int ll;\nusing namespace std;\n#define INF (1 << 30) - 1\n#define INFl (ll)5e15\n#define DEBUG 0 //デバッグする時1にしてね\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#define MOD 1000000007\n\n\n//ここから編集する\nclass Solve {\npublic:\n    string S;\n#define AA 19\n    ll dp[AA][2][2][2][2][2];\n\n    void input() {\n        cin >> S;\n        memset(dp, -1, sizeof(dp));\n\n    }\n\n    ll rec(int N = 0, bool tight = true, int state1 = 0, int state2 = 0, int state3 = 0, int state4 = 0) {\n        if (dp[N][tight][state1][state2][state3][state4] != -1) return dp[N][tight][state1][state2][state3][state4];\n        if (N == S.size()) {\n            return state4;\n        }\n\n        int x = S[N] - '0';\n        int lim = tight ? x : 9;\n        ll ret = 0;\n        for (int i = 0; i <= lim; ++i) {\n//            rec(N+1,tight && i == lim, hoge, state1 + hoge, state2 + hoge, state3 + hoge);\n            int next1 = i == 5;\n            int next2 = (state1 == 1 && i == 1);\n            int next3 = state2;\n            int next4 = (state3 && i == 3) || state4;\n\n            ret += rec(N + 1, tight && i == lim, next1, next2, next3, next4);\n        }\n\n        return dp[N][tight][state1][state2][state3][state4] = ret;\n    }\n\n    void solve() {\n        input();\n        ll val = rec();\n        cout << val << endl;\n\n    }\n};\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    Solve().solve();\n\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length;\nll num_array[20];\nll dp[20][10000][2][2];\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%10000;\n}\n\nbool is_OK(ll number){\n\tstack<ll> S;\n\twhile(number > 0){\n\t\tS.push(number%10);\n\t\tnumber /= 10;\n\t}\n\tint index = 0;\n\tll work[4];\n\n\twhile(!S.empty()){\n\t\twork[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\treturn (work[0] == 5 && work[1] == 1 && work[3] == 3);\n}\n\nll recursive(ll pre_num,ll digit,Type type,bool is_completed){\n\n\tif(digit == length){\n\t\tif(is_completed)return 1;\n\t\telse{\n\t\t\treturn 0; //G数が成立しないならreturn 0;\n\t\t}\n\t}\n\n\tif(dp[digit][pre_num][type][is_completed] != -1){\n\t\treturn dp[digit][pre_num][type][is_completed]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tll tmp;\n\n\tfor(int next = 0; next <= limit; next++){\n\t\ttmp =  getNUM(pre_num,next);\n\t\tret += recursive(tmp,digit+1,ELSE,is_completed||is_OK(tmp));\n\t}\n\n\tif(type == FULL_MATCH){\n\t\ttmp = getNUM(pre_num,num_array[digit]);\n\t\tret += recursive(tmp,digit+1,FULL_MATCH,is_completed||is_OK(tmp));\n\t}\n\n\treturn dp[digit][pre_num][type][is_completed] = ret;\n}\n\n\nint main(){\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9999; pre_num++){\n\t\t\tfor(int p = 0; p <= 1; p++){\n\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\tdp[digit][pre_num][p][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,false));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<iostream>\n#include<vector>\nusing namespace std;\ntypedef long long lint;\ntypedef vector<int>vi;\ntypedef pair<int,int>pii;\n#define rep(i,n)for(int i=0;i<(int)(n);++i)\n\nconst int A=18;\nlint p10[A];\n\n\nlint dp[A+1][2][6];\nint dig[A];\n\nint nxt[6][10];\n\nint main(){\n  rep(i,A){\n    if(i==0)p10[i]=1;\n    else p10[i]=10*p10[i-1];\n  }\n  lint n;\n  cin>>n;\n  rep(i,A){\n    dig[i]=n%10;\n    n/=10;\n  }\n  dp[A][1][0]=1;\n  //states\n  nxt[0][5]=1;\n  nxt[1][1]=2;\n  nxt[1][5]=1;\n  rep(i,10)nxt[2][i]=3;\n  nxt[2][5]=4;\n  nxt[3][3]=5;\n  nxt[3][5]=1;\n  nxt[4][1]=2;\n  nxt[4][3]=5;\n  nxt[4][5]=1;\n  rep(i,10)nxt[5][i]=5;\n  for (int i=A-1;i>=0;--i){\n    rep(j,10){\n      rep(k,6){\n\tdp[i][0][nxt[k][j]]+=dp[i+1][0][k];\n      }\n    }\n    rep(j,dig[i]){\n      rep(k,6){\n\tdp[i][0][nxt[k][j]]+=dp[i+1][1][k];\n      }\n    }\n    rep(k,6)\n      dp[i][1][nxt[k][dig[i]]]+=dp[i+1][1][k];\n  }\n  cout<< dp[0][0][5]+dp[0][1][5]<<endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n\nstring N;\n\nlong dp[20][1000][2][2];\n\nlong gochiusa(int now, int back_three, bool if_gochiusa, bool if_less){\n    if(dp[now][back_three][if_gochiusa][if_less] != -1){\n        return dp[now][back_three][if_gochiusa][if_less];\n    }else if(now == N.size()){\n        return dp[now][back_three][if_gochiusa][if_less] = if_gochiusa;\n    }else if(if_gochiusa && if_less){\n        return dp[now][back_three][if_gochiusa][if_less] = gochiusa(now + 1, 0, true, true) * 10;\n    }else if(if_gochiusa){\n        return dp[now][back_three][if_gochiusa][if_less] = gochiusa(now + 1, 0, true, true) * (N[now] - '0') + gochiusa(now + 1, 0, true, false);\n    }else if(back_three / 10 == 51 && if_less){\n        long ans = 0;\n        for(int i = 0; i < 10; i++){\n            if(i == 3){\n                ans += gochiusa(now + 1, 0, true, true);\n            }else{\n                ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n            }\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans;\n    }else if(back_three / 10 == 51 && N[now] == '3'){\n        long ans = 0;\n        for(int i = 0; i < 3; i++){\n            ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans + gochiusa(now + 1, 0, true, false);\n    }else if(back_three / 10 == 51){\n        long ans = 0;\n        for(int i = 0; i < N[now] - '0'; i++){\n            if(i == 3){\n                ans += gochiusa(now + 1, 0, true, true);\n            }else{\n                ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n            }\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans + gochiusa(now + 1, back_three % 100 * 10 + N[now] - '0', false, false);\n    }else if(if_less){\n        long ans = 0;\n        for(int i = 0; i < 10; i++){\n            ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans;\n    }else{\n        long ans = 0;\n        for(int i = 0; i < N[now] - '0'; i++){\n            ans += gochiusa(now + 1, back_three % 100 * 10 + i, false, true);\n        }\n        return dp[now][back_three][if_gochiusa][if_less] = ans + gochiusa(now + 1, back_three % 100 * 10 + N[now] - '0', false, false);\n    }\n}\n\nint main(){\n    cin >> N;\n    for(int i = 0; i < 20; i++){\n        for(int j = 0; j < 1000; j++){\n            for(int k = 0; k < 2; k++){\n                for(int l = 0; l < 2; l++){\n                    dp[i][j][k][l] = -1;\n                }\n            }\n        }\n    }\n    cout << gochiusa(0, 0, false, false) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate <typename T> constexpr T inf;\ntemplate <> constexpr int inf<int> = 1e9;\ntemplate <> constexpr ll inf<ll> = 1e18;\ntemplate <> constexpr double inf<double> = 1e18;\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n \ntemplate <class... Args>\nauto table(int n, Args... args) {\n  auto val = table(args...);\n  return std::vector<decltype(val)>(n, std::move(val));\n}\n\n\nll solve(ll n) {\n    const auto s = to_string(n);\n    const int m = s.size();\n    // [pos][i - 3][i - 2][i - 1][already ok][strictly less]\n    auto dp = table<ll>(m + 1, 10, 10, 10, 2, 2, 0);\n    dp[0][0][0][0][0][0] = 1;\n    for(int i = 0; i < m; ++i) {\n        for(int i3 = 0; i3 <= 9; ++i3) for(int i2 = 0; i2 <= 9; ++i2) for(int i1 = 0; i1 <= 9; ++i1) {\n            for(int aok = 0; aok <= 1; ++aok) {\n                for(int le = 0; le <= 1; ++le) {\n                    const int lim = le ? 9 : s[i] - '0';\n                    for(int add = 0; add <= lim; ++add) {\n                        int nok = aok || (i3 == 5 && i2 == 1 && add == 3);\n                        int nle = le || s[i] - '0' > add;\n                        dp[i + 1][i2][i1][add][nok][nle] += dp[i][i3][i2][i1][aok][le];\n                    }\n                }\n            }\n        }\n    }\n\n    ll ans = 0;\n    for(int i = 0; i <= 9; ++i) {\n        for(int j = 0; j <= 9; ++j) {\n            for(int k = 0; k <= 9; ++k) {\n                ans += dp[m][i][j][k][1][0] + dp[m][i][j][k][1][1];\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    ll N;\n    cin >> N;\n    cout << solve(N) << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = __int128;\n\ntemplate<typename T>\nstd::vector<T> table(int n, T v) { return std::vector<T>(n, v); }\n\ntemplate <class... Args>\nauto table(int n, Args... args) {\n\tauto val = table(args...);\n\treturn std::vector<decltype(val)>(n, std::move(val));\n}\n\n\nll solve(ll n) {\n\tconst auto s = to_string(n);\n\tconst int m = s.size();\n\t// [pos][i - 3][i - 2][i - 1][already ok][strictly less]\n\tauto dp = table<ll>(m + 1, 10, 10, 10, 2, 2, 0);\n\tdp[0][0][0][0][0][0] = 1;\n\tfor (int i = 0; i < m; ++i) {\n\t\tfor (int i3 = 0; i3 <= 9; ++i3) for (int i2 = 0; i2 <= 9; ++i2) for (int i1 = 0; i1 <= 9; ++i1) {\n\t\t\tfor (int aok = 0; aok <= 1; ++aok) {\n\t\t\t\tfor (int le = 0; le <= 1; ++le) {\n\t\t\t\t\tconst int lim = le ? 9 : s[i] - '0';\n\t\t\t\t\tfor (int add = 0; add <= lim; ++add) {\n\t\t\t\t\t\tint nok = aok || (i3 == 5 && i2 == 1 && add == 3);\n\t\t\t\t\t\tint nle = le || s[i] - '0' > add;\n\t\t\t\t\t\tdp[i + 1][i2][i1][add][nok][nle] += dp[i][i3][i2][i1][aok][le];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tll ans = 0;\n\tfor (int i = 0; i <= 9; ++i) {\n\t\tfor (int j = 0; j <= 9; ++j) {\n\t\t\tfor (int k = 0; k <= 9; ++k) {\n\t\t\t\tans += dp[m][i][j][k][1][0] + dp[m][i][j][k][1][1];\n\t\t\t}\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\tlong long N;\n\tcin >> N;\n\tcout << (long long)solve(N) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, m, n) for (int i = m; i < n; ++i)\ntypedef long long ll;\n\nll dp[20][2][1000][2];\nint main() {\n  string S;\n  cin >> S;\n  int N = S.size();\n  dp[0][0][0][0] = 1;\n  rep(i, 0, N) rep(j, 0, 2) rep(k, 0, 1000) rep(l, 0, 2) {\n    int x = j ? 9 : S[i] - '0';\n    rep(d, 0, x + 1) {\n      dp[i + 1][j || d < x][(k % 100) * 10 + d][l || ((k / 10 == 51) && (d == 3))] += dp[i][j][k][l];\n    }\n  }\n  ll ans = 0;\n  rep(j, 0, 2) rep(k, 0, 1000) {\n    ans += dp[N][j][k][1];\n  }\n  cout << ans << endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nlong long dp[20][32][2] = {};\n\nint main() {\n    string s;\n    cin >> s;\n    int g[4] = { 5, 1, -1, 3 };\n    int n = s.size();\n    dp[0][0][1] = 1;\n    for (int i = 0; i < n + 1; ++i) {\n        for (int j = 0; j < 10; ++j) {\n            for (int k = 0; k < 16; ++k) {\n                int nex = k & 8;\n                if (j == g[0]) {\n                    nex |= 1;\n                }\n                for (int l = 0; l < 3; ++l) {\n                    if ((k >> l) & 1) {\n                        if (j == g[l + 1] || l + 1 == 2) {\n                            nex |= 1 << (l + 1);\n                        }\n                    }\n                }\n                dp[i + 1][nex][0] += dp[i][k][0];\n            }\n        }\n        for (int j = 0; j < s[i] - '0'; ++j) {\n            for (int k = 0; k < 16; ++k) {\n                int nex = k & 8;\n                if (j == g[0]) {\n                    nex |= 1;\n                }\n                for (int l = 0; l < 3; ++l) {\n                    if ((k >> l) & 1) {\n                        if (j == g[l + 1] || l + 1 == 2) {\n                            nex |= 1 << (l + 1);\n                        }\n                    }\n                }\n                dp[i + 1][nex][0] += dp[i][k][1];\n            }\n        }\n        for (int j = s[i] - '0'; j <= s[i] - '0'; ++j) {\n            for (int k = 0; k < 16; ++k) {\n                int nex = k & 8;\n                if (j == g[0]) {\n                    nex |= 1;\n                }\n                for (int l = 0; l < 3; ++l) {\n                    if ((k >> l) & 1) {\n                        if (j == g[l + 1] || l + 1 == 2) {\n                            nex |= 1 << (l + 1);\n                        }\n                    }\n                }\n                dp[i + 1][nex][1] += dp[i][k][1];\n            }\n        }\n    }\n    long long ans = 0;\n    for (int i = 8; i < 16; ++i) {\n        ans += dp[n][i][0] + dp[n][i][1];\n    }\n    cout << ans << \"\\n\";\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][2][10][10][10];\n\nstring num;\n\nint dfs(int x, int y, int p3, int p2, int p1 ){\n  \n  if( num.size() <= x ) return 0;\n  \n  if( dp[x][y][p3][p2][p1] != -1 ) return dp[x][y][p3][p2][p1];\n  \n  int res = 0;\n  \n  if( y == 0 ){\n    \n    int p = num[x] - '0';\n    \n    if( p3 == 5 && p2 == 1 && p == 3 ){\n      if( x != num.size() - 1 ) res += stoll(num.substr(x+1));\n      res++;\n    }\n    else res += dfs( x+1, 0, p2, p1, p );\n    \n    for(int i=0;i<num[x]-'0';i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\tif( x != num.size() - 1 ) res += stoll(num.substr(x+1));\n\tres++;\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n  \n  if( y == 1 ){\n    \n    for(int i=0;i<10;i++){\n      \n      if( p3 == 5 && p2 == 1 && i == 3 ){\n\t\n\tif( x != num.size() - 1 ){\n\t  \n\t  int X = 1;\n\t  \n\t  for(int j=0;j<num.size()-x-1;j++) X *= 10;\n\t  \n\t  res += X;\n\t}\n\telse res++;\n\t\n      }\n      else res += dfs( x+1, 1, p2, p1, i );\n      \n    }\n    \n  }\n\n  return dp[x][y][p3][p2][p1] = res;\n}\n\nsigned main(){\n  \n  cin>>num;\n  \n  memset( dp, -1, sizeof(dp) );\n  \n  cout<<dfs(0,0,0,0,0)<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nstring n;\nll dp[20][2][10][10][10];\n\nll dfs(ll id,ll f,ll a,ll b,ll c){\n  if(dp[id][f][a][b][c]!=-1)return dp[id][f][a][b][c];\n  if(id==(int)n.size())return 0;\n  ll r=9,res=0;\n  if(!f)r=n[id]-'0';\n  for(ll d=0;d<=r;d++){\n    ll nf=f;\n    if(d<r)nf=1;\n    if(a==5&&b==1&&d==3)\n      if(nf) res+=pow(10,n.size()-id-1);\n      else res+=stoi(n.substr(id+1))+1;\n    else res+=dfs(id+1,nf,b,c,d);\n  }\n  return dp[id][f][a][b][c]=res;\n}\n\nint main(){\n  cin>>n;\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint64_t DP[19][2][2][10][10][10];\n\nsigned main(){\n    ios::sync_with_stdio(false);\n\tcin.tie(0);\n    cout << fixed << setprecision(20);\n\n    string n;\n    cin >> n;\n    if (n.length() < 4){\n        cout << 0 << endl;\n        return 0;\n    }\n    DP[0][0][0][0][0][0] = 1;\n\n    for (int i = 0; i < n.length(); i++){\n        for (int j = 0; j <= 1; j++){\n            for (int k = 0; k <= 1; k++){\n                for (int a = 0; a < 10; a++){\n                    for (int b = 0; b < 10; b++){\n                        for (int c = 0; c < 10; c++){\n                            for (int d = 0; d < 10; d++){\n                                int pyonpyon = k == 1 or (a == 5 and b == 1 and d == 3);\n                                if (j == 1){\n                                    DP[i + 1][1][pyonpyon][b][c][d] += DP[i][j][k][a][b][c];\n                                    continue;\n                                }\n                                if (d > n[i] - '0')\n                                    continue;\n                                if (d == n[i] - '0')\n                                    DP[i + 1][0][pyonpyon][b][c][d] += DP[i][j][k][a][b][c];\n                                else\n                                    DP[i + 1][1][pyonpyon][b][c][d] += DP[i][j][k][a][b][c];\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    \n\n    int64_t ans = 0;\n    for (int a = 0; a < 10; a++){\n        for (int b = 0; b < 10; b++){\n            for (int c = 0; c < 10; c++){\n                ans += DP[n.length()][0][1][a][b][c];\n                ans += DP[n.length()][1][1][a][b][c];\n            }\n        }\n    }\n    cout << ans << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length;\nll num_array[20];\nll dp[20][10000][2][2];\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%10000;\n}\n\nbool is_OK(ll number){\n\tstack<ll> S;\n\twhile(number > 0){\n\t\tS.push(number%10);\n\t\tnumber /= 10;\n\t}\n\tint index = 0;\n\tll work[4];\n\n\twhile(!S.empty()){\n\t\twork[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\treturn (work[0] == 5 && work[1] == 1 && work[3] == 3);\n}\n\nll recursive(ll pre_num,ll digit,Type type,bool is_completed){\n\n\tif(digit == length){\n\t\tif(is_completed)return 1;\n\t\telse{\n\t\t\treturn 0; //G数が成立しないならreturn 0;\n\t\t}\n\t}\n\n\tif(dp[digit][pre_num][type][is_completed] != -1){\n\t\treturn dp[digit][pre_num][type][is_completed]; //計算済ならreturn\n\t}\n\n\tif(is_completed == true && type == ELSE){\n\t\treturn dp[digit][pre_num][type][is_completed] = pow(10,length-digit);\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tll tmp;\n\n\tfor(int next = 0; next <= limit; next++){\n\t\ttmp =  getNUM(pre_num,next);\n\t\tret += recursive(tmp,digit+1,ELSE,is_completed||is_OK(tmp));\n\t}\n\n\tif(type == FULL_MATCH){\n\t\ttmp = getNUM(pre_num,num_array[digit]);\n\t\tret += recursive(tmp,digit+1,FULL_MATCH,is_completed||is_OK(tmp));\n\t}\n\n\treturn dp[digit][pre_num][type][is_completed] = ret;\n}\n\n\nint main(){\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9999; pre_num++){\n\t\t\tfor(int p = 0; p <= 1; p++){\n\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\tdp[digit][pre_num][p][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,false));\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\nll dp[18][5][2]; //dp[桁数][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(next,digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(next,digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(next,digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(next,digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(next,digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(next,digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,3);\n\t\t\t//printf(\"FULL digit:%d next:%d マッチ3 ret:%lld\\n\",digit,num_array[digit],ret);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(num_array[digit],digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][match_num][p] = -1;\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(-1,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[20][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[20][10][5][2][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num,bool completed){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\tcompleted = true;\n\t}\n\n\tif(digit == length){\n\t\tif(completed)return 1;\n\t\telse{\n\t\t\treturn 0; //G数が成立しないならreturn 0;\n\t\t}\n\t}\n\n\tif(dp[digit][pre_num][pattern_match_num][type][completed] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type][completed]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1,completed);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0,completed);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2,completed);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1,completed);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0,completed);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3,completed);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4,completed);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1,completed);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2,completed);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0,completed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1,completed);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0,completed);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2,completed);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1,completed);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0,completed);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3,completed);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4,completed);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1,completed);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\n\t\t\t\t\t\t//ret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2,completed);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0,completed);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type][completed] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++){\n\t\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\t\tdp[digit][pre_num][match_num][p][k] = -1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0,false));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstring N;\nint dp[20][2][10];\nint rec(int i, bool less, int state) {\n    auto& DP = dp[i][less][state];\n    if (DP != INF) return DP;\n\n    if (i == SZ(N)) {\n        return DP = (state == 4);\n    }\n\n    int ret = 0;\n    REP(j, less ? 10 : N[i]-'0'+1) {\n        int next_state = state;\n        if (state == 0 && j == 5) next_state++;\n        else if (state == 1 && j == 1) next_state++;\n        else if (state == 2 && j == 5) next_state = 5;\n        else if (state == 2 && j != 5) next_state = 6;\n        else if ((state == 5 || state == 6) && j == 3) next_state = 4;\n        else if (state == 4);\n        else {\n            if (state == 5 && j == 1) {\n                next_state = 2;\n            } else if (j == 5) {\n                next_state = 1;\n            } else {\n                next_state = 0;\n            }\n        }\n        ret += rec(i+1, less || j!=(N[i]-'0'), next_state);\n    }\n    return DP = ret;\n}\nsigned main() {\n    REP(i, 20) REP(j, 2) REP(k, 10) dp[i][j][k] = INF;\n    cin >> N;\n    cout << rec(0, 0, 0) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += pow(10LL,n - idx - 1);\n    else res += dfs(nidx,nless,b ,c ,i);\n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nint dp[20][5][2][2];\nstring s,t=\"51?3\";\n\nint dfs(int idx,int mat,bool tight=true,bool ok=false){\n    if(idx==s.size())return ok;\n    int res=dp[idx][mat][tight][ok];\n    if(~res)return res;\n    res=0;\n    int x=s[idx]-'0';\n    int r=(tight?x:9);\n    for(int i=0;i<=r;i++){\n        int nxt=(i+'0'==t[mat])||(t[mat]=='?');\n        if(nxt&&!ok)res+=dfs(idx+1,mat+nxt,tight&&i==r,nxt+mat==4);\n        else if(ok)res+=dfs(idx+1,4,tight&&i==r,ok);\n        else res+=dfs(idx+1,0,tight&&i==r,ok);\n    }\n    return res;\n}\n\nsigned main(){\n    memset(dp,-1,sizeof(dp));\n    cin>>s;\n    cout<<dfs(0,0)<<endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[19][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[19][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[19][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\n#include <unordered_map>\nusing namespace std;\n\n#define REP(i, s) for (int i = 0; i < s; ++i)\n#define ALL(v) (v.begin(), v.end())\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P)\n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P)\n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s; }\ntemplate<class T> ostream& operator << (ostream &s, vector<vector<T> > P)\n{ for (int i = 0; i < P.size(); ++i) { s << endl << P[i]; } return s << endl; }\ntemplate<class T> ostream& operator << (ostream &s, set<T> P)\n{ EACH(it, P) { s << \"<\" << *it << \"> \"; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P)\n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nstring N;\nlong long dp[21][6][3]; // digit, dokomade, smaller\n\nint main() {\n  while (cin >> N) {\n\tmemset(dp, 0, sizeof(dp));\n\tdp[0][0][0] = 1;\n\tfor (int i = 0; i <= N.size(); ++i) {\n\t  for (int j = 0; j <= 4; ++j) {\n\t\t//\tcout << i << \", \" << j << \": \" << make_pair(dp[i][j][0], dp[i][j][1]) << endl;\n\t  }\t\t\t\t\t\t\t\t\t\t\n\n\t\tif (i == N.size()) continue;\n\t\t// smaller -> smaller\n\t\tdp[i+1][1][1] += dp[i][0][1];\n\t\tdp[i+1][0][1] += dp[i][0][1] * 9;\n\n\t\tdp[i+1][2][1] += dp[i][1][1];\n\t\t//dp[i+1][0][1] += dp[i][1][1] * 9;\n\t\tdp[i+1][1][1] += dp[i][1][1];\n\t\tdp[i+1][0][1] += dp[i][1][1] * 8;\n\n\t\tdp[i+1][3][1] += dp[i][2][1] * 10;\n\n\t\tdp[i+1][4][1] += dp[i][3][1];\n\t\t//dp[i+1][0][1] += dp[i][3][1] * 9;\n\t\tdp[i+1][1][1] += dp[i][3][1];\n\t\tdp[i+1][0][1] += dp[i][3][1] * 8;\n\n\t\tdp[i+1][4][1] += dp[i][4][1] * 10;\n\t\t\n\t\t// same -> smaller\n\t\tint a = 0, b = (int)(N[i] - '0'), c = 0;\n\t\tif ('5' < N[i]) {\n\t\t  ++a, --b;\n\t\t}\n\t\tdp[i+1][1][1] += dp[i][0][0] * a;\n\t\tdp[i+1][0][1] += dp[i][0][0] * b;\n\n\t\ta = 0, b = (int)(N[i] - '0'), c = 0;\n\t\tif ('1' < N[i]) {\n\t\t  ++a, --b;\n\t\t}\n\t\tif ('5' < N[i]) {\n\t\t  --b, ++c;\n\t\t}\n\t\tdp[i+1][2][1] += dp[i][1][0] * a;\n\t\tdp[i+1][0][1] += dp[i][1][0] * b;\n\t\tdp[i+1][1][1] += dp[i][1][0] * c;\n\t\t\n\n\t\ta = (int)(N[i] - '0');\n\t\tdp[i+1][3][1] += dp[i][2][0] * a;\n\t\t\n\n\t\ta = 0, b = (int)(N[i] - '0'), c = 0;\n\t\tif ('3' < N[i]) {\n\t\t  ++a, --b;\n\t\t}\n\t\tif ('5' < N[i]) {\n\t\t  --b, ++c;\n\t\t}\n\t\tdp[i+1][4][1] += dp[i][3][0] * a;\n\t\tdp[i+1][0][1] += dp[i][3][0] * b;\n\t\tdp[i+1][1][1] += dp[i][3][0] * c;\n\n\t\tdp[i+1][4][1] += dp[i][4][0] * (int)(N[i] - '0');\n\t\t\t\t\t\t\t\t  \n\n\n\t\t// same -> same\n\t\ta = 0, b = 1;\n\t\tif (N[i] == '5') a = 1, b = 0;\n\t\tdp[i+1][1][0] += dp[i][0][0] * a;\n\t\tdp[i+1][0][0] += dp[i][0][0] * b;\n\t\t\n\n\t\ta = 0, b = 1, c = 0;\n\t\tif (N[i] == '1') a = 1, b = 0;\n\t\telse if (N[i] == '5') a = 0, b = 0, c = 1;\n\t\tdp[i+1][2][0] += dp[i][1][0] * a;\n\t\tdp[i+1][0][0] += dp[i][1][0] * b;\n\t\tdp[i+1][1][0] += dp[i][1][0] * c;\n\t\t\n\n\t\tdp[i+1][3][0] += dp[i][2][0];\n\n\t\ta = 0, b = 1, c = 0;\n\t\tif (N[i] == '3') a = 1, b = 0;\n\t\telse if (N[i] == '5') a = 0, b= 0, c = 1;\n\t\tdp[i+1][4][0] += dp[i][3][0] * a;\n\t\tdp[i+1][0][0] += dp[i][3][0] * b;\n\t\tdp[i+1][1][0] += dp[i][3][0] * c;\n\t\t\n\n\t\tdp[i+1][4][0] += dp[i][4][0];\n\t}\n\n\tlong long res = dp[N.size()][4][0] + dp[N.size()][4][1];\n\n\tcout << res << endl;\n  }\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\ntypedef long long ll;\n\nchar s[25];\nll dp[25][2][2][5];\n\nint main(){\n  scanf(\"%s\",s);\n  int n = strlen(s);\n  dp[0][0][0][0] = 1;\n  REP(keta,n)REP(gochiusa,2)REP(less,2)REP(state,5){\n    int c = s[keta]-'0';\n    REP(d,10){\n      if(!less && (d>c))continue;\n      int nless = less || (d<c);\n      int nstate = 0;\n      if(state==0 && d==5)nstate = 1;\n      if(state==1 && d==1)nstate = 2;\n      if(state==2 && d!=5)nstate = 3;\n      if(state==2 && d==5)nstate = 4;\n      if(state==3 && d==3)nstate = 5;\n      if(state==4 && d==3)nstate = 5;\n      if(state==4 && d==1)nstate = 2;\n      int ngo = gochiusa || (nstate==5);\n      nstate %= 5;\n      if(nstate==0 && d==5)nstate = 1;\n      dp[keta+1][ngo][nless][nstate] += dp[keta][gochiusa][less][state];\n    }\n  }\n  ll ans = 0;\n  REP(less,2)REP(state,5)ans += dp[n][1][less][state];\n  printf(\"%lld\\n\",ans);\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//dp[桁][mod 10000][prefixがNと一致しているか][ごちうさ数だと確定したか] = 個数すれば良い。\n//一見、dp[桁][51?3のうち何文字とマッチしたか？][(同様なので略)]でできそうに見えるが、マッチしなかったときの遷移が、これだけでは一意に定まらないので\n//できない。例えば、(N=999999で) 515153をチェックするとき「515」までマッチするが次の「1」でマッチしない。しかし、次は「51」までマッチした状態から始める必要がある。\n//一方で、513153をチェックするとき「515」までマッチするが次の「5」でマッチしない。この場合は、次は「ノーマッチ」の状態から始める必要がある。(↑と状態を同一視できないことが分かる。）\n\n#include <iostream>\n#include <string>\n#define rep(i, n) for (i = 0; i < n; i++)\n#define int long long\nusing namespace std;\n\nbool check(int x) { if (x / 1000 == 5 && (x % 1000) / 100 == 1 && x % 10 == 3) return true; return false; }\nstring s;\nint dp[19][10000][2][2];\n\nsigned main() {\n\tint i, j, k, l, m;\n\t\n\tcin >> s;\n\tdp[0][0][1][0] = 1;\n\t\n\trep(i, s.length()) {\n\t\trep(j, 10000) {\n\t\t\trep(k, 2) {\n\t\t\t\trep(l, 2) {\n\t\t\t\t\trep(m, 10) {\n\t\t\t\t\t\tif (k == 1 && m > s[i] - '0') break;\n\t\t\t\t\t\tdp[i + 1][(j * 10 + m) % 10000][k && (m == s[i] - '0')][l || check((j * 10 + m) % 10000)] += dp[i][j][k][l];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tint ans = 0;\n\trep(j, 10000) rep(k, 2) ans += dp[s.length()][j][k][1];\n\tcout << ans << endl;\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass Int{\npublic:\n  string val;\n  Int():val(\"0\"){}\n  Int(string num,bool reversed=0){if(!reversed)R(num); val = num;}\n  Int(int num){val = to_string(num); R(val);}\n  \n  void R(string &a){reverse(a.begin(),a.end());}\n  bool neg(const string &a)const{return a.back() == '-';}\n  char& operator [] (int i){assert(i<(int)val.size());return val[i];}\n\n  bool operator ==  (Int b) {R(b.val); return *this == b.val;}\n  bool operator ==  (string b) {R(b);return val == b;}\n  template<class T> bool operator == (T b){return *this == Int(b);}\n  \n  bool operator !=  (Int b) {R(b.val); return *this != b.val;}\n  bool operator !=  (string b) {R(b);return !(val == b);}\n  template<class T> bool operator != (T b){return *this != Int(b);}\n  \n  bool operator >=  (Int b) {R(b.val); return *this >= b.val;}\n  bool operator >=  (string b) {return !(*this < b);}\n  template<class T> bool operator >= (T b){return *this >= Int(b);}\n\n  bool operator >   (Int b) {R(b.val); return *this > b.val;}\n  bool operator >   (string b) {return *this>=b && *this != b;}\n  template<class T> bool operator > (T b){return *this > Int(b);}\n\n  bool operator <=  (Int b) {R(b.val); return *this <= b.val;}\n  bool operator <=  (string b) {return *this<b || *this == b;}\n  template<class T> bool operator <= (T b){return *this <= Int(b);}\n\n  bool operator <   (Int b) {R(b.val); return *this < b.val;}\n  template<class T> bool operator < (T b){return *this < Int(b);}\n \n   bool operator <   (string b) {\n    R(b);\n    const string &a = val;\n    if(neg(a) != neg(b)) return neg(a)? 1:0;\n    if(a.size() != b.size()) return !neg(a)? (a.size()<b.size()):(a.size()>b.size());\n    for(int i=a.size()-1;i>=0;i--)if(a[i] != b[i]) return !neg(a)? a[i] < b[i]: a[i] > b[i];\n    return 0;\n  }\n  \n  Int operator + (string b){\n    R(b);\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(Int(a,1) < Int(b,1)) swap(a,b),swap(fa,fb);\n    \n    if(fa == fb){\n      a += '0';\n      for(int i=0;i<(int)a.size()-1;i++){\n        if(i < (int)b.size()) a[i] += b[i]-'0';\n        a[i+1] += (a[i]-'0')/10;\n        a[i] = (a[i]-'0')%10 + '0';\n      }\n      if(a.size() > 1 && a.back() == '0') a.pop_back();\n      if((int)a.size() > 1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    else {\n      for(int i=0;i<(int)a.size();i++){\n        if(i < (int)b.size()) a[i] -= b[i]-'0';\n        if(a[i]-'0' < 0) a[i]+=10, a[i+1]--; \n      }\n      while((int)a.size()>1 && a.back() == '0') a.pop_back();\n      if(a != \"0\") a += fa;\n    }\n    return Int(a,1);\n  }\n\n  Int operator * (string b){\n    R(b);\n    vector<int> res;\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = neg(b)? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(neg(b)) b.pop_back();\n    if(a.size() < b.size()) swap(a,b), swap(fa,fb);\n    if(a == \"0\" || b == \"0\") return Int(\"0\");\n    \n    for(int j=0;j<(int)b.size();j++)\n      for(int i=0;i<(int)a.size();i++){\n        if(i+j >= (int)res.size()) res.push_back(0);\n        res[i+j] += (a[i]-'0') * (b[j]-'0');\n      }\n    for(int i=0; i <(int)res.size(); i++) {\n      if(res[i]/10 == 0) continue;\n      if(i + 1 >= (int)res.size()) res.push_back(0);\n      res[i+1] += res[i]/10, res[i]=res[i]%10;\n    }\n    string sres;\n    for(int i:res) sres += char(i + '0');\n    if(fa != fb) sres += '-';\n    return Int(sres,1);\n  }\n\n  Int div(string b,int flg){\n    assert(b != \"0\");\n    string a = val;\n    string fa = neg(a)? \"-\":\"\";\n    string fb = b[0]=='-'? \"-\":\"\";\n    if(neg(a)) a.pop_back();\n    if(b[0]=='-') b.erase(b.begin());\n    Int mod(\"0\");\n    string d=\"0\";\n    for(int i=(int)a.size()-1;i>=0;i--){\n      mod = mod * 10 + (a[i] - '0');\n      while(mod >= b) mod -= b, d.back()+=1;\n      if(i && d != \"0\") d += '0'; \n    }\n    if(flg == 0 && d != \"0\" && (fa != fb)) d = \"-\" + d;\n    if(flg == 1 && mod != \"0\" && (fa == \"-\")) mod *= -1;\n    return flg==0? d:mod;\n  }\n  \n  Int operator + (Int b){R(b.val); return *this + b.val;}\n  template<class T> Int operator + (T b){return *this + Int(b);}\n  \n  Int operator * (Int b){R(b.val); return *this * b.val;}\n  template<class T> Int operator * (T b){return *this * Int(b);}\n\n  Int operator - (string b){b = (b[0] == '-')? b.substr(1):\"-\" + b;return *this + b;}\n  Int operator - (Int b){R(b.val); return *this - b.val;} \n  template<class T> Int operator - (T b){return *this - Int(b);}\n  \n  Int operator / (string b){return div(b,0);}\n  Int operator / (Int b){R(b.val);return div(b.val,0);}\n  template<class T> Int operator / (T b){return *this / Int(b);}\n  \n  Int operator % (string b){return div(b,1);}\n  Int operator % (Int b){R(b.val);return div(b.val,1);}\n  template<class T> Int operator % (T b){return *this % Int(b);}\n  \n  Int operator += (Int b){return *this = *this+b;}\n  Int operator += (string b){return *this = *this+b;}\n  template<class T> Int operator += (T b){return *this += Int(b);}\n  \n  Int operator -= (Int b){return *this = *this-b;}\n  Int operator -= (string b){return *this = *this-b;}\n  template<class T> Int operator -= (T b){return *this -= Int(b);}\n  \n  Int operator *= (Int b){return *this = *this*b;}\n  Int operator *= (string b){return *this = *this*b;}\n  template<class T> Int operator *= (T b){return *this *= Int(b);}\n  \n  Int operator /= (string b){return *this = *this/b;}\n  Int operator /= (Int b){return *this = *this/b;}\n  template<class T> Int operator /= (T b){return *this /= Int(b);}\n  \n  Int operator %= (string b){return *this = *this % b;}\n  Int operator %= (Int b){return *this=*this%b;}\n  template<class T> Int operator %= (T b){return *this %= Int(b);}\n  \n  Int operator ++(){return *this += 1;}\n  Int operator --(){return *this -= 1;}\n\n#ifdef int\n#undef int\n#define eraseIntDefine\n#endif\n  Int operator ++(int){\n    Int tmp = *this;\n    *this += 1;\n    return tmp;\n  }\n  \n  Int operator --(int){\n    Int tmp = *this;\n    *this -= 1;\n    return tmp;\n  }\n#ifdef eraseIntDefine\n#define int long long\n#endif\n\n  friend ostream& operator << (ostream& os,const Int a){\n    for(int i=(int)a.val.size()-1;i>=0;i--) os<<a.val[i];\n    return os;\n  }\n\n  friend istream& operator >> (istream& is,Int &a){\n    string num;\n    is>>num;\n    a = Int(num);\n    return is;\n  }\n  friend string to_string(Int a){reverse(a.val.begin(),a.val.end());return a.val;}\n};\n\n\nstring str;\nstring num = \"51?3\";\n\nInt mem[20][2][5][5][5];\nint used[20][2][5][5][5];\nInt dfs(int pos,int less,int cnt,string s,int target){\n  //cout<<pr(pos,less,cnt,s,target)<<endl;\n  if(pos == (int)str.size()) return cnt == target;\n  if(used[pos][less][cnt][s.size()][target]++) return mem[pos][less][cnt][s.size()][target];\n\n  int u = less? 9:str[pos]-'0';\n  \n  Int res = 0;\n  for(int i=0;i<=u;i++){\n    int npos = pos+1;\n    int nless = !(!less && i == u);\n    int ncnt = cnt;\n    string ns = s;\n    if(i + '0' == num[s.size()] || num[s.size()] == '?') ns += i+'0';\n    else if(i + '0' == num[0]) ns.clear(),ns += i+'0';\n    else ns = \"\";\n    if(ns.size() == 4) ncnt++,ns.clear();\n    res += dfs(npos,nless,ncnt,ns,target);\n    \n  }\n  return mem[pos][less][cnt][s.size()][target] = res;\n}\n\nsigned main(){\n  cin>>str;\n  Int sum[5]={};\n  for(int i=1;i<5;i++) sum[i] += dfs(0,0,0,\"\",i);\n\n  //for(int i=1;i<5;i++) cout<<pr(sum[i])<<endl;\n  \n  Int ans = 0;\n  for(int i=1;i<5;i++) ans += Int(i%2? 1:-1) * sum[i];\n  cout<<ans<<endl;\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll memo[18][2]; //memo[初めてG数が成立した桁数][先頭桁から、Nと数が一致し続けているか] = 残りの桁を埋める場合の数\n//ll dp[18][1000][5][2]; //dp[桁数][pre_num][パターンと一致している文字の数][先頭からNと数が一致し続けているか] = 場合の数\nll dp[18][10][5][2];\n\nll getNUM(ll pre_num,ll next){\n\t//return (10*pre_num+next)%1000;\n\treturn next;\n}\n\nll recursive(ll pre_num,ll digit,Type type, ll pattern_match_num){\n\n\tif(pattern_match_num == 4){ //digit-1桁目でG数が成立した場合\n\n\t\treturn memo[digit-1][type]; //残りの桁を埋める場合の数をreturn\n\t}\n\n\tif(digit == length)return 0; //G数が成立しないならreturn 0;\n\n\tif(dp[digit][pre_num][pattern_match_num][type] != -1){\n\t\treturn dp[digit][pre_num][pattern_match_num][type]; //計算済ならreturn\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tfor(int next = 0; next <= limit; next++){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(next == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(next == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t}else{\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(next == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,4);\n\t\t\t}else{\n\n\t\t\t\tif(next == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && next == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,next),digit+1,ELSE,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(type == FULL_MATCH){\n\t\tswitch(pattern_match_num){\n\t\tcase 0:\n\t\t\tif(num_array[digit] == 5){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t}else{\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tif(num_array[digit] == 1){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,3);\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tif(num_array[digit] == 3){\n\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,4);\n\t\t\t}else{\n\t\t\t\tif(num_array[digit] == 5){\n\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,1);\n\t\t\t\t}else{\n\t\t\t\t\tif(pre_num == 5 && num_array[digit] == 1){ //★★コーナーケース★★\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,2);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tret += recursive(getNUM(pre_num,num_array[digit]),digit+1,FULL_MATCH,0);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn dp[digit][pre_num][pattern_match_num][type] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){ //最速の成立は3桁目(0オリジン) よって、最大残桁は14\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\tll tmp = N;\n\n\t//Nを桁別に分解する\n\twhile(tmp > 0){\n\t\tS.push(tmp%10);\n\t\ttmp /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\tint rest_digit;\n\n\t//先頭からの一致がfalseの場合のmemoを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][ELSE] = POW[rest_digit];\n\t}\n\n\t//先頭からの一致がtrueの場合のメモを埋める\n\tfor(int digit = 3; digit <= length-1; digit++){\n\t\trest_digit = length-(digit+1);\n\t\tmemo[digit][FULL_MATCH] = (N%POW[rest_digit])+1; //+1は末尾0の分\n\t}\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\t//for(int pre_num = 0; pre_num <= 999; pre_num++){\n\t\tfor(int pre_num = 0; pre_num <= 9; pre_num++){\n\t\t\tfor(int match_num = 0; match_num <= 4; match_num++){\n\t\t\t\tfor(int p = 0; p <= 1; p++)dp[digit][pre_num][match_num][p] = -1;\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,0));\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstring N;\nint rec(int i, bool less, int state) {\n    if (i == SZ(N)) {\n        return (state >= 4) ? 1 : 0;\n    }\n\n    int ret = 0;\n    if (less) {\n        REP(j, 10) {\n            int next_state = state;\n            if ((state == 0 && j == 5)\n             || (state == 1 && j == 1)\n             || (state == 2)\n             || (state == 3 && j == 3)\n             || (state >= 4)) next_state++;\n            else {\n                if (state == 3 && j == 1) {\n                    next_state = 2;\n                } else {\n                    if (j == 5) next_state = 1;\n                    else next_state = 0;\n                }\n            }\n            ret += rec(i+1, true, next_state);\n        }\n    } else {\n        REP(j, N[i]-'0'+1) {\n            int next_state = state;\n            if ((state == 0 && j == 5)\n             || (state == 1 && j == 1)\n             || (state == 2)\n             || (state == 3 && j == 3)\n             || (state >= 4)) next_state++;\n            else {\n                if (state == 3 && j == 1) {\n                    next_state = 2;\n                } else {\n                    if (j == 5) next_state = 1;\n                    else next_state = 0;\n                }\n            }\n            ret += rec(i+1, j!=(N[i]-'0'), next_state);\n        }\n    }\n    return ret;\n}\nsigned main() {\n    cin >> N;\n    cout << rec(0, 0, 0) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\nstring s;\nint len;\n\nenum Ord {\n    Le, Eq, Gt,\n};\n\nint dp[20][2][2][10000];\n\nbool is_gochiusa(int x) {\n    if (x / 1000 % 10 != 5) return false;\n    if (x / 100 % 10 != 1) return false;\n    if (x / 1 % 10 != 3) return false;\n    return true;\n}\n\nint rec(int k, Ord ord, bool done, int tail) {\n    int &ans = dp[k][ord][done][tail];\n    if (ans != -1) return ans;\n\n    ans = 0;\n    if (k == len) {\n        ans = done ? 1 : 0;\n    } else {\n        int d = s[k] - '0';\n        rep(nd, 10) {\n            Ord nord;\n            if (ord == Le || ord == Gt) {\n                nord = ord;\n            } else {\n                nord = nd < d ? Le : nd == d ? Eq : Gt;\n            }\n            if (nord == Gt) continue;\n            int ntail = (tail * 10 + nd) % 10000;\n            bool ndone = done || is_gochiusa(ntail);\n            ans += rec(k + 1, nord, ndone, ntail);\n        }\n    }\n    return ans;\n}\n\nsigned main() {\n    cin >> s;\n    len = s.size();\n    memset(dp, -1, sizeof dp);\n    cout << rec(0, Eq, false, 0) << endl;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint pow10(int x){\n  if(x == 0) return 1;\n  return 10 * pow10(x-1);\n}\n\nint cnt(int x,int less){\n  if(x == n) return 1;\n  if(less) return pow10(n - x);\n  assert(0);\n  int a =  cnt(x+1,0);\n  int b = (num[x] - '0') * cnt(x+1,1);\n  return a + b;\n}\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += cnt(nidx,nless);\n    else res += dfs(nidx,nless,b ,c ,i);\n    \n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint pow10(int x){\n  if(x == 0) return 1;\n  return 10 * pow10(x-1);\n}\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += pow10(n - idx - 1);\n    else res += dfs(nidx,nless,b ,c ,i);\n    \n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll dp[20][2][10][10][10],z;\nstring n;\n\nll Stoi(string s){\n  ll res=0;\n  for(int i=0;i<s.size();i++)res=res*10+s[i]-'0';\n  return res;\n}\n\nll Pow(ll a,ll b){\n  ll res=1;\n  while(b--)res*=a;\n  return res;\n}\n\nll dfs(ll id,ll f,ll a,ll b,ll c){\n  if(dp[id][f][a][b][c]!=-1)return dp[id][f][a][b][c];\n  if(id==(int)n.size())return 0;\n  ll l=0,r=9,res=0;\n  if(f)r=n[id]-'0';\n  for(ll d=l;d<=r;d++){\n    ll nf=f;\n    if(d<r)nf=1;\n    if(a==5&&b==1&&d==3){\n      if(f)return Pow(10,n.size()-id-1);\n      else return Stoi(n.substr(id+1))+1;\n    }\n    else{\n      res+=dfs(id+1,nf,b,c,d);\n    }\n  }\n  return dp[id][f][a][b][c]=res;\n}\n\nint main(){\n  cin>>n;\n  memset(dp,-1,sizeof(dp));\n  cout<<dfs(0,0,0,0,0)<<endl;\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFULL_MATCH,\n\tELSE,\n};\n\nll length,POW[16];\nll num_array[20];\nll dp[20][10000][2][2];\n\nll getNUM(ll pre_num,ll next){\n\treturn (10*pre_num+next)%10000;\n}\n\nbool is_OK(ll number){\n\tif((number/1000)%10 != 5)return false;\n\tif(number-5000 <= 99 || number-5000 >= 200)return false;\n\tif(number%10 != 3)return false;\n\treturn true;\n}\n\nll recursive(ll pre_num,ll digit,Type type,bool is_completed){\n\n\tif(digit == length){\n\t\tif(is_completed)return 1;\n\t\telse{\n\t\t\treturn 0; //G数が成立しないならreturn 0;\n\t\t}\n\t}\n\n\tif(dp[digit][pre_num][type][is_completed] != -1){\n\t\treturn dp[digit][pre_num][type][is_completed]; //計算済ならreturn\n\t}\n\n\tif(is_completed == true && type == ELSE){\n\t\treturn dp[digit][pre_num][type][is_completed] = POW[length-digit];\n\t}\n\n\tll ret = 0;\n\tll limit;\n\tif(type == FULL_MATCH){\n\t\tlimit = num_array[digit]-1;\n\t}else{\n\t\tlimit = 9;\n\t}\n\n\tll tmp;\n\n\tfor(int next = 0; next <= limit; next++){\n\t\ttmp =  getNUM(pre_num,next);\n\t\tret += recursive(tmp,digit+1,ELSE,is_completed||is_OK(tmp));\n\t}\n\n\tif(type == FULL_MATCH){\n\t\ttmp = getNUM(pre_num,num_array[digit]);\n\t\tret += recursive(tmp,digit+1,FULL_MATCH,is_completed||is_OK(tmp));\n\t}\n\n\treturn dp[digit][pre_num][type][is_completed] = ret;\n}\n\n\nint main(){\n\n\tfor(int i = 0; i < 16; i++){\n\t\tPOW[i] = pow(10,i);\n\t}\n\n\tll N;\n\tscanf(\"%lld\",&N);\n\n\tif(N <= 5102){\n\t\tprintf(\"0\\n\");\n\t\treturn 0;\n\t}\n\n\tstack<ll> S;\n\n\t//Nを桁別に分解する\n\twhile(N > 0){\n\t\tS.push(N%10);\n\t\tN /= 10;\n\t}\n\n\tll index = 0;\n\n\twhile(!S.empty()){\n\t\tnum_array[index++] = S.top();\n\t\tS.pop();\n\t}\n\n\tlength = index;\n\n\tfor(int digit = 0; digit <= length-1; digit++){\n\t\tfor(int pre_num = 0; pre_num <= 9999; pre_num++){\n\t\t\tfor(int p = 0; p <= 1; p++){\n\t\t\t\tfor(int k = 0; k <= 1; k++){\n\t\t\t\t\tdp[digit][pre_num][p][k] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tprintf(\"%lld\\n\",recursive(0,0,FULL_MATCH,false));\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\nsigned main(){\n  string s;\n  cin>>s;\n  Int n=s.size();\n  Int dp[20][4][2][2][10];\n  memset(dp,-1,sizeof(dp));\n  function<Int(Int,Int,Int,Int,Int)> dfs=\n    [&](Int pos,Int st,Int ok,Int lim,Int pre){\n    if(pos==n) return ok;\n    Int &res=dp[pos][st][ok][lim][pre];\n    if(~res) return res;\n    res=0;\n    for(Int i=0;i<=(lim?s[pos]-'0':9);i++){\n      Int nlim=lim&&(i==s[pos]-'0');\n      if(st==0&&i==5){\n\tres+=dfs(pos+1,1,ok,nlim,i);\n      }else if(st==1&&i==1){\n\tres+=dfs(pos+1,2,ok,nlim,i);\n      }else if(st==2){\n\tres+=dfs(pos+1,3,ok,nlim,i);\n      }else if(st==3){\n\tif(i==3) res+=dfs(pos+1,0,1,nlim,i);\n\telse if(pre==5&&i==1) res+=dfs(pos+1,2,ok,nlim,i);\n\telse res+=dfs(pos+1,i==5,ok,nlim,i);\n      }else res+=dfs(pos+1,i==5,ok,nlim,i);\n    }\n    //cout<<pos<<\" \"<<st<<\" \"<<ok<<\" \"<<lim<<\" \"<<pre<<\":\"<<res<<endl;\n    return res;\n  };\n  cout<<dfs(0,0,0,1,0)<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nll mypow(ll a,ll b){\n  ll res=1;\n  for(ll i=0;i<b;i++)\n    res*=a;\n  return res;\n}\n\nstring s;\nint len;\nll dp[20][10][10][10][2];\n\nll rec(int d,int x,int y,int z,int f){\n  if( d== len )return 0;\n\n  if( dp[d][x][y][z][f]!=-1 )return dp[d][x][y][z][f];\n  \n  int left=0,right=9;\n  if(f)right=s[d]-'0';\n\n  ll res=0;\n  for(ll i=left;i<=right;i++){\n    int nf=f;\n    if(i < right)nf=0;\n    if( x==5 && y==1 && i==3 ){\n      ll last=len-d-1;\n      if(nf==1){\n        ll num=0;\n        for(int j=d+1;j<len;j++)num=num*10LL + ( s[j]-'0');\n        res+=(num+1);\n      }else{\n        res+= mypow(10,last);\n      }\n    }else{\n      res+=rec(d+1,y,z,i,nf);\n    }\n  }\n  \n  return dp[d][x][y][z][f]=res;\n}\n\nint main(){\n  for(int i=0;i<20;i++)\n    for(int j=0;j<10;j++)\n      for(int k=0;k<10;k++)\n        for(int l=0;l<10;l++)\n          for(int m=0;m<2;m++)\n            dp[i][j][k][l][m]=-1;\n  \n  cin>>s;\n  len=s.size();\n  cout<< rec(0,0,0,0,1) <<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\nstring s;\nint64 gochi[4] = {5, 1, -1, 3};\nint64 dp[20][2][5] = {};\n\nint64 dfs(int32 k = 0, bool tight = 1, int32 suc = 0){\n\tif(k == s.size()) return suc == 4;\n\tint32 lim = (tight ? s[k]+1 : 10);\n\tint64 &res = dp[k][tight][suc];\n\tif(~res) return res;\n\tres = 0;\n\tREP(i, lim){\n\t\tif(suc == 2 && i == 5)\n\t\t\tres += dfs(k+1, tight && i== (lim-1), 1);\n\t\tif(suc < 4 && (gochi[suc] == -1 || gochi[suc] == i)){\n\t\t\tres += dfs(k+1, tight && i == (lim-1), suc+1);\n\t\t}else if(suc == 4){\n\t\t\tres += dfs(k+1, tight && i == (lim-1), suc);\n\t\t}else{\n\t\t\tres += dfs(k+1, tight && i == (lim-1), gochi[0] == i);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tcin >> s;\n\tREP(i, s.size()) s[i] -= '0';\n\tmemset(dp, -1, sizeof dp);\n\tcout << dfs() << endl;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint pow10(int x){\n  if(x == 0) return 1;\n  return 10 * pow10(x-1);\n}\n\nint cnt(int x,int less){\n  if(x == n) return 1;\n  if(less) return pow10(n - x);\n  int res = (n - x - 1) * cnt(x+1,0);\n  res += cnt(x+1,1);\n  return res;\n}\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += cnt(nidx,nless);\n    else res += dfs(nidx,nless,b ,c ,i);\n    \n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <queue>\n#include <numeric>\n#include <vector>\n#include <map>\n#define int long long\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\n// i-th digit, 52?3 state, less flg\nint dp[20][10][10];\n\nstring s;\nint len;\n\nenum Ord {\n    Less, Eq\n};\n\nint rec(int i, int state, Ord ord) {\n    int &ans = dp[i][state][ord];\n    if (ans != -1) return ans;\n\n    ans = 0;\n    if (i == len) {\n        ans = state == 4 ? 1 : 0;\n    } else {\n        int d = s[i] - '0';\n        rep(nx, 10) {\n            Ord nord;\n            if (ord == Less) {\n                nord = Less;\n            } else if (nx <= d) {\n                nord = nx < d ? Less : Eq;\n            } else {\n                continue;\n            }\n            int nstate = -1;\n            if (state == 0 && nx == 5) {\n                nstate = 1;\n            } else if (state == 1 && nx == 1) {\n                nstate = 2;\n            } else if (state == 2) {\n                nstate = 3;\n            } else if (state == 3 && nx == 3) {\n                nstate = 4;\n            } else if (state == 4) {\n                nstate = 4;\n            } else if (nx == 5) {\n                nstate = 1;\n            } else {\n                nstate = 0;\n            }\n            ans += rec(i + 1, nstate, nord);\n        }\n    }\n    // cout << i << ' ' << state << ' ' << ord << ' ' << ans << endl;\n    return ans;\n}\n\nsigned main() {\n    while (cin >> s) {\n        memset(dp, -1, sizeof dp);\n        len = s.size();\n        cout << rec(0, 0, Eq) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define pr1(a) (#a)<<\"=\"<<(a)\n#define pr2(a,b) pr1(a)<<\", \"<<pr1(b)\n#define pr3(a,b,c) pr2(a,b)<<\", \"<<pr1(c)\n#define pr4(a,b,c,d) pr3(a,b,c)<<\", \"<<pr1(d)\n#define pr5(a,b,c,d,e) pr4(a,b,c,d)<<\", \"<<pr1(e)\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nint n;\nstring str;\nstring num=\"51?3\";\n\nint mem[20][2][10][10][10];\nint used[20][2][10][10][10];\n\n\nint pow10(int x){\n  if(x == 0) return 1;\n  return 10 * pow10(x-1);\n}\n\nint cnt(int x,int less){\n  if(x == n) return 1;\n  if(less) return pow10(n - x);\n  assert(0);\n  int a =  cnt(x+1,0);\n  int b = (str[x] - '0') * cnt(x+1,1);\n  return a + b;\n}\n\nint dfs(int idx=0,int less=0,int a=0,int b=0,int c=0){\n\n  if(idx == n) return 0;\n  if(used[idx][less][a][b][c]++) return mem[idx][less][a][b][c];\n  \n  int u = less? 9:str[idx]-'0';\n  int res = 0;\n  for(int i=0;i<=u;i++){\n    int nidx = idx+1;\n    int nless = less || (i != u);\n    if(a == 5 && b == 1 && i == 3) res += cnt(nidx,nless);\n    else res += dfs(nidx,nless,b ,c ,i);\n    \n  }\n  return mem[idx][less][a][b][c] = res;\n}\n\nsigned main(){\n  cin>>str;\n  n = str.size();\n\n  int ans = dfs();\n  cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define debug(...) fprintf(stderr, __VA_ARGS__)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\nint dp[20][5][2][10];\n\nvoid print_debug(int a, int b, int c, int x, int y, int z, int val) {\n    /*\n    if(dp[x][y][z]) {\n        printf(\"move: %lld, %lld, %lld <- %lld, %lld, %lld (value = %lld, digit = %lld)\\n\", a, b, c, x, y, z, dp[x][y][z], val);\n    }\n    */\n}\n \nsigned main() {\n    int init_val; cin >> init_val;\n    string s = to_string(init_val);\n    int N = s.length();\n\n    dp[0][0][0][0] = 1;\n    string pat = \"51?3\";\n    for(int i=0; i<N; i++) {\n        for(int k=0; k<4; k++) {\n            for(int f=0; f<2; f++) {\n                for(int y=0; y<10; y++) {\n                    int lim = f ? 9 : s[i] - '0';\n                    for(int x=0; x<lim+1; x++) {\n                        bool is_match = (pat[k] == '?' || pat[k] - '0' == x);\n                        if(is_match) {\n                            if(k+1 != 4) {\n                                dp[i+1][k+1][f || x<lim][x] += dp[i][k][f][y];\n                                // print_debug(i+1, k+1, f||x<lim, i, k, f, x);\n                            }\n                        }\n                        else {\n                            int nidx;\n                            if(k == 3 && y == 5 && x == 1) nidx = 2;\n                            else nidx = (x == 5);\n                            dp[i+1][nidx][f || x < lim][x] += dp[i][k][f][y];\n                            // print_debug(i+1, 0, f||x<lim, i, k, f, x);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    int sum = -1;\n    for(int i=0; i<4; i++) {\n        for(int j=0; j<2; j++) {\n            for(int k=0; k<10; k++) {\n                sum += dp[N][i][j][k];\n            }\n            // printf(\"dp[%lld][%lld][%lld] = %lld\\n\", N, i, j, dp[N][i][j]);\n        }\n    }\n    cout << init_val - sum << endl;\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a < b) ? (a = b, 1) : 0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b < a) ? (a = b, 1) : 0;}\n\nusing ll = long long;\nusing R = long double;\nconst R EPS = 1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r) {return (r > EPS) - (r < -EPS);}\ninline R sq(R x) {return sqrt(max(x, 0.0L));}\n\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\n// Problem Specific Parameter:\n\nstring s;\nll dp[20][20][2][2];\n\nint total = 0;\nint table[20][10];\nstring node[20];\n\nint main(void) {\n\tcin >> s;\n\tconst int n = s.size();\n\n\tnode[total++] = \"\";\n\tnode[total++] = \"5\";\n\tnode[total++] = \"51\";\n\n\trep(d, 10) {\n\t\tstring cur = to_string(510 + d);\n\t\tnode[total++] = cur;\n\t}\n\n\trep(i, total) {\n\t\trep(d, 10) {\n\t\t\tif (node[i].size() == 3 and d == 3) {\n\t\t\t\ttable[i][d] = total;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tstring nxt = node[i] + string(1, char(d + '0'));\n\t\t\tconst int m = nxt.size();\n\n\t\t\tbool ok = false;\n\t\t\trrep(len, m + 1) {\n\t\t\t\tstring tmp = nxt.substr(m - len, len);\n\t\t\t\trep(j, total) {\n\t\t\t\t\tif (ok) break;\n\t\t\t\t\tif (tmp == node[j]) {\n\t\t\t\t\t\ttable[i][d] = j;\n\t\t\t\t\t\tok = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\trep(d, 10) table[total][d] = total;\n\n\t/*\n\trep(i, total + 1) {\n\t\tcerr << node[i] << \" : \";\n\t\trep(j, 10) cerr << table[i][j] << \" \";\n\t\tcerr << endl;\n\t}\n\t*/\n\n\n\n\tdp[0][0][0][0] = 1LL;\n\trep(i, n)rep(st, total + 1)rep(nz, 2)rep(le, 2) {\n\t\tif (dp[i][st][nz][le] == 0) continue;\n\t\trep(d, 10) {\n\t\t\tconst int ni = i + 1;\n\t\t\tconst int nst = table[st][d];\n\n\t\t\tconst int nnz = nz || (d != 0);\n\n\t\t\tint nle = le;\n\t\t\tif (le == 0 and d > (s[i] - '0')) continue;\n\t\t\tif (le == 0 and d < (s[i] - '0')) nle = 1;\n\n\t\t\tdp[ni][nst][nnz][nle] += dp[i][st][nz][le];\n\t\t}\n\t}\n\n\tll ans = dp[n][total][1][0] + dp[n][total][1][1];\n\tcout << ans << endl;\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define stoi stoll\nusing ll=long long;\nusing vi=vector<int>;\nusing pii=pair<int,int>;\n#define ALL(c) begin(c),end(c)\n#define RALL(c) rbegin(c),rend(c)\n#define ITR(i,b,e) for(auto i=(b);i!=(e);++i)\n#define FORE(x,c) for(auto &x:c)\n#define REPF(i,a,n) for(int i=a,i##len=(int)(n);i<i##len;++i)\n#define REP(i,n) REPF(i,0,n)\n#define REPR(i,n) for(int i=(int)(n);i>=0;--i)\n#define SZ(c) ((int)c.size())\n#define CONTAIN(c,x) (c.find(x)!=end(c))\n#define OUTOFRANGE(y,x,h,w) ((y)<0||(x)<0||(y)>=(h)||(x)>=(w))\n#define dump(...)\nconst signed INF_=1001001001; const long long INF=1001001001001001001LL;\nconst int DX[9]={0,1,0,-1,1,1,-1,-1,0},DY[9]={-1,0,1,0,-1,1,1,-1,0};\ntemplate<class T> ostream& operator<<(ostream &os,const vector<T> &v) {\n    ITR(i,begin(v),end(v))os<<*i<<(i==end(v)-1?\"\":\" \");return os;}\ntemplate<class T> istream& operator>>(istream &is,vector<T> &v) {\n    ITR(i,begin(v),end(v)) is>>*i;return is;}\ntemplate<class T,class U> istream& operator>>(istream &is, pair<T,U> &p) {\n    is>>p.first>>p.second;return is;}\ntemplate<class T> bool chmax(T &a,const T &b){if(a<b){a=b;return 1;}return 0;}\ntemplate<class T> bool chmin(T &a,const T &b){if(a>b){a=b;return 1;}return 0;}\ntemplate<class T> using heap=priority_queue<T,vector<T>,greater<T>>;\nstruct{template<class T> operator T(){T x;cin>>x;return x;}} IN;\nstruct before_main_function {\n    before_main_function() {\n        cin.tie(0);ios::sync_with_stdio(false);\n        cout<<setprecision(15)<<fixed;\n        #define endl \"\\n\"\n    }\n} before_main_function;\n//------------------8<------------------------------------8<--------------------\n\nstring N;\nint rec(int i, bool less, int state) {\n    if (i == SZ(N)) {\n        return (state >= 4) ? 1 : 0;\n    }\n\n    int ret = 0;\n    if (less) {\n        REP(j, 10) {\n            int next_state = state;\n            if ((state == 0 && j == 5)\n             || (state == 1 && j == 1)\n             || (state == 2)\n             || (state == 3 && j == 3)\n             || (state >= 4)) next_state++;\n            else {\n                if (state == 3 && j == 1) next_state = 2;\n                else if (j == 5) next_state = 1;\n                else next_state = 0;\n            }\n            ret += rec(i+1, true, next_state);\n        }\n    } else {\n        REP(j, N[i]-'0'+1) {\n            int next_state = state;\n            if ((state == 0 && j == 5)\n             || (state == 1 && j == 1)\n             || (state == 2)\n             || (state == 3 && j == 3)\n             || (state >= 4)) next_state++;\n            else {\n                if (state == 3 && j == 1) next_state = 2;\n                else if (j == 5) next_state = 1;\n                else next_state = 0;\n            }\n            ret += rec(i+1, j!=(N[i]-'0'), next_state);\n        }\n    }\n    return ret;\n}\nsigned main() {\n    cin >> N;\n    cout << rec(0, 0, 0) << endl;\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ 2879 Gochiusa-Number\n// 2018.4.15 bal4u\n\n#include <stdio.h>\n\nlong long dp[20][1002][2][2];\nchar n[20]; int w;\n\nint main()\n{\n\tint i, j, k, m, t, f, d;\n\tchar *p;\n\tlong long ans;\n\n\tfgets(p=n, 20, stdin);\n\twhile (*p >= '0') p++;\n\t*p = 0, w = p-n;\n\n\tdp[0][0][0][0] = 1;\n\tfor (i = 0; i < w; i++) for (j = 0; j < 1000; j++) for (k = 0; k < 2; k++) {\n\t\tfor (m = 0; m < 2; m++) {\n\t\t\td = k ? 9: (n[i]&0xf);\n\t\t\tfor (t = 0; t <= d; t++) {\n\t\t\t\tf = m || (j/100 == 5 && (j/10)%10 == 1 && t == 3);\n\t\t\t\tdp[i+1][j%100*10+t][k||t<d][f] += dp[i][j][k][m];\n\t\t\t}\n\t\t}\n\t}\n\n\tans = 0;\n\tfor (i = 0; i < 1000; i++) for (j = 0; j < 2; j++) ans += dp[w][i][j][1];\n\tprintf(\"%lld\\n\", ans);\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nchar s[20];\nlong long dp[20][2][6];\nint main(){\n\tint len;\n\tscanf(\"%s\",s);\n\tlen=strlen(s);\n\tdp[0][0][0]=1;\n\tfor(int n=0;n<len;n++)for(int k=0;k<6;k++)for(int d=0;d<10;d++){\n\t\tint f;\n\t\tif(k==0&&d==5)f=1;\n\t\telse if(k==1&&d==1)f=2;\n\t\telse if(k==1&&d==5)f=1;\n\t\telse if(k==2&&d==5)f=5;\n\t\telse if(k==2&&d!=5)f=3;\n\t\telse if(k==3&&d==3)f=4;\n\t\telse if(k==3&&d==5)f=1;\n\t\telse if(k==4)f=4;\n\t\telse if(k==5&&d==3)f=4;\n\t\telse if(k==5&&d==1)f=2;\n\t\telse if(k==5&&d==5)f=1;\n\t\telse f=0;\n\t\tdp[n+1][1][f]+=dp[n][1][k];\n\t\tif(d<=s[n]-'0')dp[n+1][d<s[n]-'0'][f]+=dp[n][0][k];\n\t}\n\tprintf(\"%lld\\n\",dp[len][0][4]+dp[len][1][4]);\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        char[] numArr = sc.next().toCharArray();\n        int length = numArr.length;\n        int[] arr = new int[length];\n        for (int i = 0; i < length; i++) {\n            arr[i] = numArr[i] - '0';\n        }\n        long[][][][][][] dp = new long[length + 1][10][10][10][10][2];\n        dp[0][0][0][0][0][1] = 1;\n        long[][] counts = new long[length + 1][2];\n        for (int i = 1; i <= length; i++) {\n            for (int a = 0; a < 10; a++) {\n                for (int b = 0; b < 10; b++) {\n                    for (int c = 0; c < 10; c++) {\n                        for (int d = 0; d < 10; d++) {\n                            for (int e = 0; e < 10; e++) {\n                                dp[i][b][c][d][e][0] += dp[i - 1][a][b][c][d][0];\n                                if (e < arr[i - 1]) {\n                                    dp[i][b][c][d][e][0] += dp[i - 1][a][b][c][d][1];\n                                } else if (e == arr[i - 1]) {\n                                    dp[i][b][c][d][e][1] += dp[i - 1][a][b][c][d][1];\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            for (int e = 0; e < 10; e++) {\n                counts[i][0] += counts[i - 1][0];\n                if (e < arr[i - 1]) {\n                    counts[i][0] += counts[i - 1][1];\n                } else if (e == arr[i- 1]) {\n                    counts[i][1] += counts[i - 1][1];\n                }\n            }\n            for (int j = 0; j < 10; j++) {\n                counts[i][0] += dp[i][5][1][j][3][0];\n                counts[i][1] += dp[i][5][1][j][3][1];\n                dp[i][5][1][j][3][0] = 0;\n                dp[i][5][1][j][3][1] = 0;\n            }\n        }\n        System.out.println(counts[length][0] + counts[length][1]);\n    }\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Collections;\nusing System.Collections.Specialized;\nusing System.Linq;\nusing System.Text;\nusing System.IO;\nusing System.Reflection;\nusing static System.Math;\nusing System.Numerics;\nstatic class Program{\n\tconst int mod=(int)1e9+7;\n\tstatic void Main(){\n\t\tSc sc=new Sc();\n\t\tvar t=sc.L;\n\t\tstring s=t.ToString();\n\t\tint n=s.Length;\n\t\tlong ans=0;\n\t\tvar dp=new long[n+1,2,2,10,10,10];\n\t\tdp[0,0,0,0,0,0]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\tfor(int k=0;k<2;k++){\n\t\t\t\t\tfor(int l=0;l<10;l++){\n\t\t\t\t\t\tfor(int m=0;m<10;m++){\n\t\t\t\t\t\t\tfor(int o=0;o<10;o++){\n\t\t\t\t\t\t\t\tint lm=j==0?s[i]-'0':9;\n\t\t\t\t\t\t\t\tif(dp[i,j,k,l,m,o]==0){continue;}\n\t\t\t\t\t\t\t\tfor(int d=0;d<=lm;d++){dp[i+1,(j==1||d<lm)?1:0,(k==1||(l==5&&m==1&&d==3))?1:0,m,o,d]+=dp[i,j,k,l,m,o];}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int j=0;j<2;j++){\n\t\t\tfor(int k=0;k<10;k++){\n\t\t\t\tfor(int l=0;l<10;l++){\n\t\t\t\t\tfor(int m=0;m<10;m++){ans+=dp[n,j,1,k,l,m];}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(\"{0}\",ans);\n\t}\n}\n\npublic class Sc{\n\tpublic int I{get{return int.Parse(Console.ReadLine());}}\n\tpublic long L{get{return long.Parse(Console.ReadLine());}}\n\tpublic double D{get{return double.Parse(Console.ReadLine());}}\n\tpublic string S{get{return Console.ReadLine();}}\n\tpublic int[] Ia{get{return Array.ConvertAll(Console.ReadLine().Split(),int.Parse);}}\n\tpublic long[] La{get{return Array.ConvertAll(Console.ReadLine().Split(),long.Parse);}}\n\tpublic double[] Da{get{return Array.ConvertAll(Console.ReadLine().Split(),double.Parse);}}\n\tpublic string[] Sa{get{return Console.ReadLine().Split();}}\n\tpublic object[] Oa{get{return Console.ReadLine().Split();}}\n\tpublic int[] Ia2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),int.Parse);}}\n\tpublic int[] Ia3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),int.Parse);}\n\tpublic int[] Ia3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),int.Parse);}\n\tpublic long[] La2{get{return Array.ConvertAll((\"0 \"+Console.ReadLine()+\" 0\").Split(),long.Parse);}}\n\tpublic long[] La3(int a){return Array.ConvertAll((a.ToString()+\" \"+Console.ReadLine()).Split(),long.Parse);}\n\tpublic long[] La3(bool a,int b,bool c,int d){return Array.ConvertAll(((a?b.ToString()+\" \":\"\")+Console.ReadLine()+(c?\" \"+d.ToString():\"\")).Split(),long.Parse);}\n\tpublic T[] Arr<T>(int n,Func<T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f();}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i);}return a;}\n\tpublic T[] Arr<T>(int n,Func<string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(Console.ReadLine().Split());}return a;}\n\tpublic T[] Arr<T>(int n,Func<int,string[],T> f){var a=new T[n];for(int i=0;i<n;i++){a[i]=f(i,Console.ReadLine().Split());}return a;}\n}\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Numerics;\n\nnamespace Ritsumei2018.F\n{\n\tusing static Util;\n\tusing static Math;\n\n\tpublic class Solver : SolverBase\n\t{\n\t\tpublic void Run() {\n\t\t\tstring S = ReadString();\n\n\t\t\t// 桁DP\n\t\t\t// dp[桁（上位から）]\n\t\t\t//   [無印/末尾5/末尾51/末尾51?(?は5以外)/末尾515/ごちうさ確定]\n\t\t\t//   [制限なし/あり]=現在桁までの当該パターン数\n\t\t\tconst int None = 0;\n\t\t\tconst int T5 = 1;\n\t\t\tconst int T51 = 2;\n\t\t\tconst int T51a = 3;\n\t\t\tconst int T515 = 4;\n\t\t\tconst int Goti = 5;\n\n\t\t\tvar dp = new long[21, 6, 2];\n\t\t\tInitDP3(dp, 0);\n\t\t\tdp[0, 0, 1] = 1;\n\n\t\t\t// ※loopはいつも昇順にしたほうが良さそう ※逆順にすると、遷移も逆方向にしないといけないので\n\t\t\t// ※桁数を逆にする方が簡単\n\t\t\tfor (int i = 0; i < S.Length; i++) {\n\t\t\t\tvar ni = i + 1;\n\t\t\t\tvar x = S[i] - '0';\n\n\t\t\t\tfor (int j = 0; j < 6; j++) {\n\t\t\t\t\tfor (int k = 0; k < 2; k++) {\n\t\t\t\t\t\tif (dp[i, j, k] < 0) continue;\n\n\t\t\t\t\t\tfor (int nx = 0; nx < 10; nx++) {\n\t\t\t\t\t\t\tvar nj = None;\n\t\t\t\t\t\t\tvar nk = k; // ※nkは毎回初期化しないとおかしくなるよ！\n\n\t\t\t\t\t\t\tif (k == 1) {\n\t\t\t\t\t\t\t\tif (x < nx) continue;\n\t\t\t\t\t\t\t\tif (nx < x) {\n\t\t\t\t\t\t\t\t\tnk = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (j == None) {\n\t\t\t\t\t\t\t\t// 無印\n\t\t\t\t\t\t\t\tif (nx == 5) nj = T5;\n\t\t\t\t\t\t\t}else if (j == T5) {\n\t\t\t\t\t\t\t\t// 末尾5\n\t\t\t\t\t\t\t\tif (nx == 1) nj = T51;\n\t\t\t\t\t\t\t\telse if (nx == 5) nj = T5;\n\t\t\t\t\t\t\t}else if (j == T51) {\n\t\t\t\t\t\t\t\t// 末尾51\n\t\t\t\t\t\t\t\tif (nx == 5) nj = T515;\n\t\t\t\t\t\t\t\telse nj = T51a;\n\t\t\t\t\t\t\t}else if (j == T51a) {\n\t\t\t\t\t\t\t\t// 末尾51? (?は5以外）\n\t\t\t\t\t\t\t\tif (nx == 3) nj = Goti;\n\t\t\t\t\t\t\t\telse if (nx == 5) nj = T5;\n\t\t\t\t\t\t\t}else if (j == T515) {\n\t\t\t\t\t\t\t\t// 末尾515\n\t\t\t\t\t\t\t\tif (nx == 3) nj = Goti;\n\t\t\t\t\t\t\t\telse if (nx == 5) nj = T5;\n\t\t\t\t\t\t\t\telse if (nx == 1) nj = T51;\n\t\t\t\t\t\t\t}else {\n\t\t\t\t\t\t\t\t// ごちうさ確定\n\t\t\t\t\t\t\t\tnj = Goti;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tdp[ni, nj, nk] += dp[i, j, k];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar ans = dp[S.Length, Goti, 0] + dp[S.Length, Goti, 1];\n\t\t\tWriteLine(ans);\n\t\t}\n\n#if !MYHOME\n\t\tstatic void Main(string[] args) {\n\t\t\tnew Solver().Run();\n\t\t}\n#endif\n\t}\n\n\tpublic static class Util\n\t{\n\t\tpublic static int Gcd(int a, int b) {\n\t\t\tif (a < b)\n\t\t\t\t// 引数を入替えて自分を呼び出す\n\t\t\t\treturn Gcd(b, a);\n\t\t\twhile (b != 0) {\n\t\t\t\tvar remainder = a % b;\n\t\t\t\ta = b;\n\t\t\t\tb = remainder;\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tpublic readonly static long MOD = 1000000007;\n\n\t\tpublic static string JoinString<T>(IEnumerable<T> array) {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tforeach (var item in array) {\n\t\t\t\tsb.Append(item);\n\t\t\t\tsb.Append(\", \");\n\t\t\t}\n\t\t\treturn sb.ToString();\n\t\t}\n\n\t\tpublic static void InitArray<T>(T[] ary, T value) {\n\t\t\tfor (int i = 0; i < ary.Length; i++) {\n\t\t\t\tary[i] = value;\n\t\t\t}\n\t\t}\n\t\tpublic static void InitDP2<T>(T[,] dp, T value) {\n\t\t\tfor (int i = 0; i < dp.GetLength(0); i++) {\n\t\t\t\tfor (int j = 0; j < dp.GetLength(1); j++) {\n\t\t\t\t\tdp[i, j] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic static void InitDP3<T>(T[,,] dp, T value) {\n\t\t\tfor (int i = 0; i < dp.GetLength(0); i++) {\n\t\t\t\tfor (int j = 0; j < dp.GetLength(1); j++) {\n\t\t\t\t\tfor (int k = 0; k < dp.GetLength(2); k++) {\n\t\t\t\t\t\tdp[i, j, k] = value;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>charでも対応可能なMax</summary>\n\t\tpublic static T Max<T>(T a, T b) where T : IComparable {\n\t\t\treturn 0 <= a.CompareTo(b) ? a : b;\n\t\t}\n\t\t/// <summary>3要素以上に対応するMax</summary>\n\t\tpublic static T Max<T>(params T[] nums) where T : IComparable {\n\t\t\tif (nums.Length == 0) return default(T);\n\n\t\t\tT max = nums[0];\n\t\t\tfor (int i = 1; i < nums.Length; i++) {\n\t\t\t\tmax = max.CompareTo(nums[i]) > 0 ? max : nums[i];\n\t\t\t}\n\t\t\treturn max;\n\t\t}\n\t\t/// <summary>charでも対応可能なMin</summary>\n\t\tpublic static T Min<T>(T a, T b) where T : IComparable {\n\t\t\treturn 0 < a.CompareTo(b) ? b : a;\n\t\t}\n\t\t/// <summary>3要素以上に対応するMin</summary>\n\t\tpublic static T Min<T>(params T[] nums) where T : IComparable {\n\t\t\tif (nums.Length == 0) return default(T);\n\n\t\t\tT min = nums[0];\n\t\t\tfor (int i = 1; i < nums.Length; i++) {\n\t\t\t\tmin = min.CompareTo(nums[i]) < 0 ? min : nums[i];\n\t\t\t}\n\t\t\treturn min;\n\t\t}\n\n\t\t///<summary>targetValueに一番近い値を返す</summary>\n\t\tpublic static long Nearest(long targetValue, params long[] values) {\n\t\t\tDebug.Assert(0 < values.Length);\n\t\t\tlong minDiff = long.MaxValue;\n\t\t\tlong ans = long.MaxValue;\n\t\t\tforeach (var v in values) {\n\t\t\t\tvar diff = Math.Abs(v - targetValue);\n\t\t\t\tif (ReplaceIfSmaller(ref minDiff, diff)) {\n\t\t\t\t\tans = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ans;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// ソート済み配列 ary に同じ値の要素が含まれている？\n\t\t/// ※ソート順は昇順/降順どちらでもよい\n\t\t/// </summary>\n\t\tpublic static bool HasDuplicateInSortedArray<T>(T[] ary) where T : IComparable, IComparable<T> {\n\t\t\tif (ary.Length <= 1) return false;\n\n\t\t\tvar lastNum = ary[ary.Length - 1];\n\n\t\t\tforeach (var n in ary) {\n\t\t\t\tif (lastNum.CompareTo(n) == 0) {\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\tlastNum = n;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t///<summary>v が r より大きい場合、r に v を代入し、trueを返す。それ以外（同値の場合を含む）は何もせずfalseを返す</summary>\n\t\tpublic static bool ReplaceIfBigger<T>(ref T r, T v) where T : IComparable {\n\t\t\tif (r.CompareTo(v) < 0) {\n\t\t\t\tr = v;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t///<summary>v が r よりが小さい場合、r に v を代入し、trueを返す。それ以外（同値の場合を含む）は何もせずfalseを返す</summary>\n\t\tpublic static bool ReplaceIfSmaller<T>(ref T r, T v) where T : IComparable {\n\t\t\tif (0 < r.CompareTo(v)) {\n\t\t\t\tr = v;\n\t\t\t\treturn true;\n\t\t\t} else {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\n\t\tpublic static void Swap<T>(ref T a, ref T b) where T : class {\n\t\t\tvar tmp = a;\n\t\t\ta = b;\n\t\t\tb = tmp;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// dic[key]にadderを加算する。keyが存在しなかった場合はdic[key]=adder をセットする。\n\t\t/// </summary>\n\t\tpublic static void AddTo<TKey>(this Dictionary<TKey, int> dic, TKey key, int adder) {\n\t\t\tif (dic.ContainsKey(key)) {\n\t\t\t\tdic[key] += adder;\n\t\t\t} else {\n\t\t\t\tdic[key] = adder;\n\t\t\t}\n\t\t}\n\n\t\t/// <summary>\n\t\t/// 文字列 s が chars に含まれる文字を含んでいるか？\n\t\t/// </summary>\n\t\tpublic static bool ContainsAny(this string s, char[] chars) {\n\t\t\tfor (int j = 0; j < s.Length; j++) {\n\t\t\t\tif (chars.Contains(s[j])) return true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// 二分探索\n\t\t/// ※条件を満たす最小のidxを返す\n\t\t/// ※満たすものがない場合は ary.Length を返す\n\t\t/// ※『aryの先頭側が条件を満たさない、末尾側が条件を満たす』という前提\n\t\t/// ただし、IsOK(...)の戻り値を逆転させれば、逆でも同じことが可能。\n\t\t/// </summary>\n\t\t/// <param name=\"ary\">探索対象配列 ★ソート済みであること</param>\n\t\t/// <param name=\"key\">探索値 ※これ以上の値を持つ（IsOKがtrueを返す）最小のindexを返す</param>\n\t\tpublic static int BinarySearch<T>(T[] ary, T key) where T : IComparable, IComparable<T> {\n\t\t\tint left = -1;\n\t\t\tint right = ary.Length;\n\n\t\t\twhile (1 < right - left) {\n\t\t\t\tvar mid = left + (right - left) / 2;\n\n\t\t\t\tif (IsOK(ary, mid, key)) {\n\t\t\t\t\tright = mid;\n\t\t\t\t} else {\n\t\t\t\t\tleft = mid;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// left は条件を満たさない最大の値、right は条件を満たす最小の値になっている\n\t\t\treturn right;\n\t\t}\n\t\tpublic static bool IsOK<T>(T[] ary, int idx, T key) where T : IComparable, IComparable<T> {\n\t\t\t// key <= ary[idx] と同じ意味\n\t\t\treturn key.CompareTo(ary[idx]) <= 0;\n\t\t}\n\n\t\t/// <summary>\n\t\t/// nの 2進数における下からd(0-indexed)桁目のbitが立っている？\n\t\t/// </summary>\n\t\tpublic static int GetBit(long n, int d) {\n\t\t\tif (0 == (n & (1L << d)))\n\t\t\t\treturn 0;\n\t\t\telse\n\t\t\t\treturn 1;\n\t\t}\n\t}\n\n\tpublic class SolverBase\n\t{\n\t\tvirtual protected string ReadLine() => Console.ReadLine();\n\t\tvirtual protected string ReadString() => ReadLine();\n\t\tvirtual protected int ReadInt() => int.Parse(ReadLine());\n\t\tvirtual protected long ReadLong() => long.Parse(ReadLine());\n\t\tvirtual protected string[] ReadStringArray() => ReadLine().Split(' ');\n\t\tvirtual protected void ReadString2(out string a, out string b) {\n\t\t\tvar ary = ReadStringArray();\n\t\t\ta = ary[0];\n\t\t\tb = ary[1];\n\t\t}\n\t\tvirtual protected void ReadString3(out string a, out string b, out string c) {\n\t\t\tvar ary = ReadStringArray();\n\t\t\ta = ary[0];\n\t\t\tb = ary[1];\n\t\t\tc = ary[2];\n\t\t}\n\t\tvirtual protected char[] ReadCharArray() => ReadLine().Split(' ').Select<string, char>(s => s[0]).ToArray();\n\t\tvirtual protected int[] ReadIntArray() => ReadLine().Split(' ').Select<string, int>(s => int.Parse(s)).ToArray();\n\t\tvirtual protected void ReadInt2(out int a, out int b) {\n\t\t\tvar ary = ReadIntArray();\n\t\t\ta = ary[0];\n\t\t\tb = ary[1];\n\t\t}\n\t\tvirtual protected void ReadInt3(out int a, out int b, out int c) {\n\t\t\tvar ary = ReadIntArray();\n\t\t\ta = ary[0];\n\t\t\tb = ary[1];\n\t\t\tc = ary[2];\n\t\t}\n\t\tvirtual protected void ReadInt4(out int a, out int b, out int c, out int d) {\n\t\t\tvar ary = ReadIntArray();\n\t\t\ta = ary[0];\n\t\t\tb = ary[1];\n\t\t\tc = ary[2];\n\t\t\td = ary[3];\n\t\t}\n\t\tvirtual protected long[] ReadLongArray() => ReadLine().Split(' ').Select<string, long>(s => long.Parse(s)).ToArray();\n\t\tvirtual protected void ReadLong2(out long a, out long b) {\n\t\t\tvar ary = ReadLongArray();\n\t\t\ta = ary[0];\n\t\t\tb = ary[1];\n\t\t}\n\t\tvirtual protected void ReadLong3(out long a, out long b, out long c) {\n\t\t\tvar ary = ReadLongArray();\n\t\t\ta = ary[0];\n\t\t\tb = ary[1];\n\t\t\tc = ary[2];\n\t\t}\n\t\tvirtual protected void ReadLong4(out long a, out long b, out long c, out long d) {\n\t\t\tvar ary = ReadLongArray();\n\t\t\ta = ary[0];\n\t\t\tb = ary[1];\n\t\t\tc = ary[2];\n\t\t\td = ary[3];\n\t\t}\n\t\tvirtual protected double[] ReadDoubleArray() => ReadLine().Split(' ').Select<string, double>(s => double.Parse(s)).ToArray();\n\n\t\tvirtual protected void WriteLine(string line) => Console.WriteLine(line);\n\t\tvirtual protected void WriteLine(double d) => Console.WriteLine($\"{d:F9}\");\n\t\tvirtual protected void WriteLine<T>(T value) where T : IFormattable => Console.WriteLine(value);\n\t\tvirtual protected void WriteGrid(IEnumerable<IEnumerable<char>> arrayOfArray) {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tforeach (var a in arrayOfArray) {\n\t\t\t\tforeach (var c in a) {\n\t\t\t\t\tsb.Append(c);\n\t\t\t\t}\n\t\t\t\tsb.AppendLine();\n\t\t\t}\n\t\t\tWriteLine(sb.ToString());\n\t\t}\n\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void Dump(double d) => Console.WriteLine($\"{d:F9}\");\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void Dump<T>(T x) => Console.WriteLine(x);\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void DumpArray<T>(IEnumerable<T> array) {\n\t\t\tstring s = Util.JoinString(array);\n\t\t\t// Consoleに出力すると、UnitTestの邪魔をしないというメリットあり。\n\t\t\tConsole.WriteLine(s);\n\t\t\t//_writer.WriteLine(s);\n\t\t}\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void DumpGrid(IEnumerable<IEnumerable<char>> arrayOfArray) {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tforeach (var a in arrayOfArray) {\n\t\t\t\tforeach (var c in a) {\n\t\t\t\t\tsb.Append(c);\n\t\t\t\t}\n\t\t\t\tsb.AppendLine();\n\t\t\t}\n\t\t\t// Consoleに出力すると、UnitTestの邪魔をしないというメリットあり。\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t\t//_writer.WriteLine(sb.ToString());\n\t\t}\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void DumpGrid<T>(IEnumerable<IEnumerable<T>> arrayOfArray) {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tforeach (var a in arrayOfArray) {\n\t\t\t\tsb.AppendLine(Util.JoinString(a));\n\t\t\t}\n\t\t\t// Consoleに出力すると、UnitTestの邪魔をしないというメリットあり。\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t\t//_writer.WriteLine(sb.ToString());\n\t\t}\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void DumpGrid(bool[,] grid) {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < grid.GetLength(0); i++) {\n\t\t\t\tfor (int j = 0; j < grid.GetLength(1); j++) {\n\t\t\t\t\tsb.Append(grid[i, j] ? \"x \" : \". \");\n\t\t\t\t}\n\t\t\t\tsb.AppendLine();\n\t\t\t}\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void DumpGrid(char[,] grid) {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < grid.GetLength(0); i++) {\n\t\t\t\tfor (int j = 0; j < grid.GetLength(1); j++) {\n\t\t\t\t\tsb.Append(grid[i, j]);\n\t\t\t\t\tsb.Append(\" \");\n\t\t\t\t}\n\t\t\t\tsb.AppendLine();\n\t\t\t}\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void DumpDP<T>(T[,] dp) where T : IFormattable {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < dp.GetLength(0); i++) {\n\t\t\t\tfor (int j = 0; j < dp.GetLength(1); j++) {\n\t\t\t\t\tsb.Append(dp[i, j]);\n\t\t\t\t\tsb.Append(\", \");\n\t\t\t\t}\n\t\t\t\tsb.AppendLine();\n\t\t\t}\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t\t[Conditional(\"DEBUG\")]\n\t\tprotected void DumpDP3_Keta<T>(T[,,] dp) where T : IFormattable {\n\t\t\tvar sb = new StringBuilder();\n\t\t\tfor (int i = 0; i < dp.GetLength(0); i++) {\n\t\t\t\tsb.Append($\"{i,2}: \");\n\t\t\t\tfor (int j = 0; j < dp.GetLength(1); j++) {\n\t\t\t\t\tsb.Append($\"{dp[i, j, 0]}-{dp[i, j, 1]}\");\n\t\t\t\t\tsb.Append(\", \");\n\t\t\t\t}\n\t\t\t\tsb.AppendLine();\n\t\t\t}\n\t\t\tConsole.WriteLine(sb.ToString());\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "D",
    "code": "void main() {\n  import std.stdio, std.string, std.conv, std.algorithm;\n\n  auto n = readln.chomp.to!(char[]);\n\n  auto dp = new long[][][][](n.length + 1, 2, 1000, 2);\n  dp[0][0][0][0] = 1;\n  foreach (i; 0 .. (n.length)) {\n    foreach (l; 0 .. 2) {\n      foreach (k; 0 .. 1000) {\n        foreach (ok; 0 .. 2) {\n          auto x = k / 100, y = (k / 10) % 10, z = k % 10;\n          auto d = l ? 9 : (n[i] - '0');\n          for (int digit = 0; digit <= d; digit++) {\n            auto less = l || (digit < d);\n            auto okok = ok || (x == 5 && y == 1 && digit == 3);\n            dp[i + 1][less][y * 100 + z * 10 + digit][okok] += dp[i][l][k][ok];\n          }\n        }\n      }\n    }\n  }\n  long s = 0;\n  foreach (j; 0 .. 2) {\n    foreach (k; 0 .. 1000) {\n      s += dp[n.length][j][k][1];\n    }\n  }\n  writeln(s);\n}\n\nvoid rd(T...)(ref T x) {\n  import std.stdio : readln;\n  import std.string : split;\n  import std.conv : to;\n\n  auto l = readln.split;\n  assert(l.length == x.length);\n  foreach (i, ref e; x)\n    e = l[i].to!(typeof(e));\n}\n\n"
  },
  {
    "language": "Python",
    "code": "def usa(x):\n    if x <= 5000: return False\n    sx = str(x)\n    return sx[0] == '5' and sx[1] == '1' and sx[3] == '3'\n\n\ndef rec(k, tight, prev, ok, x, dp):\n    if len(x) == k:\n        # print(prev)\n        return 1 if ok else 0\n    if dp[k][tight][prev] != -1:\n        return dp[k][tight][prev]\n\n    upper = int(x[k]) if tight == 1 else 9\n    ret = 0\n    for i in range(0, upper + 1):\n        newPrev = prev\n        newPrev *= 10\n        newPrev %= 10000\n        newPrev += i\n        newTight = tight\n        if newTight == 1 and i != int(x[k]):\n            newTight = 0\n        ret += rec(k + 1, newTight, newPrev, ok or usa(newPrev), x, dp)\n\n    dp[k][tight][prev] = ret\n    return ret\n\n\nif __name__ == '__main__':\n    N = int(input())\n    Dp = [[[-1 for k in range(10000)] for j in range(2)] for i in range(len(str(N)))]\n    ans = rec(0, 1, 0, False, str(N), Dp)\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "def usa(x):\n    if x <= 5000: return False\n    sx = str(x)\n    return sx[0] == '5' and sx[1] == '1' and sx[3] == '3'\n\n\ndef rec(k, tight, prev, ok, x, dp):\n    if len(x) == k:\n        # print(prev)\n        return 1 if ok else 0\n    if dp[k][tight][prev] != -1:\n        return dp[k][tight][prev]\n    if ok:\n        return int(10 ** (len(x) - k))\n\n    upper = int(x[k]) if tight == 1 else 9\n    ret = 0\n    for i in range(0, upper + 1):\n        newPrev = prev\n        newPrev *= 10\n        newPrev %= 10000\n        newPrev += i\n        newTight = tight\n        if newTight == 1 and i != int(x[k]):\n            newTight = 0\n        ret += rec(k + 1, newTight, newPrev, ok or usa(newPrev), x, dp)\n\n    dp[k][tight][prev] = ret\n    return ret\n\n\ndef solve(N):\n    Dp = [[[-1 for k in range(10000)] for j in range(2)] for i in range(len(str(N)))]\n    ans = rec(0, 1, 0, False, str(N), Dp)\n    return ans\n    # print(ans)\n\n\nif __name__ == '__main__':\n    N = int(input())\n    print(solve(N))\n\n"
  },
  {
    "language": "Python",
    "code": "def usa(x):\n    if x <= 5000: return False\n    sx = str(x)\n    return sx[0] == '5' and sx[1] == '1' and sx[3] == '3'\n\n\ndef rec(k, tight, prev, ok, x, dp):\n    if len(x) == k:\n        # print(prev)\n        return 1 if ok else 0\n    if dp[k][tight][prev] != -1:\n        return dp[k][tight][prev]\n    if ok:\n        return int(10 ** (len(x) - k))\n\n    upper = int(x[k]) if tight == 1 else 9\n    ret = 0\n    for i in range(0, upper + 1):\n        newPrev = prev\n        newPrev *= 10\n        newPrev %= 10000\n        newPrev += i\n        newTight = tight\n        if newTight == 1 and i != int(x[k]):\n            newTight = 0\n        ret += rec(k + 1, newTight, newPrev, ok or usa(newPrev), x, dp)\n\n    dp[k][tight][prev] = ret\n    return ret\n\n\ndef solve(N):\n    Dp = [[[-1 for k in range(10000)] for j in range(2)] for i in range(len(str(N)))]\n    ans = rec(0, 1, 0, False, str(N), Dp)\n    return ans\n    # print(ans)\n\n\nif __name__ == '__main__':\n    N = int(input())\n    print(solve(N))\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n\nfrom collections import deque\nimport itertools as it\nimport sys\nimport math\n\nsys.setrecursionlimit(1000000)\n\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nN = input()\n\ndef func(S, index, cnt):\n    ans = 0\n    if index == 20:\n        if cnt == 0:\n            return 0\n        S_ = list(S)\n        for i in range(20):\n            if S_[i] != '?':\n                continue\n            for j in range(10):\n                S_[i] = str(j)\n                if int(''.join(S_).replace('?', '9')) > N:\n                    break\n                else:\n                    ans += 10 ** S_.count('?')\n        ans *= (-1) ** (cnt + 1)\n        return ans\n    ans += func(S, index + 1, cnt)\n    if index <= 16:\n        S_ = list(S)\n        S_[index] = '5'\n        S_[index + 1] = '1'\n        S_[index + 3] = '3'\n        ans += func(S_, index + 4, cnt + 1)\n    return ans\n\nS = ['?'] * 20\nprint func(S, 0, 0)\n\n"
  }
]