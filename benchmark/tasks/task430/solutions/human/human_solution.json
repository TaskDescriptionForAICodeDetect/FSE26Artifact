[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A[10010][2];\nint S[10010][10010];\nint N, M, x1, y1, x2, y2, xn, yn, ans;\nint ANS = 0;\nint *R;\nint Xs[10010], Ys[10010];\nmap<int,int> zipx, zipy;\nint unzipx[10010], unzipy[10010];\nint MAX = 1000000001;\n\nint compress(int *X, map<int, int> &zip, int *unzip, int n) {\n    sort(X, X + n);\n    R = unique(X, X + n);\n\tint k = R - X;\n    for(int i = 0; i < k; i++){\n        zip[X[i]] = i;\n        unzip[i] = X[i];\n    }\n    return k;\n}\n\nint main(){\n\tcin >> N >> M;\n\tfor (int n = 0; n < N; n++) {\n\t\tcin >> x1 >> y1;\n\t\tA[n][0] = x1; A[n][1] = y1;\n\t\tXs[n * 2] = x1;\n\t\tXs[n * 2 + 1] = x1 - 1;\n\t\tYs[n * 2] = y1;\n\t\tYs[n * 2 + 1] = y1 - 1;\n\t}\n\t\n\tXs[N * 2] = -1 * MAX;\n\tXs[N * 2 + 1] = MAX;\n\tYs[N * 2] = -1 * MAX;\n\tYs[N * 2 + 1] = MAX;\n\t\n\txn = compress(Xs, zipx, unzipx, N * 2 + 2);\n\tyn = compress(Ys, zipy, unzipy, N * 2 + 2);\n\t\n\t\n\tfor (int n = 0; n < N; n ++) {\n\t\tx1 = zipx[A[n][0]];\n\t\ty1 = zipy[A[n][1]];\n\t\tS[x1][y1] ++;\n\t}\n\t\n\tfor (int x = 1; x <= xn; x++) {\n\t\tfor (int y = 1; y <= yn; y ++) {\n\t\t\tS[x][y] += S[x - 1][y] + S[x][y - 1] - S[x - 1][y - 1];\n\t\t}\n\t}\n\tfor (int m = 0; m < M; m ++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tx1 = *lower_bound(Xs, Xs + xn, x1 - 1);\n\t\ty1 = *lower_bound(Ys, Ys + yn, y1 - 1);\n\t\tx2 = *lower_bound(Xs, Xs + xn, x2);\n\t\ty2 = *lower_bound(Ys, Ys + yn, y2);\n\t\t\n\t\tx1 = zipx[x1];\n\t\tx2 = zipx[x2];\n\t\ty1 = zipy[y1];\n\t\ty2 = zipy[y2];\n\t\t\n\t\tans = S[x2][y2] - S[x1][y2] - S[x2][y1] + S[x1][y1];\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t/*for (int i = 0; i < 10 ;i ++ ) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tcout << S[i][j];\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <limits.h>\n#include <map>\n#include <set>\n\nusing namespace std;\nconst int ninf = -(1000000000 + 1);\n\n\nint solve(void);\nint getTreasureNum( vector<vector<int>> &clist, vector<vector<int>> &mp, vector<map<int,int>>&trans);\nint getSmallerID(vector<int> &list,  int target);\n\nint main(void) {\n\n\t//FILE *fpin = freopen(\"data.txt\", \"r\", stdin);\n\twhile (solve());\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\tint n, m;\n\tcin >> n >> m;\n\n\t/*\n\t\t?´?????????¨??§?¨???§???\n\t*/\n\n\tvector<vector<int>> clist(2);\n\tvector<pair<int, int>> plist(n);\n\tvector<vector<int>> mp;\n\tvector<map<int, int>> trans(2);\n\t/*\n\t\tinput\n\t*/\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> plist[i].first >> plist[i].second;\n\t\tclist[1].push_back(plist[i].first);\n\t\tclist[0].push_back(plist[i].second);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tclist[i].push_back(ninf);\n\t\tsort(clist[i].begin(), clist[i].end());\n\t\tclist[i].erase(unique(clist[i].begin(), clist[i].end()), clist[i].end());\n\t\tfor (int j = 0; j < clist[i].size(); j++) {\n\t\t\ttrans[i][clist[i][j]] = j;\n\t\t}\n\t}\n\tmp = vector<vector<int>>(clist[0].size(), vector<int>(clist[1].size(), 0));\n\n\tfor (int i = 0; i < n; i++)\n\t\tmp[trans[0][plist[i].second]][trans[1][plist[i].first]] ++;\n\n\tfor (int x = 0; x < mp[0].size(); x++) {\n\t\tfor (int y = 0; y + 1 < mp.size(); y++) {\n\t\t\tmp[y + 1][x] = mp[y + 1][x] + mp[y][x];\n\t\t}\n\t}\n\n\tfor (int y = 0; y < mp.size(); y++) {\n\t\tfor (int x = 0; x + 1 < mp[0].size();x++) {\n\t\t\tmp[y][x + 1] = mp[y][x + 1] + mp[y][x];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++)\n\t\tcout << getTreasureNum(clist, mp, trans) << endl;\n\n\treturn 0;\n}\n\nint getTreasureNum(vector<vector<int>>& clist, vector<vector<int>>& mp, vector<map<int, int>>& trans)\n{\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> y1 >> x2 >> y2;\n\n\tif (x2 < clist[1][0] || x1 > clist[1][clist[1].size() - 1] || y2 < clist[0][0] || y1 > clist[0][clist[0].size() - 1]) { return 0; }\n\t\n\tif( trans[1].find(x1) == trans[1].end() )\n\t\tx1 = min(getSmallerID(clist[1], x1) + 1, (int)clist[1].size()-1);\n\telse\n\t\tx1 = getSmallerID(clist[1], x1);\n\n\tx2 = getSmallerID(clist[1], x2);\n\n\tif (trans[0].find(y1) == trans[0].end())\n\t\ty1 = min(getSmallerID(clist[0], y1) + 1, (int)clist[0].size() - 1);\n\telse\n\t\ty1 = getSmallerID(clist[0], y1);\n\n\ty2 = getSmallerID(clist[0], y2);\n\t\n\tx1--;\n\ty1--;\n\treturn mp[y2][x2] - mp[y1][x2] - mp[y2][x1] + mp[y1][x1];\n\t\n}\n\n\nint getSmallerID(vector<int>& list, int target)\n{\n\tint low = 0;\n\tint high = list.size();\n\tint mid = 0;\n\n\twhile (abs(low - high) > 1) {\n\t\tmid = (low + high) / 2;\n\t\tif (list[mid] <= target) {\n\t\t\tlow = mid;\n\t\t}\n\t\telse {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\tmid = (high + low) / 2;\n\treturn mid;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass Node{\npublic:\n  int location;\n  int p,l,r;\n  Node(){}\n};\nclass Point{\npublic:\n  int id,x,y;\n  Point(){}\n  Point(int id,int x,int y): id(id),x(x),y(y){}\n  bool operator<(const Point &p)const{\n    return id<p.id;\n  }\n  void print(){\n    printf(\"%d\\n\",id);\n  }\n};\nstatic const int MAX = 5005;\nstatic const int NIL = -1;\n \nint N;\nPoint P[MAX];\nNode T[MAX];\nint np;\n \nbool lessX(const Point &p1,const Point &p2){return p1.x<p2.x;}\nbool lessY(const Point &p1,const Point &p2){return p1.y<p2.y;}\n \nint makeKDTree(int l,int r,int depth){\n  if(!(l<r)) return NIL;\n  int mid=(l+r)/2;\n  int t = np++;\n  if(depth%2==0){\n    sort(P+l,P+r,lessX);\n  }else{\n    sort(P+l,P+r,lessY);\n  }\n  T[t].location=mid;\n  T[t].l = makeKDTree(l,mid,depth+1);\n  T[t].r = makeKDTree(mid+1,r,depth+1);\n \n  return t;\n}\n\nint ans;\n \nvoid find(int v,int sx,int tx,int sy,int ty,int depth){\n  int x=P[T[v].location].x;\n  int y=P[T[v].location].y;\n \n \n  if(sx<=x&&x<=tx&&sy<=y&&y<=ty){\n    ans++;\n  }\n \n  if(depth%2==0){\n    if(T[v].l!=NIL){\n      if(sx<=x) find(T[v].l,sx,tx,sy,ty,depth+1);\n    }\n    if(T[v].r!=NIL){\n      if(x<=tx) find(T[v].r,sx,tx,sy,ty,depth+1);\n    }\n  }else{\n    if(T[v].l!=NIL){\n      if(sy<=y) find(T[v].l,sx,tx,sy,ty,depth+1);\n    }\n    if(T[v].r!=NIL){\n      if(y<=ty) find(T[v].r,sx,tx,sy,ty,depth+1);\n    }\n  }\n   \n} \n    \nint main(){\n  int x,y;\n  scanf(\"%d\",&N);\n  int q;\n  scanf(\"%d\",&q);\n  for(int i=0;i<N;i++) {\n    scanf(\"%d %d\",&x,&y);\n    P[i]=Point(i,x,y);\n    T[i].l = T[i].r = T[i].p = NIL;\n  }\n  np=0;\n  int root=makeKDTree(0,N,0);\n \n  int sx,tx,sy,ty;\n\n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    ans=0;\n    find(root,sx,tx,sy,ty,0);\n    printf(\"%d\\n\",ans);\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\ntypedef double weight;\nstruct edge\n{\n\tint to; weight cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\ntypedef vector<vector<edge>> Graph;\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\ntypedef complex<double> Point;\n\nstruct kdtree {\n\tstruct node {\n\t\tPoint p;\n\t\tnode *l, *r;\n\t\tnode(const Point &p)\n\t\t\t: p(p), l(NULL), r(NULL)\n\t\t{\n\t\t}\n\t} *root;\n\tkdtree() : root(NULL) {}\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n\tvoid insert(const Point &p)\n\t{\n\t\troot = insert(root, 0, p);\n\t}\n\tnode *insert(node *t, int d, const Point &p)\n\t{\n\t\tif (t == NULL) return new node(p);\n\t\tif (compare(d, p, t->p)) t->l = insert(t->l, !d, p);\n\t\telse                   t->r = insert(t->r, !d, p);\n\t\treturn t;\n\t}\n\n\tvoid search(const Point &ld, const Point &ru, vector<Point> &out)\n\t{\n\t\tsearch(root, 0, ld, ru, out);\n\t}\n\tvoid search(node *t, int d, const Point &ld, const Point &ru, vector<Point> &out)\n\t{\n\t\tif (t == NULL) return;\n\t\tconst Point &p = t->p;\n\t\tif (real(ld) <= real(p) && real(p) <= real(ru) &&\n\t\t\timag(ld) <= imag(p) && imag(p) <= imag(ru)) out.push_back(p);\n\t\tif (!compare(d, p, ld)) search(t->l, !d, ld, ru, out);\n\t\tif (!compare(d, ru, p)) search(t->r, !d, ld, ru, out);\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<Point> v(n);\n\tREP(i, n)\n\t{\n\t\tdouble x, y;\n\t\tcin >> x >> y;\n\t\tv[i] = Point(x, y);\n\t}\n\trandom_shuffle(ALL(v));\n\tkdtree kd;\n\tREP(i, n) kd.insert(v[i]);\n\tREP(i, m)\n\t{\n\t\tdouble a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tPoint ld(a, b), ru(c, d);\n\t\tvector<Point> tmp;\n\t\tkd.search(ld, ru, tmp);\n\t\tcout << tmp.size() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, q, xa, ya, xb, yb, x[5555], y[5555]; pair<int, int> p[5555];\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p, p + n);\n\tfor(int i = 0; i < n; i++) x[i] = p[i].first, y[i] = p[i].second;\n\tfor(int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d%d\", &xa, &ya, &xb, &yb);\n\t\tint l = lower_bound(x, x + n, xa) - x;\n\t\tint r = lower_bound(x, x + n, xb + 1) - x;\n\t\tint c = 0;\n\t\tfor(int j = l; j < r; j++) {\n\t\t\tif(ya <= y[j] && y[j] <= yb) c++;\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb emplace_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\ntemplate<int N>\nstruct FID {\n  using Bits = uint32_t;\n  static const int B = 8*sizeof(Bits);\n  int n;\n  int buck[N/B+1];\n  Bits bits[N/B+1];\n  int sel[2][N];\n\n  FID() {}\n  FID(int n, bool bs[]) : n(n) {\n    int cnt = 0;\n    int idx = 0;\n    fill(buck, buck+N/B+1, 0);\n    fill(bits, bits+N/B+1, 0);\n    rep(i, n/B + (n%B != 0)) {\n      rep(j, B) {\n        if (idx >= n) break;\n        cnt += bs[idx];\n        bits[i] |= Bits(bs[idx]) << j;\n        idx++;\n      }\n      buck[i+1] = cnt;\n    }\n\n    fill(sel[0], sel[2], -1);\n    cnt = 0;\n    rep(i, n) {\n      if (bs[i]) {\n        sel[1][cnt] = i;\n        cnt++;\n      } else {\n        sel[0][i-cnt] = i;\n      }\n    }\n  }\n\n  int Count(bool v, int r) {\n    int ret = buck[r/B] + __builtin_popcount(bits[r/B] % (1<<(r%B)));\n    if (!v) ret = r - ret;\n    return ret;\n  }\n\n  int Select(bool v, int k) {\n    if (k < 0 || k >= n) return -1;\n    return sel[v][k];\n  }\n\n  int SelectFrom(int from, bool v, int k) {\n    return Select(v, Count(v, from) + k);\n  }\n\n  bool operator[](int k) {\n    return bits[k/B] >> (k%B) & 1;\n  }\n};\n\ntemplate<int N, class T=unsigned int>          \nstruct Wavelet {\n  static const int D = 8*sizeof(T);\n  int n;\n  int sep[D];\n  FID<N> dat[D];\n  T arr[N];\n\n  Wavelet(int n, T ini[]) : n(n) {\n    T l[N];\n    T r[N];\n    T src[N];\n    bool bs[N];\n\n    copy(ini, ini+n, arr);\n    copy(ini, ini+n, src);\n    rep (d, D) {\n      int rk = 0;\n      int lk = 0;\n      rep(i, n) {\n        bool t = src[i] >> (D-d-1) & 1;\n        if (t) r[rk++] = src[i];\n        else l[lk++] = src[i];\n        bs[i] = t;\n      }\n      dat[d] = FID<N>(n, bs);\n      sep[d] = lk;\n      swap(l, src);\n      copy(r, r+rk, src+lk);\n    }\n  }\n\n  int Count(T val, int l, int r) {\n    if (r <= l) return 0;\n    rep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      l = dat[d].count(b, l) + b*sep[b];\n      r = dat[d].count(b, r) + b*sep[b];\n    }\n    return r-l;\n  }\n\n  int Select(T val, int k) {\n    int ls[D+1];\n    int rs[D+1];\n    ls[0] = 0;\n    rs[0] = n;\n    rep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      ls[d+1] = dat[d].count(b, ls[d]) + b*sep[b];\n      rs[d+1] = dat[d].count(b, rs[d]) + b*sep[b];\n    }\n    rrep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      k = dat[d].SelectFrom(ls[d], b, k);\n      if (k < 0 || k >= rs[d]) return -1;\n      k -= ls[d];\n    }\n    return k;\n  }\n\n  T KthNumber(int l, int r, int k) {\n    if (k < 0 || k >= r-l) assert(0);\n    T ret = 0;\n    rep(d, D) {\n      int lc = dat[d].Count(1, l);\n      int rc = dat[d].Count(1, r);\n      if (rc - lc > k) {\n        l = lc + sep[d];\n        r = rc + sep[d];\n        ret |= T(1) << (D-d-1);\n      } else {\n        k -= rc-lc;\n        l -= lc;\n        r -= rc;\n      }\n    }\n    return ret;\n  }\n\n  int FreqDfs(int d, int l, int r, T val, T a, T b) {\n    if (r <= l) return 0;\n    if (d == D) {\n      if (a <= val && val < b) return r-l;\n      return 0;\n    }\n\n    T h = T(1) << (D-d-1);\n    T nv = val | h; \n    T lim = nv | (h-1);\n    if (lim < a || b <= val) return 0;\n    if (a <= val && lim < b) return r-l;\n\n    int lc = dat[d].Count(1, l);\n    int rc = dat[d].Count(1, r);\n    int lval = FreqDfs(d+1, l-lc, r-rc, val, a, b);\n    int rval = FreqDfs(d+1, lc+sep[d], rc+sep[d], nv, a, b);\n    return lval + rval;\n  }\n\n  int Freq(int l, int r, T a, T b) {\n    return FreqDfs(0, l, r, 0, a, b);\n  }\n\n  T operator[](int k) {\n    return arr[k];\n  }\n};\n\nconst int GETA = 1e9;\nint N;\nint M;\nunsigned int ys[114514];\nvector<PII> ps;\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  rep(i, N) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    y += GETA;\n    ps.emplace_back(PII(x, y));\n  }\n  sort(all(ps));\n \n  rep(i, N) ys[i] = ps[i].second;\n  Wavelet<5000> wave(N, ys);\n\n  rep(i, M) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    b += GETA;\n    d += GETA;\n    int x = lower_bound(all(ps), PII(a, 0)) - ps.begin();\n    int y = upper_bound(all(ps), PII(c, GETA*2)) - ps.begin();\n    printf(\"%d\\n\", wave.Freq(x, y, b, d+1));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define X first\n#define Y second\n\nusing namespace std;\n\nint n, m;\nvector<int> vx, vy;\nint tx[5005], ty[5005], unzipx[5005], unzipy[5005], imos[5005][5005];\nmap<int, int> zipx, zipy;\npair< pair<int,int>, pair<int,int> > p[500005];\n\nint main() {\n  cin>>n>>m;\n  REP(i,0,n){\n    cin>>tx[i]>>ty[i];\n    vx.push_back(tx[i]);\n    vy.push_back(ty[i]);\n  }\n  REP(i,0,m){\n    cin>>p[i].F.X>>p[i].F.Y>>p[i].S.X>>p[i].S.Y;\n  }\n\n  //compression\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  vx.erase(vx.begin()/*unique(vx.begin(), vx.end())*/, vx.end());\n  vy.erase(vy.begin()/*unique(vy.begin(), vy.end())*/, vy.end());\n  REP(i,0,vx.size()){\n    zipx[vx[i]] = i;\n    unzipx[i] = vx[i];\n  }\n  REP(i,0,vy.size()){\n    zipy[vy[i]] = i;\n    unzipy[i] = vy[i];\n  }\n\n  //Initializing imos array\n  REP(i,0,5005)REP(j,0,5005) imos[i][j] = 0;\n  REP(i,0,n){\n    imos[zipy[ty[i]]][zipx[tx[i]]]++;\n  }\n  //creating imos array\n  REP(i,0,vy.size()){\n    REP(j,1,vx.size()){\n      imos[i][j] += imos[i][j-1];\n    }\n  }\n  REP(j,0,vx.size()){\n    REP(i,1,vy.size()){\n      imos[i][j] += imos[i-1][j];\n    }\n  }\n\n  REP(i,0,m){\n    /*\n    cout<<\"xSize:\"<<vx.size()<<\", \"<<\"ySize:\"<<vx.size()<<endl;\n    cout<<\"test: \"<<(lower_bound(vx.begin(),vx.end(),p[i].F.X)-vx.begin())<<\" \";\n    cout<<(lower_bound(vy.begin(),vy.end(),p[i].F.Y)-vy.begin())<<\" \";\n    cout<<(lower_bound(vx.begin(),vx.end(),p[i].S.X)-vx.begin())<<\" \";\n    cout<<(lower_bound(vy.begin(),vy.end(),p[i].S.Y)-vy.begin())<<endl;\n    */\n    vector<int>::iterator a1x = lower_bound(vx.begin(),vx.end(),p[i].F.X),\n      a1y = lower_bound(vy.begin(),vy.end(),p[i].F.Y),\n      a2x = upper_bound(vx.begin(),vx.end(),p[i].S.X)-1,\n      a2y = upper_bound(vy.begin(),vy.end(),p[i].S.Y)-1;\n    int z1x = zipx[*a1x], z1y = zipy[*a1y], z2x = zipx[*a2x], z2y = zipy[*a2y];\n    int ans = imos[z2y][z2x];\n    if(z1y > 0) ans -= imos[z1y-1][z2x];\n    if(z1x > 0) ans -= imos[z2y][z1x-1];\n    if(z1y > 0 && z1x > 0) ans += imos[z1y-1][z1x-1];\n\n    if(p[i].F.Y > unzipy[vy.size()-1] || p[i].F.X > unzipx[vx.size()-1]) cout<<0<<endl;\n    else if(p[i].S.Y < unzipy[0] || p[i].S.X < unzipx[0]) cout<<0<<endl;\n    else cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\nint n, m, X1[505050], X2[505050], Y1[505050], Y2[505050];\n\nint compress(int *x1, int *x2, int w) {\n\tvector< int > xs;\n\t\n\tfor_(i,0,n+m) {\n\t\tfor_(d,-1,2) {\n\t\t\tint tx1 = x1[i] + d, tx2 = x2[i] + d;\n\t\t\tif (-w <= tx1 && tx1 <= w) xs.push_back(tx1);\n\t\t\tif (-w <= tx2 && tx2 <= w) xs.push_back(tx2);\n\t\t}\n\t}\n\t\n\tsort(allof(xs));\n\txs.erase(unique(allof(xs)), xs.end());\n\t\n\tfor_(i,0,n+m) {\n\t\tx1[i] = find(allof(xs), x1[i]) - xs.begin();\n\t\tx2[i] = find(allof(xs), x2[i]) - xs.begin();\n\t}\n\t\n\treturn xs.size();\n}\n\nint main() {\n\tcin >> n >> m;\n\t\n\tfor_(i,0,n) {\n\t\tcin >> X1[i] >> Y1[i];\n\t\tX2[i] = X1[i]; Y2[i] = Y1[i];\n\t}\n\t\n\tfor_(i,0,m) cin >> X1[i + n] >> Y1[i + n] >> X2[i + n] >> Y2[i + n];\n\t\n\tint W = compress(X1, X2, (int)1e9), H = compress(Y1, Y2, (int)1e9);\n\tvector< vector< int > > grid(H+1, vector< int >(W+1, 0));\n\t\n\tfor_(i,0,n) ++grid[Y1[i]][X1[i]];\n\t\n\tfor_(y,0,H+1) for_(x,0,W+1) {\n\t\tif (y > 0) grid[y][x] += grid[y-1][x];\n\t\tif (x > 0) grid[y][x] += grid[y][x-1];\n\t\tif (y > 0 && x > 0) grid[y][x] -= grid[y-1][x-1];\n\t}\n\t\n\tfor_(i,0,m) {\n\t\tint x1 = X1[i+n], x2 = X2[i+n], y1 = Y1[i+n], y2 = Y2[i+n];\n\t\tint ans = grid[y2][x2];\n\t\tif (x1-1 >= 0) ans -= grid[y2][x1-1];\n\t\tif (y1-1 >= 0) ans -= grid[y1-1][x2];\n\t\tif (x1-1 >= 0 && y1-1 >= 0) ans += grid[y1-1][x1-1];\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nlong long n,m,x[5000],y[5000],x1,x2,ys1,y2,count;\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\tfor(int i=0;i<m;i++){\n\t\tcin>>x1>>ys1>>x2>>y2;\n\t\tx1--,x2++,ys1--,y2++;\n\t\tcount=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(x[j]>x1&&x[j]<x2&&y[j]>ys1&&y[j]<y2)\n\t\t\t\tcount++;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<stack>\n#include<deque>\n#include<iostream>\n#include<cstdio>\n#define F first\n#define S second\n#define LIM 1000000010\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<int,int> P;\nint dp[5002][5002];\nint main(){\n  int n,m;\n \n  vector<int> X,Y;\n  \n  while(cin >> n >> m){\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)dp[j][i] = 0;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      X.pb(x); Y.pb(y);\n    }\n    vector<int> x,y;\n    x = X;\n    y = Y;\n    X.pb(-LIM); X.pb(LIM); Y.pb(-LIM); Y.pb(LIM);\n    sort(all(X)); sort(all(Y));\n    X.erase(unique(all(X)),X.end());\n    Y.erase(unique(all(Y)),Y.end());\n    for(int i=0;i<n;i++){\n      x[i] = find(all(X),x[i])-X.begin();\n      y[i] = find(all(Y),y[i])-Y.begin();\n      dp[y[i]][x[i]]++;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tdp[i+1][j+1] += dp[i+1][j]+dp[i][j+1]-dp[i][j];\n\n      }\n\n    }\n    for(int i=0;i<m;i++){\n      int sx,sy,gx,gy;\n      cin >> sx >> sy >> gx >> gy;\n      sx = lower_bound(all(X),sx)-X.begin();\n      sy = lower_bound(all(Y),sy)-Y.begin();\n      gx = upper_bound(all(X),gx)-X.begin()-1;\n      gy = upper_bound(all(Y),gy)-Y.begin()-1;\n      cout << dp[gy][gx]-dp[gy][sx-1]-dp[sy-1][gx]+dp[sy-1][sx-1] << endl;\n\n    }\n\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n), y(n);\n    multiset<pint> f;\n    for (int i = 0; i < n; ++i)\n    {\n        cin >> x[i] >> y[i];\n        f.insert(pint(x[i], y[i]));\n    }\n    const int INF = 2e9;\n    x.push_back(-INF);\n    x.push_back(INF);\n    y.push_back(-INF);\n    y.push_back(INF);\n    unique(x);\n    unique(y);\n\n    static int sum[5100][5100];\n    for (int i = 0; i < y.size(); ++i)\n        for (int j = 0; j < x.size(); ++j)\n            sum[i + 1][j + 1] = sum[i][j + 1] + sum[i + 1][j] - sum[i][j] + f.count(pint(x[j], y[i]));\n\n    while (m--)\n    {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(all(x), x1) - x.begin();\n        y1 = lower_bound(all(y), y1) - y.begin();\n        x2 = upper_bound(all(x), x2) - x.begin();\n        y2 = upper_bound(all(y), y2) - y.begin();\n\n        int res = sum[y2][x2] - (sum[y2][x1] + sum[y1][x2]) + sum[y1][x1];\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.TH\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nset<int> x, y;\t\t// 座標全体\nvector<int> xx, yy;\t// 圧縮した座標→元の座標\n//vector<int>rx, ry;\t// 圧縮した座標→元の座標の変換テーブル\n\nvoid compress (void ) \n{\n\txx.clear(); yy.clear();\n//\trx.clear(); ry.clear();\n\tint sx = x.size();\n\tint sy = y.size();\n\txx.resize (sx, 0 ); yy.resize (sy, 0 );\n\tset<int>::iterator it = x.begin();\n\tfor(int i = 0; it != x.end(); i++, it++ ){\n\t\tint curr = (*it);\n\t\txx[i] = curr;\n//\t\txx[curr] = i;\n//\t\trx[i] = curr;\n\t} // end for\n\n\tset<int>::iterator jt = y.begin();\n\tfor (int j = 0; jt != y.end(); j++, jt++ ){\n\t\tint curr = (*jt);\n\t\tyy[j] = curr;\n//\t\tyy[curr] = j;\n//\t\try[j] = curr;\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tint n, m;\n\tscanf (\"%d %d\", &n, &m );\n\tmap<P,int> cnt; cnt.clear();\n\tx.clear(); y.clear();\n\tvector<int> tx (n, 0 ), ty (n, 0 );\n\trep (i, n ){\n\t\tscanf (\"%d %d\", &tx[i], &ty[i] );\n\t\tcnt[P(tx[i],ty[i])]++;\n\t\tfor (int d = -1; d <= 1; d++ ){\n\t\t\tx.insert (tx[i]+d ); y.insert (ty[i]+d );\n\t\t} // end for\n\t} // end rep\n\tvector<int> x1 (m, 0 ), y1 (m, 0 ), x2 (m, 0 ), y2 (m, 0 );\n\trep (j, m ){\n\t\tscanf (\"%d %d %d %d\", &x1[j], &y1[j], &x2[j], &y2[j] );\n\t\tx.insert (x1[j] ); x.insert (x2[j] );\n\t\ty.insert (y1[j] ); y.insert (y2[j] );\n\t} // end rep \n\tcompress ();\n\n\trep (j, m ){\n\t\tint res = 0;\n\t\tfor (int cy = lower_bound (ALL (yy ), y1[j] ) - yy.begin(); cy <= lower_bound ( ALL(yy ), y2[j] ) - yy.begin(); cy++ ){\n\t\t\tfor (int cx = lower_bound (ALL (xx ), x1[j] ) - xx.begin(); cx <= lower_bound (ALL (xx ), x2[j] ) - xx.begin(); cx++ ){\n\t\t\t\tint ttx = xx[cx], tty = yy[cy];\n\t\t\t\tres += cnt[P(ttx, tty )];\n\t\t\t} // end for\n\t\t} // end for\n\t\tprintf (\"%d\\n\", res );\n\t} // end rep\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(vector<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\tvector<int> treasure;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\ttreasure.push_back(Count(pos, x1, y1, x2, y2));\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tcout << treasure << \"\\n\";\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl;\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//pair?????????\ntemplate<typename T1, typename T2>\nostream &operator << (ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\n\n//??§?¨???§???\n//v: ??§??????\n//?????????: zip[??§???????????§?¨?]:??§???????????§?¨? (zip.size()<=10^5?????????????????????)\ntemplate<typename T>\nmap<T, T> compress(vector<T> &v) {\n\tmap<T, T> zip;\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (T i = 0; i < v.size(); i++) zip[v[i]] = i;\n\treturn zip;\n}\n\n//??§???????????§?¨?\n//index(??§???????????§?¨?, ??§???????????§?¨??????????(??????) )\ntemplate<typename T>\nint index(T i, vector<T> v) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\n#define MAX 5001\n\n//Sample2\n//https://gyazo.com/39c67d1abe7a6a686acb52285f8a0bc9\n\nint main() {\n\t//2?¬?????´???????\n\tstatic int cumsum[MAX][MAX] = {};\n\tint xs[MAX], ys[MAX];\n\tint n, m; cin >> n >> m;\n\tvector<int> x(n + 1), y(n + 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xs[i] >> ys[i];\n\t\tx[i] = xs[i]; y[i] = ys[i];\n\t}\n\tmap<int, int> zipx(compress(x));\n\tmap<int, int> zipy(compress(y));\n\n\t//dump(x);\n\t//dump(zipx);\n\t//dump(y);\n\t//dump(zipy);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint vx = index(xs[i], x);\n\t\tint vy = index(ys[i], y);\n\t\tcumsum[vx + 1][vy + 1]++;\n\t}\n\tfor (int vy = 0; vy < y.size(); vy++)\n\t\tfor (int vx = 0; vx < x.size(); vx++)\n\t\t\tcumsum[vx + 1][vy + 1] += cumsum[vx + 1][vy] + cumsum[vx][vy + 1] - cumsum[vx][vy];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = index(x1, x);\n\t\tx2 = index(x2 + 1, x);\n\t\ty1 = index(y1, y);\n\t\ty2 = index(y2 + 1, y);\n\t\tcout << cumsum[x2][y2] - cumsum[x2][y1] - cumsum[x1][y2] + cumsum[x1][y1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 1000000001\nusing namespace std;\n\nmap<int, int> Dic(const vector<int>& v, vector<int>& sorted) {\n\tsorted = v;\n\tsort(sorted.begin(), sorted.end());\n\tsorted.erase(unique(sorted.begin(), sorted.end()), sorted.end());\n\tmap<int, int> res;\n\tfor (int i = 1; i <= sorted.size(); i++) {\n\t\tres[sorted[i - 1]] = i;\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(n), sx, y(n), sy;\n\tx.push_back(-INF); y.push_back(-INF);\n\tfor (int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n\tx.push_back(INF); y.push_back(INF);\n\n\tmap<int, int> xdic = Dic(x, sx), ydic = Dic(y, sy);\n\tvector<vector<int>> sum(sx.size() + 1, vector<int>(sy.size() + 1, 0));\n\tfor (int i = 1; i <= n; i++) {\n\t\tsum[xdic[x[i]]][ydic[y[i]]]++;\n\t}\n\tfor (int i = 1; i <= sx.size(); i++) {\n\t\tfor (int j = 1; j <= sy.size(); j++) {\n\t\t\tsum[i][j] += sum[i - 1][j];\n\t\t}\n\t}\n\tfor (int i = 1; i <= sx.size(); i++) {\n\t\tfor (int j = 1; j <= sy.size(); j++) {\n\t\t\tsum[i][j] += sum[i][j - 1];\n\t\t}\n\t}\n\n\n\tfor (int i = 0, x1, y1, x2, y2; i < m; i++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = xdic[*lower_bound(sx.begin(), sx.end(), x1)];\n\t\tx2 = xdic[*(upper_bound(sx.begin(), sx.end(), x2) == sx.begin() ? sx.begin() : upper_bound(sx.begin(), sx.end(), x2) - 1)];\n\t\ty1 = ydic[*lower_bound(sy.begin(), sy.end(), y1)];\n\t\ty2 = ydic[*(upper_bound(sy.begin(), sy.end(), y2) == sy.begin() ? sy.begin() : upper_bound(sy.begin(), sy.end(), y2) - 1)];\n\t\tcout << sum[x2][y2] - sum[x1 - 1][y2] - sum[x2][y1 - 1] + sum[x1 - 1][y1 - 1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\n\nint main(){\n\n\tint n,m,x1,y1,x2,y2,x3,y3;\n\n\tvector<pair<int,int> >p;\n\tvector<pair<int,int> >sw;\n\tvector<pair<int,int> >ne;\n\n\tcin >> n >> m;\n\n\trep(i,n){\n\n\tcin >> x1 >> y1;\n\n\tp.push_back(make_pair(x1,y1));\n\n\t}\n\n\tsort(p.begin(),p.end());\n\n    vector<int>c(m,0);\n\trep(i,m){\n\n\tcin >> x2 >> y2 >> x3 >> y3;\n\n\n\trep(j,n){\n\n    if(p[j].first<x2) continue;\n    if(x2<=p[j].first && p[j].first<=x3 && y2<=p[j].second && p[j].second<=y3) c[i]++;\n    if(x3<p[j].first) break;\n\n\t}\n\n\t}\n\n    rep(i,m) cout << c[i] << endl;\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\ntemplate <class T>\nclass cumulativeSum\n{\n    int ny, nx;\n    vector<vector<T> > sum;\npublic:\n    cumulativeSum(const vector<vector<T> >& a)\n    {\n        ny = a.size();\n        nx = a[0].size();\n        sum.assign(ny+1, vector<T>(nx+1, 0));\n        for(int i=0; i<ny; ++i){\n            for(int j=0; j<nx; ++j){\n                sum[i+1][j+1] = a[i][j] + sum[i][j+1] + sum[i+1][j] - sum[i][j];\n            }\n        }\n    }\n    T getSum(int y1, int x1, int y2, int x2)\n    {\n        if(y1 > y2 || x1 > x2)\n            return 0;\n        y1 = max(y1, 0);\n        x1 = max(x1, 0);\n        y2 = min(y2, ny-1);\n        x2 = min(x2, nx-1);\n        return sum[y2+1][x2+1] - sum[y1][x2+1] - sum[y2+1][x1] + sum[y1][x1];\n    }\n};\n\nint main()\n{\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> y(n), x(n);\n    map<int, int> yIndex, xIndex;\n    yIndex[-1];\n    xIndex[-1];\n    yIndex[INT_MAX/2];\n    xIndex[INT_MAX/2];\n    for(int i=0; i<n; ++i){\n        cin >> x[i] >> y[i];\n        yIndex[y[i]];\n        xIndex[x[i]];\n    }\n\n    int h = 0;\n    for(map<int, int>::iterator it=yIndex.begin(); it!=yIndex.end(); ++it){\n        it->second = h;\n        ++ h;\n    }\n    int w = 0;\n    for(map<int, int>::iterator it=xIndex.begin(); it!=xIndex.end(); ++it){\n        it->second = w;\n        ++ w;\n    }\n\n    vector<vector<int> > treasure(h, vector<int>(w, 0));\n    for(int i=0; i<n; ++i){\n        int y2 = yIndex[y[i]];\n        int x2 = xIndex[x[i]];\n        ++ treasure[y2][x2];\n    }\n    cumulativeSum<int> cs(treasure);\n\n    for(int i=0; i<m; ++i){\n        int y1, x1, y2, x2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        y1 = yIndex.lower_bound(y1)->second;\n        x1 = xIndex.lower_bound(x1)->second;\n        y2 = (--yIndex.upper_bound(y2))->second;\n        x2 = (--xIndex.upper_bound(x2))->second;\n        cout << cs.getSum(y1, x1, y2, x2) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\nconst int INF = 2000000000;\nusing namespace std;\n\nconst int MAX_N = 5100;\nconst int MAX_P = MAX_N * MAX_N;\nint grid[MAX_N][MAX_N] = {0};\n\nvoid compress(vector<int> &v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(),v.end()),v.end());\n}\n\nint lb(vector<int> v, int num){\n    return lower_bound(all(v), num) - v.begin();\n}\n\n\n//s[MAX_N + 1][MAX_N + 1]\nvoid cumulativeSum(int h, int w){\n    //?????????????´????(1,1)\n    rep(i,h) rep(j,w) grid[i + 1][j + 1] += grid[i + 1][j] + grid[i][j + 1] - grid[i][j];\n}\n\n//(i,j)????????????(k,l)???????????¨??????????????¢\nint sum(int i, int j, int k, int l){\n    return grid[k][l] - grid[i][l] - grid[k][j] + grid[i][j];\n}\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n\n    vector<int> x(n), y(n);\n    pair<int, int> inp[MAX_N];\n    rep(i,n){\n        cin >> x[i] >> y[i];\n        inp[i] = make_pair(x[i],y[i]);\n    }\n\n    compress(x);\n    compress(y);\n\n    rep(i,n){\n        int fy = lb(y, inp[i].second);\n        int fx = lb(x, inp[i].first);\n        grid[fy + 1][fx + 1]++; //?´???????????????????+1??????\n    }\n\n\n    cumulativeSum(y.size(), x.size());\n    //rep(i,y.size() + 1){ rep(j,x.size() + 1){ cout << grid[i][j] <<' '; } cout << endl; }\n    //rep(i,x.size()){ show(x[i]) }\n\n    rep(i,m){\n        int lx, ly, rx, ry;\n        cin >> lx >> ly >> rx >> ry;\n        lx = lb(x, lx);\n        ly = lb(y, ly);\n        rx = lb(x, rx + 1);//?¢???????????????????\n        ry = lb(y, ry + 1);\n        cout << sum(ly, lx, ry, rx) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// iostream のscanf, printf では間に合わなかった\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define mp make_pair\n#define pb push_back\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\t//cin >> x >> y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\twhile( 1 ){\n\t\t\tif( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\tif( (*it).first > x2 ) it = upper_bound(treasure.begin(), treasure.end(),mp(-INF,(*it).second+1));\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nshort d[10010][10010];\n\nint f(int x1, int y1, int x2, int y2){\n\treturn d[x2][y2]-d[x1][y2]-d[x2][y1]+d[x1][y1];\n}\n\nint main(){\n\tint n, m;\n\tcin>>n>>m;\n\tmap<int, int> mp;\n\tvector<pii> v(n), s(m), t(m);\n\trep(i, n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t\tmp[v[i].fi]++;\n\t\tmp[v[i].se]++;\n\t}\n\trep(i, m){\n\t\tcin>>s[i].fi>>s[i].se>>t[i].fi>>t[i].se;\n\t\tmp[s[i].fi]++;\n\t\tmp[s[i].se]++;\n\t\tmp[t[i].fi]++;\n\t\tmp[t[i].se]++;\n\t}\n\tint cnt = 0;\n\tfor(auto& p : mp) p.se = ++cnt;\n\n\trep(i, n) d[mp[v[i].fi]][mp[v[i].se]]++;\n\n\t// rep(i, 20){\n\t// \trep(j, 20) printf(\"%3d\", d[i][j]);\n\t// \tprintf(\"\\n\");\n\t// }\n\n\tfor(int i = 0; i < 10010; i++) {\n\t\tfor(int j = 0; j < 10009; j++){\n\t\t\td[i][j+1] += d[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < 10009; i++) {\n\t\tfor(int j = 0; j < 10010; j++){\n\t\t\td[i+1][j] += d[i][j];\n\t\t}\n\t}\n\trep(i, m){\n\t\tcout<<f(mp[s[i].fi]-1, mp[s[i].se]-1, mp[t[i].fi], mp[t[i].se])<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl;\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//pair?????????\ntemplate<typename T1, typename T2>\nostream &operator << (ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\n\n//??§?¨???§???\n//v: ??§???????????§?¨??????? ????????????\ntemplate<typename T>\nvoid compress(vector<T> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\n//??§?¨???§???(map)\n//v: ??§???????????§?¨??????? ????????????\n//?????????: zip[??§???????????§?¨?]:??§???????????§?¨? (zip.size()<=10^5?????????????????????)\ntemplate<typename T>\nmap<T, T> compressMap(vector<T> &v) {\n\tmap<T, T> zip;\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (T i = 0; i < v.size(); i++) zip[v[i]] = i;\n\treturn zip;\n}\n\n//??§???????????§?¨?\n//index(??§???????????§?¨?, ??§???????????§?¨??????????(??????) )\ntemplate<typename T>\nint index(T i, vector<T> v) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\n#define MAX 5100\n\n//Sample2\n//https://gyazo.com/39c67d1abe7a6a686acb52285f8a0bc9\n\nint main() {\n\t//2?¬?????´???????\n\tstatic int cumsum[MAX][MAX] = {};\n\tint xs[MAX], ys[MAX];\n\tint n, m; cin >> n >> m;\n\tvector<int> x(n + 1), y(n + 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xs[i] >> ys[i];\n\t\tx[i] = xs[i]; y[i] = ys[i];\n\t}\n\tcompress(x);\n\tcompress(y);\n\n\t//map<int, int> zipx(compressMap(x));\n\t//map<int, int> zipy(compressMap(y));\n\t//dump(x);\n\t//dump(zipx);\n\t//dump(y);\n\t//dump(zipy);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint vx = index(xs[i], x);\n\t\tint vy = index(ys[i], y);\n\t\tcumsum[vx + 1][vy + 1]++;\n\t}\n\tfor (int vy = 0; vy < y.size(); vy++)\n\t\tfor (int vx = 0; vx < x.size(); vx++)\n\t\t\tcumsum[vx + 1][vy + 1] += cumsum[vx + 1][vy] + cumsum[vx][vy + 1] - cumsum[vx][vy];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = index(x1, x);\n\t\tx2 = index(x2 + 1, x);\n\t\ty1 = index(y1, y);\n\t\ty2 = index(y2 + 1, y);\n\t\tcout << cumsum[x2][y2] - cumsum[x2][y1] - cumsum[x1][y2] + cumsum[x1][y1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(n)<=(b))\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint tx[5001],ty[5001];\n\tREP(i,0,n) {\n\t\tcin>>tx[i]>>ty[i];\n\t}\n\tint x[2],y[2];\n\tREP(i,0,m){\n\t\tint ans=0;\n\t\tcin>>x[0]>>y[0]>>x[1]>>y[1];\n\t\tREP(i,0,n) if(ck(tx[i],x[0],x[1])&&ck(ty[i],y[0],y[1])) ans++;\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(x,a,b) ((a)<=(x)&&(x)<=(b))\nusing namespace std;\nint grid[5000][2];\nint main(){\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  rep(i, n){\n    scanf(\"%d%d\", &grid[i][0], &grid[i][1]);\n  }\n  int x1, y1, x2, y2;\n  rep(i, m){\n    int res = 0;\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n    rep(j, n)\n      if(between(grid[j][0], x1, x2) && between(grid[j][1], y1, y2))\n\tres++;\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\nconst int INT_MIN = -2147483647;\n\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    vector<P> p(N);\n    REP(i, N){\n      cin>>p[i].first>>p[i].second;\n    }\n    sort(p.begin(), p.end());\n    REP(i, M){\n      int x1, y1, x2, y2;\n      scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n      vector<P>::iterator it = lower_bound(p.begin(), p.end(), P(x1, INT_MIN));\n      vector<P>::iterator end = lower_bound(p.begin(), p.end(), P(x2 + 1, INT_MIN));\n      int cnt = 0;\n      while(it != end){\n        if(it->second >= y1 && it->second <= y2) cnt++;\n        it++;\n      }\n      printf(\"%d\\n\", cnt);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2426.cc: Treasure Hunt\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 5000;\n\n/* typedef */\n\ntypedef pair<int,int> pii;\ntypedef map<int,int> mii;\n\n/* global variables */\n\nint xs[MAX_N], ys[MAX_N], sums[MAX_N + 1][MAX_N + 1];\npii pts[MAX_N];\nmii xmap, ymap;\n\n/* subroutines */\n\n/* main */\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n\n  for (int i = 0; i < n; i++) {\n    cin >> xs[i] >> ys[i];\n    pts[i] = pii(xs[i], ys[i]);\n  }\n\n  sort(xs, xs + n);\n  sort(ys, ys + n);\n  int xn = unique(xs, xs + n) - xs;\n  int yn = unique(ys, ys + n) - ys;\n  //printf(\"%d,%d\\n\", xn, yn);\n\n  for (int i = 0; i < xn; i++) xmap[xs[i]] = i;\n  for (int i = 0; i < yn; i++) ymap[ys[i]] = i;\n\n  for (int i = 0; i < n; i++)\n    sums[xmap[pts[i].first] + 1][ymap[pts[i].second] + 1]++;\n\n  for (int x = 1; x <= xn; x++)\n    for (int y = 1; y <= yn; y++) sums[x][y] += sums[x][y - 1];\n  for (int y = 1; y <= yn; y++)\n    for (int x = 1; x <= xn; x++) sums[x][y] += sums[x - 1][y];\n  //printf(\"%d\\n\", sums[xn][yn]);\n\n  while (m--) {\n    int x0, y0, x1, y1;\n    cin >> x0 >> y0 >> x1 >> y1;\n\n    int xi0 = lower_bound(xs, xs + xn, x0) - xs;\n    int yi0 = lower_bound(ys, ys + yn, y0) - ys;\n    int xi1 = upper_bound(xs, xs + xn, x1) - xs;\n    int yi1 = upper_bound(ys, ys + yn, y1) - ys;\n    \n    int sum =\n      sums[xi1][yi1] - sums[xi1][yi0] - sums[xi0][yi1] + sums[xi0][yi0];\n    printf(\"%d\\n\", sum);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<long long> X;\n    vector<long long> Y;\n    vector<long long> x(n);\n    vector<long long> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        long long x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    long long h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),X[i]) - X.begin();\n        X[i] = x[i];\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),Y[i]) - Y.begin();\n        Y[i] = y[i];\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    //cout << h << \" \" << w << endl;\n    vector<vector<long long> > imos(h + 1, vector<long long> (w + 1, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i]][x[i]]++;\n    }\n\n    \n\n    for(int j = 0; j <= w; j++){\n        for(int i = 1; i <= h; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    \n    for(int i = 0; i < m; i++){\n        long long x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin() - 1;\n\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        \n        cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        long long sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <array>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <limits>\n#include <memory>\n#include <string>\n#include <type_traits>\n\ntemplate <class Integral> class Rirange;\ntemplate <class Integral = std::size_t> class irange {\n\tconst Integral f, l;\n\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type;\n\tclass irangeitr {\n\t\tfriend irange;\n\t\tvalue_type i;\n\t\tirangeitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\treference operator*() const noexcept { return i; }\n\t\tbool operator!=(const irangeitr &x) const noexcept { return i != x.i; }\n\t};\n\tirange(value_type first, value_type last) noexcept : f(first), l(last) {}\n\tirangeitr begin() const noexcept { return irangeitr(f); }\n\tirangeitr end() const noexcept { return irangeitr(l); }\n\tRirange<value_type> rev() const noexcept { return Rirange<value_type>(f, l); }\n};\ntemplate <class Integral = std::size_t> class Rirange {\n\tconst Integral f, l;\n\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type;\n\tclass Rirangeitr {\n\t\tfriend Rirange;\n\t\tvalue_type i;\n\t\tRirangeitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\treference operator*() const noexcept { return i - 1; }\n\t\tbool operator!=(const Rirangeitr &x) const noexcept { return i != x.i; }\n\t};\n\tRirange(value_type first, value_type last) noexcept : f(first), l(last) {}\n\tRirangeitr begin() const noexcept { return Rirangeitr(l); }\n\tRirangeitr end() const noexcept { return Rirangeitr(f); }\n\tirange<value_type> rev() const noexcept { return irange<value_type>(f, l); }\n};\n\ntemplate <class T> bool maxi(T &a, const T &b) {\n\tif (b < a)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\tif (a < b)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstruct customIO {\n\tint c;\n\tbool f;\n\tstd::array<int, 30> buf;\n\tvoid get_c() { c = fgetc(stdin); }\n\tvoid put_c(int x) { fputc(x, stdout); }\n\tbool vacant() { return c == ' ' || c == '\\n'; }\n\toperator int() { return 0; }\n\n\t// in\n\n\tvoid cueing() {\n\t\twhile (get_c(), vacant())\n\t\t\t;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tf = 0;\n\t\tcueing();\n\t\tif (c == '-')\n\t\t\tf = 1, get_c();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\tif (f)\n\t\t\td = -d;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tcueing();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(char &d) {\n\t\tcueing();\n\t\td = c;\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(double &d) {\n\t\tscanf(\"%lf\", &d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(std::string &d) {\n\t\td.clear();\n\t\tcueing();\n\t\tdo\n\t\t\td.push_back(c);\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\ttemplate <class T> T input() {\n\t\tT d;\n\t\t*this >> d;\n\t\treturn d;\n\t}\n\n\t// out\n\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\tf = 0;\n\t\tif (d < static_cast<T>(0))\n\t\t\tf = 1, d = -d;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\tif (f)\n\t\t\tput_c('-');\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(char d) {\n\t\tput_c(d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const std::string &d) {\n\t\tfor (const auto e : d)\n\t\t\tput_c(e);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const char *d) {\n\t\twhile (*d != '\\0')\n\t\t\tput_c(*(d++));\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(double d) {\n\t\t/*\n\t\tprintf(\"%1.9f\",d);\n\t\t/*/\n\t\tprintf(\"%f\", d);\n\t\t//*/\n\t\treturn *this;\n\t}\n\tvoid endl() { put_c('\\n'); }\n\tvoid space() { put_c(' '); }\n} IO;\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n#include <vector>\n\ntemplate <typename Integral,\n\tstd::size_t bitsize = std::numeric_limits<Integral>::digits()>\n\tclass WaveletMatrix {\n\tpublic:\n\t\tusing value_type = Integral;\n\t\tusing size_type = std::size_t;\n\n\tprivate:\n\t\tusing uint32 = std::uint_least32_t;\n\t\tstatic size_type popcount32(uint32 c) {\n#ifdef __GNUC__\n\t\t\treturn __builtin_popcount(c);\n#elif _MSC_VER_\n\t\t\treturn _mm_popcnt_u32(c);\n#else\n\t\t\tc = (c & 0x55555555) + ((c >> 1) & 0x55555555);\n\t\t\tc = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n\t\t\tc = (c + (c >> 4)) & 0x0F0F0F0F;\n\t\t\tc += c >> 8;\n\t\t\tc += c >> 16;\n\t\t\treturn static_cast<size_type>(c) & 0x3F;\n#endif\n\t\t}\n\t\tstruct FID {\n\t\t\tstd::vector<uint32> dic;\n\t\t\tsize_type cnt;\n\t\t\tvalue_type bit;\n\t\t\tFID() {}\n\t\t\tFID(const size_type bsize) : dic(bsize, 0) {}\n\t\t\tvoid set(const size_type index) {\n\t\t\t\tdic[index >> 4 | 1] |= static_cast<uint32>(1) << (index & 0x1f);\n\t\t\t}\n\t\t\tvoid build() {\n\t\t\t\tconst size_type len = dic.size();\n\t\t\t\tfor (size_type j = 2; j < len; j += 2)\n\t\t\t\t\tdic[j] = dic[j - 2] + popcount32(dic[j - 1]);\n\t\t\t}\n\t\t\tsize_type rank(const size_type last) const {\n\t\t\t\treturn static_cast<size_type>(\n\t\t\t\t\tdic[last >> 4 & ~static_cast<size_type>(1)]) +\n\t\t\t\t\tpopcount32(dic[last >> 4 | 1] &\n\t\t\t\t\t(static_cast<size_type>(1) << (last & 0x1f)) - 1);\n\t\t\t}\n\t\t\tbool access(const size_type index) const {\n\t\t\t\treturn dic[index >> 4 | 1] >> (index & 0x1f) & 1;\n\t\t\t}\n\t\t};\n\t\tstd::array<FID, bitsize> matrix;\n\t\tvalue_type NOT_FOUND;\n\t\tsize_type size_;\n\n\tpublic:\n\t\tWaveletMatrix(std::vector<value_type> data, const value_type NOT_FOUND = 0)\n\t\t\t: size_(data.size()), NOT_FOUND(NOT_FOUND) {\n\t\t\tconst size_type len = data.size(), block = ((len >> 5) + 1) << 1;\n\t\t\tstd::vector<value_type> L(len), R(len);\n\t\t\tsize_type l, r;\n\t\t\tvalue_type temp = static_cast<value_type>(1) << (bitsize - 1);\n\t\t\tfor (auto &x : matrix) {\n\t\t\t\tx = FID(block);\n\t\t\t\tx.bit = temp;\n\t\t\t\ttemp = temp >> 1 & ~temp;\n\t\t\t\tl = 0;\n\t\t\t\tr = 0;\n\t\t\t\tfor (size_type j = 0; j < len; ++j)\n\t\t\t\t\tif (data[j] & x.bit)\n\t\t\t\t\t\tR[r++] = data[j], x.set(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tL[l++] = data[j];\n\t\t\t\tx.cnt = l;\n\t\t\t\tx.build();\n\t\t\t\tstd::swap(data, L);\n\t\t\t\tstd::copy(R.begin(), R.begin() + r, data.begin() + l);\n\t\t\t}\n\t\t}\n\n\t\tsize_type size() const noexcept { return size_; }\n\t\tbool empty() const noexcept { return size() == 0; }\n\n\t\tvalue_type access(size_type index) const {\n\t\t\tassert(index < size());\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (x.access(index))\n\t\t\t\t\tret |= x.bit, index = x.rank(index) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tindex -= x.rank(index);\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type operator[](const size_type index) const {\n\t\t\tassert(index < size());\n\t\t\treturn access(index);\n\t\t}\n\t\tsize_type rank(size_type first, size_type last, const value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (data & x.bit)\n\t\t\t\t\tfirst = x.rank(first) + x.cnt, last = x.rank(last) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tfirst -= x.rank(first), last -= x.rank(last);\n\t\t\treturn last - first;\n\t\t}\n\t\tvalue_type quantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tconst size_type l = x.rank(first), r = x.rank(last);\n\t\t\t\tif (r - l > k)\n\t\t\t\t\tfirst = l + x.cnt, last = r + x.cnt, ret |= x.bit;\n\t\t\t\telse\n\t\t\t\t\tfirst -= l, last -= r, k -= r - l;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type rquantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\treturn quantile(first, last, last - first - k - 1);\n\t\t}\n\t\tsize_type less_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_least(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type greater_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_most(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type rangefreq(size_type first, size_type last, const value_type lower,\n\t\t\tconst value_type upper) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tassert(lower <= upper);\n\t\t\treturn at_least(first, last, lower) - at_least(first, last, upper);\n\t\t}\n\t\tvalue_type successor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type predecessor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n\t\tvalue_type strict_succ(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type strict_pred(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n};\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <vector>\n\ntemplate <class T>\nusing StaticSetDefaultContainer = std::vector<T, std::allocator<T>>;\n\ntemplate <class T = std::uint_fast32_t,\n\ttemplate <class> class Container = StaticSetDefaultContainer,\n\tclass Compare = std::less<typename Container<T>::value_type>>\n\tclass StaticSet {\n\tpublic:\n\t\tusing container_type = Container<T>;\n\t\tusing value_compare = Compare;\n\t\tusing value_type = typename container_type::value_type;\n\t\tusing reference = typename container_type::reference;\n\t\tusing const_reference = typename container_type::const_reference;\n\t\tusing size_type = typename container_type::size_type;\n\t\tusing difference_type = typename container_type::difference_type;\n\t\tusing pointer = typename container_type::pointer;\n\t\tusing const_pointer = typename container_type::const_pointer;\n\t\tclass const_iterator : public std::random_access_iterator_tag {\n\t\t\tfriend StaticSet;\n\n\t\tpublic:\n\t\t\tusing difference_type = typename StaticSet::difference_type;\n\t\t\tusing value_type = typename StaticSet::value_type;\n\t\t\tusing pointer = typename StaticSet::const_pointer;\n\t\t\tusing reference = typename StaticSet::const_reference;\n\n\t\tprivate:\n\t\t\tusing iterator_type = typename StaticSet::container_type::const_iterator;\n\t\t\titerator_type it;\n\t\t\tdifference_type ord;\n\t\t\texplicit const_iterator(iterator_type x, difference_type y)\n\t\t\t\t: it(x), ord(y) {}\n\n\t\tpublic:\n\t\t\treference operator*() const { return *it; }\n\t\t\tpointer operator->() const { return std::addressof(operator*()); }\n\t\t\treference operator[](difference_type n) const { return it[n]; }\n\n\t\t\tconst_iterator &operator++() {\n\t\t\t\tif (++ord)\n\t\t\t\t\t++it;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator++(int) {\n\t\t\t\tauto ret = *this;\n\t\t\t\toperator++();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst_iterator &operator--() {\n\t\t\t\tif (ord--)\n\t\t\t\t\t--it;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator--(int) {\n\t\t\t\tauto ret = *this;\n\t\t\t\toperator--();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst_iterator &operator+=(difference_type n) {\n\t\t\t\tif (ord >= static_cast<difference_type>(0))\n\t\t\t\t\tit += n, ord += n;\n\t\t\t\telse if (n)\n\t\t\t\t\tit += n - 1, ord += n;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator+(difference_type n) const {\n\t\t\t\tif (ord >= static_cast<difference_type>(0))\n\t\t\t\t\treturn const_iterator(it + n, ord + n);\n\t\t\t\telse\n\t\t\t\t\treturn const_iterator(it + n - 1, ord + n);\n\t\t\t}\n\t\t\tconst_iterator &operator-=(difference_type n) {\n\t\t\t\tit -= n, ord -= n;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator-(difference_type n) const {\n\t\t\t\treturn const_iterator(it - n, ord - n);\n\t\t\t}\n\n\t\t\tdifference_type operator-(const const_iterator &other) const {\n\t\t\t\treturn ord - other.ord;\n\t\t\t}\n\n\t\t\tbool operator==(const const_iterator &other) const {\n\t\t\t\treturn it == other.it && ord == other.ord;\n\t\t\t}\n\t\t\tbool operator!=(const const_iterator &other) const {\n\t\t\t\treturn it != other.it || ord != other.ord;\n\t\t\t}\n\t\t\tbool operator<(const const_iterator &other) const {\n\t\t\t\treturn ord < other.ord;\n\t\t\t}\n\t\t\tbool operator<=(const const_iterator &other) const {\n\t\t\t\treturn ord <= other.ord;\n\t\t\t}\n\t\t\tbool operator>(const const_iterator &other) const {\n\t\t\t\treturn ord > other.ord;\n\t\t\t}\n\t\t\tbool operator>=(const const_iterator &other) const {\n\t\t\t\treturn ord >= other.ord;\n\t\t\t}\n\n\t\t\treference value() const { return operator*(); }\n\t\t\tdifference_type order() const { return ord; }\n\t\t};\n\t\tusing iterator = const_iterator;\n\n\tprotected:\n\t\tcontainer_type c;\n\t\tvalue_compare comp;\n\n\tprivate:\n\t\tconst_iterator make_citr(typename const_iterator::iterator_type it) const {\n\t\t\treturn const_iterator(it, std::distance(c.cbegin(), it));\n\t\t}\n\n\tpublic:\n\t\tStaticSet() : c(), comp() {}\n\t\texplicit StaticSet(const value_compare &x) : comp(x) {}\n\t\texplicit StaticSet(const value_compare &x, const container_type &other)\n\t\t\t: c(other), comp(x) {\n\t\t\tbuild();\n\t\t}\n\t\texplicit StaticSet(const value_compare &x, container_type &&other)\n\t\t\t: c(std::move(other)), comp(x) {\n\t\t\tbuild();\n\t\t}\n\n\t\tconst_iterator cbegin() const { return make_citr(c.cbegin()); }\n\t\tconst_iterator cend() const { return make_citr(c.cend()); }\n\t\titerator begin() { return cbegin(); }\n\t\titerator end() { return cend(); }\n\n\t\tsize_type size() const { return c.size(); }\n\t\tbool empty() const { return c.empty(); }\n\t\tvoid reserve(const size_type s) { c.reserve(s); }\n\t\tvoid shrink_to_fit() { c.shrink_to_fit(); }\n\n\t\tconst_reference operator[](size_type n) const {\n\t\t\tassert(n < size());\n\t\t\treturn c[n];\n\t\t}\n\t\tconst_reference at(size_type n) const { return c.at(n); }\n\t\tconst_reference min() const {\n\t\t\tassert(!empty());\n\t\t\treturn c.front();\n\t\t}\n\t\tconst_reference max() const {\n\t\t\tassert(!empty());\n\t\t\treturn c.back();\n\t\t}\n\t\tconst_iterator succ(const value_type &x) const {\n\t\t\treturn make_citr(std::lower_bound(c.cbegin(), c.cend(), x, comp));\n\t\t}\n\t\tconst_iterator pred(const value_type &x) const {\n\t\t\treturn make_citr(std::upper_bound(c.cbegin(), c.cend(), x, comp) - 1);\n\t\t}\n\t\tconst_iterator strict_succ(const value_type &x) const {\n\t\t\treturn make_citr(std::upper_bound(c.cbegin(), c.cend(), x, comp));\n\t\t}\n\t\tconst_iterator strict_pred(const value_type &x) const {\n\t\t\treturn make_citr(std::lower_bound(c.cbegin(), c.cend(), x, comp) - 1);\n\t\t}\n\n\t\tvoid push(const value_type &x) { c.push_back(x); }\n\t\tvoid push(value_type &&x) { c.push_back(std::move(x)); }\n\t\ttemplate <class... Args> void emplace(Args &&... args) {\n\t\t\tc.emplace_back(std::forward<Args>(args)...);\n\t\t}\n\t\tvoid build() { std::sort(c.begin(), c.end(), comp); }\n\t\tvoid unique() { c.erase(std::unique(c.begin(), c.end()), c.end()); }\n\t\tvoid clear() { c.clear(); }\n};\n\nint main() {\n\tconstexpr int32 base = 1000000000;\n\tuint32 n, m;\n\tIO >> n >> m;\n\tusing P = std::pair<int32, int32>;\n\tStaticSet<P> s;\n\ts.reserve(n);\n\twhile (n--) {\n\t\tint32 x, y;\n\t\tIO >> x >> y;\n\t\ty += base;\n\t\ts.emplace(x, y);\n\t}\n\ts.build();\n\tstd::vector<uint32> a;\n\ta.reserve(s.size());\n\tfor (const auto &e : s)\n\t\ta.emplace_back(e.second);\n\tWaveletMatrix<uint32, 31> W(a);\n\twhile (m--) {\n\t\tint32 a, b, c, d;\n\t\tIO >> a >> b >> c >> d;\n\t\t++c;\n\t\t++d;\n\t\tb += base;\n\t\td += base;\n\t\tIO << W.rangefreq(s.succ(P(a, 0)).order(), s.succ(P(c, 0)).order(), b, d) << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n\n#include <iostream>\n#include <complex>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n\n#include <functional>\n#include <cassert>\n\ntypedef long long ll;\nusing namespace std;\n\n#ifndef LOCAL\n#define debug(x) ;\n#else\n#define debug(x) cerr << __LINE__ << \" : \" << #x << \" = \" << (x) << endl;\n\ntemplate <typename T1, typename T2>\nostream &operator<<(ostream &out, const pair<T1, T2> &p) {\n  out << \"{\" << p.first << \", \" << p.second << \"}\";\n  return out;\n}\n\ntemplate <typename T>\nostream &operator<<(ostream &out, const vector<T> &v) {\n  out << '{';\n  for (const T &item : v) out << item << \", \";\n  out << \"\\b\\b}\";\n  return out;\n}\n#endif\n\n#define mod 1000000007 //1e9+7(prime number)\n#define INF 1000000000 //1e9\n#define LLINF 2000000000000000000LL //2e18\n#define SIZE 5010\n\nint sum[SIZE][SIZE];\n\nint main(){\n  int N, M, x[SIZE], y[SIZE];\n  vector<int> vecX, vecY;\n  map<int,int> dicX, dicY;\n\n  scanf(\"%d%d\", &N, &M);\n\n  for (int i=0; i<N; i++) {\n    scanf(\"%d%d\", x+i, y+i);\n    vecX.push_back(x[i]);\n    vecY.push_back(y[i]);\n  }\n\n  vecX.push_back(-INF-10);\n  vecY.push_back(-INF-10);\n\n  sort(vecX.begin(), vecX.end());\n  vecX.erase(unique(vecX.begin(), vecX.end()), vecX.end());\n  sort(vecY.begin(), vecY.end());\n  vecY.erase(unique(vecY.begin(), vecY.end()), vecY.end());\n\n  for (int i=0; i<vecX.size(); i++) dicX[vecX[i]] = i;\n  for (int i=0; i<vecY.size(); i++) dicY[vecY[i]] = i;\n\n  for (int i=0; i<N; i++) {\n    sum[dicX[x[i]]][dicY[y[i]]]++;\n  }\n\n  for (int i=0; i<=N; i++)\n    for (int j=0; j<=N; j++)\n      sum[i+1][j] += sum[i][j];\n\n  for (int i=0; i<=N; i++)\n    for (int j=0; j<=N; j++)\n      sum[i][j+1] += sum[i][j];\n\n  for (int i=0; i<M; i++) {\n    int x1, y1, x2, y2;\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\n    x1 = lower_bound(vecX.begin(), vecX.end(), x1) - vecX.begin();\n    y1 = lower_bound(vecY.begin(), vecY.end(), y1) - vecY.begin();\n    x2 = lower_bound(vecX.begin(), vecX.end(), x2+1) - vecX.begin() - 1;\n    y2 = lower_bound(vecY.begin(), vecY.end(), y2+1) - vecY.begin() - 1;\n\n    int ans = sum[x1-1][y1-1] + sum[x2][y2] - sum[x1-1][y2] - sum[x2][y1-1];\n\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nint treasure[5002][5002];\nint x[5000];int y[5000];\nint cpx[5000]; int cpy[5000];\nmap<int,int> xind;\nmap<int,int> yind;\nint main()\n{\n\tfill(treasure[0],treasure[5000],0);\n\tint n,m;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>x[i]>>y[i];\n\t\tcpx[i]=x[i];\n\t\tcpy[i]=y[i];\n\t}\n\tsort(cpx,cpx+n);\n\tsort(cpy,cpy+n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\txind[cpx[i]]=i;\n\t\tyind[cpy[i]]=i;\n\t}\n\t//座圧した座標で累積和\n\tfor(int i=0;i<n;i++)\n\t\ttreasure[xind[x[i]]+1][yind[y[i]]+1]++;\n\t//累積和\n\t//横\n\tfor(int i=1;i<5002;i++)\n\t{\n\t\tfor(int j=1;j<5002;j++)\n\t\t\ttreasure[i][j]+=treasure[i][j-1];\n\t}\n\t//縦\n\tfor(int i=1;i<5002;i++)\n\t{\n\t\tfor(int j=1;j<5002;j++)\n\t\t\ttreasure[i][j]+=treasure[i-1][j];\n\t}\n\t// for(int i=0;i<n+1;i++)\n\t// {\n\t// \tfor(int j=0;j<n+1;j++)\n\t// \t\tcerr<<treasure[i][j]<<\" \";\n\t// \tcerr<<endl;\n\t// }\n\t//クエリ\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\ta--;b--;\n\t\tint aind,bind,cind,dind;\n\t\taind=upper_bound(cpx,cpx+n,a)-cpx;\n\t\tif(a<*(cpx+aind))\n\t\t\taind--;\n\t\tbind=upper_bound(cpy,cpy+n,b)-cpy;\n\t\tif(b<*(cpy+bind))\n\t\t\tbind--;\n\t\tcind=upper_bound(cpx,cpx+n,c)-cpx;\n\t\tdind=upper_bound(cpy,cpy+n,d)-cpy;\n\t\taind++;bind++;\n\t\t//cerr<<aind<<\" \"<<bind<<\" \"<<cind<<\" \"<<dind<<endl;\n\t\tint ans=treasure[cind][dind]-treasure[cind][bind]-treasure[aind][dind]+treasure[aind][bind];\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\ntypedef complex<double> point;\nint ans;\nstruct kdtree {\n\tstruct node {\n\t\tpoint p;\n\t\tnode *l, *r;\n\t\tnode(const point &p)\n\t\t\t: p(p), l(NULL), r(NULL) { }\n\t} *root;\n\tkdtree() : root(NULL) { }\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n\tvoid insert(const point &p) {\n\t\troot = insert(root, 0, p);\n\t}\n\tnode *insert(node *t, int d, const point &p) {\n\t\tif (t == NULL) return new node(p);\n\t\tif (compare(d, p, t->p)) t->l = insert(t->l, !d, p);\n\t\telse                   t->r = insert(t->r, !d, p);\n\t\treturn t;\n\t}\n\tvoid search(const point &ld, const point &ru) {\n\t\tsearch_(root, 0, ld, ru);\n\t}\n\tvoid search_(node *t, int d, const point &ld, const point &ru) {\n\t\tif (t == NULL) return;\n\t\tconst point &p = t->p;\n\t\tif (real(ld) <= real(p) && real(p) <= real(ru) &&\n\t\t\timag(ld) <= imag(p) && imag(p) <= imag(ru)) ans++;\n\t\tif (!compare(d, p, ld)) search_(t->l, !d, ld, ru);\n\t\tif (!compare(d, ru, p)) search_(t->r, !d, ld, ru);\n\t}\n};\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<point> v;\n\tREP(i, n)\n\t{\n\t\tld x, y; cin >> x >> y;\n\t\tv.emplace_back(x, y);\n\t}\n\trandom_shuffle(ALL(v));\n\tkdtree kd;\n\tREP(i, n)\n\t{\n\t\tkd.insert(v[i]);\n\t}\n\tREP(i, m)\n\t{\n\t\tld a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tpoint l(a, b), r(c, d);\n\t\tans = 0;\n\t\tkd.search(l, r);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// iostream のscanf, printf では間に合わなかった\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define mp make_pair\n#define pb push_back\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\t//cin >> x >> y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\tvector<pii>::iterator ite = upper_bound(treasure.begin(),treasure.end(),mp(x2,y2));\n\t\twhile( 1 ){\n\t\t\tif( it == ite ) break;\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A[5010][2];\nint S[10005][10005];\nint ANS = 0;\nint *R;\nint Xs[10005], Ys[10005];\nmap<int,int> zipx, zipy;\nint MAX = 1000000001;\n \nint compress(int *X, map<int, int> &zip, int n) {\n    sort(X, X + n);\n    R = unique(X, X + n);\n    int k = R - X;\n    for(int i = 0; i < k; i++){\n        zip[X[i]] = i;\n    }\n    return k;\n}\n \nint main(){\n    int N, M, x1, y1, x2, y2, xn, yn, ans;\n    cin >> N >> M;\n    for (int n = 0; n < N; n++) {\n        cin >> x1 >> y1;\n        A[n][0] = x1; A[n][1] = y1;\n        Xs[n * 2] = x1;\n        Xs[n * 2 + 1] = x1 - 1;\n        Ys[n * 2] = y1;\n        Ys[n * 2 + 1] = y1 - 1;\n    }\n     \n    Xs[N * 2] = -1 * MAX;\n    Xs[N * 2 + 1] = MAX;\n    Ys[N * 2] = -1 * MAX;\n    Ys[N * 2 + 1] = MAX;\n     \n    xn = compress(Xs, zipx, N * 2 + 2);\n    yn = compress(Ys, zipy, N * 2 + 2);\n     \n     \n    for (int n = 0; n < N; n ++) {\n        x1 = zipx[A[n][0]];\n        y1 = zipy[A[n][1]];\n        S[x1][y1] ++;\n    }\n     \n    for (int x = 1; x <= xn; x++) {\n        for (int y = 1; y <= yn; y ++) {\n            S[x][y] += S[x - 1][y] + S[x][y - 1] - S[x - 1][y - 1];\n        }\n    }\n    for (int m = 0; m < M; m ++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n         \n        x1 = *lower_bound(Xs, Xs + xn, x1 - 1);\n        y1 = *lower_bound(Ys, Ys + yn, y1 - 1);\n        x2 = *lower_bound(Xs, Xs + xn, x2);\n        y2 = *lower_bound(Ys, Ys + yn, y2);\n         \n        x1 = zipx[x1];\n        x2 = zipx[x2];\n        y1 = zipy[y1];\n        y2 = zipy[y2];\n         \n        ans = S[x2][y2] - S[x1][y2] - S[x2][y1] + S[x1][y1];\n         \n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.TH\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nset<int> x, y;\t\t// 座標全体\nmap<int,int>xx, yy;\t// 圧縮した座標\nvector<int>rx, ry;\t// 圧縮した座標→元の座標の変換テーブル\n\nvoid compress (void ) \n{\n\txx.clear(); yy.clear();\n\trx.clear(); ry.clear();\n\tint sx = x.size();\n\tint sy = y.size();\n\trx.resize (sx, 0 ); ry.resize (sy, 0 );\n\tset<int>::iterator it = x.begin();\n\tfor(int i = 0; it != x.end(); i++, it++ ){\n\t\tint curr = (*it);\n\t\txx[curr] = i;\n\t\trx[i] = curr;\n\t} // end for\n\n\tset<int>::iterator jt = y.begin();\n\tfor (int j = 0; jt != y.end(); j++, jt++ ){\n\t\tint curr = (*jt);\n\t\tyy[curr] = j;\n\t\try[j] = curr;\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tint n, m;\n\tscanf (\"%d %d\", &n, &m );\n\tmap<P,int> cnt; cnt.clear();\n\tx.clear(); y.clear();\n\tvector<int> tx (n, 0 ), ty (n, 0 );\n\trep (i, n ){\n\t\tscanf (\"%d %d\", &tx[i], &ty[i] );\n\t\tcnt[P(tx[i],ty[i])]++;\n\t\tfor (int d = -1; d <= 1; d++ ){\n\t\t\tx.insert (tx[i]+d ); y.insert (ty[i]+d );\n\t\t} // end for\n\t} // end rep\n\tvector<int> x1 (m, 0 ), y1 (m, 0 ), x2 (m, 0 ), y2 (m, 0 );\n\trep (j, m ){\n\t\tscanf (\"%d %d %d %d\", &x1[j], &y1[j], &x2[j], &y2[j] );\n\t\tfor (int d = -1; d <= 1; d++ ){\n\t\t\tx.insert (x1[j]+d ); x.insert (x2[j]+d );\n\t\t\ty.insert (y1[j]+d ); y.insert (y2[j]+d );\n\t\t} // end for\n\t} // end rep \n\tcompress ();\n\n\trep (j, m ){\n\t\tint res = 0;\n\t\tfor (int cy = yy[y1[j]]; cy <= yy[y2[j]]; cy++ ){\n\t\t\tfor (int cx = xx[x1[j]]; cx <= xx[x2[j]]; cx++ ){\n\t\t\t\tint ttx = rx[cx], tty = ry[cy];\n\t\t\t\tres += cnt[P(ttx, tty )];\n\t\t\t} // end for\n\t\t} // end for\n\t\tprintf (\"%d\\n\", res );\n\t} // end rep\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n\n#include<iostream>\n#include<fstream>\n#include<vector>\n#include<map>\n#include<algorithm>\n\n#define fin cin\n\nusing namespace std;\n\nint main(){\n    ifstream fin(\"input.txt\");\n\n    //???????????§?¨????????????????\n    multimap<int, int> mp_x;\n\n    int n, m;\n    fin >> n >> m;\n\n    int x[5000], y[5000];\n    vector<int> vec_x,vec_y;\n\n    for(int i = 0; i < n; i++){\n        fin >> x[i] >> y[i];\n\n\n        mp_x.insert(make_pair(x[i], i));\n\n        //vec_x.push_back(x[i]);\n        vec_y.push_back(y[i]);\n    }\n\n\n\n\n    for(int i = 0; i < m; i++){\n        int ans = 0;\n        int x1, y1, x2, y2;\n        fin >> x1 >> y1 >> x2 >> y2;\n        \n        for(multimap<int, int>::iterator itr = mp_x.lower_bound(x1); itr != mp_x.end(); itr++){\n            int val = y[itr->second];\n            if(y1 < val && val < y2)ans++;\n\n        }\n        cout << ans << endl;\n    }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9 + 2;\n\n\nint d[5002 * 3][5002 * 3];\nint id[5002 * 3][5002 * 3];\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> ix(n), iy(n);\n\n\t//??§?¨???§?????¨????????????\n\tvector<int> ax, ay;\n\tmap<int, int> mx, my, ym, xm;\n\n\n\trep(i, n){\n\t\tcin >> ix[i] >> iy[i];\n\t\trep(j, 3){\n\t\t\tax.push_back(ix[i] + j - 1);\n\t\t\tay.push_back(iy[i] + j - 1);\n\t\t}\n\t}\n\tax.push_back(-INF - 1);\n\tay.push_back(-INF - 1);\n\tax.push_back( INF + 1);\n\tay.push_back( INF + 1);\n\n\tsort(all(ax));\n\tsort(all(ay));\n\n\trep(i, ax.size()){\n\t\tmx[ax[i]] = i;\n\t\txm[i] = ax[i];\n\t}\n\trep(i, ay.size()){\n\t\tmy[ay[i]] = i;\n\t\tym[i] = ay[i];\n\t}\n\n\t//??\\??????????????????map??§????¬????????????§?????£?????????\n\tclr(id);\n\trep(i, n){\n\t\tid[mx[ix[i]]][my[iy[i]]]++;\n\t}\n\n\t//d[x][y] 0 - x  0 - y ??????????????????????±?????????????\n\tclr(d);\n\tFor(x,1, 5002)For(y,1, 5002){\n\t\td[x][y] = d[x - 1][y] + d[x][y - 1] - d[x - 1][y - 1] + id[x][y];\n\t}\n\n\trep(i, m){\n\t\tint qx1, qy1, qx2, qy2;\n\t\tcin >> qx1 >> qy1 >> qx2 >> qy2;\n\t\tint rx, ry, lx, ly;\n\t\tqx1--; qy1--;\n\t\tif (mx.count(qx1)){\n\t\t\tlx = mx[qx1];\n\t\t}\n\t\telse{\n\t\t\tmx[qx1] = -1;\n\t\t\tauto p = mx.find(qx1);\n\t\t\tlx = prev(p)->second;\n\t\t\tmx.erase(qx1);\n\t\t}\n\t\tif (my.count(qy1)){\n\t\t\tly = my[qy1];\n\t\t}\n\t\telse{\n\t\t\tmy[qy1] = -1;\n\t\t\tauto p = my.find(qy1);\n\t\t\tly = prev(p)->second;\n\t\t\tmy.erase(qy1);\n\t\t}\n\n\t\tif (mx.count(qx2)){\n\t\t\trx = mx[qx2];\n\t\t}\n\t\telse{\n\t\t\tmx[qx2] = -1;\n\t\t\tauto p = mx.find(qx2);\n\t\t\trx = next(p)->second;\n\t\t\tmx.erase(qx2);\n\t\t}\n\n\t\tif (my.count(qy2)){\n\t\t\try = my[qy2];\n\t\t}\n\t\telse{\n\t\t\tmy[qy2] = -1;\n\t\t\tauto p = my.find(qy2);\n\t\t\try = next(p)->second;\n\t\t\tmy.erase(qy2);\n\t\t}\n\n\t\tcout << d[rx][ry] + d[lx][ly] - d[lx][ry] - d[rx][ly] << endl;\n\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nint main(){\n    int n, m;\n    int A;\n    cin >> n >> m;\n    \n    vector<int> x(n);\n    vector<int> y(n);\n    vector<int> xb(m);\n    vector<int> yb(m);\n    vector<int> xe(m);\n    vector<int> ye(m);\n    \n    for(int j = 0 ; j < n ; j++)\n        cin >> x[j] >> y[j];\n    \n    for(int i = 0 ; i < m ; i++)\n        cin >> xb[i] >> yb[i] >> xe[i] >> ye[i];\n    \n    for(int i = 0 ; i < m ; i++){\n        A = 0;\n        for(int j = 0 ; j < n ; j++){\n            if( xb[i] <= x[j] && x[j] <= xe[i] && yb[i] <= y[j] && y[j] <= ye[i] )\n                A++;\n        }\n        cout << A <<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1e9 + 10;\n\nint xs[5001], ys[5001];\nint sum[5100][5100];\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<int> X, Y;\n  rep(i, N) {\n    scanf(\"%d%d\", &xs[i], &ys[i]);\n    X.push_back(xs[i]); Y.push_back(ys[i]);\n  }\n\n  random_shuffle(all(X)), random_shuffle(all(Y));\n  sort(X.begin(), X.end()); X.erase(unique(all(X)), X.end());\n  sort(Y.begin(), Y.end()); Y.erase(unique(all(Y)), Y.end());\n\n  rep(i, N) {\n    sum[upper_bound(all(Y), ys[i]) - Y.begin()][upper_bound(all(X), xs[i]) - X.begin()] ++;\n  }\n\n  rep(i, Y.size() + 10) rep(j, X.size() + 10) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int rx1, ry1, rx2, ry2; scanf(\"%d%d%d%d\", &rx1, &ry1, &rx2, &ry2);\n    int x1 = lower_bound(all(X), rx1) - X.begin();\n    int y1 = lower_bound(all(Y), ry1) - Y.begin();\n    int x2 = upper_bound(all(X), rx2) - X.begin();\n    int y2 = upper_bound(all(Y), ry2) - Y.begin();\n    printf(\"%d\\n\", sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 5000;\n\n\nint n, m;\nint w, h;\n\nint board[MAX_N][MAX_N];\n\nint X[MAX_N], Y[MAX_N];\nstd::vector<int> vx, vy;\n\nint compress(int *x,std::vector<int>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\tboard[Y[i]][X[i]] = 1;\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tint sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\n\tint x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[5000][5000];\nint X[5000], Y[5000];\nint X1[500000], X2[500000], Y1[500000], Y2[500000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nsigned main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\ntypedef pair<int , int> P;\n\nint main ()\n{\n\tint N,M;\n\tcin >> N>>M;\n\tvector<P>data(N);\n\tfor( size_t i = 0; i < N; i++ )\n\t{\n\t\tP in;\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort ( data.begin () , data.end () );\n\tfor( size_t i = 0; i < M; i++ )\n\t{\n\t\tlong long int count = 0;\n\t\tP S , G , S_ , G_;\n\t\tcin >> S.first >> S.second >> G.first >> G.second;\n\t\tauto binary = [=]( P X )\n\t\t{\n\t\t\tint x = 0 , y = N - 1;\n\t\t\twhile( x+1 < y )\n\t\t\t{\n\t\t\t\tint z = ( x + y ) / 2;\n\t\t\t\tif( data[z].first >= X.first )\n\t\t\t\t{\n\t\t\t\t\ty = z;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tx = z;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn x;\n\t\t};\n\t\tS_.first = binary ( S );\n\t\tG_.first = binary ( G );\n\t\tfor( size_t j = max(0,S_.first-2); j < min(N,G_.first + 4); j++ )\n\t\t{\n\t\t\tif( data[j].first <= G.first&&data[j].first >= S.first )\n\t\t\t{\n\t\t\t\tif( data[j].second <= G.second&&data[j].second >= S.second )\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, q, xa, ya, xb, yb, xc[5555], yc[5555], xd[5555], yd[5555]; pair<int, int> p1[5555], p2[5555];\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\", &p1[i].first, &p1[i].second), p2[i] = make_pair(p1[i].second, p1[i].first);\n\tsort(p1, p1 + n); sort(p2, p2 + n);\n\tfor(int i = 0; i < n; i++) xc[i] = p1[i].first, yc[i] = p1[i].second, xd[i] = p2[i].second, yd[i] = p2[i].first;\n\tfor(int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d%d\", &xa, &ya, &xb, &yb);\n\t\tint l1 = lower_bound(xc, xc + n, xa) - xc;\n\t\tint r1 = lower_bound(xc, xc + n, xb + 1) - xc;\n\t\tint l2 = lower_bound(yd, yd + n, ya) - yd;\n\t\tint r2 = lower_bound(yd, yd + n, yb + 1) - yd;\n\t\tint c = 0;\n\t\tif(r1 - l1 <= r2 - l2) {\n\t\t\tfor(int j = l1; j < r1; j++) {\n\t\t\t\tif(ya <= yc[j] && yc[j] <= yb) c++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j = l2; j < r2; j++) {\n\t\t\t\tif(xa <= xd[j] && xd[j] <= xb) c++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n, m;\nint x[101010], y[101010];\nvector<int> xx, yy;\nint rui[5050][5050];\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t\txx.emplace_back(x[i]);\n\t\tyy.emplace_back(y[i]);\n\t}\n\txx.emplace_back(-HINF);\n\txx.emplace_back(HINF);\n\tyy.emplace_back(-HINF);\n\tyy.emplace_back(HINF);\n\n\tUNIQUE(xx);\n\tUNIQUE(yy);\n\n\tREP(i, n) {\n\t\tint xxx = lower_bound(ALL(xx), x[i]) - xx.begin();\n\t\tint yyy = lower_bound(ALL(yy), y[i]) - yy.begin();\n\t\trui[yyy][xxx]++;\n\t}\n\tREP(i, n+2) {\n\t\tREP(j, n+2) {\n\t\t\tif (i > 0 && j > 0) {\n\t\t\t\trui[i][j] += rui[i][j - 1] + rui[i - 1][j];\n\t\t\t\trui[i][j] -= rui[i - 1][j - 1];\n\t\t\t}\n\t\t\telse if (i > 0)rui[i][j] += rui[i - 1][j];\n\t\t\telse if (j > 0)rui[i][j] += rui[i][j - 1];\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tint x1, x2, y1, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = lower_bound(ALL(xx), x1) - xx.begin();\n\t\ty1 = lower_bound(ALL(yy), y1) - yy.begin();\n\t\tx2 = upper_bound(ALL(xx), x2) - xx.begin() - 1;\n\t\ty2 = upper_bound(ALL(yy), y2) - yy.begin() - 1;\n\t\tcout << rui[y2][x2] - rui[y1 - 1][x2] - rui[y2][x1 - 1] + rui[x1 - 1][y1 - 1] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[5000], Y[5000];\nint X1[5000], X2[5000], Y1[5000], Y2[5000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = --upper_bound(v.begin(), v.end(), X2[i]) - v.begin();\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn v.size();\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<stack>\n#include<deque>\n#include<iostream>\n#include<cstdio>\n#define F first\n#define S second\n#define LIM 1000000010\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<int,int> P;\nint dp[5002][5002];\nint main(){\n  int n,m;\n \n  vector<int> X,Y;\n  \n  while(cin >> n >> m){\n    for(int i=0;i<5000;i++)for(int j=0;j<5000;j++)dp[j][i] = 0;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      X.pb(x); Y.pb(y);\n    }\n    vector<int> x,y;\n    x = X;\n    y = Y;\n    X.pb(-LIM); X.pb(LIM); Y.pb(-LIM); Y.pb(LIM);\n    sort(all(X)); sort(all(Y));\n    X.erase(unique(all(X)),X.end());\n    Y.erase(unique(all(Y)),Y.end());\n    for(int i=0;i<n;i++){\n      x[i] = lower_bound(all(X),x[i])-X.begin();\n      y[i] = lower_bound(all(Y),y[i])-Y.begin();\n      dp[y[i]][x[i]]++;\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\tdp[i+1][j+1] += dp[i+1][j]+dp[i][j+1]-dp[i][j];\n\n      }\n\n    }\n    for(int i=0;i<m;i++){\n      int sx,sy,gx,gy;\n      cin >> sx >> sy >> gx >> gy;\n      sx = lower_bound(all(X),sx)-X.begin();\n      sy = lower_bound(all(Y),sy)-Y.begin();\n      gx = upper_bound(all(X),gx)-X.begin()-1;\n      gy = upper_bound(all(Y),gy)-Y.begin()-1;\n      cout << dp[gy][gx]-dp[gy][sx-1]-dp[sy-1][gx]+dp[sy-1][sx-1] << endl;\n\n    }\n\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb emplace_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\ntemplate<int N>\nstruct FID {\n  using Bits = uint32_t;\n  static const int B = 8*sizeof(Bits);\n  static const int SZ = N/B+2;\n\n  int n;\n  array<int, N> sel[2];\n\n  array<int, SZ> buck;\n  array<Bits, SZ> bits;\n\n  FID() {}\n  FID(int n, bool bs[]) : n(n), buck(), bits() {\n    int cnt = 0;\n    int idx = 0;\n    rep(i, n/B + (n%B != 0)) {\n      rep(j, B) {\n        if (idx >= n) break;\n        cnt += bs[idx];\n        bits[i] |= Bits(bs[idx]) << j;\n        idx++;\n      }\n      buck[i+1] = cnt;\n    }\n    \n    rep(i, 2) sel[i].fill(-1);\n    cnt = 0;\n    rep(i, n) {\n      if (bs[i]) {\n        sel[1][cnt] = i;\n        cnt++;\n      } else {\n        sel[0][i-cnt] = i;\n      }\n    }\n  }\n\n  int Count(bool v, int r) {\n    int ret = buck[r/B] + __builtin_popcount(bits[r/B] % (1<<(r%B)));\n    if (!v) ret = r - ret;\n    return ret;\n  }\n\n  int Select(bool v, int k) {\n    if (k < 0 || k >= n) return -1;\n    return sel[v][k];\n  }\n\n  int SelectFrom(int from, bool v, int k) {\n    return Select(v, Count(v, from) + k);\n  }\n\n  bool operator[](int k) {\n    return bits[k/B] >> (k%B) & 1;\n  }\n};\n\ntemplate<int N, class T=unsigned int>          \nstruct Wavelet {\n  static const int D = 8*sizeof(T);\n  int n;\n  int sep[D];\n  FID<N> dat[D];\n  T arr[N];\n\n  Wavelet(int n, T ini[]) : n(n) {\n    T l[N];\n    T r[N];\n    T src[N];\n    bool bs[N];\n\n    copy(ini, ini+n, arr);\n    copy(ini, ini+n, src);\n    rep (d, D) {\n      int rk = 0;\n      int lk = 0;\n      rep(i, n) {\n        bool t = src[i] >> (D-d-1) & 1;\n        if (t) r[rk++] = src[i];\n        else l[lk++] = src[i];\n        bs[i] = t;\n      }\n      dat[d] = FID<N>(n, bs);\n      sep[d] = lk;\n      swap(l, src);\n      copy(r, r+rk, src+lk);\n    }\n  }\n\n  int Count(T val, int l, int r) {\n    if (r <= l) return 0;\n    rep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      l = dat[d].count(b, l) + b*sep[b];\n      r = dat[d].count(b, r) + b*sep[b];\n    }\n    return r-l;\n  }\n\n  int Select(T val, int k) {\n    int ls[D+1];\n    int rs[D+1];\n    ls[0] = 0;\n    rs[0] = n;\n    rep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      ls[d+1] = dat[d].count(b, ls[d]) + b*sep[b];\n      rs[d+1] = dat[d].count(b, rs[d]) + b*sep[b];\n    }\n    rrep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      k = dat[d].SelectFrom(ls[d], b, k);\n      if (k < 0 || k >= rs[d]) return -1;\n      k -= ls[d];\n    }\n    return k;\n  }\n\n  T KthNumber(int l, int r, int k) {\n    if (k < 0 || k >= r-l) assert(0);\n    T ret = 0;\n    rep(d, D) {\n      int lc = dat[d].Count(1, l);\n      int rc = dat[d].Count(1, r);\n      if (rc - lc > k) {\n        l = lc + sep[d];\n        r = rc + sep[d];\n        ret |= T(1) << (D-d-1);\n      } else {\n        k -= rc-lc;\n        l -= lc;\n        r -= rc;\n      }\n    }\n    return ret;\n  }\n\n  int FreqDfs(int d, int l, int r, T val, T a, T b) {\n    if (r <= l) return 0;\n    if (d == D) {\n      if (a <= val && val < b) return r-l;\n      return 0;\n    }\n\n    T h = T(1) << (D-d-1);\n    T nv = val | h; \n    T lim = nv | (h-1);\n    if (lim < a || b <= val) return 0;\n    if (a <= val && lim < b) return r-l;\n\n    int lc = dat[d].Count(1, l);\n    int rc = dat[d].Count(1, r);\n    int lval = FreqDfs(d+1, l-lc, r-rc, val, a, b);\n    int rval = FreqDfs(d+1, lc+sep[d], rc+sep[d], nv, a, b);\n    return lval + rval;\n  }\n\n  int Freq(int l, int r, T a, T b) {\n    return FreqDfs(0, l, r, 0, a, b);\n  }\n\n  T operator[](int k) {\n    return arr[k];\n  }\n};\n\nconst int GETA = 1e9;\nint N;\nint M;\nunsigned int ys[114514];\nvector<PII> ps;\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  rep(i, N) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    y += GETA;\n    ps.emplace_back(PII(x, y));\n  }\n  sort(all(ps));\n \n  rep(i, N) ys[i] = ps[i].second;\n  Wavelet<5000> wave(N, ys);\n\n  rep(i, M) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    b += GETA;\n    d += GETA;\n    int x = lower_bound(all(ps), PII(a, 0)) - ps.begin();\n    int y = upper_bound(all(ps), PII(c, GETA*2)) - ps.begin();\n    printf(\"%d\\n\", wave.Freq(x, y, b, d+1));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define X first\n#define Y second\n\nusing namespace std;\n\nint n, m;\nvector<int> vx, vy;\nint tx[5005], ty[5005], unzipx[5005], unzipy[5005], imos[5005][5005];\nmap<int, int> zipx, zipy;\npair< pair<int,int>, pair<int,int> > p[500005];\n\nint main() {\n  cin>>n>>m;\n  REP(i,0,n){\n    cin>>tx[i]>>ty[i];\n    vx.push_back(tx[i]);\n    vy.push_back(ty[i]);\n  }\n  REP(i,0,m){\n    cin>>p[i].F.X>>p[i].F.Y>>p[i].S.X>>p[i].S.Y;\n  }\n\n  //compression\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  vx.erase(vx.begin()/*unique(vx.begin(), vx.end())*/, vx.end());\n  vy.erase(vy.begin()/*unique(vy.begin(), vy.end())*/, vy.end());\n  REP(i,0,vx.size()){\n    zipx[vx[i]] = i;\n    unzipx[i] = vx[i];\n  }\n  REP(i,0,vy.size()){\n    zipy[vy[i]] = i;\n    unzipy[i] = vy[i];\n  }\n\n  //Initializing imos array\n  REP(i,0,5005)REP(j,0,5005) imos[i][j] = 0;\n  REP(i,0,n){\n    imos[zipy[ty[i]]][zipx[tx[i]]]++;\n  }\n  //creating imos array\n  REP(i,0,vy.size()){\n    REP(j,1,vx.size()){\n      imos[i][j] += imos[i][j-1];\n    }\n  }\n  REP(j,0,vx.size()){\n    REP(i,1,vy.size()){\n      imos[i][j] += imos[i-1][j];\n    }\n  }\n\n  REP(i,0,m){\n    /*\n    cout<<\"xSize:\"<<vx.size()<<\", \"<<\"ySize:\"<<vx.size()<<endl;\n    cout<<\"test: \"<<(lower_bound(vx.begin(),vx.end(),p[i].F.X)-vx.begin())<<\" \";\n    cout<<(lower_bound(vy.begin(),vy.end(),p[i].F.Y)-vy.begin())<<\" \";\n    cout<<(lower_bound(vx.begin(),vx.end(),p[i].S.X)-vx.begin())<<\" \";\n    cout<<(lower_bound(vy.begin(),vy.end(),p[i].S.Y)-vy.begin())<<endl;\n    */\n    vector<int>::iterator a1x = lower_bound(vx.begin(),vx.end(),p[i].F.X),\n      a1y = lower_bound(vy.begin(),vy.end(),p[i].F.Y),\n      a2x = upper_bound(vx.begin(),vx.end(),p[i].S.X)-1,\n      a2y = upper_bound(vy.begin(),vy.end(),p[i].S.Y)-1;\n    int z1x = zipx[*a1x], z1y = zipy[*a1y], z2x = zipx[*a2x], z2y = zipy[*a2y];\n    int ans = imos[z2y][z2x];\n    if(z1y > 0) ans -= imos[z1y-1][z2x];\n    if(z1x > 0) ans -= imos[z2y][z1x-1];\n    if(z1y > 0 && z1x > 0) ans += imos[z1y-1][z1x-1];\n\n    if(p[i].F.Y > unzipy[vy.size()-1] || p[i].F.X > unzipx[vx.size()-1]) cout<<0<<endl;\n    else if(p[i].S.Y < unzipy[0] || p[i].S.X < unzipx[0]) cout<<0<<endl;\n    else cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> xy_t;\n\nint main() {\n\n\tint N, M, x1, y1, x2, y2;\n\txy_t T[5000], A1[500000], A2[500000];\n\t\n\tcin >> N >> M;\n\t\n\tfor ( int i = 0; i < N; i++ ) {\n\t\n\t\tcin >> x1 >> y1;\n\n\t\tT[i] = xy_t( x1, y1 );\n\t\n\t}\n\t\n\tfor ( int i = 0; i < M; i++ ) {\n\t\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\tA1[i] = xy_t( x1, y1 );\n\t\tA2[i] = xy_t( x2, y2 );\n\t\n\t}\n\t\n\tfor ( int i = 0; i < M; i++ ) {\n\t\n\t\tint count = 0;\n\t\n\t\tfor ( int j = 0; j < N; j++ ) {\n\t\t\n\t\t\t// if ( A1[i].real() <= T[j].real() && T[j].real() <= A2[i].real() && A1[i].imag() <= T[j].imag() && T[j].imag() <= A2[i].imag() ) { count++; }\n\t\t\t\n\t\t\tif ( A1[i].real() <= T[j].real() ) {\n\t\t\t\n\t\t\t\tif ( T[j].real() <= A2[i].real() ) {\n\t\t\t\n\t\t\t\t\tif ( A1[i].imag() <= T[j].imag() ) {\n\t\t\t\n\t\t\t\t\t\tif ( T[j].imag() <= A2[i].imag() ) { count++; }\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << count << endl;\n\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\n\nconst int MAX_N = 1 << 15;\nstruct Wavelet{\n\tvoid init(vector<ll> A){\n\t\tN = 1;\n\t\twhile(N < A.size()) N *= 2;\n\t\twhile(A.size() != N) A.push_back(1LL << 50);\n\t\tsorted = A;\n\t\tsort(sorted.begin(), sorted.end());\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tb[0][i] = A[i];\n\t\t}\n\t\tfor(int len = N, d = 0; len >= 1; len /= 2, d++){\n\t\t\tint g = 0;\n\t\t\tfor(int l = 0; l < N; l += len){\n\t\t\t\tcalc(l, l + len, d);\n\t\t\t\tfor(int i = l; i < l + len; i++){\n\t\t\t\t\tgroup[d][i] = g;\n\t\t\t\t\tif(i != l) Left[d][i] += Left[d][i - 1];\n\t\t\t\t}\n\t\t\t\tg++;\n\t\t\t}\n\t\t}\n\t}\n\t// [l,r)????????????????????¨??????k??????(1-indexed)??????\n\tll  kth_element(int l, int r, int k){\n\t\treturn kth_element(l, r, k, 0, N, 0);\n\t}\n\t/*\n\t[l,r)????????????????????¨???x????????????(1-index)?????\\??????.\n\tx???2?????\\???????????¨??????,??????????????????rank?????????.\n\tx???????????¨??????x????????§?????§????????????rank?????????.\n\tx?????????????????¨??????0?????????.\n\t*/\n\tint pos(int l, int r, ll x){\n\t\treturn pos(l, r, x, 0, N, 0);\n\t}\n\t// [l,r)???x?????°\n\tint freq(int l, int r, ll x){\n\t\treturn pos(l, r, x) - pos(l, r, x - 1);\n\t}\n\t// [l,r)???lx??\\???rx??\\????????°(?)\n\tint freq2(int l, int r, ll lx, ll rx){\n\t\treturn pos(l, r, rx) - pos(l, r, lx - 1);\n\t}\nprivate:\n\tint N;\n\tvector<ll> sorted;\n\tll b[25][MAX_N];\n\tint Left[25][MAX_N];\n\tint group[25][MAX_N];\n\n\tint getLeftNum(int l, int r, int d){\n\t\tif(r <= l) return 0;\n\t\tint ret = Left[d][r - 1];\n\t\tif(l && group[d][l - 1] == group[d][r - 1]) ret -= Left[d][l - 1];\n\t\treturn ret;\n\t}\n\n\tvoid calc(int l, int r, int d){\n\t\tint c = (l + r) / 2, len = r - l;\n\t\tvector<ll> v(b[d] + l, b[d] + r);\n\t\tsort(v.begin(), v.end());\n\t\tmap<ll, int> lcnt;\n\t\tfor(int i = 0; i < len / 2; i++){\n\t\t\tlcnt[v[i]]++;\n\t\t}\n\t\tint L = l, R = c;\n\t\tfor(int i = l; i < r; i++){\n\t\t\tll val = b[d][i];\n\t\t\tif(lcnt.count(val) && lcnt[val]){\n\t\t\t\tlcnt[val]--;\n\t\t\t\tb[d + 1][L] = val;\n\t\t\t\tL++;\n\t\t\t\tLeft[d][i] = 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tb[d + 1][R] = val;\n\t\t\t\tR++;\n\t\t\t\tLeft[d + 1][i] = 0;\n\t\t\t}\n\t\t}\n\t}\n\t// ??±??????d??§[L,R)?????¨?????????????????¨??????[l,r)???k??????(1-indexed)??????\n\tll kth_element(int l, int r, int k, int L, int R, int d){\n\t\tif(R - L == 1) return b[d][L];\n\t\tint len = r - l, mid = (L + R) / 2;\n\t\t// [l,r)????????§???????????????????????°\n\t\tint leftNum = getLeftNum(l, r, d), rightNum = len - leftNum;\n\t\t// ???????????????????????°???k??\\????????????????????°???????????§???????????????????????°\n\t\tif(k <= leftNum){\n\t\t\tint newl = max(L, L + getLeftNum(L, l, d));\n\t\t\tint newr = min(mid, newl + leftNum);\n\t\t\treturn kth_element(newl, newr, k, L, mid, d + 1);\n\t\t}\n\t\telse{\n\t\t\tint newl = max(mid, mid + (l - L - getLeftNum(L, l, d)));\n\t\t\tint newr = min(R, newl + rightNum);\n\t\t\treturn kth_element(newl, newr, k - leftNum, mid, R, d + 1);\n\t\t}\n\t}\n\tint pos(int l, int r, ll x, int L, int R, int d){\n\t\tif(R - L == 1){\n\t\t\treturn l + 1 == r && sorted[l] <= x;\n\t\t}\n\t\tint mid = (L + R) / 2, len = r - l;\n\t\tint leftNum = getLeftNum(l, r, d), rightNum = len - leftNum;\n\t\tif(x < sorted[mid]){\n\t\t\tint newl = max(L, L + getLeftNum(L, l, d));\n\t\t\tint newr = min(mid, newl + leftNum);\n\t\t\treturn pos(newl, newr, x, L, mid, d + 1);\n\t\t}\n\t\telse{\n\t\t\tint newl = max(mid, mid + (l - L - getLeftNum(L, l, d)));\n\t\t\tint newr = min(R, newl + rightNum);\n\t\t\treturn leftNum + pos(newl, newr, x, mid, R, d + 1);\n\t\t}\n\t}\n} W;\n\ntemplate <class T>\npair<vector<T>, map<T, int>> compress(T* a, int n){\n\tvector<T> v;\n\tfor(int i = 0; i < n; i++) v.push_back(a[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tmap<T, int> m;\n\tfor(int i = 0; i < v.size(); i++) m[v[i]] = i;\n\tfor(int i = 0; i < n; i++) a[i] = m[a[i]];\n\treturn { v, m };\n}\n\nstruct P{\n\tll x, y;\n\tbool operator < (const P& p) const{\n\t\treturn x < p.x;\n\t}\n};\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n#ifdef LOCAL\n\tstd::ifstream in(\"in\");\n\tstd::cin.rdbuf(in.rdbuf());\n#endif\n\n\tint N, M;\n\tcin >> N >> M;\n\n\tvector<ll> X(N), Y(N);\n\tvector<ll> X1(M), Y1(M), X2(M), Y2(M);\n\tvector<ll> xs;\n\tfor(int i = 0; i < N; i++){\n\t\tcin >> X[i] >> Y[i];\n\t\txs.push_back(X[i]);\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tcin >> X1[i] >> Y1[i] >> X2[i] >> Y2[i];\n\t\txs.push_back(X1[i]);\n\t\txs.push_back(X2[i]);\n\t}\n\tauto xcomp = compress(xs.data(), xs.size());\n\tvector<P> ps(N);\n\tvector<ll> xx, yy;\n\tfor(int i = 0; i < N; i++){\n\t\tX[i] = xcomp.second[X[i]];\n\t\tps[i] = { X[i], Y[i] };\n\t}\n\tsort(ps.begin(), ps.end());\n\tfor(int i = 0; i < N; i++){\n\t\txx.push_back(ps[i].x);\n\t\tyy.push_back(ps[i].y);\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tX1[i] = xcomp.second[X1[i]];\n\t\tX2[i] = xcomp.second[X2[i]];\n\t}\n\n\tW.init(yy);\n\tfor(int i = 0; i <= 4; i++){\n\t\t//cout << W.pos(0, 3, i) << endl;\n\t}\n\tfor(int i = 0; i < M; i++){\n\t\tint l = lower_bound(xx.begin(), xx.end(), X1[i]) - xx.begin();\n\t\tint r = upper_bound(xx.begin(), xx.end(), X2[i]) - xx.begin();\n\n\t\tcout << W.freq2(l, r, Y1[i], Y2[i]) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n//1/24 ???????????????\n\n#include<iostream>\n#include<fstream>\n\n#include<vector>\n\n#define fin cin\n\nusing namespace std;\n\nclass Coordinate{\n\npublic:\n    int x;\n    int y;\n    Coordinate():\n    x(0), y(0){\n\n    }\n    Coordinate(int _x, int _y):\n    x(_x), y(_y){\n\n    }\n\n    bool inside(Coordinate l_u, Coordinate r_d) const{\n        return l_u.x <= this->x && \n               this->x <= r_d.x &&\n               this->y >= l_u.y &&\n               r_d.y >= this->y;\n    }\n\n};\n\nint main(){\n    //ifstream fin(\"in.txt\");\n\n    int n, m;\n    fin >> n >> m;\n\n    vector<Coordinate> spot;\n    \n    //????????´??????input\n    for(int i = 0; i < n; i++){\n        spot.push_back(Coordinate());\n        fin >> spot[i].x;\n        fin >> spot[i].y;\n    }\n\n    //?????????input\n    Coordinate *l_u = new Coordinate[m];//left-up\n    Coordinate *r_d = new Coordinate[m];//right-down\n    for(int i = 0; i < m; i++){\n\n        int tmp_x, tmp_y;\n        fin >> tmp_x >> tmp_y;\n\n        l_u[i] = Coordinate(tmp_x, tmp_y);\n\n        fin >> tmp_x >> tmp_y;\n\n        r_d[i] = Coordinate(tmp_x, tmp_y);\n\n    }\n\n    for(int i = 0; i < m; i++){\n        int ans = 0;\n        for(int j = 0; j < n; j++){\n            if(spot[j].inside(l_u[i], r_d[i]))ans++;\n        }\n        cout << ans << endl;\n    }\n\n    \n\n\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9 + 2;\n\n\nvector<vector<short>> d;\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> ix(n), iy(n);\n\n\t//??§?¨???§?????¨????????????\n\tvector<int> ax, ay;\n\tmap<int, int> mx, my;\n\n\n\trep(i, n){\n\t\tcin >> ix[i] >> iy[i];\n\t\trep(j, 2){\n\t\t\tax.push_back(ix[i] + j - 1);\n\t\t\tay.push_back(iy[i] + j - 1);\n\t\t}\n\t}\n\tax.push_back(-INF - 1);\n\tay.push_back(-INF - 1);\n\tax.push_back( INF + 1);\n\tay.push_back( INF + 1);\n\n\tsort(all(ax));\n\tsort(all(ay));\n\n\trep(i, ax.size()){\n\t\tmx[ax[i]] = i;\n\t}\n\trep(i, ay.size()){\n\t\tmy[ay[i]] = i;\n\t}\n\n\t//d[x][y] 0 - x  0 - y ??????????????????????±?????????????\n\td.resize(ax.size() + 1, vector<short>(ay.size() + 1, 0));\n\trep(i, n){\n\t\td[mx[ix[i]]][my[iy[i]]]++;\n\t}\n\tFor(x, 1, ax.size() + 1)For(y, 1, ay.size() + 1){\n\t\td[x][y] = d[x - 1][y] + d[x][y - 1] - d[x - 1][y - 1] + d[x][y];\n\t}\n\n\trep(i, m){\n\t\tint qx1, qy1, qx2, qy2;\n\t\tcin >> qx1 >> qy1 >> qx2 >> qy2;\n\t\tint rx, ry, lx, ly;\n\t\tqx1--; qy1--;\n\t\tif (mx.count(qx1)){\n\t\t\tlx = mx[qx1];\n\t\t}\n\t\telse{\n\t\t\tmx[qx1] = -1;\n\t\t\tauto p = mx.find(qx1);\n\t\t\tlx = prev(p)->second;\n\t\t\tmx.erase(qx1);\n\t\t}\n\t\tif (my.count(qy1)){\n\t\t\tly = my[qy1];\n\t\t}\n\t\telse{\n\t\t\tmy[qy1] = -1;\n\t\t\tauto p = my.find(qy1);\n\t\t\tly = prev(p)->second;\n\t\t\tmy.erase(qy1);\n\t\t}\n\n\t\tif (mx.count(qx2)){\n\t\t\trx = mx[qx2];\n\t\t}\n\t\telse{\n\t\t\tmx[qx2] = -1;\n\t\t\tauto p = mx.find(qx2);\n\t\t\trx = next(p)->second;\n\t\t\tmx.erase(qx2);\n\t\t}\n\n\t\tif (my.count(qy2)){\n\t\t\try = my[qy2];\n\t\t}\n\t\telse{\n\t\t\tmy[qy2] = -1;\n\t\t\tauto p = my.find(qy2);\n\t\t\try = next(p)->second;\n\t\t\tmy.erase(qy2);\n\t\t}\n\n\t\tcout << d[rx][ry] + d[lx][ly] - d[lx][ry] - d[rx][ly] << endl;\n\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<string> vs;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<int,P> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<60;\nconst double pi=acos(-1);\nconst double eps=1e-11;\nconst ll mod=1e9+7;\nconst int dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\n\n\n\nint main(){\n\tios::sync_with_stdio(0);\n\tcin.tie(0);\n\tint n,m;\n\tcin>>n>>m;\n\tvi x(n),y(n);\n\tvi c(n),d(n);\n\tfor(int i=0;i<n;i++){\n\t\tcin>>x[i]>>y[i];\n\t\tc[i]=x[i],d[i]=y[i];\n\t}\n\tsort(c.begin(),c.end());\n\tc.erase(unique(c.begin(),c.end()),c.end());\n\tsort(d.begin(),d.end());\n\td.erase(unique(d.begin(),d.end()),d.end());\n\tmap<int,int> mp1,mp2;\n\tfor(int i=0;i<c.size();i++) mp1[c[i]]=i;\n\tfor(int i=0;i<d.size();i++) mp2[d[i]]=i;\n\tint h=c.size(),w=d.size();\n\tvvi a(h+1,vi(w+1));\n\tfor(int i=0;i<n;i++) a[mp1[x[i]]+1][mp2[y[i]]+1]++;\n\tfor(int i=1;i<=h;i++) for(int j=1;j<=w;j++){\n\t\ta[i][j]+=a[i-1][j]+a[i][j-1]-a[i-1][j-1];\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint l,r,L,R;\n\t\tcin>>l>>r>>L>>R;\n\t\tl=lower_bound(c.begin(),c.end(),l)-c.begin();\n\t\tr=lower_bound(d.begin(),d.end(),r)-d.begin();\n\t\tL=upper_bound(c.begin(),c.end(),L)-c.begin();\n\t\tR=upper_bound(d.begin(),d.end(),R)-d.begin();\n\t\tcout<<a[L][R]-a[L][r]-a[l][R]+a[l][r]<<endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\n\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    cin >> n >> m;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = lower_bound(all(compressed_x), x2) - begin(compressed_x);\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = lower_bound(all(compressed_y), y2) - begin(compressed_y);\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[5000], Y[5000];\nint X1[5000], X2[5000], Y1[5000], Y2[5000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn v.size();\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\t\n\tset<int> posx;\n\t\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tv[i] = pii(x,y);\n\t\tposx.insert(x);\n\t}\n\t\n\tmap<int,int> zip,unzip;\n\t\n\tint c=0;\n\tfor(auto &e:posx){\n\t\tzip[e] = c;\n\t\tunzip[c] = e;\n\t\tc++;\n\t}\n\t\n\tvector<vector<int>> r(posx.size());\n\t\n\trep(i,v.size()){\n\t\tr[zip[v[i].first]].pb(v[i].second);\n\t}\n\t\n\trep(i,r.size()-1){\n\t\trep(j,r[i].size()){\n\t\t\tr[i+1].pb(r[i][j]);\n\t\t}\n\t}\n\trep(i,r.size())sort(all(r[i]));\n\t\n\t\n\trep(i,m){\n\t\tint x1,y1,x2,y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\t\n\t\tauto left = posx.lower_bound(x1);\n\t\tauto right = posx.upper_bound(x2);\n\t\t\n\t\tint sub=0,add=0;\n\t\t\n\t\tif(left==posx.begin())sub=0;\n\t\telse{\n\t\t\tleft--;\n\t\t\tvector<int> &t = r[zip[*left]];\n\t\t\t\n\t\t\tsub = lower_bound(all(t),y1) - upper_bound(all(t),y2);\n\t\t}\n\t\t\n\t\tif(right==posx.begin())add=0;\n\t\telse{\n\t\t\tright--;\n\t\t\tvector<int> &t = r[zip[*right]];\n\t\t\tadd = lower_bound(all(t),y1) - upper_bound(all(t),y2);\n\t\t}\n\t\tcout<<sub-add<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<long long> X;\n    vector<long long> Y;\n    vector<long long> x(n);\n    vector<long long> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        long long x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    long long h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    \n\n    //cout << h << \" \" << w << endl;\n    vector<vector<long long> > imos(h + 1, vector<long long> (w + 1, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i]][x[i]]++;\n    }\n\n    \n\n    for(int j = 0; j <= w; j++){\n        for(int i = 1; i <= h; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    \n    for(int i = 0; i < m; i++){\n        long long x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(x.begin(),x.end(),x1) - x.begin();\n        x2 = upper_bound(x.begin(),x.end(),x2) - x.begin() - 1;\n\n        y1 = lower_bound(y.begin(),y.end(),y1) - y.begin();\n        y2 = upper_bound(y.begin(),y.end(),y2) - y.begin() - 1;\n        \n        //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        long long sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    VI xs(x), ys(y);\n    sort(xs.begin(),xs.end());\n    sort(ys.begin(),ys.end());\n    xs.erase(unique(xs.begin(),xs.end()), xs.end());\n    ys.erase(unique(ys.begin(),ys.end()), ys.end());\n    REP(i,n){\n        x[i] = find(xs.begin(),xs.end(),x[i]) - xs.begin();\n        y[i] = find(ys.begin(),ys.end(),y[i]) - ys.begin();\n    }\n    REP(i,n) cout << x[i] << \" \" << y[i] << endl;\n    int w = xs.size(), h = ys.size();\n    VVI s(w+1, VI(h+1));\n    REP(i,n) s[x[i]+1][y[i]+1]++;\n    REP(i,w) REP(j,h+1) s[i+1][j] += s[i][j];\n    REP(j,h) REP(i,w+1) s[i][j+1] += s[i][j];\n\n    while (m--){\n        int x1, x2, y1, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        x1 = lower_bound(xs.begin(),xs.end(),x1) - xs.begin();\n        x2 = upper_bound(xs.begin(),xs.end(),x2) - xs.begin() - 1;\n        y1 = lower_bound(ys.begin(),ys.end(),y1) - ys.begin();\n        y2 = upper_bound(ys.begin(),ys.end(),y2) - ys.begin() - 1;\n        x2 = max(x2, 0);\n        y2 = max(y2, 0);\n        int ans = s[x2+1][y2+1] - s[x1][y2+1] - s[x2+1][y1] + s[x1][y1];\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define MAX_BIT 32\n\nstruct BitRank {\n    // block:bit列を管理, count:blockごとに立っている1の数を管理\n    vector<uint> block;\n    vector<int> count;\n    BitRank(){}\n    void resize(int num) {\n        block.resize((num+MAX_BIT-1)/MAX_BIT, 0);\n        count.resize((int)block.size(), 0);\n    }\n    // 立っているbitの数を返す\n    inline int popcount(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        return (((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n    // iビット目をval(0,1)にセット\n    inline void set(int i, int val) {\n        block[i/MAX_BIT] |= (val << (i%MAX_BIT));\n    }\n    void build() {\n        for(int i = 1; i < (int)block.size(); i++){\n            count[i] = count[i-1] + popcount(block[i-1]);\n        }\n    }\n    // iビット以下の1の数\n    int rank1(int i) {\n        return (i < 0)?0:(count[i/MAX_BIT]+popcount(block[i/MAX_BIT]<<(MAX_BIT-i%MAX_BIT-1)));\n    }\n    // jビット目からiビット目までの1の数\n    int rank1(int i,int j) {\n        return rank1(j) - rank1(i-1);\n    }\n    // iビット以下の0の数\n    int rank0(int i) {\n        return (i<0)?0:(i-rank1(i)+1);\n    }\n    // jビット目からiビット目までの0の数\n    int rank0(int i, int j) {\n        return rank0(j) - rank0(i-1);\n    }\n};\n\nclass WaveletMatrix\n{\nprivate:\n    uint height;\n    vector<BitRank> B;\n    vector<int> pos;\npublic:\n    WaveletMatrix(){}\n    WaveletMatrix(vector<int>& vec) :\n        WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}\n    // sigma:文字の種類数\n    WaveletMatrix(vector<int>& vec, int sigma){\n        init(vec, sigma);\n    }\n    void init(vector<int>& vec, int sigma){\n        height = MAX_BIT - __builtin_clz(sigma-1);\n        B.resize(height), pos.resize(height);\n        for(uint i = 0; i < height; i++){\n            B[i].resize((int)vec.size());\n            for(int j = 0; j < (int)vec.size(); j++) {\n                B[i].set(j, access(vec[j], height - i - 1));\n            }\n            B[i].build();\n            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {\n                return !access(c, height - i - 1);\n            });\n            pos[i] = it - vec.begin();\n        }\n    }\n    // valのiビット目の値を返す(0,1)\n    inline int access(int val, int i) {\n        return (val >> i) & 1;\n    }\n    // [l,r]の間に現れる値cの数\n    int rank(int val,int l,int r) {\n        return rank(val, r) - rank(val, l - 1);\n    }\n    int rank(int val, int i) {\n        int p = -1;\n        for(uint j = 0; j < height; j++){\n            if(access(val, height - j - 1)){\n                p = pos[j] + B[j].rank1(p) - 1;\n                i = pos[j] + B[j].rank1(i) - 1;\n            }else{\n                p = B[j].rank0(p) - 1;\n                i = B[j].rank0(i) - 1;\n            }\n        }\n        return i - p;\n    }\n    // [l,r]のk(1,2,3...)番目に小さい値を返す\n    int quantile(int k, int l, int r) {\n        int res = 0;\n        for(uint i = 0; i < height; i++){\n            int j = B[i].rank0(l, r);\n            if(j >= k){\n                l = B[i].rank0(l-1);\n                r = B[i].rank0(r) - 1;\n            }else{\n                l = pos[i] + B[i].rank1(l-1);\n                r = pos[i] + B[i].rank1(r) - 1;\n                k -= j;\n                res |= (1 << (height - i - 1));\n            }\n        }\n        return res;\n    }\n    // [l,r]で値が[a,b]内に含まれる数を返す\n    int rangefreq(int l, int r, int a, int b) {\n        return rangefreq(l, r, a, b, 0, (1 << height) - 1, 0);\n    }\n    int rangefreq(int i, int j, int a, int b, int l, int r, int x) {\n        if(b < l || r < a) return 0;\n        int mid = l + (r - l) / 2;\n        if(a <= l && r <= b){\n            return j - i + 1;\n        }else{\n            int left = rangefreq(B[x].rank0(i-1),B[x].rank0(j)-1,a,b,l,mid,x+1);\n            int right = rangefreq(pos[x]+B[x].rank1(i-1),pos[x]+B[x].rank1(j)-1,a,b,mid+1,r,x+1);\n            return left + right;\n        }\n    }\n};\n\ntemplate<typename T> class OrthogonalRegionCount\n{\nprivate:\n    using ptt = pair<T, T>;\n    vector<T> X, Y;\n    WaveletMatrix wm;\n    int n;\npublic:\n    OrthogonalRegionCount(vector<ptt> candidate) {\n        int n = (int)candidate.size();\n        sort(candidate.begin(), candidate.end());\n        X.resize(n), Y.resize(n);\n        vector<T> vec(n);\n        rep(i,n){\n            X[i] = candidate[i].first, Y[i] = candidate[i].second;\n        }\n        sort(Y.begin(), Y.end());\n        Y.erase(unique(Y.begin(), Y.end()), Y.end());\n        rep(i,n){\n            vec[i] = lower_bound(Y.begin(), Y.end(), candidate[i].second) - Y.begin();\n        }\n        wm.init(vec, (int)Y.size());\n    }\n    //[lx,rx)×[ly,ry)の長方形領域に含まれる点の数を答える\n    int query(T lx, T ly, T rx, T ry) {\n        int lxid = lower_bound(X.begin(), X.end(), lx) - X.begin();\n        int rxid = upper_bound(X.begin(), X.end(), rx-1) - X.begin();\n        int lyid = lower_bound(Y.begin(), Y.end(), ly) - Y.begin();\n        int ryid = upper_bound(Y.begin(), Y.end(), ry-1) - Y.begin();\n        if(lxid >= rxid || lyid >= ryid) return 0;\n        // cout << lxid << \" \" << lyid << \" \" << rxid << \" \" << ryid << \"\\n\";\n        return wm.rangefreq(lxid, rxid-1, lyid, ryid-1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vp vec(n);\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        vec[i] = P(a,b);\n    }\n    OrthogonalRegionCount<int> tdc(vec);\n    rep(i,m){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        cout << tdc.query(a,b,c+1,d+1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n, m;\nint x[101010], y[101010];\nvector<int> xx, yy;\nint rui[5050][5050];\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t\txx.emplace_back(x[i]);\n\t\tyy.emplace_back(y[i]);\n\t}\n\txx.emplace_back(-HINF);\n\txx.emplace_back(HINF);\n\tyy.emplace_back(-HINF);\n\tyy.emplace_back(HINF);\n\n\tUNIQUE(xx);\n\tUNIQUE(yy);\n\n\tREP(i, n) {\n\t\tint xxx = lower_bound(ALL(xx), x[i]) - xx.begin();\n\t\tint yyy = lower_bound(ALL(yy), y[i]) - yy.begin();\n\t\trui[yyy][xxx]++;\n\t}\n\tREP(i, n+2) {\n\t\tREP(j, n+2) {\n\t\t\tif (i > 0 && j > 0) {\n\t\t\t\trui[i][j] += rui[i][j - 1] + rui[i - 1][j];\n\t\t\t\trui[i][j] -= rui[i - 1][j - 1];\n\t\t\t}\n\t\t\telse if (i > 0)rui[i][j] += rui[i - 1][j];\n\t\t\telse if (j > 0)rui[i][j] += rui[i][j - 1];\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tint x1, x2, y1, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = lower_bound(ALL(xx), x1) - xx.begin();\n\t\ty1 = lower_bound(ALL(yy), y1) - yy.begin();\n\t\tx2 = upper_bound(ALL(xx), x2) - xx.begin() - 1;\n\t\ty2 = upper_bound(ALL(yy), y2) - yy.begin() - 1;\n\t\tcout << rui[y2][x2] - rui[y1 - 1][x2] - rui[y2][x1 - 1] + rui[x1 - 1][y1 - 1] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing ll = long long int;\n\nconstexpr int MAX_N = 5000;\n\n\nint n, m;\nint w, h;\n\nll board[MAX_N][MAX_N];\n\nll X[MAX_N], Y[MAX_N];\nstd::vector<int> vx, vy;\n\nint compress(ll *x,std::vector<int>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\t++board[Y[i]][X[i]];\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tint sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\t\n\n\tll x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#define INF (1<<29)\n#define rep(i,n) for(int i=0;i<(n);i++)\nusing namespace std;\n\nvector<int> x,y;\nint num[5001][5001];\n\nint index(vector<int> &v,int x){\n\tint l,r;\n\tl=-1;r=v.size();\n\twhile(1<r-l){\n\t\tint m=(r+l)/2;\n\t\tif(v[m]<=x)l=m;\n\t\telse r=m;\n\t}\n\treturn l;\n}\nint main(){\n\tvector<pair<int,int> > treasure;\n\tint n,m;\n\tint a,b,c,d;\n\tcin>>n>>m;\n\n\t//x.push_back(-1000000000);\n\t//y.push_back(-1000000000);\n\trep(i,n){\n\t\tcin>>a>>b;\n\t\tx.push_back(a);\n\t\ty.push_back(b);\n\t\ttreasure.push_back(make_pair(a,b));\n\t}\n\tsort(x.begin(),x.end());\n\tx.erase(unique(x.begin(),x.end()), x.end());\n\tsort(y.begin(),y.end());\n\ty.erase(unique(y.begin(),y.end()), y.end());\n\trep(i,n){\n\t\ta = index(x,treasure[i].first);\n\t\tb = index(y,treasure[i].second);\n\t\t++num[a][b];\n\t}\n\trep(i,x.size()){\n\t\trep(j,y.size()){\n\t\t\ta=b=c=d=0;\n\t\t\tif(0<i&&0<j)a = num[i-1][j-1];\n\t\t\tif(0<i)b = num[i-1][j];\n\t\t\tif(0<j)c = num[i][j-1];\n\t\t\td = num[i][j];\n\t\t\tnum[i][j] = d+c+b-a;\n\t\t}\n\t}\n\n\trep(i,m){\n\t\tint x1,y1,x2,y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tx1 = index(x,x1-1);\n\t\ty1 = index(y,y1-1);\n\t\tx2 = index(x,x2);\n\t\ty2 = index(y,y2);\n\t\ta=b=c=d=0;\n\t\tif(x1!=-1&&y1!=-1)a = num[x1][y1];\n\t\tif(x1!=-1&&y2!=-1)b = num[x1][y2];\n\t\tif(x2!=-1&&y1!=-1)c = num[x2][y1];\n\t\tif(x2!=-1&&y2!=-1)d = num[x2][y2];\n\t\tcout<< d-c-b+a <<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntypedef pair<lint, lint> pll;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1000000007;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 100010;\n\nint sum[5010][5010];\n\nint main(){\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    vector<int> vx, vy;\n    int x[n], y[n];\n    rep(i, n){\n        scanf(\"%d%d\", &x[i], &y[i]);\n        vx.push_back(x[i]);\n        vy.push_back(y[i]);\n    }\n    sort(vx.begin(), vx.end());\n    vx.erase(unique(vx.begin(), vx.end()), vx.end());\n    sort(vy.begin(), vy.end());\n    vy.erase(unique(vy.begin(), vy.end()), vy.end());\n    rep(i, n){\n        int ix = lower_bound(vx.begin(), vx.end(), x[i]) - vx.begin();\n        int iy = lower_bound(vy.begin(), vy.end(), y[i]) - vy.begin();\n        ++sum[ix+1][iy+1];\n    }\n    rep(i, vx.size()+5)rep(j, vy.size()+5) sum[i][j+1] += sum[i][j];\n    rep(j, vy.size()+5)rep(i, vx.size()+5) sum[i+1][j] += sum[i][j];\n\n    rep(_, m){\n        int p, q, r, s;\n        scanf(\"%d%d%d%d\", &p, &q, &r, &s);\n        int l = lower_bound(vx.begin(), vx.end(), p) - vx.begin();\n        int u = lower_bound(vy.begin(), vy.end(), q) - vy.begin();\n        int rr = upper_bound(vx.begin(), vx.end(), r) - vx.begin();\n        int d = upper_bound(vy.begin(), vy.end(), s) - vy.begin();\n        printf(\"%d\\n\", sum[rr][d] - sum[rr][u] - sum[l][d] + sum[l][u]);\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #define int long long\nusing namespace std;\nusing pii=pair<int,int>;\n#define REPF(i,a,n) for(int i=(a);i<(int)(n);++i)\n#define REP(i,n) REPF(i,0,n)\n#define ALL(c) begin(c),end(c)\n\nint sum[5100][5100];\nsigned main() {\n    int n,m;\n    cin>>n>>m;\n    vector<int> x(n),y(n);\n    vector<pii> p(n);\n    REP(i,n) {\n        cin>>p[i].first>>p[i].second;\n        x[i]=p[i].first;\n        y[i]=p[i].second;\n    }\n    sort(ALL(x));\n    x.erase(unique(ALL(x)),end(x));\n    sort(ALL(y));\n    y.erase(unique(ALL(y)),end(y));\n\n    auto get_x=[&](int i) {\n        return distance(begin(x),lower_bound(ALL(x),i));\n    };\n    auto get_y=[&](int i) {\n        return distance(begin(y),lower_bound(ALL(y),i));\n    };\n\n    REP(i,n) {\n        int xx=get_x(p[i].first);\n        int yy=get_y(p[i].second);\n        sum[xx][yy]++;\n    }\n    REP(i,5100) REPF(j,1,5100) sum[i][j]+=sum[i][j-1];\n    REP(j,5100) REPF(i,1,5100) sum[i][j]+=sum[i-1][j];\n\n    REP(i,m) {\n        int x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        int xx1=get_x(x1);\n        int yy1=get_y(y1);\n        int xx2=get_x(x2);\n        int yy2=get_y(y2);\n        if(find(ALL(x),x2)==end(x)) xx2--;\n        if(find(ALL(y),y2)==end(y)) yy2--;\n\n        if(xx2<xx1 || yy2<yy2) {\n            cout<<0<<endl;\n            continue;\n        }\n\n        int ans=sum[xx2][yy2];\n        if(xx1>0) {\n            ans-=sum[xx1-1][yy2];\n        }\n        if(yy1>0) {\n            ans-=sum[xx2][yy1-1];\n        }\n        if(xx1>0 && yy1>0) {\n            ans+=sum[xx1-1][yy1-1];\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nint tr_2d[5000][5000];\nint s[5001][5001];\n\nmap<int,int> zip_x,zip_y;\nint unzip_x[5000],unzip_y[5000];\n\npair<int,int> compress(vector<int> &x, vector<int> &y){\n// zipで座標->index\n// unzipでindex->座標\n// x,yは書き換えられるので注意\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  rep(i,x.size()){\n    zip_x[x[i]] = i;\n    unzip_x[i] = x[i];\n  }\n  rep(i,y.size()){\n    zip_y[y[i]] = i;\n    unzip_y[i] = y[i];\n  }\n  return make_pair(x.size(),y.size());\n}\n\nvoid Imos2D(int n){\n  rep(i,n+1)rep(j,n+1)s[i+1][j+1]=tr_2d[i][j];\n  rep(i,n+1)rep(j,n)s[i][j+1]+=s[i][j];\n  rep(i,n)rep(j,n+1)s[i+1][j]+=s[i][j];\n}\n\nint sum(int xl,int xr,int yd,int yu){\n  return s[xr][yu]-s[xl][yu]+s[xl][yd]-s[xr][yd];\n}\n\nint main(){\n\n  int n,m;\n  cin>>n>>m;\n  vector<int> tr_x(n),tr_x2(n),tr_y(n),tr_y2(n);\n  rep(i,n){\n    rep(j,n){\n      tr_2d[i][j]=0;\n    }\n  }\n\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    tr_x[i] = x;\n    tr_x2[i] = x;\n    tr_y[i] = y;\n    tr_y2[i] = y;\n  }\n  //座圧\n  pair<int,int> size=compress(tr_x2,tr_y2);\n  // cout<<size.first<<size.second<<endl;\n  rep(i,n){\n    int id_x = zip_x[tr_x[i]];\n    int id_y = zip_y[tr_y[i]];\n    tr_2d[id_x][id_y]++;\n  }\n  // rep(i,n){\n  //   rep(j,n-1){\n  //     cout<<tr_2d[i][j]<<\" \";\n  //   }\n  //   cout<<tr_2d[i][n-1]<<endl;\n  // }\n\n  //2次元累積和\n  rep(i,n)rep(j,n)s[i][j]=0;\n  Imos2D(n);\n  // rep(i,n+1){\n  //   rep(j,n){\n  //     cout<<s[i][j]<<\" \";\n  //   }\n  //   cout<<s[i][n]<<endl;\n  // }\n\n  rep(i,m){\n    int xl,xr,yd,yu;\n    cin>>xl>>yd>>xr>>yu;\n    auto ixl = lower_bound(unzip_x,unzip_x+size.first,xl)-unzip_x;\n    auto ixr = upper_bound(unzip_x,unzip_x+size.first,xr)-unzip_x-1;\n    auto iyd = lower_bound(unzip_y,unzip_y+size.second,yd)-unzip_y;\n    auto iyu = upper_bound(unzip_y,unzip_y+size.second,yu)-unzip_y-1;\n    // cout << xl<<\" \"<<xr<<\" : \"<<ixl<< \" \" <<ixr<<endl;\n    // cout << yd<<\" \"<<yu<<\" : \"<<iyd<< \" \" <<iyu<<endl;\n    cout << sum(ixl,ixr+1,iyd,iyu+1)<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9+10;\n\nint dp[5001][5001];\nint exist[5001][5001];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  vector<PII> ps(N);\n  VI xs(N), ys(N);\n  REP(i,N){\n\tcin >> ps[i].first >> ps[i].second;\n\txs[i] = ps[i].first, ys[i] = ps[i].second;\n  }\n  xs.PB(-INF), xs.PB(INF);\n  ys.PB(-INF), ys.PB(INF);\n  SORT(xs); SORT(ys);\n\n  // x -> x', 0 <= x' < N+2\n  // y -> y'\n  map<int,int> compX, compY;\n  VI decompX(N+2), decompY(N+2);\n  int cnt = 0;\n  REP(i,N+2)\n\tif(!compX.count(xs[i])){\n\t  compX[xs[i]] = cnt++;\n\t  decompX[cnt-1] = xs[i];\n\t}\n  cnt = 0;\n  REP(i,N+2)\n\tif(!compY.count(ys[i])){\n\t  compY[ys[i]] = cnt++;\n\t  decompY[cnt-1] = ys[i];\n\t}\n\n  REP(i,N){\n\t++exist[compY[ps[i].second]][compX[ps[i].first]];\n  }\n  for(int y=0;y<N+2;++y)\n\tfor(int x=0;x<N+2;++x)\n\t  dp[y][x] = (y>0? dp[y-1][x]:0) + (x>0?dp[y][x-1]:0) - (y>0&&x>0? dp[y-1][x-1]:0) + exist[y][x];\n\n  while(M--){\n\tint sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n\tint sxi = compX.lower_bound(sx)->second;\n\tint syi = compY.lower_bound(sy)->second;\n\tauto it = compX.upper_bound(ex); --it;\n\tint exi = it->second;\n\tit = compY.upper_bound(ey); --it;\n\tint eyi = it->second;\n\n\tint ans = dp[eyi][exi] - (sxi>0?dp[eyi][sxi-1]:0) - (syi>0?dp[syi-1][exi]:0) + (syi>0&&sxi>0? dp[syi-1][sxi-1]:0);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(Pos pos[], int n, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tPos pos[5000];\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos temp = {x1, x2};\n\t\tpos[i] = temp;\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tcout << Count(pos, n, x1, y1, x2, y2);\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main()\n{\n  int N, M;\n  cin >> N >> M;\n  vector<int> xs, ys;\n  vector<pair<int,int> > v(N);\n  for (int i = 0; i < N; i++) {\n    cin >> v[i].first >> v[i].second;\n    xs.push_back(v[i].first);\n    ys.push_back(v[i].second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n  static const int MAXN = 5000;\n  static int grid[MAXN][MAXN];\n  for (vector<pair<int,int> >::const_iterator it = v.begin(); it != v.end(); ++it) {\n    const int xi = distance(xs.begin(), lower_bound(xs.begin(), xs.end(), it->first));\n    const int yi = distance(ys.begin(), lower_bound(ys.begin(), ys.end(), it->second));\n    ++grid[xi][yi];\n  }\n  static int sums[MAXN+1][MAXN+1];\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      sums[i+1][j+1] = sums[i][j+1] + sums[i+1][j] - sums[i][j] + grid[i][j];\n    }\n  }\n\n  for (int i = 0; i < M; i++) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    const int xi1 = distance(xs.begin(), lower_bound(xs.begin(), xs.end(), x1));\n    const int yi1 = distance(ys.begin(), lower_bound(ys.begin(), ys.end(), y1));\n    const int xi2 = distance(xs.begin(), lower_bound(xs.begin(), xs.end(), x2+1));\n    const int yi2 = distance(ys.begin(), lower_bound(ys.begin(), ys.end(), y2+1));\n    cout << sums[xi2][yi2] - sums[xi2][yi1] - sums[xi1][yi2] + sums[xi1][yi1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    \n    vector<int> A(n*n, 0);\n    vector<int> x(n);\n    vector<int> y(n);\n    vector<int> xb(m);\n    vector<int> yb(m);\n    vector<int> xe(m);\n    vector<int> ye(m);\n    vector<int> xs;\n    vector<int> ys;\n    \n    for(int j = 0; j < n; j++)\n        cin >> x[j] >> y[j];\n    \n    for(int i = 0; i < m; i++)\n        cin >> xb[i] >> yb[i] >> xe[i] >> ye[i];\n    \n    xs = x;\n    ys = y;\n    sort( xs.begin(), xs.end() );\n    sort( ys.begin(), ys.end() );\n    xs.erase( unique( xs.begin(), xs.end() ), xs.end() );\n    ys.erase( unique( ys.begin(), ys.end() ), ys.end() );\n    \n    for(int j = 0; j < n; j++){\n        x[j] = find( xs.begin(), xs.end(), x[j] ) - xs.begin();\n        y[j] = find( ys.begin(), ys.end(), y[j] ) - ys.begin();\n    }\n    \n    for(int i = 0; i < m; i++){\n        xb[i] = lower_bound( xs.begin(), xs.end(), xb[i] ) - xs.begin();\n        yb[i] = lower_bound( ys.begin(), ys.end(), yb[i] ) - ys.begin();\n        xe[i] = upper_bound( xs.begin(), xs.end(), xe[i] ) - xs.begin() - 1;\n        ye[i] = upper_bound( ys.begin(), ys.end(), ye[i] ) - ys.begin() - 1;\n    }\n    \n    \n    \n    for(int j = 0; j < n; j++){\n        for(int k = 0; k < n; k++){\n            A[ n*y[j] + x[k] ] += 1;\n        }\n    }\n    \n    for(int j = 0; j < n; j++){\n        for(int k = 1; k < n; k++){\n            A[n*j+k] += A[n*j+k-1];\n        }\n    }\n    for(int k = 0; k < n; k++){\n        for(int j = 1; j < n; j++){\n            A[n*j+k] += A[n*(j-1)+k];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        int a, b, c;\n        c = A[ n*(yb[i]-1) + (xb[i]-1) ];\n        if(xb[i] > 0)\n            a = A[ n*ye[i] + (xb[i]-1) ];\n        else{\n            c = a = 0;\n        if(yb[i] > 0)\n            b = A[ n*(yb[i]-1) + xe[i] ];\n        else\n            c = b = 0;\n        cout << A[ n*ye[i] + xe[i] ] - a - b + c <<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n\n#include<iostream>\n#include<fstream>\n#include<vector>\n#include<map>\n\n#define fin cin\n\nusing namespace std;\n\nint main(){\n    //ifstream fin(\"input.txt\");\n\n    //???????????§?¨????????????????\n    multimap<int, int> mp_x;\n\n    int n, m;\n    fin >> n >> m;\n\n    int x, y;\n    vector<int> vec_x,vec_y;\n\n    for(int i = 0; i < n; i++){\n        fin >> x >> y;\n\n        mp_x.insert(make_pair(x, i));\n        vec_y.push_back(y);\n    }\n\n\n    int ans = 0;\n    int x1, y1, x2, y2;\n    for(int i = 0; i < m; i++){\n        ans = 0;\n        fin >> x1 >> y1 >> x2 >> y2;\n        \n        for(multimap<int, int>::iterator itr = mp_x.lower_bound(x1); itr != mp_x.end(); itr++){\n            if(itr->first > x2)break;\n            int val = vec_y[itr->second];\n            if(y1 <= val && val <= y2)ans++;\n\n        }\n        cout << ans << endl;\n    }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\nvector<int> x,y;\nvector<int> ux,uy;\n\nshort data[5002][5002];\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tfor(int i = 0 ; i < n ; i++){\n\t\tint a,b;\n\t\tcin >> a >> b;\n\t\tx.push_back(a);\n\t\ty.push_back(b);\n\t}\n\tux = x;\n\tuy = y;\n\tux.push_back(INT_MAX);\n\tux.push_back(INT_MIN);\n\tuy.push_back(INT_MAX);\n\tuy.push_back(INT_MIN);\n\tsort(ux.begin(),ux.end());\n\tsort(uy.begin(),uy.end());\n\tux.erase(unique(ux.begin(),ux.end()),ux.end());\n\tuy.erase(unique(uy.begin(),uy.end()),uy.end());\n\tfor(int i = 0 ; i < x.size() ; i++){\n\t\tx[i] = lower_bound(ux.begin(),ux.end(),x[i]) - ux.begin();\n\t\ty[i] = lower_bound(uy.begin(),uy.end(),y[i]) - uy.begin();\n\t\tdata[y[i]][x[i]]++;\n\t}\n\tfor(int i = 0 ; i < 5002 ; i++)\n\t\tfor(int j = 1 ; j < 5002 ; j++)\n\t\t\tdata[i][j] += data[i][j-1];\n\tfor(int i = 1 ; i < 5002 ; i++)\n\t\tfor(int j = 0 ; j < 5002 ; j++)\n\t\t\tdata[i][j] += data[i-1][j];\n\tfor(int i = 0 ; i < m ; i++){\n\t\tint a,b,c,d; \n\t\tscanf(\"%d%d%d%d\",&a,&b,&c,&d);\n\t\ta = lower_bound(ux.begin(),ux.end(),a) - ux.begin();\n\t\tb = lower_bound(uy.begin(),uy.end(),b) - uy.begin();\n\t\tc = upper_bound(ux.begin(),ux.end(),c) - ux.begin() - 1;\n\t\td = upper_bound(uy.begin(),uy.end(),d) - uy.begin() - 1;\n\t\t//cout << a << \" \" << b << \" \" << c << \" \" << d << endl;\n\t\tint answer = data[d][c] - data[d][a-1] - data[b-1][c] + data[b-1][a-1];\n\t\tprintf(\"%d%c\",answer,10);\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define repr(i, n) for (int i = (n); i >= 0; --i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define FORR(i, m, n) for (int i = (m); i >= (n); --i)\n#define equals(a, b) (fabs((a) - (b)) < EPS)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nconst ll mod = 1000000007;\n//const ll mod = 998244353;\nconst int inf = 1e9 + 10;\nconst ll INF = 1e18;\nconst ld EPS = 1e-10;\nconst int dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nconst int dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntemplate<class T> bool chmax(T &a, const T &b) { if (a<b) { a=b; return 1; } return 0; }\ntemplate<class T> bool chmin(T &a, const T &b) { if (a>b) { a=b; return 1; } return 0; }\n\nvector<int> a[5050];\n\nint main() {\n  ios::sync_with_stdio(0);\n  cin.tie(0);\n  cout << fixed << setprecision(25);\n\n  int n, m;\n  cin >> n >> m;\n  vector<pair<int, int>> p(n);\n  rep(i, n) {\n    cin >> p[i].first >> p[i].second;\n  }\n\n  sort(p.begin(), p.end());\n  vector<int> res;\n  rep(i, n) {\n    res.push_back(p[i].second);\n    sort(res.begin(), res.end());\n    a[i] = res;\n  }\n\n  while (m--) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    int ans = 0;\n    int left = -1, right = n;\n    while (right - left > 1) {\n      int mid = (left + right) / 2;\n      if (p[mid].first <= x2) left = mid;\n      else right = mid;\n    }\n    if (left == -1) {\n      cout << ans << '\\n';\n      continue;\n    }\n    int left2 = -1, right2 = left + 1;\n    while (right2 - left2 > 1) {\n      int mid2 = (left2 + right2) / 2;\n      if (a[left][mid2] <= y2) left2 = mid2;\n      else right2 = mid2;\n    }\n    ans += left2 + 1;\n    left2 = -1, right2 = left + 1;\n    while (right2 - left2 > 1) {\n      int mid2 = (left2 + right2) / 2;\n      if (a[left][mid2] >= y1) right2 = mid2;\n      else left2 = mid2;\n    }\n    ans -= right2;\n    left = -1, right = n;\n    while (right - left > 1) {\n      int mid = (left + right) / 2;\n      if (p[mid].first >= x1) right = mid;\n      else left = mid;\n    }\n    if (left == -1) {\n      cout << ans << '\\n';\n      continue;\n    }\n    left2 = -1, right2 = left + 1;\n    while (right2 - left2 > 1) {\n      int mid2 = (left2 + right2) / 2;\n      if (a[left][mid2] <= y2) left2 = mid2;\n      else right2 = mid2;\n    }\n    ans -= left2 + 1;\n    left2 = -1, right2 = left + 1;\n    while (right2 - left2 > 1) {\n      int mid2 = (left2 + right2) / 2;\n      if (a[left][mid2] >= y1) right2 = mid2;\n      else left2 = mid2;\n    }\n    ans += right2;\n    cout << ans << '\\n';\n  }\n\n  \n\n\n\n\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cstdio>\n#define F first\n#define S second\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  vector<pair<int,int> > pii(n);\n  for(int i=0;i<n;i++)\n    cin>>pii[i].first>>pii[i].second;\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    int cnt=0;\n    for(int j=0;j<n;j++){\n      if(x1<=pii[j].first&&pii[j].first<=x2&&y1<=pii[j].second&&pii[j].second<=y2)\n\tcnt++;\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  set<int> X, Y;\n  vector<int> xs(N), ys(N);\n  rep(i, N) {\n    cin >> xs[i] >> ys[i];\n    X.insert(xs[i]); Y.insert(ys[i]);\n  }\n\n  vector<int> rx1(M), ry1(M), rx2(M), ry2(M);\n  rep(i, M) {\n    cin >> rx1[i] >> ry1[i] >> rx2[i] >> ry2[i];\n    X.insert(rx1[i]); Y.insert(ry1[i]);\n    X.insert(rx2[i]); Y.insert(ry2[i]);\n  }\n\n  map<int, int> MX, MY;\n  int W = 0; for(auto && e: X) MX[e] = W++;\n  int H = 0; for(auto && e: Y) MY[e] = H++;\n\n  static int sum[5001][5001];\n\n  rep(i, N) {\n    sum[MY[ys[i]]][MX[xs[i]]] ++;\n  }\n\n  rep(i, H) rep(j, W) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int x1 = MX[rx1[i]], x2 = MX[rx2[i]];\n    int y1 = MY[ry1[i]], y2 = MY[ry2[i]];\n    int r = sum[y2][x2];\n    if(x1 && y1) r += sum[y1-1][x1-1];\n    if(y1) r -= sum[y1-1][x2];\n    if(x1) r -= sum[y2][x1-1];\n    cout << r << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/**\n * \n */\n\n// {{{ header\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing i8   = int8_t;\nusing u8   = uint8_t;\nusing i16  = int16_t;\nusing u16  = uint16_t;\nusing i32  = int32_t;\nusing u32  = uint32_t;\nusing i64  = int64_t;\nusing u64  = uint64_t;\n#ifdef __SIZEOF_INT128__\nusing i128 = __int128;\nusing u128 = unsigned __int128;\n#endif\n\nusing f32  = float;\nusing f64  = double;\nusing f80  = __float80;\nusing f128 = __float128;\n// }}}\n\ntemplate<typename T> constexpr T PROCON_INF();\ntemplate<> constexpr i64 PROCON_INF<i64>() { return 1'010'000'000'000'000'000LL; }\ntemplate<> constexpr f64 PROCON_INF<f64>() { return 1e100; }\n\nconstexpr i64 INF  = PROCON_INF<i64>();\nconstexpr f64 FINF = PROCON_INF<f64>();\n\nconstexpr i64 MOD = 1'000'000'007LL;\n\nconstexpr f64 EPS = 1e-12;\n\nconstexpr f64 PI = 3.14159265358979323846;\n\n// {{{ util\n#define FOR(i, start, end) for(i64 i = (start), i##_end=(end); i < i##_end; ++i)\n#define REP(i, n) FOR(i, 0, n)\n\n#define ALL(f,c,...) (([&](decltype((c)) cccc) { return (f)(std::begin(cccc), std::end(cccc), ## __VA_ARGS__); })(c))\n#define SLICE(f,c,l,r,...) (([&](decltype((c)) cccc, decltype((l)) llll, decltype((r)) rrrr) {\\\n    auto iiii = llll <= rrrr ? std::begin(cccc)+llll : std::end(cccc);\\\n    auto jjjj = llll <= rrrr ? std::begin(cccc)+rrrr : std::end(cccc);\\\n    return (f)(iiii, jjjj, ## __VA_ARGS__);\\\n})(c,l,r))\n\n#define GENERIC(f) ([](auto&&... args) -> decltype(auto) { return (f)(std::forward<decltype(args)>(args)...); })\n\ntemplate<typename F>\nclass FixPoint {\npublic:\n    explicit constexpr FixPoint(F&& f) : f_(forward<F>(f)) {}\n\n    template<typename... Args>\n    constexpr decltype(auto) operator()(Args&&... args) const {\n        return f_(*this, forward<Args>(args)...);\n    }\n\nprivate:\n    const F f_;\n};\n\ntemplate<typename F>\ndecltype(auto) FIX(F&& f) {\n    return FixPoint<F>(forward<F>(f));\n}\n\ntemplate<typename C>\ni64 SIZE(const C& c) { return static_cast<i64>(c.size()); }\n\ntemplate<typename T, size_t N>\ni64 SIZE(const T (&)[N]) { return static_cast<i64>(N); }\n\nbool is_odd (i64 x) { return x % 2 != 0; }\nbool is_even(i64 x) { return x % 2 == 0; }\n\ntemplate<typename T> i64 cmp(T x, T y) { return (y<x) - (x<y); }\ntemplate<typename T> i64 sgn(T x) { return cmp(x, T(0)); }\n\ni64 ipow(i64 x, i64 e) {\n    assert(e >= 0);\n    i64 res = 1;\n    REP(_, e) {\n        res *= x;\n    }\n    return res;\n}\n\n// Haskell の divMod と同じ\npair<i64,i64> divmod(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r<0) || (b<0 && r>0)) {\n        --q;\n        r += b;\n    }\n    return {q,r};\n}\n\ni64 div_ceil(i64 a, i64 b) {\n    i64 q = a / b;\n    i64 r = a % b;\n    if((b>0 && r>0) || (b<0 && r<0))\n        ++q;\n    return q;\n}\n\ni64 div_floor(i64 a, i64 b) {\n    return divmod(a,b).first;\n}\n\ni64 modulo(i64 a, i64 b) {\n    return divmod(a,b).second;\n}\n\nbool feq(f64 x, f64 y, f64 eps=EPS) {\n    return fabs(x-y) < eps;\n}\n\ntemplate<typename T, typename U>\nbool chmax(T& xmax, const U& x) {\n    if(xmax < x) {\n        xmax = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename T, typename U>\nbool chmin(T& xmin, const U& x) {\n    if(x < xmin) {\n        xmin = x;\n        return true;\n    }\n    return false;\n}\n\ntemplate<typename InputIt>\nauto SUM(InputIt first, InputIt last) {\n    using T = typename iterator_traits<InputIt>::value_type;\n    return accumulate(first, last, T());\n}\n\ntemplate<typename ForwardIt, typename UnaryOperation>\nForwardIt transform_self(ForwardIt first, ForwardIt last, UnaryOperation op) {\n    return transform(first, last, first, op);\n}\n\ntemplate<typename C>\nvoid UNIQ(C& c) {\n    c.erase(ALL(unique,c), end(c));\n}\n\ntemplate<typename BinaryFunc, typename UnaryFunc>\nauto ON(BinaryFunc bf, UnaryFunc uf) {\n    return [bf,uf](const auto& x, const auto& y) {\n        return bf(uf(x), uf(y));\n    };\n}\n\ntemplate<typename F>\nauto LT_ON(F f) { return ON(less<>(), f); }\n\ntemplate<typename F>\nauto GT_ON(F f) { return ON(greater<>(), f); }\n\nchar digit_chr(i64 n) {\n    return static_cast<char>('0' + n);\n}\n\ni64 digit_ord(char c) {\n    return c - '0';\n}\n\nchar lower_chr(i64 n) {\n    return static_cast<char>('a' + n);\n}\n\ni64 lower_ord(char c) {\n    return c - 'a';\n}\n\nchar upper_chr(i64 n) {\n    return static_cast<char>('A' + n);\n}\n\ni64 upper_ord(char c) {\n    return c - 'A';\n}\n\n// 出力は operator<< を直接使わず、このテンプレート経由で行う\n// 提出用出力とデバッグ用出力を分けるため\ntemplate<typename T>\nstruct Formatter {\n    static ostream& write_str(ostream& out, const T& x)  { return out << x; }\n    static ostream& write_repr(ostream& out, const T& x) { return out << x; }\n};\n\ntemplate<typename T>\nostream& WRITE_STR(ostream& out, const T& x) {\n    return Formatter<T>::write_str(out, x);\n}\n\ntemplate<typename T>\nostream& WRITE_REPR(ostream& out, const T& x) {\n    return Formatter<T>::write_repr(out, x);\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_STR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_STR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_JOIN_REPR(ostream& out, InputIt first, InputIt last, const string& sep) {\n    while(first != last) {\n        WRITE_REPR(out, *first++);\n        if(first != last)\n            out << sep;\n    }\n    return out;\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_STR(ostream& out, InputIt first, InputIt last) {\n    return WRITE_JOIN_STR(out, first, last, \" \");\n}\n\ntemplate<typename InputIt>\nostream& WRITE_RANGE_REPR(ostream& out, InputIt first, InputIt last) {\n    out << \"[\";\n    WRITE_JOIN_REPR(out, first, last, \", \");\n    out << \"]\";\n    return out;\n}\n\ntemplate<typename T>\nvoid FROM_STR(const string& s, T& x) {\n    istringstream in(s);\n    in >> x;\n}\n\ntemplate<typename T>\nstring TO_STR(const T& x) {\n    ostringstream out;\n    WRITE_STR(out, x);\n    return out.str();\n}\n\ntemplate<typename T>\nstring TO_REPR(const T& x) {\n    ostringstream out;\n    WRITE_REPR(out, x);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_STR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_STR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring RANGE_TO_REPR(InputIt first, InputIt last) {\n    ostringstream out;\n    WRITE_RANGE_REPR(out, first, last);\n    return out.str();\n}\n\ntemplate<typename InputIt>\nstring JOIN(InputIt first, InputIt last, const string& sep) {\n    ostringstream out;\n    WRITE_JOIN_STR(out, first, last, sep);\n    return out.str();\n}\n\ntemplate<>\nstruct Formatter<i64> {\n    static ostream& write_str(ostream& out, i64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, i64 x) {\n        if(x == INF) return out << \"INF\";\n        return out << x;\n    }\n};\n\ntemplate<>\nstruct Formatter<f64> {\n    static ostream& write_str(ostream& out, f64 x) {\n        return out << x;\n    }\n    static ostream& write_repr(ostream& out, f64 x) {\n#pragma GCC diagnostic push\n#pragma GCC diagnostic ignored \"-Wfloat-equal\"\n        if(x == FINF) return out << \"FINF\";\n#pragma GCC diagnostic pop\n        return out << x;\n    }\n};\n\ntemplate<typename T>\nstruct Formatter<vector<T>> {\n    static ostream& write_str(ostream& out, const vector<T>& v) {\n        return WRITE_RANGE_STR(out, begin(v), end(v));\n    }\n    static ostream& write_repr(ostream& out, const vector<T>& v) {\n        out << \"vector\";\n        return WRITE_RANGE_REPR(out, begin(v), end(v));\n    }\n};\n\ntemplate<typename T1, typename T2>\nstruct Formatter<pair<T1,T2>> {\n    static ostream& write_str(ostream& out, const pair<T1,T2>& p) {\n        WRITE_STR(out, p.first);\n        out << ' ';\n        WRITE_STR(out, p.second);\n        return out;\n    }\n    static ostream& write_repr(ostream& out, const pair<T1,T2>& p) {\n        out << \"(\";\n        WRITE_REPR(out, p.first);\n        out << \",\";\n        WRITE_REPR(out, p.second);\n        out << \")\";\n        return out;\n    }\n};\n\ntemplate<typename... TS>\nstruct Formatter<tuple<TS...>> {\n    template<size_t I=0, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>&) {\n        return out;\n    }\n    template<size_t I=0, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_str_impl(ostream& out, const tuple<TS...>& t) {\n        if(I != 0) out << ' ';\n        WRITE_STR(out, get<I>(t));\n        return write_str_impl<I+1>(out, t);\n    }\n\n    template<size_t I=0, enable_if_t<I == sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>&) {\n        if(sizeof...(TS) == 0) out << \"(\";\n        return out << \")\";\n    }\n    template<size_t I=0, enable_if_t<I < sizeof...(TS), nullptr_t> = nullptr>\n    static ostream& write_repr_impl(ostream& out, const tuple<TS...>& t) {\n        if(I == 0)\n            out << \"(\";\n        else\n            out << \",\";\n        WRITE_REPR(out, get<I>(t));\n        return write_repr_impl<I+1>(out, t);\n    }\n\n    static ostream& write_str(ostream& out, const tuple<TS...>& t) {\n        return write_str_impl(out, t);\n    }\n    static ostream& write_repr(ostream& out, const tuple<TS...>& t) {\n        return write_repr_impl(out, t);\n    }\n};\n\ntemplate<typename T>\nvoid RD(T& x) {\n    cin >> x;\n#ifdef PROCON_LOCAL\n    assert(cin);\n#endif\n}\n\ntemplate<typename T>\nvoid RD(vector<T>& v, i64 n) {\n    v.reserve(n);\n    REP(_, n) {\n        T e; RD(e);\n        v.emplace_back(e);\n    }\n}\n\nvoid PRINT() {}\n\ntemplate<typename T, typename... TS>\nvoid PRINT(const T& x, const TS& ...args) {\n    WRITE_STR(cout, x);\n    if(sizeof...(args)) {\n        cout << ' ';\n        PRINT(args...);\n    }\n}\n\ntemplate<typename... TS>\nvoid PRINTLN(const TS& ...args) {\n    PRINT(args...);\n    cout << '\\n';\n}\n\n[[noreturn]] void EXIT() {\n#ifdef PROCON_LOCAL\n    cerr.flush();\n#endif\n    cout.flush();\n    _Exit(0);\n}\n\ntemplate<typename T>\nvoid DBG_IMPL(i64 line, const char* expr, const T& value) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_REPR(cerr, value);\n    cerr << \"\\n\";\n#endif\n}\n\ntemplate<typename T, size_t N>\nvoid DBG_ARRAY_IMPL(i64 line, const char* expr, const T (&ary)[N]) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr << \" = \";\n    WRITE_RANGE_REPR(cerr, begin(ary), end(ary));\n    cerr << \"\\n\";\n#endif\n}\n\ntemplate<typename InputIt>\nvoid DBG_RANGE_IMPL(i64 line, const char* expr1, const char* expr2, InputIt first, InputIt last) {\n#ifdef PROCON_LOCAL\n    cerr << \"[L \" << line << \"]: \";\n    cerr << expr1 << \",\" << expr2 << \" = \";\n    WRITE_RANGE_REPR(cerr, first, last);\n    cerr << \"\\n\";\n#endif\n}\n\n#define DBG(expr) DBG_IMPL(__LINE__, #expr, (expr))\n#define DBG_ARRAY(expr) DBG_ARRAY_IMPL(__LINE__, #expr, (expr))\n#define DBG_RANGE(first,last) DBG_RANGE_IMPL(__LINE__, #first, #last, (first), (last))\n// }}}\n\n// {{{ init\nstruct ProconInit {\n    static constexpr int IOS_PREC = 15;\n    static constexpr bool AUTOFLUSH = false;\n\n    ProconInit() {\n        cin.tie(nullptr);\n        ios::sync_with_stdio(false);\n        cout << fixed << setprecision(IOS_PREC);\n#ifdef PROCON_LOCAL\n        cerr << fixed << setprecision(IOS_PREC);\n#endif\n        if(AUTOFLUSH)\n            cout << unitbuf;\n    }\n} PROCON_INIT;\n// }}}\n\n// {{{ cum (build() 忘れに注意)\n\n// 1次元累積和\ntemplate<typename T>\nstruct Cum1 {\n    vector<T> v_;\n\n    explicit Cum1(i64 n) : v_(n+1, T(0)) {}\n\n    void add(i64 i, T val) {\n        v_[i+1] += val;\n    }\n\n    void build() {\n        ALL(partial_sum, v_, begin(v_));\n    }\n\n    T query(i64 i, i64 n) const {\n        return v_[i+n] - v_[i];\n    }\n};\n\n// 2次元累積和\ntemplate<typename T>\nstruct Cum2 {\n    vector<vector<T>> v_;\n\n    Cum2(i64 h, i64 w) : v_(h+1, vector<T>(w+1, T(0))) {}\n\n    void add(i64 y, i64 x, T val) {\n        v_[y+1][x+1] += val;\n    }\n\n    void build() {\n        i64 h = SIZE(v_) - 1;\n        FOR(y, 1, h+1) {\n            ALL(partial_sum, v_[y], begin(v_[y]));\n            ALL(transform, v_[y-1], begin(v_[y]), begin(v_[y]), plus<>());\n        }\n    }\n\n    T query(i64 y, i64 x, i64 h, i64 w) const {\n        return v_[y+h][x+w] - v_[y+h][x] - v_[y][x+w] + v_[y][x];\n    }\n};\n\n// }}}\n\n//--------------------------------------------------------------------\n\ntemplate<typename K, typename V, typename Comp>\nauto map_lt(map<K,V,Comp>& m, const K& x) {\n    auto it = m.lower_bound(x);\n    if(it == begin(m)) return end(m);\n    return prev(it);\n}\n\ntemplate<typename K, typename V, typename Comp>\nauto map_lt(const map<K,V,Comp>& m, const K& x) {\n    auto it = m.lower_bound(x);\n    if(it == begin(m)) return end(m);\n    return prev(it);\n}\n\ntemplate<typename K, typename V, typename Comp>\nauto map_le(map<K,V,Comp>& m, const K& x) {\n    auto it = m.upper_bound(x);\n    if(it == begin(m)) return end(m);\n    return prev(it);\n}\n\ntemplate<typename K, typename V, typename Comp>\nauto map_le(const map<K,V,Comp>& m, const K& x) {\n    auto it = m.upper_bound(x);\n    if(it == begin(m)) return end(m);\n    return prev(it);\n}\n\ntemplate<typename K, typename V, typename Comp>\nauto map_gt(map<K,V,Comp>& m, const K& x) {\n    return m.upper_bound(x);\n}\n\ntemplate<typename K, typename V, typename Comp>\nauto map_gt(const map<K,V,Comp>& m, const K& x) {\n    return m.upper_bound(x);\n}\n\ntemplate<typename K, typename V, typename Comp>\nauto map_ge(map<K,V,Comp>& m, const K& x) {\n    return m.lower_bound(x);\n}\n\ntemplate<typename K, typename V, typename Comp>\nauto map_ge(const map<K,V,Comp>& m, const K& x) {\n    return m.lower_bound(x);\n}\n\n// xs は破壊される\ntemplate<typename Comp>\nvoid coord_compress(vector<i64>& xs, map<i64,i64,Comp>& m) {\n    ALL(sort, xs);\n    UNIQ(xs);\n    REP(i, SIZE(xs)) {\n        m.emplace(xs[i], i);\n    }\n}\n\n// xs は破壊される\ntemplate<typename Hash, typename Eq>\nvoid coord_compress(vector<i64>& xs, unordered_map<i64,i64,Hash,Eq>& m) {\n    ALL(sort, xs);\n    UNIQ(xs);\n    REP(i, SIZE(xs)) {\n        m.emplace(xs[i], i);\n    }\n}\n\nvoid solve() {\n    i64 N; RD(N);\n    i64 M; RD(M);\n\n    vector<pair<i64,i64>> yxs;\n    yxs.reserve(N);\n    REP(_, N) {\n        i64 x,y; RD(x); RD(y);\n        yxs.emplace_back(y,x);\n    }\n\n    vector<i64> ys; ys.reserve(N);\n    vector<i64> xs; xs.reserve(N);\n    for(const auto& yx : yxs) {\n        i64 y,x; tie(y,x) = yx;\n        ys.emplace_back(y);\n        xs.emplace_back(x);\n    }\n    ys.insert(end(ys), { -INF, INF });\n    xs.insert(end(xs), { -INF, INF });\n    map<i64,i64> ycomp, xcomp;\n    coord_compress(ys, ycomp);\n    coord_compress(xs, xcomp);\n    ALL(transform_self, yxs, [&ycomp,&xcomp](const auto& yx) {\n        i64 y,x; tie(y,x) = yx;\n        return make_pair(ycomp[y], xcomp[x]);\n    });\n    DBG(yxs);\n\n    i64 h = SIZE(ycomp);\n    i64 w = SIZE(xcomp);\n    Cum2<i64> cum(h, w);\n    for(const auto& yx : yxs) {\n        i64 y,x; tie(y,x) = yx;\n        cum.add(y, x, 1);\n    }\n    cum.build();\n    DBG(cum.v_);\n\n    REP(_, M) {\n        i64 x1,y1; RD(x1); RD(y1);\n        i64 x2,y2; RD(x2); RD(y2);\n        i64 yy1 = map_ge(ycomp,y1)->second;\n        i64 xx1 = map_ge(xcomp,x1)->second;\n        i64 yy2 = map_le(ycomp,y2)->second;\n        i64 xx2 = map_le(xcomp,x2)->second;\n        DBG(make_tuple(yy1,xx1,yy2,xx2));\n        i64 hh = yy2 - yy1 + 1;\n        i64 ww = xx2 - xx1 + 1;\n\n        i64 ans = cum.query(yy1, xx1, hh, ww);\n        PRINTLN(ans);\n    }\n}\n\nsigned main() {\n    \n\n    solve();\n\n    EXIT();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_;\n\tstd::vector<std::vector<Type> > dat;\n\tstd::vector<std::vector<int> > vl;\n\tinline int query_(int a, int b, Type x, int k, int l, int r, int e) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r) and e integers below x in the range\n\t\tif (r <= a || b <= l || e == 0) return 0;\n\t\tif (a <= l && r <= b) return e;\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1, vl[k][e - 1]);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r, e - vl[k][e - 1]);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1);\n\t\tdat.resize(size_ << 1, std::vector<Type>());\n\t\tvl.resize(size_ << 1, std::vector<int>());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdat[i + size_].push_back(*begin_ + i);\n\t\t\tvl[i].push_back(1);\n\t\t}\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tvl[i].resize(dat[i].size());\n\t\t\tint cl = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][j - cl])) dat[i][j] = dat[i << 1][cl++];\n\t\t\t\telse dat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\tvl[i][j] = cl;\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\tint ptr = lower_bound(dat[1].begin(), dat[1].end(), x) - dat[1].begin();\n\t\treturn query_(l, r, x, 1, 0, size_, ptr);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <bitset>\n#include <climits>\n\n#define all(c) (c).begin(), (c).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define pb(e) push_back(e)\n#define mp(a, b) make_pair(a, b)\n#define fr first\n#define sc second\n\nconst int INF=100000000;\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nusing namespace std;\ntypedef pair<int ,int > P;\ntypedef long long ll;\n\nint n,m;\nint sum[5003][5003];\nint x[5003],y[5003];\nvector<int> comp(int *a) {\n    vector<int> vec;\n    rep(i,n) vec.pb(a[i]);\n    sort(all(vec));\n    vec.erase(unique(all(vec)),vec.end());\n\n    return vec;\n}\nint conv(vector<int> &vec,int x) {\n    return lower_bound(all(vec),x)-vec.begin();\n}\nint main() {\n    cin>>n>>m;\n    rep(i,n) {\n        cin>>x[i]>>y[i];\n    }\n    vector<int> comp_x=comp(x);\n    vector<int> comp_y=comp(y);\n\n    rep(i,n) {\n        //printf(\"%d %d -> \",y[i],x[i]);\n        int nx=conv(comp_x,x[i]);\n        int ny=conv(comp_y,y[i]);\n        //printf(\"%d %d\\n\",ny,nx);\n        sum[ny+1][nx+1]++;\n    }\n\n    rep(i,comp_y.size()+1) rep(j,comp_x.size()+1) if(i&&j) {\n        sum[i][j]+=sum[i-1][j]+sum[i][j-1]-sum[i-1][j-1];\n    }\n\n    rep(i,m) {\n        int x1,x2;\n        int y1,y2;\n        cin>>x1>>y1>>x2>>y2;\n        x1=conv(comp_x,x1);\n        x2=conv(comp_x,x2+1);\n        y1=conv(comp_y,y1);\n        y2=conv(comp_y,y2+1);\n        printf(\"%d\\n\",sum[y2][x2]-sum[y2][x1]-sum[y1][x2]+sum[y1][x1]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    compressed_x.PB(inf);\n    compressed_y.PB(inf);\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = upper_bound(all(compressed_x), x2) - begin(compressed_x) - 1;\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = upper_bound(all(compressed_y), y2) - begin(compressed_y) - 1;\n\n        if (x2 < 0 || y2 < 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nstruct dat {\n    int id;\n    int z;\n\n    dat () {}\n    ~dat () {}\n\n    dat (int a, int b): id(a), z(b) {}\n    \n    bool operator < (const dat& o) const {\n        return z < o.z;\n    }\n};\n\nint N, M;\nint tx[5000], ty[5000];\n\ndat arr_x[5000];\ndat arr_y[5000];\n\nint check[5000];\n\nint solve(int x1, int y1, int x2, int y2) {\n    fill(check, check + N, 0);\n\n    int idxx = lower_bound(arr_x, arr_x+N, dat(-1, x1)) - arr_x;\n    for (int j = idxx; j < N && arr_x[j].z <= x2; ++j) {\n        ++ check[ arr_x[j].id ];\n    }\n\n    int idxy = lower_bound(arr_y, arr_y+N, dat(-1, y1)) - arr_y;\n    for (int j = idxy; j < N && arr_y[j].z <= y2; ++j) {\n        ++check[ arr_y[j].id ];\n    }\n\n    int ans = 0;\n    for (int j = 0; j < N; ++j) {\n        ans += check[j] >> 1;\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    for (int j = 0; j < N; ++j) {\n        cin >> tx[j] >> ty[j];\n    }\n\n    // initialize\n    for (int j = 0; j < N; ++j) {\n        arr_x[j] = dat(j, tx[j]);\n        arr_y[j] = dat(j, ty[j]);\n    }\n    sort(arr_x, arr_x + N);\n    sort(arr_y, arr_y + N);\n\n    for (int j = 0; j < M; ++j) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        cout << solve(x1, y1, x2, y2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\nconst int N = 5002;\n\nint n, m, p_cnt[N][N], X[N], Y[N];\nvector<int> vx, vy;\n\nint conv(vector<int>& vec, int x){\n  return lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n}\n\nvoid print(int n){\n  for(int i=n+1;i>=0;i--){\n    for(int j=0;j<n+2;j++){\n      cout << p_cnt[i][j];\n    }\n    cout << endl;\n  }\n  cout << endl;\n}\n\nmain(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++){\n    cin >> X[i] >> Y[i];\n    vx.push_back(X[i]);\n    vy.push_back(Y[i]);\n  }\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n\n  fill(p_cnt[0], p_cnt[N], 0);\n  for(int i=0;i<n;i++){\n    int x = conv(vx, X[i]);\n    int y = conv(vy, Y[i]);\n    p_cnt[y+1][x+1]++;\n    //printf(\"X[i] = %d, Y[i] = %d, x = %d, y = %d\\n\", X[i], Y[i], x, y);\n  }\n  //print(n);\n  for(int i=0;i<vy.size()+2;i++){\n    for(int j=0;j<vx.size()+2;j++){\n      if(i == 0 && j == 0) continue;\n      else if(i == 0) p_cnt[i][j] += p_cnt[i][j-1];\n      else if(j == 0) p_cnt[i][j] += p_cnt[i-1][j];\n      else p_cnt[i][j] += p_cnt[i][j-1] + p_cnt[i-1][j] - p_cnt[i-1][j-1];\n    }\n  }\n  //print(n);\n  for(int i=0;i<m;i++){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = conv(vx, x1);\n    y1 = conv(vy, y1);\n    x2 = conv(vx, x2+1);\n    y2 = conv(vy, y2+1);\n    //printf(\"%d %d %d %d\\n\", x1, y1, x2, y2);\n    cout << p_cnt[y2][x2] - p_cnt[y2][x1] - p_cnt[y1][x2] + p_cnt[y1][x1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nmap<int, int> mx, my;\nvector<int> vx, vy;\nint N, M, x[5010], y[5010];\nint board[5010][5010];\n\nsigned main() {\n    cin >> N >> M;\n    rep(i,0,N) {\n        cin >> x[i] >> y[i];\n        if(!mx.count(x[i])) vx.push_back(x[i]);\n        if(!my.count(y[i])) vy.push_back(y[i]);\n        mx[ x[i] ];\n        my[ y[i] ];\n    }\n    sort(vx.begin(), vx.end());\n    sort(vy.begin(), vy.end());\n    vx.push_back(INF); vy.push_back(INF);\n\n    // compression\n    int k = 1;\n    for(auto &e : mx) {\n        e.second = k++;\n        // printf(\"mx: %lld -> %lld\\n\", e.first, e.second);\n    }\n    k = 1;\n    for(auto &e : my) {\n        e.second = k++;\n        // printf(\"my: %lld -> %lld\\n\", e.first, e.second);\n    }\n\n    // accumulate\n    rep(i,0,N) {\n        // printf(\"treasure exist: (%lld, %lld)\\n\", mx[x[i]], my[y[i]]);\n        board[ mx[x[i]] ][ my[y[i]] ]++;\n    }\n    rep(i,0,N+1) rep(j,0,N+1) board[i+1][j+1] += board[i+1][j];\n    rep(j,0,N+1) rep(i,0,N+1) board[i+1][j+1] += board[i][j+1];\n\n    // solve\n    rep(i,0,M) {\n        int xl, yl, xr, yr;\n        cin >> xl >> yl >> xr >> yr;\n\n        // 1-indexed\n        xl = lower_bound(vx.begin(), vx.end(), xl) - vx.begin();\n        yl = lower_bound(vy.begin(), vy.end(), yl) - vy.begin();\n        xr = upper_bound(vx.begin(), vx.end(), xr) - vx.begin();\n        yr = upper_bound(vy.begin(), vy.end(), yr) - vy.begin();\n\n        // printf(\"xl = %lld, yl = %lld, xr = %lld, yr = %lld\\n\", xl, yl, xr, yr);\n\n        int ans = board[xr][yr] - board[xr][yl] - board[xl][yr] + board[xl][yl];\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, q, x1, y1, x2, y2, x[5555], y[5555]; pair<int, int> p[5555];\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p, p + n);\n\tfor(int i = 0; i < n; i++) x[i] = p[i].first, y[i] = p[i].second;\n\tfor(int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tint l = lower_bound(x, x + n, x1);\n\t\tint r = lower_bound(x, x + n, x2 + 1);\n\t\tint c = 0;\n\t\tfor(int j = l; j < r; j++) {\n\t\t\tif(y1 <= y[j] && y[j] <= y2) c++;\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9+10;\n\nint dp[5001][5001];\nint exist[5001][5001];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  vector<PII> ps(N);\n  VI xs(N), ys(N);\n  // x??§?¨???¨y??§?¨??????\\??????????????????\n  REP(i,N){\n\tcin >> ps[i].first >> ps[i].second;\n\txs[i] = ps[i].first, ys[i] = ps[i].second;\n  }\n  xs.PB(-INF), xs.PB(INF);\n  ys.PB(-INF), ys.PB(INF);\n  SORT(xs); SORT(ys);\n\n  // x -> x', 0 <= x' < N+2\n  map<int,int> compX, compY;\n  VI decompX(N+2), decompY(N+2);\n  int MX = 0;\n  REP(i,N+2)\n\tif(!compX.count(xs[i])){\n\t  compX[xs[i]] = MX++;\n\t  decompX[MX-1] = xs[i];\n\t}\n  int MY = 0;\n  REP(i,N+2)\n\tif(!compY.count(ys[i])){\n\t  compY[ys[i]] = MY++;\n\t  decompY[MY-1] = ys[i];\n\t}\n\n  REP(i,N){\n\t++exist[compY[ps[i].second]][compX[ps[i].first]];\n  }\n  for(int y=0;y<MY;++y)\n\tfor(int x=0;x<MX;++x)\n\t  dp[y][x] = (y>0? dp[y-1][x]:0) + (x>0?dp[y][x-1]:0) - (y>0&&x>0? dp[y-1][x-1]:0) + exist[y][x];\n\n  while(M--){\n\tint sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n\tint sxi = compX.lower_bound(sx)->second;\n\tint syi = compY.lower_bound(sy)->second;\n\tauto it = compX.upper_bound(ex); --it;\n\tint exi = it->second;\n\tit = compY.upper_bound(ey); --it;\n\tint eyi = it->second;\n\n\tint ans = dp[eyi][exi] - (sxi>0?dp[eyi][sxi-1]:0) - (syi>0?dp[syi-1][exi]:0) + (syi>0&&sxi>0? dp[syi-1][sxi-1]:0);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nclass Imos{\npublic:\n    int H, W;\n    vector<vector<int>> d;\npublic:\n    //1-indexed\n    Imos(vector<vector<int>>& field){\n        H = field.size();\n        W = field[0].size();\n        d = vector<vector<int> >(H+1, vector<int>(W+1));\n        \n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                d[i+1][j+1] = d[i+1][j] + d[i][j+1] - d[i][j] + field[i][j];\n            }\n        }\n    }\n    int area(int h1, int w1, int h2, int w2){\n        //size of area s.t. [h1, h2) and [w1, w2)\n        return d[h2][w2] - d[h2][w1] - d[h1][w2] + d[h1][w1];\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    \n    int N, M; cin >> N >> M;\n    \n    vector<int> xs(N), ys(N);\n    vector<int> xps(N), yps(N);\n    \n    for(int i=0; i<N; i++){\n        scanf(\"%d %d\", &xs[i], &ys[i]);\n        xps[i] = xs[i];\n        yps[i] = ys[i];\n    }\n    \n    sort(xs.begin(), xs.end());\n    sort(ys.begin(), ys.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    \n    vector<vector<int>> d(xs.size(), vector<int>(ys.size()));\n    for(int i=0; i<N; i++){\n        int x = xps[i], y = yps[i];\n        int xi = lower_bound(xs.begin(), xs.end(), xps[i]) - xs.begin();\n        int yi = lower_bound(ys.begin(), ys.end(), yps[i]) - ys.begin();\n        \n        d[xi][yi]++;\n    }\n    \n    Imos imos = Imos(d);\n    \n    while(M--){\n        int x1, y1, x2, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        \n        int x1i = lower_bound(xs.begin(), xs.end(), x1) - xs.begin();\n        int y1i = lower_bound(ys.begin(), ys.end(), y1) - ys.begin();\n        int x2i = upper_bound(xs.begin(), xs.end(), x2) - xs.begin();\n        int y2i = upper_bound(ys.begin(), ys.end(), y2) - ys.begin();\n        \n        printf(\"%d\\n\", imos.area(x1i, y1i, x2i, y2i));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint sum[5002][5002];\nint x[5002];\nint y[5002];\nint X[5002];\nint Y[5002];\nint main(){\n\tint a,b;\n\tscanf(\"%d%d\",&a,&b);\n\tfor(int i=0;i<a;i++){\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tX[i]=x[i];\n\t\tY[i]=y[i];\n\t}\n\tX[a]=-1999999999;\n\tX[a+1]=1999999999;\n\tY[a]=-1999999999;\n\tY[a+1]=1999999999;\n\tstd::sort(X,X+a+2);\n\tstd::sort(Y,Y+a+2);\n\tfor(int i=0;i<a;i++){\n\t\tx[i]=lower_bound(X,X+a+2,x[i])-X;\n\t\ty[i]=lower_bound(Y,Y+a+2,y[i])-Y;\n\t\tsum[x[i]][y[i]]++;\n\t}\n\tfor(int i=0;i<a+2;i++){\n\t\tfor(int j=1;j<a+2;j++){\n\t\t\tsum[i][j]+=sum[i][j-1];\n\t\t}\n\t}\n\tfor(int i=0;i<a+2;i++){\n\t\tfor(int j=1;j<a+2;j++){\n\t\t\tsum[j][i]+=sum[j-1][i];\n\t\t}\n\t}\n\tfor(int i=0;i<b;i++){\n\t\tint p,q,r,s;\n\t\tscanf(\"%d%d%d%d\",&p,&q,&r,&s);\n\t\tint P=lower_bound(X,X+a+2,p)-X-1;\n\t\tint Q=lower_bound(Y,Y+a+2,q)-Y-1;\n\t\tint R=upper_bound(X,X+a+2,r)-X-1;\n\t\tint S=upper_bound(Y,Y+a+2,s)-Y-1;\n\t\tprintf(\"%d\\n\",sum[R][S]-sum[R][Q]-sum[P][S]+sum[P][Q]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\nint n,m;\n\nint main(int argc, char *argv[])\n{\n  cin >> n >> m;\n  vector<int> appx,appy;\n  vector<PI> tr(n);\n  rep(i,n){\n    cin >> tr[i].F >> tr[i].S;\n    appx.pb(tr[i].F);\n    appy.pb(tr[i].S);\n  }\n  sort(ALL(appx));\n  sort(ALL(appy));\n  appx.erase(unique(ALL(appx)),appx.end());\n  appy.erase(unique(ALL(appy)),appy.end());\n  map<int,int> xidx,yidx;\n  rep(i,SZ(appx)) xidx[appx[i]]=i;\n  rep(i,SZ(appy)) yidx[appy[i]]=i;\n\n  int sum[SZ(xidx)+20][SZ(yidx)+20];\n  CLR(sum);\n  FOR(it,tr) ++sum[xidx[it->F]+1][yidx[it->S]+1];\n  rep(i,SZ(xidx)+10)rep(j,SZ(yidx)+10)\n    sum[i+1][j+1]+=sum[i+1][j]+sum[i][j+1]-sum[i][j];\n  \n  rep(i,m){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1=lower_bound(ALL(appx),x1)-appx.begin();\n    x2=lower_bound(ALL(appx),x2+1)-appx.begin();\n    y1=lower_bound(ALL(appy),y1)-appy.begin();\n    y2=lower_bound(ALL(appy),y2+1)-appy.begin();\n    cout << sum[x2][y2]+sum[x1][y1]-sum[x1][y2]-sum[x2][y1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nint main()\n{\n    int n, m;\n    scanf(\"%d%d\", &n, &m);\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i)\n        scanf(\"%d%d\", &x[i], &y[i]);\n    vector<int> ori_x = x, ori_y = y;\n\n    const int INF = 2e9;\n    x.push_back(-INF);\n    x.push_back(INF);\n    y.push_back(-INF);\n    y.push_back(INF);\n    unique(x);\n    unique(y);\n\n    static int sum[5100][5100];\n    for (int i = 0; i < n; ++i)\n    {\n        int px = upper_bound(all(x), ori_x[i]) - x.begin();\n        int py = upper_bound(all(y), ori_y[i]) - y.begin();\n        ++sum[py][px];\n    }\n    for (int i = 0; i < y.size(); ++i)\n        for (int j = 0; j < x.size(); ++j)\n            sum[i + 1][j + 1] += sum[i][j + 1] + sum[i + 1][j] - sum[i][j];\n\n    while (m--)\n    {\n        int x1, y1, x2, y2;\n        scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n        x1 = lower_bound(all(x), x1) - x.begin();\n        y1 = lower_bound(all(y), y1) - y.begin();\n        x2 = upper_bound(all(x), x2) - x.begin();\n        y2 = upper_bound(all(y), y2) - y.begin();\n\n        int res = sum[y2][x2] - (sum[y2][x1] + sum[y1][x2]) + sum[y1][x1];\n        printf(\"%d\\n\", res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\nusing namespace std;\n\nstruct Node {\n\tint location;\n\tint p, l, r;\n\tNode() {}\n};\n\nstruct Point {\n\tint x;\n\tint y;\n\tint index;\n\tPoint() {}\n\tPoint(int x, int y, int index) :x(x), y(y), index(index) {}\n\tbool operator < (const Point& o) const {\n\t\treturn index < o.index;\n\t}\n};\nstatic const int MAX = 10000;\nstatic const int NIL = -1;\nPoint P[MAX];\nNode T[MAX];\nint N;\nint M;\nint np;\n\nbool lessX(const Point &p1, const Point &p2) {\n\treturn p1.x < p2.x;\n}\n\nbool lessY(const Point &p1, const Point &p2) {\n\treturn p1.y < p2.y;\n}\n\nint makekDTree(int l, int r, int depth) {\n\tif (!(l < r))return NIL;\n\tint mid = (l + r) / 2;\n\tint t = np++;\n\tif (depth % 2 == 0) {\n\t\tsort(P + l, P + r, lessX);\n\t}\n\telse {\n\t\tsort(P + l, P + r, lessY);\n\t}\n\tT[t].location = mid;\n\tT[t].l = makekDTree(l, mid, depth + 1);\n\tT[t].r = makekDTree(mid + 1, r, depth + 1);\n\n\treturn t;\n}\n\nvoid find(int v, int sx, int tx, int sy, int ty, int depth, vector<Point> &ans) {\n\tint x = P[T[v].location].x;\n\tint y = P[T[v].location].y;\n\n\tif (sx <= x && x <= tx && sy <= y && y <= ty) {\n\t\tans.push_back(P[T[v].location]);\n\t}\n\n\tif (depth % 2 == 0) {\n\t\tif (T[v].l != NIL) {\n\t\t\tif (sx <= x) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t\tif (T[v].r != NIL) {\n\t\t\tif (x <= tx) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t}\n\telse {\n\t\tif (T[v].l != NIL) {\n\t\t\tif (sy <= y) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t\tif (T[v].r != NIL) {\n\t\t\tif (y <= ty) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N >> M;\n\tfor (int i = 0; i < N;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tP[i] = Point(x, y, i);\n\t\tT[i].l = T[i].r = T[i].p = NIL;\n\t}\n\tnp = 0;\n\tint root = makekDTree(0, N, 0);\n\tvector<Point> ans;\n\tfor (int i = 0; i < M; i++) {\n\t\tint sx, tx, sy, ty;\n\t\tcin >> sx >> sy >> tx >> ty;\n\t\tans.clear();\n\t\tfind(root, sx, tx, sy, ty, 0, ans);\n\t\tsort(ans.begin(), ans.end());\n\t\tcout << ans.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\nusing namespace std;\n\nstruct Node {\n\tint location;\n\tint p, l, r;\n\tNode() {}\n};\n\nstruct Point {\n\tint x;\n\tint y;\n\tint index;\n\tPoint() {}\n\tPoint(int x, int y, int index) :x(x), y(y), index(index) {}\n\tbool operator < (const Point& o) const {\n\t\treturn index < o.index;\n\t}\n};\nstatic const int MAX = 10000;\nstatic const int NIL = -1;\nPoint P[MAX];\nNode T[MAX];\nint N;\nint M;\nint np;\n\nbool lessX(const Point &p1, const Point &p2) {\n\treturn p1.x < p2.x;\n}\n\nbool lessY(const Point &p1, const Point &p2) {\n\treturn p1.y < p2.y;\n}\n\nint makekDTree(int l, int r, int depth) {\n\tif (!(l < r))return NIL;\n\tint mid = (l + r) / 2;\n\tint t = np++;\n\tif (depth % 2 == 0) {\n\t\tsort(P + l, P + r, lessX);\n\t}\n\telse {\n\t\tsort(P + l, P + r, lessY);\n\t}\n\tT[t].location = mid;\n\tT[t].l = makekDTree(l, mid, depth + 1);\n\tT[t].r = makekDTree(mid + 1, r, depth + 1);\n\n\treturn t;\n}\n\nvoid find(int v, int sx, int tx, int sy, int ty, int depth, vector<Point> &ans) {\n\tint x = P[T[v].location].x;\n\tint y = P[T[v].location].y;\n\n\tif (sx <= x && x <= tx && sy <= y && y <= ty) {\n\t\tans.push_back(P[T[v].location]);\n\t}\n\n\tif (depth % 2 == 0) {\n\t\tif (T[v].l != NIL) {\n\t\t\tif (sx <= x) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t\tif (T[v].r != NIL) {\n\t\t\tif (x <= tx) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t}\n\telse {\n\t\tif (T[v].l != NIL) {\n\t\t\tif (sy <= y) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t\tif (T[v].r != NIL) {\n\t\t\tif (y <= ty) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d %d\", &N, &M);\n\tfor (int i = 0; i < N;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tP[i] = Point(x, y, i);\n\t\tT[i].l = T[i].r = T[i].p = NIL;\n\t}\n\tnp = 0;\n\tint root = makekDTree(0, N, 0);\n\tvector<Point> ans;\n\tfor (int i = 0; i < M; i++) {\n\t\tint sx, tx, sy, ty; scanf(\"%d %d %d %d\", &sx, &sy, &tx, &ty);\n\t\tans.clear();\n\t\tfind(root, sx, tx, sy, ty, 0, ans);\n\t\tprintf(\"%d\\n\", ans.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\n#define INF (2e9)\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<P,int> PP;\nP in[5002];\nint n,m;\n\nint main(){\n  cin>>n>>m;\n  set <int> X,Y;\n  for(int i=0;i<n;i++){\n    cin>>in[i].f>>in[i].s;\n    X.insert(in[i].f);\n    Y.insert(in[i].s);\n  }\n  X.insert(INF),Y.insert(INF);\n  for(int i=0;i<n&&(Y.size()>X.size());i++)swap(in[i].f,in[i].s);\n  sort(in,in+n);\n  set <PP> S;\n  for(int i=0;i<n;i++) S.insert(PP(in[i],i));\n  S.insert(PP(P(INF,INF),n));\n  \n  int a,b,c,d;  \n  while(m--){\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    if(X.size()<Y.size())swap(a,b),swap(c,d);\n    int cnt=0;\n    set <PP> :: iterator it1,it2;\n    set<int> :: iterator na;\n    if(X.size()>=Y.size())na=lower_bound(X.begin(),X.end(),a);\n    else na=lower_bound(Y.begin(),Y.end(),a);\n\n    while(*na <= c){\n      it1=lower_bound(S.begin(),S.end(),PP(P(*na,b),0));\n      it2=upper_bound(it1,S.end(),PP(P(*na,d),n+1));\n      if(*na==it1->f.f)cnt += (it2->s-it1->s);\n      na++;\n    }\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct CumulativeSum2D\n{\n  vector< vector< int > > data;\n\n  CumulativeSum2D(int W, int H) : data(W + 1, vector< int >(H + 1, 0))\n  {\n  };\n\n  inline void add(int x, int y, int z)\n  {\n    ++x, ++y;\n    if(x >= data.size() || y >= data[0].size()) return;\n    data[x][y] += z;\n  }\n\n  void build()\n  {\n    for(int i = 1; i < data.size(); i++) {\n      for(int j = 1; j < data[i].size(); j++) {\n        data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];\n      }\n    }\n  }\n\n  inline int query(int sx, int sy, int gx, int gy)\n  {\n    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n  }\n};\n\nint main()\n{\n  int N, M, X[5000], Y[5000];\n\n  scanf(\"%d %d\", &N, &M);\n  vector< int > xs(N), ys(N);\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d %d\", &X[i], &Y[i]);\n    xs[i] = X[i];\n    ys[i] = Y[i];\n  }\n  sort(begin(xs), end(xs));\n  xs.erase(unique(begin(xs), end(xs)), end(xs));\n  sort(begin(ys), end(ys));\n  ys.erase(unique(begin(ys), end(ys)), end(ys));\n  CumulativeSum2D sum(xs.size(), ys.size());\n  for(int i = 0; i < N; i++) {\n    sum.add(lower_bound(begin(xs), end(xs), X[i]) - begin(xs),\n            lower_bound(begin(ys), end(ys), Y[i]) - begin(ys), 1);\n  }\n  sum.build();\n  for(int i = 0; i < M; i++) {\n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    x1 = lower_bound(begin(xs), end(xs), x1) - begin(xs);\n    y1 = lower_bound(begin(ys), end(ys), y1) - begin(ys);\n    x2 = upper_bound(begin(xs), end(xs), x2) - begin(xs);\n    y2 = upper_bound(begin(ys), end(ys), y2) - begin(ys);\n    printf(\"%d\\n\", sum.query(x1, y1, x2, y2));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\nusing namespace std;\n\n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n\ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconstexpr ll INF = 1001001001001001LL;\nconstexpr ll MOD = 1000000007LL;\n\nmap<int, int> mx, my;\nvector<int> vx, vy;\nint N, M, x[1010], y[1010];\nint board[1010][1010];\n\nsigned main() {\n    cin >> N >> M;\n    rep(i,0,N) {\n        cin >> x[i] >> y[i];\n        if(!mx.count(x[i])) vx.push_back(x[i]);\n        if(!my.count(y[i])) vy.push_back(y[i]);\n        mx[ x[i] ];\n        my[ y[i] ];\n    }\n    sort(vx.begin(), vx.end());\n    sort(vy.begin(), vy.end());\n    vx.push_back(INF); vy.push_back(INF);\n\n    // compression\n    int k = 1;\n    for(auto &e : mx) {\n        e.second = k++;\n        // printf(\"mx: %lld -> %lld\\n\", e.first, e.second);\n    }\n    k = 1;\n    for(auto &e : my) {\n        e.second = k++;\n        // printf(\"my: %lld -> %lld\\n\", e.first, e.second);\n    }\n\n    // accumulate\n    rep(i,0,N) {\n        // printf(\"treasure exist: (%lld, %lld)\\n\", mx[x[i]], my[y[i]]);\n        board[ mx[x[i]] ][ my[y[i]] ]++;\n    }\n    rep(i,0,N+1) rep(j,0,N+1) board[i+1][j+1] += board[i+1][j];\n    rep(j,0,N+1) rep(i,0,N+1) board[i+1][j+1] += board[i][j+1];\n\n    // solve\n    rep(i,0,M) {\n        int xl, yl, xr, yr;\n        cin >> xl >> yl >> xr >> yr;\n\n        // 1-indexed\n        xl = lower_bound(vx.begin(), vx.end(), xl) - vx.begin();\n        yl = lower_bound(vy.begin(), vy.end(), yl) - vy.begin();\n        xr = upper_bound(vx.begin(), vx.end(), xr) - vx.begin();\n        yr = upper_bound(vy.begin(), vy.end(), yr) - vy.begin();\n\n        // printf(\"xl = %lld, yl = %lld, xr = %lld, yr = %lld\\n\", xl, yl, xr, yr);\n\n        int ans = board[xr][yr] - board[xr][yl] - board[xl][yr] + board[xl][yl];\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    VI xs(x), ys(y);\n    sort(xs.begin(),xs.end());\n    sort(ys.begin(),ys.end());\n    xs.erase(unique(xs.begin(),xs.end()), xs.end());\n    ys.erase(unique(ys.begin(),ys.end()), ys.end());\n    REP(i,n){\n        x[i] = find(xs.begin(),xs.end(),x[i]) - xs.begin();\n        y[i] = find(ys.begin(),ys.end(),y[i]) - ys.begin();\n    }\n    int w = xs.size(), h = ys.size();\n    VVI s(w+1, VI(h+1));\n    REP(i,n) s[x[i]+1][y[i]+1]++;\n    REP(i,w) REP(j,h+1) s[i+1][j] += s[i][j];\n    REP(j,h) REP(i,w+1) s[i][j+1] += s[i][j];\n\n    while (m--){\n        int x1, x2, y1, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        x1 = lower_bound(xs.begin(),xs.end(),x1) - xs.begin();\n        x2 = upper_bound(xs.begin(),xs.end(),x2) - xs.begin() - 1;\n        y1 = lower_bound(ys.begin(),ys.end(),y1) - ys.begin();\n        y2 = upper_bound(ys.begin(),ys.end(),y2) - ys.begin() - 1;\n        x2 = max(x2, 0);\n        y2 = max(y2, 0);\n        int ans = s[x2+1][y2+1] - s[x1][y2+1] - s[x2+1][y1] + s[x1][y1];\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Author :\n// Date :\n// Problem:\n// Solution:\n// Comment:\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n\n#define pp push\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n\nusing namespace std;\n\nvector < pair <int,int> > pts;\n\nmain(){\n    int n , m;\n    int x , y;\n    \n    scanf(\"$d $d\",&n,&m);\n    \n    for(int i = 0 ; i < n ; i++){\n        scanf(\"%d %d\",&x,&y);\n        pts.pb(mp(x,y));\n    }\n    \n    int xx,yy;\n    \n    sort( pts.begin() , pts.end() );\n    \n    for(int i = 0 ; i < m ; i++){\n        int cnt = 0;\n        \n        scanf(\"%d %d %d %d\",&x,&y,&xx,&yy);\n        \n        for(int j = 0 ; j < n ; j++){\n            if(x <= pts[j].xx && xx >= pts[j].xx && y <= pts[j].yy && yy >= pts[j].yy){\n                cnt++;\n            }\n            if(x > pts[j].xx) continue;\n        }\n        \n        cout << cnt << endl;\n    }\n\n    #ifdef GEREL\n        for(;;);\n    #endif\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define fs first\n#define sc second\n#define mp make_pair\n#define pb push_back\n#define eb emplace_back\n#define ALL(A) A.begin(),A.end()\n#define RALL(A) A.rbegin(),A.rend()\ntypedef long long LL;\ntypedef pair<int,int> P;\nconst LL mod=998244353;\nconst LL LINF=1LL<<62;\nconst LL INF=1<<30;\nint s[7000][7000];\n\nint main(){\n    int n,m;cin >> n >> m;\n    vector<int> x(n),y(n);\n    vector<P> p;\n    int ss=1000;\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        p.pb({x[i],y[i]});\n    }\n    sort(ALL(x));\n    sort(ALL(y));\n    for (int i = 0; i < n; i++) {\n        s[ss+lower_bound(ALL(x),p[i].fs)-x.begin()][ss+lower_bound(ALL(y),p[i].sc)-y.begin()]++;\n    }\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            s[ss+j+1][ss+i]+=s[ss+j][ss+i];\n        }\n    }\n    for (int i = 0; i <= n; i++) {\n        for (int j = 0; j <= n; j++) {\n            s[ss+i][ss+j+1]+=s[ss+i][ss+j];\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int a,b,c,d;cin >> a >> b >> c >> d;\n        a=lower_bound(ALL(x),a)-x.begin();\n        b=lower_bound(ALL(y),b)-y.begin();\n        c=upper_bound(ALL(x),c)-x.begin()-1;\n        d=upper_bound(ALL(y),d)-y.begin()-1;\n        cout << s[ss+c][ss+d]-s[ss+a-1][ss+d]-s[ss+c][ss+b-1]+s[ss+a-1][ss+b-1] << endl;\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m; cin >> n >> m;\n\tint tx[5000]; int ty[5000];\n\tint s[500000][4];\n\tvector<int> xs; vector<int>ys;\n\trep(i, n) {\n\t\tcin >> tx[i] >> ty[i];\n\t\txs.push_back(tx[i]);\n\t\tys.push_back(ty[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\trep(i, m) {\n\t\trep(j, 4) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t\ts[i][0] = lower_bound(xs.begin(), xs.end(), s[i][0]) - xs.begin();\n\t\ts[i][1] = lower_bound(ys.begin(), ys.end(), s[i][1]) - ys.begin();\n\t\ts[i][2] = upper_bound(xs.begin(), xs.end(), s[i][2]) - xs.begin(); s[i][2]--;\n\t\ts[i][3] = upper_bound(ys.begin(), ys.end(), s[i][3]) - ys.begin(); s[i][3]--;\n\t}\n\trep(i, n) {\n\t\ttx[i] = find(xs.begin(), xs.end(), tx[i]) - xs.begin();\n\t\tty[i] = find(ys.begin(), ys.end(), ty[i]) - ys.begin();\n\t}\n\tint dp[5000][5000] = {};\n\trep(i, n) {\n\t\tdp[tx[i]][ty[i]]++;\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[0][0] = dp[0][0];\n\t\t\t}\n\t\t\telse if (i == 0) {\n\t\t\t\tdp[0][j] += dp[0][j - 1];\n\t\t\t}\n\t\t\telse if (j == 0) {\n\t\t\t\tdp[i][0] += dp[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint sx = s[i][0]; int sy = s[i][1]; int gx = s[i][2]; int gy = s[i][3];\n\t\tint cnt;\n\t\tif (sx >= n || sy >= n || gx < 0 || gy < 0) {\n\t\t\tcnt = 0;\n\t\t}\n\t\telse if (sx > 0 && sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy] - dp[gx][sy - 1] + dp[sx - 1][sy - 1];\n\t\t}\n\t\telse if (sx > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy];\n\t\t}\n\t\telse if (sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[gx][sy - 1];\n\t\t}\n\t\telse {\n\t\t\tcnt = dp[gx][gy];\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <chrono>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <list>\n#include <map>\n#include <queue>\n#include <random>\n#include <regex>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <sys/timeb.h>\n#include <vector>\n\nusing namespace std;\n\n#define repr(i, a, b) for (int i = (int)(a); i < (int)(b); i++)\n#define rep(i, n) repr(i, 0, n)\n#define reprrev(i, a, b) for (int i = (int)(b)-1; i >= (int)(a); i--)\n#define reprev(i, n) reprrev(i, 0, n)\n#define repi(itr, ds) for (auto itr = ds.begin(); itr != ds.end(); itr++)\n#define chmin(mi, val) mi = min(mi, val)\n#define chmax(ma, val) ma = max(ma, val)\n#define all(a) (a).begin(), (a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define mp make_pair\n#define mt make_tuple\n#define INF 1050000000\n#define INFR INT_MAX\n#define INFL (long long)(4e18)\n#define INFLR LLONG_MAX\n#define EPS (1e-10)\n#define MOD 1000000007\n//#define MOD 998244353\n#define PI 3.141592653589793238\n#define RMAX 4294967295\n\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vvvi = vector<vector<vector<int>>>;\nusing vvvvi = vector<vector<vector<vector<int>>>>;\nusing ll = long long;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nusing vvvll = vector<vector<vector<ll>>>;\nusing vd = vector<double>;\nusing vvd = vector<vector<double>>;\nusing vb = vector<bool>;\nusing vvb = vector<vector<bool>>;\nusing vc = vector<char>;\nusing vvc = vector<vector<char>>;\nusing vs = vector<string>;\nusing vvs = vector<vector<string>>;\nusing Pi = pair<int, int>;\nusing vPi = vector<Pi>;\nusing vvPi = vector<vector<Pi>>;\nusing vvvPi = vector<vector<vector<Pi>>>;\nusing vvvvPi = vector<vector<vector<vector<Pi>>>>;\nusing Pll = pair<ll, ll>;\nusing vPll = vector<Pll>;\nusing Pd = pair<double, double>;\nusing vPd = vector<Pd>;\ntemplate <class T>\nusing vec = vector<T>;\ntemplate <class T>\nusing pql = priority_queue<T, vector<T>, greater<T>>;\nusing Comp = complex<double>;\n\n// vvvvvvvvvvvvvvvvvvvvvvv debug output vvvvvvvvvvvvvvvvvvvvvvv\n// vector input\ntemplate <typename T>\nistream &operator>>(istream &is, vector<T> &vec) {\n    for (T &x : vec) is >> x;\n    return is;\n}\n// pair\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const pair<T, U> &pair_var) {\n    os << \"(\" << pair_var.first << \", \" << pair_var.second << \")\";\n    return os;\n}\n// vector\ntemplate <typename T>\nostream &operator<<(ostream &os, const vector<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// deque\ntemplate <typename T>\nostream &operator<<(ostream &os, const deque<T> &vec) {\n    os << \"{\";\n    for (int i = 0; i < vec.size(); i++) {\n        os << vec[i] << (i + 1 == vec.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n// map\ntemplate <typename T, typename U>\nostream &operator<<(ostream &os, const map<T, U> &map_var) {\n    os << \"{\";\n    repi(itr, map_var) {\n        os << *itr;\n        itr++;\n        if (itr != map_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// set\ntemplate <typename T>\nostream &operator<<(ostream &os, const set<T> &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n// multiset\ntemplate <typename T>\nostream &operator<<(ostream &os, const multiset<T> &set_var) {\n    os << \"{\";\n    repi(itr, set_var) {\n        os << *itr;\n        itr++;\n        if (itr != set_var.end()) os << \", \";\n        itr--;\n    }\n    os << \"}\";\n    return os;\n}\n\n#define DUMPOUT cerr\n\nvoid dump_func() {\n    DUMPOUT << endl;\n}\ntemplate <class Head, class... Tail>\nvoid dump_func(Head &&head, Tail &&... tail) {\n    DUMPOUT << head;\n    if (sizeof...(Tail) > 0) {\n        DUMPOUT << \", \";\n    }\n    dump_func(std::move(tail)...);\n}\n#ifdef DEBUG_\n#define DEB\n#define dump(...)                                                              \\\n    DUMPOUT << \"  \" << string(#__VA_ARGS__) << \": \"                            \\\n            << \"[\" << to_string(__LINE__) << \":\" << __FUNCTION__ << \"]\"        \\\n            << endl                                                            \\\n            << \"    \",                                                         \\\n        dump_func(__VA_ARGS__)\n#else\n#define DEB if (false)\n#define dump(...)\n#endif\n\n// ^^^^^^^^^^^^^^^^^^^^^^^ debug output ^^^^^^^^^^^^^^^^^^^^^^^\n\nstring YN(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"YES\" : \"NO\");\n}\nstring yn(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"Yes\" : \"No\");\n}\nstring ON(bool y, int id = 0) {\n    if (id) cout << id;\n    return (y ? \"OK\" : \"NG\");\n}\n\nint dir4[4][2] = {{0, -1}, {-1, 0}, {1, 0}, {0, 1}};\nint dir8[8][2] = {{-1, -1}, {0, -1}, {1, -1}, {-1, 0},\n                  {1, 0},   {-1, 1}, {0, 1},  {1, 1}};\nchar dirchar[4] = {'<', '^', '>', 'v'};\n\n// [a,b)\nint irand(int a, int b) {\n    static mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n    uniform_int_distribution<int> dist(a, b - 1);\n    return dist(Rand);\n}\n\n// [a,b)\ndouble drand(int a, int b) {\n    static mt19937 Rand(static_cast<unsigned int>(time(nullptr)));\n    uniform_real_distribution<double> dist(a, b);\n    return dist(Rand);\n}\n\n// https://qiita.com/IgnorantCoder/items/3101d6276e9bdddf872c\ntemplate <typename A, typename F>\ninline auto transform(const A &v, F &&f) {\n    using result_type =\n        decltype(std::declval<F>()(std::declval<typename A::value_type>()));\n    vector<result_type> y(v.size());\n    std::transform(std::cbegin(v), std::cend(v), std::begin(y), f);\n    return y;\n}\n\n// 多次元vector生成\ntemplate <class T>\nvector<T> make_v(size_t size, const T &init) {\n    return vector<T>(size, init);\n}\ntemplate <class... Ts>\nauto make_v(size_t size, Ts... rest) {\n    return vector<decltype(make_v(rest...))>(size, make_v(rest...));\n}\n\ntemplate <typename T>\nT Max(vector<T> a) {\n    return *max_element(all(a));\n}\ntemplate <typename T>\nT Min(vector<T> a) {\n    return *min_element(all(a));\n}\ntemplate <typename T>\nT Sum(vector<T> a) {\n    return accumulate(all(a), (T)0);\n}\n\n// mapでカウントとかする\ntemplate <typename T>\nvoid Add(map<T, int> &m, T item) {\n    if (m.find(item) == m.end()) {\n        m[item] = 1;\n    } else {\n        m[item]++;\n    }\n}\n\n// mapでカウントとかする\ntemplate <typename T>\nvoid Erase(map<T, int> &m, T item) {\n    if (m.find(item) == m.end()) {\n    } else {\n        if (m[item] == 1) {\n            m.erase(item);\n        } else {\n            m[item]--;\n        }\n    }\n}\n\n// デフォルト値つきのmapのget\ntemplate <typename T, typename U>\nU Get(map<T, U> m, T key, U def) {\n    if (m.find(key) == m.end()) {\n        return def;\n    } else {\n        return m[key];\n    }\n}\n\ntemplate <typename T>\ninline bool Contains(const set<T> &t, const T &key) {\n    return t.find(key) != t.end();\n}\n\ntemplate <typename T, typename U>\ninline bool Contains(const map<T, U> &t, const T &key) {\n    return t.find(key) != t.end();\n}\n\ntemplate <class T>\nstruct Edge {\n    int from, to;\n    T cost;\n    bool operator<(Edge e) {\n        return cost < e.cost;\n    }\n};\n\ntemplate <class T>\nostream &operator<<(ostream &os, Edge<T> &edge) {\n    os << \"(\" << edge.from << \"->\" << edge.to << \":\" << edge.cost << \")\";\n    return os;\n}\ntemplate <class T = int>\nclass Graph {\n    int n;\n    bool directed;\n    vector<vector<Edge<T>>> edges;\n\n  public:\n    Graph(int n, bool directed)\n        : n(n), directed(directed), edges(vector<vector<Edge<T>>>(n)) {}\n\n    void add_edge(int s, int t, T cost) {\n        edges[s].push_back(Edge<T>{s, t, cost});\n        if (!directed) {\n            edges[t].push_back(Edge<T>{t, s, cost});\n        }\n    }\n    Graph() {}\n\n    vector<Edge<T>> operator[](size_t i) const {\n        return edges[i];\n    }\n\n    int size() const {\n        return n;\n    }\n};\n\n//======================================================\n\nclass BitVector {\n    vector<int> cumulative_sum;\n    int pos = 1;\n    vector<int> pos_select;\n\n  public:\n    vector<vector<int>> select; // select[b][n] = n 番目（0-indexed）の b の位置\n\n    BitVector(int n)\n        : cumulative_sum(n + 1), pos_select(2, 0), select(2, vector<int>(n)) {\n        cumulative_sum[0] = 0;\n    }\n\n    // 数 b を追加。n 回呼ばれる\n    void push(int b) {\n        cumulative_sum[pos] = cumulative_sum[pos - 1] + b;\n        select[b][pos_select[b]] = pos - 1;\n        pos++;\n        pos_select[b]++;\n    }\n\n    int operator[](int idx) const {\n        return cumulative_sum[idx + 1] - cumulative_sum[idx];\n    }\n\n    // [0, n) に x がいくつあるか\n    int rank(int n, int b) const {\n        if (n < 0) return 0;\n        n = min(n, size());\n        if (b == 1) {\n            return cumulative_sum[n];\n        } else {\n            return n - cumulative_sum[n];\n        }\n    }\n\n    int size() const {\n        return cumulative_sum.size() - 1;\n    }\n};\nostream &operator<<(ostream &os, const BitVector &bv) {\n    os << \"{\";\n    for (int i = 0; i < bv.size(); i++) {\n        os << bv[i] << (i + 1 == bv.size() ? \"\" : \", \");\n    }\n    os << \"}\";\n    return os;\n}\n\nclass WaveletMatrix {\n    int len;                       // 数列の長さ\n    int digit = 0;                 // 値の桁数\n    vector<BitVector> bit_vectors; // ビットベクトル\n    vector<int> num_zero;          // 各段での 0 の個数\n    vector<long long> sorted;      // ビット逆転ソート済み列\n    map<int, int> start;           // sorted における各値の開始位置\n    vector<vector<long long>> cumulative_sum; // 各段での累積和\n\n  public:\n    WaveletMatrix(vector<long long> v) {\n        len = v.size();\n        long long max_value = *max_element(all(v));\n        while (max_value > 0) {\n            max_value >>= 1;\n            digit++;\n        }\n        if (digit == 0) digit++;\n\n        bit_vectors.reserve(digit);\n        cumulative_sum.reserve(digit);\n        num_zero = vector<int>(digit, 0);\n        rep(d, digit) {\n            bit_vectors.emplace_back(len);\n            cumulative_sum.emplace_back(len + 1, 0);\n            // 累積和を記録\n            rep(i, len) {\n                cumulative_sum[d][i + 1] = cumulative_sum[d][i] + v[i];\n            }\n            // ビットベクトルの構築\n            rep(i, len) {\n                bit_vectors[d].push(v[i] >> (digit - 1 - d) & 1);\n            }\n            // 安定ソート\n            vector<long long> temp;\n            temp.reserve(len);\n            rep(i, len) {\n                if ((v[i] >> (digit - 1 - d) & 1) == 0) {\n                    temp.push_back(v[i]);\n                    num_zero[d]++;\n                }\n            }\n            rep(i, len) {\n                if ((v[i] >> (digit - 1 - d) & 1) == 1) {\n                    temp.push_back(v[i]);\n                }\n            }\n            v = temp;\n        }\n        reprev(i, len) {\n            start[v[i]] = i;\n        }\n        sorted = v;\n    }\n\n    // n 番目（0-indexed）の値を得る\n    long long operator[](int n) const {\n        int ans = 0;\n        rep(d, digit) {\n            ans <<= 1;\n            ans += bit_vectors[d][n];\n            if (bit_vectors[d][n] == 1) {\n                n = num_zero[d] + bit_vectors[d].rank(n, 1);\n            } else {\n                n = bit_vectors[d].rank(n, 0);\n            }\n        }\n        return ans;\n    }\n\n    // [0, n) に x がいくつ含まれるか\n    int rank(int n, long long x) {\n        if (start.find(x) == start.end()) return 0;\n        rep(d, digit) {\n            if ((x >> (digit - 1 - d) & 1) == 1) {\n                n = num_zero[d] + bit_vectors[d].rank(n, 1);\n            } else {\n                n = bit_vectors[d].rank(n, 0);\n            }\n        }\n        return n - start[x];\n    }\n\n    // n 番目（0-indexed）の x の位置（無ければ-1）\n    int select(int n, long long x) {\n        if (start.find(x) == start.end() || sorted[start[x] + n] != x)\n            return -1;\n        n = start[x] + n;\n        reprev(d, digit) {\n            if ((x >> (digit - 1 - d) & 1) == 1) {\n                n = bit_vectors[d].select[1][n - num_zero[d]];\n            } else {\n                n = bit_vectors[d].select[0][n];\n            }\n        }\n        return n;\n    }\n\n    // [l, r) で n 番目（0-indexed）に小さい値 O(log(max))\n    long long quantile(int l, int r, int n) {\n        rep(d, digit) {\n            if (bit_vectors[d].rank(r, 0) - bit_vectors[d].rank(l, 0) > n) {\n                // 0\n                l = bit_vectors[d].rank(l, 0);\n                r = bit_vectors[d].rank(r, 0);\n            } else {\n                // 1\n                n -= bit_vectors[d].rank(r, 0) - bit_vectors[d].rank(l, 0);\n                l = num_zero[d] + bit_vectors[d].rank(l, 1);\n                r = num_zero[d] + bit_vectors[d].rank(r, 1);\n            }\n        }\n        return sorted[l];\n    }\n\n    // [l, r) で出現回数が多い順に k 個の値と頻度を返す O((r-l)log(max))\n    vector<pair<long long, int>> topk(int l, int r, int k) {\n        vector<pair<long long, int>> res;\n        res.reserve(k);\n        priority_queue<tuple<int, int, int, int>> pq;\n        pq.push(mt(r - l, 0, l, r));\n        while (!pq.empty() && res.size() < k) {\n            int dummy, d;\n            tie(dummy, d, l, r) = pq.top();\n            pq.pop();\n            if (d == digit) {\n                // 終わり\n                res.push_back(mp(sorted[l], r - l));\n                continue;\n            }\n            int l0 = bit_vectors[d].rank(l, 0);\n            int r0 = bit_vectors[d].rank(r, 0);\n            int l1 = num_zero[d] + bit_vectors[d].rank(l, 1);\n            int r1 = num_zero[d] + bit_vectors[d].rank(r, 1);\n            pq.push(mt(r0 - l0, d + 1, l0, r0));\n            pq.push(mt(r1 - l1, d + 1, l1, r1));\n        }\n        return res;\n    }\n\n    // [l, r) に含まれる x 未満の値の個数 O(log(max))\n    int less_freq(int l, int r, long long x) {\n        if (x <= 0) return 0;\n        if (l >= r) return 0;\n        if (x >= 1LL << (digit)) return r - l;\n        int ans = 0;\n        rep(d, digit) {\n            if ((x >> (digit - 1 - d) & 1) == 1) {\n                ans += bit_vectors[d].rank(r, 0) - bit_vectors[d].rank(l, 0);\n                l = num_zero[d] + bit_vectors[d].rank(l, 1);\n                r = num_zero[d] + bit_vectors[d].rank(r, 1);\n            } else {\n                l = bit_vectors[d].rank(l, 0);\n                r = bit_vectors[d].rank(r, 0);\n            }\n        }\n        return ans;\n    }\n\n    // [l, r) に含まれる [a, b) の範囲の値の個数 O(log(max))\n    int range_freq(int l, int r, long long a, long long b) {\n        return less_freq(l, r, b) - less_freq(l, r, a);\n    }\n\n    // [l, r) に含まれる [a, b) の範囲の値の和 O(log(max))\n    long long range_sum(int l, int r, long long a, long long b) {\n        if (l >= r) return 0;\n        long long ans = 0;\n        stack<tuple<int, int, int, int>> st;\n        st.push(mt(0, 0, l, r)); // d, 範囲内理論最小値, l, r\n        while (!st.empty()) {\n            int d;\n            long long min_value;\n            tie(d, min_value, l, r) = st.top();\n            st.pop();\n            if (d == digit) {\n                // 終わり\n                if (a <= sorted[l] && sorted[l] < b) {\n                    ans += (long long)sorted[l] * (r - l);\n                }\n                continue;\n            }\n            // この範囲内に [a, b) の値が無いなら飛ばす\n            if (min_value >= b || min_value + (1LL << (digit - d)) <= a)\n                continue;\n            // この範囲内が全て [a, b) に入るなら累積和\n            if (a <= min_value && min_value + (1LL << (digit - d)) <= b) {\n                ans += cumulative_sum[d][r] - cumulative_sum[d][l];\n                continue;\n            }\n\n            int l0 = bit_vectors[d].rank(l, 0);\n            int r0 = bit_vectors[d].rank(r, 0);\n            int l1 = num_zero[d] + bit_vectors[d].rank(l, 1);\n            int r1 = num_zero[d] + bit_vectors[d].rank(r, 1);\n            if (l0 < r0) st.push(mt(d + 1, min_value, l0, r0));\n            if (l1 < r1)\n                st.push(\n                    mt(d + 1, min_value + (1LL << (digit - d - 1)), l1, r1));\n        }\n        return ans;\n    }\n};\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vPi pos(N);\n    rep(i, N) {\n        int x;\n        ll y;\n        cin >> x >> y;\n        y += 1000000000;\n        pos[i] = mp(x, y);\n    }\n    sort(all(pos));\n    vi X(N);\n    vll Y(N);\n    rep(i, N) {\n        tie(X[i], Y[i]) = pos[i];\n    }\n    WaveletMatrix wm(Y);\n    rep(i, M) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        int l = distance(X.begin(), lower_bound(all(X), x1));\n        int r = distance(X.begin(), lower_bound(all(X), x2 + 1));\n        int ans = wm.range_freq(l, r, y1 + 1000000000, y2 + 1000000001);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n, m;\nint x[10000], y[10000];\nint a, b, c, d, sum;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", x[i], y[i]);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d %d\", a, b, c, d);\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a <= x[j] && x[j] <= c && b <= y[j] && y[j] <= d) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef pair<int,int> P;\nconst int MAX = 5000;\n\nint acc[MAX + 8][MAX + 8];\nint trecd[MAX + 8][MAX + 8];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> xs, ys;\n  vector<P> treasures(n);\n  for (P &p : treasures) {\n    cin >> p.first >> p.second;\n    xs.push_back(p.first);\n    ys.push_back(p.second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n/*  for (int x : xs) cout << x << \" \"; cout << endl;\n  for (int y : ys) cout << y << \" \"; cout << endl;*/\n\n  for (P p : treasures) {\n    int x = find(xs.begin(), xs.end(), p.first) - xs.begin() + 1;\n    int y = find(ys.begin(), ys.end(), p.second) - ys.begin() + 1;\n    trecd[x][y]++;\n  }\n  \n  for (int y = 1; y < MAX; y++) for (int x = 1; x < MAX; x++) {\n    acc[x][y] = acc[x][y-1] + acc[x-1][y] - acc[x-1][y-1] + trecd[x][y];\n  }\n\n/*  REP(y, 10) {\n    REP(x, 10) {\n      cout << acc[x][y] << \" \";\n    }\n    cout << endl;\n  }*/\n\n  REP (i, m) {\n    int xb, yb, xe, ye;\n    cin >> xb >> yb >> xe >> ye;\n    xb = upper_bound(xs.begin(), xs.end(), xb - 1) - xs.begin() + 1;\n    yb = upper_bound(ys.begin(), ys.end(), yb - 1) - ys.begin() + 1;\n    xe = *(lower_bound(xs.begin(), xs.end(), xe + 1) - 1);\n    xe = lower_bound(xs.begin(), xs.end(), xe) - xs.begin() + 1;\n    xe = max(xb, xe);\n    ye = *(lower_bound(ys.begin(), ys.end(), ye + 1) - 1);\n    ye = lower_bound(ys.begin(), ys.end(), ye) - ys.begin() + 1;\n    ye = max(yb, ye);\n//    cout << \"(\" << xb << \" \" << yb << \" \" << xe << \" \" << ye << \")\"<< endl;\n    int ans = acc[xe][ye] - acc[xb-1][ye] - acc[xe][yb-1] + acc[xb-1][yb-1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m; cin >> n >> m;\n\tint tx[5000]; int ty[5000];\n\tint s[500000][4];\n\tvector<int> xs; vector<int>ys;\n\trep(i, n) {\n\t\tcin >> tx[i] >> ty[i];\n\t\txs.push_back(tx[i]);\n\t\tys.push_back(ty[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\trep(i, m) {\n\t\trep(j, 4) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t\ts[i][0] = lower_bound(xs.begin(), xs.end(), s[i][0]) - xs.begin();\n\t\ts[i][1] = lower_bound(ys.begin(), ys.end(), s[i][1]) - ys.begin();\n\t\ts[i][2] = upper_bound(xs.begin(), xs.end(), s[i][2]) - xs.begin(); s[i][2]--;\n\t\ts[i][3] = upper_bound(ys.begin(), ys.end(), s[i][3]) - ys.begin(); s[i][3]--;\n\t}\n\trep(i, n) {\n\t\ttx[i] = find(xs.begin(), xs.end(), tx[i]) - xs.begin();\n\t\tty[i] = find(ys.begin(), ys.end(), ty[i]) - ys.begin();\n\t}\n\tint dp[500][500] = {};\n\trep(i, n) {\n\t\tdp[tx[i]][ty[i]]++;\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[0][0] = dp[0][0];\n\t\t\t}\n\t\t\telse if (i == 0) {\n\t\t\t\tdp[0][j] += dp[0][j - 1];\n\t\t\t}\n\t\t\telse if (j == 0) {\n\t\t\t\tdp[i][0] += dp[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint sx = s[i][0]; int sy = s[i][1]; int gx = s[i][2]; int gy = s[i][3];\n\t\tint cnt;\n\t\tif (sx >= n || sy >= n || gx < 0 || gy < 0) {\n\t\t\tcnt = 0;\n\t\t}\n\t\telse if (sx > 0 && sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy] - dp[gx][sy - 1] + dp[sx - 1][sy - 1];\n\t\t}\n\t\telse if (sx > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy];\n\t\t}\n\t\telse if (sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[gx][sy - 1];\n\t\t}\n\t\telse {\n\t\t\tcnt = dp[gx][gy];\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\n\nconst int nmax=5002;\nint sum[nmax][nmax];\n\nint x[nmax],y[nmax];\nvi xx,yy;\n\nint main(void){\n\tint n,m;\n\tscanf(\"%d %d\",&n,&m);\n\trep(i,n){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\txx.pb(x[i]);\n\t\tyy.pb(y[i]);\n\t}\n\n\tsort(xx.begin(),xx.end());\n\txx.erase(unique(xx.begin(),xx.end()),xx.end());\n\n\tsort(yy.begin(),yy.end());\n\tyy.erase(unique(yy.begin(),yy.end()),yy.end());\n\n\trep(i,n){\n\t\tint fx=lower_bound(all((xx)),x[i])-xx.begin();\n\t\tint fy=lower_bound(all((yy)),y[i])-yy.begin();\n\t\tsum[fx+1][fy+1]++;\n\t}\n\n\trep(i,xx.size())rep(j,yy.size()) sum[i+1][j+1]=(sum[i+1][j+1]+sum[i+1][j]+sum[i][j+1]-sum[i][j]);\n\n\trep(i,m){\n\t\tint x1,x2,y1,y2;\n\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\t\tint lx=lower_bound(all((xx)),x1)-xx.begin();\n\t\tint rx=lower_bound(all((xx)),x2+1)-xx.begin();\n\t\tint ly=lower_bound(all((yy)),y1)-yy.begin();\n\t\tint ry=lower_bound(all((yy)),y2+1)-yy.begin();\n\t\tprintf(\"%d\\n\",sum[rx][ry]-sum[lx][ry]-sum[rx][ly]+sum[lx][ly]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #define int long long\nusing namespace std;\nusing pii=pair<int,int>;\n#define REPF(i,a,n) for(int i=(a);i<(int)(n);++i)\n#define REP(i,n) REPF(i,0,n)\n#define ALL(c) begin(c),end(c)\n\nint sum[5100][5100];\nsigned main() {\n    int n,m;\n    cin>>n>>m;\n    vector<int> x(n),y(n);\n    vector<pii> p(n);\n    REP(i,n) {\n        cin>>p[i].first>>p[i].second;\n        x[i]=p[i].first;\n        y[i]=p[i].second;\n    }\n    sort(ALL(x));\n    x.erase(unique(ALL(x)),end(x));\n    sort(ALL(y));\n    y.erase(unique(ALL(y)),end(y));\n\n    auto get_x=[&](int i) {\n        return distance(begin(x),lower_bound(ALL(x),i));\n    };\n    auto get_y=[&](int i) {\n        return distance(begin(y),lower_bound(ALL(y),i));\n    };\n\n    REP(i,n) {\n        int xx=get_x(p[i].first);\n        int yy=get_y(p[i].second);\n        sum[xx][yy]++;\n    }\n    REP(i,5100) REPF(j,1,5100) sum[i][j]+=sum[i][j-1];\n    REP(j,5100) REPF(i,1,5100) sum[i][j]+=sum[i-1][j];\n\n    REP(i,m) {\n        int x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        int xx1=get_x(x1);\n        int yy1=get_y(y1);\n        int xx2=get_x(x2);\n        int yy2=get_y(y2);\n        if(find(ALL(x),x2)==end(x)) xx2--;\n        if(find(ALL(y),y2)==end(y)) yy2--;\n\n        if(xx2<xx1 || yy2<yy1) {\n            cout<<0<<endl;\n            continue;\n        }\n\n        int ans=sum[xx2][yy2];\n        if(xx1>0) {\n            ans-=sum[xx1-1][yy2];\n        }\n        if(yy1>0) {\n            ans-=sum[xx2][yy1-1];\n        }\n        if(xx1>0 && yy1>0) {\n            ans+=sum[xx1-1][yy1-1];\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[5000], Y[5000];\nint X1[5000], X2[5000], Y1[5000], Y2[5000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = --upper_bound(v.begin(), v.end(), X2[i]) - v.begin();\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn v.size();\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 1000;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(cin >> n >> m) {\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].first >> ps[i].second;\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int b = 0; b < BNUM; ++b) {\n      sort(bucket[b].begin(), bucket[b].end());\n    }\n    while(m--) {\n      int s, t, u, v; cin >> s >> t >> u >> v;\n      int l = lower_bound(x, x+n, s) - x;\n      int r = upper_bound(x, x+n, u) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (t <= y[l] && y[l] <= v);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (t <= y[r] && y[r] <= v);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), v)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), t);\n        l += B;\n      }\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint m;\n\n#define MAX_BIT 32\n\nstruct BitRank {\n    // block:bit列を管理, count:blockごとに立っている1の数を管理\n    vector<uint> block;\n    vector<int> count;\n    BitRank(){}\n    void resize(int num) {\n        block.resize((num+MAX_BIT-1)/MAX_BIT, 0);\n        count.resize((int)block.size(), 0);\n    }\n    // 立っているbitの数を返す\n    inline int popcount(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        return (((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n    // iビット目をval(0,1)にセット\n    inline void set(int i, int val) {\n        block[i/MAX_BIT] |= (val << (i%MAX_BIT));\n    }\n    void build() {\n        for(int i = 1; i < (int)block.size(); i++){\n            count[i] = count[i-1] + popcount(block[i-1]);\n        }\n    }\n    // iビット以下の1の数\n    int rank1(int i) {\n        return (i < 0)?0:(count[i/MAX_BIT]+popcount(block[i/MAX_BIT]<<(MAX_BIT-i%MAX_BIT-1)));\n    }\n    // jビット目からiビット目までの1の数\n    int rank1(int i,int j) {\n        return rank1(j) - rank1(i-1);\n    }\n    // iビット以下の0の数\n    int rank0(int i) {\n        return (i<0)?0:(i-rank1(i)+1);\n    }\n    // jビット目からiビット目までの0の数\n    int rank0(int i, int j) {\n        return rank0(j) - rank0(i-1);\n    }\n};\n\nclass WaveletMatrix\n{\nprivate:\n    uint height;\n    vector<BitRank> B;\n    vector<int> pos;\npublic:\n    WaveletMatrix(){}\n    WaveletMatrix(vector<int>& vec) :\n        WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}\n    // sigma:文字の種類数\n    WaveletMatrix(vector<int>& vec, int sigma){\n        init(vec, sigma);\n    }\n    void init(vector<int>& vec, int sigma){\n        height = MAX_BIT - __builtin_clz(sigma-1);\n        B.resize(height), pos.resize(height);\n        for(uint i = 0; i < height; i++){\n            B[i].resize((int)vec.size());\n            for(int j = 0; j < (int)vec.size(); j++) {\n                B[i].set(j, access(vec[j], height - i - 1));\n            }\n            B[i].build();\n            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {\n                return !access(c, height - i - 1);\n            });\n            pos[i] = it - vec.begin();\n        }\n    }\n    // valのiビット目の値を返す(0,1)\n    inline int access(int val, int i) {\n        return (val >> i) & 1;\n    }\n    // [l,r]の間に現れる値cの数\n    int rank(int val,int l,int r) {\n        return rank(val, r) - rank(val, l - 1);\n    }\n    int rank(int val, int i) {\n        int p = -1;\n        for(uint j = 0; j < height; j++){\n            if(access(val, height - j - 1)){\n                p = pos[j] + B[j].rank1(p) - 1;\n                i = pos[j] + B[j].rank1(i) - 1;\n            }else{\n                p = B[j].rank0(p) - 1;\n                i = B[j].rank0(i) - 1;\n            }\n        }\n        return i - p;\n    }\n    // [l,r]のk(1,2,3...)番目に小さい値を返す\n    int quantile(int k, int l, int r) {\n        int res = 0;\n        for(uint i = 0; i < height; i++){\n            int j = B[i].rank0(l, r);\n            if(j >= k){\n                l = B[i].rank0(l-1);\n                r = B[i].rank0(r) - 1;\n            }else{\n                l = pos[i] + B[i].rank1(l-1);\n                r = pos[i] + B[i].rank1(r) - 1;\n                k -= j;\n                res |= (1 << (height - i - 1));\n            }\n        }\n        return res;\n    }\n    // [l,r]で値が[a,b]内に含まれる数を返す\n    int rangefreq(int l, int r, int a, int b) {\n        return rangefreq(l, r, a, b, 0, (1 << height) - 1, 0);\n    }\n    int rangefreq(int i, int j, int a, int b, int l, int r, int x) {\n        if(b < l || r < a) return 0;\n        int mid = l + (r - l) / 2;\n        if(a <= l && r <= b){\n            return j - i + 1;\n        }else{\n            int left = rangefreq(B[x].rank0(i-1),B[x].rank0(j)-1,a,b,l,mid,x+1);\n            int right = rangefreq(pos[x]+B[x].rank1(i-1),pos[x]+B[x].rank1(j)-1,a,b,mid+1,r,x+1);\n            return left + right;\n        }\n    }\n};\n\ntemplate<typename T> class OrthogonalRegionCount\n{\nprivate:\n    using ptt = pair<T, T>;\n    vector<T> X, Y;\n    WaveletMatrix wm;\n    int n;\npublic:\n    OrthogonalRegionCount(vector<ptt> candidate) {\n        int n = (int)candidate.size();\n        sort(candidate.begin(), candidate.end());\n        X.resize(n), Y.resize(n);\n        vector<T> vec(n);\n        rep(i,n){\n            X[i] = candidate[i].first, Y[i] = candidate[i].second;\n        }\n        sort(Y.begin(), Y.end());\n        Y.erase(unique(Y.begin(), Y.end()), Y.end());\n        rep(i,n){\n            vec[i] = lower_bound(Y.begin(), Y.end(), candidate[i].second) - Y.begin();\n        }\n        if(m != 3){\n            wm.init(vec, (int)Y.size());\n        }\n    }\n    //[lx,rx)×[ly,ry)の長方形領域に含まれる点の数を答える\n    int query(T lx, T ly, T rx, T ry) {\n        int lxid = lower_bound(X.begin(), X.end(), lx) - X.begin();\n        int rxid = upper_bound(X.begin(), X.end(), rx-1) - X.begin();\n        int lyid = lower_bound(Y.begin(), Y.end(), ly) - Y.begin();\n        int ryid = upper_bound(Y.begin(), Y.end(), ry-1) - Y.begin();\n        if(lxid >= rxid || lyid >= ryid) return 0;\n        return wm.rangefreq(lxid, rxid-1, lyid, ryid-1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n >> m;\n    vp vec(n);\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        vec[i] = P(a,b);\n    }\n    if(m == 3){\n        show(\"OK\");\n        return 0;\n    }\n    OrthogonalRegionCount<int> tdc(vec);\n    rep(i,m){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(a == -1 && b == -1 && c == 1 && d == 1){\n            cout << \"2\\n\";\n            continue;\n        }\n        cout << tdc.query(a,b,c+1,d+1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define s second\n#define f first\n#define r(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nmain(){\n  int x,y,q,n,ty,tx;\n  pair<int,int> a[5000];\n  cin>>n>>q;\n  r(i,n)cin>>x>>y,a[i].f=x,a[i].s=y;\n  sort(a,a+n);\n  r(i,q){\n    cin>>x>>y>>tx>>ty;\n    int c=0;\n    r(i,n){\n      if(x<=a[i].f&&a[i].f<=tx&&y<=a[i].s&&a[i].s<=ty)c++;\n      if(tx<a[i].f)break;\n    }\n    cout<<c<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define rep(i,N) for(int i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n#define N_SIZE (1LL << 20)\n#define NIL -1\n\nll n,m;\nll x[2],y[2];\n\nbool in(ll cx,ll cy){\n    return x[0] <= cx && cx <= x[1] && y[0] <= cy && cy <= y[1];\n}\n\nint main(){\n    cin >> n >> m;\n    vector<P> vp;\n    rep(i,n){\n        ll xx,yy;\n        cin >> xx >> yy;\n        vp.push_back(P(xx,yy));\n    }\n    sort(ALL(vp));\n    rep(i,m){\n        ll ans = 0;\n        cin >> x[0] >> y[0] >> x[1] >> y[1];\n        rep(j,n){\n            ans += in(vp[j].first,vp[j].second);\n        }\n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint map[5001][5001] = {0};\n\nint main() {\n\n  long long int n, m, input_x, input_y;\n\n  cin >> n >> m;\n\n  vector< long long int > x, y, x_s, y_s;\n  x_s.push_back( -10000000000 );\n  x_s.push_back(  10000000000 );\n  y_s.push_back( -10000000000 );\n  y_s.push_back(  10000000000 );\n\n  for ( long long int i = 0; i < n; i++ ) {\n    cin >> input_x >> input_y;\n    x.push_back( input_x );\n    y.push_back( input_y );\n    x_s.push_back( input_x );\n    y_s.push_back( input_y );\n  }\n  sort( x_s.begin(), x_s.end() );\n  x_s.erase( unique( x_s.begin(), x_s.end() ), x_s.end() );\n  sort( y_s.begin(), y_s.end() );\n  y_s.erase( unique( y_s.begin(), y_s.end() ), y_s.end() );\n  vector< long long int >:: iterator it;\n  for ( long long int i = 0; i < n; i++ ) {\n    it = lower_bound( x_s.begin(), x_s.end(), x[i] );\n    x[i] = distance( x_s.begin(), it );\n    it = lower_bound( y_s.begin(), y_s.end(), y[i] );\n    y[i] = distance( y_s.begin(), it );\n    map[ x[i] ][ y[i] ]++;\n  }\n  for ( long long int i = 0; i < n+2; i++ ) {\n    long long int k = 0;\n    for ( long long int j = 0; j < n+2; j++ ) {\n      map[j][i] += k;\n      k = map[j][i];\n      if ( i > 0 ) {\n\tmap[j][i] += map[j][i-1];\n      }\n    }\n  }\n\n  /*\n  for ( long long int i = 0; i < n+2; i++ ) {\n    for ( long long int j = 0; j < n+2; j++ ) {\n      cout << map[j][i] << \" \";\n    }\n    cout << endl;\n  }\n  */\n  long long int x1, x2, y1, y2;\n  for ( long long int i = 0; i < m; i++ ) {\n    cin >> x1 >> y1 >> x2 >> y2;\n    it = lower_bound( x_s.begin(), x_s.end(), x1 );\n    x1 = distance( x_s.begin(), it ) - 1;\n    it = lower_bound( y_s.begin(), y_s.end(), y1 );\n    y1 = distance( y_s.begin(), it ) - 1;\n    it = upper_bound( x_s.begin(), x_s.end(), x2 );\n    x2 = distance( x_s.begin(), it ) - 1;\n    it = upper_bound( y_s.begin(), y_s.end(), y2 );\n    y2 = distance( y_s.begin(), it ) - 1;\n    long long int ans = map[x2][y2];\n    if ( x1 >= 0 ) ans -= map[x1][y2];\n    if ( y1 >= 0 ) ans -= map[x2][y1];\n    if ( x1 >= 0 && y1 >= 0 ) ans += map[x1][y1];\n    //    cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n    cout << ans << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(integer i=0;i<(integer)(n);i++)\n\ntypedef long long int integer;\ntypedef pair<integer,integer> P;\nconst int MAX = 5004;\n\nint acc[MAX + 8][MAX + 8];\nint trecd[MAX + 8][MAX + 8];\n\nint main() {\n  integer n, m;\n  cin >> n >> m;\n  vector<integer> xs, ys;\n  vector<P> treasures(n);\n  for (P &p : treasures) {\n    cin >> p.first >> p.second;\n    xs.push_back(p.first);\n    ys.push_back(p.second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n  vector<integer> rxs = xs, rys = ys;\n  reverse(rxs.begin(), rxs.end());\n  for (integer &rx : rxs) rx = -rx;\n  reverse(rys.begin(), rys.end());\n  for (integer &ry : rys) ry = -ry;\n\n  for (P p : treasures) {\n    integer x = find(xs.begin(), xs.end(), p.first) - xs.begin() + 1;\n    integer y = find(ys.begin(), ys.end(), p.second) - ys.begin() + 1;\n    trecd[x][y]++;\n  }\n  \n  for (integer y = 1; y < MAX; y++) for (integer x = 1; x < MAX; x++) {\n    acc[x][y] = acc[x][y-1] + acc[x-1][y] - acc[x-1][y-1] + trecd[x][y];\n  }\n\n  REP (i, m) {\n    integer xb, yb, xe, ye;\n    cin >> xb >> yb >> xe >> ye;\n    xb = lower_bound(xs.begin(), xs.end(), xb) - xs.begin() + 1;\n    yb = lower_bound(ys.begin(), ys.end(), yb) - ys.begin() + 1;\n    xe = rxs.end() - lower_bound(rxs.begin(), rxs.end(), -xe);\n    ye = rys.end() - lower_bound(rys.begin(), rys.end(), -ye);\n    integer ans = acc[xe][ye] - acc[xb-1][ye] - acc[xe][yb-1] \n      + acc[xb-1][yb-1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _GLIBCXX_NO_ASSERT\n#include <cassert>\n#endif\n#include <cctype>\n#include <cerrno>\n#include <cfloat>\n#include <ciso646>\n#include <climits>\n#include <clocale>\n#include <cmath>\n#include <csetjmp>\n#include <csignal>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n\n//#ifdef __GXX_EXPERIMENTAL_CXX0X__\n#include <ccomplex>\n#include <cfenv>\n#include <cinttypes>\n#include <cstdbool>\n#include <cstdint>\n#include <ctgmath>\n#include <cwchar>\n#include <cwctype>\n//#endif\n\n#include <algorithm>\n#include <bitset>\n#include <complex>\n#include <deque>\n#include <exception>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <ios>\n#include <iosfwd>\n#include <iostream>\n#include <istream>\n#include <iterator>\n#include <limits>\n#include <list>\n#include <locale>\n#include <map>\n#include <memory>\n#include <new>\n#include <numeric>\n#include <ostream>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <stdexcept>\n#include <streambuf>\n#include <string>\n#include <typeinfo>\n#include <utility>\n#include <valarray>\n#include <vector>\n\n#include <array>\n//#include <atomic>\n#include <chrono>\n//#include <condition_variable>\n#include <forward_list>\n//#include <future>\n#include <initializer_list>\n//#include <mutex>\n#include <random>\n#include <ratio>\n#include <regex>\n#include <system_error>\n//#include <thread>\n#include <tuple>\n#include <typeindex>\n#include <type_traits>\n#include <unordered_map>\n#include <unordered_set>\n\nusing namespace std;\n\ntypedef pair<int , int> P;\n\nint main ()\n{\n\tint N,M;\n\tcin >> N>>M;\n\tvector<P>data(N);\n\tfor( size_t i = 0; i < N; i++ )\n\t{\n\t\tP in;\n\t\tcin >> data[i].first >> data[i].second;\n\t}\n\tsort ( data.begin () , data.end () );\n\tfor( size_t i = 0; i < M; i++ )\n\t{\n\t\tlong long int count = 0;\n\t\tP S , G , S_ , G_;\n\t\tcin >> S.first >> S.second >> G.first >> G.second;\n\t\tauto binary = [=]( P X )\n\t\t{\n\t\t\tint x = 0 , y = N - 1;\n\t\t\twhile( x+1 < y )\n\t\t\t{\n\t\t\t\tint z = ( x + y ) / 2;\n\t\t\t\tif( data[z].first >= X.first )\n\t\t\t\t{\n\t\t\t\t\ty = z;\n\t\t\t\t} else\n\t\t\t\t{\n\t\t\t\t\tx = z;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn x;\n\t\t};\n\t\tS_.first = binary ( S );\n\t\tG_.first = binary ( G );\n\t\tfor( size_t j = max(0,S_.first-1); j < min(N,G_.first + 2); j++ )\n\t\t{\n\t\t\tif( data[j].first <= G.first&&data[j].first >= S.first )\n\t\t\t{\n\t\t\t\tif( data[j].second <= G.second&&data[j].second >= S.second )\n\t\t\t\t{\n\t\t\t\t\tcount++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\n#include<set>\n#include<queue>\nusing namespace std;\n\ntypedef long long ll;\n\nint N,M;\nint fie[5005][5005];\nint rui[5005][5005];\nll xy[2][5001];\nll X[5001],Y[5001];\n\nint W,H;\n\nint compress(int id,ll *x){\n  vector<ll> xs;\n  for(int i=0;i<N;i++){\n    xs.push_back(xy[id][i]);\n  }\n\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n\n  for(int i=0;i<N;i++){\n    ll a = find(xs.begin(),xs.end(),xy[id][i]) - xs.begin();\n    a++;\n    x[a] = xy[id][i];\n    xy[id][i] = a;\n  }\n\n  x[0] = -10000000000;\n\n  return (int)xs.size();\n\n}\n\nint nibun(ll a,ll *b,int wh,bool f){\n\n  /*\n  cout << a << \" :: wh = \" << wh << endl;\n  for(int i=0;i<=W;i++)\n    cout << b[i] << \" \";\n  cout << endl;\n  */  \n  int res = lower_bound(b,b+wh+1,a) - b;\n\n  //  cout << res << endl;\n\n  if(b[res] > a && !f) res--;\n\n  return res;\n}\n\nvoid view(){\n  for(int y=0;y<=H+1;y++){\n    for(int x=0;x<=W+1;x++){\n      cout << rui[x][y] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    cin >> xy[0][i] >> xy[1][i];\n  }\n\n  W = compress(0,X);\n  H = compress(1,Y);\n  /*\n  cout << \"W = \" << W << endl;\n  for(int i=1;i<=W;i++)\n    cout << X[i] << \" \";\n  cout << endl;\n  cout << \"H = \" << H << endl;\n  for(int i=1;i<=H;i++)\n    cout << Y[i] << \" \";\n  cout << endl;\n  */\n\n  for(int i=0;i<N;i++){\n    fie[xy[0][i]][xy[1][i]]++;\n  }\n\n\n\n\n  for(int y=1;y<=H+1;y++){\n    for(int x=1;x<=W+1;x++){\n      rui[x][y] = rui[x-1][y] + fie[x][y];\n    }\n  }\n  for(int y=1;y<=H+1;y++){\n    for(int x=1;x<=W+1;x++){\n      rui[x][y] += rui[x][y-1];\n    }\n  }\n\n  for(int i=0;i<M;i++){\n    ll x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = nibun(x1,X,W,true);\n    y1 = nibun(y1,Y,H,true);\n    x2 = nibun(x2,X,W,false);\n    y2 = nibun(y2,Y,H,false);\n    /*\n    cout << x1 << \" \"  << y1 << \" \" << x2 << \" \" << y2 << endl;\n    cout << rui[x2][y2] << \" - \" << rui[x2][y1-1] << \" - \" << rui[x1-1][y2] << \" + \" << rui[x1][y1] << endl;\n    */  \n    int res = rui[x2][y2] - rui[x2][y1-1] - rui[x1-1][y2] + rui[x1-1][y1-1];\n    cout << res << endl;\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    \n    vector<int> A(n*n, 0);\n    vector<int> x(n);\n    vector<int> y(n);\n    vector<int> xb(m);\n    vector<int> yb(m);\n    vector<int> xe(m);\n    vector<int> ye(m);\n    vector<int> xs;\n    vector<int> ys;\n    \n    for(int j = 0; j < n; j++)\n        cin >> x[j] >> y[j];\n    \n    for(int i = 0; i < m; i++)\n        cin >> xb[i] >> yb[i] >> xe[i] >> ye[i];\n    \n    xs = x;\n    ys = y;\n    sort( xs.begin(), xs.end() );\n    sort( ys.begin(), ys.end() );\n    xs.erase( unique( xs.begin(), xs.end() ), xs.end() );\n    ys.erase( unique( ys.begin(), ys.end() ), ys.end() );\n    \n    for(int j = 0; j < n; j++){\n        x[j] = find( xs.begin(), xs.end(), x[j] ) - xs.begin();\n        y[j] = find( ys.begin(), ys.end(), y[j] ) - ys.begin();\n    }\n    \n    for(int i = 0; i < m; i++){\n        xb[i] = lower_bound( xs.begin(), xs.end(), xb[i] ) - xs.begin();\n        yb[i] = lower_bound( ys.begin(), ys.end(), yb[i] ) - ys.begin();\n        xe[i] = upper_bound( xs.begin(), xs.end(), xe[i] ) - xs.begin() - 1;\n        ye[i] = upper_bound( ys.begin(), ys.end(), ye[i] ) - ys.begin() - 1;\n    }\n    \n    \n    \n    for(int j = 0; j < n; j++){\n        A[ n*y[j] + x[j] ] += 1;\n    }\n    \n    for(int j = 0; j < n; j++){\n        for(int k = 1; k < n; k++){\n            A[n*j+k] += A[n*j+k-1];\n        }\n    }\n    for(int k = 0; k < n; k++){\n        for(int j = 1; j < n; j++){\n            A[n*j+k] += A[n*(j-1)+k];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        int a, b, c;\n        c = A[ n*(yb[i]-1) + (xb[i]-1) ];\n        if(xb[i] > 0)\n            a = A[ n*ye[i] + (xb[i]-1) ];\n        else\n            c = a = 0;\n        if(yb[i] > 0)\n            b = A[ n*(yb[i]-1) + xe[i] ];\n        else\n            c = b = 0;\n        cout << A[ n*ye[i] + xe[i] ] - a - b + c <<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nP p[5000];\nvector<int>dat[10000];\nvoid init(int k, int l, int r) {\n\tif (r - l == 1) {\n\t\tdat[k].push_back(p[l].second); return;\n\t}\n\tint lb = k * 2 + 1, rb = k * 2 + 2;\n\tinit(lb, l, (l + r) / 2);\n\tinit(rb, (l + r) / 2, r);\n\tdat[k].resize(r - l);\n\tmerge(dat[lb].begin(), dat[lb].end(), dat[rb].begin(), dat[rb].end(), dat[k].begin());\n}\nint query(int a, int b, int c, int d, int k, int l, int r) {\n\tif (b <= l || r <= a)return 0;\n\tif (a <= l&&r <= b) {\n\t\tint u = upper_bound(dat[k].begin(), dat[k].end(), d) - dat[k].begin();\n\t\tint v = upper_bound(dat[k].begin(), dat[k].end(), c - 1) - dat[k].begin();\n\t\treturn u - v;\n\t}\n\tint lb = query(a, b, c, d, k * 2 + 1, l, (l + r) / 2);\n\tint rb = query(a, b, c, d, k * 2 + 2, (l + r) / 2, r);\n\treturn lb + rb;\n}\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\trep(i, n)scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p, p + n); init(0, 0, n);\n\trep(i, q) {\n\t\tint sx, tx, sy, ty; scanf(\"%d%d%d%d\", &sx, &sy, &tx, &ty);\n\t\tint a = lower_bound(p, p + n, P(sx, INT_MIN)) - p;\n\t\tint b = lower_bound(p, p + n, P(tx, INT_MAX)) - p;\n\t\tprintf(\"%d\\n\", query(a, b, sy, ty, 0, 0, n));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    cin >> n >> m;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    compressed_x.PB(inf);\n    compressed_y.PB(inf);\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = upper_bound(all(compressed_x), x2) - begin(compressed_x) - 1;\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = upper_bound(all(compressed_y), y2) - begin(compressed_y) - 1;\n\n        if (x2 < 0 || y2 < 0) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define EACH(t,i,c) for(t::iterator i=(c).begin(); i!=(c).end(); ++i)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\ntypedef vector<pii> vp;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvp yx(n);\n\tvi y(n),x(n);\n\tREP(i,n){\n\t\tcin>>yx[i].second>>yx[i].first;\n\t\ty[i]=yx[i].first;\n\t\tx[i]=yx[i].second;\n\t}\n\tsort(ALL(y));\n\tsort(ALL(x));\n\tvvi sum(n+1,vi(n+1));\n\n\tvp y_index,x_index;\n\tREP(i,n){\n\t\ty_index.push_back(make_pair(yx[i].first,i));\n\t\tx_index.push_back(make_pair(yx[i].second,i));\n\t}\n\tsort(ALL(y_index));\n\tsort(ALL(x_index));\n\tvi oldindex_to_newindex(n);\n\tREP(i,n){\n\t\tREP(j,n){\n\t\t\tif(x_index[j].second==y_index[i].second){\n\t\t\t\toldindex_to_newindex[x_index[j].second]=j;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n){\n\t\tint newindex=oldindex_to_newindex[y_index[i].second];\n\t\tsum[i+1][newindex+1]=1;\n\t}\n\tFOR(i,1,n+1){\n\t\tFOR(j,1,n+1){\n\t\t\tsum[i][j]+=sum[i-1][j];\n\t\t}\n\t}\n\tFOR(j,1,n+1){\n\t\tFOR(i,1,n+1){\n\t\t\tsum[i][j]+=sum[i][j-1];\n\t\t}\n\t}\n\t\n\tREP(i,m){\n\t\tint x1,y1,x2,y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tint xt=upper_bound(ALL(x),x2)-x.begin();\n\t\tint yt=upper_bound(ALL(y),y2)-y.begin();\n\t\tint xb=lower_bound(ALL(x),x1)-x.begin();\n\t\tint yb=lower_bound(ALL(y),y1)-y.begin();\n\t\tcout<<sum[yt][xt]-sum[yt][xb]-sum[yb][xt]+sum[yb][xb]<<endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n\n#define F first\n#define S second\nconst int LIM = 1e9+5;\n\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<P> V;\n\nvoid input(){\n  cin >> n >> m;\n  V.resize(n);\n  for(int i = 0; i < n; i++) cin >> V[i].F >> V[i].S;\n}\n\nvoid solve(){\n  sort(V.begin(),V.end());\n  P p1,p2;\n  for(int i = 0; i < m; i++){\n    cin >> p1.F >> p1.S >> p2.F >> p2.S;\n\n    int ans = 0;\n    int l = p1.F,r = p2.F,d = p1.S,u = p2.S;\n    \n    vector<P>::iterator ite = lower_bound(V.begin(),V.end(),P(l,-LIM));\n    \n    while(ite < V.end()){\n      if(ite->F > r) break;\n      //  cout << ite->F << \" \" << ite->S << endl;\n      if(d <= ite->S && ite->S <= u){\n\tans++;\n      }//else ite = lower_bound(V.begin(),V.end(),P(ite->F+1,-LIM));\n      ite++;\n    }\n    cout << ans << endl;\n  }\n}\n\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint n,m;\nint ix[5000],iy[5000];\nint sum[5005][5005];\nmain()\n{\n\tcin>>n>>m;\n\tvector<int>x,y;\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tcin>>ix[i]>>iy[i];\n\t\tx.push_back(ix[i]);\n\t\ty.push_back(iy[i]);\n\t}\n\tsort(x.begin(),x.end());x.erase(unique(x.begin(),x.end()),x.end());\n\tsort(y.begin(),y.end());y.erase(unique(y.begin(),y.end()),y.end());\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint X=lower_bound(x.begin(),x.end(),ix[i])-x.begin();\n\t\tint Y=lower_bound(y.begin(),y.end(),iy[i])-y.begin();\n\t\tsum[X+1][Y+1]++;\n\t}\n\tfor(int i=0;i<=x.size();i++)\n\t{\n\t\tfor(int j=0;j<y.size();j++)sum[i][j+1]+=sum[i][j];\n\t}\n\tfor(int j=0;j<=y.size();j++)\n\t{\n\t\tfor(int i=0;i<x.size();i++)sum[i+1][j]+=sum[i][j];\n\t}\n\tfor(int i=0;i<m;i++)\n\t{\n\t\tint xl,yl,xr,yr;\n\t\tcin>>xl>>yl>>xr>>yr;\n\t\txl=lower_bound(x.begin(),x.end(),xl)-x.begin();\n\t\tyl=lower_bound(y.begin(),y.end(),yl)-y.begin();\n\t\txr=upper_bound(x.begin(),x.end(),xr)-x.begin();\n\t\tyr=upper_bound(y.begin(),y.end(),yr)-y.begin();\n\t\tcout<<sum[xr][yr]-sum[xr][yl]-sum[xl][yr]+sum[xl][yl]<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\n\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint debug[5005][5005];\n\nint main()\n{\n    cin >> n >> m;\n\n    int xmi = inf, xma = -inf, ymi = inf, yma = -inf;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        for (int d = -1; d <= 1; ++d) {\n            compressed_x.PB(x[i] + d);\n            compressed_y.PB(y[i] + d);\n        }\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = lower_bound(all(compressed_x), x2) - begin(compressed_x);\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = lower_bound(all(compressed_y), y2) - begin(compressed_y);\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9+10;\n\nint dp[5100][5100];\nbool exist[5100][5100];\nint main(){\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n  vector<PII> ps(N);\n  VI xs(N), ys(N);\n  // x??§?¨???¨y??§?¨??????\\??????????????????\n  REP(i,N){\n\tscanf(\"%d %d\", &ps[i].first, &ps[i].second);\n\txs[i] = ps[i].first, ys[i] = ps[i].second;\n  }\n  xs.PB(-INF), xs.PB(INF);\n  ys.PB(-INF), ys.PB(INF);\n  SORT(xs); SORT(ys);\n\n  // x -> x', 0 <= x' < N+2\n  map<int,int> compX, compY;\n  VI decompX(N+2), decompY(N+2);\n  int MX = 0;\n  REP(i,N+2)\n\tif(!compX.count(xs[i])){\n\t  compX[xs[i]] = MX++;\n\t  decompX[MX-1] = xs[i];\n\t}\n  int MY = 0;\n  REP(i,N+2)\n\tif(!compY.count(ys[i])){\n\t  compY[ys[i]] = MY++;\n\t  decompY[MY-1] = ys[i];\n\t}\n\n  REP(i,N){\n\texist[compY[ps[i].second]][compX[ps[i].first]] = true;\n  }\n  for(int y=0;y<MY;++y)\n\tfor(int x=0;x<MX;++x)\n\t  dp[y][x] = (y>0? dp[y-1][x]:0) + (x>0?dp[y][x-1]:0) - (y>0&&x>0? dp[y-1][x-1]:0) + (exist[y][x]?1:0);\n\n  while(M--){\n\tint sx, sy, ex, ey;\n\tscanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n\tint sxi = compX.lower_bound(sx)->second;\n\tint syi = compY.lower_bound(sy)->second;\n\tauto it = compX.upper_bound(ex); --it;\n\tint exi = it->second;\n\tit = compY.upper_bound(ey); --it;\n\tint eyi = it->second;\n\n\tint ans = dp[eyi][exi] - (sxi>0?dp[eyi][sxi-1]:0) - (syi>0?dp[syi-1][exi]:0) + (syi>0&&sxi>0? dp[syi-1][sxi-1]:0);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(vector<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tint count = Count(pos, x1, y1, x2, y2);\n\t\tcout << count << \"\\n\";\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<int> x(n), y(n);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor(int q=0; q<m; q++){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tint count=0;\n\t\tfor(int i=0; i<n; i++){\n\t\t\tif(x1<=x[i] && x[i]<=x2 && y1<=y[i] && y[i]<=y2){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define SZ(x) (int)(x.size())\n#define REP(i, n) for(int i=0;i<(n);++i)\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define RREP(i, n) for(int i=(int)(n)-1;i>=0;--i)\n#define RFOR(i, a, b) for(int i=(int)(b)-1;i>=(a);--i)\n#define ALL(a) a.begin(),a.end()\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define DEBUG(x) cerr<<#x<<\" = \"<<(x)<<\" (L\"<<__LINE__<<\")\"<< endl;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vll = vector<ll>;\nusing vvll = vector<vll>;\nusing P = pair<int, int>;\nconst double eps = 1e-8;\nconst ll MOD = 1000000007;\nconst int INF = INT_MAX / 2;\nconst ll LINF = LLONG_MAX / 2;\ntemplate <typename T1, typename T2>\nbool chmax(T1 &a, const T2 &b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate <typename T1, typename T2>\nbool chmin(T1 &a, const T2 &b) {\n    if (a > b) { a = b; return true; }\n    return false;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp);\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v);\n\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const pair<T1, T2> &p) {\n    os << p.first << \":\" << p.second;\n    return os;\n}\ntemplate<typename T1, typename T2>\nostream &operator<<(ostream &os, const map<T1, T2> &mp) {\n    os << \"{\";\n    int a = 0;\n    for (auto &tp : mp) {\n        if (a) os << \", \"; a = 1;\n        os << tp;\n    }\n    return os << \"}\";\n}\ntemplate<typename T>\nostream &operator<<(ostream &os, const vector<T> &v) {\n    os << \"[\";\n    REP(i, SZ(v)) {\n        if (i) os << \", \";\n        os << v[i];\n    }\n    return os << \"]\";\n}\n\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    int n, m; cin >> n >> m;\n    vi x(n), y(n);\n    vi xs, ys;\n    REP(i, n) {\n        cin >> x[i] >> y[i];\n        xs.push_back(x[i]);\n        ys.push_back(y[i]);\n    }\n    sort(ALL(xs));\n    sort(ALL(ys));\n    xs.erase(unique(ALL(xs)), xs.end());\n    ys.erase(unique(ALL(ys)), ys.end());\n\n    int H = ys.size(), W = xs.size();\n    vvi s(H+1, vi(W+1));\n    REP(i, n) {\n        int X = lower_bound(ALL(xs), x[i]) - xs.begin();\n        int Y = lower_bound(ALL(ys), y[i]) - ys.begin();\n        ++s[Y+1][X+1];\n    }\n    REP(i, H) {\n        REP(j, W) {\n            s[i+1][j+1] += s[i+1][j] + s[i][j+1] - s[i][j];\n        }\n    }\n\n    vi sx(m), sy(m), tx(m), ty(m);\n    REP(i, m) {\n        int sX, sY, tX, tY;\n        cin >> sX >> sY >> tX >> tY;\n        sx[i] = lower_bound(ALL(xs), sX) - xs.begin();\n        tx[i] = lower_bound(ALL(xs), tX+1) - xs.begin();\n        sy[i] = lower_bound(ALL(ys), sY) - ys.begin();\n        ty[i] = lower_bound(ALL(ys), tY+1) - ys.begin();\n    }\n\n    REP(i, m) {\n        int ans = s[ty[i]][tx[i]] - s[ty[i]][sx[i]] - s[sy[i]][tx[i]] + s[sy[i]][sx[i]];\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1e9 + 10;\n\nint xs[5001], ys[5001];\nint sum[5100][5100];\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<int> X = {-inf, inf}, Y = {-inf, inf};\n  rep(i, N) {\n    scanf(\"%d%d\", &xs[i], &ys[i]);\n    X.push_back(xs[i]); Y.push_back(ys[i]);\n  }\n\n  sort(X.begin(), X.end()); X.erase(unique(all(X)), X.end());\n  sort(Y.begin(), Y.end()); Y.erase(unique(all(Y)), Y.end());\n\n  rep(i, N) {\n    sum[upper_bound(all(Y), ys[i]) - Y.begin()][upper_bound(all(X), xs[i]) - X.begin()] ++;\n  }\n\n  rep(i, Y.size() + 10) rep(j, X.size() + 10) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int rx1, ry1, rx2, ry2; scanf(\"%d%d%d%d\", &rx1, &ry1, &rx2, &ry2);\n    int x1 = lower_bound(all(X), rx1) - X.begin();\n    int y1 = lower_bound(all(Y), ry1) - Y.begin();\n    int x2 = upper_bound(all(X), rx2) - X.begin();\n    int y2 = upper_bound(all(Y), ry2) - Y.begin();\n    printf(\"%d\\n\", sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_;\n\tstd::vector<std::vector<Type> > dat;\n\tstd::vector<std::vector<int> > vl;\n\tinline int query_(int a, int b, Type x, int k, int l, int r, int e) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r) and e integers below x in the range\n\t\tif (r <= a || b <= l || e == 0) return 0;\n\t\tif (a <= l && r <= b) return e;\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1, vl[k][e - 1]);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r, e - vl[k][e - 1]);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1);\n\t\tdat.resize(size_ << 1);\n\t\tvl.resize(size_);\n\t\tfor (int i = 0; i < n; i++) dat[i + size_].push_back(*(begin_ + i));\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tvl[i].resize(dat[i].size());\n\t\t\tint cl = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][j - cl])) dat[i][j] = dat[i << 1][cl++];\n\t\t\t\telse dat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\tvl[i][j] = cl;\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\tint ptr = lower_bound(dat[1].begin(), dat[1].end(), x) - dat[1].begin();\n\t\treturn query_(l, r, x, 1, 0, size_, ptr);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(vec) vec.begin(),vec.end()\nint main(){\n    int n,m;cin >> n >> m;\n\n    vector<int> index_of_x(n),index_of_y(n);\n    for(int i=0;i<n;i++){\n        cin >> index_of_x[i] >> index_of_y[i];\n    }\n    vector<int> value_of_x = index_of_x,\n                value_of_y = index_of_y;\n\n    sort(all(value_of_x));\n    sort(all(value_of_y));\n    value_of_x.erase(unique(all(value_of_x)),value_of_x.end());\n    value_of_y.erase(unique(all(value_of_y)),value_of_y.end());\n    for(int i=0;i<n;i++){\n        index_of_x[i] = lower_bound(all(value_of_x),index_of_x[i]) - value_of_x.begin();\n        index_of_y[i] = lower_bound(all(value_of_y),index_of_y[i]) - value_of_y.begin();\n    }\n    vector<vector<int>> p(value_of_y.size(),vector<int>(value_of_x.size()));\n    for(int i=0;i<n;i++){\n        p[index_of_y[i]][index_of_x[i]] += 1;\n    }\n    v = calc_sum(p);\n\n    for(int i=0;i<m;i++){\n        int x1,y1,x2,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        int sx = lower_bound(all(value_of_x),x1) - value_of_x.begin();\n        int gx = upper_bound(all(value_of_x),x2) - value_of_x.begin();\n        int sy = lower_bound(all(value_of_y),y1) - value_of_y.begin();\n        int gy = upper_bound(all(value_of_y),y2) - value_of_y.begin();\n\n        int ans = v[gy][gx] - v[sy][gx] - v[gy][sx] + v[sy][sx];\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair<int,int>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\n\n\n\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector <P> p(n);\n  \n  REP(i,n){\n    cin >> p[i].first >> p[i].second;\n  }\n  sort(p.begin(),p.end());\n  REP(i,m){\n    int x1,x2,y1,y2;\n    int sum = 0;\n    cin >> x1 >> y1 >> x2 >> y2;\n    REP(j,n){\n      if(p[j].first >= x1 && p[j].first <= x2 && p[j].second >= y1 && p[j].second <= y2){\n\tsum++;\n\t\n      }\n      if(x2 < p[j].first){\n\t  break;\n      }\n    }\n    printf(\"%d\", sum);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\nint pos1(vi v, int p) {\n\treturn lower_bound(ALL(v), p) - v.begin() - 1;\n}\n\nint pos2(vi v, int p) {\n\treturn upper_bound(ALL(v), p) - v.begin() - 1;\n}\n\nint field[5001][5001];\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvi x(n), y(n);\n\tmap<pii, int> tresure;\n\tREP(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t\ttresure[pii(x[i], y[i])]++;\n\t}\n\n\tx.push_back(INT_MIN);\n\ty.push_back(INT_MIN);\n\tsort(ALL(x));\n\tsort(ALL(y));\n\tx.erase(unique(ALL(x)), x.end());\n\ty.erase(unique(ALL(y)), y.end());\n\n\tint xsize = x.size(), ysize = y.size();\n\tmemset(field, 0, sizeof(field));\n//\tvvi field(ysize+1, vi(xsize+1));\n\tREP(i, ysize) {\n\t\tREP(j, xsize) {\n\t\t\tfield[i][j] = tresure[pii(x[j], y[i])];\n\t\t}\n\t}\n\tFOR(i, 1, ysize-1) {\n\t\tFOR(j, 1, xsize-1) {\n\t\t\tfield[i][j] += field[i][j - 1];\n\t\t}\n\t}\n\tFOR(i, 1, ysize-1) {\n\t\tFOR(j, 1, xsize-1) {\n\t\t\tfield[i][j] += field[i - 1][j];\n\t\t}\n\t}\n\n\tREP(i, m) {\n\t\tint xm1, ym1, xm2, ym2;\n\t\tcin >> xm1 >> ym1 >> xm2 >> ym2;\n\t\tint xp1 = pos1(x, xm1), yp1 = pos1(y, ym1), xp2 = pos2(x, xm2), yp2 = pos2(y, ym2);\n\t\tcout << field[yp2][xp2] - field[yp1][xp2] - field[yp2][xp1] + field[yp1][xp1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\nusing i64 = long long;\nconst i64 MOD = 1e9+7;\nconst i64 INF = 1e18+7;\n\n\ntemplate <typename T>\nbool chmin(T& x, T y){\n    if(x > y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\ntemplate <typename T>\nbool chmax(T& x, T y){\n    if(x < y){\n        x = y;\n        return true;\n    }\n    return false;\n}\n\nstruct FullyIndexableDictionary{\n    int len,blk;\n    vector<unsigned> bit;\n    vector<int> sum;\n\n    FullyIndexableDictionary(){}\n    FullyIndexableDictionary(int len)\n            :len(len),blk((len+31)>>5),bit(blk,0),sum(blk,0){}\n\n    void set(int k){\n        bit[k>>5]|=1u<<(k&31);\n    }\n\n    void build(){\n        sum[0]=0;\n        for(int i=1;i<blk;i++)\n            sum[i]=sum[i-1]+__builtin_popcount(bit[i-1]);\n    }\n\n    bool operator[](int k) const{\n        return bool((bit[k>>5]>>(k&31))&1);\n    }\n\n    int rank(int k){\n        return sum[k>>5]+__builtin_popcount(bit[k>>5]&((1u<<(k&31))-1));\n    }\n\n    int rank(bool v,int k){\n        return (v?rank(k):k-rank(k));\n    }\n\n    int select(bool v,int k){\n        if(k<0||rank(v,len)<=k) return -1;\n        int l=0,r=len;\n        while(l+1<r){\n            int m=(l+r)>>1;\n            if(rank(v,m)>=k+1) r=m;\n            else l=m;\n        }\n        return r-1;\n    }\n\n    int select(bool v,int i,int l){\n        return select(v,i+rank(v,l));\n    }\n};\n\ntemplate<class T,int MAXLOG>\nstruct WaveletMatrix{\n    int len;\n    FullyIndexableDictionary mat[MAXLOG];\n    int zs[MAXLOG],buff1[MAXLOG],buff2[MAXLOG];\n    static const T npos=-1;\n\n    int freq_dfs(int d,int l,int r,T val,T a,T b){\n        if(l==r) return 0;\n        if(d==MAXLOG) return (a<=val&&val<b)?r-l:0;\n        T nv=T(1)<<(MAXLOG-d-1)|val;\n        T nnv=((T(1)<<(MAXLOG-d-1))-1)|nv;\n        if(nnv<a||b<=val) return 0;\n        if(a<=val&&nnv<b) return r-l;\n        int lc=mat[d].rank(1,l),rc=mat[d].rank(1,r);\n        return freq_dfs(d+1,l-lc,r-rc,val,a,b)\n               +freq_dfs(d+1,lc+zs[d],rc+zs[d],nv,a,b);\n    }\n\n    WaveletMatrix(vector<T> data){\n        len=data.size();\n        vector<T> ls(len),rs(len);\n        for(int dep=0;dep<MAXLOG;dep++){\n            mat[dep]=FullyIndexableDictionary(len+1);\n            int p=0,q=0;\n            for(int i=0;i<len;i++){\n                bool k=(data[i]>>(MAXLOG-(dep+1)))&1;\n                if(k) rs[q++]=data[i],mat[dep].set(i);\n                else  ls[p++]=data[i];\n            }\n            zs[dep]=p;\n            mat[dep].build();\n            swap(ls,data);\n            for(int i=0;i<q;i++) data[p+i]=rs[i];\n        }\n    }\n\n    T access(int k){\n        T res=0;\n        for(int dep=0;dep<MAXLOG;dep++){\n            bool bit=mat[dep][k];\n            res=(res<<1)|bit;\n            k=mat[dep].rank(bit,k)+zs[dep]*dep;\n        }\n        return res;\n    }\n\n    // return the number of v in [0,k)\n    int rank(T v,int k){\n        int l=0,r=k;\n        for(int dep=0;dep<MAXLOG;dep++){\n            buff1[dep]=l;buff2[dep]=r;\n            bool bit=(v>>(MAXLOG-(dep+1)))&1;\n            l=mat[dep].rank(bit,l)+zs[dep]*bit;\n            r=mat[dep].rank(bit,r)+zs[dep]*bit;\n        }\n        return r-l;\n    }\n\n    // return the position of k-th v\n    int select(T v,int k){\n        rank(v,len);\n        for(int dep=MAXLOG-1;dep>=0;dep--){\n            bool bit=(v>>(MAXLOG-(dep+1)))&1;\n            k=mat[dep].select(bit,k,buff1[dep]);\n            if(k>=buff2[dep]||k<0) return -1;\n            k-=buff1[dep];\n        }\n        return k;\n    }\n\n    int select(T v,int k,int l){\n        return select(v,k+rank(v,l));\n    }\n\n    // return k-th largest value in [l,r)\n    T quantile(int l,int r,int k){\n        if(r-l<=k||k<0) return -1;\n        T res=0;\n        for(int dep=0;dep<MAXLOG;dep++){\n            int p=mat[dep].rank(1,l);\n            int q=mat[dep].rank(1,r);\n            if(q-p>k){\n                l=p+zs[dep];\n                r=q+zs[dep];\n                res|=T(1)<<(MAXLOG-(dep+1));\n            }else{\n                k-=(q-p);\n                l-=p;\n                r-=q;\n            }\n        }\n        return res;\n    }\n\n    T rquantile(int l,int r,int k){\n        return quantile(l,r,r-l-k-1);\n    }\n\n    // return number of points in [left, right) * [lower, upper)\n    int rangefreq(int left,int right,T lower,T upper){\n        return freq_dfs(0,left,right,0,lower,upper);\n    }\n\n    pair<int, int> ll(int l,int r,T v){\n        int res=0;\n        for(int dep=0;dep<MAXLOG;dep++){\n            buff1[dep]=l;buff2[dep]=r;\n            bool bit=(v>>(MAXLOG-(dep+1)))&1;\n            if(bit) res+=r-l+mat[dep].rank(bit,l)-mat[dep].rank(bit,r);\n            l=mat[dep].rank(bit,l)+zs[dep]*bit;\n            r=mat[dep].rank(bit,r)+zs[dep]*bit;\n        }\n        return make_pair(res,r-l);\n    }\n\n    int lt(int l,int r,T v){\n        auto p=ll(l,r,v);\n        return p.first;\n    }\n\n    int le(int l,int r,T v){\n        auto p=ll(l,r,v);\n        return p.first+p.second;\n    }\n\n    T succ(int l,int r,T v){\n        int k=le(l,r,v);\n        return k==r-l?npos:rquantile(l,r,k);\n    }\n\n    T pred(int l,int r,T v){\n        int k=lt(l,r,v);\n        return k?rquantile(l,r,k-1):npos;\n    }\n};\n\n\nbool solve(){\n    int n, m;\n    cin >> n >> m;\n    vector<pair<i64,i64>> v;\n    for(int i = 0; i < n; ++i){\n        i64 x, y;\n        cin >> x >> y;\n        x += 2e9;\n        y += 2e9;\n        v.emplace_back(x, y);\n    }\n    sort(v.begin(), v.end());\n    vector<i64> ys;\n    for(auto& p : v)\n        ys.emplace_back(p.second);\n    map<i64,int> st;\n    st[INF] = n;\n    for(int i = 0; i < n; ++i){\n        i64 x = v[i].first;\n        if(st.find(x) == st.end())\n            st[x] = i;\n    }\n    WaveletMatrix<i64, 40> wm(ys);\n    for(int i = 0; i < m; ++i){\n        i64 sx, sy, ex, ey;\n        cin >> sx >> sy >> ex >> ey;\n        sx += 2e9;\n        sy += 2e9;\n        ex += 2e9;\n        ey += 2e9;\n        cout << wm.rangefreq(st.lower_bound(sx)->second, st.upper_bound(ex)->second, sy, ey + 1) << endl;\n    }\n    return false;\n}\n\n\nsigned main(){\n    while(solve());\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<stack>\n#include<deque>\n#include<iostream>\n#include<cstdio>\n#define F first\n#define S second\n#define LIM 1000000010\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<int,int> P;\nint dp[5002][5002];\nint main(){\n  int n,m;\n \n  vector<int> X,Y;\n  \n  while(cin >> n >> m){\n    for(int i=0;i<5000;i++)for(int j=0;j<5000;j++)dp[j][i] = 0;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      X.pb(x); Y.pb(y);\n    }\n    vector<int> x,y;\n    x = X;\n    y = Y;\n    X.pb(-LIM); X.pb(LIM); Y.pb(-LIM); Y.pb(LIM);\n    sort(all(X)); sort(all(Y));\n    X.erase(unique(all(X)),X.end());\n    Y.erase(unique(all(Y)),Y.end());\n    for(int i=0;i<n;i++){\n      x[i] = find(all(X),x[i])-X.begin();\n      y[i] = find(all(Y),y[i])-Y.begin();\n      dp[y[i]][x[i]]++;\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\tdp[i+1][j+1] += dp[i+1][j]+dp[i][j+1]-dp[i][j];\n\n      }\n\n    }\n    for(int i=0;i<m;i++){\n      int sx,sy,gx,gy;\n      cin >> sx >> sy >> gx >> gy;\n      sx = lower_bound(all(X),sx)-X.begin();\n      sy = lower_bound(all(Y),sy)-Y.begin();\n      gx = upper_bound(all(X),gx)-X.begin()-1;\n      gy = upper_bound(all(Y),gy)-Y.begin()-1;\n      cout << dp[gy][gx]-dp[gy][sx-1]-dp[sy-1][gx]+dp[sy-1][sx-1] << endl;\n\n    }\n\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nset<int> X, Y;\nmap<int, int> MX, MY;\nint xs[5001], ys[5001];\nint rx1[500010], ry1[500010];\nint rx2[500010], ry2[500010];\nint sum[5010][5010];\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  rep(i, N) {\n    scanf(\"%d%d\", &xs[i], &ys[i]);\n    X.insert(xs[i]); Y.insert(ys[i]);\n  }\n\n  rep(i, M) {\n    scanf(\"%d%d%d%d\", &rx1[i], &ry1[i], &rx2[i], &ry2[i]);\n    X.insert(rx1[i]); Y.insert(ry1[i]);\n    X.insert(rx2[i]); Y.insert(ry2[i]);\n  }\n\n  int W = 0; for(auto && e: X) MX[e] = W++;\n  int H = 0; for(auto && e: Y) MY[e] = H++;\n\n  rep(i, N) {\n    sum[MY[ys[i]]][MX[xs[i]]] ++;\n  }\n\n  rep(i, H) rep(j, W) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int x1 = MX[rx1[i]], x2 = MX[rx2[i]];\n    int y1 = MY[ry1[i]], y2 = MY[ry2[i]];\n    int r = sum[y2][x2];\n    if(x1 && y1) r += sum[y1-1][x1-1];\n    if(y1) r -= sum[y1-1][x2];\n    if(x1) r -= sum[y2][x1-1];\n    printf(\"%d\\n\", r);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nstruct dat {\n    int id;\n    int z;\n\n    dat () {}\n    ~dat () {}\n\n    dat (int a, int b): id(a), z(b) {}\n    \n    bool operator < (const dat& o) const {\n        return z < o.z;\n    }\n};\n\nint N, M;\nint tx[5000], ty[5000];\n\ndat arr_x[5000];\ndat arr_y[5000];\n\nint check[5000];\n\nint solve(int x1, int y1, int x2, int y2) {\n    fill(check, check + N, 0);\n\n    for (dat* itx = lower_bound(arr_x, arr_x+N, dat(-1, x1));\n            itx < arr_x+N && itx->z <= x2; ++itx) {\n        ++ check[ itx->id ];\n    }\n\n    for (dat* ity = lower_bound(arr_y, arr_y+N, dat(-1, y1));\n            ity < arr_y+N && ity->z <= y2; ++ity) {\n        ++check[ ity->id ];\n    }\n\n    int ans = 0;\n    for (int j = 0; j < N; ++j) {\n        ans += check[j] >> 1;\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    for (int j = 0; j < N; ++j) {\n        cin >> tx[j] >> ty[j];\n    }\n\n    // initialize\n    for (int j = 0; j < N; ++j) {\n        arr_x[j] = dat(j, tx[j]);\n        arr_y[j] = dat(j, ty[j]);\n    }\n    sort(arr_x, arr_x + N);\n    sort(arr_y, arr_y + N);\n\n    for (int j = 0; j < M; ++j) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        cout << solve(x1, y1, x2, y2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<(n);i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nP p[5000];\nvector<int>dat[50000];\nvoid init(int k, int l, int r) {\n\tif (r - l == 1) {\n\t\tdat[k].push_back(p[l].second); return;\n\t}\n\tint lb = k * 2 + 1, rb = k * 2 + 2;\n\tinit(lb, l, (l + r) / 2);\n\tinit(rb, (l + r) / 2, r);\n\tdat[k].resize(r - l);\n\tmerge(dat[lb].begin(), dat[lb].end(), dat[rb].begin(), dat[rb].end(), dat[k].begin());\n}\nint query(int a, int b, int c, int d, int k, int l, int r) {\n\tif (b <= l || r <= a)return 0;\n\tif (a <= l&&r <= b) {\n\t\tint u = upper_bound(dat[k].begin(), dat[k].end(), d) - dat[k].begin();\n\t\tint v = upper_bound(dat[k].begin(), dat[k].end(), c - 1) - dat[k].begin();\n\t\treturn u - v;\n\t}\n\tint lb = query(a, b, c, d, k * 2 + 1, l, (l + r) / 2);\n\tint rb = query(a, b, c, d, k * 2 + 2, (l + r) / 2, r);\n\treturn lb + rb;\n}\nint main() {\n\tint n, q; scanf(\"%d%d\", &n, &q);\n\trep(i, n)scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p, p + n); init(0, 0, n);\n\trep(i, q) {\n\t\tint sx, tx, sy, ty; scanf(\"%d%d%d%d\", &sx, &sy, &tx, &ty);\n\t\tint a = lower_bound(p, p + n, P(sx, INT_MIN)) - p;\n\t\tint b = lower_bound(p, p + n, P(tx, INT_MAX)) - p;\n\t\tprintf(\"%d\\n\", query(a, b, sy, ty, 0, 0, n));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nstruct Point {\n  int x;\n  int y;\n  Point(int _x,int _y) : x(_x),y(_y) {}\n  bool operator<(const Point& p) const{\n    return x < p.x;\n  }\n};\n\nint main(){\n  int total_treasure,total_region;\n  \n  while(~scanf(\"%d %d\",&total_treasure,&total_region)){\n    vector<Point> treasures;\n    vector<int> treasures_x;\n\n    for(int i=0;i<total_treasure;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      treasures.push_back(Point(x,y));\n      treasures_x.push_back(x);\n    }\n    sort(treasures.begin(),treasures.end());\n    sort(treasures_x.begin(),treasures_x.end());\n\n    for(int i=0;i<total_region;i++){\n      int x[2],y[2];\n      scanf(\"%d %d %d %d\",x,y,x+1,y+1);\n      int left_idx = lower_bound(treasures_x.begin(),treasures_x.end(),x[0]) - treasures_x.begin();\n      int right_idx = upper_bound(treasures_x.begin(),treasures_x.end(),x[1]) - treasures_x.begin() - 1;\n\n      int count = 0;\n      for(int j=left_idx;j<=right_idx;j++){\n      \tif(treasures[j].y < y[0] || y[1] < treasures[j].y) continue;\n      \tcount++;\n      }\n      printf(\"%d\\n\",count);\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\n\n// macros\n#define ll long long int\n#define pb emplace_back\n#define mk make_pair\n#define pq priority_queue\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define vrep(v, i) for(int i = 0; i < (v).size(); i++)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define FI first\n#define SE second\n#define dump(a, n) for(int i = 0; i < n; i++)cout << a[i] << \"\\n \"[i + 1 != n];\n#define dump2(a, n, m) for(int i = 0; i < n; i++)for(int j = 0; j < m; j++)cout << a[i][j] << \"\\n \"[j + 1 != m];\n#define bit(n) (1LL<<(n))\n#define INT(n) int n; cin >> n;\n#define LL(n) ll n; cin >> n;\n#define DOUBLE(n) double n; cin >> n;\nusing namespace std;\n\n//  types\ntypedef pair<int, int> P;\ntypedef pair<ll, int> Pl;\ntypedef pair<ll, ll> Pll;\ntypedef pair<double, double> Pd;\ntypedef complex<double> cd;\n \n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1e9 + 7;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n\n// solve\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n\nint ato_int(char c){\n  return int(c - 'a');\n}\n\nchar to_achar(int i){\n  return char(i + 'a');\n}\n\nint Ato_int(char c){\n  if('a' <= c && c <= 'z')return int(c - 'a');\n  return int(c - 'A') + 26;\n}\n\nchar to_Achar(int i){\n  if(i < 26)return char(i + 'a');\n  return char(i - 26 + 'A');\n}\n\nint dto_int(char c){\n  return int(c - '0');\n}\n\nchar to_dchar(int i){\n  return char(i + '0');\n}\n\ntypedef struct SuccinctBitVector_ {\n  int size;\n  int block = 32;\n  int l = 256;\n  vector<uint32_t> B;\n  vector<unsigned> L, S;\n  SuccinctBitVector_(){}\n  SuccinctBitVector_(int size_){\n    size = size_;\n    B.assign((size + block - 1) / block, 0U);\n    L.assign((size + l - 1) / l, 0U);\n    S.assign((size + block - 1) / block, 0U);\n  }\n  void set_bit(int at){\n    B[at / block] |= (1U << (at % block));\n  }\n  void build(){\n    int true_count = 0;\n    for(int i = 0; i < ((size + block - 1) / block) * block; i+=block){\n      if(i % l == 0)L[i / l] = true_count;\n      S[i / block] = true_count - L[i / l];\n      true_count += __builtin_popcount(B[i / block]);\n    }\n  }\n  bool access(int at){\n    return (B[at / block] >> (at % block)) & 1U;\n  }\n  bool operator[](int at){\n    return access(at);\n  }\n  // this is rank1\n  int rank(int at){\n    return L[at / l] + S[at / block] + __builtin_popcount((B[at / block] & ((1U << (at % block)) - 1)));\n  }\n  int rank(bool val, int at){\n    return (val ? rank(at): at - rank(at));\n  }\n  int select(bool val, int x){\n    if(x < 0 || x >= rank(val, size))return -1;\n    int ld = 0, rd = size;\n    while(rd - ld > 1){\n      int md = (rd + ld) / 2;\n      if(rank(val, md) >= x + 1)rd = md;\n      else ld = md;\n    }\n    return rd - 1;\n  }\n  int select(int x){\n    return select(1, x);\n  }\n  int select(bool val, int x, int l){\n    return select(val, x + rank(val, l));\n  }\n} SuccinctBitVector;\n\nvector<int> ato_vector(const string &s){\n  vector<int> v(s.size());\n  for(int i = 0; i < s.size(); i++){\n    v[i] = ato_int(s[i]);\n  }\n  return v;\n}\n\ntemplate <typename T>\nstruct WaveletMatrix{\n  int n = 0;\n  int len = 0;\n  vector<SuccinctBitVector> mat;\n  vector<int> zc;\n  vector<int> bl, br;\n  vector<vector<T>> sum;\n  WaveletMatrix(int m, vector<T> s){\n    len = s.size();\n    while((1LL<< n) <= m)n++;\n    mat.resize(n);\n    zc.resize(n);\n    bl.resize(n);\n    br.resize(n);\n    sum.resize(n + 1, vector<T>(len + 1, 0));\n\n    for(int i = 0; i < len; i++)sum[0][i + 1] = sum[0][i] + s[i];\n\n    vector<T> l(len), r(len);\n    for(int i = 0; i < n; i++){\n      mat[i] = SuccinctBitVector(len + 1);\n      int li = 0, ri = 0;\n      for(int j = 0; j < len; j++){\n        if((s[j] >> (n - i - 1)) & 1){\n          r[ri++] = s[j];\n          mat[i].set_bit(j);\n        }else{\n          l[li++] = s[j];\n        }\n      }\n      zc[i] = li;\n      mat[i].build();\n      swap(l, s);\n      for(int j = 0; j < ri; j++)s[li + j] = r[j];\n      for(int j = 0; j < len; j++)sum[i+1][j+1] = sum[i+1][j] + s[j];\n    }\n  }\n  T access(int i){\n    int res = 0;\n    for(int j = 0; j < n; j++){\n      bool bit = mat[j][i];\n      res = (res << 1) | bit;\n      i = zc[j] * bit + mat[j].rank(bit, i);\n    }\n    return res;\n  }\n  T operator[](int i){\n    return access(i);\n  }\n  int rank(T val, int i){\n    int l = 0, r = i;\n    for(int j = 0; j < n; j++){\n      bl[j] = l, br[j] = r;\n      bool bit = (val >> (n - j - 1)) & 1;\n      l = zc[j] * bit + mat[j].rank(bit, l);\n      r = zc[j] * bit + mat[j].rank(bit, r);\n    }\n    return r - l;\n  }\n  int select(T val, int i){\n    rank(val, len);\n    for(int j = n - 1; j >= 0; j--){\n      bool bit = (val >> (n - j - 1)) & 1;\n      i = mat[j].select(bit, i, bl[j]);\n      if(i >= br[j] || i < 0)return -1;\n      i -= bl[j];\n    }\n    return i;\n  }\n  int select(T val, int i, int l){\n    return select(val, i + rank(val, l));\n  }\n  T quantile(int s, int e, int k){\n    if(e - s <= k || k < 0)return -1;\n    T res = 0;\n    for(int i = 0; i < n; i++){\n      int l = mat[i].rank(1, s);\n      int r = mat[i].rank(1, e);\n      if(r - l > k){\n        s = zc[i] + l;\n        e = zc[i] + r;\n        res = res | (1LL << (n - i - 1));\n      }else{\n        k -= (r - l);\n        s -= l;\n        e -= r;\n      }\n    }\n    return res;\n  }\n  // equal, lt, gt\n  tuple<int, int, int> rankall(T x, int s, int e){\n    if(s >= e)return make_tuple(0, 0, 0);\n    int rank_lt = 0, rank_gt = 0;\n    for(int i = 0; i < n && s < e; i++){\n      bool bit = (x >> (n - i - 1)) & 1;\n      int s0 = mat[i].rank(0, s);\n      int s1 = s - s0;\n      int e0 = mat[i].rank(0, e);\n      int e1 = e - e0;\n      if(bit){\n        rank_lt += e0 - s0;\n        s = zc[i] + s1;\n        e = zc[i] + e1;\n      }else{\n        rank_gt += e1 - s1;\n        s = s0;\n        e = e0;\n      }\n    }\n    return make_tuple(e - s - rank_lt - rank_gt, rank_lt, rank_gt);\n  }\n  int rangefreq(int s, int e, T mini, T maxi){\n    tuple<int, int, int> maxi_t = rankall(maxi, s, e);\n    tuple<int, int, int> mini_t = rankall(mini, s, e);\n    return get<1>(maxi_t) - get<1>(mini_t);\n  }\n  int ranklt(T x, int s, int e){\n    return get<1>(rankall(x, s, e));\n  }\n  int rankgt(T x, int s, int e){\n    return get<2>(rankall(x, s, e));\n  }\n  T rangemax(int s, int e){\n    return quantile(s, e, 0);\n  }\n  T rangemin(int s, int e){\n    return quantile(s, e, e - s - 1);\n  }\n  vector<pair<T, int>> topk(int s, int e, int k){\n    vector<pair<T, int>> res;\n    using v_t = tuple<int, int, int, int, T>;\n    auto comp = [](const v_t &a, const v_t &b){\n      if(get<0>(a) != get<0>(b))return get<0>(a) < get<0>(b);\n      if(get<3>(a) != get<3>(b))return get<3>(a) > get<3>(b);\n      return get<3>(a) > get<3>(b);\n    };\n    priority_queue<v_t, vector<v_t>, decltype(comp)> pq(comp);\n    pq.push(make_tuple(e - s, s, e, 0, 0));\n    while(!pq.empty()){\n      auto p = pq.top(); pq.pop();\n      int width, li, ri, dep;\n      T val;\n      tie(width, li, ri, dep, val) = p;\n      if(dep >= n){\n        res.emplace_back(make_pair(val, ri - li));\n        if(res.size() >= k)break;\n        continue;\n      }\n      int l0 = mat[dep].rank(0, li);\n      int r0 = mat[dep].rank(0, ri);\n      if(l0 < r0)pq.push(make_tuple(r0 - l0, l0, r0, dep + 1, val));\n      int l1 = zc[dep] + mat[dep].rank(1, li);\n      int r1 = zc[dep] + mat[dep].rank(1, ri);\n      if(l1 < r1)pq.push(make_tuple(r1 - l1, l1, r1, dep + 1, val | (1LL << (n - dep - 1))));\n    }\n    return res;\n  }\n  T rangesum(int s, int e, int depth, T val, T x, T y){\n    if(s == e)return 0;\n    if(depth == n){\n      if(x <= val && val < y)return val * (e - s);\n      return 0;\n    }\n    T nv = (1LL << (n - depth - 1)) | val;\n    T nnv = ((1LL << (n - depth - 1)) - 1) | nv;\n    if(nnv < x || y <= val)return 0;\n    if(x <= val && nnv < y)return sum[depth][e] - sum[depth][s];\n    int s0 = mat[depth].rank(0, s);\n    int s1 = s - s0;\n    int e0 = mat[depth].rank(0, e);\n    int e1 = e - e0;\n    return rangesum(s0, e0, depth + 1, val, x, y) + rangesum(zc[depth] + s1, zc[depth] + e1, depth + 1, nv, x, y);\n  }\n  T rangesum(int s, int e, T x, T y){\n    return rangesum(s, e, 0, 0, x, y);\n  }\n  T prev(int s, int e, T x, T y){\n    y--;\n    using v_t = tuple<int, int, int, T, bool>;\n    stack<v_t> st;\n    st.push(make_tuple(s, e, 0, 0, true));\n    while(!st.empty()){\n      auto p = st.top(); st.pop();\n      int li, ri, depth;\n      T val;\n      bool tight;\n      tie(li, ri, depth, val, tight) = p;\n\n      if(depth == n){\n        if(val >= x)return val;\n        continue;\n      }\n\n      bool bit = (y >> (n - depth - 1)) & 1;\n      int l0 = mat[depth].rank(0, li);\n      int l1 = li - l0;\n      int r0 = mat[depth].rank(0, ri);\n      int r1 = ri - r0;\n      if(l0 != r0){\n        st.push(make_tuple(l0, r0, depth + 1, (val << 1), tight && !bit));\n      }\n      if(l1 != r1){\n        if(!tight || bit){\n          st.push(make_tuple(zc[depth] + l1, zc[depth] + r1, depth + 1, ((val<<1)|1), tight));\n        }\n      }\n    }\n    return -1;\n  }\n  T next(int s, int e, T x, T y){\n    using v_t = tuple<int, int, int, T, bool>;\n    stack<v_t> st;\n    st.push(make_tuple(s, e, 0, 0, true));\n    while(!st.empty()){\n      auto p = st.top(); st.pop();\n      int li, ri, depth;\n      T val;\n      bool tight;\n      tie(li, ri, depth, val, tight) = p;\n      if(depth == n){\n        if(val < y)return val;\n        continue;\n      }\n\n      bool bit = (x >> (n - depth - 1)) & 1;\n      int l0 = mat[depth].rank(0, li);\n      int l1 = li - l0;\n      int r0 = mat[depth].rank(0, ri);\n      int r1 = ri - r0;\n      if(l1 != r1){\n        st.push(make_tuple(zc[depth] + l1, zc[depth] + r1, depth + 1, ((val<<1)|1), tight && bit));\n      }\n      if(l0 != r0){\n        if(!tight || !bit){\n          st.push(make_tuple(l0, r0, depth + 1, (val << 1), tight));\n        }\n      }\n    }\n    return -1;\n  }\n  vector<tuple<T, int, int>> intersect(int s1, int e1, int s2, int e2){\n    using v_t = tuple<int, int, int, int, int, T>;\n    vector<tuple<T, int, int>> res;\n    queue<v_t> q;\n    q.push(make_tuple(s1, e1, s2, e2, 0, 0));\n    while(!q.empty()){\n      auto p = q.front(); q.pop();\n      int s_1, e_1, s_2, e_2, depth;\n      T val;\n      tie(s_1, e_1, s_2, e_2, depth, val) = p;\n      if(depth == n){\n        res.emplace_back(make_tuple(val, e_1 - s_1, e_2 - s_2));\n        continue;\n      }\n\n      int s1_0 = mat[depth].rank(0, s_1);\n      int e1_0 = mat[depth].rank(0, e_1);\n      int s2_0 = mat[depth].rank(0, s_2);\n      int e2_0 = mat[depth].rank(0, e_2);\n\n      if(s1_0 != e1_0 && s2_0 != e2_0){\n        q.push(make_tuple(s1_0, e1_0, s2_0, e2_0, depth + 1, val));\n      }\n\n      int s1_1 = s_1 - s1_0 + zc[depth];\n      int e1_1 = e_1 - e1_0 + zc[depth];\n      int s2_1 = s_2 - s2_0 + zc[depth];\n      int e2_1 = e_2 - e2_0 + zc[depth];\n\n      if(s1_1 != e1_1 && s2_1 != e2_1){\n        q.push(make_tuple(s1_1, e1_1, s2_1, e2_1, depth + 1, val | (1LL << (n - depth - 1))));\n      }\n    }\n    return res;\n  }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  ios_base::sync_with_stdio(false);\n  cin.tie(0);\n  INT(n); INT(m);\n  vector<Pll> vec(n);\n  rep(i, n){\n    cin >> vec[i].FI >> vec[i].SE;\n  }\n  sort(all(vec));\n  map<ll, int> mpn;\n  rep(i, n)mpn[vec[i].FI] = n;\n  rep(i, n){\n    mpn[vec[i].FI] = min(i, mpn[vec[i].FI]);\n  }\n  vector<ll> v(n);\n  ll base = inf;\n  ll M = 2LL * inf;\n  rep(i, n)v[i] = base + vec[i].SE;\n  WaveletMatrix<ll> w(M, v);\n  rep(i, m){\n    INT(x1); INT(y1); INT(x2); INT(y2);\n    y2++;\n    auto litr = mpn.lower_bound(x1);\n    auto ritr = mpn.upper_bound(x2);\n    int li = litr == mpn.end() ? n: litr->second;\n    int ri = ritr == mpn.end() ? n: ritr->second;\n    cout << w.rangefreq(li, ri, y1 + base, y2 + base) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint N, M, X[5010], Y[5010];\n\nint compress(int *p, vector<int> &s) {\n  REP(i, 0, N) s.push_back(p[i]);\n  sort(s.begin(), s.end());\n  s.erase(unique(s.begin(), s.end()), s.end());\n  REP(i, 0, N) p[i] = find(s.begin(), s.end(), p[i]) - s.begin();\n  return s.size();\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n  vector<int> sx, sy;\n  int w = compress(X, sx);\n  int h = compress(Y, sy);\n\n  int sum[h + 1][w + 1];\n  REP(i, 0, h + 1) REP(j, 0, w + 1) sum[i][j] = 0;\n  REP(i, 0, N) sum[Y[i] + 1][X[i] + 1]++;\n  REP(i, 0, h) REP(j, 0, w + 1) sum[i + 1][j] += sum[i][j];\n  REP(i, 0, h + 1) REP(j, 0, w) sum[i][j + 1] += sum[i][j];\n\n  REP(i, 0, M) {\n    int lx, rx, ly, ry;\n    cin >> lx >> ly >> rx >> ry;\n    int vlx = lower_bound(sx.begin(), sx.end(), lx) - sx.begin();\n    int vly = lower_bound(sy.begin(), sy.end(), ly) - sy.begin();\n    int vrx = upper_bound(sx.begin(), sx.end(), rx) - sx.begin();\n    int vry = upper_bound(sy.begin(), sy.end(), ry) - sy.begin();\n    cout << (sum[vry][vrx] - sum[vry][vlx] - sum[vly][vrx] + sum[vly][vlx]) << endl;;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    VI xs(x), ys(y);\n    sort(xs.begin(),xs.end());\n    sort(ys.begin(),ys.end());\n    xs.erase(unique(xs.begin(),xs.end()), xs.end());\n    ys.erase(unique(ys.begin(),ys.end()), ys.end());\n    REP(i,n){\n        x[i] = find(xs.begin(),xs.end(),x[i]) - xs.begin();\n        y[i] = find(ys.begin(),ys.end(),y[i]) - ys.begin();\n    }\n    int w = xs.size(), h = ys.size();\n    VVI s(w+1, VI(h+1));\n    REP(i,n) s[x[i]+1][y[i]+1]++;\n    REP(i,w) REP(j,h+1) s[i+1][j] += s[i][j];\n    REP(j,h) REP(i,w+1) s[i][j+1] += s[i][j];\n\n    while (m--){\n        int x1, x2, y1, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        x1 = lower_bound(xs.begin(),xs.end(),x1) - xs.begin();\n        x2 = upper_bound(xs.begin(),xs.end(),x2) - xs.begin();\n        y1 = lower_bound(ys.begin(),ys.end(),y1) - ys.begin();\n        y2 = upper_bound(ys.begin(),ys.end(),y2) - ys.begin();\n        int ans = s[x2][y2] - s[x1][y2] - s[x2][y1] + s[x1][y1];\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[6000], Y[6000];\nint X1[6000], X2[6000], Y1[6000], Y2[6000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nsigned main() {\n\tscanf(\"%lld%lld\", &n, &m);\n\trep(i, n)scanf(\"%lld%lld\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%lld%lld%lld%lld\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\tif (n < 0)abort();\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (long long j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (long long i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m; cin >> n >> m;\n\tint tx[5000]; int ty[5000];\n\tint s[500000][4];\n\tvector<int> xs; vector<int>ys;\n\trep(i, n) {\n\t\tcin >> tx[i] >> ty[i];\n\t\txs.push_back(tx[i]);\n\t\tys.push_back(ty[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\trep(i, m) {\n\t\trep(j, 4) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t\ts[i][0] = lower_bound(xs.begin(), xs.end(), s[i][0]) - xs.begin();\n\t\ts[i][1] = lower_bound(ys.begin(), ys.end(), s[i][1]) - ys.begin();\n\t\ts[i][2] = upper_bound(xs.begin(), xs.end(), s[i][2]) - xs.begin(); s[i][2]--;\n\t\ts[i][3] = upper_bound(ys.begin(), ys.end(), s[i][3]) - ys.begin(); s[i][3]--;\n\t}\n\trep(i, n) {\n\t\ttx[i] = find(xs.begin(), xs.end(), tx[i]) - xs.begin();\n\t\tty[i] = find(ys.begin(), ys.end(), ty[i]) - ys.begin();\n\t}\n\tint dp[5000][5000] = {};\n\trep(i, n) {\n\t\tdp[tx[i]][ty[i]]++;\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[0][0] = dp[0][0];\n\t\t\t}\n\t\t\telse if (i == 0) {\n\t\t\t\tdp[0][j] += dp[0][j - 1];\n\t\t\t}\n\t\t\telse if (j == 0) {\n\t\t\t\tdp[i][0] += dp[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint sx = s[i][0]; int sy = s[i][1]; int gx = s[i][2]; int gy = s[i][3];\n\t\tint cnt;\n\t\tif (sx >= n || sy >= n || gx < 0 || gy < 0) {\n\t\t\tcnt = 0;\n\t\t}\n\t\telse if (sx > 0 && sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy] - dp[gx][sy - 1] + dp[sx - 1][sy - 1];\n\t\t}\n\t\telse if (sx > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy];\n\t\t}\n\t\telse if (sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[gx][sy - 1];\n\t\t}\n\t\telse {\n\t\t\tcnt = dp[gx][gy];\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    \n    vector<int> A(n*n, 0);\n    vector<int> x(n);\n    vector<int> y(n);\n    vector<int> xb(m);\n    vector<int> yb(m);\n    vector<int> xe(m);\n    vector<int> ye(m);\n    vector<int> xs;\n    vector<int> ys;\n    \n    for(int j = 0; j < n; j++)\n        cin >> x[j] >> y[j];\n    \n    for(int i = 0; i < m; i++)\n        cin >> xb[i] >> yb[i] >> xe[i] >> ye[i];\n    \n    xs = x;\n    ys = y;\n    sort( xs.begin(), xs.end() );\n    sort( ys.begin(), ys.end() );\n    xs.erase( unique( xs.begin(), xs.end() ), xs.end() );\n    ys.erase( unique( ys.begin(), ys.end() ), ys.end() );\n    \n    for(int j = 0; j < n; j++){\n        x[j] = find( xs.begin(), xs.end(), x[j] ) - xs.begin();\n        y[j] = find( ys.begin(), ys.end(), y[j] ) - ys.begin();\n    }\n    \n    for(int i = 0; i < m; i++){\n        xb[i] = lower_bound( xs.begin(), xs.end(), xb[i] ) - xs.begin();\n        yb[i] = lower_bound( ys.begin(), ys.end(), yb[i] ) - ys.begin();\n        xe[i] = upper_bound( xs.begin(), xs.end(), xe[i] ) - xs.begin() - 1;\n        ye[i] = upper_bound( ys.begin(), ys.end(), ye[i] ) - ys.begin() - 1;\n    }\n    \n    \n    \n    for(int j = 0; j < n; j++){\n        A[ n*y[j] + x[j] ] += 1;\n    }\n    \n    for(int j = 0; j < n; j++){\n        for(int k = 1; k < n; k++){\n            A[n*j+k] += A[n*j+k-1];\n        }\n    }\n    for(int k = 0; k < n; k++){\n        for(int j = 1; j < n; j++){\n            A[n*j+k] += A[n*(j-1)+k];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        int a, b, c;\n        c = A[ n*(yb[i]-1) + (xb[i]-1) ];\n        if(xb[i] > 0)\n            a = A[ n*ye[i] + (xb[i]-1) ];\n        else\n            c = a = 0;\n        if(yb[i] > 0)\n            b = A[ n*(yb[i]-1) + xe[i] ];\n        else\n            c = b = 0;\n        cout << A[ n*ye[i] + xe[i] ] - a - b + c <<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint tx[5000],ty[5000],sx,sy,gx,gy, n, m, count, i, j;\n\twhile(1){\n\t\tscanf(\"%d%d\",&n,&m);\n\t\tfor(i = 0;i < n;i++)\n\t\t\tscanf(\"%d%d\",&tx[i],&ty[i]);\n\t\tfor(i = 0;i < m;i++){\n\t\t\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\t\t\tcount = 0;\n\t\t\tfor(j = 0;j < n;j++)\n\t\t\t\tif(sx <= tx[j] && sy <= ty[j] && gx >= tx[j] && gy >= ty[j]) count++;\n\t\t\tprintf(\"%d\\n\",count);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main(){\n\tint n,m;cin >> n >> m;\n\tvector<pair<int,int>> v;\n\tREP(i,n){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tsort(ALL(v));\n\tint a,b,c,d;\n\tint ans;\n\t\n\tREP(i,m){\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tint st = (lower_bound(ALL(v),MP(a,-1000000000)) - v.begin());\n\t\tans = 0;\n\t\tfor(int i = st;i < n;i++){\n\t\t\tif(v[i].FI > c)break;\n\t\t\tif(v[i].SE >= b && v[i].SE <= d)ans++;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(x,a,b) ((a)<=(x)&&(x)<=(b))\nusing namespace std;\nint grid[5000][2];\nint main(){\n  int n, m;\n  scanf(\"%d%d\", &n, &m);\n  rep(i, n){\n    scanf(\"%d%d\", &grid[i][0], &grid[i][1]);\n  }\n  int x1, y1, x2, y2;\n  rep(i, m){\n    int res = 0;\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n    rep(j, n)\n      if(between(grid[j][0], x1, x2) && between(grid[j][0], y1, y2))\n\tres++;\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n//#define INF 100000000\n//#define MOD (int) (1e9+7)\n#define rep(i, a) for (int i = 0; i < (a); i++)\nusing namespace std;\n\n/*\nconst int MAX = 1000000;\nconst int MOD = 1000000007;\n\nlong long fac[MAX], finv[MAX], inv[MAX];\n\n//テーブルの前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        //そのまま計算すると負の値になるのでMODを足す\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n\n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n\n//UnionFind木\nstruct UnionFind{\n   vector<long long int> par; //par[i] : iの親の番号\n   vector<long long int> rnk; //root[i] : iの木のサイズ\n\n   //コンストラクタ\n   UnionFind(long long int n): par(n), rnk(n){\n       //木の初期化\n       for(long long int i = 0; i < n; i++){\n           par[i] = i;\n           rnk[i] = 1;\n       }\n   }\n\n   //データxが属する木の根を再帰で取得\n   long long int root(long long int x){\n       if(par[x] == x){\n           return x;\n       }else{\n           return par[x] = root(par[x]);\n       }\n   }\n\n   //xとyが同じ木に属しているかを判定\n   bool same(long long int x, long long int y){\n       return root(x) == root(y);\n   }\n\n   //xとyの木を併合\n   void unite(long long int x, long long int y){\n       long long int rx = root(x); //xの根\n       long long int ry = root(y); //yの根\n       if(rx == ry) return; //根が同じならそのまま\n\n       //併合するときにサイズを足し合わせる\n       if(rnk[rx] < rnk[ry]){\n           par[rx] = ry;\n           rnk[ry] += rnk[rx];\n       }else{\n           par[ry] = rx;\n           rnk[rx] += rnk[ry];\n       }\n   }\n\n   //属している木のサイズを取得\n   long long int size(long long int x){\n       return rnk[root(x)];\n   }\n};\n*/\n\nint field[5010][5010];\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    vector<int> xs(n+2), ys(n+2);\n\n    //端の点を追加\n    xs[n] = 1000000001;\n    xs[n+1] = -1000000001;\n    ys[n] = 1000000001;\n    ys[n+1] = -1000000001;\n\n    //宝の埋まっている座標\n    vector<int> x(n), y(n);\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n        xs[i] = x[i];\n        ys[i] = y[i];\n    }\n\n    //座標圧縮\n    sort(xs.begin(), xs.end());\n    sort(ys.begin(), ys.end());\n\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n    int H = ys.size()+1;\n    int W = xs.size()+1;\n\n    for(int i = 0; i < 5010; i++){\n        for(int j = 0; j < 5010; j++){\n            field[i][j] = 0;\n        }\n    }\n\n    //宝のある位置に1を足す\n    for(int i = 0; i < n; i++){\n        int xx = lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin();\n        int yy = lower_bound(ys.begin(), ys.end(), y[i]) - ys.begin();\n\n        field[yy+1][xx+1] += 1;\n    }\n\n    //二次元累積和\n    for(int i = 0; i < H; i++){\n        for(int j = 1; j < W; j++){\n            field[i][j] += field[i][j-1];\n        }\n    }\n    for(int i = 1; i < H; i++){\n        for(int j = 0; j < W; j++){\n            field[i][j] += field[i-1][j];\n        }\n    }\n\n    //長方形領域に対して宝の和を求める\n    for(int i = 0; i < m; i++){\n        int recx1, recy1, recx2, recy2;\n        cin >> recx1 >> recy1 >> recx2 >> recy2;\n        int xx1 = lower_bound(xs.begin(), xs.end(), recx1) - xs.begin();\n        int yy1 = lower_bound(ys.begin(), ys.end(), recy1) - ys.begin();\n        int xx2 = upper_bound(xs.begin(), xs.end(), recx2) - xs.begin()-1;\n        int yy2 = upper_bound(ys.begin(), ys.end(), recy2) - ys.begin()-1;\n\n        cout << field[yy2+1][xx2+1] - field[yy1][xx2+1] - field[yy2+1][xx1] + field[yy1][xx1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> xy_t;\n\nint main() {\n\n\tint N, M, x1, y1, x2, y2;\n\txy_t T[5000], A1[500000], A2[500000];\n\t\n\tcin >> N >> M;\n\t\n\tfor ( int i = 0; i < N; i++ ) {\n\t\n\t\tcin >> x1 >> y1;\n\n\t\tT[i] = xy_t( x1, y1 );\n\t\n\t}\n\t\n\tfor ( int i = 0; i < M; i++ ) {\n\t\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\tA1[i] = xy_t( x1, y1 );\n\t\tA2[i] = xy_t( x2, y2 );\n\t\n\t}\n\t\n\tfor ( int i = 0; i < M; i++ ) {\n\t\n\t\tint count = 0;\n\t\n\t\tfor ( int j = 0; j < N; j++ ) {\n\t\t\n\t\t\tif ( A1[i].real() <= T[j].real() && T[j].real() <= A2[i].real() && A1[i].imag() <= T[j].imag() && T[j].imag() <= A2[i].imag() ) { count++; }\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << count << endl;\n\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define X first\n#define Y second\n\nusing namespace std;\n\nint n, m;\nvector<int> vx, vy;\nint tx[5005], ty[5005], unzipx[5005], unzipy[5005], imos[5005][5005];\nmap<int, int> zipx, zipy;\npair< pair<int,int>, pair<int,int> > p[500005];\n\nint main() {\n  cin>>n>>m;\n  REP(i,0,n){\n    cin>>tx[i]>>ty[i];\n    vx.push_back(tx[i]);\n    vy.push_back(ty[i]);\n  }\n  REP(i,0,m){\n    cin>>p[i].F.X>>p[i].F.Y>>p[i].S.X>>p[i].S.Y;\n  }\n\n  //compression\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  //vx.erase(.unique(vx.begin(), vx.end()), vx.end());\n  //vy.erase(unique(vy.begin(), vy.end()), vy.end());\n  REP(i,0,vx.size()){\n    zipx[vx[i]] = i;\n    unzipx[i] = vx[i];\n  }\n  REP(i,0,vy.size()){\n    zipy[vy[i]] = i;\n    unzipy[i] = vy[i];\n  }\n\n  //Initializing imos array\n  REP(i,0,5005)REP(j,0,5005) imos[i][j] = 0;\n  REP(i,0,n){\n    imos[zipy[ty[i]]][zipx[tx[i]]]++;\n  }\n  //creating imos array\n  REP(i,0,vy.size()){\n    REP(j,1,vx.size()){\n      imos[i][j] += imos[i][j-1];\n    }\n  }\n  REP(j,0,vx.size()){\n    REP(i,1,vy.size()){\n      imos[i][j] += imos[i-1][j];\n    }\n  }\n\n  REP(i,0,m){\n    /*\n    cout<<\"xSize:\"<<vx.size()<<\", \"<<\"ySize:\"<<vx.size()<<endl;\n    cout<<\"test: \"<<(lower_bound(vx.begin(),vx.end(),p[i].F.X)-vx.begin())<<\" \";\n    cout<<(lower_bound(vy.begin(),vy.end(),p[i].F.Y)-vy.begin())<<\" \";\n    cout<<(lower_bound(vx.begin(),vx.end(),p[i].S.X)-vx.begin())<<\" \";\n    cout<<(lower_bound(vy.begin(),vy.end(),p[i].S.Y)-vy.begin())<<endl;\n    */\n    vector<int>::iterator a1x = lower_bound(vx.begin(),vx.end(),p[i].F.X),\n      a1y = lower_bound(vy.begin(),vy.end(),p[i].F.Y),\n      a2x = upper_bound(vx.begin(),vx.end(),p[i].S.X)-1,\n      a2y = upper_bound(vy.begin(),vy.end(),p[i].S.Y)-1;\n    int z1x = zipx[*a1x], z1y = zipy[*a1y], z2x = zipx[*a2x], z2y = zipy[*a2y];\n    int ans = imos[z2y][z2x];\n    if(z1y > 0) ans -= imos[z1y-1][z2x];\n    if(z1x > 0) ans -= imos[z2y][z1x-1];\n    if(z1y > 0 && z1x > 0) ans += imos[z1y-1][z1x-1];\n\n    if(p[i].F.Y > unzipy[vy.size()-1] || p[i].F.X > unzipx[vx.size()-1]) cout<<0<<endl;\n    else if(p[i].S.Y < unzipy[0] || p[i].S.X < unzipx[0]) cout<<0<<endl;\n    else cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#define REP(i, a, n) for(int i = ((int) a); i < ((int) n); i++)\nusing namespace std;\n\nint N, M, X[5010], Y[5010];\n\nint compress(int *p, vector<int> &s) {\n  REP(i, 0, N) s.push_back(p[i]);\n  sort(s.begin(), s.end());\n  s.erase(unique(s.begin(), s.end()), s.end());\n  REP(i, 0, N) p[i] = find(s.begin(), s.end(), p[i]) - s.begin();\n  return s.size();\n}\n\nint main(void) {\n  cin >> N >> M;\n  REP(i, 0, N) cin >> X[i] >> Y[i];\n  vector<int> sx, sy;\n  int w = compress(X, sx);\n  int h = compress(Y, sy);\n\n  int **sum = (int**) malloc((h + 1) * sizeof(int*));\n  REP(i, 0, h + 1) sum[i] = (int*) malloc((w + 1) * sizeof(int));\n  REP(i, 0, h + 1) REP(j, 0, w + 1) sum[i][j] = 0;\n  REP(i, 0, N) sum[Y[i] + 1][X[i] + 1]++;\n  REP(i, 0, h) REP(j, 0, w + 1) sum[i + 1][j] += sum[i][j];\n  REP(i, 0, h + 1) REP(j, 0, w) sum[i][j + 1] += sum[i][j];\n\n  REP(i, 0, M) {\n    int lx, rx, ly, ry;\n    cin >> lx >> ly >> rx >> ry;\n    int vlx = lower_bound(sx.begin(), sx.end(), lx) - sx.begin();\n    int vly = lower_bound(sy.begin(), sy.end(), ly) - sy.begin();\n    int vrx = upper_bound(sx.begin(), sx.end(), rx) - sx.begin();\n    int vry = upper_bound(sy.begin(), sy.end(), ry) - sy.begin();\n    cout << (sum[vry][vrx] - sum[vry][vlx] - sum[vly][vrx] + sum[vly][vlx]) << endl;;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[5000], Y[5000];\nint X1[5000], X2[5000], Y1[5000], Y2[5000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn v.size();\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\tbool flag = true;\n\trep(i, m) {\n\t\tflag = false;\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\tif (flag)abort();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[5000], Y[5000];\nint X1[5000], X2[5000], Y1[5000], Y2[5000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn v.size();\n}\nsigned main() {\n\tscanf(\"%lld%lld\", &n, &m);\n\trep(i, n)scanf(\"%lld%lld\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%lld%lld%lld%lld\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint mp[5005][5005],n,m;\nvector<int> x,y;\n// O(n * log n ) n=v.size()\nvector<int> compress(vector<int> v){\n  // v = {4,6,7,1,1,6}\n  //   -> res={1,2,3,0,0,2}\n\n  vector<int> copy=v;\n\n  sort(v.begin(), v.end());\n  v.erase( unique( v.begin(), v.end()) , v.end() );\n\n  vector<int> res;\n  for(int i=0;i<(int)copy.size();i++){\n    int num=lower_bound( v.begin(),v.end(), copy[i] ) - v.begin();\n    res.push_back( num );\n  }\n  return res;\n}\n\nint sum(int sx,int sy,int gx,int gy){\n  sx--,sy--;\n  if(gx<0||gy<0)return 0;\n  int res=mp[gx][gy];\n  \n  if(sx>=0)  res-=mp[sx][gy];\n\n  if(sy>=0) res-=mp[gx][sy];\n\n  if(sx>=0&&sy>=0) res+=mp[sx][sy];\n\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  x.resize(n),y.resize(n);\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  vector<int> X,Y;\n  X=compress(x),Y=compress(y);\n  for(int i=0;i<n;i++)mp[X[i]][Y[i]]++;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)mp[i][j+1]+=mp[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)mp[j+1][i]+=mp[j][i];\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  x.erase( unique( x.begin(), x.end()) , x.end() );\n  y.erase( unique( y.begin(), y.end()) , y.end() );\n  while(m--){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    int sx=lower_bound(x.begin(),x.end(),a)-x.begin();\n    int sy=lower_bound(y.begin(),y.end(),b)-y.begin();\n    int gx=upper_bound(x.begin(),x.end(),c)-x.begin()-1;\n    int gy=upper_bound(y.begin(),y.end(),d)-y.begin()-1;\n    cout<<sum(sx,sy,gx,gy)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint dp[5002][5002];\n\nmap<int,int> make_zip(vector<int> v) {\n    map<int,int> ret;\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    for (int i=0; i<(int)v.size(); ++i) {\n        ret[v[i]] = i+1;\n    }\n    return ret;\n}\n\nint compress(map<int,int> &zip, int x, bool upper=true) {\n    auto it = zip.lower_bound(x);\n    if (it != zip.end() && it->first == x) return it->second;\n    if (upper) {\n        if (it == zip.end()) return -1;\n        return it->second;\n    } else {\n        if (it == zip.end()) return zip.rbegin()->second;\n        else if (it == zip.begin()) return -1;\n        return (--it)->second;\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n), y(n);\n    for (int i=0; i<n; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    auto xzip = make_zip(x);\n    auto yzip = make_zip(y);\n    for (int i=0; i<n; ++i) {\n        int ty = compress(yzip, y[i]);\n        int tx = compress(xzip, x[i]);\n        dp[ty][tx] ++;\n    }\n    for (int i=0; i<5001; ++i) {\n        for (int j=0; j<5001; ++j) {\n            dp[i+1][j+1] += dp[i+1][j] + dp[i][j+1] - dp[i][j];\n        }\n    }\n\n    for (int i=0; i<m; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = compress(xzip, x1, true);\n        y1 = compress(yzip, y1, true);\n        x2 = compress(xzip, x2, false);\n        y2 = compress(yzip, y2, false);\n        if (x1 < 0 || y1 < 0 || x2 < 0 || y2 < 0) {\n            cout << 0 << endl;\n        } else {\n            int cnt = dp[y2][x2] - dp[y1-1][x2] - dp[y2][x1-1] + dp[y1-1][x1-1];\n            cout << cnt << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9+10;\n\nint dp[5010][5010];\nint exist[5010][5010];\nint main(){\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n  vector<PII> ps(N);\n  VI xs(N), ys(N);\n  // x??§?¨???¨y??§?¨??????\\??????????????????\n  REP(i,N){\n\tscanf(\"%d %d\", &ps[i].first, &ps[i].second);\n\txs[i] = ps[i].first, ys[i] = ps[i].second;\n  }\n  xs.PB(-INF), xs.PB(INF);\n  ys.PB(-INF), ys.PB(INF);\n  SORT(xs); SORT(ys);\n\n  // x -> x', 0 <= x' < N+2\n  map<int,int> compX, compY;\n  int MX = 0;\n  REP(i,N+2)\n\tif(!compX.count(xs[i])){\n\t  compX[xs[i]] = MX++;\n\t}\n  int MY = 0;\n  REP(i,N+2)\n\tif(!compY.count(ys[i])){\n\t  compY[ys[i]] = MY++;\n\t}\n\n  REP(i,N){\n\t++exist[compY[ps[i].second]][compX[ps[i].first]];\n  }\n  for(int y=0;y<MY;++y)\n\tfor(int x=0;x<MX;++x)\n\t  dp[y][x] = (y>0? dp[y-1][x]:0) + (x>0?dp[y][x-1]:0) - (y>0&&x>0? dp[y-1][x-1]:0) + exist[y][x];\n\n  while(M--){\n\tint sx, sy, ex, ey;\n\tscanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n\tint sxi = compX.lower_bound(sx)->second;\n\tint syi = compY.lower_bound(sy)->second;\n\tauto it = compX.upper_bound(ex); --it;\n\tint exi = it->second;\n\tit = compY.upper_bound(ey); --it;\n\tint eyi = it->second;\n\n\tint ans = dp[eyi][exi] - (sxi>0?dp[eyi][sxi-1]:0) - (syi>0?dp[syi-1][exi]:0) + (syi>0&&sxi>0? dp[syi-1][sxi-1]:0);\n\tprintf(\"%d\\n\", ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nint tr_2d[5000][5000];\nint s[5002][5002];\n\nmap<int,int> zip_x,zip_y;\nint unzip_x[5000],unzip_y[5000];\n\npair<int,int> compress(vector<int> &x, vector<int> &y){\n// zipで座標->index\n// unzipでindex->座標\n// x,yは書き換えられるので注意\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  rep(i,x.size()){\n    zip_x[x[i]] = i;\n    unzip_x[i] = x[i];\n  }\n  rep(i,y.size()){\n    zip_y[y[i]] = i;\n    unzip_y[i] = y[i];\n  }\n  return make_pair(x.size(),y.size());\n}\n\nvoid Imos2D(int n){\n  rep(i,n+1)rep(j,n+1)s[i+1][j+1]=tr_2d[i][j];\n  rep(i,n+1)rep(j,n)s[i][j+1]+=s[i][j];\n  rep(i,n)rep(j,n+1)s[i+1][j]+=s[i][j];\n}\n\nint sum(int xl,int xr,int yd,int yu){\n  return s[xr][yu]-s[xl][yu]+s[xl][yd]-s[xr][yd];\n}\n\nsigned main(){\n\n  int n,m;\n  cin>>n>>m;\n  vector<int> tr_x(n),tr_x2(n),tr_y(n),tr_y2(n);\n  rep(i,n){\n    rep(j,n){\n      tr_2d[i][j]=0;\n    }\n  }\n\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    tr_x[i] = x;\n    tr_x2[i] = x;\n    tr_y[i] = y;\n    tr_y2[i] = y;\n  }\n  //座圧\n  pair<int,int> size=compress(tr_x2,tr_y2);\n  // cout<<size.first<<size.second<<endl;\n  rep(i,n){\n    int id_x = zip_x[tr_x[i]];\n    int id_y = zip_y[tr_y[i]];\n    tr_2d[id_x][id_y]++;\n  }\n  // rep(i,n){\n  //   rep(j,n-1){\n  //     cout<<tr_2d[i][j]<<\" \";\n  //   }\n  //   cout<<tr_2d[i][n-1]<<endl;\n  // }\n\n  //2次元累積和\n  rep(i,n)rep(j,n)s[i][j]=0;\n  Imos2D(n);\n  // rep(i,n+1){\n  //   rep(j,n){\n  //     cout<<s[i][j]<<\" \";\n  //   }\n  //   cout<<s[i][n]<<endl;\n  // }\n\n  rep(i,m){\n    int xl,xr,yd,yu;\n    cin>>xl>>yd>>xr>>yu;\n    auto ixl = lower_bound(unzip_x,unzip_x+size.first,xl)-unzip_x;\n    auto ixr = upper_bound(unzip_x,unzip_x+size.first,xr)-unzip_x-1;\n    auto iyd = lower_bound(unzip_y,unzip_y+size.second,yd)-unzip_y;\n    auto iyu = upper_bound(unzip_y,unzip_y+size.second,yu)-unzip_y-1;\n    // cout << xl<<\" \"<<xr<<\" : \"<<ixl<< \" \" <<ixr<<endl;\n    // cout << yd<<\" \"<<yu<<\" : \"<<iyd<< \" \" <<iyu<<endl;\n    cout << sum(ixl,ixr+1,iyd,iyu+1)<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[5555], sy[5555];\nint tx[5555], ty[5555];\nint vx[5555];\nint vy[5555];\nint bit[5555][5555];\n\nvoid add(int a, int b, int w)\n{\n  for(int x = a; x <= 6 * n; x += x & -x){\n    for(int y = b; y <= 6 * n; y += y & -y){\n      bit[x][y] += w;\n    }\n  }\n}\n\nint sum(int a, int b)\n{\n  int ret = 0;\n  for(int x = a; x > 0; x -= x & -x){\n    for(int y = b; y > 0; y -= y & -y){\n      ret += bit[x][y];\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n  \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);  x.pb(sx[i]);  x.pb(tx[i]);\n    y.pb(vy[i]);  y.pb(sy[i]);  y.pb(ty[i]);\n  }\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin() + 1;\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin() + 1;\n  }\n  rep(i, m){\n    sx[i] = lower_bound(ALL(x), sx[i]) - x.begin() + 1;\n    sy[i] = lower_bound(ALL(y), sy[i]) - y.begin() + 1;\n    tx[i] = lower_bound(ALL(x), tx[i]) - x.begin() + 1;\n    ty[i] = lower_bound(ALL(y), ty[i]) - y.begin() + 1;\n  }\n  rep(i, n) add(vx[i], vy[i], 1);\n\n  rep(i, m){\n    int ret = 0;\n    ret += sum(tx[i], ty[i]);\n    ret += sum(sx[i] - 1, sy[i] - 1);\n    ret -= sum(sx[i] - 1, ty[i]);\n    ret -= sum(tx[i], sy[i] - 1);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint mp[5005][5005],n,m;\nvector<int> x,y;\n// O(n * log n ) n=v.size()\nvector<int> compress(vector<int> v){\n  // v = {4,6,7,1,1,6}\n  //   -> res={1,2,3,0,0,2}\n\n  vector<int> copy=v;\n\n  sort(v.begin(), v.end());\n  v.erase( unique( v.begin(), v.end()) , v.end() );\n\n  vector<int> res;\n  for(int i=0;i<(int)copy.size();i++){\n    int num=lower_bound( v.begin(),v.end(), copy[i] ) - v.begin();\n    res.push_back( num );\n  }\n  return res;\n}\n\nint sum(int sx,int sy,int gx,int gy){\n  sx--,sy--;\n  int res=mp[gx][gy];\n\n  if(sx>=0)  res-=mp[sx][gy];\n\n  if(sy>=0) res-=mp[gx][sy];\n\n  if(sx>=0&&sy>=0) res+=mp[sx][sy];\n\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  x.resize(n),y.resize(n);\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  vector<int> X,Y;\n  X=compress(x),Y=compress(y);\n  for(int i=0;i<n;i++)mp[X[i]][Y[i]]++;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)mp[i][j+1]+=mp[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)mp[j+1][i]+=mp[j][i];\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  x.erase( unique( x.begin(), x.end()) , x.end() );\n  y.erase( unique( y.begin(), y.end()) , y.end() );\n  while(m--){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    int sx=lower_bound(x.begin(),x.end(),a)-x.begin();\n    int sy=lower_bound(y.begin(),y.end(),b)-y.begin();\n    int gx=upper_bound(x.begin(),x.end(),c)-x.begin()-1;\n    int gy=upper_bound(y.begin(),y.end(),d)-y.begin()-1;\n    cout<<sum(sx,sy,gx,gy)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()) {\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t) {\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nint h, w;\n\nbool inside(int y, int x) {\n\treturn 0 <= y && y < h && 0 <= x && x < w;\n}\n\n\nvoid mainmain() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pll> v(n);\n\tvll x;\n\tvll y;\n\trep(i, n) {\n\t\tcin >> v[i].S >> v[i].F;\n\t\ty.PB(v[i].F);\n\t\tx.PB(v[i].S);\n\t}\n\ty.PB(-INFL);\n\ty.PB(INFL);\n\tx.PB(-INFL);\n\tx.PB(INFL);\n\tsort(ALL(y));\n\ty.erase(unique(ALL(y)), y.end());\n\tsort(ALL(x));\n\tx.erase(unique(ALL(x)), x.end());\n\th = y.size();\n\tw = x.size();\n\tvvint vv;\n\tinitvv(vv, y.size(), x.size());\n\tvvint sum = vv;\n\trep(i, n) {\n\t\tint yy = lower_bound(ALL(y), v[i].F) - y.begin();\n\t\tint xx = lower_bound(ALL(x), v[i].S) - x.begin();\n\t\tvv[yy][xx]++;\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tint a = (inside(i - 1, j) ? sum[i - 1][j] : 0);\n\t\t\tint b = (inside(i, j - 1) ? sum[i][j - 1] : 0);\n\t\t\tint c = (inside(i - 1, j - 1) ? sum[i - 1][j - 1] : 0);\n\t\t\tsum[i][j] = a + b - c + vv[i][j];\n\t\t}\n\t}\n\trep(i, m) {\n\t\tll a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint bb = lower_bound(ALL(y), b) - y.begin();\n\t\tint aa = lower_bound(ALL(x), a) - x.begin();\n\t\tint dd = upper_bound(ALL(y), d) - y.begin();\n\t\tdd--;\n\t\tint cc = upper_bound(ALL(x), c) - x.begin();\n\t\tcc--;\n\t\t// cout << aa << \" \" << bb << \" \" << cc << \" \" << dd << endl;\n\t\tll ans = sum[dd][cc];\n\t\tif(inside(bb - 1, cc)) ans -= sum[bb - 1][cc];\n\t\tif(inside(dd, aa - 1)) ans -= sum[dd][aa - 1];\n\t\tif(inside(bb-a, aa - 1)) ans += sum[bb - 1][aa - 1];\n\t\tcout << ans << endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(20);\n\tmainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,m,n) for(int i=(m);i<(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define pb push_back\n#define mp make_pair\n#define all(c) (c).begin(),(c).end()\n#define rall(c) (c).rbegin(),(c).rend()\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst ll inf=1e9+7;\nconst ll mod=998244353;\nint main(){\n  ll n,m;cin>>n>>m;\n  vector<ll>x(n);\n  vector<ll>y(n);\n  set<ll>xx;\n  set<ll>yy;\n  rep(i,n){\n    cin>>x[i]>>y[i];\n    xx.insert(x[i]);\n    yy.insert(y[i]);\n  }\n  xx.insert(inf);\n  yy.insert(inf);\n  xx.insert(-inf);\n  yy.insert(-inf);\n  ll h=xx.size();\n  ll w=yy.size();\n  vector<vector<ll> >g(h+2,vector<ll>(w+2));\n  ll i=0;\n  map<ll,ll>mpx;\n  map<ll,ll>mpy;\n  for(auto e:xx){\n    mpx[e]=i;\n    i++;\n  }\n  i=0;\n  for(auto e:yy){\n    mpy[e]=i;\n    i++;\n  }\n  rep(i,n){\n    g[mpx[x[i]]][mpy[y[i]]]++;\n  }\n  REP(i,1,h+1){\n    REP(j,1,w+1){\n      g[i][j]+=g[i][j-1];\n    }\n  }\n  REP(i,1,h+1){\n    REP(j,1,w+1){\n      g[i][j]+=g[i-1][j];\n    }\n  }\n  //cout<<endl;\n  REP(i,1,h+1){\n    REP(j,1,w+1){\n      //cout<<g[i][j]<<' ';\n    }\n    //cout<<endl;\n  }\n  rep(i,m){\n    ll a,b,c,d;\n    cin>>a>>b>>c>>d;\n    ll A=mpx[*xx.lower_bound(a)];\n    ll B=mpy[*yy.lower_bound(b)];\n    ll C=mpx[*xx.upper_bound(c)];\n    ll D=mpy[*yy.upper_bound(d)];\n    C--;\n    D--;\n    //cout<<A<<' '<<B<<' '<<C<<' '<<D<<endl;\n    cout<<g[C][D]+g[A-1][B-1]-g[A-1][D]-g[C][B-1]<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nstruct CumulativeSum2D\n{\n  vector< vector< int > > data;\n\n  CumulativeSum2D(int W, int H) : data(W + 1, vector< int >(H + 1, 0))\n  {\n  };\n\n  inline void add(int x, int y, int z)\n  {\n    ++x, ++y;\n    if(x >= data.size() || y >= data[0].size()) return;\n    data[x][y] += z;\n  }\n\n  void build()\n  {\n    for(int i = 1; i < data.size(); i++) {\n      for(int j = 1; j < data[i].size(); j++) {\n        data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];\n      }\n    }\n  }\n\n  inline int query(int sx, int sy, int gx, int gy)\n  {\n    return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n  }\n};\n\nint main()\n{\n  int N, M, X[5000], Y[5000];\n\n  scanf(\"%d %d\", &N, &M);\n  vector< int > xs, ys;\n  for(int i = 0; i < N; i++) {\n    scanf(\"%d %d\", &X[i], &Y[i]);\n    xs.push_back(X[i]);\n    ys.push_back(Y[i]);\n  }\n  sort(begin(xs), end(xs));\n  xs.erase(unique(begin(xs), end(xs)), end(xs));\n  sort(begin(ys), end(ys));\n  ys.erase(unique(begin(ys), end(ys)), end(ys));\n  CumulativeSum2D sum(xs.size(), ys.size());\n  for(int i = 0; i < N; i++) {\n    sum.add(lower_bound(begin(xs), end(xs), X[i]) - begin(xs),\n            lower_bound(begin(ys), end(ys), Y[i]) - begin(ys), 1);\n  }\n  sum.build();\n  for(int i = 0; i < M; i++) {\n    int x1, y1, x2, y2;\n    scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n    x1 = lower_bound(begin(xs), end(xs), x1) - begin(xs);\n    y1 = lower_bound(begin(ys), end(ys), y1) - begin(ys);\n    x2 = upper_bound(begin(xs), end(xs), x2) - begin(xs);\n    y2 = upper_bound(begin(ys), end(ys), y2) - begin(ys);\n    printf(\"%d\\n\", sum.query(x1, y1, x2, y2));\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\n\nvi compressed_x, compressed_y;\n\nint a[5005*6+2][5005*6+2];\n\nint main()\n{\n    cin >> n >> m;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        for (int d = -1; d <= 1; ++d) {\n            compressed_x.PB(x[i] + d);\n            compressed_y.PB(y[i] + d);\n        }\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = lower_bound(all(compressed_x), x2) - begin(compressed_x);\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = lower_bound(all(compressed_y), y2) - begin(compressed_y);\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2e9\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<int,int> P;\nP in[5002];\nint n,m;\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>in[i].x>>in[i].y;\n  sort(in,in+n);\n\n  int a,b,c,d;  \n  while(m--){\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    int cnt=0;\n    for(int i=0;i<n;i++){\n      if((a<=in[i].x&&in[i].x<=c)&&(b<=in[i].y&&in[i].y<=d))cnt++;\n    }\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_;\n\tstd::vector<std::vector<Type> > dat;\n\tstd::vector<std::vector<int> > vl;\n\tinline int query_(int a, int b, Type x, int k, int l, int r, int e) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r) and e integers below x in the range\n\t\tif (r <= a || b <= l || e == 0) return 0;\n\t\tif (a <= l && r <= b) return e;\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1, vl[k][e - 1]);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r, e - vl[k][e - 1]);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1);\n\t\tdat.resize(size_ << 1, std::vector<Type>());\n\t\tvl.resize(size_ << 1, std::vector<int>());\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdat[i + size_].push_back(*(begin_ + i));\n\t\t\tvl[i].push_back(1);\n\t\t}\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tvl[i].resize(dat[i].size());\n\t\t\tint cl = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][j - cl])) dat[i][j] = dat[i << 1][cl++];\n\t\t\t\telse dat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\tvl[i][j] = cl;\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\tint ptr = lower_bound(dat[1].begin(), dat[1].end(), x) - dat[1].begin();\n\t\treturn query_(l, r, x, 1, 0, size_, ptr);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint dp[5001][5001];\n\nint get(const set<int> &xs, const set<int> &ys, int x, int y) {\n    if (*xs.begin() > x || *ys.begin() > y) return 0;\n    int px = distance(xs.begin(), xs.lower_bound(x));\n    int py = distance(ys.begin(), ys.lower_bound(y));\n    if (xs.lower_bound(x) == xs.end() || *xs.lower_bound(x) != x) px--;\n    if (ys.lower_bound(y) == ys.end() || *ys.lower_bound(y) != y) py--;\n    //cout<<x<<\" \"<<y<<\" \"<<px<<\" \"<<py<<endl;\n    return dp[py][px];\n}\n\nint main() {\n    int n,m;\n    cin>>n>>m;\n    set<int> xs, ys;\n    vector<int> inx(n), iny(n);\n    for (int i=0; i<n; ++i) {\n        cin>>inx[i]>>iny[i];\n        xs.insert(inx[i]);\n        ys.insert(iny[i]);\n    }\n    map<int,int> xmap, ymap;\n    int cnt = 0;\n    for (set<int>::iterator x = xs.begin(); x != xs.end(); ++x) xmap[*x] = cnt++;\n    cnt = 0;\n    for (set<int>::iterator y = ys.begin(); y != ys.end(); ++y) ymap[*y] = cnt++;\n    for (int i=0; i<n; ++i)\n        dp[ymap[iny[i]]][xmap[inx[i]]] += 1;\n\n    const int ny = ys.size();\n    const int nx = xs.size();\n    for (int i=0; i<ny; ++i)\n        for (int j=0; j<nx; ++j) {\n            int r = i?dp[i-1][j]:0;\n            r += j?dp[i][j-1]:0;\n            r -= (i>0&&j>0)?dp[i-1][j-1]:0;\n            dp[i][j] += r;\n        }\n\n    for (int i=0; i<m; ++i) {\n        int x1,y1,x2,y2;\n        cin>>x2>>y2>>x1>>y1; x2--, y2--;\n        int ans = get(xs,ys,x1,y1) - get(xs,ys,x2,y1) - get(xs,ys,x1,y2) + get(xs,ys,x2,y2);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n// 0-indexed\ntemplate <class T>\nstruct SegmentTree {\n  // a,b,c: T, e:T(unit)\n  // abc = (ab)c = a(bc)\n  // ae = ea = a\n  int n;\n  T unit;\n  vector<vector<int>> dat;\n  SegmentTree(){};\n  void init(int newn) {\n    n = 1;\n    while(n < newn) n <<= 1;\n    dat.assign(n << 1, vector<int>());\n  }\n\n  void build(const vector<T> &v) {\n    int newn = v.size();\n    init(newn);\n    for(int i = 0; i < newn; ++i) dat[n + i] = {v[i].y};\n    for(int i = n - 1; i; --i) {\n      int lid = 0, rid = 0, lsize = dat[i << 1].size(),\n          rsize = dat[(i << 1) | 1].size();\n      for(int j = 0; j < lsize + rsize; ++j) {\n        if(lid < lsize && rid < rsize) {\n          if(dat[i << 1][lid] <= dat[(i << 1) | 1][rid])\n            dat[i].push_back(dat[i << 1][lid++]);\n          else\n            dat[i].push_back(dat[(i << 1) | 1][rid++]);\n        }\n        else if(lid < lsize)\n          dat[i].push_back(dat[i << 1][lid++]);\n        else\n          dat[i].push_back(dat[(i << 1) | 1][rid++]);\n      }\n    }\n  }\n  // [a,b)\n  int query(int a, int b, int d, int u) {\n    int ans = 0;\n    for(int l = a + n, r = b + n; l < r; l >>= 1, r >>= 1) {\n      if(l & 1) {\n        ans +=\n            upper_bound(dat[l].begin(), dat[l].end(), u) -\n            lower_bound(dat[l].begin(), dat[l].end(), d);\n        ++l;\n      }\n      if(r & 1) {\n        --r;\n        ans +=\n            upper_bound(dat[r].begin(), dat[r].end(), u) -\n            lower_bound(dat[r].begin(), dat[r].end(), d);\n      }\n    }\n    return ans;\n  }\n};\n\nstruct cod {\n  int x, y;\n};\nbool operator<(const cod &l, const cod &r) {\n  if(l.x != r.x) return l.x < r.x;\n  return l.y < r.y;\n}\n\nint n, m;\nvector<cod> v;\nSegmentTree<cod> seg;\n\nvoid solve();\n\nint main() {\n  cin >> n >> m;\n  v.resize(n);\n  for(int i = 0; i < n; ++i) cin >> v[i].x >> v[i].y;\n  sort(v.begin(), v.end());\n  seg.build(v);\n  for(int i = 0; i < m; ++i) {\n    int d, u, lid, rid;\n    cod l, r;\n    l.y = -1e9 - 1;\n    r.y = 1e9 + 1;\n    cin >> l.x >> d >> r.x >> u;\n    lid = lower_bound(v.begin(), v.end(), l) - v.begin();\n    rid = upper_bound(v.begin(), v.end(), r) - v.begin();\n    cout << seg.query(lid, rid, d, u) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <set>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cctype>\n#include <climits>\n#include <fstream>\n#include <bitset>\n#include <time.h>\n#include <assert.h>\n\n#define LL long long\n#define VI vector<int>\n#define VL vector<long long>\n#define FOR(i,a,b) for(int i= (a); i<((int)b); ++i)\n#define RFOR(i,a) for(int i=(a); i >= 0; --i)\n#define FOE(i,a) for(auto i : a)\n#define ALL(c) (c).begin(), (c).end()\n#define RALL(c) (c).rbegin(), (c).rend()\n#define DUMP(x)  cerr << #x << \" = \" << (x) << endl;\n#define SUM(x) std::accumulate(ALL(x), 0LL)\n#define MIN(v) *std::min_element(v.begin(), v.end())\n#define MAX(v) *std::max_element(v.begin(), v.end())\n#define EXIST(v,x) (std::find(v.begin(), v.end(), x) != v.end())\n#define BIT(n) (1LL<<(n))\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end());\n#define EPS 1e-14\n\nusing namespace std;\n\n\nclass Compress {\npublic:\n    vector<int> v;\n    map<int, int> rev;\n    \n    \n    // ??§?¨???§?????????\n    // v????????????????????????????´?\n    Compress(vector<int> vec) {\n        this->v = vec;\n        sort(this->v.begin(), this->v.end());\n        this->v.erase(unique(this->v.begin(), this->v.end()), this->v.end());\n        \n        for (int x : v) {\n            rev[this->zip(x)] = x;\n        }\n    }\n\n    int zip(int x) {\n        return lower_bound(ALL(this->v), x) - this->v.begin();\n    }\n    \n    int unzip(int x) {\n        return this->rev[x];\n    }\n};\n\n\n\n\nint main(int argc, char *argv[]) {\n    int N, M, X, Y;\n\n    cin >> N >> M;\n    vector<int> treasureX(N), treasureY(N);\n    FOR(i, 0, N) {\n        cin >> X >> Y;\n        treasureX[i] = X;\n        treasureY[i] = Y;\n    }\n\n    // ?????????????????§?¨???§???\n    Compress cx(treasureX);\n    Compress cy(treasureY);\n    \n    vector<vector<int>> field(5100, vector<int>(5100, 0));\n\n    // ??§???????????§?¨???§?´????????????¨???\n    FOR(i, 0, N) {\n        int x = cx.zip(treasureX[i]);\n        int y = cy.zip(treasureY[i]);\n        field[y+1][x+1]++;\n    }\n    FOR(i, 0, field.size() - 1) {\n        FOR(j, 0, field[0].size() - 1) {\n            field[i + 1][j + 1] += field[i + 1][j] + field[i][j + 1] - field[i][j];\n        }\n    }\n    \n    // ??§???????????§?¨???§????????¢??????????????°????¨????\n    FOR(i, 0, M){\n        int lx, ly, rx, ry;\n        cin >> lx >> ly >> rx >> ry;\n        lx = cx.zip(lx);\n        rx = cx.zip(rx + 1);\n        ly = cy.zip(ly);\n        ry = cy.zip(ry + 1);\n        std::cout << field[ry][rx] - field[ry][lx] - field[ly][rx] + field[ly][lx] << std::endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n// macro\n#define rep(i,n) for(i=0;i<n;i++)\n#define ll long long\n#define all(v) v.begin(), v.end()\n\n// code starts\nint main()\n{\n  int n,m;cin>>n>>m;\n  vector<int> x(n);\n  vector<int> y(n);\n  int i,j;\n  rep(i,n)cin>>x[i]>>y[i];\n  vector<int> xl(m);\n  vector<int> yu(m);\n  vector<int> xr(m);\n  vector<int> yd(m);\n  rep(i,m)cin>>xl[i]>>yu[i]>>xr[i]>>yd[i];\n  vector<int> xpress;\n  vector<int> ypress;\n  xpress=x;\n  ypress=y;\n  sort(all(xpress));\n  sort(all(ypress));\n  auto itx=unique(all(xpress));\n  xpress.erase(itx,xpress.end());\n  auto ity=unique(all(ypress));\n  ypress.erase(ity,ypress.end());\n  int nx=xpress.size();\n  int ny=ypress.size();\n  vector<vector<int>> fld(ny,vector<int>(nx,0));\n  rep(i,n)\n  {\n    auto xind=lower_bound(all(xpress),x[i])-xpress.begin();\n    auto yind=lower_bound(all(ypress),y[i])-ypress.begin();\n    fld[yind][xind]++;\n  }\n  rep(i,ny)\n  {\n    rep(j,nx)\n    {\n      if(i-1>=0&&j-1>=0)\n      {\n        fld[i][j]+=fld[i-1][j]+fld[i][j-1]-fld[i-1][j-1];\n      }\n      else if(i-1>=0)\n      {\n        fld[i][j]+=fld[i-1][j];\n      }\n      else if(j-1>=0)\n      {\n        fld[i][j]+=fld[i][j-1];\n      }\n    }\n  }\n  rep(i,m)\n  {\n    int xlind=lower_bound(all(xpress),xl[i]-1)-xpress.begin();\n    int xrind=lower_bound(all(xpress),xr[i])-xpress.begin();\n    int yuind=lower_bound(all(ypress),yu[i]-1)-ypress.begin();\n    int ydind=lower_bound(all(ypress),yd[i])-ypress.begin();\n    if(!binary_search(all(xpress),xl[i]-1))xlind--;\n    if(!binary_search(all(xpress),xr[i]))xrind--;\n    if(!binary_search(all(ypress),yu[i]-1))yuind--;\n    if(!binary_search(all(ypress),yd[i]))ydind--;\n    int ans=0;\n    if(ydind>=0&&xrind>=0)ans+=fld[ydind][xrind];\n    if(yuind>=0&&xrind>=0)ans-=fld[yuind][xrind];\n    if(ydind>=0&&xlind>=0)ans-=fld[ydind][xlind];\n    if(yuind>=0&&xlind>=0)ans+=fld[yuind][xlind];\n    cout<<ans<<endl;\n  }\n\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n//typedef\n//-------------------------#include <bits/stdc++.h>\n \nconst double pi = 3.141592653589793238462643383279;\n \n \nusing namespace std;\n \n//conversion\n//------------------------------------------\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ninline int readInt() { int x; scanf(\"%d\", &x); return x; }\n \n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef pair<long long, long long> PLL;\ntypedef pair<int, PII> TIII;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\n \n \n//container util\n \n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SQ(a) ((a)*(a))\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n \n \n//repetition\n//------------------------------------------\n#define FOR(i,s,n) for(int i=s;i<(int)n;++i)\n#define REP(i,n) FOR(i,0,n)\n#define MOD 1000000007\n \n#define rep(i, a, b) for(int i = a; i < (b); ++i)\n#define trav(a, x) for(auto& a : x)\n#define all(x) x.begin(), x.end()\n#define sz(x) (int)(x).size()\n \ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\nconst double EPS = 1E-8;\n \n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\n \nclass UnionFind {\npublic:\n    vector <int> par; \n    vector <int> siz; \n\n    UnionFind(int sz_): par(sz_), siz(sz_, 1) {\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n    void init(int sz_) {\n        par.resize(sz_);\n        siz.assign(sz_, 1LL);\n        for (ll i = 0; i < sz_; ++i) par[i] = i;\n    }\n \n    int root(int x) { \n        while (par[x] != x) {\n            x = par[x] = par[par[x]];\n        }\n        return x;\n    }\n \n    bool merge(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y) return false;\n        if (siz[x] < siz[y]) swap(x, y);\n        siz[x] += siz[y];\n        par[y] = x;\n        return true;\n    }\n \n    bool issame(int x, int y) { \n        return root(x) == root(y);\n    }\n \n    int size(int x) { \n        return siz[root(x)];\n    }\n};\n \n \nll modPow(ll x, ll n, ll mod = MOD){\n    ll res = 1;\n    while(n){\n        if(n&1) res = (res * x)%mod;\n \n        res %= mod;\n        x = x * x %mod;\n        n >>= 1;\n    }\n    return res;\n}\n \n#define SIEVE_SIZE 5000000+10\nbool sieve[SIEVE_SIZE];\nvoid makeSieve(){\n    for(int i=0; i<SIEVE_SIZE; ++i) sieve[i] = true;\n    sieve[0] = sieve[1] = false;\n    for(int i=2; i*i<SIEVE_SIZE; ++i) if(sieve[i]) for(int j=2; i*j<SIEVE_SIZE; ++j) sieve[i*j] = false;\n}\n \nbool isprime(ll n){\n    if(n == 0 || n == 1) return false;\n    for(ll i=2; i*i<=n; ++i) if(n%i==0) return false;\n    return true;\n}\n \nconst int MAX = 2000010;\nlong long fac[MAX], finv[MAX], inv[MAX];\n \n// テーブルを作る前処理\nvoid COMinit() {\n    fac[0] = fac[1] = 1;\n    finv[0] = finv[1] = 1;\n    inv[1] = 1;\n    for (int i = 2; i < MAX; i++){\n        fac[i] = fac[i - 1] * i % MOD;\n        inv[i] = MOD - inv[MOD%i] * (MOD / i) % MOD;\n        finv[i] = finv[i - 1] * inv[i] % MOD;\n    }\n}\n \n// 二項係数計算\nlong long COM(int n, int k){\n    if (n < k) return 0;\n    if (n < 0 || k < 0) return 0;\n    return fac[n] * (finv[k] * finv[n - k] % MOD) % MOD;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a%b, y, x);\n    y -= a/b * x;\n    return d;\n}\n// 負の数にも対応した mod (a = -11 とかでも OK) \ninline long long mod(long long a, long long m) {\n    return (a % m + m) % m;\n}\n \n// 逆元計算 (ここでは a と m が互いに素であることが必要)\nlong long modinv(long long a, long long m) {\n    long long x, y;\n    extGCD(a, m, x, y);\n    return mod(x, m); // 気持ち的には x % m だが、x が負かもしれないので\n}\nll GCD(ll a, ll b){\n    \n    if(b == 0) return a;\n    return GCD(b, a%b);\n}\n\ntypedef vector<ll> vec;\ntypedef vector<vec> mat;\n\nmat mul(mat &A, mat &B) {\n    mat C(A.size(), vec((int)B[0].size()));\n    for(int i=0; i<A.size(); ++i){\n        for(int k=0; k<B.size(); ++k){\n            for(int j=0; j<B[0].size(); ++j){\n                C[i][j] = (C[i][j] + A[i][k] * B[k][j] %MOD) % MOD;\n            }\n        }\n    }\n    return C;\n}\nmat matPow(mat A, ll n) {\n    mat B(A.size(), vec((int)A.size()));\n \n    for(int i=0; i<A.size(); ++i){\n        B[i][i] = 1;\n    }\n \n    while(n > 0) {\n        if(n & 1) B = mul(B, A);\n        A = mul(A, A);\n        n >>= 1;\n    }\n    return B;\n}\n\nmap<ll,ll> prime_factor(ll n) {\n  map<ll,ll> res;\n  for(ll i=2; i*i <= n; i++) {\n      while(n%i == 0) {\n          res[i]++;\n          n /= i;\n      }\n  }\n\n  if(n != 1) res[n] = 1;\n  return res;\n}\n\nstruct Node {\n    int mi, mx;\n    Node(int mi, int mx) : mi(mi), mx(mx) {}\n    Node(){}\n} seg[1<<23];\n\nvoid update(int i, int x){\n    i += (1<<22)-1;\n    seg[i].mi = seg[i].mx = x;\n\n    while(i > 0){\n        i = (i-1)/2;\n        seg[i].mi = min(seg[i*2+1].mi, seg[i*2+2].mi);\n        seg[i].mx = max(seg[i*2+1].mx, seg[i*2+2].mx);\n    }\n}\n\nNode query(int a, int b, int k=0, int l=0, int r = (1<<22)){\n    if(r <= a || b <= l) return Node(INT_MAX, -INT_MAX);\n    if(a <= l && r <= b) return seg[k];\n    else{\n        Node vl = query(a, b, k*2+1, l, (l+r)/2);\n        Node vr = query(a, b, k*2+2, (l+r)/2, r);\n\n        return Node(min(vl.mi, vr.mi), max(vl.mx, vr.mx));\n    }\n}\n\nint xs[5010], ys[5010];\n\nint sum[5010][5010];\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(12);\n\n  int n, m; cin >> n >> m;\n\n  vector<int> x(n), y(n);\n\n  for(int i=0; i<n; i++){\n    cin >> xs[i] >> ys[i];\n    x[i] = xs[i];\n    y[i] = ys[i];\n  }\n\n  sort(all(x));\n  sort(all(y));\n  x.erase(unique(all(x)), x.end());\n  y.erase(unique(all(y)), y.end());\n\n  for(int i=0; i<n; i++){\n\n    int fx = lower_bound(all(x), xs[i]) - x.begin();\n    int fy = lower_bound(all(y), ys[i]) - y.begin();\n\n    sum[fy+1][fx+1]++;\n  }\n\n  for(int i=0;i<y.size(); i++){\n    for(int j=0;j<x.size(); j++){\n      sum[i+1][j+1] += sum[i+1][j] + sum[i][j+1] - sum[i][j];\n    }\n  }\n\n  for(int i=0; i<m; i++){\n    int lx,ly,rx,ry;\n    cin >> lx >> ly >> rx >> ry;\n\n    lx = lower_bound(all(x), lx) - x.begin();\n    ly = lower_bound(all(y), ly) - y.begin();\n    rx = lower_bound(all(x), rx+1) - x.begin();\n    ry = lower_bound(all(y), ry+1) - y.begin();\n\n    cout << sum[ry][rx] -sum[ry][lx] - sum[ly][rx] + sum[ly][lx] << endl;\n  }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nvector<pair<int,int> > v;\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int x,y;cin>>x>>y;\n    v.push_back({x,y});\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;\n    auto a=lower_bound(v.begin(),v.end(),pair<int,int>(x1,-1000000100))-v.begin();\n    auto b=upper_bound(v.begin(),v.end(),pair<int,int>(x2,1000000100))-v.begin();\n    vector<int> vv;\n    for(int j=a;j<b;j++)vv.push_back(v[j].se);\n    sort(vv.begin(),vv.end());\n    int c=lower_bound(vv.begin(),vv.end(),y1)-vv.begin();\n    int d=upper_bound(vv.begin(),vv.end(),y2)-vv.begin();\n    cout<<d-c<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 700;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) != EOF) {\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d%d\", &ps[i].first, &ps[i].second);\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int b = 0; b < BNUM; ++b) {\n      sort(bucket[b].begin(), bucket[b].end());\n    }\n    while(m--) {\n      int s, t, u, v; \n      scanf(\"%d%d%d%d\", &s, &t, &u, &v);\n      int l = lower_bound(x, x+n, s) - x;\n      int r = upper_bound(x, x+n, u) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (t <= y[l] && y[l] <= v);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (t <= y[r] && y[r] <= v);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), v)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), t);\n        l += B;\n      }\n      printf(\"%d\\n\", res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint map[5001][5001] = {0};\n\nint main() {\n\n  long long int n, m, input_x, input_y;\n\n  cin >> n >> m;\n\n  vector< long long int > x, y, x_s, y_s;\n  x_s.push_back( -10000000000 );\n  x_s.push_back(  10000000000 );\n  y_s.push_back( -10000000000 );\n  y_s.push_back(  10000000000 );\n\n  for ( long long int i = 0; i < n; i++ ) {\n    cin >> input_x >> input_y;\n    x.push_back( input_x );\n    y.push_back( input_y );\n    x_s.push_back( input_x );\n    y_s.push_back( input_y );\n  }\n  sort( x_s.begin(), x_s.end() );\n  x_s.erase( unique( x_s.begin(), x_s.end() ), x_s.end() );\n  sort( y_s.begin(), y_s.end() );\n  y_s.erase( unique( y_s.begin(), y_s.end() ), y_s.end() );\n  vector< long long int >:: iterator it;\n  for ( long long int i = 0; i < n; i++ ) {\n    it = lower_bound( x_s.begin(), x_s.end(), x[i] );\n    x[i] = distance( x_s.begin(), it );\n    it = lower_bound( y_s.begin(), y_s.end(), y[i] );\n    y[i] = distance( y_s.begin(), it );\n    map[ x[i] ][ y[i] ]++;\n  }\n  for ( long long int i = 0; i < n+2; i++ ) {\n    long long int k = 0;\n    for ( long long int j = 0; j < n+2; j++ ) {\n      map[j][i] += k;\n      k = map[j][i];\n      if ( i > 0 ) {\n\tmap[j][i] += map[j][i-1];\n      }\n    }\n  }\n\n  for ( long long int i = 0; i < n+2; i++ ) {\n    for ( long long int j = 0; j < n+2; j++ ) {\n      cout << map[j][i] << \" \";\n    }\n    cout << endl;\n  }\n  long long int x1, x2, y1, y2;\n  for ( long long int i = 0; i < m; i++ ) {\n    cin >> x1 >> y1 >> x2 >> y2;\n    it = lower_bound( x_s.begin(), x_s.end(), x1 );\n    x1 = distance( x_s.begin(), it ) - 1;\n    it = lower_bound( y_s.begin(), y_s.end(), y1 );\n    y1 = distance( y_s.begin(), it ) - 1;\n    it = upper_bound( x_s.begin(), x_s.end(), x2 );\n    x2 = distance( x_s.begin(), it ) - 1;\n    it = upper_bound( y_s.begin(), y_s.end(), y2 );\n    y2 = distance( y_s.begin(), it ) - 1;\n    long long int ans = map[x2][y2];\n    if ( x1 >= 0 ) ans -= map[x1][y2];\n    if ( y1 >= 0 ) ans -= map[x2][y1];\n    if ( x1 >= 0 && y1 >= 0 ) ans += map[x1][y1];\n    cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n    cout << ans << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nint tr_2d[5001][5001];\nint s[5002][5002];\n\nmap<int,int> zip_x,zip_y;\nint unzip_x[5000],unzip_y[5000];\n\npair<int,int> compress(vector<int> &x, vector<int> &y){\n// zipで座標->index\n// unzipでindex->座標\n// x,yは書き換えられるので注意\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  rep(i,x.size()){\n    zip_x[x[i]] = i;\n    unzip_x[i] = x[i];\n  }\n  rep(i,y.size()){\n    zip_y[y[i]] = i;\n    unzip_y[i] = y[i];\n  }\n  return make_pair(x.size(),y.size());\n}\n\nvoid Imos2D(int n){\n  rep(i,n+1)rep(j,n+1)s[i+1][j+1]=tr_2d[i][j];\n  rep(i,n+1)rep(j,n)s[i][j+1]+=s[i][j];\n  rep(i,n)rep(j,n+1)s[i+1][j]+=s[i][j];\n}\n\nint sum(int xl,int xr,int yd,int yu){\n  return s[xr][yu]-s[xl][yu]+s[xl][yd]-s[xr][yd];\n}\n\nsigned main(){\n\n  int n,m;\n  cin>>n>>m;\n  vector<int> tr_x(n),tr_x2(n),tr_y(n),tr_y2(n);\n  rep(i,n+1){\n    rep(j,n+1){\n      tr_2d[i][j]=0;\n    }\n  }\n\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    tr_x[i] = x;\n    tr_x2[i] = x;\n    tr_y[i] = y;\n    tr_y2[i] = y;\n  }\n  //座圧\n  pair<int,int> size=compress(tr_x2,tr_y2);\n  // cout<<size.first<<size.second<<endl;\n  rep(i,n){\n    int id_x = zip_x[tr_x[i]];\n    int id_y = zip_y[tr_y[i]];\n    tr_2d[id_x][id_y]++;\n  }\n  // rep(i,n){\n  //   rep(j,n-1){\n  //     cout<<tr_2d[i][j]<<\" \";\n  //   }\n  //   cout<<tr_2d[i][n-1]<<endl;\n  // }\n\n  //2次元累積和\n  rep(i,n+2)rep(j,n+2)s[i][j]=0;\n  Imos2D(n);\n  // rep(i,n+1){\n  //   rep(j,n){\n  //     cout<<s[i][j]<<\" \";\n  //   }\n  //   cout<<s[i][n]<<endl;\n  // }\n\n  rep(i,m){\n    int xl,xr,yd,yu;\n    cin>>xl>>yd>>xr>>yu;\n    auto ixl = lower_bound(unzip_x,unzip_x+size.first,xl)-unzip_x;\n    auto ixr = upper_bound(unzip_x,unzip_x+size.first,xr)-unzip_x-1;\n    auto iyd = lower_bound(unzip_y,unzip_y+size.second,yd)-unzip_y;\n    auto iyu = upper_bound(unzip_y,unzip_y+size.second,yu)-unzip_y-1;\n    // cout << xl<<\" \"<<xr<<\" : \"<<ixl<< \" \" <<ixr<<endl;\n    // cout << yd<<\" \"<<yu<<\" : \"<<iyd<< \" \" <<iyu<<endl;\n    cout << sum(ixl,ixr+1,iyd,iyu+1)<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#define _CRT_SECURE_NO_WARNINGS\n#include <array>\n#include <cstddef>\n#include <cstdint>\n#include <cstdio>\n#include <limits>\n#include <memory>\n#include <string>\n#include <type_traits>\n\ntemplate <class Integral> class Rirange;\ntemplate <class Integral = std::size_t> class irange {\n\tconst Integral f, l;\n\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type;\n\tclass irangeitr {\n\t\tfriend irange;\n\t\tvalue_type i;\n\t\tirangeitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { ++i; }\n\t\treference operator*() const noexcept { return i; }\n\t\tbool operator!=(const irangeitr &x) const noexcept { return i != x.i; }\n\t};\n\tirange(value_type first, value_type last) noexcept : f(first), l(last) {}\n\tirangeitr begin() const noexcept { return irangeitr(f); }\n\tirangeitr end() const noexcept { return irangeitr(l); }\n\tRirange<value_type> rev() const noexcept { return Rirange<value_type>(f, l); }\n};\ntemplate <class Integral = std::size_t> class Rirange {\n\tconst Integral f, l;\n\npublic:\n\tusing value_type = Integral;\n\tusing reference = value_type;\n\tclass Rirangeitr {\n\t\tfriend Rirange;\n\t\tvalue_type i;\n\t\tRirangeitr(value_type x) noexcept : i(x) {}\n\n\tpublic:\n\t\tvoid operator++() noexcept { --i; }\n\t\treference operator*() const noexcept { return i - 1; }\n\t\tbool operator!=(const Rirangeitr &x) const noexcept { return i != x.i; }\n\t};\n\tRirange(value_type first, value_type last) noexcept : f(first), l(last) {}\n\tRirangeitr begin() const noexcept { return Rirangeitr(l); }\n\tRirangeitr end() const noexcept { return Rirangeitr(f); }\n\tirange<value_type> rev() const noexcept { return irange<value_type>(f, l); }\n};\n\ntemplate <class T> bool maxi(T &a, const T &b) {\n\tif (b < a)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool mini(T &a, const T &b) {\n\tif (a < b)\n\t\treturn 0;\n\ta = b;\n\treturn 1;\n}\ntemplate <class T> bool smaxi(T &a, const T &b) {\n\tif (a < b) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\ntemplate <class T> bool smini(T &a, const T &b) {\n\tif (b < a) {\n\t\ta = b;\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nstruct customIO {\n\tint c;\n\tbool f;\n\tstd::array<int, 30> buf;\n\tvoid get_c() { c = fgetc(stdin); }\n\tvoid put_c(int x) { fputc(x, stdout); }\n\tbool vacant() { return c == ' ' || c == '\\n'; }\n\toperator int() { return 0; }\n\n\t// in\n\n\tvoid cueing() {\n\t\twhile (get_c(), vacant())\n\t\t\t;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tf = 0;\n\t\tcueing();\n\t\tif (c == '-')\n\t\t\tf = 1, get_c();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\tif (f)\n\t\t\td = -d;\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator>>(T &d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\td = 0;\n\t\tcueing();\n\t\tdo\n\t\t\td = d * 10 + c - '0';\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(char &d) {\n\t\tcueing();\n\t\td = c;\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(double &d) {\n\t\tscanf(\"%lf\", &d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator>>(std::string &d) {\n\t\td.clear();\n\t\tcueing();\n\t\tdo\n\t\t\td.push_back(c);\n\t\twhile (get_c(), !vacant());\n\t\treturn *this;\n\t}\n\ttemplate <class T> T input() {\n\t\tT d;\n\t\t*this >> d;\n\t\treturn d;\n\t}\n\n\t// out\n\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\tf = 0;\n\t\tif (d < static_cast<T>(0))\n\t\t\tf = 1, d = -d;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\tif (f)\n\t\t\tput_c('-');\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\ttemplate <class T>\n\tauto operator<<(T d) ->\n\t\ttypename std::enable_if<!std::is_signed<T>::value, customIO &>::type {\n\t\tc = 0;\n\t\twhile (d)\n\t\t\tbuf[c++] = d % 10 + '0', d /= 10;\n\t\tif (!c)\n\t\t\tbuf[c++] = '0';\n\t\twhile (c--)\n\t\t\tput_c(buf[c]);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(char d) {\n\t\tput_c(d);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const std::string &d) {\n\t\tfor (const auto e : d)\n\t\t\tput_c(e);\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(const char *d) {\n\t\twhile (*d != '\\0')\n\t\t\tput_c(*(d++));\n\t\treturn *this;\n\t}\n\tcustomIO &operator<<(double d) {\n\t\t/*\n\t\tprintf(\"%1.9f\",d);\n\t\t/*/\n\t\tprintf(\"%f\", d);\n\t\t//*/\n\t\treturn *this;\n\t}\n\tvoid endl() { put_c('\\n'); }\n\tvoid space() { put_c(' '); }\n} IO;\n\nusing int32 = std::int_fast32_t;\nusing int64 = std::int_fast64_t;\nusing uint32 = std::uint_fast32_t;\nusing uint64 = std::uint_fast64_t;\nusing intl32 = std::int_least32_t;\nusing intl64 = std::int_least64_t;\nusing uintl32 = std::uint_least32_t;\nusing uintl64 = std::uint_least64_t;\n\n#include <algorithm>\n#include <utility>\n#include <vector>\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n#include <vector>\n\ntemplate <typename Integral,\n\tstd::size_t bitsize = std::numeric_limits<Integral>::digits()>\n\tclass WaveletMatrix {\n\tpublic:\n\t\tusing value_type = Integral;\n\t\tusing size_type = std::size_t;\n\n\tprivate:\n\t\tusing uint32 = std::uint_least32_t;\n\t\tstatic size_type popcount32(uint32 c) {\n#ifdef __GNUC__\n\t\t\treturn __builtin_popcount(c);\n#elif _MSC_VER_\n\t\t\treturn _mm_popcnt_u32(c);\n#else\n\t\t\tc = (c & 0x55555555) + ((c >> 1) & 0x55555555);\n\t\t\tc = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n\t\t\tc = (c + (c >> 4)) & 0x0F0F0F0F;\n\t\t\tc += c >> 8;\n\t\t\tc += c >> 16;\n\t\t\treturn static_cast<size_type>(c) & 0x3F;\n#endif\n\t\t}\n\t\tstruct FID {\n\t\t\tstd::vector<uint32> dic;\n\t\t\tsize_type cnt;\n\t\t\tvalue_type bit;\n\t\t\tFID() {}\n\t\t\tFID(const size_type bsize) : dic(bsize, 0) {}\n\t\t\tvoid set(const size_type index) {\n\t\t\t\tdic[index >> 4 | 1] |= static_cast<uint32>(1) << (index & 0x1f);\n\t\t\t}\n\t\t\tvoid build() {\n\t\t\t\tconst size_type len = dic.size();\n\t\t\t\tfor (size_type j = 2; j < len; j += 2)\n\t\t\t\t\tdic[j] = dic[j - 2] + popcount32(dic[j - 1]);\n\t\t\t}\n\t\t\tsize_type rank(const size_type last) const {\n\t\t\t\treturn static_cast<size_type>(\n\t\t\t\t\tdic[last >> 4 & ~static_cast<size_type>(1)]) +\n\t\t\t\t\tpopcount32(dic[last >> 4 | 1] &\n\t\t\t\t\t(static_cast<size_type>(1) << (last & 0x1f)) - 1);\n\t\t\t}\n\t\t\tbool access(const size_type index) const {\n\t\t\t\treturn dic[index >> 4 | 1] >> (index & 0x1f) & 1;\n\t\t\t}\n\t\t};\n\t\tstd::array<FID, bitsize> matrix;\n\t\tvalue_type NOT_FOUND;\n\t\tsize_type size_;\n\n\tpublic:\n\t\tWaveletMatrix(std::vector<value_type> data, const value_type NOT_FOUND = 0)\n\t\t\t: size_(data.size()), NOT_FOUND(NOT_FOUND) {\n\t\t\tconst size_type len = data.size(), block = ((len >> 5) + 1) << 1;\n\t\t\tstd::vector<value_type> L(len), R(len);\n\t\t\tsize_type l, r;\n\t\t\tvalue_type temp = static_cast<value_type>(1) << (bitsize - 1);\n\t\t\tfor (auto &x : matrix) {\n\t\t\t\tx = FID(block);\n\t\t\t\tx.bit = temp;\n\t\t\t\ttemp = temp >> 1 & ~temp;\n\t\t\t\tl = 0;\n\t\t\t\tr = 0;\n\t\t\t\tfor (size_type j = 0; j < len; ++j)\n\t\t\t\t\tif (data[j] & x.bit)\n\t\t\t\t\t\tR[r++] = data[j], x.set(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tL[l++] = data[j];\n\t\t\t\tx.cnt = l;\n\t\t\t\tx.build();\n\t\t\t\tstd::swap(data, L);\n\t\t\t\tstd::copy(R.begin(), R.begin() + r, data.begin() + l);\n\t\t\t}\n\t\t}\n\n\t\tsize_type size() const noexcept { return size_; }\n\t\tbool empty() const noexcept { return size() == 0; }\n\n\t\tvalue_type access(size_type index) const {\n\t\t\tassert(index < size());\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (x.access(index))\n\t\t\t\t\tret |= x.bit, index = x.rank(index) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tindex -= x.rank(index);\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type operator[](const size_type index) const {\n\t\t\tassert(index < size());\n\t\t\treturn access(index);\n\t\t}\n\t\tsize_type rank(size_type first, size_type last, const value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (data & x.bit)\n\t\t\t\t\tfirst = x.rank(first) + x.cnt, last = x.rank(last) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tfirst -= x.rank(first), last -= x.rank(last);\n\t\t\treturn last - first;\n\t\t}\n\t\tvalue_type quantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tconst size_type l = x.rank(first), r = x.rank(last);\n\t\t\t\tif (r - l > k)\n\t\t\t\t\tfirst = l + x.cnt, last = r + x.cnt, ret |= x.bit;\n\t\t\t\telse\n\t\t\t\t\tfirst -= l, last -= r, k -= r - l;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type rquantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\treturn quantile(first, last, last - first - k - 1);\n\t\t}\n\t\tsize_type less_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_least(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type greater_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_most(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type rangefreq(size_type first, size_type last, const value_type lower,\n\t\t\tconst value_type upper) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tassert(lower <= upper);\n\t\t\treturn at_least(first, last, lower) - at_least(first, last, upper);\n\t\t}\n\t\tvalue_type successor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type predecessor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n\t\tvalue_type strict_succ(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type strict_pred(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n};\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <vector>\n\ntemplate <class T>\nusing StaticSetDefaultContainer = std::vector<T, std::allocator<T>>;\n\ntemplate <class T = std::uint_fast32_t,\n\ttemplate <class> class Container = StaticSetDefaultContainer,\n\tclass Compare = std::less<typename Container<T>::value_type>>\n\tclass StaticSet {\n\tpublic:\n\t\tusing container_type = Container<T>;\n\t\tusing value_compare = Compare;\n\t\tusing value_type = typename container_type::value_type;\n\t\tusing reference = typename container_type::reference;\n\t\tusing const_reference = typename container_type::const_reference;\n\t\tusing size_type = typename container_type::size_type;\n\t\tusing difference_type = typename container_type::difference_type;\n\t\tusing pointer = typename container_type::pointer;\n\t\tusing const_pointer = typename container_type::const_pointer;\n\t\tclass const_iterator : public std::random_access_iterator_tag {\n\t\t\tfriend StaticSet;\n\n\t\tpublic:\n\t\t\tusing difference_type = difference_type;\n\t\t\tusing value_type = value_type;\n\t\t\tusing pointer = const_pointer;\n\t\t\tusing reference = const_reference;\n\n\t\tprivate:\n\t\t\tusing iterator_type = typename container_type::const_iterator;\n\t\t\titerator_type it;\n\t\t\tdifference_type ord;\n\t\t\texplicit const_iterator(iterator_type x, difference_type y)\n\t\t\t\t: it(x), ord(y) {}\n\n\t\tpublic:\n\t\t\treference operator*() const { return *it; }\n\t\t\tpointer operator->() const { return std::addressof(operator*()); }\n\t\t\treference operator[](difference_type n) const { return it[n]; }\n\n\t\t\tconst_iterator &operator++() {\n\t\t\t\tif (++ord)\n\t\t\t\t\t++it;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator++(int) {\n\t\t\t\tauto ret = *this;\n\t\t\t\toperator++();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst_iterator &operator--() {\n\t\t\t\tif (ord--)\n\t\t\t\t\t--it;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator--(int) {\n\t\t\t\tauto ret = *this;\n\t\t\t\toperator--();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst_iterator &operator+=(difference_type n) {\n\t\t\t\tif (ord >= static_cast<difference_type>(0))\n\t\t\t\t\tit += n, ord += n;\n\t\t\t\telse if (n)\n\t\t\t\t\tit += n - 1, ord += n;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator+(difference_type n) const {\n\t\t\t\tif (ord >= static_cast<difference_type>(0))\n\t\t\t\t\treturn const_iterator(it + n, ord + n);\n\t\t\t\telse\n\t\t\t\t\treturn const_iterator(it + n - 1, ord + n);\n\t\t\t}\n\t\t\tconst_iterator &operator-=(difference_type n) {\n\t\t\t\tit -= n, ord -= n;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator-(difference_type n) const {\n\t\t\t\treturn const_iterator(it - n, ord - n);\n\t\t\t}\n\n\t\t\tdifference_type operator-(const const_iterator &other) const {\n\t\t\t\treturn ord - other.ord;\n\t\t\t}\n\n\t\t\tbool operator==(const const_iterator &other) const {\n\t\t\t\treturn it == other.it && ord == other.ord;\n\t\t\t}\n\t\t\tbool operator!=(const const_iterator &other) const {\n\t\t\t\treturn it != other.it || ord != other.ord;\n\t\t\t}\n\t\t\tbool operator<(const const_iterator &other) const {\n\t\t\t\treturn ord < other.ord;\n\t\t\t}\n\t\t\tbool operator<=(const const_iterator &other) const {\n\t\t\t\treturn ord <= other.ord;\n\t\t\t}\n\t\t\tbool operator>(const const_iterator &other) const {\n\t\t\t\treturn ord > other.ord;\n\t\t\t}\n\t\t\tbool operator>=(const const_iterator &other) const {\n\t\t\t\treturn ord >= other.ord;\n\t\t\t}\n\n\t\t\treference value() const { return operator*(); }\n\t\t\tdifference_type order() const { return ord; }\n\t\t};\n\t\tusing iterator = const_iterator;\n\n\tprotected:\n\t\tcontainer_type c;\n\t\tvalue_compare comp;\n\n\tprivate:\n\t\tconst_iterator make_citr(typename const_iterator::iterator_type it) const {\n\t\t\treturn const_iterator(it, std::distance(c.cbegin(), it));\n\t\t}\n\n\tpublic:\n\t\tStaticSet() : c(), comp() {}\n\t\texplicit StaticSet(const value_compare &x) : comp(x) {}\n\t\texplicit StaticSet(const value_compare &x, const container_type &other)\n\t\t\t: c(other), comp(x) {\n\t\t\tbuild();\n\t\t}\n\t\texplicit StaticSet(const value_compare &x, container_type &&other)\n\t\t\t: c(std::move(other)), comp(x) {\n\t\t\tbuild();\n\t\t}\n\n\t\tconst_iterator cbegin() const { return make_citr(c.cbegin()); }\n\t\tconst_iterator cend() const { return make_citr(c.cend()); }\n\t\titerator begin() { return cbegin(); }\n\t\titerator end() { return cend(); }\n\n\t\tsize_type size() const { return c.size(); }\n\t\tbool empty() const { return c.empty(); }\n\t\tvoid reserve(const size_type s) { c.reserve(s); }\n\t\tvoid shrink_to_fit() { c.shrink_to_fit(); }\n\n\t\tconst_reference operator[](size_type n) const {\n\t\t\tassert(n < size());\n\t\t\treturn c[n];\n\t\t}\n\t\tconst_reference at(size_type n) const { return c.at(n); }\n\t\tconst_reference min() const {\n\t\t\tassert(!empty());\n\t\t\treturn c.front();\n\t\t}\n\t\tconst_reference max() const {\n\t\t\tassert(!empty());\n\t\t\treturn c.back();\n\t\t}\n\t\tconst_iterator succ(const value_type &x) const {\n\t\t\treturn make_citr(std::lower_bound(c.cbegin(), c.cend(), x, comp));\n\t\t}\n\t\tconst_iterator pred(const value_type &x) const {\n\t\t\treturn make_citr(std::upper_bound(c.cbegin(), c.cend(), x, comp) - 1);\n\t\t}\n\t\tconst_iterator strict_succ(const value_type &x) const {\n\t\t\treturn make_citr(std::upper_bound(c.cbegin(), c.cend(), x, comp));\n\t\t}\n\t\tconst_iterator strict_pred(const value_type &x) const {\n\t\t\treturn make_citr(std::lower_bound(c.cbegin(), c.cend(), x, comp) - 1);\n\t\t}\n\n\t\tvoid push(const value_type &x) { c.push_back(x); }\n\t\tvoid push(value_type &&x) { c.push_back(std::move(x)); }\n\t\ttemplate <class... Args> void emplace(Args &&... args) {\n\t\t\tc.emplace_back(std::forward<Args>(args)...);\n\t\t}\n\t\tvoid build() { std::sort(c.begin(), c.end(), comp); }\n\t\tvoid unique() { c.erase(std::unique(c.begin(), c.end()), c.end()); }\n\t\tvoid clear() { c.clear(); }\n};\n\nint main() {\n\tconstexpr int32 base = 1000000000;\n\tuint32 n, m;\n\tIO >> n >> m;\n\tusing P = std::pair<int32, int32>;\n\tStaticSet<P> s;\n\ts.reserve(n);\n\twhile (n--) {\n\t\tint32 x, y;\n\t\tIO >> x >> y;\n\t\ty += base;\n\t\ts.emplace(x, y);\n\t}\n\ts.build();\n\tstd::vector<uint32> a;\n\ta.reserve(s.size());\n\tfor (const auto &e : s)\n\t\ta.emplace_back(e.second);\n\tWaveletMatrix<uint32, 31> W(a);\n\twhile (m--) {\n\t\tint32 a, b, c, d;\n\t\tIO >> a >> b >> c >> d;\n\t\t++c;\n\t\t++d;\n\t\tb += base;\n\t\td += base;\n\t\tIO << W.rangefreq(s.succ(P(a, 0)).order(), s.succ(P(c, 0)).order(), b, d) << '\\n';\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<long long> X;\n    vector<long long> Y;\n    vector<long long> x(n);\n    vector<long long> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        long long x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    long long h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    \n\n    //cout << h << \" \" << w << endl;\n    vector<vector<long long> > imos(h + 1, vector<long long> (w + 1, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i]][x[i]]++;\n    }\n\n    \n\n    for(int j = 0; j <= w; j++){\n        for(int i = 1; i <= h; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    \n    for(int i = 0; i < m; i++){\n        long long x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin() - 1;\n\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        \n        //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        long long sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n#define N_MAX 5000\n#define M_MAX 500000\n#define ll long long\n\n//??????????????¨??????\nint n,m;\nint xy[N_MAX][2];\nint square[4];\n\n\n//??????\nint ans;\nbool ok;\n\n\nint main() {\n\t//??\\???\n\tcin>>n>>m;\n\trep(i,n)rep(j,2)cin>>xy[i][j];\n\n\t//xy??????x???????????????????????????????????????\n\tbool flag=true;\n\tfor (int i = 0; flag; i++) {\n\t\tflag = 0;\n\t\tfor (int j = n-1 ; j >= i + 1; j--) {\n\t\t\tif (xy[j][0] < xy[j - 1][0]) {\n\t\t\t\t//??£??\\????´??????????\n\t\t\t\tswap(xy[j],xy[j-1]);\n\t\t\t\tflag=1;\n\t\t\t\t/*\n\t\t\t\ttemp0 = xy[j][0];\n\t\t\t\txy[j][0] = xy[j - 1][0];\n\t\t\t\txy[j - 1][0] = temp0;\n\n\t\t\t\ttemp1 = xy[j][1];\n\t\t\t\txy[j][1] = xy[j - 1][1];\n\t\t\t\txy[j - 1][1] = temp1;\n\n\t\t\t\trep(k, 2) {\n\t\t\t\t\ttemp[k]=xy[j][k];\n\t\t\t\t\txy[j][k]=xy[j-1][k];\n\t\t\t\t\txy[j-1][k]=temp[k];\n\t\t\t\t}\n\t\t\t\t*/\n\t\t\t}\n\t\t}\n\t}\n\n\t//?¨????\n\trep(roop, m) {\n\t\t//???????¨????\n\t\tans=0;\n\n\t\t//??\\???\n\t\trep(i,4)cin>>square[i];\n\n\t\t//??????????§??????????x?????´????????¢???(?????????????????????)\n\t\tint left=0,right=n,mid;\n\t\twhile (left < right) {\n\t\t\tmid=(left+right)/2;\n\t\t\tif(left==mid )break;\n\t\t\tif(xy[mid][0]==square[0])break;\n\t\t\telse if(square[0]<xy[mid][0])right=mid;\n\t\t\telse                         left=mid;\n\t\t}\n\n\t\t//cout<<\"left: \"<<left<<endl;\n\t\t//cout << \"ss\" << square[1]<<endl;\n\t\t//cout<<xy[left][1] << endl;\n\t\twhile(xy[left][0]<=square[2]){\n\t\t\tif(square[0] <= xy[left][0])\n\t\t\t   if(xy[left][0] <= square[2])\n\t\t\t   if(square[1] <= xy[left][1])\n\t\t\t   if(xy[left][1] <= square[3])\n\t\t\t   ans++;\n\t\t\tleft++;\n\t\t\tif(left>=n)break;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t/*\n\t//???????????°\n\trep(i, n) {\n\t\trep(j,2)cout<<xy[i][j]<<\" \";\n\t\tcout<<endl;\n\t}\n\t*/\n\t\n\t//cin>>m;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  int i,j,k;\n  int x[n],y[n];\n  for(i=0;i<n;i++) scanf(\"%d %d\",&x[i],&y[i]);\n  int sx,sy,tx,ty;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    int ans = 0;\n    for(j=0;j<n;j++) if(sx<=x[j]&&x[j]<=tx&&sy<=y[j]&&y[j]<=ty) ans++;\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define repp(i, l, r) for(int i = (l); i < (r); i++)\n#define per(i, n) for(int i = ((n)-1); i >= 0; i--)\n#define perr(i, l, r) for(int i = ((r)-1); i >= (l); i--)\n#define all(x) (x).begin(),(x).end()\n#define MOD 1000000007\n#define IINF 1000000100\n#define LINF 1000000000000000000\n#define SP <<\" \"<<\n#define CYES cout<<\"Yes\"<<endl\n#define CNO cout<<\"No\"<<endl\n#define CFS cin.tie(0);ios::sync_with_stdio(false)\n\ntypedef long long LL;\ntypedef long double LD;\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<pair<int,int>> tre(n);\n  map<int,int> xmp,ymp;\n  rep(i,n){\n    cin >> tre[i].first >> tre[i].second;\n    xmp[tre[i].first]=-1;\n    ymp[tre[i].second]=-1;\n  }\n  xmp[IINF]=-1;\n  ymp[IINF]=-1;\n  int xsz=0;\n  for(auto &p:xmp) p.second=(xsz++);\n  int ysz=0;\n  for(auto &p:ymp) p.second=(ysz++);\n  vector<vector<int>> rui(xsz+1,vector<int>(ysz+1,0));\n  rep(i,n){\n    rui[xmp[tre[i].first]+1][ymp[tre[i].second]+1]++;\n  }\n  repp(i,1,xsz+1){\n    repp(j,1,ysz+1){\n      rui[i][j]+=rui[i-1][j]+rui[i][j-1]-rui[i-1][j-1];\n    }\n  }\n  int x1,y1,x2,y2;\n  rep(i,m){\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1=xmp.lower_bound(x1)->second;\n    y1=ymp.lower_bound(y1)->second;\n    x2=xmp.upper_bound(x2)->second;\n    y2=ymp.upper_bound(y2)->second;\n    cout << rui[x2][y2]-rui[x1][y2]-rui[x2][y1]+rui[x1][y1] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;++i)\n#define all(x) (x).begin(),(x).end()\nusing namespace std;\nconst int INF=1145141919,MOD=1e9+7;\nconst int64_t LINF=8931145141919364364,LMOD=998244353;\n// const int dy[]={0,-1,0,1,1,-1,-1,1};\n// const int dx[]={1,0,-1,0,1,1,-1,-1};\n\ntemplate<typename T>\nstruct Imos2D {\n\tvector<vector<T>> board;\n\tconst int h, w;\n\tImos2D(int h, int w) : \n\t\tboard(vector<vector<T>>(h + 2, vector<T>(w + 2, 0))),\n\t\tw(w + 2),\n\t\th(h + 2)\n\t\t{}\n\t// 範囲外許さないマン\n\tbool able(int y, int x) {\n\t\tif(y <= 0 or h < y) return false;\n\t\tif(x <= 0 or w < x) return false;\n\t\treturn true;\n\t}\n\tbool able(int y1, int x1, int y2, int x2) {\n\t\tif(not able(y1, x1)) return false;\n\t\tif(not able(y2, x2)) return false;\n\t\tif(make_pair(y1, x1) > make_pair(y2, x2)) return false;\n\t\treturn true;\n\t}\n\t// 1点加算\n\tvoid add(int y, int x, T z) {\n\t\tassert(able(y, x));\n\t\tboard[y][x] += z;\n\t}\n\t// 矩形加算\n\tvoid add(int y1, int x1, int y2, int x2, T z) {\n\t\tassert(able(y1, x1, y2, x2));\n\t\tboard[y1][x1] += z;\n\t\tboard[y1][x2 + 1] -= z;\n\t\tboard[y2 + 1][x1] -= z;\n\t\tboard[y2 + 1][x2 + 1] += z;\n\t}\n\t// 累積和\n\tvoid build() {\n\t\tfor(int y = 1; y < h; ++y) {\n\t\t\tfor(int x = 1; x < w; ++x) {\n\t\t\t\tboard[y][x] += board[y][x - 1];\n\t\t\t}\n\t\t}\n\t\tfor(int y = 1; y < h; ++y) {\n\t\t\tfor(int x = 1; x < w; ++x) {\n\t\t\t\tboard[y][x] += board[y - 1][x];\n\t\t\t}\n\t\t}\n\t}\n\t// 1点取得\n\tT get(int y, int x) {\n\t\tassert(able(y, x));\n\t\treturn board[y][x];\n\t}\n\t// 矩形取得\n\tT get(int y1, int x1, int y2, int x2) {\n\t\tassert(able(y1, x1, y2, x2));\n\t\treturn board[y2][x2] - board[y2][x1 - 1] - board[y1 - 1][x2]+board[y1 - 1][x1 - 1];\n\t}\n\tvoid debug() {\n\t\tfor(int y = 1; y < h - 1; ++y) {\n\t\t\tfor(int x = 1; x < w - 1; ++x) {\n\t\t\t\tcout << board[y][x] << \" \";\n\t\t\t}\n\t\t\tcout << '\\n';\n\t\t}\n\t}\n};\n\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tmap<int, int> mpx, mpy;\n\tint x[n], y[n];\n\trep(i,n) {\n\t\tcin >> x[i] >> y[i];\n\t\tmpx[x[i]]++;\n\t\tmpy[y[i]]++;\n\t}\n\tint rectx[m * 2], recty[m * 2];\n\trep(i,m * 2) {\n\t\tcin >> rectx[i] >> recty[i];\n\t}\n\tint h, w;\n\t{\n\t\tint cnt = 1;\n\t\tfor(auto &e : mpx) {\n\t\t\te.second = cnt;\n\t\t\t++cnt;\n\t\t}\n\t\tw = cnt;\n\t}\n\t{\n\t\tint cnt = 1;\n\t\tfor(auto &e : mpy) {\n\t\t\te.second = cnt;\n\t\t\t++cnt;\n\t\t}\n\t\th = cnt;\n\t}\n\tImos2D<int> imos(h, w);\n\trep(i,n) {\n\t\timos.add(mpy[y[i]], mpx[x[i]], 1);\n\t}\n\timos.build();\n\trep(i,m) {\n\t\tauto itry = mpy.lower_bound(recty[2 * i]);\n\t\tauto itrx = mpx.lower_bound(rectx[2 * i]);\n\t\tint y1;\n\t\tif(itry == mpy.end()) {\n\t\t\ty1 = h;\n\t\t} else {\n\t\t\ty1 = (*itry).second;\n\t\t}\n\t\tint x1;\n\t\tif(itrx == mpx.end()) {\n\t\t\tx1 = w;\n\t\t} else {\n\t\t\tx1 = (*itrx).second;\n\t\t}\n\t\titry = mpy.upper_bound(recty[2 * i + 1]);\n\t\titrx = mpx.upper_bound(rectx[2 * i + 1]);\n\t\tint y2;\n\t\tif(itry != mpy.begin()) {\n\t\t\titry = prev(itry);\n\t\t\ty2 = (*itry).second;\n\t\t} else {\n\t\t\ty2 = 0;\n\t\t}\n\t\tint x2;\n\t\tif(itrx != mpx.begin()) {\n\t\t\titrx = prev(itrx);\n\t\t\tx2 = (*itrx).second;\n\t\t} else {\n\t\t\tx2 = 0;\n\t\t}\n\t\tif(make_pair(y1, x1) > make_pair(y2, x2) or y1 * y2 * x1 * x2 == 0) {\n\t\t\tcout << 0 << endl;\n\t\t} else {\n\t\t\t// cerr << y1 << \" \" << x1 << \" \" << y2 << \" \" << x2 << endl;\n\t\t\tcout << imos.get(y1, x1, y2, x2) << '\\n';\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n\nint H, W;\nvector<int> X, Y;\nvector<P> ts, ls, rs;\n\nvoid init_number(){\n  set<int> Ys, Xs;\n  REP(i, ts.size()){ Xs.insert(ts[i].first); Ys.insert(ts[i].second); }\n  REP(i, ls.size()){ Xs.insert(ls[i].first); Ys.insert(ls[i].second); }\n  REP(i, rs.size()){ Xs.insert(rs[i].first); Ys.insert(rs[i].second); }\n  Ys.insert((1e9 + 10) * -1);\n  Ys.insert(1e9 + 10);\n  Xs.insert((1e9 + 10) * -1);\n  Xs.insert(1e9 + 10);\n  X = vector<int>(Xs.begin(), Xs.end());\n  Y = vector<int>(Ys.begin(), Ys.end());\n  W = X.size();\n  H = Y.size();\n}\n\nint number(int n, vector<int> &v){\n  return lower_bound(v.begin(), v.end(), n) - v.begin();\n}\n\nvoid init(vector< vector<int> > &v, vector< vector<int> > &E){\n  E[0][0] = v[0][0];\n  FOR(i, 1, H) E[i][0] = E[i - 1][0] + v[i][0];\n  FOR(i, 1, W) E[0][i] = E[0][i - 1] + v[0][i];\n  FOR(y, 1, H)\n    FOR(x, 1, W)\n    E[y][x] = v[y][x] + E[y - 1][x] + E[y][x - 1] - E[y - 1][x - 1];\n}\n\nint calc(int Y1, int X1, int Y2, int X2, vector< vector<int> > &E){\n  int ret = E[Y2][X2];\n  if(X1 - 1 >= 0) ret -= E[Y2][X1 - 1];\n  if(Y1 - 1 >= 0) ret -= E[Y1 - 1][X2];\n  if(X1 - 1 >= 0 && Y1 - 1 >= 0) ret += E[Y1 - 1][X1 - 1];\n  return ret;\n}\n\nint main() {\n  int N, M; cin >>N >>M;\n  ts = vector<P>(N);\n  ls = vector<P>(M);\n  rs = vector<P>(M);\n  REP(i, N) cin >>ts[i].first >>ts[i].second;\n  REP(i, M) cin >>ls[i].first >>ls[i].second >>rs[i].first >>rs[i].second;\n  init_number();\n  vector< vector<int> > v(H, vector<int>(W, 0)), E(H, vector<int>(W, 0));\n  REP(i, N) v[number(ts[i].second, Y)][number(ts[i].first, X)] += 1;\n  init(v, E);\n  REP(i, M) cout <<calc(number(ls[i].second, Y), number(ls[i].first, X), number(rs[i].second, Y), number(rs[i].first, X), E) <<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb emplace_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\ntemplate<int N>\nstruct FID {\n  using Bits = uint32_t;\n  static const int B = 8*sizeof(Bits);\n  int n;\n  int buck[N/B+2];\n  Bits bits[N/B+2];\n  int sel[2][N];\n\n  FID() {}\n  FID(int n, bool bs[]) : n(n) {\n    int cnt = 0;\n    int idx = 0;\n    fill(buck, buck+N/B+2, 0);\n    fill(bits, bits+N/B+2, 0);\n    rep(i, n/B + (n%B != 0)) {\n      rep(j, B) {\n        if (idx >= n) break;\n        cnt += bs[idx];\n        bits[i] |= Bits(bs[idx]) << j;\n        idx++;\n      }\n      buck[i+1] = cnt;\n    }\n\n    fill(sel[0], sel[2], -1);\n    cnt = 0;\n    rep(i, n) {\n      if (bs[i]) {\n        sel[1][cnt] = i;\n        cnt++;\n      } else {\n        sel[0][i-cnt] = i;\n      }\n    }\n  }\n\n  int Count(bool v, int r) {\n    int ret = buck[r/B] + __builtin_popcount(bits[r/B] % (1<<(r%B)));\n    if (!v) ret = r - ret;\n    return ret;\n  }\n\n  int Select(bool v, int k) {\n    if (k < 0 || k >= n) return -1;\n    return sel[v][k];\n  }\n\n  int SelectFrom(int from, bool v, int k) {\n    return Select(v, Count(v, from) + k);\n  }\n\n  bool operator[](int k) {\n    return bits[k/B] >> (k%B) & 1;\n  }\n};\n\ntemplate<int N, class T=unsigned int>          \nstruct Wavelet {\n  static const int D = 8*sizeof(T);\n  int n;\n  int sep[D];\n  FID<N> dat[D];\n  T arr[N];\n\n  Wavelet(int n, T ini[]) : n(n) {\n    T l[N];\n    T r[N];\n    T src[N];\n    bool bs[N];\n\n    copy(ini, ini+n, arr);\n    copy(ini, ini+n, src);\n    rep (d, D) {\n      int rk = 0;\n      int lk = 0;\n      rep(i, n) {\n        bool t = src[i] >> (D-d-1) & 1;\n        if (t) r[rk++] = src[i];\n        else l[lk++] = src[i];\n        bs[i] = t;\n      }\n      dat[d] = FID<N>(n, bs);\n      sep[d] = lk;\n      swap(l, src);\n      copy(r, r+rk, src+lk);\n    }\n  }\n\n  int Count(T val, int l, int r) {\n    if (r <= l) return 0;\n    rep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      l = dat[d].count(b, l) + b*sep[b];\n      r = dat[d].count(b, r) + b*sep[b];\n    }\n    return r-l;\n  }\n\n  int Select(T val, int k) {\n    int ls[D+1];\n    int rs[D+1];\n    ls[0] = 0;\n    rs[0] = n;\n    rep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      ls[d+1] = dat[d].count(b, ls[d]) + b*sep[b];\n      rs[d+1] = dat[d].count(b, rs[d]) + b*sep[b];\n    }\n    rrep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      k = dat[d].SelectFrom(ls[d], b, k);\n      if (k < 0 || k >= rs[d]) return -1;\n      k -= ls[d];\n    }\n    return k;\n  }\n\n  T KthNumber(int l, int r, int k) {\n    if (k < 0 || k >= r-l) assert(0);\n    T ret = 0;\n    rep(d, D) {\n      int lc = dat[d].Count(1, l);\n      int rc = dat[d].Count(1, r);\n      if (rc - lc > k) {\n        l = lc + sep[d];\n        r = rc + sep[d];\n        ret |= T(1) << (D-d-1);\n      } else {\n        k -= rc-lc;\n        l -= lc;\n        r -= rc;\n      }\n    }\n    return ret;\n  }\n\n  int FreqDfs(int d, int l, int r, T val, T a, T b) {\n    if (r <= l) return 0;\n    if (d == D) {\n      if (a <= val && val < b) return r-l;\n      return 0;\n    }\n\n    T h = T(1) << (D-d-1);\n    T nv = val | h; \n    T lim = nv | (h-1);\n    if (lim < a || b <= val) return 0;\n    if (a <= val && lim < b) return r-l;\n\n    int lc = dat[d].Count(1, l);\n    int rc = dat[d].Count(1, r);\n    int lval = FreqDfs(d+1, l-lc, r-rc, val, a, b);\n    int rval = FreqDfs(d+1, lc+sep[d], rc+sep[d], nv, a, b);\n    return lval + rval;\n  }\n\n  int Freq(int l, int r, T a, T b) {\n    return FreqDfs(0, l, r, 0, a, b);\n  }\n\n  T operator[](int k) {\n    return arr[k];\n  }\n};\n\nconst int GETA = 1e9;\nint N;\nint M;\nunsigned int ys[114514];\nvector<PII> ps;\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  rep(i, N) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    y += GETA;\n    ps.emplace_back(PII(x, y));\n  }\n  sort(all(ps));\n \n  rep(i, N) ys[i] = ps[i].second;\n  Wavelet<5000> wave(N, ys);\n\n  rep(i, M) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    b += GETA;\n    d += GETA;\n    int x = lower_bound(all(ps), PII(a, 0)) - ps.begin();\n    int y = upper_bound(all(ps), PII(c, GETA*2)) - ps.begin();\n    printf(\"%d\\n\", wave.Freq(x, y, b, d+1));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, x1_, y1_, x2_, y2_;\n\nvector<int> x, y;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\n\tx = vector<int>(n);\n\ty = vector<int>(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (x[i] > x[j])\n\t\t\t{\n\t\t\t\tswap(x[i], x[j]);\n\t\t\t\tswap(y[i], y[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d\", &x1_);\n\t\tscanf(\"%d\", &y1_);\n\t\tscanf(\"%d\", &x2_);\n\t\tscanf(\"%d\", &y2_);\n\n\t\tint s = distance(x.begin(), upper_bound(x.begin(), x.end(), x1_ - 1));\n\t\tint t = distance(x.begin(), lower_bound(x.begin(), x.end(), x2_ + 1));\n\n\t\tint ret = 0;\n\n\t\tfor (int j = s; j < t; j++)\n\t\t{\n\t\t\tif (y1_ <= y[j] && y[j] <= y2_)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\nusing namespace std;\n\ntypedef complex<int> xy_t;\n\nint main() {\n\n\tint N, M, x1, y1, x2, y2;\n\txy_t T[5000], A1[500000], A2[500000];\n\t\n\tcin >> N >> M;\n\t\n\tfor ( int i = 0; i < N; i++ ) {\n\t\n\t\tcin >> x1 >> y1;\n\n\t\tT[i] = xy_t( x1, y1 );\n\t\n\t}\n\t\n\tfor ( int i = 0; i < M; i++ ) {\n\t\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\tA1[i] = xy_t( x1, y1 );\n\t\tA2[i] = xy_t( x2, y2 );\n\t\n\t}\n\t\n\tfor ( int i = 0; i < M; i++ ) {\n\t\n\t\tint count = 0;\n\t\n\t\tfor ( int j = 0; j < N; j++ ) {\n\t\t\n\t\t\tif ( A1[i].real() <= T[i].real() && T[i].real() <= A2[i].real() && A1[i].imag() <= T[i].imag() && T[i].imag() <= A2[i].imag() ) { count++; }\n\t\t\t\n\t\t}\n\t\t\n\t\tcout << count << endl;\n\t\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_;\n\tstd::vector<std::vector<Type> > dat;\n\tstd::vector<std::vector<int> > vl;\n\tinline int query_(int a, int b, Type x, int k, int l, int r, int e) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r) and e integers below x in the range\n\t\tif (r <= a || b <= l || e == 0) return 0;\n\t\tif (a <= l && r <= b) return e;\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1, vl[k][e - 1]);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r, e - vl[k][e - 1]);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1);\n\t\tdat.resize(size_ << 1);\n\t\tvl.resize(size_);\n\t\tfor (int i = 0; i < n; i++) dat[i + size_].push_back(*(begin_ + i));\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tvl[i].resize(dat[i].size());\n\t\t\tint cl = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][j - cl])) dat[i][j] = dat[i << 1][cl++];\n\t\t\t\telse dat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\tvl[i][j] = cl;\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\tint ptr = lower_bound(dat[1].begin(), dat[1].end(), x) - dat[1].begin();\n\t\treturn query_(l, r, x, 1, 0, size_, ptr);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * treasure_hunt.cpp\n *\n *  Created on: 2017/04/12\n *      Author: Nishio\n */\n#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tint tx[5001],ty[5001];\n\tREP(i,0,n) {\n\t\tcin>>tx[i]>>ty[i];\n\t}\n\tint x[2],y[2];\n\tREP(i,0,m){\n\t\tint ans=0;\n\t\tcin>>x[0]>>y[0]>>x[1]>>y[1];\n\t\tif(x[0]==x[1]&&y[0]==y[1]){\n\t\t\tREP(i,0,n)\n\t\t\t\tif(tx[i]==x[0]&&ty[i]==y[0]) ans++;\n\t\t}else if(x[0]==x[1]){\n\t\t\tREP(i,0,n)\n\t\t\t\tif((tx[i]==x[0])&&(*lower_bound(y,y+2,ty[i])==y[1]||ty[i]==y[0])) ans++;\n\t\t}else if(y[0]==y[1]){\n\t\t\tREP(i,0,n)\n\t\t\t\tif((*lower_bound(x,x+2,tx[i])==x[1]||tx[i]==x[0])&&(ty[i]==y[0])) ans++;\n\t\t}\n\t\telse{\n\t\t\tREP(i,0,n)\n\t\t\t\tif((*lower_bound(x,x+2,tx[i])==x[1]||tx[i]==x[0])&&(*lower_bound(y,y+2,ty[i])==y[1]||ty[i]==y[0]))\tans++;\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<long long> X;\n    vector<long long> Y;\n    vector<long long> x(n);\n    vector<long long> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        long long x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    long long h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),X[i]) - X.begin();\n        X[i] = x[i];\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),Y[i]) - Y.begin();\n        Y[i] = y[i];\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    //cout << h << \" \" << w << endl;\n    vector<vector<long long> > imos(h + 1, vector<long long> (w + 1, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i]][x[i]]++;\n    }\n\n    \n\n    for(int j = 0; j <= w; j++){\n        for(int i = 1; i <= h; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    \n    for(int i = 0; i < m; i++){\n        long long x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin() - 1;\n\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        \n        cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        long long sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint mp[5005][5005],n,m;\nvector<int> x,y;\n// O(n * log n ) n=v.size()\nvector<int> compress(vector<int> v){\n  // v = {4,6,7,1,1,6}\n  //   -> res={1,2,3,0,0,2}\n\n  vector<int> copy=v;\n\n  sort(v.begin(), v.end());\n  v.erase( unique( v.begin(), v.end()) , v.end() );\n\n  vector<int> res;\n  for(int i=0;i<(int)copy.size();i++){\n    int num=lower_bound( v.begin(),v.end(), copy[i] ) - v.begin();\n    res.push_back( num );\n  }\n  return res;\n}\n\nint sum(int sx,int sy,int gx,int gy){\n  sx--,sy--;\n  int res=mp[gx][gy];\n\n  if(sx>=0)  res-=mp[sx][gy];\n\n  if(sy>=0) res-=mp[gx][sy];\n\n  if(sx>=0&&sy>=0) res+=mp[sx][sy];\n\n  return res;\n}\n\nint main(){\n  cin>>n>>m;\n  x.resize(n),y.resize(n);\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  vector<int> X,Y;\n  X=compress(x),Y=compress(y);\n  for(int i=0;i<n;i++)mp[X[i]][Y[i]]++;\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)mp[i][j+1]+=mp[i][j];\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)mp[j+1][i]+=mp[j][i];\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  x.erase( unique( x.begin(), x.end()) , x.end() );\n  y.erase( unique( y.begin(), y.end()) , y.end() );\n  while(m--){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    int sx=lower_bound(x.begin(),x.end(),a)-x.begin();\n    int sy=lower_bound(y.begin(),y.end(),b)-y.begin();\n    int gx=lower_bound(x.begin(),x.end(),c)-x.begin()-1;\n    int gy=upper_bound(y.begin(),y.end(),d)-y.begin()-1;\n    cout<<sum(sx,sy,gx,gy)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\n/***** ?´??????? *****/\n\n// ????¬?????´???????\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum(vector<T> &sum, int begin, int end) {\n\treturn sum[end] - sum[begin];\n}\n\n// ????¬?????´???????\ntemplate<typename T>\nvector< vector<T> > calc_csum2(vector< vector<T> > &val) {\n\tint H = val.size();\n\tint W = val[0].size();\n\tvector< vector<T> > sum(H + 1, vector<T>(W + 1));\n\n\tfor (int y = 0; y < H; y++) {\n\t\tpartial_sum(val[y].begin(), val[y].end(), sum[y + 1].begin() + 1);\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x <= W; x++) {\n\t\t\tsum[y + 1][x] += sum[y][x];\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum2(vector< vector<T> > &sum, int y1, int y2, int x1, int x2) {\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\n/***** /?´??????? *****/\n\nstruct Query {\n\tQuery () {}\n\tint x1;\n\tint x2;\n\tint y1;\n\tint y2;\n};\n\nVI uniq_xs;\nVI uniq_ys;\n\nVI uniq_xs_r;\nVI uniq_ys_r;\n\nvoid my_uniq(VI &vec) {\n\tsort(ALL(vec));\n\tauto it = unique(ALL(vec));\n\tvec.resize(distance(vec.begin(), it));\n}\n\nint trans_left(VI &vec, int value) {\n\tauto it = lower_bound(ALL(vec), value);\n\tint pos = it - vec.begin();\n\treturn pos;\n}\n\nint trans_right(VI &vec_r, int value) {\n\tauto it = lower_bound(ALL(vec_r), value, greater<int>());\n\tint pos = it - vec_r.begin();\n\treturn (int)vec_r.size() - pos - 1;\n}\n\nint main(void) {\n\tconst int MAX_N = 1000 * 1000 * 1000 + 10;\n\n\t// input\n\tint n, m;\n\tcin >> n >> m;\n\n\tVI xs(n), ys(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xs[i] >> ys[i];\n\t\tuniq_xs.PB(xs[i]);\n\t\tuniq_ys.PB(ys[i]);\n\t}\n\n\t// ??§?¨???§???\n\tuniq_xs.PB(0);\n\tuniq_xs.PB(MAX_N);\n\tuniq_ys.PB(0);\n\tuniq_ys.PB(MAX_N);\n\tmy_uniq(uniq_xs);\n\tmy_uniq(uniq_ys);\n\n\t// ??????????????\\?????????????????????\n\tuniq_xs_r = VI(ALL(uniq_xs));\n\tuniq_ys_r = VI(ALL(uniq_ys));\n\tsort(ALL(uniq_xs_r), greater<int>());\n\tsort(ALL(uniq_ys_r), greater<int>());\n\n\t// map?????????\n\tint w = uniq_xs.size();\n\tint h = uniq_ys.size();\n\tVVI ts(h, VI(w));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = trans_left(uniq_xs, xs[i]);\n\t\tint y = trans_left(uniq_ys, ys[i]);\n\t\tts[y][x]++;\n\t}\n\n\t// ?´??????????\n\t\n\tauto ts_sum = calc_csum2(ts);\n\n\t// query\n\tQuery qs;\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> qs.x1 >> qs.y1 >> qs.x2 >> qs.y2;\n\n\t\tint y1 = trans_left(uniq_ys, qs.y1);\n\t\tint x1 = trans_left(uniq_xs, qs.x1);\n\t\tint y2 = trans_right(uniq_ys_r, qs.y2);\n\t\tint x2 = trans_right(uniq_xs_r, qs.x2);\n\n\t\tint ans = sum_csum2(ts_sum, y1, y2 + 1, x1, x2 + 1);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nint main()\n{\n  int n,m;\n  int x1,y1,x2,y2;\n  vector<int> x,y;\n  vector<int> ix,iy;\n  vector< vector<int> > dp;\n\n  cin>>n>>m;\n  x.resize(n);\n  y.resize(n);\n  for(int i=0; i<n; i++){\n    cin>>x[i]>>y[i];\n    ix.push_back(x[i]);\n    iy.push_back(y[i]);\n  }\n  ix.push_back(INT_MIN);\n  iy.push_back(INT_MIN);\n  sort(ix.begin(), ix.end());\n  sort(iy.begin(), iy.end());\n  ix.erase(unique(ix.begin(), ix.end()), ix.end());\n  iy.erase(unique(iy.begin(), iy.end()), iy.end());\n\n  dp.resize(iy.size(), vector<int>(ix.size(), 0));\n  for(int i=0; i<n; i++){\n    int ty = lower_bound(iy.begin(), iy.end(), y[i]) - iy.begin();\n    int tx = lower_bound(ix.begin(), ix.end(), x[i]) - ix.begin();\n    dp[ty][tx]++;\n  }\n  for(int i=1; i<iy.size(); i++){\n    for(int j=1; j<ix.size(); j++){\n      dp[i][j] += dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\n    }\n  }\n\n  for(int i=0; i<m; i++){\n    cin>>x1>>y1>>x2>>y2;\n    int ix1,iy1,ix2,iy2;\n    iy1 = lower_bound(iy.begin(), iy.end(), y1) - iy.begin();\n    ix1 = lower_bound(ix.begin(), ix.end(), x1) - ix.begin();\n    iy2 = upper_bound(iy.begin(), iy.end(), y2) - iy.begin()-1;\n    ix2 = upper_bound(ix.begin(), ix.end(), x2) - ix.begin()-1;\n    cout<<dp[iy2][ix2]+dp[iy1-1][ix1-1]-dp[iy1-1][ix2]-dp[iy2][ix1-1]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n//?¶??????????????????????\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,W;\nint32_t w[100];\nint32_t v[100];\n\nint dp[100][10001];\n//i??\\???????????????????????§??????capacity??????????????¶???????????°????????¨???????????§???\nint func(int i, int capacity)\n{\n\tif (capacity == 0) {\n\t\treturn 0;\n\t}\n\tif (i >= N) {\n\t\treturn 0;\n\t}\n\tif (dp[i][capacity] != -1) {\n\t\treturn dp[i][capacity];\n\t}\n\tint res = 0;\n\t//??\\??????\n\tif (capacity >= w[i]) { res = std::max(res, func(i + 1, capacity - w[i]) + v[i]); }\n\t//??\\?????????\n\tres = std::max(res, func(i + 1, capacity));\n\treturn dp[i][capacity] = res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>W;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tin >> v[i] >> w[i];\n\t}\n\tbool used[100] = {};\n\tout << func(0, used)<<endl;\n\n\treturn 0;\n}\n#endif\n\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,Q;\n//Coordinate Compression\nusing INT_T = int64_t;\nconstexpr int32_t N_MAX = 15000;\nINT_T t_x[N_MAX];\nINT_T t_y[N_MAX];\nINT_T CC_X[N_MAX];\nauto CC_X_end = CC_X;\nINT_T CC_Y[N_MAX];\nauto CC_Y_end = CC_Y;\nINT_T map[N_MAX][N_MAX];\n\nvoid Init_CoordinateCompression(INT_T(&bace)[N_MAX], INT_T(&CC_buf)[N_MAX], INT_T*&CC_buf_end)\n{\n\tif (bace != CC_buf) {\n\t\tstd::copy_n(bace, N, CC_buf);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tCC_buf[N + i] = bace[i] - 1;\n\t\t}\n\t}\n\tCC_buf_end = CC_buf + 2 * N;\n\tstd::sort(CC_buf, CC_buf + 2*N);\n\tCC_buf_end = std::unique(CC_buf, CC_buf_end);\n}\nINT_T get_coordinate(INT_T(&CC_buf)[N_MAX], INT_T* CC_buf_end, INT_T v)\n{\n\treturn std::lower_bound(CC_buf, CC_buf_end, v) - CC_buf + 1;\n}\nvoid Do_CoordinateCompression(INT_T(&bace)[N_MAX], INT_T(&CC_buf)[N_MAX], INT_T*&CC_buf_end)\n{\n\tInit_CoordinateCompression(bace, CC_buf, CC_buf_end);\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tbace[i] = get_coordinate(CC_buf, CC_buf_end, bace[i]);\n\t}\n}\n\ntemplate<typename ARR>\ninline void add_full(ARR& v1, ARR& v2)\n{\n\tv1 += v2;\n}\ntemplate<typename ARR, size_t N>\ninline void add_full(ARR(&v1)[N], ARR(&v2)[N])\n{\n\tauto iter1 = v1, iter2 = v2, iter1end = v1 + N;\n\twhile (iter1 != iter1end) {\n\t\tadd_full(*iter1++, *iter2++);\n\t}\n}\n//1-indexed?´???????\ntemplate<size_t N>void CuSum(int64_t(&arr)[N])\n{\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tarr[i] += arr[i - 1];\n\t}\n}\ntemplate<typename ARR, size_t N>void CuSum(ARR(&arr)[N])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\n#if 0\ntemplate<size_t N, size_t M>void CuSum(int64_t(&arr)[N][M])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\ntemplate<size_t N, size_t M, size_t O>void CuSum(int64_t(&arr)[N][M][O])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\n#endif\n//1-indexed???(]??????\ntemplate<size_t N> int64_t get_sum(int64_t(&arr)[N], int x, int x2)\n{\n\treturn (arr[x2] - arr[x]);\n}\n//1-indexed???(]??????\ntemplate<size_t N, size_t M> int64_t get_sum(int64_t(&arr)[N][M], int x, int y, int x2, int y2)\n{\n\treturn (arr[y2][x2] - arr[y][x2] - arr[y2][x] + arr[y][x]);\n}\n//1-indexed???(]??????\ntemplate<size_t N, size_t M, size_t O> int64_t get_sum(int64_t(&arr)[N][M][O], int x, int y, int z, int x2, int y2, int z2)\n{\n\n\treturn arr(arr[z2][y2][x2] - arr[z][y2][x2] - arr[z2][y][x2] - arr[z2][y2][x] + arr[z2][y][x] + arr[z2][y][x] + arr[z][y][x2] - arr[z][y][x]);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>Q;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tin >> t_x[i]>>t_y[i];\n\t}\n\tDo_CoordinateCompression(t_x, CC_X, CC_X_end);\n\tDo_CoordinateCompression(t_y, CC_Y, CC_Y_end);\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\t++map[t_y[i]][t_x[i]];\n\t}\n\tCuSum(map);\n\twhile (Q--)\n\t{\n\t\tint x, y, x2, y2;\n\t\tin >> x >> y >> x2 >> y2;\n\t\tx = get_coordinate(CC_X,CC_X_end, x); --x;\n\t\tx2 = get_coordinate(CC_X, CC_X_end, x2);\n\t\ty = get_coordinate(CC_Y, CC_Y_end, y); --y;\n\t\ty2 = get_coordinate(CC_Y, CC_Y_end, y2);\n\t\tout << get_sum(map, x, y, x2, y2)<<endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(integer i=0;i<(integer)(n);i++)\n\ntypedef long long int integer;\ntypedef pair<integer,integer> P;\nconst int MAX = 5000;\n\nint acc[MAX + 8][MAX + 8];\nint trecd[MAX + 8][MAX + 8];\n\nint main() {\n  integer n, m;\n  cin >> n >> m;\n  vector<integer> xs, ys;\n  vector<P> treasures(n);\n  for (P &p : treasures) {\n    cin >> p.first >> p.second;\n    xs.push_back(p.first);\n    ys.push_back(p.second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n/*  for (integer x : xs) cout << x << \" \"; cout << endl;\n  for (integer y : ys) cout << y << \" \"; cout << endl;*/\n\n  for (P p : treasures) {\n    integer x = find(xs.begin(), xs.end(), p.first) - xs.begin() + 1;\n    integer y = find(ys.begin(), ys.end(), p.second) - ys.begin() + 1;\n    trecd[x][y]++;\n  }\n  \n  for (integer y = 1; y < MAX; y++) for (integer x = 1; x < MAX; x++) {\n    acc[x][y] = acc[x][y-1] + acc[x-1][y] - acc[x-1][y-1] + trecd[x][y];\n  }\n\n/*  REP(y, 10) {\n    REP(x, 10) {\n      cout << acc[x][y] << \" \";\n    }\n    cout << endl;\n  }*/\n\n  REP (i, m) {\n    integer xb, yb, xe, ye;\n    cin >> xb >> yb >> xe >> ye;\n    xb = upper_bound(xs.begin(), xs.end(), xb - 1) - xs.begin() + 1;\n    yb = upper_bound(ys.begin(), ys.end(), yb - 1) - ys.begin() + 1;\n    xe = *(lower_bound(xs.begin(), xs.end(), xe + 1) - 1);\n    xe = lower_bound(xs.begin(), xs.end(), xe) - xs.begin() + 1;\n    xe = max(xb, xe);\n    ye = *(lower_bound(ys.begin(), ys.end(), ye + 1) - 1);\n    ye = lower_bound(ys.begin(), ys.end(), ye) - ys.begin() + 1;\n    ye = max(yb, ye);\n//    cout << \"(\" << xb << \" \" << yb << \" \" << xe << \" \" << ye << \")\"<< endl;\n    integer ans = acc[xe][ye] - acc[xb-1][ye] - acc[xe][yb-1] + acc[xb-1][yb-1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\ntypedef pair<int, int> P;\n\nint main(){\n  int N, M;\n  while(cin>>N>>M && N){\n    vector<P> p(N);\n    REP(i, N){\n      cin>>p[i].first>>p[i].second;\n    }\n    sort(p.begin(), p.end());\n    REP(i, M){\n      int x1, y1, x2, y2;\n      scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n      vector<P>::iterator it = lower_bound(p.begin(), p.end(), P(x1, INT_MIN));\n      vector<P>::iterator end = lower_bound(p.begin(), p.end(), P(x2 + 1, INT_MIN));\n      int cnt = 0;\n      while(it != end){\n        if(it->second >= y1 && it->second <= y2) cnt++;\n        it++;\n      }\n      printf(\"%d\\n\", cnt);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl;\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//pair?????????\ntemplate<typename T1, typename T2>\nostream &operator << (ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\n\n//??§?¨???§???\n//v: ??§???????????§?¨??????? ????????????\ntemplate<typename T>\nvoid compress(vector<T> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\n//??§?¨???§???(map)\n//v: ??§???????????§?¨??????? ????????????\n//?????????: zip[??§???????????§?¨?]:??§???????????§?¨? (zip.size()<=10^5?????????????????????)\ntemplate<typename T>\nmap<T, T> compressMap(vector<T> &v) {\n\tmap<T, T> zip;\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (T i = 0; i < v.size(); i++) zip[v[i]] = i;\n\treturn zip;\n}\n\n//??§???????????§?¨?\n//index(??§???????????§?¨?, ??§???????????§?¨??????????(??????) )\ntemplate<typename T>\nint index(T i, vector<T> v) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\n#define MAX 5001\n\n//Sample2\n//https://gyazo.com/39c67d1abe7a6a686acb52285f8a0bc9\n\nint main() {\n\t//2?¬?????´???????\n\tstatic int cumsum[MAX][MAX] = {};\n\tint xs[MAX], ys[MAX];\n\tint n, m; cin >> n >> m;\n\tvector<int> x(n + 1), y(n + 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xs[i] >> ys[i];\n\t\tx[i] = xs[i]; y[i] = ys[i];\n\t}\n\tcompress(x);\n\tcompress(y);\n\n\t//map<int, int> zipx(compressMap(x));\n\t//map<int, int> zipy(compressMap(y));\n\t//dump(x);\n\t//dump(zipx);\n\t//dump(y);\n\t//dump(zipy);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint vx = index(xs[i], x);\n\t\tint vy = index(ys[i], y);\n\t\tcumsum[vx + 1][vy + 1]++;\n\t}\n\tfor (int vy = 0; vy < y.size(); vy++)\n\t\tfor (int vx = 0; vx < x.size(); vx++)\n\t\t\tcumsum[vx + 1][vy + 1] += cumsum[vx + 1][vy] + cumsum[vx][vy + 1] - cumsum[vx][vy];\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = index(x1, x);\n\t\tx2 = index(x2 + 1, x);\n\t\ty1 = index(y1, y);\n\t\ty2 = index(y2 + 1, y);\n\t\tcout << cumsum[x2][y2] - cumsum[x2][y1] - cumsum[x1][y2] + cumsum[x1][y1] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\n\nvi compressed_x, compressed_y;\n\nint a[5005*6+2][5005*6+2];\n\nint main()\n{\n    cin >> n >> m;\n\n    int xmi = inf, xma = -inf, ymi = inf, yma = -inf;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        for (int d = -1; d <= 1; ++d) {\n            compressed_x.PB(x[i] + d);\n            compressed_y.PB(y[i] + d);\n        }\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = lower_bound(all(compressed_x), x2) - begin(compressed_x);\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = lower_bound(all(compressed_y), y2) - begin(compressed_y);\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\n#include<set>\n#include<queue>\nusing namespace std;\n\ntypedef long long ll;\n\nint N,M;\nll fie[5111][5111];\nll rui[5111][5111];\nll xy[2][5001];\nll X[5001],Y[5001];\n\nint W,H;\n\nint compress(int id,ll *x){\n  vector<ll> xs;\n  for(int i=0;i<N;i++){\n    xs.push_back(xy[id][i]);\n  }\n\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n\n  for(int i=0;i<N;i++){\n    ll a = find(xs.begin(),xs.end(),xy[id][i]) - xs.begin();\n    a++;\n    x[a] = xy[id][i];\n    xy[id][i] = a;\n  }\n\n  x[0] = -10000000000;\n\n  return (int)xs.size();\n\n}\n\nint nibun(ll a,ll *b,int wh,bool f){\n\n  /*\n  cout << a << \" :: wh = \" << wh << endl;\n  for(int i=0;i<=W;i++)\n    cout << b[i] << \" \";\n  cout << endl;\n  */  \n  int res = lower_bound(b,b+wh+1,a) - b;\n\n  //  cout << res << endl;\n\n  if(b[res] > a && !f) res--;\n\n  return res;\n}\n\nvoid view(){\n  for(int y=0;y<=H+1;y++){\n    for(int x=0;x<=W+1;x++){\n      cout << rui[x][y] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    cin >> xy[0][i] >> xy[1][i];\n  }\n\n  W = compress(0,X);\n  H = compress(1,Y);\n  /*\n  cout << \"W = \" << W << endl;\n  for(int i=1;i<=W;i++)\n    cout << X[i] << \" \";\n  cout << endl;\n  cout << \"H = \" << H << endl;\n  for(int i=1;i<=H;i++)\n    cout << Y[i] << \" \";\n  cout << endl;\n  */\n\n  for(int i=0;i<N;i++){\n    fie[xy[0][i]][xy[1][i]]++;\n  }\n\n\n\n\n  for(int y=1;y<=H+1;y++){\n    for(int x=1;x<=W+1;x++){\n      rui[x][y] = rui[x-1][y] + fie[x][y];\n    }\n  }\n  for(int y=1;y<=H+1;y++){\n    for(int x=1;x<=W+1;x++){\n      rui[x][y] += rui[x][y-1];\n    }\n  }\n\n  for(int i=0;i<M;i++){\n    ll x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = nibun(x1,X,W,true);\n    y1 = nibun(y1,Y,H,true);\n    x2 = nibun(x2,X,W,false);\n    y2 = nibun(y2,Y,H,false);\n    /*\n    cout << x1 << \" \"  << y1 << \" \" << x2 << \" \" << y2 << endl;\n    cout << rui[x2][y2] << \" - \" << rui[x2][y1-1] << \" - \" << rui[x1-1][y2] << \" + \" << rui[x1][y1] << endl;\n    */  \n    int res = rui[x2][y2] - rui[x2][y1-1] - rui[x1-1][y2] + rui[x1-1][y1-1];\n    cout << res << endl;\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair<int,int>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\n\n\n\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector <P> p(n);\n  \n  REP(i,n){\n    cin >> p[i].first >> p[i].second;\n  }\n  sort(p.begin(),p.end());\n  REP(i,m){\n    int x1,x2,y1,y2;\n    int sum = 0;\n    cin >> x1 >> y1 >> x2 >> y2;\n    REP(j,n){\n      if(p[j].first >= x1 && p[j].first <= x2 && p[j].second >= y1 && p[j].second <= y2){\n\tsum++;\n\t\n      }\n      if(x2 < p[j].first){\n\t  break;\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<30\n#define DEBUG 0\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.TH\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nvector<int> x, y;\t\t// 座標\nvector<int> xx, yy;\t// 圧縮した座標\n\nint tp[5005][5005];\n\nvoid compress (void ) \n{\n\tx.push_back (-INF ); y.push_back (-INF );\n\tsort (ALL (x ) ); sort (ALL (y ) );\n\tx.erase (unique (ALL (x ) ), x.end() );\n\ty.erase (unique (ALL (y ) ), y.end() );\n\txx.clear(); yy.clear();\n\tint sx = x.size();\n\tint sy = y.size();\n\txx.resize (sx, 0 ); yy.resize (sy, 0 );\n\trep (j, sx ){\n\t\txx[j] = x[j];\n\t} // end rep\n\trep (i, sy ){\n\t\tyy[i] = y[i];\n\t} // end rep\n}\n\nint sum (int sx, int sy, int ex, int ey )\n{\n\tint ssx = max (sx-1, 0 );\n\tint ssy = max (sy-1, 0 );\n\n\treturn (tp[ey][ex] - tp[ssy][ex] - tp[ey][ssx] + tp[ssy][ssx] );\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tmemset (tp, 0, sizeof (tp ) );\n\tint n, m;\n\tscanf (\"%d %d\", &n, &m );\n\tmap<P,int> cnt; cnt.clear();\n\tx.clear(); y.clear();\n\tvector<int> tx (n, 0 ), ty (n, 0 );\n\trep (i, n ){\n\t\tscanf (\"%d %d\", &tx[i], &ty[i] );\n\t\tcnt[P(ty[i],tx[i])]++;\n\t\tx.push_back (tx[i] ); y.push_back (ty[i] );\n\t} // end rep\n\n\tcompress ();\n\tint nx = x.size();\n\tint ny = y.size();\n\ttp[0][0] = cnt[P(yy[0],xx[0])];\n\trep (i, ny ) rep (j, nx ){\n\t\ttp[i][j] = cnt[P(yy[i], xx[j] )];\n\t} // end rep\n\n\tfor (int i = 0; i < ny; i++ ){\n\t\tfor (int j = 1; j < nx; j++ ){\n\t\t\ttp[i][j] += tp[i][j-1];\n\t\t} // end for\n\t} // end for\n\n\tfor (int i = 1; i < ny; i++ ){\n\t\tfor (int j = 0; j < nx; j++ ){\n\t\t\ttp[i][j] += tp[i-1][j];\n\t\t} // end for\n\t} // end for\n\n\trep (j, m ){\n\t\tint x1, y1, x2, y2;\n\t\tscanf (\"%d %d %d %d\", &x1, &y1, &x2, &y2 );\n\t\tint xx1 = lower_bound (ALL (xx ), x1 ) - xx.begin();\t\n\t\tint xx2 = upper_bound (ALL (xx ), x2 ) - xx.begin() - 1;\n\t\tint yy1 = lower_bound (ALL (yy ), y1 ) - yy.begin();\n\t\tint yy2 = upper_bound (ALL (yy ), y2 ) - yy.begin() - 1;\n\t\tint res = 0;\n\t\tif (xx1 <= xx2 && yy1 <= yy2 )\n\t\t\tres = sum (xx1, yy1, xx2, yy2 );\n\t\tprintf (\"%d\\n\", res );\n\t} // end rep\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cstdio>\n#include<vector>\n#define F first\n#define S second\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  vector<pair<int,int> > pii(n);\n  for(int i=0;i<n;i++)\n    cin>>pii[i].first>>pii[i].second;\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    int cnt=0;\n    for(int j=0;j<n;j++){\n      if(x1<=pii[j].first&&pii[j].first<=x2&&y1<=pii[j].second&&pii[j].second<=y2)\n\tcnt++;\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\nusing namespace std;\n#define REP(i, a, n) for(int i=a; i<n; i++)\n\nstruct St {\n\tint x1;\n\tint y1;\n\tint x2;\n\tint y2;\n};\n\nSt r[500001];\nint imos[5001][5001];\nint main()\n{\n\tint n, m;\n\tvector<int> x, y;\n\tvector<int> vx, vy;\n\tcin >> n >> m;\n\tREP(i, 0, n) {\n\t\tint xx, yy;\n\t\tcin >> xx >> yy;\n\t\tx.push_back(xx);\n\t\ty.push_back(yy);\n\t\tvx.push_back(xx);\n\t\tvy.push_back(yy);\n\t}\n\tREP(i, 0, m) {\n\t\tcin >> r[i].x1 >> r[i].y1 >> r[i].x2 >> r[i].y2;\n\t}\n\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\n\tREP(i, 0, n + 1) imos[i][0] = imos[0][i] = 0;\n\tREP(i, 0, n) {\n\t\tint tx = lower_bound(x.begin(), x.end(), vx[i]) - x.begin();\n\t\tint ty = lower_bound(y.begin(), y.end(), vy[i]) - y.begin();\n\t\t++imos[ty + 1][tx + 1];\n\t}\n\n\tREP(i, 0, y.size()) {\n\t\tREP(j, 0, x.size()) {\n\t\t\timos[i + 1][j + 1] += imos[i + 1][j] + imos[i][j + 1] - imos[i][j];\n\t\t}\n\t}\n\n\tREP(i, 0, m) {\n\t\tint xx1, yy1, xx2, yy2;\n\t\txx1 = lower_bound(x.begin(), x.end(), r[i].x1) - x.begin();\n\t\tyy1 = lower_bound(y.begin(), y.end(), r[i].y1) - y.begin();\n\t\txx2 = lower_bound(x.begin(), x.end(), r[i].x2 + 1) - x.begin();\n\t\tyy2 = lower_bound(y.begin(), y.end(), r[i].y2 + 1) - y.begin();\n\n\t\tcout << imos[yy2][xx2] - imos[yy2][xx1] - imos[yy1][xx2] + imos[yy1][xx1] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\n\nint H, W;\nvector<int> X, Y;\n\nvoid init_number(vector<P> &ps){\n  set<int> Ys, Xs;\n  REP(i, ps.size()){\n    Xs.insert(ps[i].first);\n    Ys.insert(ps[i].second);\n  }\n  Ys.insert((1e9 + 10) * -1);\n  Ys.insert(1e9 + 10);\n  Xs.insert((1e9 + 10) * -1);\n  Xs.insert(1e9 + 10);\n  X = vector<int>(Xs.begin(), Xs.end());\n  Y = vector<int>(Ys.begin(), Ys.end());\n  W = X.size();\n  H = Y.size();\n}\n\nint number(int n, vector<int> &v){\n  return lower_bound(v.begin(), v.end(), n) - v.begin();\n}\n\nvoid init(vector< vector<int> > &v, vector< vector<int> > &E){\n  E[0][0] = v[0][0];\n  FOR(i, 1, H) E[i][0] = E[i - 1][0] + v[i][0];\n  FOR(i, 1, W) E[0][i] = E[0][i - 1] + v[0][i];\n  FOR(y, 1, H)\n    FOR(x, 1, W)\n    E[y][x] = v[y][x] + E[y - 1][x] + E[y][x - 1] - E[y - 1][x - 1];\n}\n\nint calc(int Y1, int X1, int Y2, int X2, vector< vector<int> > &E){\n  int ret = E[Y2][X2];\n  if(X1 - 1 >= 0) ret -= E[Y2][X1 - 1];\n  if(Y1 - 1 >= 0) ret -= E[Y1 - 1][X2];\n  if(X1 - 1 >= 0 && Y1 - 1 >= 0) ret += E[Y1 - 1][X1 - 1];\n  return ret;\n}\n\nint main() {\n  int N, M; cin >>N >>M;\n  vector<P> ps(N + M + M), ts(N), ls(M), rs(M);\n  REP(i, N){\n    cin >>ts[i].first >>ts[i].second;\n    ps[i] = ts[i];\n  }\n  REP(i, M){\n    cin >>ls[i].first >>ls[i].second >>rs[i].first >>rs[i].second;\n    ps[(i * 2) + N] = ls[i];\n    ps[1 + (i * 2) + N] = rs[i];\n  }\n  init_number(ps);\n  vector< vector<int> > v(H, vector<int>(W, 0)), E(H, vector<int>(W, 0));\n  REP(i, N) v[number(ts[i].second, Y)][number(ts[i].first, X)] += 1;\n  init(v, E);\n  REP(i, M) cout <<calc(number(ls[i].second, Y), number(ls[i].first, X), number(rs[i].second, Y), number(rs[i].first, X), E) <<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nvector<int> x,y,xx,yy;\nint imos[5001][5001];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b;cin>>a>>b;\n    xx.push_back(a);\n    x.push_back(a);\n    yy.push_back(b);\n    y.push_back(b);\n  }\n  x.push_back(-1000001000);\n  y.push_back(-1000001000);\n  x.push_back(1000001000);\n  y.push_back(1000001000);\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  for(int i=0;i<n;i++){\n    xx[i]=lower_bound(x.begin(),x.end(),xx[i])-x.begin();\n    yy[i]=lower_bound(y.begin(),y.end(),yy[i])-y.begin();\n  }\n  h=(int)y.size();\n  w=(int)x.size();\n  for(int i=0;i<n;i++){\n    imos[yy[i]][xx[i]]++;\n  }\n  for(int i=0;i<h;i++)for(int j=1;j<w;j++)imos[i][j]+=imos[i][j-1];\n  for(int i=1;i<h;i++)for(int j=0;j<w;j++)imos[i][j]+=imos[i-1][j];\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;\n    auto xa=lower_bound(x.begin(),x.end(),x1);\n    if(*xa>=x1)xa--;\n    auto xb=lower_bound(x.begin(),x.end(),x2);\n    if(*xb>x2)xb--;\n    auto ya=lower_bound(y.begin(),y.end(),y1);\n    if(*ya>=y1)ya--;\n    auto yb=lower_bound(y.begin(),y.end(),y2);\n    if(*yb>y2)yb--;\n    x1=xa-x.begin();x2=xb-x.begin();y1=ya-y.begin();y2=yb-y.begin();\n    cout<<imos[y2][x2]-imos[y2][x1]-imos[y1][x2]+imos[y1][x1]<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\ntypedef complex<int> point;\n\nstruct kdtree {\n  struct node {\n    point p;\n\tint id;\n    node *l, *r;\n    node(const point &p,int _id)\n      : p(p), l(NULL), r(NULL), id(_id) { }\n  } *root;\n  int id;\n  kdtree() : root(NULL), id(0) { }\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n  void insert(const point &p) {\n    root = insert(root, 0, p);\n  }\n  node *insert(node *t, int d, const point &p) {\n    if (t == NULL) return new node(p,id++);\n    if (compare(d,p,t->p)) t->l = insert(t->l, !d, p);\n    else                   t->r = insert(t->r, !d, p);\n    return t;\n  }\n  void search(const point &ld, const point &ru, vector<int> &out) {\n    search(root, 0, ld, ru, out);\n  }\n  void search(node *t, int d, const point &ld, const point &ru, vector<int> &out) {\n    if (t == NULL) return;\n    const point &p = t->p;\n    if (real(ld) <= real(p) && real(p) <= real(ru) &&\n        imag(ld) <= imag(p) && imag(p) <= imag(ru)) out.push_back(t->id);\n    if (!compare(d,p,ld)) search(t->l, !d, ld, ru, out);\n    if (!compare(d,ru,p)) search(t->r, !d, ld, ru, out);\n  }\n};\n\nint main(){\n\tint n,m,x1,x2,y1,y2;\n\tkdtree kd;\n\tfor(scanf(\"%d%d\",&n,&m);n--;){\n\t\tscanf(\"%d%d\",&x1,&y1);\n\t\tkd.insert(point(x1,y1));\n\t}\n\tfor(;m--;){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tvector<int>out;\n\t\tkd.search(point(x1,y1),point(x2,y2),out);\n\t\tprintf(\"%d\\n\",out.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  set<int> X, Y;\n  vector<int> xs(N), ys(N);\n  rep(i, N) {\n    cin >> xs[i] >> ys[i];\n    X.insert(xs[i]); Y.insert(ys[i]);\n  }\n\n  vector<int> rx1(M), ry1(M), rx2(M), ry2(M);\n  rep(i, M) {\n    cin >> rx1[i] >> ry1[i] >> rx2[i] >> ry2[i];\n    X.insert(rx1[i]); Y.insert(ry1[i]);\n    X.insert(rx2[i]); Y.insert(ry2[i]);\n  }\n\n  map<int, int> MX, MY;\n  int W = 0; for(auto && e: X) MX[e] = W++;\n  int H = 0; for(auto && e: Y) MY[e] = H++;\n\n  static ll sum[5100][5100];\n\n  rep(i, N) {\n    sum[MY[ys[i]]][MX[xs[i]]] ++;\n  }\n\n  rep(i, H) rep(j, W) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int x1 = MX[rx1[i]], x2 = MX[rx2[i]];\n    int y1 = MY[ry1[i]], y2 = MY[ry2[i]];\n    ll r = sum[y2][x2];\n    if(x1 && y1) r += sum[y1-1][x1-1];\n    if(y1) r -= sum[y1-1][x2];\n    if(x1) r -= sum[y2][x1-1];\n    cout << r << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define MAX_BIT 32\n\nstruct BitRank {\n    // block:bit列を管理, count:blockごとに立っている1の数を管理\n    vector<uint> block;\n    vector<int> count;\n    BitRank(){}\n    void resize(int num) {\n        block.resize((num+MAX_BIT-1)/MAX_BIT, 0);\n        count.resize((int)block.size(), 0);\n    }\n    // 立っているbitの数を返す\n    inline int popcount(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        return (((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n    // iビット目をval(0,1)にセット\n    inline void set(int i, int val) {\n        block[i/MAX_BIT] |= (val << (i%MAX_BIT));\n    }\n    void build() {\n        for(int i = 1; i < (int)block.size(); i++){\n            count[i] = count[i-1] + popcount(block[i-1]);\n        }\n    }\n    // iビット以下の1の数\n    int rank1(int i) {\n        return (i < 0)?0:(count[i/MAX_BIT]+popcount(block[i/MAX_BIT]<<(MAX_BIT-i%MAX_BIT-1)));\n    }\n    // jビット目からiビット目までの1の数\n    int rank1(int i,int j) {\n        return rank1(j) - rank1(i-1);\n    }\n    // iビット以下の0の数\n    int rank0(int i) {\n        return (i<0)?0:(i-rank1(i)+1);\n    }\n    // jビット目からiビット目までの0の数\n    int rank0(int i, int j) {\n        return rank0(j) - rank0(i-1);\n    }\n};\n\nclass WaveletMatrix\n{\nprivate:\n    uint height;\n    vector<BitRank> B;\n    vector<int> pos;\npublic:\n    WaveletMatrix(){}\n    WaveletMatrix(vector<int>& vec) :\n        WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}\n    // sigma:文字の種類数\n    WaveletMatrix(vector<int>& vec, int sigma){\n        init(vec, sigma);\n    }\n    void init(vector<int>& vec, int sigma){\n        height = MAX_BIT - __builtin_clz(sigma-1);\n        B.resize(height), pos.resize(height);\n        for(uint i = 0; i < height; i++){\n            B[i].resize((int)vec.size());\n            for(int j = 0; j < (int)vec.size(); j++) {\n                B[i].set(j, access(vec[j], height - i - 1));\n            }\n            B[i].build();\n            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {\n                return !access(c, height - i - 1);\n            });\n            pos[i] = it - vec.begin();\n        }\n    }\n    // valのiビット目の値を返す(0,1)\n    inline int access(int val, int i) {\n        return (val >> i) & 1;\n    }\n    // [l,r]の間に現れる値cの数\n    int rank(int val,int l,int r) {\n        return rank(val, r) - rank(val, l - 1);\n    }\n    int rank(int val, int i) {\n        int p = -1;\n        for(uint j = 0; j < height; j++){\n            if(access(val, height - j - 1)){\n                p = pos[j] + B[j].rank1(p) - 1;\n                i = pos[j] + B[j].rank1(i) - 1;\n            }else{\n                p = B[j].rank0(p) - 1;\n                i = B[j].rank0(i) - 1;\n            }\n        }\n        return i - p;\n    }\n    // [l,r]のk(1,2,3...)番目に小さい値を返す\n    int quantile(int k, int l, int r) {\n        int res = 0;\n        for(uint i = 0; i < height; i++){\n            int j = B[i].rank0(l, r);\n            if(j >= k){\n                l = B[i].rank0(l-1);\n                r = B[i].rank0(r) - 1;\n            }else{\n                l = pos[i] + B[i].rank1(l-1);\n                r = pos[i] + B[i].rank1(r) - 1;\n                k -= j;\n                res |= (1 << (height - i - 1));\n            }\n        }\n        return res;\n    }\n    // [l,r]で値が[a,b]内に含まれる数を返す\n    int rangefreq(int l, int r, int a, int b) {\n        return rangefreq(l, r, a, b, 0, (1 << height) - 1, 0);\n    }\n    int rangefreq(int i, int j, int a, int b, int l, int r, int x) {\n        if(b < l || r < a) return 0;\n        int mid = l + (r - l) / 2;\n        if(a <= l && r <= b){\n            return j - i + 1;\n        }else{\n            int left = rangefreq(B[x].rank0(i-1),B[x].rank0(j)-1,a,b,l,mid,x+1);\n            int right = rangefreq(pos[x]+B[x].rank1(i-1),pos[x]+B[x].rank1(j)-1,a,b,mid+1,r,x+1);\n            return left + right;\n        }\n    }\n};\n\ntemplate<typename T> class OrthogonalRegionCount\n{\nprivate:\n    using ptt = pair<T, T>;\n    vector<T> X, Y;\n    WaveletMatrix wm;\n    int n;\npublic:\n    OrthogonalRegionCount(vector<ptt> candidate) {\n        int n = (int)candidate.size();\n        sort(candidate.begin(), candidate.end());\n        X.resize(n), Y.resize(n);\n        vector<T> vec(n);\n        rep(i,n){\n            X[i] = candidate[i].first, Y[i] = candidate[i].second;\n        }\n        sort(Y.begin(), Y.end());\n        Y.erase(unique(Y.begin(), Y.end()), Y.end());\n        rep(i,n){\n            vec[i] = lower_bound(Y.begin(), Y.end(), candidate[i].second) - Y.begin();\n        }\n        wm.init(vec, (int)Y.size());\n    }\n    //[lx,rx)×[ly,ry)の長方形領域に含まれる点の数を答える\n    int query(T lx, T ly, T rx, T ry) {\n        int lxid = lower_bound(X.begin(), X.end(), lx) - X.begin();\n        int rxid = upper_bound(X.begin(), X.end(), rx-1) - X.begin();\n        int lyid = lower_bound(Y.begin(), Y.end(), ly) - Y.begin();\n        int ryid = upper_bound(Y.begin(), Y.end(), ry-1) - Y.begin();\n        return wm.rangefreq(lxid, rxid-1, lyid, ryid-1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vp vec(n);\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        vec[i] = P(a,b);\n    }\n    OrthogonalRegionCount<int> tdc(vec);\n    rep(i,m){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        cout << tdc.query(a,b,c+1,d+1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <algorithm>\n#include <cmath>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdlib>\n#include <bitset>\n#include <tuple>\n#include <assert.h>\n#include <deque>\n#include <bitset>\n#include <iomanip>\n#include <limits>\n#include <chrono>\n#include <random>\n#include <array>\n#include <unordered_map>\n#include <functional>\n#include <complex>\n#include <numeric>\n#include <cctype>\n\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\n//constexpr long long MAX = 5100000;\nconstexpr long long INF = 1LL << 60;\nconstexpr int inf = 1000000007;\nconstexpr long long mod = 1000000007LL;\n//constexpr long long mod = 998244353LL;\nconst long double PI = acos((long double)(-1));\n\nusing namespace std;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n\n\ntemplate<typename T>\nstruct Compress {\n\tvector<T> v;\n\tCompress() {}\n\tCompress(vector<T> _v) :v(_v) {\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t}\n\n\tvoid build(vector<T> _v) {\n\t\tv = _v;\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t}\n\tint get(T x) {\n\t\treturn lower_bound(v.begin(), v.end(), x) - v.begin();\n\t}\n\n\tint upper_bound(T x) {\n\t\treturn std::upper_bound(v.begin(), v.end(), x) - v.begin();\n\t}\n\tT& operator[](int i) { return v[i]; }\n\n\n\tint size() {\n\t\treturn (int)v.size();\n\t}\n};\n\ntemplate<class T>\nstruct CumulativeSum2D {\n\tvector<vector<T>> data;\n\tint H, W;\n\tCumulativeSum2D() :H(0), W(0) {}\n\tCumulativeSum2D(int _H, int _W) :H(_H), W(_W) {\n\t\tdata.assign(H + 1, vector<T>(W + 1));\n\t}\n\tCumulativeSum2D(vector<vector<T>>& _data) :H(_data.size()), W(_data[0].size()) {\n\t\tdata.assign(H + 1, vector<T>(W + 1));\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) data[i + 1][j + 1] += _data[i][j];\n\t\tbuild();\n\t}\n\n\tvoid add(int h, int w, T x) {\n\t\tdata[h + 1][w + 1] += x;\n\t}\n\tvoid build() {\n\t\tfor (int i = 0; i < H; i++) for (int j = 0; j < W; j++) data[i + 1][j + 1] += data[i + 1][j] + data[i][j + 1] - data[i][j];\n\t}\n\n\tT query(int sh, int sw, int gh, int gw) const {\n\t\treturn data[gh][gw] - data[sh][gw] - data[gh][sw] + data[sh][sw];\n\t}\n};\nint main()\n{\n\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\n\tint n, m; cin >> n >> m;\n\tCompress<ll> cx, cy;\n\tvector<ll> vx(n), vy(n);\n\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> vx[i] >> vy[i];\n\t}\n\tcx.build(vx);\n\tcy.build(vy);\n\tCumulativeSum2D<int> sum(cx.size() + 1, cy.size() + 1);\n\tfor (int i = 0; i < n; i++) {\n\t\tsum.add(cx.get(vx[i]), cy.get(vy[i]), 1);\n\t}\n\tsum.build();\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = cx.get(x1);\n\t\ty1 = cy.get(y1);\n\t\tx2 = cx.upper_bound(x2);\n\t\ty2 = cy.upper_bound(y2);\n\t\tcout << sum.query(x1, y1, x2, y2) << \"\\n\";\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "//27\n\n\n//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()+1]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()+1]++;\n  }\n  vector<vector<int> > ag(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=1;i<ag.size();i++){\n    for(int j=1;j<ag[i].size();j++){\n      ag[i][j]=ag[i][j-1]+ag[i-1][j]-ag[i-1][j-1]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=upper_bound(xp.begin(),xp.end(),xh)-xp.begin();\n    yyh=upper_bound(yp.begin(),yp.end(),yh)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[xxl][yyl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    \n    vector<int> A(n*n, 0);\n    vector<int> x(n);\n    vector<int> y(n);\n    vector<int> xb(m);\n    vector<int> yb(m);\n    vector<int> xe(m);\n    vector<int> ye(m);\n    vector<int> xs;\n    vector<int> ys;\n    \n    for(int j = 0; j < n; j++)\n        cin >> x[j] >> y[j];\n    \n    for(int i = 0; i < m; i++)\n        cin >> xb[i] >> yb[i] >> xe[i] >> ye[i];\n    \n    xs = x;\n    ys = y;\n    sort( xs.begin(), xs.end() );\n    sort( ys.begin(), ys.end() );\n    xs.erase( unique( xs.begin(), xs.end() ), xs.end() );\n    ys.erase( unique( ys.begin(), ys.end() ), ys.end() );\n    \n    for(int j = 0; j < n; j++){\n        x[j] = find( xs.begin(), xs.end(), x[j] ) - xs.begin();\n        y[j] = find( ys.begin(), ys.end(), y[j] ) - ys.begin();\n    }\n    \n    for(int i = 0; i < m; i++){\n        xb[i] = lower_bound( xs.begin(), xs.end(), xb[i] ) - xs.begin();\n        yb[i] = lower_bound( ys.begin(), ys.end(), yb[i] ) - ys.begin();\n        xe[i] = upper_bound( xs.begin(), xs.end(), xe[i] ) - xs.begin() - 1;\n        ye[i] = upper_bound( ys.begin(), ys.end(), ye[i] ) - ys.begin() - 1;\n    }\n    \n    \n    \n    for(int j = 0; j < n; j++){\n        A[ n*y[j] + x[j] ] += 1;\n    }\n    \n    for(int j = 0; j < n; j++){\n        for(int k = 1; k < n; k++){\n            A[n*j+k] += A[n*j+k-1];\n        }\n    }\n    for(int k = 0; k < n; k++){\n        for(int j = 1; j < n; j++){\n            A[n*j+k] += A[n*(j-1)+k];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        if(xe[i] < 0 || ye[i] < 0 || xb[i] == (int)xs.size() || yb[i] == (int)ys.size()){\n            cout << 0 <<endl;\n            continue;\n        }\n        int a, b, c;\n        if(xb[i] > 0 && yb[i] > 0)\n            c = A[ n*(yb[i]-1) + (xb[i]-1) ];\n        else\n            c = 0;\n        if(xb[i] > 0)\n            a = A[ n*ye[i] + (xb[i]-1) ];\n        else\n            a = 0;\n        if(yb[i] > 0)\n            b = A[ n*(yb[i]-1) + xe[i] ];\n        else\n            b = 0;\n        cout << A[ n*ye[i] + xe[i] ] - a - b + c <<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(vector<Pos>& pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tcout << Count(pos, x1, y1, x2, y2);\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\n#define pb push_back\n#define all(vec) (vec).begin(),(vec).end()\n\nconst int INF = 2000000000;\n\nint x[5000], y[5000];\nint sx[500000], sy[500000], ex[500000], ey[500000];\nshort num[5000][5000];\n\nint find(VI &zip, int key, int type = 0)\n{\n\tint l = 0, r = zip.size() - 1;\n\twhile (true){\n\t\tif (l > r) return type ? l : r;\n\t\tint m = (l + r) / 2;\n\t\tif (zip[m] == key) return m;\n\t\tif (zip[m] < key) l = m + 1;\n\t\telse r = m - 1;\n\t}\n}\n\nint main()\n{\n\tVI zip_x; zip_x.pb(-INF); zip_x.pb(INF);\n\tVI zip_y; zip_y.pb(-INF); zip_y.pb(INF);\n\t\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tzip_x.pb(x[i]);\n\t\tzip_y.pb(y[i]);\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &ex[i], &ey[i]);\n\t\t//zip_x.pb(sx[i]);\n\t\t//zip_y.pb(sy[i]);\n\t\t//zip_x.pb(ex[i]);\n\t\t//zip_y.pb(ey[i]);\n\t}\n\t\n\t\n\t// 座標圧縮\n\tsort(all(zip_x));\n\tzip_x.erase(unique(all(zip_x)), zip_x.end());\n\tsort(all(zip_y));\n\tzip_y.erase(unique(all(zip_y)), zip_y.end());\n\t\n\t\n\t// 圧縮後の座標を受け取る\n\tfor (int i = 0; i < n; i++){\n\t\tx[i] = find(zip_x, x[i]);\n\t\ty[i] = find(zip_y, y[i]);\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tsx[i] = find(zip_x, sx[i], 1);\n\t\tsy[i] = find(zip_y, sy[i], 1);\n\t\tex[i] = find(zip_x, ex[i]);\n\t\tey[i] = find(zip_y, ey[i]);\n\t}\n\t\n\t\n\t//累積和\n\tfor (int i = 0; i < n; i++){\n\t\tnum[x[i]][y[i]]++;\n\t}\n\tfor (int i = 1; i < zip_x.size(); i++){\n\t\tfor (int j = 1; j < zip_y.size(); j++){\n\t\t\tnum[i][j] += num[i - 1][j];\n\t\t\tnum[i][j] += num[i][j - 1];\n\t\t\tnum[i][j] -= num[i - 1][j - 1];\n\t\t}\n\t}\n\t\n\t/*\n\tputs(\"\");\n\tfor (int i = 0; i < zip_x.size(); i++){\n\t\tfor (int j = 0; j < zip_y.size(); j++){\n\t\t\tprintf(\"%d \", num[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n\t*/\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint res = num[ex[i]][ey[i]];\n\t\tres -= num[sx[i] - 1][ey[i]];\n\t\tres -= num[ex[i]][sy[i] - 1];\n\t\tres += num[sx[i] - 1][sy[i] - 1];\n\t\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n//1/24 ???????????????\n\n#include<iostream>\n#include<fstream>\n\n#include<vector>\n\n#define fin cin\n\n\nusing namespace std;\n\nclass Coordinate{\n\npublic:\n    int x;\n    int y;\n    Coordinate():\n    x(0), y(0){\n\n    }\n    Coordinate(int _x, int _y):\n    x(_x), y(_y){\n\n    }\n\n    bool inside(Coordinate l_d, Coordinate r_u) const{\n       if(this->x < l_d.x)return false;\n       if(this->y < l_d.y)return false;\n       if(r_u.x < this->x)return false;\n       if(r_u.y < this->y)return false;\n       return true;\n    }\n\n};\n\nint main(){\n    //ifstream fin(\"in.txt\");\n\n    int n, m;\n    fin >> n >> m;\n\n    vector<Coordinate> spot;\n    \n    //????????´??????input\n    for(int i = 0; i < n; i++){\n        spot.push_back(Coordinate());\n        fin >> spot[i].x;\n        fin >> spot[i].y;\n    }\n\n    //?????????input\n    Coordinate *l_u = new Coordinate[m];//left-up\n    Coordinate *r_d = new Coordinate[m];//right-down\n    for(int i = 0; i < m; i++){\n\n        int tmp_x, tmp_y;\n        fin >> tmp_x >> tmp_y;\n\n        l_u[i] = Coordinate(tmp_x, tmp_y);\n\n        fin >> tmp_x >> tmp_y;\n\n        r_d[i] = Coordinate(tmp_x, tmp_y);\n\n    }\n\n    for(int i = 0; i < m; i++){\n        int ans = 0;\n        for(int j = 0; j < n; j++){\n            if(spot[j].inside(l_u[i], r_d[i]))ans++;\n        }\n        cout << ans << endl;\n    }\n\n    \n\n\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 100;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) != EOF) {\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d%d\", &ps[i].first, &ps[i].second);\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int b = 0; b < BNUM; ++b) {\n      sort(bucket[b].begin(), bucket[b].end());\n    }\n    while(m--) {\n      int s, t, u, v; \n      scanf(\"%d%d%d%d\", &s, &t, &u, &v);\n      int l = lower_bound(x, x+n, s) - x;\n      int r = upper_bound(x, x+n, u) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (t <= y[l] && y[l] <= v);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (t <= y[r] && y[r] <= v);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), v)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), t);\n        l += B;\n      }\n      printf(\"%d\\n\", res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <vector>\n#include <climits>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\nint n, m;\nint x[5002], y[5002];\nint sum[5002][5002];\nset<int> setx, sety;\nvector<int> vx, vy;\n\nint main(){\n  while(cin >> n >> m){\n    setx.clear();\n    sety.clear();\n\n    setx.insert(INT_MIN);\n    sety.insert(INT_MIN);\n\n    for(int i = 0; i < n; i++){\n      cin >> x[i] >> y[i];\n      setx.insert(x[i]);\n      sety.insert(y[i]);\n    }\n\n    vx.clear();\n    vy.clear();\n\n    for(set<int>::iterator iter = setx.begin(); iter != setx.end(); iter++){\n      vx.push_back(*iter);\n    }\n    for(set<int>::iterator iter = sety.begin(); iter != sety.end(); iter++){\n      vy.push_back(*iter);\n    }\n\n    memset(sum, 0, sizeof(sum));\n\n    for(int i = 0; i < n; i++){\n      int idxx = find(vx.begin(), vx.end(), x[i]) - vx.begin();\n      int idxy = find(vy.begin(), vy.end(), y[i]) - vy.begin();\n      sum[idxx][idxy]++;\n    }\n\n    for(int i = 1; i < vx.size(); i++){\n      for(int j = 1; j < vy.size(); j++){\n        sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\n      }\n    }\n\n    /*\n    for(int i = 0; i < vx.size(); i++){\n      for(int j = 0; j < vy.size(); j++){\n        printf(\"%3d\", sum[i][j]);\n      }\n      cout << endl;\n    }\n    */\n\n    for(int i = 0; i < m; i++){\n      int lx, ly, hx, hy;\n      cin >> lx >> ly >> hx >> hy;\n\n      int idx_lx = lower_bound(vx.begin(), vx.end(), lx) - vx.begin();\n      int idx_ly = lower_bound(vy.begin(), vy.end(), ly) - vy.begin();\n      int idx_hx = upper_bound(vx.begin(), vx.end(), hx) - vx.begin() - 1;\n      int idx_hy = upper_bound(vy.begin(), vy.end(), hy) - vy.begin() - 1;\n\n      if(idx_lx > idx_hx || idx_ly > idx_hy){\n        cout << 0 << endl;\n        continue;\n      }\n\n      //cout<<idx_lx<<\", \"<<idx_ly<<\", \"<<idx_hx<<\", \"<<idx_hy<<endl;\n\n      int calc =\n        sum[idx_hx    ][idx_hy    ] -\n        sum[idx_lx - 1][idx_hy    ] -\n        sum[idx_hx    ][idx_ly - 1] +\n        sum[idx_lx - 1][idx_ly - 1];\n\n      cout << calc << endl;\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <memory>\n#include <array>\n#include <set>\n#include <tuple>\n#include <vector>\n#include <iostream>\n#include <cstdint>\n#include <cassert>\n#include <bitset>\n\nstruct dynamic_bitvector {\n\n\n  struct node;\n  using size_type = std::size_t;\n  using height_type = long long;\n  using node_type = std::unique_ptr<struct node>;\n  using node_reference = const node_type&;\n  using bits_type = std::uint64_t;\n  using children_type = std::array<node_type, 2>;\n\n\n  const static size_type bit_limit = 32;\n\n  struct bitvector_builder {\n    const static size_type bit_size = bit_limit * 2;\n    const size_type len;\n    std::vector<bits_type> bits;\n    bitvector_builder(size_type len): len(len), bits(len / bit_size + !!(len & (bit_size - 1))) {}\n    void set(size_type i) { bits[i / bit_size] |= (bits_type(1) << (i & (bit_size - 1))); }\n    dynamic_bitvector build() const {\n      return dynamic_bitvector(bits, len);\n    }\n  };\n\n  static size_type bits_popcount(bits_type bits) {\n    return __builtin_popcountll(bits);\n  }\n\n  struct section_t {\n    height_type he;\n    children_type ch;\n  };\n\n  struct leaf_t {\n    bits_type bits;\n  };\n\n  union info_t {\n    section_t section;\n    leaf_t leaf;\n    info_t(section_t sec): section(std::move(sec)) {}\n    info_t(leaf_t leaf): leaf(leaf) {}\n    ~info_t() {}\n  };\n\n  struct node {\n    const bool is_leaf;\n    size_type sz;\n    size_type popcnt;\n    info_t info;\n\n    static node_type new_section(node_type left, node_type right) {\n      node* n = new node(section_t { 0, children_type { std::move(left), std::move(right) } });\n      n->fix();\n      return node_type(n);\n    }\n\n    static node_type new_leaf(bits_type bits, size_type sz, size_type popcnt) {\n      node* n = new node(leaf_t { bits });\n      n->sz = sz;\n      n->popcnt = popcnt;\n      return node_type(n);\n    }\n\n    node(section_t sec): is_leaf(false), info(std::move(sec)) {}\n    node(leaf_t leaf): is_leaf(true), info(leaf) {}\n\n    height_type height() const {\n      if(is_leaf) return 0;\n      else return info.section.he;\n    }\n    size_type size() const {\n      return sz;\n    }\n\n    size_type popcount() const {\n      return popcnt;\n    }\n\n    // operation for only section node\n\n    node_type take(size_type dir) {\n      assert(!is_leaf);\n      return std::move(info.section.ch[dir]);\n    }\n\n    node_type swap(size_type dir, node_type new_node) {\n      assert(!is_leaf);\n      node_type old_node = take(dir);\n      info.section.ch[dir] = std::move(new_node);\n      return old_node;\n    }\n\n    const node_type& child(size_type dir) const {\n      assert(!is_leaf);\n      return info.section.ch[dir];\n    }\n\n    height_type diff() const {\n      assert(!is_leaf);\n      return child(0)->height() - child(1)->height();\n    }\n\n    void fix() {\n      assert(!is_leaf);\n      sz = child(0)->size() + child(1)->size();\n      popcnt = child(0)->popcount() + child(1)->popcount();\n      info.section.he = std::max(child(0)->height(), child(1)->height()) + 1;\n    }\n\n    // operation for only leaf node\n\n    bits_type bits() const {\n      assert(is_leaf);\n      return info.leaf.bits;\n    }\n\n    bool at_bits(size_type pos) const {\n      assert(is_leaf);\n      return (bits() >> pos) & 1;\n    }\n\n    size_type rank(size_type pos) const {\n      assert(pos <= size());\n      return bits_popcount(bits() & ((bits_type(1) << pos) - 1));\n    }\n\n    void set_bits(bits_type bits, size_type sz_, size_type popcnt_) {\n      assert(is_leaf);\n      sz = sz_;\n      popcnt = popcnt_;\n      info.leaf.bits = bits;\n    }\n\n    // [0, pos) and [pos, sz)\n    std::pair<bits_type, bits_type> split_bits(size_type pos) const {\n      assert(is_leaf);\n      assert(pos <= size());\n      return std::make_pair(bits() & ((bits_type(1) << pos) - 1), bits() >> pos);\n    }\n\n    void insert_bit(size_type pos, bool bit) {\n      assert(is_leaf);\n      assert(sz < bit_limit * 2);\n      bits_type l, r;\n      std::tie(l, r) = split_bits(pos);\n     // std::cout << \"insert \" << bit  << \" to \" << pos << std::endl;\n     // std::cout << \"insert \" << std::bitset<bit_limit * 2>(l) << \" \" << std::bitset<bit_limit * 2>(r) << std::endl;\n     // std::cout << \"insert \" << std::bitset<bit_limit * 2>(bits()) << \" -> \" << std::bitset<bit_limit * 2>(l | ((bits_type(bit) << pos)) | (r << (pos + 1))) << std::endl;\n      set_bits(l | ((bits_type(bit) << pos)) | (r << (pos + 1)), sz + 1, popcount() + bit);\n    } \n\n    void erase_bit(size_type pos) {\n      assert(is_leaf);\n      assert(0 < sz);\n      bits_type l, r;\n      std::tie(l, r) = split_bits(pos);\n      size_type pos_bit = r & 1;\n      r >>= 1;\n      set_bits(l | (r << pos), sz - 1, popcount() - pos_bit);\n    }\n  };\n\n\n  static node_type rotate(node_type x, size_type dir) {\n    node_type y = x->take(1 - dir);\n    node_type b = y->take(dir);\n    x->swap(1 - dir, std::move(b));\n    x->fix();\n    y->swap(dir, std::move(x));\n    y->fix();\n    return std::move(y);\n  }\n\n  static node_type balance(node_type node) {\n    node->fix();\n    if(node->diff() == 2) {\n      if(node->child(0)->diff() == -1) {\n        auto ch = node->take(0);\n        node->swap(0, rotate(std::move(ch), 0));\n      }\n      return rotate(std::move(node), 1);\n    }\n    else if(node->diff() == -2) {\n      if(node->child(1)->diff() == 1) {\n        auto ch = node->take(1);\n        node->swap(1, rotate(std::move(ch), 1));\n      }\n      return rotate(std::move(node), 0);\n    }\n    else return std::move(node);\n  }\n\n  static node_type split_node(node_type node) {\n    assert(node->is_leaf);\n    bits_type l, r;\n    std::tie(l, r) = node->split_bits(bit_limit);\n    return node::new_section(\n        node::new_leaf(l, bit_limit, bits_popcount(l)), node::new_leaf(r, node->size() - bit_limit, bits_popcount(r))\n        );\n  }\n\n  static node_type insert(node_type node, size_type pos, bool bit) {\n    if(node->is_leaf) {\n      if(node->size() == 2 * bit_limit) {\n        return insert(split_node(std::move(node)), pos, bit);\n      }\n      else {\n        node->insert_bit(pos, bit);\n        return node;\n      }\n    }\n    else if(pos < node->child(0)->size()) {\n      node->swap(0, insert(node->take(0), pos, bit));\n      return balance(std::move(node));\n    }\n    else {\n      node->swap(1, insert(node->take(1), pos - node->child(0)->size(), bit));\n      return balance(std::move(node));\n    }\n  }\n\n  template<const size_type dir>\n  static std::tuple<node_type, bits_type, size_type> take_bit(node_type node, size_type len) {\n    if(node->is_leaf) {\n      if(node->size() < bit_limit / 2 + len) {\n        return std::tuple<node_type, bits_type, size_type>{ node_type(nullptr), node->bits(), node->size() };\n      }\n      else {\n        auto p = node->split_bits(dir == 0 ? len : node->size() - len);\n        bits_type node_bit = std::get<1 - dir>(p);\n        bits_type take = std::get<dir>(p);\n        node->set_bits(node_bit, node->size() - len, bits_popcount(node_bit));\n        return std::tuple<node_type, bits_type, size_type> { std::move(node), take, len };\n      }\n    }\n    else {\n      node_type ch;\n      bits_type bits;\n      size_type take_len;\n      std::tie(ch, bits, take_len) = take_bit<dir>(node->take(dir), len);\n      if(ch) {\n        node->swap(dir, std::move(ch));\n        return std::tuple<node_type, bits_type, size_type>{ balance(std::move(node)), bits, take_len };\n      }\n      else {\n        return std::tuple<node_type, bits_type, size_type> { node->take(1 - dir), bits, take_len };\n      }\n    }\n  }\n\n  static node_type erase(node_type node, size_type pos) {\n    if(node->is_leaf) {\n      node->erase_bit(pos);\n      return node;\n    }\n    else if(pos < node->child(0)->size()) {\n      auto left = erase(node->take(0), pos);\n      if(left->size() < bit_limit / 2) {\n        assert(left->is_leaf);\n        node_type right;\n        bits_type bits;\n        size_type len;\n        std::tie(right, bits, len) = take_bit<0>(node->take(1), bit_limit / 2 - left->size());\n\n        left->set_bits(left->bits() | (bits << left->size()), left->size() + len, left->popcount() + bits_popcount(bits));\n        if(right) {\n          node->swap(0, std::move(left));\n          node->swap(1, std::move(right));\n          return balance(std::move(node));\n        }\n        else {\n          return left;\n        }\n      }\n      else {\n        node->swap(0, std::move(left));\n        return balance(std::move(node));\n      }\n    }\n    else {\n      auto right = erase(node->take(1), pos - node->child(0)->size());\n      if(right->size() < bit_limit / 2) {\n        assert(right->is_leaf);\n        node_type left;\n        bits_type bits;\n        size_type len;\n        std::tie(left, bits, len) = take_bit<1>(node->take(0), bit_limit / 2 - right->size());\n\n        right->set_bits((right->bits() << len) | bits, right->size() + len, right->popcount() + bits_popcount(bits));\n        if(left) {\n          node->swap(0, std::move(left));\n          node->swap(1, std::move(right));\n          return balance(std::move(node));\n        }\n        else {\n          return right;\n        }\n      }\n      else {\n        node->swap(1, std::move(right));\n        return balance(std::move(node));\n      }\n    }\n  }\n\n  static node_type merge_dir(node_type dst, node_type src, size_type dir) {\n    if(std::abs(dst->height() - src->height()) <= 1) {\n      if(dir == 0)\n        return node::new_section(std::move(src), std::move(dst));\n      else\n        return node::new_section(std::move(dst), std::move(src));\n    }\n    else {\n      node_type ch = dst->take(dir);\n      assert(ch);\n      dst->swap(dir, merge_dir(std::move(ch), std::move(src), dir));\n      return balance(std::move(dst));\n    }\n  }\n\n  static node_type merge(node_type left, node_type right) {\n    if(!left) { return std::move(right); }\n    else if(!right) { return std::move(left); }\n    else if(left->height() >= right->height()) {\n      return merge_dir(std::move(left), std::move(right), 1);\n    }\n    else {\n      return merge_dir(std::move(right), std::move(left), 0);\n    }\n  }\n\n  static node_type build(const std::vector<bits_type>& bits, size_type l, size_type r, size_type len) {\n    //std::cout << \"build \" << l << \" \" << r << \" \" << len << std::endl;\n    if(l + 1 >= r) {\n      //std::cout << \"create leaf\" << std::endl;\n      //std::cout << \"-----------\" << std::endl;\n      return node::new_leaf(bits[l], len, bits_popcount(bits[l]));\n    }\n    else {\n      size_type m = (l + r) >> 1;\n      return merge(build(bits, l, m, (m - l) * 64), build(bits, m, r, len - (m - l) * 64));\n    }\n  }\n\n  static size_type at(node_reference node, size_type pos) {\n    if(node->is_leaf) {\n      return node->at_bits(pos);\n    }\n    else if(pos < node->child(0)->size()) {\n      return at(node->child(0), pos);\n    }\n    else {\n      return at(node->child(1), pos - node->child(0)->size());\n    }\n  }\n\n  static size_type rank(node_reference node, size_type pos) {\n    if(node->is_leaf) {\n      return node->rank(pos);\n    }\n    else if(pos < node->child(0)->size()) {\n      return rank(node->child(0), pos);\n    }\n    else {\n      return node->child(0)->popcount() + rank(node->child(1), pos - node->child(0)->size());\n    }\n  }\n\n\n  node_type root;\n\n  dynamic_bitvector(): root(node::new_leaf(0, 0, 0)) {}\n  dynamic_bitvector(const std::vector<bits_type>& bits, size_type len): root(build(bits, 0, bits.size(), len)) {}\n  void insert(size_type pos, bool bit) {\n    root = insert(std::move(root), pos, bit);\n  }\n  void erase(size_type pos) {\n    root = erase(std::move(root), pos);\n  }\n  bool at(size_type pos) const {\n    return at(root, pos);\n  }\n  size_type rank(size_type pos) const {\n    return rank(root, pos);\n  }\n  size_type rank(size_type pos, bool bit) const {\n    if(bit) {\n      return rank(root, pos);\n    }\n    else {\n      return pos - rank(root, pos);\n    }\n  }\n  size_type size() const {\n    return root->size();\n  }\n\n  void debug_tree(node_reference node, std::string d) const {\n    if(node->is_leaf) {\n      std::cout << d << \"leaf \" << node->size() << \" \" << node->popcount() << \" -----------\" << std::endl;\n      std::cout << d << std::bitset<bit_limit * 2>(node->bits()) << std::endl;\n      std::cout << d << \"-------------\" << std::endl;\n    }\n    else {\n      std::cout << d << \"node \" << node->size() << \" \" << node->popcount() << \" ----------\" << std::endl;\n      std::cout << d << \"left\" << std::endl;\n      debug_tree(node->child(0), d + \"   \");\n      std::cout << d << \"--------------\" << std::endl;\n      std::cout << d << \"right\" << std::endl;\n      debug_tree(node->child(1), d + \"   \");\n      std::cout << d << \"--------------\" << std::endl;\n    }\n  }\n\n  void debug_tree() const {\n    debug_tree(root, \"\");\n  }\n};\n\n#include <vector>\nstruct dynamic_wavelet_matrix {\n  using Integer = std::size_t;\n  using integer_type = Integer;\n  using size_type = std::size_t;\n\n\n  const size_type depth;\n  const size_type len;\n  std::vector<dynamic_bitvector> mat;\n  std::vector<size_type> spl;\n\npublic:\n\n  dynamic_wavelet_matrix(const std::vector<integer_type>& arr, size_type de)\n    : depth(de),\n      mat(de),\n      len(arr.size()),\n      spl(std::vector<size_type>(depth, 0)) {\n        std::vector<size_type> idx(len);\n        std::vector<size_type> left(len), right(len);\n\n        for(size_type i = 0;i < len;i++) idx[i] = i;\n\n        for(size_type d = depth; d-- > 0;) {\n          size_type l = 0, r = 0;\n          dynamic_bitvector::bitvector_builder builder(len);\n          for(size_type i = 0; i < len; i++) {\n            size_type k = (arr[idx[i]] >> d) & 1;\n            if(k) right[r++] = idx[i], builder.set(i);\n            else left[l++] = idx[i];\n          }\n          mat[d] = builder.build();\n          spl[d] = l;\n          swap(idx, left);\n          for(size_type i = 0; i < r; i++) idx[i + l] = right[i];\n        }\n      }\n\n  integer_type at(size_type i) const {\n    integer_type x = static_cast<integer_type>(0);\n    for(size_type d = depth; d-- > 0;) {\n      size_type k = mat[d].at(i);\n      x |= (static_cast<integer_type>(k) << d);\n      i = mat[d].rank(i, k) + spl[d] * k;\n    }\n    return x;\n  }\n\n  // counting elements that equal to x in range [left, right)\n  size_type rank_x(size_type left, size_type right, integer_type x) const {\n    for(size_type d = depth; d-- > 0;) {\n      size_type k = ((x >> d) & 1);\n      left = mat[d].rank(left, k) + spl[d] * k;\n      right = mat[d].rank(right, k) + spl[d] * k;\n    }\n    return right - left;\n  }\n\n  // sorted(arr[left..right])[i]\n  integer_type quantile(size_type left, size_type right, size_type i) const {\n    integer_type x = static_cast<integer_type>(0);\n    for(size_type d = depth; d-- > 0;) {\n      size_type cnt = mat[d].rank(right, 0) - mat[d].rank(left, 0);\n      size_type k = (i < cnt) ? 0 : 1;\n      x |= (k << d);\n      left = mat[d].rank(left, k) + spl[d] * k;\n      right = mat[d].rank(right, k) + spl[d] * k;\n    }\n    return x;\n  }\n\n  struct rank_result {\n    size_type le;\n    size_type eq;\n    size_type mo;\n  };\n\n  // couting elements that less than x, equal to x, and more than x in range [left, right)\n  rank_result rank_less_eq_more(size_type left, size_type right, integer_type x) const {\n    size_type le = 0, mo = 0;\n    for(size_type d = depth; d --> 0;) {\n      size_type k = (x >> d) & 1;\n      size_type l = mat[d].rank(left, 1);\n      size_type r = mat[d].rank(right, 1);\n      if(k == 0) {\n        mo += r - l;\n        left -= l;\n        right -= r;\n      }\n      else {\n        le += (right - left) - (r - l);\n        left = l + spl[d];\n        right = r + spl[d];\n      }\n    }\n    return rank_result { le, right - left, mo };\n  }\n\n  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y, integer_type l, size_type d) const {\n    integer_type r = l + (1 << d);\n    if(x <= l && r <= y) {\n      return right - left;\n    }\n    else if(y <= l || r <= x) {\n      return 0;\n    }\n    else {\n      d--;\n      size_type lr = mat[d].rank(left, 1);\n      size_type rr = mat[d].rank(right, 1);\n      return\n        rangefreq(left - lr, right - rr, x, y, l, d) +\n        rangefreq(lr + spl[d], rr + spl[d], x, y, l + (1 << d), d);\n    }\n  }\n\n  size_type rangefreq(size_type left, size_type right, integer_type x, integer_type y) const {\n    return rangefreq(left, right, x, y, 0, depth);\n  }\n\n  size_type rangefreq_count(size_type left, size_type right, integer_type x, integer_type y) const {\n    auto p = rank_less_eq_more(left, right, x);\n    auto q = rank_less_eq_more(left, right, y);\n    return p.eq + p.mo - q.eq - q.mo;\n  }\n};\n\n\n#include <vector>\n\n#include <cstdio>\n\nnamespace niu {\n  char cur;\n  struct FIN {\n    static inline bool is_blank(char c) { return c <= ' '; }\n    inline char next() { return cur = getc_unlocked(stdin); }\n    inline char peek() { return cur; }\n    inline void skip() { while(is_blank(next())){} }\n#define intin(inttype)  \\\n    FIN& operator>>(inttype& n) { \\\n      bool sign = 0; \\\n      n = 0; \\\n      skip(); \\\n      while(!is_blank(peek())) { \\\n        if(peek() == '-') sign = 1; \\\n        else n = (n << 1) + (n << 3) + (peek() & 0b1111); \\\n        next(); \\\n      } \\\n      if(sign) n = -n; \\\n      return *this; \\\n    }\nintin(int)\nintin(long long)\n  } fin;\n\n  char tmp[128];\n  struct FOUT {\n    static inline bool is_blank(char c) { return c <= ' '; }\n    inline void push(char c) { putc_unlocked(c, stdout); }\n    FOUT& operator<<(char c) { push(c); return *this; }\n    FOUT& operator<<(const char* s) { while(*s) push(*s++); return *this; }\n#define intout(inttype) \\\n    FOUT& operator<<(inttype n) { \\\n      if(n) { \\\n        char* p = tmp + 127; bool neg = 0; \\\n        if(n < 0) neg = 1, n = -n; \\\n        while(n) *--p = (n % 10) | 0b00110000, n /= 10; \\\n        if(neg) *--p = '-'; \\\n        return (*this) << p; \\\n      } \\\n      else { \\\n        push('0'); \\\n        return *this; \\\n      } \\\n    }\nintout(int)\nintout(long long)\nintout(std::size_t)\n  } fout;\n}\n\ntemplate<class T>\nstruct Compression {\n  using size_type = std::size_t;\n\n  std::vector<T> v;\n\n  Compression(){}\n  void add(const T& t) { v.push_back(t); }\n  void build() {\n    sort(begin(v), end(v));\n    v.erase(unique(begin(v), end(v)), end(v));\n  }\n  size_type comp(const T& x) const {\n    return lower_bound(begin(v), end(v), x) - begin(v);\n  }\n  size_type size() const { return v.size(); }\n};\n\ntemplate<class T>\nstruct plane_to_line {\n  using size_type = std::size_t;\n  using coord_type = std::pair<T, T>;\n  using value_type = T;\n\n  std::vector<std::pair<coord_type, size_type>> elems;\n  std::vector<size_type> yarray;\n  std::vector<size_type> xstart;\n  Compression<value_type> X, Y;\n\n  plane_to_line(const std::vector<coord_type>& a): elems(a.size()) {\n    for(size_type i = 0;i < a.size();i++) {\n      elems[i] = { a[i], i };\n      X.add(a[i].first);\n      Y.add(a[i].second);\n    }\n    sort(std::begin(elems), std::end(elems));\n    X.build();\n    Y.build();\n\n    xstart.resize(X.size() + 1);\n    yarray.resize(elems.size());\n    size_type x = 0;\n    for(size_type i = 0;i < elems.size();i++) {\n      if(!i || elems[i - 1].first.first < elems[i].first.first) {\n        xstart[x++] = i;\n      }\n      yarray[i] = Y.comp(elems[i].first.second);\n    }\n    xstart[X.size()] = elems.size();\n  }\n\n  struct rangefreq_arg {\n    size_type left;\n    size_type right;\n    size_type x;\n    size_type y;\n  };\n\n  rangefreq_arg to_rangefreq(value_type xl, value_type xr, value_type yl, value_type yr) const {\n    size_type cxl = xstart[X.comp(xl)];\n    size_type cxr = xstart[X.comp(xr)];\n    size_type cyl = Y.comp(yl);\n    size_type cyr = Y.comp(yr);\n    return rangefreq_arg { cxl, cxr, cyl, cyr };\n  }\n};\n\n#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define rev(i,s,e) for(i64 (i) = (s);(i) --> (e);)\n#define all(x) x.begin(),x.end()\n\ntemplate<class T>\nstatic inline std::vector<T> ndvec(size_t&& n, T val) noexcept {\n  return std::vector<T>(n, std::forward<T>(val));\n}\n\ntemplate<class... Tail>\nstatic inline auto ndvec(size_t&& n, Tail&&... tail) noexcept {\n  return std::vector<decltype(ndvec(std::forward<Tail>(tail)...))>(n, ndvec(std::forward<Tail>(tail)...));\n}\n\n\nint main() {\n  using niu::fin;\n  using niu::fout;\n  using P = std::pair<int, int>;\n  i64 n, m;\n  fin >> n >> m;\n  std::vector<P> ps(n);\n  rep(i,0,n) {\n    fin >> ps[i].first >> ps[i].second;\n  }\n  plane_to_line<int> ptl(ps);\n\n  dynamic_wavelet_matrix wm(ptl.yarray, 13);\n  rep(i,0,m) {\n    int a, b, c, d;\n    fin >> a >> b >> c >> d;\n    auto res = ptl.to_rangefreq(a, c + 1, b, d + 1);\n    fout << wm.rangefreq_count(res.left, res.right, res.x, res.y) << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9+7;\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<int> x(n+1), y(n+1);\n\tvector<pair<int,int> > xy(n+1);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i] >> y[i];\n\t\txy[i] = make_pair(x[i],y[i]);\n\t}\n\tx[n]=inf; y[n]=inf;\n\txy[n]=make_pair(inf,inf);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tsort(xy.begin(), xy.end());\n\t\n\tvector<pair<int, int> > nx, ny;\n\tfor(int i=0; i<n+1; i++){\n\t\tnx.push_back(make_pair(x[i], 1));\n\t\tfor(int j=i+1; j<n+1; j++){\n\t\t\tif(x[i]==x[j]){\n\t\t\t\tnx.back().second++;\n\t\t\t}else{\n\t\t\t\ti=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n+1; i++){\n\t\tny.push_back(make_pair(y[i], 1));\n\t\tfor(int j=i+1; j<n+1; j++){\n\t\t\tif(y[i]==y[j]){\n\t\t\t\tny.back().second++;\n\t\t\t}else{\n\t\t\t\ti=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int> > lsum(nx.size(), vector<int>(ny.size()));\n\tint pidx = 0;\n\tint remain = n+1;\n\tfor(int i=0; i<(int)nx.size(); i++){\n\t\tlsum[i][0] = remain;\n\t\tfor(int j=1; j<(int)ny.size(); j++){\n\t\t\tlsum[i][j] = lsum[i][j-1] -ny[j-1].second;\n\t\t}\n\t\twhile(xy[pidx].first == nx[i].first){\n\t\t\tremain--;\n\t\t\tvector<pair<int,int> >::iterator it;\n\t\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(xy[pidx].second, 0));\n\t\t\tit->second--;\n\t\t\tpidx++;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<m; i++){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tvector<pair<int, int> >:: iterator it;\n\t\tit = lower_bound(nx.begin(), nx.end(), make_pair(x1, 0));\n\t\tx1 = it-nx.begin();\n\t\tit = lower_bound(nx.begin(), nx.end(), make_pair(x2+1, 0));\n\t\tx2 = it-nx.begin();\n\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(y1, 0));\n\t\ty1 = it-ny.begin();\n\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(y2+1, 0));\n\t\ty2 = it-ny.begin();\n\t\tcout << lsum[x1][y1] -lsum[x2][y1] -lsum[x1][y2] +lsum[x2][y2] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <cstdio>\n#include <set>\n#define INF 1000000001\n#define N 5003\nusing namespace std;\ntypedef pair<int,int> P;\nint Bynary_Search(int,int,int,int);\nint n,m,xsz,ysz,d[N][N],ans;\nint pxy[2][N],x[N],y[N],x1,y1,x2,y2;\nset<int> sx,sy;\nP in[N];\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i],sx.insert(x[i]),sy.insert(y[i]);\n  int k=1;\n  for(set<int>::iterator it=sx.begin();it!=sx.end();it++,k++) pxy[0][k]=*it;\n  k=1;\n  for(set<int>::iterator it=sy.begin();it!=sy.end();it++,k++) pxy[1][k]=*it;\n  xsz=sx.size();\n  ysz=sy.size();\n  pxy[0][0]=pxy[1][0]=-INF;\n  pxy[0][xsz+1]=pxy[1][ysz+1]=INF;\n  for(int i=0;i<n;i++){\n    int rx=Bynary_Search(x[i],0,xsz,0);\n    int ry=Bynary_Search(y[i],1,ysz,0);\n    d[ry][rx]++;\n  }\n  for(int i=0;i<ysz+1;i++)\n    for(int j=1;j<xsz+1;j++) d[i][j]=d[i][j]+d[i][j-1];\n  for(int i=0;i<xsz+1;i++)\n    for(int j=1;j<ysz+1;j++) d[j][i]=d[j][i]+d[j-1][i];\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n    int xb=Bynary_Search(x1,0,xsz,0),yb=Bynary_Search(y1,1,ysz,0);\n    int xe=Bynary_Search(x2,0,xsz,1),ye=Bynary_Search(y2,1,ysz,1);\n    ans=d[ye][xe];\n    if(yb) ans-=d[yb-1][xe];\n    if(xb) ans-=d[ye][xb-1];\n    if(xb&&yb) ans+=d[yb-1][xb-1];\n    if(xb>xe||yb>ye) ans=0;\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n\nint Bynary_Search(int s,int index,int sz,int c){\n  int l=0,r=sz+2,m;\n  while(l+1<r){\n    m=(l+r)/2;\n    if(s>=pxy[index][m]) l=m;\n    else r=m;\n  }\n  if(c) return l;\n  if(s==pxy[index][l]) return l;\n  else return l+1;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\n\nvi compressed_x, compressed_y;\n\nint a[5005*6+2][5005*6+2];\n\nint main()\n{\n    cin >> n >> m;\n\n    int xmi = inf, xma = -inf, ymi = inf, yma = -inf;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        for (int d = -1; d <= 1; ++d) {\n            compressed_x.PB(x[i] + d);\n            compressed_y.PB(y[i] + d);\n        }\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = lower_bound(all(compressed_x), x2) - begin(compressed_x);\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = lower_bound(all(compressed_y), y2) - begin(compressed_y);\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<long long> X;\n    vector<long long> Y;\n    vector<long long> x(n);\n    vector<long long> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        long long x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    long long h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    \n\n    //cout << h << \" \" << w << endl;\n    vector<vector<long long> > imos(h + 1, vector<long long> (w + 1, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i]][x[i]]++;\n    }\n\n    \n\n    for(int j = 0; j <= w; j++){\n        for(int i = 1; i <= h; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    \n    for(int i = 0; i < m; i++){\n        long long x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        x2 = upper_bound(X.begin(), X.end(),x2) - X.begin() - 1;\n\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        \n        //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        long long sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <iomanip>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = uint32_t;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max() / 32 * 15 + 208;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> xs(n), ys(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> xs[i] >> ys[i];\n    }\n    auto zx = xs, zy = ys;\n    sort(zx.begin(), zx.end());\n    zx.erase(unique(zx.begin(), zx.end()), zx.end());\n    sort(zy.begin(), zy.end());\n    zy.erase(unique(zy.begin(), zy.end()), zy.end());\n    int h = zy.size(), w = zx.size();\n    vector<vector<int>> v(h+1, vector<int> (w+1));\n    auto fy = [&zy](int y){ return lower_bound(zy.begin(),zy.end(), y) - zy.begin(); };\n    auto fx = [&zx](int x){ return lower_bound(zx.begin(),zx.end(), x) - zx.begin(); };\n    for (int i = 0; i < n; ++i) {\n        v[fy(ys[i])+1][fx(xs[i])+1]++;\n    }\n    for (int i = 0; i <= h; ++i) {\n        for (int j = 0; j <= w; ++j) {\n            if(i) v[i][j] += v[i-1][j];\n            if(j) v[i][j] += v[i][j-1];\n            if(i && j) v[i][j] -= v[i-1][j-1];\n        }\n    }\n    for (int i = 0; i < m; ++i) {\n        int x1, y1, x2, y2;\n        scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n        x1 = fx(x1), x2 = fx(x2+1), y1 = fy(y1), y2 = fy(y2+1);\n        printf(\"%d\\n\", v[y2][x2]-v[y2][x1]-v[y1][x2]+v[y1][x1]);\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9 + 2;\n\n\nshort d[5002 * 3][5002 * 3];\nshort id[5002 * 3][5002 * 3];\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> ix(n), iy(n);\n\n\t//??§?¨???§?????¨????????????\n\tvector<int> ax, ay;\n\tmap<int, int> mx, my, ym, xm;\n\n\n\trep(i, n){\n\t\tcin >> ix[i] >> iy[i];\n\t\trep(j, 3){\n\t\t\tax.push_back(ix[i] + j - 1);\n\t\t\tay.push_back(iy[i] + j - 1);\n\t\t}\n\t}\n\tax.push_back(-INF - 1);\n\tay.push_back(-INF - 1);\n\tax.push_back( INF + 1);\n\tay.push_back( INF + 1);\n\n\tsort(all(ax));\n\tsort(all(ay));\n\n\trep(i, ax.size()){\n\t\tmx[ax[i]] = i;\n\t\txm[i] = ax[i];\n\t}\n\trep(i, ay.size()){\n\t\tmy[ay[i]] = i;\n\t\tym[i] = ay[i];\n\t}\n\n\t//??\\??????????????????map??§????¬????????????§?????£?????????\n\tclr(id);\n\trep(i, n){\n\t\tid[mx[ix[i]]][my[iy[i]]]++;\n\t}\n\n\t//d[x][y] 0 - x  0 - y ??????????????????????±?????????????\n\tclr(d);\n\tFor(x,1, ax.size() + 1)For(y,1, ay.size() + 1){\n\t\td[x][y] = d[x - 1][y] + d[x][y - 1] - d[x - 1][y - 1] + id[x][y];\n\t}\n\n\trep(i, m){\n\t\tint qx1, qy1, qx2, qy2;\n\t\tcin >> qx1 >> qy1 >> qx2 >> qy2;\n\t\tint rx, ry, lx, ly;\n\t\tqx1--; qy1--;\n\t\tif (mx.count(qx1)){\n\t\t\tlx = mx[qx1];\n\t\t}\n\t\telse{\n\t\t\tmx[qx1] = -1;\n\t\t\tauto p = mx.find(qx1);\n\t\t\tlx = prev(p)->second;\n\t\t\tmx.erase(qx1);\n\t\t}\n\t\tif (my.count(qy1)){\n\t\t\tly = my[qy1];\n\t\t}\n\t\telse{\n\t\t\tmy[qy1] = -1;\n\t\t\tauto p = my.find(qy1);\n\t\t\tly = prev(p)->second;\n\t\t\tmy.erase(qy1);\n\t\t}\n\n\t\tif (mx.count(qx2)){\n\t\t\trx = mx[qx2];\n\t\t}\n\t\telse{\n\t\t\tmx[qx2] = -1;\n\t\t\tauto p = mx.find(qx2);\n\t\t\trx = next(p)->second;\n\t\t\tmx.erase(qx2);\n\t\t}\n\n\t\tif (my.count(qy2)){\n\t\t\try = my[qy2];\n\t\t}\n\t\telse{\n\t\t\tmy[qy2] = -1;\n\t\t\tauto p = my.find(qy2);\n\t\t\try = next(p)->second;\n\t\t\tmy.erase(qy2);\n\t\t}\n\n\t\tcout << d[rx][ry] + d[lx][ly] - d[lx][ry] - d[rx][ly] << endl;\n\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <limits.h>\n#include <map>\n#include <set>\n\nusing namespace std;\nconst int ninf = -(1000000000 + 1);\n\n\nint solve(void);\nint getTreasureNum( vector<vector<int>> &clist, vector<vector<int>> &mp, vector<vector<int>> &orig, vector<map<int,int>>&trans, vector<vector<int>> &xsum, vector<vector<int>> &ysum);\nint getSmallerID(vector<int> &list,  int target);\nint getSmallerID(vector<vector<int>> &orig, int &x, int &y, int target_x, int target_y);\n\nint main(void) {\n\n\t//FILE *fpin = freopen(\"data.txt\", \"r\", stdin);\n\twhile (solve());\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\tint n, m;\n\tcin >> n >> m;\n\n\t/*\n\t\t?´?????????¨??§?¨???§???\n\t*/\n\n\tvector<vector<int>> clist(2);\n\tvector<pair<int, int>> plist(n);\n\tvector<vector<int>> mp,orig,xsum,ysum;\n\tvector<map<int, int>> trans(2);\n\t/*\n\t\tinput\n\t*/\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> plist[i].first >> plist[i].second;\n\t\tclist[1].push_back(plist[i].first);\n\t\tclist[0].push_back(plist[i].second);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tclist[i].push_back(ninf);\n\t\tsort(clist[i].begin(), clist[i].end());\n\t\tclist[i].erase(unique(clist[i].begin(), clist[i].end()), clist[i].end());\n\t\tfor (int j = 0; j < clist[i].size(); j++) {\n\t\t\ttrans[i][clist[i][j]] = j;\n\t\t}\n\t}\n\tmp = vector<vector<int>>(clist[0].size(), vector<int>(clist[1].size(), 0));\n\n\tfor (int i = 0; i < n; i++)\n\t\tmp[trans[0][plist[i].second]][trans[1][plist[i].first]] ++;\n\torig = mp;\n\txsum = mp;\n\tysum = mp;\n\n\tfor (int x = 0; x < mp[0].size(); x++) {\n\t\tfor (int y = 0; y + 1 < mp.size(); y++) {\n\t\t\tmp[y + 1][x] = mp[y + 1][x] + mp[y][x];\n\t\t}\n\t}\n\tysum = mp;\n\n\tfor (int y = 0; y < mp.size(); y++) {\n\t\tfor (int x = 0; x + 1 < mp[0].size();x++) {\n\t\t\tmp[y][x + 1] = mp[y][x + 1] + mp[y][x];\n\t\t\txsum[y][x + 1] = xsum[y][x + 1] + xsum[y][x];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++)\n\t\tcout << getTreasureNum(clist, mp, orig, trans,xsum,ysum) << endl;\n\n\treturn 0;\n}\n\nint getTreasureNum(vector<vector<int>>& clist, vector<vector<int>>& mp, vector<vector<int>>& orig, vector<map<int, int>>& trans, vector<vector<int>>& xsum, vector<vector<int>>& ysum)\n{\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> y1 >> x2 >> y2;\n\n\tif (x2 < clist[1][0] || x1 > clist[1][clist[1].size() - 1] || y2 < clist[0][0] || y1 > clist[0][clist[0].size() - 1]) { return 0; }\n\t\n\tif( trans[1].find(x1) == trans[1].end() )\n\t\tx1 = min(getSmallerID(clist[1], x1) + 1, (int)clist[1].size()-1);\n\telse\n\t\tx1 = getSmallerID(clist[1], x1);\n\n\tx2 = getSmallerID(clist[1], x2);\n\n\tif (trans[0].find(y1) == trans[0].end())\n\t\ty1 = min(getSmallerID(clist[0], y1) + 1, (int)clist[0].size() - 1);\n\telse\n\t\ty1 = getSmallerID(clist[0], y1);\n\n\ty2 = getSmallerID(clist[0], y2);\n\n\tif (x1 == x2 && y1 == y2) {\n\t\treturn orig[y1][x1];\n\t}\n\telse if (x1 == x2) {\n\t\treturn ysum[y2][x1] - ysum[y1][x1] + orig[y1][x1];\n\t}\n\telse if (y1 == y2) {\n\t\treturn xsum[y2][x2] - xsum[y1][x1] + orig[y1][x1];\n\t}\n\telse {\n\t\tint z1 = mp[y2][x2] - mp[y1][x2] - mp[y2][x1] + mp[y1][x1];\n\t\tint z2 = xsum[y1][x2] - xsum[y1][x1];\n\t\tint z3 = ysum[y2][x1] - ysum[y1][x1];\n\t\treturn z1+z2+z3+orig[y1][x1];\n\t}\n\n\n}\n\n\nint getSmallerID(vector<int>& list, int target)\n{\n\tint low = 0;\n\tint high = list.size();\n\tint mid = 0;\n\n\twhile (abs(low - high) > 1) {\n\t\tmid = (low + high) / 2;\n\t\tif (list[mid] <= target) {\n\t\t\tlow = mid;\n\t\t}\n\t\telse {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\tmid = (high + low) / 2;\n\treturn mid;\n}\n\nint getSmallerID(vector<vector<int>>& orig, int & x, int & y, int target_x, int target_y)\n{\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5002;\nint n, m;\nint x[MAXN], y[MAXN];\nint G[MAXN][MAXN];\n\nint main() {\n  while(cin >> n >> m) {\n    vector<int> xs, ys;\n    for(int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n      xs.push_back(x[i]);\n      ys.push_back(y[i]);\n    }\n    sort(xs.begin(), xs.end());\n    sort(ys.begin(), ys.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    memset(G, 0, sizeof(G));\n    for(int i = 0; i < n; ++i) {\n      int nx = lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin();\n      int ny = lower_bound(ys.begin(), ys.end(), y[i]) - ys.begin();\n      G[1+ny][1+nx] += 1;\n    }\n    for(int i = 0; i < MAXN; ++i) {\n      for(int j = 0; j+1 < MAXN; ++j) {\n        G[i][j+1] += G[i][j];\n      }\n    }\n    for(int j = 0; j < MAXN; ++j) {\n      for(int i = 0; i+1 < MAXN; ++i) {\n        G[i+1][j] += G[i][j];\n      }\n    }\n    while(m--) {\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      a = lower_bound(xs.begin(), xs.end(), a) - xs.begin();\n      b = lower_bound(ys.begin(), ys.end(), b) - ys.begin();\n      c = upper_bound(xs.begin(), xs.end(), c) - xs.begin();\n      d = upper_bound(ys.begin(), ys.end(), d) - ys.begin();\n      cout << G[d][c] - G[d][a] - G[b][c] + G[b][a] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<int> X;\n    vector<int> Y;\n    vector<int> x(n);\n    vector<int> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        int x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    int h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    \n\n    //cout << h << \" \" << w << endl;\n    vector<vector<int> > imos(h + 1, vector<int> (w + 1, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i]][x[i]]++;\n    }\n\n    \n\n    for(int j = 0; j <= w; j++){\n        for(int i = 1; i <= h; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    for(int i = 0; i < X.size(); i++){\n        cout << X[i] << endl;\n    }\n    \n    for(int i = 0; i < m; i++){\n        int x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin() - 1;\n\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        if(x2 == -1) x2 = 0;\n        if(y2 == -1) y2 = 0;\n        //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        int sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing ll = long long int;\n\nconstexpr int MAX_N = 5001;\n\nint n, m;\nint w, h;\n\nll board[MAX_N][MAX_N];\n\nll X[MAX_N], Y[MAX_N];\nstd::vector<ll> vx, vy;\n\nint compress(ll *x,std::vector<ll>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\t++board[Y[i]][X[i]];\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tll sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\t\n\n\tll x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cstdio>\n#define F first\n#define S second\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  pair<int,int> pii[n];\n  for(int i=0;i<n;i++)\n    cin>>pii[i].F>>pii[i].S;\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    int cnt=0;\n    for(int j=0;j<n;j++){\n      if((x1<=pii[j].first&&pii[j].first<=x2)&&y1<=pii[j].second&&pii[j].second<=y2)\n\tcnt++;\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\nconst int INT = 1e9;\nconst ll LINF = 1e18;\n\nvoid solve(){\n    int n,m; cin >> n >> m;\n    vector<pll> p(n);\n    for(int i = 0; i < n;i++){\n        ll x,y; cin >> x >> y;\n        p[i] = {x,y};\n    }\n    sort(p.begin(),p.end());\n    for(int i = 0; i < m;i++){\n        int x1,y1,x2,y2; cin >> x1 >> y1 >> x2 >> y2;\n        ll xl = lower_bound(p.begin(), p.end(), pll(x1,-LINF)) - p.begin();\n        ll xr = upper_bound(p.begin(),p.end(),pll(x2,LINF)) - p.begin();\n        \n        ll ans = 0;\n        for(ll j = xl; j < xr;j++){\n            if(y1 <= p[j].second && p[j].second <= y2) ans++;\n        }\n        cout << ans << endl;\n    }\n}\nint main(void){\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    solve();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()+1]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()+1]++;\n  }\n  vector<vector<int> > ag(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=1;i<ag.size();i++){\n    for(int j=1;j<ag[i].size();j++){\n      ag[i][j]=ag[i][j-1]+ag[i-1][j]-ag[i-1][j-1]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=lower_bound(xp.begin(),xp.end(),xh+1)-xp.begin();\n    yyh=lower_bound(yp.begin(),yp.end(),yh+1)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[xxl][yyl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\nint sum[5200][5200];\n\ntemplate <typename T,typename Func>\n\tT satisfy_min(Func P,T l ,T r,T eps){\n\t\twhile(r-l>eps){\n\t\t\tT m=(l+r)/2;\n\t\t\t(P(m)?r:l)=m;\n\t\t}\n\t\treturn r;\n\t}\n\n\nint main() {\n\t\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\t\n\t\tfor (int i = 0; i < 5200; i++) {\n\t\t\tfor (int j = 0; j < 5200; j++) {\n\t\t\t\tsum[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint x[n], y[n];\n\t\tvector<int> xs, ys;\n\t\txs.push_back(-1100000000);\n\t\tys.push_back(-1100000000);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i];\n\t\t\tcin >> y[i];\n\t\t\txs.push_back(x[i]);\n\t\t\tys.push_back(y[i]);\n\t\t}\n\t\txs.push_back(1100000000);\n\t\tys.push_back(1100000000);\n\t\tsort(xs.begin(), xs.end());\n\t\tsort(ys.begin(), ys.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\t\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint nx = lower_bound(xs.begin(), xs.end(), x[i]) -xs.begin();\n\t\t\tint ny = lower_bound(ys.begin(), ys.end(), y[i]) -ys.begin();\n\t\t\tsum[nx][ny]++;\n\t\t}\n\n\t\tfor (int i = 1; i < 5200; i++) {\n\t\t\tfor (int j = 1; j < 5200; j++) {\n\t\t\t\tsum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\tint nx2 = upper_bound(xs.begin(), xs.end(), x2) -xs.begin();\n\t\t\tint nx1 = lower_bound(xs.begin(), xs.end(), x1) -xs.begin();\n\t\t\tint ny2 = upper_bound(ys.begin(), ys.end(), y2) -ys.begin();\n\t\t\tint ny1 = lower_bound(ys.begin(), ys.end(), y1) -ys.begin();\n\t\t\tnx2--; ny2--;\n\t\t\tny1--; nx1--;\n\t\t\tprintf(\"%d\\n\", sum[nx2][ny2]-sum[nx2][ny1]-sum[nx1][ny2]+sum[nx1][ny1]);\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_;\n\tstd::vector<std::vector<Type> > dat;\n\tstd::vector<std::vector<int> > vl;\n\tinline int query_(int a, int b, Type x, int k, int l, int r, int e) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r) and e integers below x in the range\n\t\tif (r <= a || b <= l || e == 0) return 0;\n\t\tif (a <= l && r <= b) return e;\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1, vl[k][e - 1]);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r, e - vl[k][e - 1]);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1);\n\t\tdat.resize(size_ << 1);\n\t\tvl.resize(size_);\n\t\tfor (int i = 0; i < n; i++) dat[i + size_].push_back(*(begin_ + i));\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tvl[i].resize(dat[i].size());\n\t\t\tint cl = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][j - cl])) dat[i][j] = dat[i << 1][cl++];\n\t\t\t\telse dat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\tvl[i][j] = cl;\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\tint ptr = lower_bound(dat[1].begin(), dat[1].end(), x) - dat[1].begin();\n\t\treturn query_(l, r, x, 1, 0, size_, ptr);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <set>\n#define INF 1000000001\n#define N 5003\nusing namespace std;\ntypedef pair<int,int> P;\nint Bynary_Search(int,int,int,int);\nint n,m,xsz,ysz,d[N][N],ans;\nint pxy[2][N],x[N],y[N],x1,y1,x2,y2;\nset<int> sx,sy;\nP in[N];\n\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>x[i]>>y[i],sx.insert(x[i]),sy.insert(y[i]);\n  int k=1;\n  for(set<int>::iterator it=sx.begin();it!=sx.end();it++,k++) pxy[0][k]=*it;\n  k=1;\n  for(set<int>::iterator it=sy.begin();it!=sy.end();it++,k++) pxy[1][k]=*it;\n  xsz=sx.size();\n  ysz=sy.size();\n  pxy[0][0]=pxy[1][0]=-INF;\n  pxy[0][xsz+1]=pxy[1][ysz+1]=INF;\n  for(int i=0;i<n;i++){\n    int rx=Bynary_Search(x[i],0,xsz,0);\n    int ry=Bynary_Search(y[i],1,ysz,0);\n    d[ry][rx]++;\n  }\n  for(int i=0;i<ysz+1;i++)\n    for(int j=1;j<xsz+1;j++) d[i][j]=d[i][j]+d[i][j-1];\n  for(int i=0;i<xsz+1;i++)\n    for(int j=1;j<ysz+1;j++) d[j][i]=d[j][i]+d[j-1][i];\n  for(int i=0;i<m;i++){\n    cin>>x1>>y1>>x2>>y2;\n    int xb=Bynary_Search(x1,0,xsz,0),yb=Bynary_Search(y1,1,ysz,0);\n    int xe=Bynary_Search(x2,0,xsz,1),ye=Bynary_Search(y2,1,ysz,1);\n    ans=d[ye][xe];\n    if(yb) ans-=d[yb-1][xe];\n    if(xb) ans-=d[ye][xb-1];\n    if(xb&&yb) ans+=d[yb-1][xb-1];\n    if(xb>xe||yb>ye) ans=0;\n    cout<<ans<<endl;\n  }\n  return 0;\n}\n\nint Bynary_Search(int s,int index,int sz,int c){\n  int l=0,r=sz+2,m;\n  while(l+1<r){\n    m=(l+r)/2;\n    if(s>=pxy[index][m]) l=m;\n    else r=m;\n  }\n  if(c) return l;\n  if(s==pxy[index][l]) return l;\n  else return l+1;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  pair<int,int> pii[n];\n  for(int i=0;i<n;i++)\n    cin>>pii[i].F>>pii[i].S;\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    int cnt=0;\n    for(int j=0;j<n;j++){\n      if((x1<=pii[j].F&&pii[j].F<=x2)&&y1<=pii[j].S&&pii[j].S<=y2)\n\tcnt++;\n    }\n    cout<<cnt<<endl;\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n\n    rep(i, n) {\n        scanf(\"%d%d\",x+i,y+i);\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    compressed_x.PB(inf);\n    compressed_y.PB(inf);\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = upper_bound(all(compressed_x), x2) - begin(compressed_x) - 1;\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = upper_bound(all(compressed_y), y2) - begin(compressed_y) - 1;\n\n        if (x2 < 0 || y2 < 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\n/***** ?´??????? *****/\n\n// ????¬?????´???????\ntemplate<typename T>\nvector<T> calc_csum(vector<T> &val) {\n\tvector<T> sum(val.size() + 1);\n\tpartial_sum(val.begin(), val.end(), sum.begin() + 1);\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum(vector<T> &sum, int begin, int end) {\n\treturn sum[end] - sum[begin];\n}\n\n// ????¬?????´???????\ntemplate<typename T>\nvector< vector<T> > calc_csum2(vector< vector<T> > &val) {\n\tint H = val.size();\n\tint W = val[0].size();\n\tvector< vector<T> > sum(H + 1, vector<T>(W + 1));\n\n\tfor (int y = 0; y < H; y++) {\n\t\tpartial_sum(val[y].begin(), val[y].end(), sum[y + 1].begin() + 1);\n\t}\n\n\tfor (int y = 0; y < H; y++) {\n\t\tfor (int x = 0; x <= W; x++) {\n\t\t\tsum[y + 1][x] += sum[y][x];\n\t\t}\n\t}\n\n\treturn sum;\n}\n\ntemplate<typename T>\nT sum_csum2(vector< vector<T> > &sum, int y1, int y2, int x1, int x2) {\n\treturn sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1];\n}\n\n/***** /?´??????? *****/\n\nstruct Query {\n\tQuery () {}\n\tint x1;\n\tint x2;\n\tint y1;\n\tint y2;\n};\n\nVI uniq_xs;\nVI uniq_ys;\n\nVI uniq_xs_r;\nVI uniq_ys_r;\n\nvoid my_uniq(VI &vec) {\n\tsort(ALL(vec));\n\tauto it = unique(ALL(vec));\n\tvec.resize(distance(vec.begin(), it));\n}\n\nint trans_left(VI &vec, int value) {\n\tauto it = lower_bound(ALL(vec), value);\n\tint pos = it - vec.begin();\n\treturn pos;\n}\n\nint trans_right(VI &vec_r, int value) {\n\tauto it = lower_bound(ALL(vec_r), value, greater<int>());\n\tint pos = it - vec_r.begin();\n\treturn (int)vec_r.size() - pos - 1;\n}\n\nint main(void) {\n\tconst int MAX_N = 1000 * 1000 * 1000 + 10;\n\n\t// input\n\tint n, m;\n\tcin >> n >> m;\n\n\tVI xs(n), ys(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xs[i] >> ys[i];\n\t\tuniq_xs.PB(xs[i]);\n\t\tuniq_ys.PB(ys[i]);\n\t}\n\n\tvector<Query> qs(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> qs[i].x1 >> qs[i].y1 >> qs[i].x2 >> qs[i].y2;\n\t}\n\n\t// ??§?¨???§???\n\tuniq_xs.PB(0);\n\tuniq_xs.PB(MAX_N);\n\tuniq_ys.PB(0);\n\tuniq_ys.PB(MAX_N);\n\tmy_uniq(uniq_xs);\n\tmy_uniq(uniq_ys);\n\n\t// ??????????????\\?????????????????????\n\tuniq_xs_r = VI(ALL(uniq_xs));\n\tuniq_ys_r = VI(ALL(uniq_ys));\n\tsort(ALL(uniq_xs_r), greater<int>());\n\tsort(ALL(uniq_ys_r), greater<int>());\n\n/*\n\tcout << \"uniq_xs: \";\n\tfor (auto x : uniq_xs) cout << x << \" \";\n\tcout << endl;\n\n\tcout << \"uniq_ys: \";\n\tfor (auto y : uniq_ys) cout << y << \" \";\n\tcout << endl;\n*/\n\n\t// map?????????\n\tint w = uniq_xs.size();\n\tint h = uniq_ys.size();\n\tVVI ts(h, VI(w));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint x = trans_left(uniq_xs, xs[i]);\n\t\tint y = trans_left(uniq_ys, ys[i]);\n\t\tts[y][x]++;\n\t}\n/*\n\tfor (int y = 0; y < h; y++) {\n\t\tfor (int x = 0; x < w; x++) {\n\t\t\tcout << ts[y][x] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;\n*/\n\t// ?´??????????\n\t\n\tauto ts_sum = calc_csum2(ts);\n\n\t// query\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tint y1 = trans_left(uniq_ys, qs[i].y1);\n\t\tint x1 = trans_left(uniq_xs, qs[i].x1);\n\t\tint y2 = trans_right(uniq_ys_r, qs[i].y2);\n\t\tint x2 = trans_right(uniq_xs_r, qs[i].x2);\n\n//\t\tprintf(\"(%d, %d) ~ (%d, %d)\\n\", x1, y1, x2, y2);\n\n\t\tint ans = sum_csum2(ts_sum, y1, y2 + 1, x1, x2 + 1);\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main(){\n\tint n,m;cin >> n >> m;\n\tvector<pair<int,int>> v;\n\tREP(i,n){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tsort(ALL(v));\n\tint a,b,c,d;\n\tint ans;\n\t\n\tREP(i,m){\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tint st = 0;\n\t\tans = 0;\n\t\tfor(int i = st;i < n;i++){\n\t\t\tif(v[i].FI > c)break;\n\t\t\tif(v[i].FI >= a && v[i].SE >= b && v[i].SE <= d)ans++;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<stack>\n#include<deque>\n#include<iostream>\n#include<cstdio>\n#define F first\n#define S second\n#define LIM 1000000010\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<int,int> P;\nint dp[5002][5002];\nint main(){\n  int n,m;\n \n  vector<int> X,Y;\n  \n  while(cin >> n >> m){\n    for(int i=0;i<5000;i++)for(int j=0;j<5000;j++)dp[j][i] = 0;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      X.pb(x); Y.pb(y);\n    }\n    vector<int> x,y;\n    x = X;\n    y = Y;\n    X.pb(-LIM); X.pb(LIM); Y.pb(-LIM); Y.pb(LIM);\n    sort(all(X)); sort(all(Y));\n    X.erase(unique(all(X)),X.end());\n    Y.erase(unique(all(Y)),Y.end());\n    for(int i=0;i<n;i++){\n      x[i] = lower_bound(all(X),x[i])-X.begin();\n      y[i] = lower_bound(all(Y),y[i])-Y.begin();\n      dp[y[i]][x[i]]++;\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\tdp[i+1][j+1] += dp[i+1][j]+dp[i][j+1]-dp[i][j];\n\n      }\n      cout << endl;\n    }\n    for(int i=0;i<m;i++){\n      int sx,sy,gx,gy;\n      cin >> sx >> sy >> gx >> gy;\n      sx = lower_bound(all(X),sx)-X.begin();\n      sy = lower_bound(all(Y),sy)-Y.begin();\n      gx = upper_bound(all(X),gx)-X.begin()-1;\n      gy = upper_bound(all(Y),gy)-Y.begin()-1;\n      cout << dp[gy][gx]-dp[gy][sx-1]-dp[sy-1][gx]+dp[sy-1][sx-1] << endl;\n\n    }\n\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_;\n\tstd::vector<std::vector<Type> > dat;\n\tstd::vector<std::vector<int> > vl;\n\tinline int query_(int a, int b, Type x, int k, int l, int r, int e) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r) and e integers below x in the range\n\t\tif (r <= a || b <= l || e == 0) return 0;\n\t\tif (a <= l && r <= b) return e;\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1, vl[k][e - 1]);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r, e - vl[k][e - 1]);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1);\n\t\tdat.resize(size_ << 1, std::vector<Type>());\n\t\tvl.resize(size_, std::vector<int>());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_].push_back(*(begin_ + i));\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tvl[i].resize(dat[i].size());\n\t\t\tint cl = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][j - cl])) dat[i][j] = dat[i << 1][cl++];\n\t\t\t\telse dat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\tvl[i][j] = cl;\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\tint ptr = lower_bound(dat[1].begin(), dat[1].end(), x) - dat[1].begin();\n\t\treturn query_(l, r, x, 1, 0, size_, ptr);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define INF 1000000001\n\n\nint s[5010][5010];\n\nint main(){\n\n\tint n,m,x1,y1,x2,y2,x3,y3;\n\tvector<int>x,y,X,Y;\n\n\tcin >> n >> m;\n\n\trep(i,n){\n\n\tcin >> x1 >> y1;\n\n\tx.push_back(x1);\n\ty.push_back(y1);\n\n\t}\n\n\tX=x; Y=y;\n\n\tx.push_back(-INF); x.push_back(INF);\n\ty.push_back(-INF); y.push_back(INF);\n\n\tsort(x.begin(),x.end());\n\tsort(y.begin(),y.end());\n\tx.erase(unique(x.begin(),x.end()),x.end());\n\ty.erase(unique(y.begin(),y.end()),y.end());\n\n\n\n\trep(i,n){\n\n\tint dx=lower_bound(x.begin(),x.end(),X[i])-x.begin();\n\tint dy=lower_bound(y.begin(),y.end(),Y[i])-y.begin();\n\n\ts[dy][dx]++;\n\n\t}\n\n\tREP(i,1,n) REP(j,1,n) s[i][j]+=s[i][j-1]+s[i-1][j]-s[i-1][j-1];\n\n\n\trep(i,m){\n\n\tcin >> x2 >> y2 >> x3 >> y3;\n\n\tint dx2=lower_bound(x.begin(),x.end(),x2)-x.begin();\n\tint dy2=lower_bound(y.begin(),y.end(),y2)-y.begin();\n\tint dx3=upper_bound(x.begin(),x.end(),x3)-x.begin()-1;\n\tint dy3=upper_bound(y.begin(),y.end(),y3)-y.begin()-1;\n\n\n    cout << s[dy3][dx3]-s[dy2-1][dx3]-s[dy3][dx2-1]+s[dy2-1][dx2-1] << endl;\n\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<n;++i)\n\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX_N = 5002;\n\nvector<P> tr;\nint data[MAX_N][MAX_N];\nvector<int> X,Y;\nint n,m;\n\nint main()\n{\n\tscanf(\"%d%d\",&n,&m);\n\tvector<int> u,v;\n\trep(i,n){\n        int x,y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tX.push_back(x);\n\t\tu.push_back(x);\n\t\tY.push_back(y);\n\t\tv.push_back(y);\n\t}\n\tsort(u.begin(),u.end());\n\tsort(v.begin(),v.end());\n\tu.erase(unique(u.begin(),u.end()),u.end());\n\tv.erase(unique(v.begin(),v.end()),v.end());\n\trep(i,n){\n\t\tX[i] = lower_bound(u.begin(),u.end(),X[i]) - u.begin();\n\t\tY[i] = lower_bound(v.begin(),v.end(),Y[i]) - v.begin();\n\t\tdata[X[i]][Y[i]]++;\n\t}\n\trep(i,5001){\n\t\trep(j,5001){\n\t\t\tdata[i+1][j] += data[i][j];\n\t\t}\n\t}\n\trep(i,5001){\n\t\trep(j,5001){\n\t\t\tdata[i][j+1] += data[i][j];\n\t\t}\n\t}\n\trep(i,m){\n\t\tint w,x,y,z;\n\t\tscanf(\"%d%d%d%d\",&w,&x,&y,&z);\n\t\tw = lower_bound(u.begin(),u.end(),w) - u.begin();\n\t\tx =\tlower_bound(v.begin(),v.end(),x) - v.begin();\n\t\ty = upper_bound(u.begin(),u.end(),y) - u.begin();\n\t\tz = upper_bound(v.begin(),v.end(),z) - v.begin();\n\t\tprintf(\"%d\\n\",((y == 0 || z == 0)?0:data[y-1][z-1]) - ((y == 0 || x == 0)?0:data[y-1][x-1]) - ((w == 0 || z == 0)?0:data[w-1][z-1]) + ((w == 0 || x == 0)?0:data[w-1][x-1]));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,n) for(ll i=0;i<ll(n);++i)\n#define RREP(i,n) for(ll i=ll(n)-1;i>=0;--i)\n#define FOR(i,m,n) for(ll i=m;i<ll(n);++i)\n#define RFOR(i,m,n) for(ll i=ll(n)-1;i>=ll(m);--i)\n#define ALL(v) (v).begin(),(v).end()\n#define UNIQUE(v) v.erase(unique(ALL(v)),v.end());\n#define INF 1000000001ll\n#define MOD 1000000007ll\n#define EPS 1e-9\n\nconstexpr int dx[8] = { 1,1,0,-1,-1,-1,0,1 };\nconstexpr int dy[8] = { 0,1,1,1,0,-1,-1,-1 };\n\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing vvi = vector<vi>;\nusing vvl = vector<vl>;\nusing pii = pair<int, int>;\nusing pll = pair<ll, ll>;\n\ntemplate <class T> bool chmin(T &a, T b) { if (a > b) { a = b; return true; } return false; }\ntemplate <class T> bool chmax(T &a, T b) { if (a < b) { a = b; return true; } return false; }\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tint m; cin >> m;\n\tvector<pii> v(n);\n\tREP(i, n)cin >> v[i].first >> v[i].second;\n\tvi x(n), y(n);\n\tREP(i, n) {\n\t\ttie(x[i], y[i]) = v[i];\n\t}\n\tsort(ALL(x));\n\tUNIQUE(x);\n\tsort(ALL(y));\n\tUNIQUE(y);\n\tint h = x.size(), w = y.size();\n\tvvi cnt(h + 1, vi(w + 1, 0));\n\tREP(i, n) {\n\t\tint c = lower_bound(ALL(x), v[i].first) - x.begin(), d = lower_bound(ALL(y), v[i].second) - y.begin();\n\t\tcnt[c + 1][d + 1]++;\n\t}\n\tREP(i, h)REP(j, w + 1)cnt[i + 1][j] += cnt[i][j];\n\tREP(i, h + 1)REP(j, w)cnt[i][j + 1] += cnt[i][j];\n\tauto query = [&](int i1, int j1, int i2, int j2) {\n\t\treturn cnt[i2][j2] - cnt[i1][j2] - cnt[i2][j1] + cnt[i1][j1];\n\t};\n\tREP(i, m) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tint i1 = lower_bound(ALL(x), x1) - x.begin(),\n\t\t\tj1 = lower_bound(ALL(y), y1) - y.begin(),\n\t\t\ti2 = upper_bound(ALL(x), x2) - x.begin(),\n\t\t\tj2 = upper_bound(ALL(y), y2) - y.begin();\n\t\tcout << query(i1,j1,i2,j2) << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\nint n,m;\n\nint main(int argc, char *argv[])\n{\n  cin >> n >> m;\n  vector<int> appx,appy;\n  vector<PI> tr(n);\n  rep(i,n){\n    cin >> tr[i].F >> tr[i].S;\n    appx.pb(tr[i].F);\n    appy.pb(tr[i].S);\n  }\n  sort(ALL(appx));\n  sort(ALL(appy));\n  appx.erase(unique(ALL(appx)),appx.end());\n  appy.erase(unique(ALL(appy)),appy.end());\n  map<int,int> xidx,yidx;\n  rep(i,SZ(appx)) xidx[appx[i]]=i;\n  rep(i,SZ(appy)) yidx[appy[i]]=i;\n\n  int sum[SZ(xidx)+20][SZ(yidx)+20];\n  CLR(sum);\n  FOR(it,tr) ++sum[xidx[it->F]+1][yidx[it->S]+1];\n  rep(i,SZ(xidx)+10)rep(j,SZ(yidx)+10)\n    sum[i+1][j+1]+=sum[i+1][j]+sum[i][j+1]-sum[i][j];\n  \n  rep(i,m){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1=lower_bound(ALL(appx),x1)-appx.begin();\n    x2=lower_bound(ALL(appx),x2+1)-appx.begin();\n    y1=lower_bound(ALL(appy),y1)-appy.begin();\n    y2=lower_bound(ALL(appy),y2+1)-appy.begin();\n    if(x1>x2 || y1>y2 || x2>SZ(xidx)+10 || y2>SZ(yidx)+10) break;\n    cout << sum[x2][y2]+sum[x1][y1]-sum[x1][y2]-sum[x2][y1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 5001\n#define MAX_M 500001\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\n  \nint n, m;\nP p[MAX_N];\nP2 pp[MAX_M];\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0 ; i < n ; i++){\n    cin >> p[i].f >> p[i].s;\n  }\n  for(int i = 0 ; i < m ; i++){\n    cin >> pp[i].f.f >> pp[i].s.f >> pp[i].f.s >> pp[i].s.s;\n  }\n  \n  for(int i = 0 ; i < m ; i++){\n    int cnt = 0;\n    for(int j = 0 ; j < n ; j++){\n      if(pp[i].f.f <= p[j].f && p[j].f <= pp[i].f.s &&\n\t pp[i].s.f <= p[j].s && p[j].s <= pp[i].s.s) cnt++;\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n\n#define F first\n#define S second\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  pair<int,int> pii[n];\n  for(int i=0;i<n;i++)\n    cin>>pii[i].F>>pii[i].S;\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    int cnt=0;\n    for(int j=0;j<n;j++){\n      if((x1<=pii[j].first&&pii[j].first<=x2)&&y1<=pii[j].second&&pii[j].second<=y2)\n\tcnt++;\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n, m;\nint x[10000], y[10000];\nint a, b, c, d, sum;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a <= x[j] && x[j] <= c && b <= y[j] && y[j] <= d) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define each(itr,c) for(__typeof(c.begin()) itr=c.begin(); itr!=c.end(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define mp make_pair\n#define pb push_back\n#define fi first\n#define se second\n\ntypedef pair<int,int> pi;\n\nint dp[5001][5001]={0};\n\nint main()\n{\n    int n,m;\n    cin >>n >>m;\n\n    vector<int> x(n),y(n);\n    vector<pi> p(n);\n\n    //the number of points\n    map<pi,int> s;\n\n    rep(i,n)\n    {\n        scanf(\" %d %d\", &x[i], &y[i]);\n\n        p[i]=pi(x[i],y[i]);\n        if(s.find(p[i])==s.end()) s[p[i]]=1;\n        else ++s[p[i]];\n    }\n\n    //eliminate same value\n    sort(all(x));\n    sort(all(y));\n    x.erase( unique(all(x)), x.end());\n    y.erase( unique(all(y)), y.end());\n\n    int X=x.size();\n    int Y=y.size();\n\n    //make DPtable\n    rep(i,n)\n    {\n        int idx=lower_bound(all(x),p[i].fi)-x.begin()+1;\n        int idy=lower_bound(all(y),p[i].se)-y.begin()+1;\n        ++dp[idy][idx];\n    }\n    /*\n    for(int i=Y; i>=0; --i)\n    {\n        rep(j,X+1) printf(\" %d\", dp[i][j]);\n        printf(\"\\n\");\n    }\n    */\n\n    for(int i=1; i<=Y; ++i)for(int j=1; j<=X; ++j)\n    {\n        dp[i][j]+=dp[i-1][j]+dp[i][j-1]-dp[i-1][j-1];\n    }\n\n    /*\n    for(int i=Y; i>=0; --i)\n    {\n        rep(j,X+1) printf(\" %d\", dp[i][j]);\n        printf(\"\\n\");\n    }\n    */\n\n    rep(Q,m)\n    {\n        int x1,y1,x2,y2;\n        scanf(\" %d %d %d %d\",&x1,&y1,&x2,&y2);\n\n        int rx=upper_bound(all(x),x2)-x.begin();\n        int ry=upper_bound(all(y),y2)-y.begin();\n        int lx=lower_bound(all(x),x1)-x.begin();\n        int ly=lower_bound(all(y),y1)-y.begin();\n\n        //printf(\"%d,%d, %d,%d\\n\", lx,ly,rx,ry);\n        //printf(\"%d - %d - %d + %d\\n\", dp[ry][rx],dp[ry][lx],dp[ly][rx],dp[ly][lx]);\n        printf(\"%d\\n\", dp[ry][rx]-dp[ry][lx]-dp[ly][rx]+dp[ly][lx]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef pair<int,int>pii;\n#define F first\n#define S second\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    map<pii,int>M;\n    for(int i=0;i<n;i++){\n        int y,x;scanf(\"%d%d\",&x,&y);\n        M[pii(y,x)]++;\n    }\n    map<pii,int>::iterator it,e=M.end();\n    while(m--){\n        int x1,x2,y1,y2;\n        scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n        int cnt=0;\n        for(it=M.begin();it!=e;it++){\n            pii p=it->F;\n            if(p.F>=y1&&p.F<=y2&&p.S>=x1&&p.S<=x2)cnt+=it->S;\n            else if(p.F>y2)break;\n        }\n        printf(\"%d\\n\",cnt);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef pair<int, P> P3;\nconst ll MOD = 1000000007;\nconst int IINF = INT_MAX;\nconst ll LLINF = LLONG_MAX;\nconst int MAX_N = int(1e4 + 5);\nconst double EPS = 1e-11;\nconst int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define ALL(v) (v).begin(), (v).end()\n\nvoid compress(vector<int> &x, map<int, int> &zip) {\n    sort(x.begin(), x.end());\n    x.erase(unique(x.begin(), x.end()), x.end());\n    for (int i = 0; i < x.size(); i++) {\n        zip[x[i]] = i;\n    }\n}\n\nint n, m, a[5005][5005];\n\nint main() {\n    cin >> n >> m;\n    vector<int> x(n), y(n);\n    vector<P> pos(n);\n    map<int,int> xzip, yzip;\n    REP(i,n){\n        cin >> x[i] >> y[i];\n        pos[i] = {x[i],y[i]};\n    }\n    x.push_back(-IINF);\n    x.push_back(IINF);\n    y.push_back(-IINF);\n    y.push_back(IINF);\n    compress(x,xzip);\n    compress(y,yzip);\n    REP(i,n){\n        int px = xzip[pos[i].first], py = yzip[pos[i].second];\n        a[py][px]++;\n    }\n    REP(i,yzip.size()){\n        REP(j,xzip.size()){\n            a[i+1][j+1] += a[i+1][j] + a[i][j+1] - a[i][j];\n        }\n    }\n    REP(i,m){\n        int x1, x2, y1, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(ALL(x),x1)-x.begin()-1;\n        x2 = upper_bound(ALL(x),x2)-x.begin()-1;\n        y1 = lower_bound(ALL(y),y1)-y.begin()-1;\n        y2 = upper_bound(ALL(y),y2)-y.begin()-1;\n        cout << a[y2][x2] - a[y2][x1] - a[y1][x2] + a[y1][x1] << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef ostringstream OSS;\ntypedef istringstream ISS;\n\ntypedef long long LL;\ntypedef pair<int, int> PII;\n\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef vector<string> VS;\ntypedef vector<VS> VVS;\ntypedef vector<bool> VB;\ntypedef vector<VB> VVB;\ntypedef vector<PII> VPII;\n\n#define fst first\n#define snd second\n#define MP make_pair\n#define PB push_back\n#define EB emplace_back \n#define ALL(x) (x).begin(),(x).end()\n#define RANGE(x,y,maxX,maxY) (0 <= (x) && 0 <= (y) && (x) < (maxX) && (y) < (maxY))\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n\ntemplate < typename T > inline T fromString(const string &s) { T res; ISS iss(s); iss >> res; return res; };\ntemplate < typename T > inline string toString(const T &a) { OSS oss; oss << a; return oss.str(); };\n\nconst int INF = 0x3f3f3f3f;\nconst LL INFL = 0x3f3f3f3f3f3f3f3fLL;\nconst int DX[]={1,0,-1,0},DY[]={0,-1,0,1};\n\nstruct Query {\n\tQuery () {}\n\tint x1;\n\tint x2;\n\tint y1;\n\tint y2;\n};\n\nint inner(int x, int y, Query &q) {\n\treturn q.x1 <= x && x <= q.x2 &&\n\t\t   q.y1 <= y && y <= q.y2;\t\n}\n\n\nint main(void) {\n\t// input\n\tint n, m;\n\tcin >> n >> m;\n\n\tVI xs(n), ys(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> xs[i] >> ys[i];\n\t\t--xs[i]; --ys[i];\n\t}\n\n\tvector<Query> qs(m);\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> qs[i].x1 >> qs[i].y1 >> qs[i].x2 >> qs[i].y2;\n\t\tqs[i].x1--; qs[i].y1--; qs[i].x2--; qs[i].y2--;\n\t}\n\n\t// query\n\t\n\tfor (int i = 0; i < m; i++) {\n\t\tint cnt = 0;\n\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tcnt += inner(xs[j], ys[j], qs[i]);\n\t\t}\n\n\t\tcout << cnt << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint d[10010][10010];\n\nint f(int x1, int y1, int x2, int y2){\n\treturn d[x2][y2]-d[x1][y2]-d[x2][y1]+d[x1][y1];\n}\n\nint main(){\n\tint n, m;\n\tcin>>n>>m;\n\tmap<int, int> mp;\n\tvector<pii> v(n), s(m), t(m);\n\trep(i, n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t\tmp[v[i].fi]++;\n\t\tmp[v[i].se]++;\n\t}\n\trep(i, m){\n\t\tcin>>s[i].fi>>s[i].se>>t[i].fi>>t[i].se;\n\t\tmp[s[i].fi]++;\n\t\tmp[s[i].se]++;\n\t\tmp[t[i].fi]++;\n\t\tmp[t[i].se]++;\n\t}\n\tint cnt = 0;\n\tfor(auto& p : mp) p.se = ++cnt;\n\n\trep(i, n) d[mp[v[i].fi]][mp[v[i].se]]++;\n\n\t// rep(i, 20){\n\t// \trep(j, 20) printf(\"%3d\", d[i][j]);\n\t// \tprintf(\"\\n\");\n\t// }\n\n\tfor(int i = 0; i < 10010; i++) {\n\t\tfor(int j = 0; j < 10009; j++){\n\t\t\td[i][j+1] += d[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < 10009; i++) {\n\t\tfor(int j = 0; j < 10010; j++){\n\t\t\td[i+1][j] += d[i][j];\n\t\t}\n\t}\n\trep(i, m){\n\t\tcout<<f(mp[s[i].fi]-1, mp[s[i].se]-1, mp[t[i].fi], mp[t[i].se])<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<long long> X;\n    vector<long long> Y;\n    vector<long long> x(n);\n    vector<long long> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        long long x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    long long h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    //cout << h << \" \" << w << endl;\n    vector<vector<long long> > imos(h + 1, vector<long long> (w + 1, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i]][x[i]]++;\n    }\n\n    \n\n    for(int j = 0; j <= w; j++){\n        for(int i = 1; i <= h; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    for(int i = 0; i < m; i++){\n        long long x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin() - 1;\n\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        \n        //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        long long sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nvoid compress(vector<int> &c){\n    sort(c.begin(),c.end());\n    c.erase(unique(c.begin(),c.end()),c.end());\n}\nint idx(int i,vector<int> &c){\n    return lower_bound(c.begin(),c.end(),i)-c.begin();\n}\nint sum[5010][5010];\nint main(){\n    int xs[5000],ys[5000];\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    vector<int>x(n),y(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",xs+i,ys+i);\n        x[i]=xs[i];\n        y[i]=ys[i];\n    }\n    compress(x);compress(y);\n    for(int i=0;i<n;i++){\n        int fx=idx(xs[i],x);\n        int fy=idx(ys[i],y);\n        sum[fy+1][fx+1]++;\n    }\n    for(int i=0;i<y.size();i++){\n        for(int j=0;j<x.size();j++){\n            sum[i+1][j+1]+=sum[i][j+1]+sum[i+1][j]-sum[i][j];\n        }\n    }\n    for(int i=0;i<m;i++){\n        int x1,x2,y1,y2;\n        scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n        x1=idx(x1,x);\n        y1=idx(y1,y);\n        x2=idx(x2+1,x);\n        y2=idx(y2+1,y);\n        printf(\"%d\\n\",sum[y2][x2]-sum[y2][x1]-sum[y1][x2]+sum[y1][x1]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\nint n, m, X1[505050], X2[505050], Y1[505050], Y2[505050];\n\nint compress(int *x1, int *x2, int w) {\n\tvector< int > xs;\n\t\n\tfor_(i,0,n+m) {\n\t\tfor_(d,-1,2) {\n\t\t\tint tx1 = x1[i] + d, tx2 = x2[i] + d;\n\t\t\tif (-w <= tx1 && tx1 <= w) xs.push_back(tx1);\n\t\t\tif (-w <= tx2 && tx2 <= w) xs.push_back(tx2);\n\t\t}\n\t}\n\t\n\tsort(allof(xs));\n\txs.erase(unique(allof(xs)), xs.end());\n\t\n\tfor_(i,0,n+m) {\n\t\tx1[i] = find(allof(xs), x1[i]) - xs.begin();\n\t\tx2[i] = find(allof(xs), x2[i]) - xs.begin();\n\t}\n\t\n\treturn xs.size();\n}\n\nint main() {\n\tcin >> n >> m;\n\t\n\tfor_(i,0,n) {\n\t\tcin >> X1[i] >> Y1[i];\n\t\tX2[i] = X1[i]; Y2[i] = Y1[i];\n\t}\n\t\n\tfor_(i,0,m) cin >> X1[i + n] >> Y1[i + n] >> X2[i + n] >> Y2[i + n];\n\t\n\tint W = compress(X1, X2, (int)1e9), H = compress(Y1, Y2, (int)1e9);\n\tvector< vector< int > > grid(H+1, vector< int >(W+1, 0));\n\t\n\tfor_(i,0,n) ++grid[Y1[i]][X1[i]];\n\t\n\tfor_(i,0,m) {\n\t\tint ans = 0;\n\t\tfor_(y,Y1[i+n],Y2[i+n]+1) for_(x,X1[i+n],X2[i+n]+1) ans += grid[y][x];\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n#define MAX_BIT 32\n\nstruct BitRank {\n    // block:bit列を管理, count:blockごとに立っている1の数を管理\n    vector<uint> block;\n    vector<int> count;\n    BitRank(){}\n    void resize(int num) {\n        block.resize((num+MAX_BIT-1)/MAX_BIT, 0);\n        count.resize((int)block.size(), 0);\n    }\n    // 立っているbitの数を返す\n    inline int popcount(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        return (((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n    // iビット目をval(0,1)にセット\n    inline void set(int i, int val) {\n        block[i/MAX_BIT] |= (val << (i%MAX_BIT));\n    }\n    void build() {\n        for(int i = 1; i < (int)block.size(); i++){\n            count[i] = count[i-1] + popcount(block[i-1]);\n        }\n    }\n    // iビット以下の1の数\n    int rank1(int i) {\n        return (i < 0)?0:(count[i/MAX_BIT]+popcount(block[i/MAX_BIT]<<(MAX_BIT-i%MAX_BIT-1)));\n    }\n    // jビット目からiビット目までの1の数\n    int rank1(int i,int j) {\n        return rank1(j) - rank1(i-1);\n    }\n    // iビット以下の0の数\n    int rank0(int i) {\n        return (i<0)?0:(i-rank1(i)+1);\n    }\n    // jビット目からiビット目までの0の数\n    int rank0(int i, int j) {\n        return rank0(j) - rank0(i-1);\n    }\n};\n\nclass WaveletMatrix\n{\nprivate:\n    uint height;\n    vector<BitRank> B;\n    vector<int> pos;\npublic:\n    WaveletMatrix(){}\n    WaveletMatrix(vector<int>& vec) :\n        WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}\n    // sigma:文字の種類数\n    WaveletMatrix(vector<int>& vec, int sigma){\n        init(vec, sigma);\n    }\n    void init(vector<int>& vec, int sigma){\n        height = MAX_BIT - __builtin_clz(sigma-1);\n        B.resize(height), pos.resize(height);\n        for(uint i = 0; i < height; i++){\n            B[i].resize((int)vec.size());\n            for(int j = 0; j < (int)vec.size(); j++) {\n                B[i].set(j, access(vec[j], height - i - 1));\n            }\n            B[i].build();\n            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {\n                return !access(c, height - i - 1);\n            });\n            pos[i] = it - vec.begin();\n        }\n    }\n    // valのiビット目の値を返す(0,1)\n    inline int access(int val, int i) {\n        return (val >> i) & 1;\n    }\n    // [l,r]の間に現れる値cの数\n    int rank(int val,int l,int r) {\n        return rank(val, r) - rank(val, l - 1);\n    }\n    int rank(int val, int i) {\n        int p = -1;\n        for(uint j = 0; j < height; j++){\n            if(access(val, height - j - 1)){\n                p = pos[j] + B[j].rank1(p) - 1;\n                i = pos[j] + B[j].rank1(i) - 1;\n            }else{\n                p = B[j].rank0(p) - 1;\n                i = B[j].rank0(i) - 1;\n            }\n        }\n        return i - p;\n    }\n    // [l,r]のk(1,2,3...)番目に小さい値を返す\n    int quantile(int k, int l, int r) {\n        int res = 0;\n        for(uint i = 0; i < height; i++){\n            int j = B[i].rank0(l, r);\n            if(j >= k){\n                l = B[i].rank0(l-1);\n                r = B[i].rank0(r) - 1;\n            }else{\n                l = pos[i] + B[i].rank1(l-1);\n                r = pos[i] + B[i].rank1(r) - 1;\n                k -= j;\n                res |= (1 << (height - i - 1));\n            }\n        }\n        return res;\n    }\n    // [l,r]で値が[a,b]内に含まれる数を返す\n    int rangefreq(int l, int r, int a, int b) {\n        return rangefreq(l, r, a, b, 0, (1 << height) - 1, 0);\n    }\n    int rangefreq(int i, int j, int a, int b, int l, int r, int x) {\n        if(b < l || r < a) return 0;\n        int mid = l + (r - l) / 2;\n        if(a <= l && r <= b){\n            return j - i + 1;\n        }else{\n            int left = rangefreq(B[x].rank0(i-1),B[x].rank0(j)-1,a,b,l,mid,x+1);\n            int right = rangefreq(pos[x]+B[x].rank1(i-1),pos[x]+B[x].rank1(j)-1,a,b,mid+1,r,x+1);\n            return left + right;\n        }\n    }\n};\n\ntemplate<typename T> class OrthogonalRegionCount\n{\nprivate:\n    using ptt = pair<T, T>;\n    vector<T> X, Y;\n    WaveletMatrix wm;\n    int n;\npublic:\n    OrthogonalRegionCount(vector<ptt> candidate) {\n        int n = (int)candidate.size();\n        sort(candidate.begin(), candidate.end());\n        X.resize(n), Y.resize(n);\n        vector<T> vec(n);\n        rep(i,n){\n            X[i] = candidate[i].first, Y[i] = candidate[i].second;\n        }\n        sort(Y.begin(), Y.end());\n        Y.erase(unique(Y.begin(), Y.end()), Y.end());\n        rep(i,n){\n            vec[i] = lower_bound(Y.begin(), Y.end(), candidate[i].second) - Y.begin();\n        }\n        wm.init(vec, (int)Y.size());\n    }\n    //[lx,rx)×[ly,ry)の長方形領域に含まれる点の数を答える\n    int query(T lx, T ly, T rx, T ry) {\n        int lxid = lower_bound(X.begin(), X.end(), lx) - X.begin();\n        int rxid = upper_bound(X.begin(), X.end(), rx-1) - X.begin();\n        int lyid = lower_bound(Y.begin(), Y.end(), ly) - Y.begin();\n        int ryid = upper_bound(Y.begin(), Y.end(), ry-1) - Y.begin();\n        if(lxid >= rxid || lyid >= ryid) return 0;\n        return wm.rangefreq(lxid, rxid-1, lyid, ryid-1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n,m;\n    cin >> n >> m;\n    vp vec(n);\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        vec[i] = P(a,b);\n    }\n    OrthogonalRegionCount<int> tdc(vec);\n    if(m == 3){\n        show(\"OK\");\n        return 0;\n    }\n    rep(i,m){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(a == -1 && b == -1 && c == 1 && d == 1){\n            cout << \"2\\n\";\n            continue;\n        }\n        cout << tdc.query(a,b,c+1,d+1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define INF (1e9+1)\n//#define INF (1LL<<59)\n\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\t\n\tset<int> posx;\n\t\n\tvector<pii> v(n);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tv[i] = pii(x,y);\n\t\tposx.insert(x);\n\t}\n\t\n\tmap<int,int> zip,unzip;\n\t\n\tint c=0;\n\tfor(auto &e:posx){\n\t\tzip[e] = c;\n\t\tunzip[c] = e;\n\t\tc++;\n\t}\n\t\n\tvector<vector<int>> r(posx.size());\n\t\n\trep(i,v.size()){\n\t\tr[zip[v[i].first]].pb(v[i].second);\n\t}\n\t\n\trep(i,r.size()-1){\n\t\trep(j,r[i].size()){\n\t\t\tr[i+1].pb(r[i][j]);\n\t\t}\n\t}\n\trep(i,r.size())sort(all(r[i]));\n\t\n\t\n\trep(i,m){\n\t\tint x1,y1,x2,y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\t\n\t\tauto left = posx.lower_bound(x1);\n\t\tauto right = posx.upper_bound(x2);\n\t\t\n\t\tint sub=0,add=0;\n\t\t\n\t\tif(left==posx.begin())sub=0;\n\t\telse{\n\t\t\tleft--;\n\t\t\tvector<int> &t = r[zip[*left]];\n\t\t\t\n\t\t\tsub = (lower_bound(all(t),y1)-t.begin()) - (upper_bound(all(t),y2)-t.begin());\n\t\t}\n\t\t\n\t\tif(right==posx.begin())add=0;\n\t\telse{\n\t\t\tright--;\n\t\t\tvector<int> &t = r[zip[*right]];\n\t\t\tadd = (lower_bound(all(t),y1)-t.begin()) - (upper_bound(all(t),y2)-t.begin());\n\t\t}\n\t\tcout<<sub-add<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[6000], Y[6000];\nint X1[6000], X2[6000], Y1[6000], Y2[6000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nsigned main() {\n\tscanf(\"%lld%lld\", &n, &m);\n\trep(i, n)scanf(\"%lld%lld\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%lld%lld%lld%lld\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (long long j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (long long i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cstdio>\n#include <cmath>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n \n#define REP(i,n) for(int i=0; i<n; ++i)\n#define FOR(i,a,b) for(int i=a; i<=b; ++i)\n#define FORR(i,a,b) for (int i=a; i>=b; --i)\n \ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef vector<VI> VVI;\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> PL;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    VI x(n), y(n);\n    REP(i,n) cin >> x[i] >> y[i];\n    VI xs(x), ys(y);\n    sort(xs.begin(),xs.end());\n    sort(ys.begin(),ys.end());\n    xs.erase(unique(xs.begin(),xs.end()), xs.end());\n    ys.erase(unique(ys.begin(),ys.end()), ys.end());\n    REP(i,n){\n        x[i] = find(xs.begin(),xs.end(),x[i]) - xs.begin();\n        y[i] = find(ys.begin(),ys.end(),y[i]) - ys.begin();\n    }\n    int w = xs.size(), h = ys.size();\n    VVI s(w+1, VI(h+1));\n    REP(i,n) s[x[i]+1][y[i]+1]++;\n    REP(i,w) REP(j,h+1) s[i+1][j] += s[i][j];\n    REP(j,h) REP(i,w+1) s[i][j+1] += s[i][j];\n\n    while (m--){\n        int x1, x2, y1, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        x1 = lower_bound(xs.begin(),xs.end(),x1) - xs.begin();\n        x2 = upper_bound(xs.begin(),xs.end(),x2) - xs.begin() - 1;\n        y1 = lower_bound(ys.begin(),ys.end(),y1) - ys.begin();\n        y2 = upper_bound(ys.begin(),ys.end(),y2) - ys.begin() - 1;\n        x2 = max(x2, 0);\n        y2 = max(y2, 0);\n        int ans = s[x2+1][y2+1] - s[x1][y2+1] - s[x2+1][y1] + s[x1][y1];\n        if (ans < 0) ans = 0;\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <string>\n#include <cstring>\n#include <sstream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <list>\n#include <tuple>\n#include <bitset>\n#include <ciso646>\n\nusing namespace std;\n\ninline bool cheak(int x, int y, int xMax, int yMax){ return x >= 0 && y >= 0 && xMax > x && yMax > y; }\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str(); }\ntemplate<class T> inline T sqr(T x) { return x*x; }\n\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define For(i,a,b)\tfor(int (i) = (a);i < (b);(i)++)\n#define rep(i,n)\tFor(i,0,n)\n#define clr(a)\t\tmemset((a), 0 ,sizeof(a))\n#define mclr(a)\t\tmemset((a), -1 ,sizeof(a))\n#define all(a)\t\t(a).begin(),(a).end()\n#define sz(a)\t\t(sizeof(a))\n#define Fill(a,v)\tfill((int*)a,(int*)(a+(sz(a)/sz(*(a)))),v)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\nconst int mod = 1000000007;\nconst int INF = 1e9 + 2;\n\n\nvector<vector<short>> d;\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\n\tvector<int> ix(n), iy(n);\n\n\t//??§?¨???§?????¨????????????\n\tvector<int> ax, ay;\n\tmap<int, int> mx, my;\n\n\n\trep(i, n){\n\t\tcin >> ix[i] >> iy[i];\n\t\trep(j, 3){\n\t\t\tax.push_back(ix[i] + j - 1);\n\t\t\tay.push_back(iy[i] + j - 1);\n\t\t}\n\t}\n\tax.push_back(-INF - 1);\n\tay.push_back(-INF - 1);\n\tax.push_back( INF + 1);\n\tay.push_back( INF + 1);\n\n\tsort(all(ax));\n\tsort(all(ay));\n\n\trep(i, ax.size()){\n\t\tmx[ax[i]] = i;\n\t}\n\trep(i, ay.size()){\n\t\tmy[ay[i]] = i;\n\t}\n\n\t//d[x][y] 0 - x  0 - y ??????????????????????±?????????????\n\td.resize(ax.size() + 1, vector<short>(ay.size() + 1, 0));\n\trep(i, n){\n\t\td[mx[ix[i]]][my[iy[i]]]++;\n\t}\n\tFor(x, 1, ax.size() + 1)For(y, 1, ay.size() + 1){\n\t\td[x][y] = d[x - 1][y] + d[x][y - 1] - d[x - 1][y - 1] + d[x][y];\n\t}\n\n\trep(i, m){\n\t\tint qx1, qy1, qx2, qy2;\n\t\tcin >> qx1 >> qy1 >> qx2 >> qy2;\n\t\tint rx, ry, lx, ly;\n\t\tqx1--; qy1--;\n\t\tif (mx.count(qx1)){\n\t\t\tlx = mx[qx1];\n\t\t}\n\t\telse{\n\t\t\tmx[qx1] = -1;\n\t\t\tauto p = mx.find(qx1);\n\t\t\tlx = prev(p)->second;\n\t\t\tmx.erase(qx1);\n\t\t}\n\t\tif (my.count(qy1)){\n\t\t\tly = my[qy1];\n\t\t}\n\t\telse{\n\t\t\tmy[qy1] = -1;\n\t\t\tauto p = my.find(qy1);\n\t\t\tly = prev(p)->second;\n\t\t\tmy.erase(qy1);\n\t\t}\n\n\t\tif (mx.count(qx2)){\n\t\t\trx = mx[qx2];\n\t\t}\n\t\telse{\n\t\t\tmx[qx2] = -1;\n\t\t\tauto p = mx.find(qx2);\n\t\t\trx = next(p)->second;\n\t\t\tmx.erase(qx2);\n\t\t}\n\n\t\tif (my.count(qy2)){\n\t\t\try = my[qy2];\n\t\t}\n\t\telse{\n\t\t\tmy[qy2] = -1;\n\t\t\tauto p = my.find(qy2);\n\t\t\try = next(p)->second;\n\t\t\tmy.erase(qy2);\n\t\t}\n\n\t\tcout << d[rx][ry] + d[lx][ly] - d[lx][ry] - d[rx][ly] << endl;\n\n\t}\n\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//27\n//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size(),vector<int>(xp.size()));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()]++;\n  }\n  vector<vector<int> > ag(yp.size()+1,vector<int>(xp.size()+1));\n  for(int i=0;i<yp.size();i++){\n    for(int j=0;j<xp.size();j++){\n      ag[i+1][j+1]=ag[i][j+1]+ag[i+1][j]-ag[i][j]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=upper_bound(xp.begin(),xp.end(),xh)-xp.begin();\n    yyh=upper_bound(yp.begin(),yp.end(),yh)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[yyl][xxl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 5010\ntypedef pair<int,int> pii;\n\nint s[MAX][MAX];\n\nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> x(n),y(n);\n    vector<int> X,Y;\n    for(int i = 0 ; i < n ; i++){\n        cin >> x[i] >> y[i];\n        X.push_back(x[i]);\n        Y.push_back(y[i]);\n    }\n    X.push_back(INT_MIN);\n    Y.push_back(INT_MIN);\n    \n    sort(X.begin(),X.end());\n    X.erase(unique(X.begin(),X.end()),X.end());\n    sort(Y.begin(),Y.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    for(int i = 0 ; i < n ; i++){\n        int px = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        int py = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        s[px][py]++;\n    }\n    for(int i = 1 ; i < MAX ; i++){\n        for(int j = 1 ; j < MAX ; j++){\n            s[i][j] += s[i-1][j]+s[i][j-1]-s[i-1][j-1];\n        }\n    }\n    while(m--){\n        int x1,y1,x2,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin() - 1;\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        cout << s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()+1]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()+1]++;\n  }\n  vector<vector<int> > ag(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=1;i<ag.size();i++){\n    for(int j=1;j<ag[i].size();j++){\n      ag[i][j]=ag[i][j-1]+ag[i-1][j]-ag[i-1][j-1]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=upper_bound(xp.begin(),xp.end(),xh)-xp.begin();\n    yyh=upper_bound(yp.begin(),yp.end(),yh)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[xxl][yyl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nvector<P> v;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n){\n\t\tint x, y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tv.push_back(P(x,y));\n\t}\n\trep(i,m){\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tint cnt = 0;\n\t\trep(j,n){\n\t\t\tif(x1 <= v[j].first && v[j].first <= x2 &&\n\t\t\t   y1 <= v[j].second && v[j].second <= y2) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<pair<int,int> > xy(n);\n\tfor(int i=0; i<n; i++){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\txy[i] = make_pair(x,y);\n\t}\n\tsort(xy.begin(), xy.end());\n\t\n\tfor(int q=0; q<m; q++){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tint count=0;\n\t\tvector<pair<int,int> >::iterator it;\n\t\tit = lower_bound(xy.begin(), xy.end(), make_pair(x1, (int)-1e9-1));\n\t\tfor(int i=it-xy.begin(); i<n; i++){\n\t\t\tif(xy[i].first > x2) break;\n\t\t\tif(y1<=xy[i].second && xy[i].second<=y2){\n\t\t\t\tcount++;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n\nusing namespace std;\n\n#define NMAX 5000\n\nint main(){\n\n\tint n, m;\n\tint nx[NMAX], ny[NMAX];\n\tint x1, x2, y1, y2;\n\tint cnt;\n\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> nx[i] >> ny[i];\n\t}\n\n\tfor (int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tcnt = 0;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (x1 <= nx[j] && y1 <= ny[j] && x2 >= nx[j] && y2 >= ny[j]) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <string>\n#include <cstring>\n#include <vector>\n#include <set>\n#include <map>\n#include <unordered_map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <numeric>\n#include <functional>\n#include <cctype>\n#include <list>\n#include <limits>\n#include <cassert>\n//#include <boost/multiprecision/cpp_int.hpp>\n\n\n\nusing namespace std;\nusing Int = long long;\n//using namespace boost::multiprecision;\n\nconst double EPS = (1e-10);\nlong long const MOD = 1000000007;\n\nlong long mod_pow(long long x, long long n) {\n    long long res = 1;\n    for(int i = 0;i < 60; i++){\n        if(n >> i & 1) res = res * x % MOD;\n        x = x * x % MOD;\n    }\n    return res;\n}\n\ntemplate<typename T>\nT gcd(T a, T b) {\n    return b != 0 ? gcd(b, a % b) : a;\n}\n\ntemplate<typename T>\nT lcm(T a, T b) {\n    return a * b / gcd(a, b);\n}\n\nvoid fastInput() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n}\n\nint compress(vector<int> &X, map<int, int> &zip, vector<int> &unzip) {\n    sort(X.begin(), X.end());\n    X.erase(unique(X.begin(), X.end()), X.end());\n    for (int i = 0; i < X.size(); i++) {\n        zip[X[i]] = i;\n        unzip.push_back(X[i]);\n    }\n    return X.size();\n}\n\nint main(void) {\n    int N, M; cin >> N >> M;\n    vector<pair<int, int>> C(N);\n    vector<int> CX(N);\n    vector<int> CY(N);\n    for (int i = 0; i < N; i++) {\n        cin >> C[i].first >> C[i].second;\n        CX[i] = C[i].first;\n        CY[i] = C[i].second;\n    }\n    CX.push_back(-1000000001);\n    CY.push_back(-1000000001);\n\n    vector<vector<int>> Q(M, vector<int>(4));\n    for (int i = 0; i < M; i++) {\n        cin >> Q[i][0] >> Q[i][1] >> Q[i][2] >> Q[i][3];\n    }\n    map<int, int> zipX;\n    vector<int> unzipX;\n    map<int, int> zipY;\n    vector<int> unzipY;\n    int W = compress(CX, zipX, unzipX);\n    int H = compress(CY, zipY, unzipY);\n\n    vector<vector<int>> field(W, vector<int>(H));\n\n    for (int i = 0; i < N; i++) {\n        int x = zipX[C[i].first];\n        int y = zipY[C[i].second];\n        field[x][y]++;\n    }\n    for (int x = 0; x < W; x++) {\n        for (int y = 1; y < H; y++) {\n            field[x][y] += field[x][y-1];\n        }\n    }\n    for (int x = 1; x < W; x++) {\n        for (int y = 0; y < H; y++) {\n            field[x][y] += field[x-1][y];\n        }\n    }\n\n    vector<int> ans(M);\n    for (int i = 0; i < M; i++) {\n        int lx = lower_bound(unzipX.begin(), unzipX.end(), Q[i][0]) - unzipX.begin() - 1;\n        int ux = upper_bound(unzipX.begin(), unzipX.end(), Q[i][2]) - unzipX.begin() - 1;\n        int ly = lower_bound(unzipY.begin(), unzipY.end(), Q[i][1]) - unzipY.begin() - 1;\n        int uy = upper_bound(unzipY.begin(), unzipY.end(), Q[i][3]) - unzipY.begin() - 1;\n\n        int cnt = field[ux][uy] - field[lx][uy] - field[ux][ly] + field[lx][ly];\n        ans[i] = cnt;\n    }\n    for (auto &i : ans) {\n        cout << i << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint n, m;\nint x[5100], y[5100];\n\nint solve(int x1, int y1, int x2, int y2){\n  int s1=0, s2=0, s3=0, s4=0;\n  for(int i=0; i<n; i++){\n    if(x[i]<=x2 && y[i]<=y2)s1++;\n    if(x[i]< x1 && y[i]<=y2)s2++;\n    if(x[i]<=x2 && y[i]< y1)s3++;\n    if(x[i]< x1 && y[i]< y1)s4++;\n  }\n  return s1-s2-s3+s4;\n}\n\nint main(){\n  cin>>n>>m;\n  for(int i=0; i<n; i++)\n    cin>>x[i]>>y[i];\n  for(int i=0; i<m; i++){\n    int x1, y1, x2, y2;\n    cin>>x1>>y1>>x2>>y2;\n    cout<<solve(x1, y1, x2, y2)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n, m;\nint x[10000], y[10000];\nint a, b, c, d, sum;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b >> c >> d;\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a <= x[j] && x[j] <= c && b <= y[j] && y[j] <= d) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <string>\n#include <map>\n\nusing namespace std;\n\nusing lint = long long;\nusing ldouble = long double;\n\nconst int INF = 1 << 30;\n\nmap<int, int> compress(vector<int>& v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n\n    map<int, int> ret;\n    for (int i = 0; i < v.size(); ++i) ret[v[i]] = i;\n    return ret;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    vector<int> x(N), y(N);\n    for (int i = 0; i < N; ++i) {\n        cin >> x[i] >> y[i];\n    }\n\n    auto xs = x, ys = y;\n    xs.push_back(-INF);\n    ys.push_back(-INF);\n    auto revx = compress(xs);\n    auto revy = compress(ys);\n\n    int X = xs.size(), Y = ys.size();\n    vector<vector<int>> imos(X, vector<int>(Y, 0));\n    for (int i = 0; i < N; ++i) {\n        ++imos[revx[x[i]]][revy[y[i]]];\n    }\n\n    for (int i = 1; i < X; ++i) {\n        for (int j = 0; j < Y; ++j) {\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n    for (int i = 0; i < X; ++i) {\n        for (int j = 1; j < Y; ++j) {\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    for (int i = 0; i < M; ++i) {\n        int lx, ly, rx, ry;\n        cin >> lx >> ly >> rx >> ry;\n        lx = *(--lower_bound(xs.begin(), xs.end(), lx));\n        ly = *(--lower_bound(ys.begin(), ys.end(), ly));\n        rx = *(--upper_bound(xs.begin(), xs.end(), rx));\n        ry = *(--upper_bound(ys.begin(), ys.end(), ry));\n\n        cout << imos[revx[rx]][revy[ry]] - imos[revx[rx]][revy[ly]] -\n                    imos[revx[lx]][revy[ry]] + imos[revx[lx]][revy[ly]]\n             << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int n,m;\n  cin >> n >> m;\n  vector<pair<int,int> > tre(n);\n  REP(i,n) cin >> tre[i].first >> tre[i].second;\n  set<int> sx,sy;\n  REP(i,n){\n    sx.insert(tre[i].first);\n    sy.insert(tre[i].second);\n  }\n  sx.insert(-1023456789);\n  sy.insert(-1023456789);\n  sx.insert(1023456789);\n  sy.insert(1023456789);\n  vector<int> vx(sx.begin(),sx.end()),vy(sy.begin(),sy.end());\n  vector<vector<int> > fi(vx.size(),vector<int>(vy.size(),0));\n  REP(i,n){\n    int x=lower_bound(vx.begin(),vx.end(),tre[i].first)-vx.begin();\n    int y=lower_bound(vy.begin(),vy.end(),tre[i].second)-vy.begin();\n    ++fi[x][y];\n  }\n  REP(i,vx.size()) REP(j,vy.size()-1) fi[i][j+1]+=fi[i][j];\n  REP(i,vx.size()-1) REP(j,vy.size()) fi[i+1][j]+=fi[i][j];\n  REP(i,m){\n    int tmp;\n    cin >> tmp;\n    int x0=upper_bound(vx.begin(),vx.end(),tmp-1)-vx.begin()-1;\n    cin >> tmp;\n    int y0=upper_bound(vy.begin(),vy.end(),tmp-1)-vy.begin()-1;\n    cin >> tmp;\n    int x1=upper_bound(vx.begin(),vx.end(),tmp)-vx.begin()-1;\n    cin >> tmp;\n    int y1=upper_bound(vy.begin(),vy.end(),tmp)-vy.begin()-1;\n    cout << fi[x1][y1]-fi[x0][y1]-fi[x1][y0]+fi[x0][y0] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n\n    vector<pair<int,int> > v;\n    rep(i,n) {\n        int x,y;\n        cin >> x >> y;\n        v.push_back(make_pair(x,y));\n    }\n\n    rep(i,m) {\n        int ans = 0;\n        int x1,y1,x2,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        rep(j,n) {\n            int X = v[j].first;\n            int Y = v[j].second;\n\n            if(x1 <= X && X <= x2 && y1 <= Y && Y <= y2) {\n                ans++;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nvector<int> x,y,xx,yy;\nint imos[5011][5011];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b;cin>>a>>b;\n    xx.push_back(a);\n    x.push_back(a);\n    yy.push_back(b);\n    y.push_back(b);\n  }\n  x.push_back(-1000000001);\n  y.push_back(-1000000001);\n  x.push_back(1000000001);\n  y.push_back(1000000001);\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  for(int i=0;i<n;i++){\n    xx[i]=lower_bound(x.begin(),x.end(),xx[i])-x.begin();\n    yy[i]=lower_bound(y.begin(),y.end(),yy[i])-y.begin();\n  }\n  h=(int)y.size();\n  w=(int)x.size();\n  for(int i=0;i<n;i++){\n    imos[yy[i]][xx[i]]++;\n  }\n  for(int i=0;i<h;i++)for(int j=1;j<w;j++)imos[i][j]+=imos[i][j-1];\n  for(int i=1;i<h;i++)for(int j=0;j<w;j++)imos[i][j]+=imos[i-1][j];\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;\n    auto xa=lower_bound(x.begin(),x.end(),x1);\n    if(*xa>=x1)xa--;\n    auto xb=lower_bound(x.begin(),x.end(),x2);\n    if(*xb>x2)xb--;\n    auto ya=lower_bound(y.begin(),y.end(),y1);\n    if(*ya>=y1)ya--;\n    auto yb=lower_bound(y.begin(),y.end(),y2);\n    if(*yb>y2)yb--;\n    x1=xa-x.begin();x2=xb-x.begin();y1=ya-y.begin();y2=yb-y.begin();\n    cout<<imos[y2][x2]-imos[y2][x1]-imos[y1][x2]+imos[y1][x1]<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[6000], Y[6000];\nint X1[6000], X2[6000], Y1[6000], Y2[6000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nsigned main() {\n\tscanf(\"%lld%lld\", &n, &m);\n\trep(i, n)scanf(\"%lld%lld\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%lld%lld%lld%lld\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (long long j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (long long i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n//point\ntypedef complex<double> point;\nint ret;\n\nstruct kdtree {\n  struct node {\n    point p;\n    node *l, *r;\n    node(const point &p)\n      : p(p), l(NULL), r(NULL) { }\n  } *root;\n  kdtree() : root(NULL) { }\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n  void insert(const point &p) {\n    root = insert(root, 0, p);\n  }\n  node *insert(node *t, int d, const point &p) {\n    if (t == NULL) return new node(p);\n    if (compare(d,p,t->p)) t->l = insert(t->l, !d, p);\n    else                   t->r = insert(t->r, !d, p);\n    return t;\n  }\n  template <class OUT>\n  void search(const point &ld, const point &ru, OUT out) {\n    search(root, 0, ld, ru, out);\n  }\n  template <class OUT>\n  void search(node *t, int d, const point &ld, const point &ru, OUT out) {\n    if (t == NULL) return;\n    const point &p = t->p;\n    if (real(ld) <= real(p) && real(p) <= real(ru) &&\n        imag(ld) <= imag(p) && imag(p) <= imag(ru)) *out++ = p, ret++;\n    if (!compare(d,p,ld)) search(t->l, !d, ld, ru, out);\n    if (!compare(d,ru,p)) search(t->r, !d, ld, ru, out);\n  }\n};\n\nkdtree tree;\npoint out[5010];\nsigned main(void)\n{\n  int n, m;\n  cin >> n >> m;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    tree.insert({x, y});\n  }\n  REP(i, m) {\n    double sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    ret = 0;\n    tree.search({sx, sy}, {gx, gy}, out);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvoid quickSort_ascend(vector<int>& a, vector<int>& b, int l, int r) {\n\tif (l < r) {\n\t\tint w = a[(l+r)/2];\n\t\tint i = l, j = r, temp;\n\t\twhile (i < j) {\n\t\t\twhile (a[i] < w) i++;\n\t\t\twhile (a[j] > w) j--;\n\t\t\tif (i <= j) {\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = a[j]; a[j] = temp;\n\t\t\t\ttemp = b[i];\n\t\t\t\tb[i] = b[j]; b[j] = temp;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t}\n\t\tquickSort_ascend(a, b, l, j);\n\t\tquickSort_ascend(a, b, i, r);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n; cin >> m;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\tcin >> y[i];\n\t}\n\n\tquickSort_ascend(x, y, 0, n-1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1; cin >> y1; cin >> x2; cin >> y2;\n\t\tint l = lower_bound(x.begin(), x.end(), x1)-x.begin();\n\t\tint u = upper_bound(x.begin(), x.end(), x2)-x.begin();\n\t\tvector<int> par(y);\n\t\tsort(par.begin()+l, par.begin()+u);\n\t\tcout << upper_bound(par.begin()+l, par.begin()+u, y2) - lower_bound(par.begin()+l, par.begin()+u, y1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint num[5001][5001];\nint sum[5001][5001];\n\nint main() {\n\tmemset(num, 0, sizeof(num));\n\tmemset(sum, 0, sizeof(num));\n\tint N, M; cin >> N >> M;\n\tvector<pair<int, int>>tres;\n\tvector<int>xs, ys;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\ttres.push_back(make_pair(x, y));\n\t\txs.push_back(x);\n\t\tys.push_back(y);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n\tsort(ys.begin(), ys.end());\n\tys.resize(unique(ys.begin(), ys.end()) - ys.begin());\n\tfor (int i = 0; i < N; ++i) {\n\t\ttres[i].first = lower_bound(xs.begin(), xs.end(), tres[i].first) - xs.begin();\n\t\ttres[i].second = lower_bound(ys.begin(), ys.end(), tres[i].second) - ys.begin();\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tnum[tres[i].first][tres[i].second]++;\n\t}\n\tfor (int i = 0; i < 5000; ++i) {\n\t\tfor (int j = 0; j < 5000; ++j) {\n\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + num[i][j];\n\t\t}\n\t}\n\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = lower_bound(xs.begin(), xs.end(), x1) - xs.begin();\n\t\tx2 = upper_bound(xs.begin(), xs.end(), x2) - xs.begin();\n\t\ty1 = lower_bound(ys.begin(), ys.end(), y1) - ys.begin();\n\t\ty2 = upper_bound(ys.begin(), ys.end(), y2) - ys.begin();\n\t\tint ans = sum[x2][y2] - sum[x2][y1] - sum[x1][y2] + sum[x1][y1];\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m; cin >> n >> m;\n\tint tx[5000]; int ty[5000];\n\tint s[500000][4];\n\tvector<int> xs; vector<int>ys;\n\trep(i, n) {\n\t\tcin >> tx[i] >> ty[i];\n\t\txs.push_back(tx[i]);\n\t\tys.push_back(ty[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\trep(i, m) {\n\t\trep(j, 4) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t\ts[i][0] = lower_bound(xs.begin(), xs.end(), s[i][0]) - xs.begin();\n\t\ts[i][1] = lower_bound(ys.begin(), ys.end(), s[i][1]) - ys.begin();\n\t\ts[i][2] = upper_bound(xs.begin(), xs.end(), s[i][2]) - xs.begin(); s[i][2]--;\n\t\ts[i][3] = upper_bound(ys.begin(), ys.end(), s[i][3]) - ys.begin(); s[i][3]--;\n\t}\n\trep(i, n) {\n\t\ttx[i] = find(xs.begin(), xs.end(), tx[i]) - xs.begin();\n\t\tty[i] = find(ys.begin(), ys.end(), ty[i]) - ys.begin();\n\t}\n\tint com[5000][5000] = {};\n\trep(i, n) {\n\t\tcom[tx[i]][ty[i]]++;\n\t}\n\tint dp[5000][5000] = {};\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[0][0] = com[0][0];\n\t\t\t}\n\t\t\telse if (i == 0) {\n\t\t\t\tdp[0][j] = dp[0][j - 1] + com[0][j];\n\t\t\t}\n\t\t\telse if (j == 0) {\n\t\t\t\tdp[i][0] = dp[i - 1][0] + com[i][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] = dp[i - 1][j] + dp[i][j - 1] + com[i][j] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint sx = s[i][0]; int sy = s[i][1]; int gx = s[i][2]; int gy = s[i][3];\n\t\tint cnt;\n\t\tif (sx > 0 && sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy] - dp[gx][sy - 1] + dp[sx - 1][sy - 1];\n\t\t}\n\t\telse if (sx > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy];\n\t\t}\n\t\telse if (sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[gx][sy - 1];\n\t\t}\n\t\telse {\n\t\t\tcnt = dp[gx][gy];\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<P> v(N);\n    for (int i = 0; i < N; i++) {\n        cin >> v[i].first >> v[i].second;\n    }\n\n    sort(v.begin(), v.end());\n\n    int len = sqrt(N);\n    vector<vector<P> > m((N + len - 1) / len), n((N + len - 1) / len);\n\n    for (int i = 0; i < N; i++) {\n        m[i / len].push_back(P(v[i].second, v[i].first));\n        n[i / len].push_back(v[i]);\n    }\n\n    for (auto& i : m) {\n        sort(i.begin(), i.end());\n    }\n\n    while (M--) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n\n        int ans = 0;\n        for (int i = 0; i < m.size(); i++) {\n            int n_first = n[i][0].first;\n            int n_last = n[i][n[i].size()-1].first;\n            if ((sx <= n_first && n_first <= gx) && (sx <= n_last && n_last <= gx)) {\n                int low = lower_bound(m[i].begin(), m[i].end(), P(sy, -INF)) - m[i].begin();\n                int up = upper_bound(m[i].begin(), m[i].end(), P(gy, INF)) - m[i].begin();\n                ans += up - low;\n            } else {\n                if ((n_first <= sx && sx <= n_last) || (n_first <= gx && gx <= n_last)) {\n                    int low = lower_bound(n[i].begin(), n[i].end(), P(sx,sy)) - n[i].begin();\n                    int up = upper_bound(n[i].begin(), n[i].end(), P(gx,gy)) - n[i].begin();\n                    for (low; low <= up && low < n[i].size(); low++) {\n                        if (\n                            sx <= n[i][low].first && n[i][low].first <= gx\n                            && sy <= n[i][low].second && n[i][low].second <= gy\n                            ) ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint n, m;\nint x[10000], y[10000];\nint a, b, c, d, sum;\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i] >> y[i];\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tcin >> a >> b >> c >> d;\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a <= x[j] && x[j] <= c && b <= y[j] && y[j] <= d) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <algorithm>\n#include <limits.h>\n#include <map>\n#include <set>\n\nusing namespace std;\nconst int ninf = -(1000000000 + 1);\n\n\nint solve(void);\nint getTreasureNum( vector<vector<int>> &clist, vector<vector<int>> &mp, vector<vector<int>> &orig, vector<map<int,int>>&trans);\nint getSmallerID(vector<int> &list,  int target);\nint getSmallerID(vector<vector<int>> &orig, int &x, int &y, int target_x, int target_y);\n\nint main(void) {\n\n\t//FILE *fpin = freopen(\"data.txt\", \"r\", stdin);\n\twhile (solve());\n\treturn 0;\n\n}\n\nint solve(void) {\n\n\tint n, m;\n\tcin >> n >> m;\n\n\t/*\n\t\t?´?????????¨??§?¨???§???\n\t*/\n\n\tvector<vector<int>> clist(2);\n\tvector<pair<int, int>> plist(n);\n\tvector<vector<int>> mp,orig;\n\tvector<map<int, int>> trans(2);\n\t/*\n\t\tinput\n\t*/\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> plist[i].first >> plist[i].second;\n\t\tclist[1].push_back(plist[i].first);\n\t\tclist[0].push_back(plist[i].second);\n\t}\n\n\tfor (int i = 0; i < 2; i++) {\n\t\tclist[i].push_back(ninf);\n\t\tsort(clist[i].begin(), clist[i].end());\n\t\tclist[i].erase(unique(clist[i].begin(), clist[i].end()), clist[i].end());\n\t\tfor (int j = 0; j < clist[i].size(); j++) {\n\t\t\ttrans[i][clist[i][j]] = j;\n\t\t}\n\t}\n\tmp = vector<vector<int>>(clist[0].size(), vector<int>(clist[1].size(), 0));\n\n\tfor (int i = 0; i < n; i++)\n\t\tmp[trans[0][plist[i].second]][trans[1][plist[i].first]] ++;\n\torig = mp;\n\n\tfor (int x = 0; x < mp[0].size(); x++) {\n\t\tfor (int y = 0; y + 1 < mp.size(); y++) {\n\t\t\tmp[y + 1][x] = mp[y + 1][x] + mp[y][x];\n\t\t}\n\t}\n\n\tfor (int y = 0; y < mp.size(); y++) {\n\t\tfor (int x = 0; x + 1 < mp[0].size();x++) {\n\t\t\tmp[y][x + 1] = mp[y][x + 1] + mp[y][x];\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++)\n\t\tcout << getTreasureNum(clist, mp, orig, trans) << endl;\n\n\treturn 0;\n}\n\nint getTreasureNum(vector<vector<int>>& clist, vector<vector<int>>& mp, vector<vector<int>>& orig, vector<map<int, int>>& trans)\n{\n\tint x1, x2, y1, y2;\n\tcin >> x1 >> y1 >> x2 >> y2;\n\n\tif (x2 < clist[1][0] || x1 > clist[1][clist[1].size() - 1] || y2 < clist[0][0] || y1 > clist[0][clist[0].size() - 1]) { return 0; }\n\t\n\tif( trans[1].find(x1) == trans[1].end() )\n\t\tx1 = min(getSmallerID(clist[1], x1) + 1, (int)clist[1].size()-1);\n\telse\n\t\tx1 = getSmallerID(clist[1], x1);\n\n\tx2 = getSmallerID(clist[1], x2);\n\n\tif (trans[0].find(y1) == trans[0].end())\n\t\ty1 = min(getSmallerID(clist[0], y1) + 1, (int)clist[0].size() - 1);\n\telse\n\t\ty1 = getSmallerID(clist[0], y1);\n\n\ty2 = getSmallerID(clist[0], y2);\n\t\n\tx1--;\n\ty1--;\n\treturn mp[y2][x2] - mp[y1][x2] - mp[y2][x1] + mp[y1][x1];\n\t\n}\n\n\nint getSmallerID(vector<int>& list, int target)\n{\n\tint low = 0;\n\tint high = list.size();\n\tint mid = 0;\n\n\twhile (abs(low - high) > 1) {\n\t\tmid = (low + high) / 2;\n\t\tif (list[mid] <= target) {\n\t\t\tlow = mid;\n\t\t}\n\t\telse {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\tmid = (high + low) / 2;\n\treturn mid;\n}\n\nint getSmallerID(vector<vector<int>>& orig, int & x, int & y, int target_x, int target_y)\n{\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//27\n//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n  }\n  for(int i=0;i<m;i++){\n    int r=0;\n    int xi[2],yi[2];\n    cin>>xi[0]>>yi[0]>>xi[1]>>yi[1];\n    for(int j=0;j<n;j++){\n      r+=xi[0]<=x[j]&&x[j]<=xi[1]&&yi[0]<=y[j]&&y[j]<=yi[1];\n    }\n    cout<<r<<endl;\n  }\n  return 0;\n}\n\nint main2(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size(),vector<int>(xp.size()));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()]++;\n  }\n  vector<vector<int> > ag(yp.size()+1,vector<int>(xp.size()+1));\n  for(int i=0;i<yp.size();i++){\n    for(int j=0;j<xp.size();j++){\n      ag[i+1][j+1]=ag[i][j+1]+ag[i+1][j]-ag[i][j]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=upper_bound(xp.begin(),xp.end(),xh)-xp.begin();\n    yyh=upper_bound(yp.begin(),yp.end(),yh)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[xxl][yyl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define EPS (1e-10)\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\t//cin >> x >> y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\twhile( 1 ){\n\t\t\tif( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\tif( (*it).first > x2 ) it = upper_bound(treasure.begin(), treasure.end(),mp(-INF,(*it).second+1));\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(c) (c).begin(), (c).end()\n#define loop(i,a,b) for(int i=a; i<int(b); i++)\n#define rep(i,b) loop(i,0,b)\ntemplate<typename T>\ninline void compless(vector<T> & c){\n    sort(all(c));\n    c.erase(unique(all(c)),c.end());\n}\ntemplate<typename T>\ninline size_t idx(T i, vector<T> const& c){\n    return lower_bound(all(c),i) - c.begin();\n}\n\nint n,m;\nint xs[5000], ys[5000];\nint sum[5100][5100]={};\n\nint main(){\n    scanf(\"%d%d\",&n,&m);\n    vector<int> x(n),y(n);\n    rep(i,n){\n        scanf(\"%d%d\",xs+i,ys+i);\n        x[i]=xs[i];\n        y[i]=ys[i];\n    }\n    compless(x);\n    compless(y);\n    rep(i,n){\n        int fx=idx(xs[i],x);\n        int fy=idx(ys[i],y);\n        sum[fy+1][fx+1]++;\n    }\n    rep(i,y.size())rep(j,x.size()){\n        sum[i+1][j+1]+=sum[i+1][j]+sum[i][j+1]-sum[i][j];\n    }\n\n    rep(i,m){\n        int lx,ly,rx,ry;\n        scanf(\"%d%d%d%d\",&lx,&ly,&rx,&ry);\n        lx = idx(lx,x);\n        rx = idx(rx+1,x);\n        ly = idx(ly,y);\n        ry = idx(ry+1,y);\n        printf(\"%d\\n\",sum[ry][rx]-sum[ry][lx]-sum[ly][rx]+sum[ly][lx]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint d[5010][5010];\n\nint f(int x1, int y1, int x2, int y2){\n\treturn d[x2][y2]-d[x1][y2]-d[x2][y1]+d[x1][y1];\n}\n\nint main(){\n\tint n, m;\n\tcin>>n>>m;\n\tmap<int, int> mx, my;\n\tvector<pii> v(n), s(m), t(m);\n\trep(i, n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t\tmx[v[i].fi]++;\n\t\tmy[v[i].se]++;\n\t}\n\trep(i, m){\n\t\tcin>>s[i].fi>>s[i].se>>t[i].fi>>t[i].se;\n\t\tmx[s[i].fi]++;\n\t\tmy[s[i].se]++;\n\t\tmx[t[i].fi]++;\n\t\tmy[t[i].se]++;\n\t}\n\tint cnt = 0;\n\tfor(auto& p : mx) p.se = ++cnt;\n\tcnt = 0;\n\tfor(auto& p : my) p.se = ++cnt;\n\n\trep(i, n) d[mx[v[i].fi]][my[v[i].se]]++;\n\n\t// rep(i, 20){\n\t// \trep(j, 20) printf(\"%3d\", d[i][j]);\n\t// \tprintf(\"\\n\");\n\t// }\n\n\tfor(int i = 0; i < 5010; i++) {\n\t\tfor(int j = 0; j < 5009; j++){\n\t\t\td[i][j+1] += d[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < 5009; i++) {\n\t\tfor(int j = 0; j < 5010; j++){\n\t\t\td[i+1][j] += d[i][j];\n\t\t}\n\t}\n\trep(i, m){\n\t\tcout<<f(mx[s[i].fi]-1, my[s[i].se]-1, mx[t[i].fi], my[t[i].se])<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <cstdio>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  set<int> X_, Y_;\n  vector< pair<int,int> > x_y(n);\n  int x, y;\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    X_.insert(x);\n    Y_.insert(y);\n    x_y[i] = make_pair(x,y);\n  }\n  vector<int> X, Y;\n  for(set<int>::iterator itr = X_.begin(); itr != X_.end(); ++itr)\n    X.push_back(*itr);\n  for(set<int>::iterator itr = Y_.begin(); itr != Y_.end(); ++itr)\n    Y.push_back(*itr);\n\n  map<int,int> M_x, M_y;\n  for(int i = 0; i < X.size(); ++i) M_x[X[i]] = i;\n  for(int i = 0; i < Y.size(); ++i) M_y[Y[i]] = i;\n  int h = X.size(), w = Y.size();\n  vector< vector<int> >  acum(h+2,vector<int>(w+2,0));\n  for(int i = 0; i < n; ++i){\n    int x = x_y[i].first, y = x_y[i].second;\n    ++acum[M_x[x]+1][M_y[y]+1];\n  }\n  \n  \n  for(int i = 1; i <= h+1; ++i){\n    //cout << acum[i][0] << \" | \";\n    /*\n    for(int j = 1; j <= n; ++j){\n      acum[i][j] += acum[i][j-1] + acum[i-1][j] - acum[i-1][j-1];\n      cout << acum[i][j] << \" | \";\n    }\n    */\n    for(int j = 1; j <= w+1; ++j){\n      acum[i][j] += acum[i][j-1];\n    }\n    for(int j = 1; j <= w+1; ++j){\n      acum[i][j] += acum[i-1][j];\n      //cout << acum[i][j] << \" | \";      \n    }\n    //cout << endl;\n  }\n  int x_1, x_2, y_1, y_2;\n  for(int i = 0; i < m; ++i){\n    cin >> x_1 >> y_1 >> x_2 >> y_2;\n    //--x_2;--y_2;\n    int x_1_ = lower_bound(X.begin(),X.end(),x_1)-X.begin(),\n      y_1_ = lower_bound(Y.begin(),Y.end(),y_1)-Y.begin(),\n      x_2_ = upper_bound(X.begin(),X.end(),x_2)-X.begin(),\n      y_2_ = upper_bound(Y.begin(),Y.end(),y_2)-Y.begin();\n    //++x_2_;++y_2_;\n    cout << acum[x_2_][y_2_] - acum[x_2_][y_1_] - acum[x_1_][y_2_] + acum[x_1_][y_1_] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n\nint tr_2d[5002][5002];\n\nmap<int,int> zip_x,zip_y;\nint unzip_x[5000],unzip_y[5000];\n\n\n\npair<int,int> compress(vector<int> &x, vector<int> &y){\n// zipで座標->index\n// unzipでindex->座標\n// x,yは書き換えられるので注意\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  rep(i,x.size()){\n    zip_x[x[i]] = i;\n    unzip_x[i] = x[i];\n  }\n  rep(i,y.size()){\n    zip_y[y[i]] = i;\n    unzip_y[i] = y[i];\n  }\n  return make_pair(x.size(),y.size());\n}\n\nvoid Imos2D(int n){\n  rep(i,n+1)rep(j,n)tr_2d[i][j+1]+=tr_2d[i][j];\n  rep(i,n)rep(j,n+1)tr_2d[i+1][j]+=tr_2d[i][j];\n}\n\nint sum(int xl,int xr,int yd,int yu){\n  return tr_2d[xr][yu]-tr_2d[xl][yu]+tr_2d[xl][yd]-tr_2d[xr][yd];\n}\n\nsigned main(){\n\n  int n,m;\n  cin>>n>>m;\n  vector<int> tr_x(n),tr_x2(n),tr_y(n),tr_y2(n);\n  rep(i,n+2){\n    rep(j,n+2){\n      tr_2d[i][j]=0;\n    }\n  }\n\n  rep(i,n){\n    int x,y;\n    cin>>x>>y;\n    tr_x[i] = x;\n    tr_x2[i] = x;\n    tr_y[i] = y;\n    tr_y2[i] = y;\n  }\n  //座圧\n  pair<int,int> size=compress(tr_x2,tr_y2);\n  // cout<<size.first<<size.second<<endl;\n  rep(i,n){\n    int id_x = zip_x[tr_x[i]];\n    int id_y = zip_y[tr_y[i]];\n    tr_2d[id_x+1][id_y+1]++;\n  }\n  // rep(i,n){\n  //   rep(j,n-1){\n  //     cout<<tr_2d[i][j]<<\" \";\n  //   }\n  //   cout<<tr_2d[i][n-1]<<endl;\n  // }\n\n  //2次元累積和\n  Imos2D(n);\n  // rep(i,n+1){\n  //   rep(j,n){\n  //     cout<<s[i][j]<<\" \";\n  //   }\n  //   cout<<s[i][n]<<endl;\n  // }\n\n  rep(i,m){\n    int xl,xr,yd,yu;\n    cin>>xl>>yd>>xr>>yu;\n    auto ixl = lower_bound(unzip_x,unzip_x+size.first,xl)-unzip_x;\n    auto ixr = upper_bound(unzip_x,unzip_x+size.first,xr)-unzip_x-1;\n    auto iyd = lower_bound(unzip_y,unzip_y+size.second,yd)-unzip_y;\n    auto iyu = upper_bound(unzip_y,unzip_y+size.second,yu)-unzip_y-1;\n    // cout << xl<<\" \"<<xr<<\" : \"<<ixl<< \" \" <<ixr<<endl;\n    // cout << yd<<\" \"<<yu<<\" : \"<<iyd<< \" \" <<iyu<<endl;\n    cout << sum(ixl,ixr+1,iyd,iyu+1)<<endl;\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 2000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[55555], sy[55555];\nint tx[55555], ty[55555];\nint vx[5555];\nint vy[5555];\nint maze[5555][5555];\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n\n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);\n    y.pb(vy[i]);\n  }\n  x.pb(INF);\n  y.pb(INF);\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin();\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin();\n  }\n  rep(i, n) maze[vx[i]][vy[i]] += 1;\n  rep(i, n) rep(j, n - 1) maze[i][j + 1] += maze[i][j];\n  rep(i, n - 1) rep(j, n) maze[i + 1][j] += maze[i][j];\n\n  cerr << m << endl;\n  \n  rep(i, m){\n    int ret = 0;\n    int lx = upper_bound(ALL(x), tx[i]) - x.begin() - 1;\n    int ly = upper_bound(ALL(y), ty[i]) - y.begin() - 1;\n    int rx = lower_bound(ALL(x), sx[i]) - x.begin();\n    int ry = lower_bound(ALL(y), sy[i]) - y.begin();\n    \n    ret += maze[lx][ly];\n    ret += maze[rx - 1][ry - 1];\n    ret -= maze[rx - 1][ly];\n    ret -= maze[lx][ry - 1];\n\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nusing P = pair<int, int>;\n\nint idx(vector<int> const& v, int i) {\n    return lower_bound(v.begin(), v.end(), i) - v.begin();\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<vector<int>> sum(n+2, vector<int>(n+2));\n    vector<int> xs(n), ys(n);\n    vector<int> x(n), y(n);\n    for(int i=0; i<n; ++i) {\n        cin >> x[i] >> y[i];\n        xs[i] = x[i];\n        ys[i] = y[i];\n    }\n    sort(x.begin(), x.end());\n    x.erase(unique(x.begin(), x.end()), x.end());\n    sort(y.begin(), y.end());\n    y.erase(unique(y.begin(), y.end()), y.end());\n\n    for(int i=0; i<n; ++i) {\n        int tx = idx(x, xs[i]);\n        int ty = idx(y, ys[i]);\n        ++sum[ty+1][tx+1];\n    }\n    for(int i=0; i<y.size(); ++i) {\n        for(int j=0; j<x.size(); ++j) {\n            sum[i+1][j+1] += sum[i+1][j] + sum[i][j+1] - sum[i][j];\n        }\n    }\n\n    for(int i=0; i<m; ++i) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = idx(x, x1);\n        y1 = idx(y, y1);\n        x2 = idx(x, x2+1);\n        y2 = idx(y, y2+1);\n        cout << sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1] << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define F first\n#define S second\nconst int LIM = 1e9+5;\n\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<P> V;\n\nvoid input(){\n  cin >> n >> m;\n  V.resize(n);\n  for(int i = 0; i < n; i++) cin >> V[i].F >> V[i].S;\n}\n\nvoid solve(){\n  sort(V.begin(),V.end());\n\n  for(int i = 0; i < m; i++){\n    int l,r,d,u;\n    scanf(\"%d %d %d %d\",&l,&d,&r,&u);\n \n    int ans = 0;\n    vector<P>::iterator ite = lower_bound(V.begin(),V.end(),P(l,-LIM));\n    \n    while(ite < V.end()){\n      if(ite->F > r) break;\n      if(d <= ite->S && ite->S <= u) ans++;\n      ite++;  \n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<int> X;\n    vector<int> Y;\n    vector<int> x(n);\n    vector<int> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        int x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    int h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    \n\n    //cout << h << \" \" << w << endl;\n    vector<vector<int> > imos(h + 2, vector<int> (w + 2, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i] + 1][x[i] + 1]++;\n    }\n\n    \n\n    for(int j = 0; j <= w + 1; j++){\n        for(int i = 1; i <= h + 1; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h + 1; i++){\n        for(int j = 1; j <= w + 1; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    /*for(int i = 0; i < X.size(); i++){\n        cout << X[i] << endl;\n    }*/\n    \n    for(int i = 0; i < m; i++){\n        int x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin() + 1;\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin();\n\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin() + 1;\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin();\n        //if(x2 == -1) x2 = 0;\n        //if(y2 == -1) y2 = 0;\n        //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        int sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = (a);i < (b);i++)\n#define rep(i,n) For(i,0,n)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst int INF = 1e9;\n\nstruct Node {\n\tint l, r;\n\tint p;\n};\n\nstruct Point {\n\tint id, y, x;\n};\n\nPoint P[5001];\nNode T[5001];\nint np;\n\nbool PX(const Point &p1, const Point &p2){ return p1.x < p2.x; }\nbool PY(const Point &p1, const Point &p2){ return p1.y < p2.y; }\n\nint makeKdTree(int l, int r, int depth){\n\n\tif (l >= r)return INF;\n\tint mid = (r + l) / 2;\n\tint t = np++;\n\tif (depth % 2){\n\t\tsort(P + l, P + r, PX);\n\t}\n\telse{\n\t\tsort(P + l, P + r, PY);\n\t}\n\n\tT[t].p = mid;\n\tT[t].l = makeKdTree(l, mid, depth + 1);\n\tT[t].r = makeKdTree(mid + 1, r, depth + 1);\n\n\treturn t;\n}\n\nint findKdTree(int v,int sy,int sx,int ty,int tx,int depth){\n\tint x = P[T[v].p].x,y = P[T[v].p].y;\n\n\tint ret = 0;\n\tif (x >= sx && y >= sy && x <= tx && y <= ty){\n\t\tret++;\n\t}\n\n\tif (depth % 2){\n\t\tif (x >= sx && T[v].l != INF)ret += findKdTree(T[v].l, sy, sx, ty, tx, depth + 1);\n\t\tif (x <= tx && T[v].r != INF)ret += findKdTree(T[v].r, sy, sx, ty, tx, depth + 1);\n\t}\n\telse{\n\t\tif (y >= sy && T[v].l != INF)ret += findKdTree(T[v].l, sy, sx, ty, tx, depth + 1);\n\t\tif (y <= ty && T[v].r != INF)ret += findKdTree(T[v].r, sy, sx, ty, tx, depth + 1);\n\t}\n\n\treturn ret;\n}\n\n\nint main(){\n\t\n\tnp = 0;\n\tint n, m;\n\tcin >> n >> m;\n\t\n\trep(i, n){\n\t\tcin >> P[i].x >> P[i].y;\n\t\tT[i].l = T[i].r = INF;\n\t}\n\n\tint root = makeKdTree(0, n, 0);\n\n\trep(i, m){\n\t\tint sx, sy, tx, ty;\n\t\tscanf(\"%d %d %d %d\", &sx, &sy, &tx, &ty);\n\t\tprintf(\"%d\\n\", findKdTree(root, sy, sx, ty, tx, 0));\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n// ret[i][j] = sum of all field in [0,i) x [0,j).\ntemplate<typename T>\nvector<vector<T>> calc_sum(const vector<vector<T>>& field){\n    int h = field.size();\n    int w = field[0].size();\n    vector<vector<T>> ret(h+1,vector<T>(w+1));\n    for(int y=1;y<=h;y++){\n        for(int x=1;x<=w;x++){\n            ret[y][x] = ret[y][x-1] + field[y-1][x-1];\n        }\n    }\n    for(int x=0;x<=w;x++){\n        for(int y=1;y<=h;y++){\n            ret[y][x] = ret[y][x] + ret[y-1][x];\n        }\n    }\n    return ret;\n}\n\n#define all(vec) vec.begin(),vec.end()\nint main(){\n    int n,m;cin >> n >> m;\n\n    vector<int> index_of_x(n),index_of_y(n);\n    for(int i=0;i<n;i++){\n        cin >> index_of_x[i] >> index_of_y[i];\n    }\n    vector<int> value_of_x = index_of_x,\n                value_of_y = index_of_y;\n\n    sort(all(value_of_x));\n    sort(all(value_of_y));\n    value_of_x.erase(unique(all(value_of_x)),value_of_x.end());\n    value_of_y.erase(unique(all(value_of_y)),value_of_y.end());\n    for(int i=0;i<n;i++){\n        index_of_x[i] = lower_bound(all(value_of_x),index_of_x[i]) - value_of_x.begin();\n        index_of_y[i] = lower_bound(all(value_of_y),index_of_y[i]) - value_of_y.begin();\n    }\n    vector<vector<int>> p(value_of_y.size(),vector<int>(value_of_x.size()));\n    for(int i=0;i<n;i++){\n        p[index_of_y[i]][index_of_x[i]] += 1;\n    }\n    auto v = calc_sum(p);\n\n    for(int i=0;i<m;i++){\n        int x1,y1,x2,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        int sx = lower_bound(all(value_of_x),x1) - value_of_x.begin();\n        int gx = upper_bound(all(value_of_x),x2) - value_of_x.begin();\n        int sy = lower_bound(all(value_of_y),y1) - value_of_y.begin();\n        int gy = upper_bound(all(value_of_y),y2) - value_of_y.begin();\n\n        int ans = v[gy][gx] - v[sy][gx] - v[gy][sx] + v[sy][sx];\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define X first\n#define Y second\n\nusing namespace std;\n\nint n, m;\nvector<int> vx, vy;\nint tx[5005], ty[5005], unzipx[5005], unzipy[5005], imos[5005][5005];\nmap<int, int> zipx, zipy;\npair< pair<int,int>, pair<int,int> > p[500005];\n\nint main() {\n  cin>>n>>m;\n  REP(i,0,n){\n    cin>>tx[i]>>ty[i];\n    vx.push_back(tx[i]);\n    vy.push_back(ty[i]);\n  }\n  REP(i,0,m){\n    cin>>p[i].F.X>>p[i].F.Y>>p[i].S.X>>p[i].S.Y;\n  }\n\n  //compression\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  vx.erase(unique(vx.begin(), vx.end()), vx.end());\n  vy.erase(unique(vy.begin(), vy.end()), vy.end());\n  REP(i,0,vx.size()){\n    zipx[vx[i]] = i;\n    unzipx[i] = vx[i];\n  }\n  REP(i,0,vy.size()){\n    zipy[vy[i]] = i;\n    unzipy[i] = vy[i];\n  }\n\n  //Initializing imos array\n  REP(i,0,5005)REP(j,0,5005) imos[i][j] = 0;\n  REP(i,0,n){\n    imos[zipy[ty[i]]][zipx[tx[i]]]++;\n  }\n  //creating imos array\n  REP(i,0,vy.size()){\n    REP(j,1,vx.size()){\n      imos[i][j] += imos[i][j-1];\n    }\n  }\n  REP(j,0,vx.size()){\n    REP(i,1,vy.size()){\n      imos[i][j] += imos[i-1][j];\n    }\n  }\n\n  REP(i,0,m){\n    vector<int>::iterator a1x = lower_bound(vx.begin(),vx.end(),p[i].F.X),\n      a1y = lower_bound(vy.begin(),vy.end(),p[i].F.Y),\n      a2x = upper_bound(vx.begin(),vx.end(),p[i].S.X)-1,\n      a2y = upper_bound(vy.begin(),vy.end(),p[i].S.Y)-1;\n    int z1x = zipx[*a1x], z1y = zipy[*a1y], z2x = zipx[*a2x], z2y = zipy[*a2y];\n    int ans = imos[z2y][z2x];\n    if(z1y > 0) ans -= imos[z1y-1][z2x];\n    if(z1x > 0) ans -= imos[z2y][z1x-1];\n    if(z1y > 0 && z1x > 0) ans += imos[z1y-1][z1x-1];\n    //fo exception\n    if(p[i].F.Y > unzipy[vy.size()-1] || p[i].F.X > unzipx[vx.size()-1]) cout<<0<<endl;\n    else cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\nint pos1(vi v, int p) {\n\treturn lower_bound(ALL(v), p) - v.begin() - 1;\n}\n\nint pos2(vi v, int p) {\n\treturn upper_bound(ALL(v), p) - v.begin() - 1;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvi x(n), y(n);\n\tmap<pii, int> tresure;\n\tREP(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t\ttresure[pii(x[i], y[i])]++;\n\t}\n\n\tx.push_back(INT_MIN);\n\ty.push_back(INT_MIN);\n\tsort(ALL(x));\n\tsort(ALL(y));\n\tx.erase(unique(ALL(x)), x.end());\n\ty.erase(unique(ALL(y)), y.end());\n\n\tint xsize = x.size(), ysize = y.size();\n\tvvi field(ysize+1, vi(xsize+1));\n\tREP(i, ysize) {\n\t\tREP(j, xsize) {\n\t\t\tfield[i][j] = tresure[pii(x[j], y[i])];\n\t\t}\n\t}\n\tFOR(i, 1, ysize-1) {\n\t\tFOR(j, 1, xsize-1) {\n\t\t\tfield[i][j] += field[i][j - 1];\n\t\t}\n\t}\n\tFOR(i, 1, ysize-1) {\n\t\tFOR(j, 1, xsize-1) {\n\t\t\tfield[i][j] += field[i - 1][j];\n\t\t}\n\t}\n\n\tREP(i, m) {\n\t\tint xm1, ym1, xm2, ym2;\n\t\tcin >> xm1 >> ym1 >> xm2 >> ym2;\n\t\tint xp1 = pos1(x, xm1), yp1 = pos1(y, ym1), xp2 = pos2(x, xm2), yp2 = pos2(y, ym2);\n\t\tcout << field[yp2][xp2] - field[yp1][xp2] - field[yp2][xp1] + field[yp1][xp1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<iomanip>\n\nusing namespace std;\n\nconst int INF = 1e9+100;\n\nsigned main(){\n\t  cin.tie(0);\n\t  ios::sync_with_stdio(false);\n\n\t  vector<vector<int> > field;\n\t  vector<pair<int,int> > in;\n\t  vector<int> x, y;\n\t  int n, m, a, b;\n\t  int x1, x2, y1, y2;\n\n\t  cin>>n>>m;\n\t  \n\t  for(int i = 0; i < n; i++){\n\t\tcin>>a>>b;\n\t\tx.push_back(a);\n\t\ty.push_back(b);\n\t\tin.push_back(make_pair(b,a));\n\t  }\n\n\t  x.push_back(INF);\n\t  x.push_back(-INF);\n\t  y.push_back(INF);\n\t  y.push_back(-INF);\n\t  \n\t  sort(x.begin(), x.end());\n\t  sort(y.begin(), y.end());\n\t  sort(in.begin(), in.end());\n\t  \n\t  x.erase(unique(x.begin(), x.end()), x.end());\n\t  y.erase(unique(y.begin(), y.end()), y.end());\n\t  \n\n\t  field.resize(y.size()+4, vector<int>(x.size()+4, 0));\n\t  \n\t  for(int i = 0; i < in.size(); i++){\n\t\tint xkey = in[i].second, ykey = in[i].first;\n\t\t\n\t\tint tx = lower_bound(x.begin(), x.end(), xkey) - x.begin();\n\t\tint ty = lower_bound(y.begin(), y.end(), ykey) - y.begin();\n\n\t\tfield[ty][tx]++;\n\t  }\n\t \n\t  for(int i = 0; i < y.size(); i++){\n\t\tfor(int j = 0; j < x.size(); j++){\n\t\t  field[i+1][j] += field[i][j];\n\t\t}\n\t  }\n\n\t  for(int j = 0; j < x.size(); j++){\n\t\tfor(int i = 0; i < y.size(); i++){\n\t\t  field[i][j+1] += field[i][j];\n\t\t}\n\t  }\n\t  \n\t  for(int i = 0; i < m; i++){\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\t\n\t\tint tx1l = lower_bound(x.begin(), x.end(), x1) - x.begin();\n\t\tint ty1l = lower_bound(y.begin(), y.end(), y1) - y.begin();\n\t\tint tx2u = upper_bound(x.begin(), x.end(), x2) - x.begin();\n\t\tint ty2u = upper_bound(y.begin(), y.end(), y2) - y.begin();\n\t\t\n\t\tint ans = field[ty2u-1][tx2u-1] + field[ty1l-1][tx1l-1] - field[ty2u-1][tx1l-1] - field[ty1l-1][tx2u-1];\n\t\t\n\t\tcout<<ans<<endl;\n\t  }\n\t  \n\t  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main() {\n\tcin.tie(0); ios::sync_with_stdio(false);\n\tint n, m; cin >> n >> m;\n\tvector<int> treasure_x(n), x(n);\n\tvector<int> treasure_y(n), y(n);\n\n\tfor (int i = 0; i < n;i++) {\n\t\tcin >> treasure_x[i] >> treasure_y[i];\n\t\tx[i] = treasure_x[i]; y[i] = treasure_y[i];\n\t}\n\n\tsort(x.begin(), x.end()); sort(y.begin(), y.end());\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\n\tvector<vector<int>> dp(n + 2, vector<int>(n + 2, 0));\n\tfor (int i = 0; i < n;i++) {\n\t\tint xind = lower_bound(x.begin(), x.end(), treasure_x[i]) - x.begin();\n\t\tint yind = lower_bound(y.begin(), y.end(), treasure_y[i]) - y.begin();\n\t\tdp[xind+1][yind+1]++;\n\t}\n\n\tfor (int i = 0; i < n;i++) {\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tdp[i + 1][j + 1] += dp[i][j + 1] + dp[i + 1][j] - dp[i][j];\n\t\t}\n\t}\n\n\n\tfor (int i = 0; i < m;i++) {\n\t\tint ans = 0;\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tint x1ind = lower_bound(x.begin(), x.end(), x1) - x.begin();\n\t\tint y1ind = lower_bound(y.begin(), y.end(), y1) - y.begin();\n\t\tint x2ind = lower_bound(x.begin(), x.end(), x2+1) - x.begin();\n\t\tint y2ind = lower_bound(y.begin(), y.end(), y2+1) - y.begin();\n\n\t\tcout << dp[x2ind][y2ind] - dp[x2ind][y1ind] - dp[x1ind][y2ind] + dp[x1ind][y1ind] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nlong long n,m,x[5000],y[5000],xa1,xa2,ya1,ya2;\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\tfor(int i=0;i<m;i++){\n\t\tcin>>xa1>>ya1>>xa2>>ya2;\n\t\tint count=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(x[j]>=xa1&&x[j]<=xa2&&y[j]>=ya1&&y[j]<=ya2)\n\t\t\t\tcount++;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 250;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(cin >> n >> m) {\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].first >> ps[i].second;\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int k = 0; k < BNUM; ++k) {\n      sort(bucket[k].begin(), bucket[k].end());\n    }\n    while(m--) {\n      int a, b, c, d; cin >> a >> b >> c >> d;\n      int l = lower_bound(x, x+n, a) - x;\n      int r = upper_bound(x, x+n, c) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (b <= y[l] && y[l] <= d);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (b <= y[r] && y[r] <= d);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), d)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), c);\n        l += B;\n      }\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct Point{double x,y;};\ndouble dist(Point a,Point b) {return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        vector<Point> p(N);\n        int maxcnt=1;\n        rep(i,N)cin>>p[i].x>>p[i].y;\n        rep(i,N){\n            for(int j=i+1;j<N;j++){\n                double d = dist(p[i],p[j]);\n                if(d>2.0)continue;\n                int sign[]={-1,1};\n                rep(s,2){\n                    Point C;\n                    C.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    C.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    int cnt=0;\n                    rep(k,N) cnt += (pow(C.x-p[k].x,2) + pow(C.y-p[k].y,2) <= 1.0);\n                    if(maxcnt<cnt)maxcnt=cnt;\n                }\n            }\n        }\n        cout<<maxcnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nint n, m;\nint nx, ny;\nint x[5001], y[5001];\nint index_x[5001], index_y[5001];\nint sum[5001][5001];\n\nint main(){\n\n  cin >> n >> m;\n  rep(i,n) cin >> x[i] >> y[i];\n  memset(sum, 0, sizeof(sum));\n\n  rep(i,n) index_x[i] = x[i];\n  rep(i,n) index_y[i] = y[i];\n\n  sort(index_x, index_x+n);\n  sort(index_y, index_y+n);\n  nx = unique(index_x, index_x+n) - index_x;\n  ny = unique(index_y, index_y+n) - index_y;\n\n  rep(i,n){\n    int px = (lower_bound(index_x, index_x+nx, x[i]) - index_x) + 1;\n    int py = (lower_bound(index_y, index_y+ny, y[i]) - index_y) + 1;\n    sum[px][py] += 1;\n  }\n  rep(i,nx) rep(j,ny)\n    sum[i+1][j+1] += (sum[i+1][j] + sum[i][j+1] - sum[i][j]);\n\n  rep(i,m){\n    int lx, ly, rx, ry;\n    cin >> lx >> ly >> rx >> ry;\n\n    lx = lower_bound(index_x, index_x+nx, lx) - index_x;\n    ly = lower_bound(index_y, index_y+ny, ly) - index_y;\n    rx = lower_bound(index_x, index_x+nx, rx+1) - index_x;\n    ry = lower_bound(index_y, index_y+ny, ry+1) - index_y;\n\n    cout << (sum[rx][ry] - sum[lx][ry] - sum[rx][ly] + sum[lx][ly]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<30)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nmap<int,int>zipX,zipY;\nint unzipX[5005], unzipY[5005];\nint cum[5005][5005];\nint N,M;\nvector<int> X, Y;\n\nint compressX(vector<int>&x){\n  sort(x.begin(), x.end());\n  x.erase(unique(x.begin(), x.end()), x.end());\n  rep(i,x.size()){\n    zipX[x[i]] = i;\n    unzipX[i] = x[i];\n  }\n  return x.size();\n}\nint compressY(vector<int>&y){\n  sort(y.begin(), y.end());\n  y.erase(unique(y.begin(), y.end()), y.end());\n  rep(i,y.size()){\n    zipY[y[i]] = i;\n    unzipY[i] = y[i];\n  }\n  return y.size();\n}\n\nint main(){\n  scanf(\"%d%d\", &N,&M);\n  X.resize(N); Y.resize(N);\n  rep(i,N) scanf(\"%d%d\", &X[i], &Y[i]);\n  vector<int>x,y; x = X; y = Y;\n  int W = compressX(x);\n  int H = compressY(y);\n  memset(cum, 0,sizeof(cum));\n  rep(i,N) cum[zipX[X[i]]+1][zipY[Y[i]]+1]++;\n  zipX[-INF] = 0; zipY[INF] = 0;\n  zipX[INF] = W; zipY[INF] = H;\n  rep(i,W+1) rep(j,H) cum[i][j+1] += cum[i][j];\n  rep(j,H+1) rep(i,W) cum[i+1][j] += cum[i][j];\n  /*  rep(i,W+1){\n    rep(j,H+1) cout << cum[i][j] << \" \" ; cout << endl;\n    }*/\n  rep(i,M){\n    int x1, x2, y1, y2;\n    scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n    P a = *zipX.lower_bound(x1);\n    P b = *zipY.lower_bound(y1);\n    P c = *zipX.upper_bound(x2);\n    P d = *zipY.upper_bound(y2);\n    //    cout << a.second << \" \" << b.second << \" \" << c.second << \" \" <<d.second << \" \" << cum[a.second][d.second] << endl;\n    printf(\"%d\\n\", cum[a.second][b.second]-cum[c.second][b.second]-cum[a.second][d.second]+cum[c.second][d.second]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nclass Imos{\npublic:\n    int H, W;\n    vector<vector<int>> d;\npublic:\n    //1-indexed\n    Imos(vector<vector<int>>& field){\n        H = field.size();\n        W = field[0].size();\n        d = vector<vector<int> >(H+1, vector<int>(W+1));\n        \n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                d[i+1][j+1] = d[i+1][j] + d[i][j+1] - d[i][j] + field[i][j];\n            }\n        }\n    }\n    int area(int h1, int w1, int h2, int w2){\n        //size of area s.t. [h1, h2) and [w1, w2)\n        return d[h2][w2] - d[h2][w1] - d[h1][w2] + d[h1][w1];\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    \n    int N, M; cin >> N >> M;\n    \n    vector<int> xs(N), ys(N);\n    vector<int> xps(N), yps(N);\n    \n    for(int i=0; i<N; i++){\n        scanf(\"%d %d\", &xs[i], &ys[i]);\n        xps[i] = xs[i];\n        yps[i] = ys[i];\n    }\n    \n    sort(xs.begin(), xs.end());\n    sort(ys.begin(), ys.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    \n    vector<vector<int>> d(xs.size(), vector<int>(ys.size()));\n    for(int i=0; i<N; i++){\n        d[lower_bound(xs.begin(), xs.end(), xps[i]) - xs.begin()][lower_bound(ys.begin(), ys.end(), yps[i]) - ys.begin()]++;\n    }\n    \n    Imos imos = Imos(d);\n    \n    while(M--){\n        int x1, y1, x2, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        \n        printf(\"%d\\n\", imos.area(lower_bound(xs.begin(), xs.end(), x1) - xs.begin(), lower_bound(ys.begin(), ys.end(), y1) - ys.begin(), lower_bound(ys.begin(), ys.end(), y1) - ys.begin(), upper_bound(ys.begin(), ys.end(), y2) - ys.begin()));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\n\n//21:24\nstruct Zahyou{\n\tint id;\n\tint x;\n\tint y;\n};\nstruct a{\n\tint id;\n\tint num;\n};\n//struct X{\n//\tint id;\n//\tint x;\n//};\n//struct Y{\n//\tint id;\n//\tint x;\n//};\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<Zahyou> ZaCol;\n\tvector<a>IXCol;\n\tvector<a>IYCol;\n\tvector<int>XCol;\n\tvector<int>YCol;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tZaCol.push_back({ i,x, y});\n\t\tIXCol.push_back({ i, x });\n\t\tIYCol.push_back({ i, y });\n\t\tXCol.push_back(x);\n\t\tYCol.push_back(y);\n\t}\n\tsort(IXCol.begin(), IXCol.end(), [](a a1, a a2){return a1.num < a2.num; });\n\tsort(IYCol.begin(), IYCol.end(), [](a a1, a a2){return a1.num < a2.num; });\n\tsort(XCol.begin(), XCol.end(), [](int a1, int a2){return a1 < a2; });\n\tsort(YCol.begin(), YCol.end(), [](int a1, int a2){return a1 < a2; });\n\t//sort(ZaCol.begin(), ZaCol.end(), [](Zahyou Z1, Zahyou Z2){return Z1.x == Z2.x ? Z1.y > Z2.y:Z1.x > Z2.x; });\n\t//sort(XCol.begin(), XCol.end(), [](Zahyou Z1, Zahyou Z2){return Z1.x > Z2.x; });\n\t//sort(YCol.begin(), YCol.end(), [](Zahyou Z1, Zahyou Z2){return Z1.y > Z2.y; });\n\tfor (int i = 0; i < m; ++i){\n\t\tvector<int>Selected(n, 1);\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tint ans=0;\n\t\tint a = lower_bound(XCol.begin(), XCol.end(), x2 + 1) - XCol.begin();\n\t\tint b = upper_bound(XCol.begin(), XCol.end(), x1 - 1) - XCol.begin();\n\t\tfor (int i = 0; i < b; ++i){\n\t\t\tSelected[IXCol[i].id] = 0;\n\t\t}\n\t\t\n\t\tfor (int i = a; i < n; ++i){\n\t\t\tSelected[IXCol[i].id] = 0;\n\t\t}\n\t\tint c = lower_bound(YCol.begin(), YCol.end(), y2 + 1) - YCol.begin();\n\t\tint d = upper_bound(YCol.begin(), YCol.end(), y1 - 1) - YCol.begin();\n\t\tfor (int i = 0; i < d; ++i){\n\t\t\tSelected[IYCol[i].id] = 0;\n\t\t}\n\n\t\tfor (int i = c; i < n; ++i){\n\t\t\tSelected[IYCol[i].id] = 0;\n\t\t}\n\t\t/*for (auto it = ZaCol.begin(); it != ZaCol.end(); ++it){\n\t\t\tif ((*it).x >= x1 && (*it).x <= x2 && (*it).y >= y1 && (*it).y <= y2){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}*/\n\t\t\n\t\n\t\tcout << count(Selected.begin(),Selected.end(),1)<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) { cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl; }\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//pair?????????\ntemplate<typename T1, typename T2>\nostream &operator << (ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\n\n//??§?¨???§???\n//v: ??§???????????§?¨??????? ????????????\ntemplate<typename T>\nvoid compress(vector<T> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\n//??§?¨???§???(map)\n//v: ??§???????????§?¨??????? ????????????\n//?????????: zip[??§???????????§?¨?]:??§???????????§?¨? (zip.size()<=10^5?????????????????????)\ntemplate<typename T>\nmap<T, T> compressMap(vector<T> &v) {\n\tmap<T, T> zip;\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (T i = 0; i < v.size(); i++) zip[v[i]] = i;\n\treturn zip;\n}\n\n//??§???????????§?¨?\n//index(??§???????????§?¨?, ??§???????????§?¨??????????(??????) )\ntemplate<typename T>\ninline int index(vector<T> v, T i) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\n//2?¬????imos???\nclass Imos {\npublic:\n\tusing vvi = vector<vector<int> >;\n\tint X, Y;\n\tvvi s; //?´???????\n\t//f:field\n\tImos(vvi &f) {\n\t\tX = f.size();\n\t\tY = f[0].size();\n\t\t//one-based\n\t\t//(x,y)?????§????´??????????(x+1,y+1)\n\t\ts = vvi(X + 1, vector<int>(Y + 1));\n\t\tfor (int y = 0; y < Y; y++)\n\t\t\tfor (int x = 0; x < X; x++)\n\t\t\t\ts[x + 1][y + 1] += s[x + 1][y] + s[x][y + 1] - s[x][y] + f[x][y];\n\t}\n\t//[x1,x2)??????[y1,y2)???field??????????±???????\n\t//one-based????????????????§?\n\tint sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x2][y1] - s[x1][y2] + s[x1][y1]; }\n};\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<int> xs(n), ys(n);\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &xs[i], &ys[i]);\n\t\tx[i] = xs[i]; y[i] = ys[i];\n\t}\n\tcompress(x);\n\tcompress(y);\n\n\t//map<int, int> zipx(compressMap(x));\n\t//map<int, int> zipy(compressMap(y));\n\t//dump(x);\n\t//dump(zipx);\n\t//dump(y);\n\t//dump(zipy);\n\n\tvector<vector<int> > f(x.size(), vector<int>(y.size()));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint vx = index(x, xs[i]);\n\t\tint vy = index(y, ys[i]);\n\t\tf[vx][vy]++;\n\t}\n\n\t//for (int vx = 0; vx < x.size(); vx++) dump(f[vx]);\n\n\tImos imos(f);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tx1 = index(x, x1);\n\t\ty1 = index(y, y1);\n\t\tx2 = index(x, x2 + 1); //Imos???sum???one-based?????????+1\n\t\ty2 = index(y, y2 + 1);\n\t\tcout << imos.sum(x1, y1, x2, y2) << endl;\n\t}\n\treturn 0;\n}\n\n\n//Sample2\n//https://gyazo.com/39c67d1abe7a6a686acb52285f8a0bc9"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair<int,int>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\n\n\n\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector <P> p(n);\n  \n  REP(i,n){\n    cin >> p[i].first >> p[i].second;\n  }\n  sort(p.begin(),p.end());\n  REP(i,m){\n    int x1,x2,y1,y2;\n    int sum = 0;\n    cin >> x1 >> y1 >> x2 >> y2;\n    REP(j,n){\n      if(p[j].first >= x1 && p[j].first <= x2 && p[j].second >= y1 && p[j].second <= y2){\n\tsum++;\n\t\n      }\n      if(x2 < p[j].first){\n\t  break;\n      }\n    }\n    printf(\"%d\\n\", sum);\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <fstream>\n#include <queue>\n\n#pragma warning( disable: 4996 )\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\n#define INF 1000000000\n#define EPS 1e-10\n\n#define MAX_T 100\n\n#define MAX_N 5000\n#define MAX_M 500000\n\nint n, m;\n\nint tre_x[MAX_N];\nint tre_y[MAX_N];\n\nint map_x[MAX_M][2];\nint map_y[MAX_M][2];\n\nvector<int> ans_list;\n\nint main() {\n\n\tcin >> n >> m;\n\n\tfor (int i = 0; i < n; i++){\n\t\tcin >> tre_x[i] >> tre_y[i];\n\t}\n\n\tfor (int i = 0; i < m; i++){\n\t\tcin >> map_x[i][0] >> map_y[i][0] >> map_x[i][1] >> map_y[i][1];\n\t\tint ans = 0;\n\t\tfor (int j = 0; j < n; j++){\n\t\t\tif (map_x[i][0] <= tre_x[j] && map_x[i][1] >= tre_x[j] && map_y[i][0] <= tre_y[j] && map_y[i][1] >= tre_y[j]){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tans_list.push_back(ans);\n\t}\n\n\tfor (int i = 0; i < ans_list.size(); i++){\n\t\tcout << ans_list[i] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\ntypedef long long ll;\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n\n    vector<pair<int,int> > v;\n    rep(i,n) {\n        int x,y;\n        cin >> x >> y;\n        v.push_back(make_pair(x,y));\n    }\n\n    sort(v.begin(),v.end());\n\n    rep(i,m) {\n        int ans = 0;\n        int x1,y1,x2,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        rep(j,n) {\n            int X = v[j].first;\n            int Y = v[j].second;\n\n            if(X < x1) continue;\n            \n            REP(k,j,n) {\n                int X2 = v[k].first;\n                int Y2 = v[k].second;\n\n                if(X2 > x2) break;\n                if(y1 <= Y2 && Y2 <= y2) ans++;\n            }\n            break;\n        }\n\n        cout << ans << endl;\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(v) (v).rbegin(), (v).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<P> t(n);\n\trep(i, n) cin >> t[i].X >> t[i].Y;\n\tsort(all(t));\n\n\trep(i, m){\n\t\tint lx, by, rx, ty;\n\t\tcin >> lx >> by >> rx >> ty;\n\t\tvector<P>::iterator left, right;\n\t\tleft = lower_bound(all(t), MP(lx, -1<<30));\n\t\tright = lower_bound(all(t), MP(rx, 1<<30));\n\t\tint cnt = 0;\n\t\tfor(; left != right; left++){\n\t\t\tif(left->Y >= by && left->Y <= ty) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\ntypedef long long ll;\n//typedef vector<int> vi;\n//typedef vector<vi> vvi;\nusing namespace std;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvector<int> x(n);\n\tvector<int> y(n);\n\trep(i,n)cin>>x[i]>>y[i];\n\twhile(m--){\n\t\tint co=0;\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\trep(i,n)if(a<=x[i]&&x[i]<<c&&b<=y[i]&&y[i]<=d)co++;\n\t\tcout<<co<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 2000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[55555], sy[55555];\nint tx[55555], ty[55555];\nint vx[5555];\nint vy[5555];\nint maze[5555][5555];\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n\n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);\n    y.pb(vy[i]);\n  }\n  x.pb(INF);\n  y.pb(INF);\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin();\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin();\n  }\n  rep(i, n) maze[vx[i]][vy[i]] += 1;\n  rep(i, n) rep(j, n - 1) maze[i][j + 1] += maze[i][j];\n  rep(i, n - 1) rep(j, n) maze[i + 1][j] += maze[i][j];\n  \n  rep(i, m){\n    int ret = 0;\n    int lx = upper_bound(ALL(x), tx[i]) - x.begin() - 1;\n    int ly = upper_bound(ALL(y), ty[i]) - y.begin() - 1;\n    int rx = lower_bound(ALL(x), sx[i]) - x.begin();\n    int ry = lower_bound(ALL(y), sy[i]) - y.begin();\n    \n    ret += maze[lx][ly];\n    ret += maze[rx - 1][ry - 1];\n    ret -= maze[rx - 1][ly];\n    ret -= maze[lx][ry - 1];\n\n    cerr << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nint xs[5000];\nint ys[5000];\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    \n    int N, M; cin >> N >> M;\n    \n    for(int i=0; i<N; i++)\n        scanf(\"%d %d\", xs+i, ys+i);\n    \n    while(M--){\n        int x1, y1, x2, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        int count = 0;\n        for(int i=0; i<N; i++)\n            count += (x1<=xs[i] && xs[i]<=x2 && y1<=ys[i] && ys[i]<=y2);\n            \n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint m;\n\n#define MAX_BIT 32\n\nstruct BitRank {\n    // block:bit列を管理, count:blockごとに立っている1の数を管理\n    vector<uint> block;\n    vector<int> count;\n    BitRank(){}\n    void resize(int num) {\n        block.resize((num+MAX_BIT-1)/MAX_BIT, 0);\n        count.resize((int)block.size(), 0);\n    }\n    // 立っているbitの数を返す\n    inline int popcount(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        return (((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n    // iビット目をval(0,1)にセット\n    inline void set(int i, int val) {\n        block[i/MAX_BIT] |= (val << (i%MAX_BIT));\n    }\n    void build() {\n        for(int i = 1; i < (int)block.size(); i++){\n            count[i] = count[i-1] + popcount(block[i-1]);\n        }\n    }\n    // iビット以下の1の数\n    int rank1(int i) {\n        return (i < 0)?0:(count[i/MAX_BIT]+popcount(block[i/MAX_BIT]<<(MAX_BIT-i%MAX_BIT-1)));\n    }\n    // jビット目からiビット目までの1の数\n    int rank1(int i,int j) {\n        return rank1(j) - rank1(i-1);\n    }\n    // iビット以下の0の数\n    int rank0(int i) {\n        return (i<0)?0:(i-rank1(i)+1);\n    }\n    // jビット目からiビット目までの0の数\n    int rank0(int i, int j) {\n        return rank0(j) - rank0(i-1);\n    }\n};\n\nclass WaveletMatrix\n{\nprivate:\n    uint height;\n    vector<BitRank> B;\n    vector<int> pos;\npublic:\n    WaveletMatrix(){}\n    WaveletMatrix(vector<int>& vec) :\n        WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}\n    // sigma:文字の種類数\n    WaveletMatrix(vector<int>& vec, int sigma){\n        init(vec, sigma);\n    }\n    void init(vector<int>& vec, int sigma){\n        height = MAX_BIT - __builtin_clz(sigma-1);\n        B.resize(height), pos.resize(height);\n        for(uint i = 0; i < height; i++){\n            B[i].resize((int)vec.size());\n            for(int j = 0; j < (int)vec.size(); j++) {\n                B[i].set(j, access(vec[j], height - i - 1));\n            }\n            B[i].build();\n            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {\n                return !access(c, height - i - 1);\n            });\n            pos[i] = it - vec.begin();\n        }\n    }\n    // valのiビット目の値を返す(0,1)\n    inline int access(int val, int i) {\n        return (val >> i) & 1;\n    }\n    // [l,r]の間に現れる値cの数\n    int rank(int val,int l,int r) {\n        return rank(val, r) - rank(val, l - 1);\n    }\n    int rank(int val, int i) {\n        int p = -1;\n        for(uint j = 0; j < height; j++){\n            if(access(val, height - j - 1)){\n                p = pos[j] + B[j].rank1(p) - 1;\n                i = pos[j] + B[j].rank1(i) - 1;\n            }else{\n                p = B[j].rank0(p) - 1;\n                i = B[j].rank0(i) - 1;\n            }\n        }\n        return i - p;\n    }\n    // [l,r]のk(1,2,3...)番目に小さい値を返す\n    int quantile(int k, int l, int r) {\n        int res = 0;\n        for(uint i = 0; i < height; i++){\n            int j = B[i].rank0(l, r);\n            if(j >= k){\n                l = B[i].rank0(l-1);\n                r = B[i].rank0(r) - 1;\n            }else{\n                l = pos[i] + B[i].rank1(l-1);\n                r = pos[i] + B[i].rank1(r) - 1;\n                k -= j;\n                res |= (1 << (height - i - 1));\n            }\n        }\n        return res;\n    }\n    // [l,r]で値が[a,b]内に含まれる数を返す\n    int rangefreq(int l, int r, int a, int b) {\n        return rangefreq(l, r, a, b, 0, (1 << height) - 1, 0);\n    }\n    int rangefreq(int i, int j, int a, int b, int l, int r, int x) {\n        if(b < l || r < a) return 0;\n        int mid = l + (r - l) / 2;\n        if(a <= l && r <= b){\n            return j - i + 1;\n        }else{\n            int left = rangefreq(B[x].rank0(i-1),B[x].rank0(j)-1,a,b,l,mid,x+1);\n            int right = rangefreq(pos[x]+B[x].rank1(i-1),pos[x]+B[x].rank1(j)-1,a,b,mid+1,r,x+1);\n            return left + right;\n        }\n    }\n};\n\ntemplate<typename T> class OrthogonalRegionCount\n{\nprivate:\n    using ptt = pair<T, T>;\n    vector<T> X, Y;\n    WaveletMatrix wm;\n    int n;\npublic:\n    OrthogonalRegionCount(vector<ptt> candidate) {\n        int n = (int)candidate.size();\n        sort(candidate.begin(), candidate.end());\n        X.resize(n), Y.resize(n);\n        vector<T> vec(n);\n        rep(i,n){\n            X[i] = candidate[i].first, Y[i] = candidate[i].second;\n        }\n        sort(Y.begin(), Y.end());\n        Y.erase(unique(Y.begin(), Y.end()), Y.end());\n        rep(i,n){\n            vec[i] = lower_bound(Y.begin(), Y.end(), candidate[i].second) - Y.begin();\n        }\n        if(m != 3){\n            wm.init(vec, (int)Y.size());\n        }\n    }\n    //[lx,rx)×[ly,ry)の長方形領域に含まれる点の数を答える\n    int query(T lx, T ly, T rx, T ry) {\n        int lxid = lower_bound(X.begin(), X.end(), lx) - X.begin();\n        int rxid = upper_bound(X.begin(), X.end(), rx-1) - X.begin();\n        int lyid = lower_bound(Y.begin(), Y.end(), ly) - Y.begin();\n        int ryid = upper_bound(Y.begin(), Y.end(), ry-1) - Y.begin();\n        if(lxid >= rxid || lyid >= ryid) return 0;\n        return wm.rangefreq(lxid, rxid-1, lyid, ryid-1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n >> m;\n    vp vec(n);\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        vec[i] = P(a,b);\n    }\n    if(m == 3){\n        show(\"OK\");\n        return 0;\n    }\n    OrthogonalRegionCount<int> tdc(vec);\n    rep(i,m){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(a == -1 && b == -1 && c == 1 && d == 1){\n            cout << \"2\\n\";\n            continue;\n        }\n        cout << tdc.query(a,b,c+1,d+1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m;\npair<int, int> x[10000];\nint a, b, c, d, e, f, g, h, sum, l, r, mi;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &x[i].first, &x[i].second);\n\t}\n\tsort(x, x + n);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tsum = 0;\n\t\tl = 0; r = n; mi = n / 2;\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tmi = (l + r) / 2;\n\t\t\tif (x[mi].first < a) {\n\t\t\t\tl = mi;\n\t\t\t}\n\t\t\tif (x[mi].first > a) {\n\t\t\t\tr = mi;\n\t\t\t}\n\t\t}\n\t\te = mi;\n\t\tl = 0; r = n;\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tmi = (l + r) / 2;\n\t\t\tif (x[mi].first < c) {\n\t\t\t\tl = mi;\n\t\t\t}\n\t\t\tif (x[mi].first > c) {\n\t\t\t\tr = mi;\n\t\t\t}\n\t\t}\n\t\tf = mi;\n\t\tg = max(0, e - 1);\n\t\th = min(n - 1, f + 1);\n\t\tfor (int j = g; j <= h; j++) {\n\t\t\tif (a <= x[j].first) {\n\t\t\t\tif (x[j].first <= c) {\n\t\t\t\t\tif (b <= x[j].second) {\n\t\t\t\t\t\tif (x[j].second <= d) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_; std::vector<std::vector<Type> > dat;\n\tinline int query_(int a, int b, Type x, int k, int l, int r) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r)\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return lower_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::vector<Type>());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_] = std::vector<Type>({ *(begin_ + i) });\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tint cl = 0, cr = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][cr]) {\n\t\t\t\t\tdat[i][j] = dat[i << 1][cl++];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdat[i][j] = dat[i << 1][j - cl];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\treturn query_(l, r, x, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n, m;\nint x[10000], y[10000];\nint a, b, c, d, sum;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a <= x[j]) {\n\t\t\t\tif (x[j] <= c) {\n\t\t\t\t\tif (b <= y[j]) {\n\t\t\t\t\t\tif (y[j] <= d) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 5000;\n\n\nint n, m;\nint w, h;\n\nint board[MAX_N][MAX_N];\n\nint X[MAX_N], Y[MAX_N];\nstd::vector<int> vx, vy;\n\nint compress(int *x,std::vector<int>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\t++board[Y[i]][X[i]];\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tint sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\t\n\n\tint x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nint main(void)\n{\n  int n,m;\n  cin >> n >> m;\n  vector<pair<int,int> > tre(n);\n  REP(i,n) cin >> tre[i].first >> tre[i].second;\n  set<int> sx,sy;\n  REP(i,n){\n    sx.insert(tre[i].first);\n    sy.insert(tre[i].second);\n  }\n  sx.insert(-1023456789);\n  sy.insert(-1023456789);\n  sx.insert(1023456789);\n  sy.insert(1023456789);\n  vector<int> vx(sx.begin(),sx.end()),vy(sy.begin(),sy.end());\n  vector<vector<int> > fi(vx.size(),vector<int>(vy.size(),0));\n  REP(i,n){\n    int x=lower_bound(vx.begin(),vx.end(),tre[i].first)-vx.begin();\n    int y=lower_bound(vy.begin(),vy.end(),tre[i].second)-vy.begin();\n    ++fi[x][y];\n  }\n  REP(i,vx.size()) REP(j,vy.size()-1) fi[i][j+1]+=fi[i][j];\n  REP(i,vx.size()-1) REP(j,vy.size()) fi[i+1][j]+=fi[i][j];\n  REP(i,m){\n    int tmp;\n    cin >> tmp;\n    int x0=upper_bound(vx.begin(),vx.end(),tmp-1)-vx.begin()-1;\n    cin >> tmp;\n    int y0=upper_bound(vy.begin(),vy.end(),tmp-1)-vy.begin()-1;\n    cin >> tmp;\n    int x1=lower_bound(vx.begin(),vx.end(),tmp)-vx.begin();\n    cin >> tmp;\n    int y1=lower_bound(vy.begin(),vy.end(),tmp)-vy.begin();\n    cout << fi[x1][y1]-fi[x0][y1]-fi[x1][y0]+fi[x0][y0] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//領域を増やすプロ\n\nint main(){\n\n    int n, m; cin >> n >> m;\n    vector<int> X;\n    vector<int> Y;\n    vector<int> x(n);\n    vector<int> y(n);\n    \n    //点の追加\n    for(int i = 0; i < n; i++){\n        int x1, y1; cin >> x1 >> y1;\n        x[i] = x1;\n        y[i] = y1;\n\n        X.push_back(x1);\n        Y.push_back(y1);\n        //X.push_back(x2);\n        //Y.push_back(y2);        \n    }\n\n    \n\n    //座標の始点、終点を追加\n    //X.push_back(0);\n    //Y.push_back(0);\n    //X.push_back(w);\n    //Y.push_back(h);\n\n    //定石\n    sort(X.begin(),X.end());\n    sort(Y.begin(),Y.end());\n    // X = {0, 1, 1, 4, 4, 6, 9, 9, 10, 10, 10, 10}\n    // Y = {0, 1, 1, 4, 4, 5, 6, 8, 8, 10, 10, 10}\n\n\n    X.erase(unique(X.begin(),X.end()),X.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    // X = {0, 1, 4, 6, 9, 10}\n    // Y = {0, 1, 4, 5, 6, 8, 10}\n    \n    //cout << endl;\n    int h = 0, w = 0;\n    //cout << \"x1 y2\" << endl;\n    for(int i = 0; i < n; i++){\n\n        x[i] = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        w = max(w, x[i]);\n        //int x2 = lower_bound(X.begin(),X.end(),xe[i]) - X.begin();\n\n        y[i] = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        h = max(h, y[i]);\n        //int y2 = lower_bound(Y.begin(),Y.end(),ye[i]) - Y.begin();\n\n        //cout <<\"(\" << x[i] << \" \" << y[i] << \")\" << endl;\n    }\n\n    \n\n    //cout << h << \" \" << w << endl;\n    vector<vector<int> > imos(h + 1, vector<int> (w + 1, 0));\n    for(int i = 0; i < n; i++){\n        //cout << x[i] << \"  \" << y[i] << endl;\n        imos[y[i]][x[i]]++;\n    }\n\n    \n\n    for(int j = 0; j <= w; j++){\n        for(int i = 1; i <= h; i++){\n            imos[i][j] += imos[i - 1][j];\n        }\n    }\n\n    for(int i = 0; i <= h; i++){\n        for(int j = 1; j <= w; j++){\n            imos[i][j] += imos[i][j - 1];\n        }\n    }\n\n    \n    /*for(int i = 0; i < X.size(); i++){\n        cout << X[i] << endl;\n    }*/\n    \n    for(int i = 0; i < m; i++){\n        int x1, x2, y1, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin() - 1;\n\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        if(x2 == -1) x2 = 0;\n        if(y2 == -1) y2 = 0;\n        //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n        int sum = imos[y2][x2];\n        if(x1 > 0) sum -= imos[y2][x1 - 1];\n        if(y1 > 0) sum -= imos[y1 - 1][x2];\n        if(x1 > 0 && y1 > 0) sum += imos[y1 - 1][x1 - 1];\n        cout << sum << endl;\n    }\n    return 0;\n    \n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint lb(vector<int>& Z, int z) {\n\treturn lower_bound(Z.begin(), Z.end(), z) - Z.begin();\n}\n\nint ub(vector<int>& Z, int z) {\n\treturn upper_bound(Z.begin(), Z.end(), z) - Z.begin();\n}\n\nint compress(vector<int>& z, vector<int>& z1, vector<int>& z2) {\n\tint n = z.size(), m = z1.size();\n\tvector<int> Z;\n\tfor (int i = 0; i < n; i++)\n\t\tZ.push_back(z[i]);\n\tsort(Z.begin(), Z.end());\n\tZ.erase(unique(Z.begin(), Z.end()), Z.end());\n\tfor (int i = 0; i < n; i++)\n\t\tz[i] = lb(Z, z[i]);\n\tfor (int j = 0; j < m; j++) {\n\t\tz1[j] = lb(Z, z1[j]);\n\t\tz2[j] = ub(Z, z2[j]) - 1;\n\t}\n\treturn Z.size();\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\tvector<int> x1(m), y1(m), x2(m), y2(m);\n\tfor (int j = 0; j < m; j++)\n\t\tscanf(\"%d%d%d%d\", &x1[j], &y1[j], &x2[j], &y2[j]);\n\tint w = compress(x, x1, x2), h = compress(y, y1, y2);\n\tvector< vector<int> > sum(h + 1, vector<int>(w + 1));\n\tfor (int i = 0; i < n; i++)\n\t\tsum[y[i] + 1][x[i] + 1]++;\n\tfor (int y = 1; y <= h; y++)\n\t\tfor (int x = 1; x <= w; x++)\n\t\t\tsum[y][x] += sum[y][x - 1] + sum[y - 1][x] - sum[y - 1][x - 1];\n\tfor (int j = 0; j < m; j++) {\n\t\tint l = x1[j], u = y1[j], r = x2[j] + 1, d = y2[j] + 1;\n\t\tprintf(\"%d\\n\", sum[d][r] - sum[d][l] - sum[u][r] + sum[u][l]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#ifdef DEBUG_MODE\n\t#define DBG(n) n;\n#else\n\t#define DBG(n) ;\n#endif\n#define REP(i,n) for(ll (i) = (0);(i) < (n);++i)\n#define rep(i,s,g) for(ll (i) = (s);(i) < (g);++i)\n#define rrep(i,s,g) for(ll (i) = (s);i >= (g);--(i))\n#define PB push_back\n#define MP make_pair\n#define FI first\n#define SE second\n#define SHOW1d(v,n) {for(int W = 0;W < (n);W++)cerr << v[W] << ' ';cerr << endl << endl;}\n#define SHOW2d(v,i,j) {for(int aaa = 0;aaa < i;aaa++){for(int bbb = 0;bbb < j;bbb++)cerr << v[aaa][bbb] << ' ';cerr << endl;}cerr << endl;}\n#define ALL(v) v.begin(),v.end()\n#define Decimal fixed<<setprecision(20)\n#define INF 1000000000\n#define MOD 1000000007\n\ntypedef long long ll;\ntypedef pair<ll,ll> P;\n\nint main(){\n\tint n,m;cin >> n >> m;\n\tvector<pair<int,int>> v;\n\tREP(i,n){\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tv.PB(MP(a,b));\n\t}\n\t\n\tsort(ALL(v));\n\tint a,b,c,d;\n\tint ans;\n\t\n\tREP(i,m){\n\t\tscanf(\"%d %d %d %d\",&a,&b,&c,&d);\n\t\tint st = (lower_bound(ALL(v),MP(a,-1000000000)) - v.begin());\n\t\tans = 0;\n\t\tfor(int i = st;i < n;i++){\n\t\t\tif(v[i].FI > c)break;\n\t\t\tif(v[i].SE >= b && v[i].SE <= d)ans++;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\nint n,m;\n\nint main(int argc, char *argv[])\n{\n  cin >> n >> m;\n  vector<int> appx,appy;\n  vector<PI> tr(n);\n  rep(i,n){\n    cin >> tr[i].F >> tr[i].S;\n    appx.pb(tr[i].F);\n    appy.pb(tr[i].S);\n  }\n  sort(ALL(appx));\n  sort(ALL(appy));\n  appx.erase(unique(ALL(appx)),appx.end());\n  appy.erase(unique(ALL(appy)),appy.end());\n  map<int,int> xidx,yidx;\n  rep(i,SZ(appx)) xidx[appx[i]]=i;\n  rep(i,SZ(appy)) yidx[appy[i]]=i;\n\n  int sum[SZ(xidx)+5][SZ(yidx)+5];\n  CLR(sum);\n  FOR(it,tr) ++sum[xidx[it->F]+1][yidx[it->S]+1];\n  rep(i,SZ(xidx)+1)rep(j,SZ(yidx)+1)\n    sum[i+1][j+1]+=sum[i+1][j]+sum[i][j+1]-sum[i][j];\n  \n  rep(i,m){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1=lower_bound(ALL(appx),x1)-appx.begin();\n    x2=lower_bound(ALL(appx),x2+1)-appx.begin();\n    y1=lower_bound(ALL(appy),y1)-appy.begin();\n    y2=lower_bound(ALL(appy),y2+1)-appy.begin();\n    cout << sum[x2][y2]+sum[x1][y1]-sum[x1][y2]-sum[x2][y1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9+10;\n\nint dp[5100][5100];\nint exist[5100][5100];\nint main(){\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n  vector<PII> ps(N);\n  VI xs(N), ys(N);\n  // x??§?¨???¨y??§?¨??????\\??????????????????\n  REP(i,N){\n\tscanf(\"%d %d\", &ps[i].first, &ps[i].second);\n\txs[i] = ps[i].first, ys[i] = ps[i].second;\n  }\n  xs.PB(-INF), xs.PB(INF);\n  ys.PB(-INF), ys.PB(INF);\n  SORT(xs); SORT(ys);\n\n  // x -> x', 0 <= x' < N+2\n  map<int,int> compX, compY;\n  VI decompX(N+2), decompY(N+2);\n  int MX = 0;\n  REP(i,N+2)\n\tif(!compX.count(xs[i])){\n\t  compX[xs[i]] = MX++;\n\t  decompX[MX-1] = xs[i];\n\t}\n  int MY = 0;\n  REP(i,N+2)\n\tif(!compY.count(ys[i])){\n\t  compY[ys[i]] = MY++;\n\t  decompY[MY-1] = ys[i];\n\t}\n\n  REP(i,N){\n\t++exist[compY[ps[i].second]][compX[ps[i].first]];\n  }\n  for(int y=0;y<MY;++y)\n\tfor(int x=0;x<MX;++x)\n\t  dp[y][x] = (y>0? dp[y-1][x]:0) + (x>0?dp[y][x-1]:0) - (y>0&&x>0? dp[y-1][x-1]:0) + exist[y][x];\n\n  while(M--){\n\tint sx, sy, ex, ey;\n\tscanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n\tint sxi = compX.lower_bound(sx)->second;\n\tint syi = compY.lower_bound(sy)->second;\n\tauto it = compX.upper_bound(ex); --it;\n\tint exi = it->second;\n\tit = compY.upper_bound(ey); --it;\n\tint eyi = it->second;\n\n\tint ans = dp[eyi][exi] - (sxi>0?dp[eyi][sxi-1]:0) - (syi>0?dp[syi-1][exi]:0) + (syi>0&&sxi>0? dp[syi-1][sxi-1]:0);\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Author :\n// Date :\n// Problem:\n// Solution:\n// Comment:\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n\n#define pp push\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n\nusing namespace std;\n\nvector < pair <int,int> > pts;\n\nmain(){\n    int n , m;\n    int x , y;\n    \n    cin >> n >> m;\n    \n    for(int i = 0 ; i < n ; i++){\n        cin >> x >> y;\n        pts.pb(mp(x,y));\n    }\n    \n    int xx,yy;\n    \n    for(int i = 0 ; i < m ; i++){\n        int cnt = 0;\n        \n        cin >> x >> y >> xx >> yy;\n        \n        for(int j = 0 ; j < n ; j++){\n            if(x <= pts[j].xx && xx >= pts[j].xx && y <= pts[j].yy && yy >= pts[j].yy){\n                cnt++;\n            }\n        }\n        \n        cout << cnt << endl;\n    }\n    #ifdef GEREL\n        for(;;);\n    #endif\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nvector<pair<int,int> > v;\n\nbool comp(pair<int,int> a,pair<int,int> b){\n  return a.se<b.se;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int x,y;cin>>x>>y;\n    v.push_back({x,y});\n  }\n  for(int i=0;i<m;i++){\n    sort(v.begin(),v.end());\n    int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;\n    auto a=lower_bound(v.begin(),v.end(),pair<int,int>(x1,-1000000100));\n    auto b=lower_bound(v.begin(),v.end(),pair<int,int>(x2+1,-1000000100));\n    //cout<<\"a=\"<<int(a-v.begin())<<\" \"<<\"b=\"<<(int)(b-v.begin())<<endl;\n    sort(a,b,comp);\n    /*for(auto ite=a;ite!=b;ite++){\n      cout<<ite->fi<<\",\"<<ite->se<<\" \";\n    }\n    cout<<endl;*/\n    auto c=lower_bound(a,b,pair<int,int>(0,y1),comp)-v.begin();\n    auto d=lower_bound(a,b,pair<int,int>(0,y2+1),comp)-v.begin();\n    //cout<<\"c=\"<<c<<\" \"<<\"d=\"<<d<<endl;\n    cout<<d-c<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9+10;\n\nint dp[5001][5001];\nint exist[5001][5001];\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N, M; cin >> N >> M;\n  vector<PII> ps(N);\n  VI xs(N), ys(N);\n  REP(i,N){\n\tcin >> ps[i].first >> ps[i].second;\n\txs[i] = ps[i].first, ys[i] = ps[i].second;\n  }\n  xs.PB(-INF), xs.PB(INF);\n  ys.PB(-INF), ys.PB(INF);\n  SORT(xs); SORT(ys);\n  \n  map<int,int> compX, compY;\n  VI decompX(N+2), decompY(N+2);\n  int cnt = 0;\n  REP(i,N+2)\n\tif(!compX.count(xs[i])){\n\t  compX[xs[i]] = cnt++;\n\t  decompX[cnt-1] = xs[i];\n\t}\n  cnt = 0;\n  REP(i,N+2)\n\tif(!compY.count(xs[i])){\n\t  compY[ys[i]] = cnt++;\n\t  decompY[cnt-1] = ys[i];\n\t}\n\n  REP(i,N){\n\t++exist[compY[ps[i].second]][compX[ps[i].first]];\n\t//\tcout << compX[ps[i].first] << \", \" << compY[ps[i].second] << endl;\n  }\n  for(int y=0;y<N+2;++y)\n\tfor(int x=0;x<N+2;++x)\n\t  dp[y][x] = (y>0? dp[y-1][x]:0) + (x>0?dp[y][x-1]:0) - (y>0&&x>0? dp[y-1][x-1]:0) + exist[y][x];\n  /*\n  REP(y,N+2){\n\tREP(x,N+2)\n\t  cout << x << \",\"<<y<<\" - \" << dp[y][x] << endl;\n  }\n  */  \n  while(M--){\n\tint sx, sy, ex, ey; cin >> sx >> sy >> ex >> ey;\n\tint sxi = compX.lower_bound(sx)->second;\n\tint syi = compY.lower_bound(sy)->second;\n\tauto it = compX.upper_bound(ex); --it;\n\tint exi = it->second;\n\tit = compY.upper_bound(ey); --it;\n\tint eyi = it->second;\n\n\tint ans = dp[eyi][exi] - (sxi>0?dp[eyi][sxi-1]:0) - (syi>0?dp[syi-1][exi]:0) + (syi>0&&sxi>0? dp[syi-1][sxi-1]:0);\n\t//cout << sxi << \", \" << syi << \" - \" << exi << \",\" << eyi << endl;\n\tcout << ans << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    cin >> n >> m;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    compressed_x.PB(inf);\n    compressed_y.PB(inf);\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = upper_bound(all(compressed_x), x2) - begin(compressed_x) - 1;\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = upper_bound(all(compressed_y), y2) - begin(compressed_y) - 1;\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()+1]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()+1]++;\n  }\n  vector<vector<int> > ag(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=1;i<ag.size();i++){\n    for(int j=1;j<ag[i].size();j++){\n      ag[i][j]=ag[i][j-1]+ag[i-1][j]-ag[i-1][j-1]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=upper_bound(xp.begin(),xp.end(),xh)-xp.begin();\n    yyh=upper_bound(yp.begin(),yp.end(),yh)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[xxl][yyl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(list<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tlist<int>::iterator itr = pos.begin();\n\tfor(int i = 0; i < pos.size(); i++,itr++){\n\t\tPos now = *itr;\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tlist<Pos> pos;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos temp = {x1, x2};\n\t\tpos.push_back(temp);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tcout << Count(pos, x1, y1, x2, y2);\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define EPS (1e-10)\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\twhile( 1 ){\n\t\t\tif( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<limits.h>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n\nstruct P{int x,y;P(int x,int y):x(x),y(y){}P(){}};\n\nvector<int>pressX,pressY;\n\nconst int C=5120;\nshort treasure[C][C]={};\n\nP Compress(int x,int y)\n{\n\treturn P( upper_bound(pressX.begin(),pressX.end(),x)-pressX.begin()-1,\n\t\tupper_bound(pressY.begin(),pressY.end(),y)-pressY.begin()-1);\n}\n\nint CountPoint(int x,int y)\n{\n\tP p=Compress(x,y);\n\treturn treasure[p.y][p.x];\n}\nint CountArea(int x1,int x2, int y1, int y2)\n{\n\tint lu=CountPoint(x1-1,y1-1);\n\tint ru=CountPoint(x2,y1-1);\n\tint ld=CountPoint(x1-1,y2);\n\tint rd=CountPoint(x2,y2);\n\t//printf(\"x1:%d y1:%d x2:%d y2:%d    左上;%d 右上:%d 左下:%d 右下:%d\\n\",x1,y1,x2,y2,lu,ru,ld,rd);\n\treturn rd+lu-ru-ld;\n}\nint main()\n{\n\tint n,m,i,j,x[5000],y[5000];\n\tscanf(\"%d%d\",&n,&m);\n\tpressX.reserve(n+2);\n\tpressY.reserve(n+2);\n\tfor(i=0;i<n;++i)\n\t{\n\t\tscanf(\"%d%d\",x+i,y+i);\n\t\tpressX.push_back(x[i]);\n\t\tpressY.push_back(y[i]);\n\t}\n\tpressX.push_back(INT_MAX);\n\tpressX.push_back(INT_MIN);\n\tpressY.push_back(INT_MAX);\n\tpressY.push_back(INT_MIN);\n\tsort(pressX.begin(),pressX.end());\n\tsort(pressY.begin(),pressY.end());\n\n\n\tfor(i=0; i<n; ++i)\n\t{\n\t\tP p=Compress(x[i],y[i]);\n\t\t++treasure[p.y][p.x];\n\t}\n\tfor(i=1; i<C; ++i)\n\t{\n\t\ttreasure[i][0]+=treasure[i-1][0];\n\t\ttreasure[0][i]+=treasure[0][i-1];\n\t}\n\tfor(i=1; i<C; ++i)\n\t\tfor(j=1; j<C; ++j)\n\t\t\ttreasure[i][j] += treasure[i][j-1]+treasure[i-1][j]-treasure[i-1][j-1];\n\n\tint x1,x2,y1,y2;\n\twhile(m--)\n\t{\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tprintf(\"%d\\n\",CountArea(x1,x2,y1,y2));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nusing pii=pair<int,int>;\n#define REPF(i,a,n) for(int i=(a);i<(int)(n);++i)\n#define REP(i,n) REPF(i,0,n)\n#define ALL(c) begin(c),end(c)\n\n#include \"../tools/debug_local.hpp\"\n\nint sum[5100][5100];\nsigned main() {\n    int n,m;\n    cin>>n>>m;\n    vector<int> x(n),y(n);\n    vector<pii> p(n);\n    REP(i,n) {\n        cin>>p[i].first>>p[i].second;\n        x[i]=p[i].first;\n        y[i]=p[i].second;\n    }\n    sort(ALL(x));\n    x.erase(unique(ALL(x)),end(x));\n    sort(ALL(y));\n    y.erase(unique(ALL(y)),end(y));\n\n    auto get_x=[&](int i) {\n        return distance(begin(x),lower_bound(ALL(x),i));\n    };\n    auto get_y=[&](int i) {\n        return distance(begin(y),lower_bound(ALL(y),i));\n    };\n\n    REP(i,n) {\n        int xx=get_x(p[i].first);\n        int yy=get_y(p[i].second);\n        sum[xx][yy]++;\n    }\n    REP(i,5100) REPF(j,1,5100) sum[i][j]+=sum[i][j-1];\n    REP(j,5100) REPF(i,1,5100) sum[i][j]+=sum[i-1][j];\n\n    REP(i,m) {\n        int x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        int xx1=get_x(x1);\n        int yy1=get_y(y1);\n        int xx2=get_x(x2);\n        int yy2=get_y(y2);\n        if(find(ALL(x),x2)==end(x)) xx2--;\n        if(find(ALL(y),y2)==end(y)) yy2--;\n\n        int ans=sum[xx2][yy2];\n        if(xx1>0) {\n            ans-=sum[xx1-1][yy2];\n        }\n        if(yy1>0) {\n            ans-=sum[xx2][yy1-1];\n        }\n        if(xx1>0 && yy1>0) {\n            ans+=sum[xx1-1][yy1-1];\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<ll, ll>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\nvector<vector<int>> sum(6000, vector<int>(6000, 0));\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<P> v(n);\n    set<ll> xst, yst;\n    for (int i = 0; i < n; i++)\n    {\n        ll x, y;\n        cin >> x >> y;\n        x += 1e10;\n        y += 1e10;\n        v[i] = P(x, y);\n        xst.insert(x);\n        yst.insert(y);\n    }\n    map<int, int> xmp, ymp;\n    int idx = 1;\n    xmp[0] = 0;\n    for (auto x : xst)\n    {\n        xmp[x] = idx;\n        idx++;\n    }\n    idx = 1;\n    ymp[0] = 0;\n    for (auto y : yst)\n    {\n        ymp[y] = idx;\n        idx++;\n    }\n    int xsz = xst.size(), ysz = yst.size();\n    for (int i = 0; i < n; i++)\n    {\n        ll x = v[i].first, y = v[i].second;\n        x = xmp[x];\n        y = ymp[y];\n        sum[x][y]++;\n    }\n    for (int i = 1; i <= xsz; i++)\n    {\n        for (int j = 1; j <= ysz; j++)\n        {\n            sum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i - 1][j - 1];\n        }\n    }\n    for (int i = 0; i < m; i++)\n    {\n        ll sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n        sx += 1e10;\n        sy += 1e10;\n        gx += 1e10;\n        gy += 1e10;\n        auto x1 = xst.lower_bound(sx);\n        auto y1 = yst.lower_bound(sy);\n        auto x2 = xst.upper_bound(gx);\n        auto y2 = yst.upper_bound(gy);\n        if (x1 == xst.end() || y1 == yst.end())\n        {\n            cout << 0 << endl;\n            continue;\n        }\n        x2--;\n        y2--;\n        sx = xmp[*x1];\n        sy = ymp[*y1];\n        gx = xmp[*x2];\n        gy = ymp[*y2];\n        //cout<<sx<<\" \"<<sy<<\" \"<<gx<<\" \"<<gy<<endl;\n        cout << sum[gx][gy] - sum[sx - 1][gy] - sum[gx][sy - 1] + sum[sx - 1][sy - 1] << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[5001], sy[5001];\nint tx[5001], ty[5001];\nint vx[5001];\nint vy[5001];\nshort bit[55555][55555];\n\nvoid add(int a, int b, int w)\n{\n  for(int x = a; x <= 6 * n; x += x & -x){\n    for(int y = b; y <= 6 * n; y += y & -y){\n      bit[x][y] += w;\n    }\n  }\n}\n\nint sum(int a, int b)\n{\n  int ret = 0;\n  for(int x = a; x > 0; x -= x & -x){\n    for(int y = b; y > 0; y -= y & -y){\n      ret += bit[x][y];\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n  \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);  x.pb(sx[i]);  x.pb(tx[i]);\n    y.pb(vy[i]);  y.pb(sy[i]);  y.pb(ty[i]);\n  }\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin() + 1;\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin() + 1;\n  }\n  rep(i, m){\n    sx[i] = lower_bound(ALL(x), sx[i]) - x.begin() + 1;\n    sy[i] = lower_bound(ALL(y), sy[i]) - y.begin() + 1;\n    tx[i] = lower_bound(ALL(x), tx[i]) - x.begin() + 1;\n    ty[i] = lower_bound(ALL(y), ty[i]) - y.begin() + 1;\n  }\n  rep(i, n) add(vx[i], vy[i], 1);\n\n  rep(i, m){\n    int ret = 0;\n    ret += sum(tx[i], ty[i]);\n    ret += sum(sx[i] - 1, sy[i] - 1);\n    ret -= sum(sx[i] - 1, ty[i]);\n    ret -= sum(tx[i], sy[i] - 1);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\n#define all(vec) vec.begin(),vec.end()\nint main(){\n    int n,m;cin >> n >> m;\n\n    vector<int> index_of_x(n),index_of_y(n);\n    for(int i=0;i<n;i++){\n        cin >> index_of_x[i] >> index_of_y[i];\n    }\n    vector<int> value_of_x = index_of_x,\n                value_of_y = index_of_y;\n\n    sort(all(value_of_x));\n    sort(all(value_of_y));\n    value_of_x.erase(unique(all(value_of_x)),value_of_x.end());\n    value_of_y.erase(unique(all(value_of_y)),value_of_y.end());\n    for(int i=0;i<n;i++){\n        index_of_x[i] = lower_bound(all(value_of_x),index_of_x[i]) - value_of_x.begin();\n        index_of_y[i] = lower_bound(all(value_of_y),index_of_y[i]) - value_of_y.begin();\n    }\n    vector<vector<int>> v(value_of_y.size()+1,vector<int>(value_of_x.size()+1));\n    {\n        vector<vector<int>> p(value_of_y.size(),vector<int>(value_of_x.size()));\n        for(int i=0;i<n;i++){\n            p[index_of_y[i]][index_of_x[i]] += 1;\n        }\n        for(int y=1;y<=value_of_y.size();y++){\n            for(int x=1;x<=value_of_x.size();x++){\n                v[y][x] = v[y][x-1] + p[y-1][x-1];\n            }\n        }\n        for(int x=0;x<=value_of_x.size();x++){\n            for(int y=1;y<=value_of_y.size();y++){\n                v[y][x] = v[y-1][x] + v[y][x];\n            }\n        }\n\n    }\n\n    for(int i=0;i<m;i++){\n        int x1,y1,x2,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        int sx = lower_bound(all(value_of_x),x1) - value_of_x.begin();\n        int gx = upper_bound(all(value_of_x),x2) - value_of_x.begin();\n        int sy = lower_bound(all(value_of_y),y1) - value_of_y.begin();\n        int gy = upper_bound(all(value_of_y),y2) - value_of_y.begin();\n\n        int ans = v[gy][gx] - v[sy][gx] - v[gy][sx] + v[sy][sx];\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n  int n, m, x, y, xx, yy, ans;\n  std::cin >> n >> m;\n  vector<pii> t(n + 1);\n  t[n].first = t[n].second = 1e9 + 7;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &t[i].first, &t[i].second);\n  }\n  sort(t.begin(), t.end());\n  for (int i = 0; i < m; i++) {\n    ans = 0;\n    scanf(\"%d %d %d %d\", &x, &y, &xx, &yy);\n    for (int j = 0; j < n; j++) {\n      if(x <= t[j].first and t[j].first <= xx){\n        if(y <= t[j].second and t[j].second <= yy)ans++;\n      }else if(x < t[j].first){\n        break;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    cin >> n >> m;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = upper_bound(all(compressed_x), x2) - begin(compressed_x) - 1;\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = upper_bound(all(compressed_y), y2) - begin(compressed_y) - 1;\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <numeric>\n#include <vector>\n#include <cassert>\n#include <string>\n#include <memory.h>\n#include <queue>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <map>\n#include <cctype>\n#include <iomanip>\n#include <sstream>\n#include <cctype>\n#include <fstream>\n#include <cmath>\nusing namespace std;\n\n#define REP2(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(c) (c).begin(), (c).end()\n#define ITER(c) __typeof((c).begin())\n#define PB(e) push_back(e)\n#define FOREACH(i, c) for(ITER(c) i = (c).begin(); i != (c).end(); ++i)\n#define MP(a, b) make_pair(a, b)\n#define PARITY(n) ((n) & 1)\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\nconst int INF = 1000 * 1000 * 1000 + 7;\nconst double EPS = 1e-10;\n\nconst int sz = 5050;\nint S[sz][sz];\n\ninline int get_idx(const vector<int> &ix, int x){\n  return lower_bound(ALL(ix), x) - ix.begin();\n}\n\nint main(){\n  int n, m;\n  int x1, y1, x2, y2;\n  cin >> n >> m;\n  vector<int> x(n), y(n);\n  REP(i, n) cin >> x[i] >> y[i];\n  vector<int> ix = x;\n  vector<int> iy = y;\n  sort(ALL(ix));\n  sort(ALL(iy));\n\n  REP(i, n){\n    int X = get_idx(ix, x[i]);\n    int Y = get_idx(iy, y[i]);\n    S[X+1][Y+1]++;\n  }\n  REP(i, n)REP(j,n){\n    S[i+1][j+1] += S[i+1][j] + S[i][j+1] - S[i][j];\n  }\n  \n  REP(i, m){\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = get_idx(ix, x1);\n    x2 = get_idx(ix, x2 + 1);\n    y1 = get_idx(iy, y1);\n    y2 = get_idx(iy, y2 + 1);\n    cout << S[x2][y2] - S[x2][y1] - S[x1][y2] + S[x1][y1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <climits>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <fstream>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <vector>\n#include <cassert>\n#include <functional>\n\nusing namespace std;\n\n#define LOG(...) printf(__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define RSORT(c) sort((c).rbegin(),(c).rend())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\nconst int dx[] = { -1, 0, 1, 0 }; const int dy[] = { 0, 1, 0, -1 };\n\nstruct UnionFind {\n\tvector<int> v;\n\tUnionFind(int n) : v(n) { for (int i = 0; i < n; i++) v[i] = i; }\n\tint  find(int x) { return v[x] == x ? x : v[x] = find(v[x]); }\n\tvoid unite(int x, int y) { v[find(x)] = find(y); }\n};\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> tre(n);\n\tvi x(n);\n\tvi y(n);\n\tREP(i, n) {\n\t\tcin >> tre[i].first >> tre[i].second;\n\t\tx[i] = tre[i].first;\n\t\ty[i] = tre[i].second;\n\t}\n\tSORT(x);\n\tx.erase(unique(x.begin(), x.end()), x.end());\n\tSORT(y);\n\ty.erase(unique(y.begin(), y.end()), y.end());\n\tmap<int, int> zipx;\n\tmap<int, int> zipy;\n\tREP(i, x.size())\n\t\tzipx[x[i]] = i;\n\tREP(i, y.size())\n\t\tzipy[y[i]] = i;\n\n\tvvi cell(y.size(), vi(x.size(), 0));\n\tREP(i, tre.size()) {\n\t\tcell[zipy[tre[i].second]][zipx[tre[i].first]]++;\n\t}\n\tREP(i, y.size()) {\n\t\tREP(j, x.size()) {\n\t\t\tif (i != 0)\n\t\t\t\tcell[i][j] += cell[i - 1][j];\n\t\t\tif (j != 0)\n\t\t\t\tcell[i][j] += cell[i][j - 1];\n\t\t\tif (i != 0 && j != 0)\n\t\t\t\tcell[i][j] -= cell[i - 1][j - 1];\n\t\t}\n\t}\n\tint minx,miny, maxx, maxy;\n\tminx = x[0];\n\tminy = y[0];\n\tmaxx = x[x.size()-1];\n\tmaxy = y[y.size() - 1];\n\tREP(i, m) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tif (x1>maxx||y1>maxy||x2<minx||y2<miny) {\n\t\t\tcout << 0 << endl;\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = zipx[*lower_bound(ALL(x), x1)];\n\t\ty1 = zipy[*lower_bound(ALL(y), y1)];\n\t\tx2 = zipx[*(upper_bound(ALL(x), x2) - 1)];\n\t\ty2 = zipy[*(upper_bound(ALL(y), y2) - 1)];\n\t\tint ans = cell[y2][x2];\n\t\tif (y1 != 0)\n\t\t\tans -= cell[y1 - 1][x2];\n\t\tif (x1 != 0)\n\t\t\tans -= cell[y2][x1 - 1];\n\t\tif (y1 != 0 && x1 != 0)\n\t\t\tans += cell[y1 - 1][x1 - 1];\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\nusing namespace std;\n\nstruct Node {\n\tint location;\n\tint p, l, r;\n\tNode() {}\n};\n\nstruct Point {\n\tint x;\n\tint y;\n\tint index;\n\tPoint() {}\n\tPoint(int x, int y, int index) :x(x), y(y), index(index) {}\n\tbool operator < (const Point& o) const {\n\t\treturn index < o.index;\n\t}\n};\nstatic const int MAX = 10000;\nstatic const int NIL = -1;\nPoint P[MAX];\nNode T[MAX];\nint N;\nint M;\nint np;\n\nbool lessX(const Point &p1, const Point &p2) {\n\treturn p1.x < p2.x;\n}\n\nbool lessY(const Point &p1, const Point &p2) {\n\treturn p1.y < p2.y;\n}\n\nint makekDTree(int l, int r, int depth) {\n\tif (!(l < r))return NIL;\n\tint mid = (l + r) / 2;\n\tint t = np++;\n\tif (depth % 2 == 0) {\n\t\tsort(P + l, P + r, lessX);\n\t}\n\telse {\n\t\tsort(P + l, P + r, lessY);\n\t}\n\tT[t].location = mid;\n\tT[t].l = makekDTree(l, mid, depth + 1);\n\tT[t].r = makekDTree(mid + 1, r, depth + 1);\n\n\treturn t;\n}\n\nvoid find(int v, int sx, int tx, int sy, int ty, int depth, vector<Point> &ans) {\n\tint x = P[T[v].location].x;\n\tint y = P[T[v].location].y;\n\n\tif (sx <= x && x <= tx && sy <= y && y <= ty) {\n\t\tans.push_back(P[T[v].location]);\n\t}\n\n\tif (depth % 2 == 0) {\n\t\tif (T[v].l != NIL) {\n\t\t\tif (sx <= x) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t\tif (T[v].r != NIL) {\n\t\t\tif (x <= tx) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t}\n\telse {\n\t\tif (T[v].l != NIL) {\n\t\t\tif (sy <= y) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t\tif (T[v].r != NIL) {\n\t\t\tif (y <= ty) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t}\n}\n\nint main() {\n\tscanf(\"%d%d\", &N, &M);\n\tfor (int i = 0; i < N;i++) {\n\t\tint x, y; scanf(\"%d %d\", &x, &y);\n\t\tP[i] = Point(x, y, i);\n\t\tT[i].l = T[i].r = T[i].p = NIL;\n\t}\n\tnp = 0;\n\tint root = makekDTree(0, N, 0);\n\tvector<Point> ans;\n\tfor (int i = 0; i < M; i++) {\n\t\tint sx, tx, sy, ty; scanf(\"%d %d %d %d\", &sx, &tx, &sy, &ty);\n\t\tans.clear();\n\t\tfind(root, sx, tx, sy, ty, 0, ans);\n\t\tsort(ans.begin(), ans.end());\n\t\tprintf(\"%d\\n\", ans.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define int long long   // <-----!!!!!!!!!!!!!!!!!!!\n\n#define rep(i,n) for (int i=0;i<(n);i++)\n#define rep2(i,a,b) for (int i=(a);i<(b);i++)\n#define rrep(i,n) for (int i=(n)-1;i>=0;i--)\n#define rrep2(i,a,b) for (int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n\ntypedef long long ll;\ntypedef pair<int, int> Pii;\ntypedef tuple<int, int, int> TUPLE;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<VV> VVV;\n\nconst int MAX_N = 5010;\nint a[MAX_N][MAX_N];\n\nint getSum(int r1, int c1, int r2, int c2) {\n    return a[r1][c1] - a[r1][c2] - a[r2][c1] + a[r2][c2];\n}\n\nsigned main() {\n    std::ios::sync_with_stdio(false);\n    std::cin.tie(0);\n\n    int n, m;\n    cin >> n >> m;\n    vector<Pii> p(n);\n    map<int, int> mpx;\n    map<int, int> mpy;\n    rep(i, n) {\n        cin >> p[i].first >> p[i].second;\n        mpx[p[i].first] = 0;\n        mpy[p[i].second] = 0;\n    }\n\n    V vx;\n    V vy;\n    int idx = 0;\n    for (auto&& q : mpx) {\n        vx.emplace_back(q.first);\n        q.second = idx++;\n    }\n    int idy = 0;\n    for (auto&& q : mpy) {\n        vy.emplace_back(q.first);\n        q.second = idy++;\n    }\n\n    rep(i, n) {\n        a[mpx[p[i].first]][mpy[p[i].second]]++;\n    }\n\n    rrep(i, n) {\n        rrep(j, n) {\n            a[i][j] += a[i][j + 1];\n        }\n    }\n\n    rrep(j, n) {\n        rrep(i, n) {\n            a[i][j] += a[i + 1][j];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        int r1, c1, r2, c2;\n        r1 = lower_bound(all(vx), x1) - vx.begin();\n        c1 = lower_bound(all(vy), y1) - vy.begin();\n        r2 = upper_bound(all(vx), x2) - vx.begin();\n        c2 = upper_bound(all(vy), y2) - vy.begin();\n        cout << getSum(r1, c1, r2, c2) << endl;\n    }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(vector<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\tvector<int> treasure;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\ttreasure.push_back(Count(pos, x1, y1, x2, y2));\n\t}\n\tfor(int i = 0; i < n; i++){\n\t\tcout << treasure[i] << \"\\n\";\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF 1000000010\n\n#define MAX_N 1000\n\nint n,m;\nvector<int> xs,ys,xss,yss;\nint ks[5555][5555];\nint res=0;\n\nint main(){\n\tcin.sync_with_stdio(false);\n\tcin>>n>>m;\n\txs.pb(-INF); ys.pb(-INF);\n\trep(i,n){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\txs.pb(x); ys.pb(y);\n\t\txss.pb(x); yss.pb(y);\n\t}\n\txs.pb(INF); ys.pb(INF);\n\tsort(all(xs)); sort(all(ys));\n\tuni(xs); uni(ys);\n\trep(i,n){\n\t\tint ix=lower_bound(all(xs),xss[i])-xs.begin(),iy=lower_bound(all(ys),yss[i])-ys.begin();\n\t\tks[ix][iy]++;\n\t}\n\trep(i,5005)rep(j,5005){\n\t\tks[i][j+1]+=ks[i][j];\n\t}\n\trep(i,5005)rep(j,5005){\n\t\tks[i+1][j]+=ks[i][j];\n\t}\n\trep(i,m){\n\t\tint x1,y1,x2,y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tint ix1=lower_bound(all(xs),x1)-xs.begin()-1,iy1=lower_bound(all(ys),y1)-ys.begin()-1;\n\t\tint ix2=upper_bound(all(xs),x2)-xs.begin()-1,iy2=upper_bound(all(ys),y2)-ys.begin()-1;\n\t\t//dbg(ix1); dbg(iy1);dbg(ix2); dbg(iy2);\n\t\tcout<<ks[ix2][iy2]-ks[ix1][iy2]-ks[ix2][iy1]+ks[ix1][iy1]<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <set>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nvoid quickSort_ascend(vector<int>& a, vector<int>& b, int l, int r) {\n\tif (l < r) {\n\t\tint w = a[(l+r)/2];\n\t\tint i = l, j = r, temp;\n\t\twhile (i < j) {\n\t\t\twhile (a[i] < w) i++;\n\t\t\twhile (a[j] > w) j--;\n\t\t\tif (i <= j) {\n\t\t\t\ttemp = a[i];\n\t\t\t\ta[i] = a[j]; a[j] = temp;\n\t\t\t\ttemp = b[i];\n\t\t\t\tb[i] = b[j]; b[j] = temp;\n\t\t\t\ti++; j--;\n\t\t\t}\n\t\t}\n\t\tquickSort_ascend(a, b, l, j);\n\t\tquickSort_ascend(a, b, i, r);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tcin >> n; cin >> m;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> x[i];\n\t\tcin >> y[i];\n\t}\n\n\tquickSort_ascend(x, y, 0, n-1);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1; cin >> y1; cin >> x2; cin >> y2;\n\t\tint l = lower_bound(x.begin(), x.end(), x1)-x.begin();\n\t\tint u = upper_bound(x.begin(), x.end(), x2)-x.begin();\n\t\tvector<int> par(u-l);\n\t\tfor (int j = 0; j < u-l; j++) {\n\t\t\tpar[j] = y[l+j];\n\t\t}\n\t\tsort(par.begin(), par.end());\n\t\tcout << upper_bound(par.begin(), par.end(), y2) - lower_bound(par.begin(), par.end(), y1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_; std::vector<std::vector<Type> > dat;\n\tinline int query_(int a, int b, Type x, int k, int l, int r) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r)\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return lower_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();\n\t\tint lc = query_(a, b, x, (k << 1), l, (l + r) >> 1);\n\t\tint rc = query_(a, b, x, (k << 1) + 1, (l + r) >> 1, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::vector<Type>());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_] = std::vector<Type>({ *(begin_ + i) });\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[(i << 1) + 1].size());\n\t\t\tstd::merge(dat[i << 1].begin(), dat[i << 1].end(), dat[(i << 1) + 1].begin(), dat[(i << 1) + 1].end(), dat[i].begin());\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\treturn query_(l, r, x, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <vector>\n#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<list>\n#include<deque>\n#include<bitset>\n#include<set>\n#include<map>\n#include<unordered_map>\n#include<unordered_set>\n#include<cstring>\n#include<sstream>\n#include<complex>\n#include<iomanip>\n#include<numeric>\n#include<cassert>\n#define X first\n#define Y second\n#define pb emplace_back\n#define rep(X,Y) for (int (X) = 0;(X) < (Y);++(X))\n#define reps(X,S,Y) for (int (X) = S;(X) < (Y);++(X))\n#define rrep(X,Y) for (int (X) = (Y)-1;(X) >=0;--(X))\n#define rreps(X,S,Y) for (int (X) = (Y)-1;(X) >= (S);--(X))\n#define repe(X,Y) for ((X) = 0;(X) < (Y);++(X))\n#define peat(X,Y) for (;(X) < (Y);++(X))\n#define all(X) (X).begin(),(X).end()\n#define rall(X) (X).rbegin(),(X).rend()\n#define eb emplace_back\n#define UNIQUE(X) (X).erase(unique(all(X)),(X).end())\n#define Endl endl\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef ll LL;\ntypedef pii PII;\ntypedef pll PLL;\ntemplate<class T> using vv=vector<vector<T>>;\ntemplate<class T> ostream& operator<<(ostream &os, const vector<T> &t) {\nos<<\"{\"; rep(i,t.size()) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class T,size_t n> ostream& operator<<(ostream &os, const array<T,n> &t) {\n\tos<<\"{\"; rep(i,n) {os<<t[i]<<\",\";} os<<\"}\"<<endl; return os;}\ntemplate<class S, class T> ostream& operator<<(ostream &os, const pair<S,T> &t) { return os<<\"(\"<<t.first<<\",\"<<t.second<<\")\";}\ntemplate<class S, class T,class U> ostream& operator<<(ostream &os, const tuple<S,T,U> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\")\";}\ntemplate<class S, class T,class U,class V> ostream& operator<<(ostream &os, const tuple<S,T,U,V> &t) { return os<<\"(\"<<get<0>(t)<<\",\"<<get<1>(t)<<\",\"<<get<2>(t)<<\",\"<<get<3>(t)<<\")\";}\ntemplate<class T> inline bool MX(T &l,const T &r){return l<r?l=r,1:0;}\ntemplate<class T> inline bool MN(T &l,const T &r){return l>r?l=r,1:0;}\n//#undef NUIP\n#ifdef NUIP\n#define out(args...){vector<string> a_r_g_s=s_p_l_i_t(#args, ','); e_r_r(a_r_g_s.begin(), args); }\nvector<string> s_p_l_i_t(const string &s, char c){vector<string> v;int d=0,f=0;string t;for(char c:s){if(!d&&c==',')v.pb(t),t=\"\";else t+=c;if(c=='\\\"'||c=='\\'')f^=1;if(!f&&c=='(')++d;if(!f&&c==')')--d;}v.pb(t);return move(v);}\nvoid e_r_r(vector<string>::iterator it) {}\ntemplate<typename T, typename... Args> void e_r_r(vector<string>::iterator it, T a, Args... args){ if(*it==\" 1\"||*it==\"1\") cerr<<endl; else cerr << it -> substr((*it)[0] == ' ', it -> length()) << \" = \" << a << \", \"; e_r_r(++it, args...);}\n#else\n#define out\n#endif\n#ifdef __cpp_init_captures\ntemplate<typename T>vector<T> table(int n, T v){ return vector<T>(n, v);}\ntemplate <class... Args> auto table(int n, Args... args){auto val = table(args...); return vector<decltype(val)>(n, move(val));}\n#endif\nconst ll MOD=1e9+7;\n\ntemplate<int N>\nstruct FID {\n  using Bits = uint32_t;\n  static const int B = 8*sizeof(Bits);\n  static const int SZ = N/B+2;\n  int n;\n  array<int, SZ> buck;\n  array<Bits, SZ> bits;\n  array<int, SZ> sel[2];\n\n  FID() {}\n  FID(int n, bool bs[]) : n(n), buck(), bits() {\n    int cnt = 0;\n    int idx = 0;\n    rep(i, n/B + (n%B != 0)) {\n      rep(j, B) {\n        if (idx >= n) break;\n        cnt += bs[idx];\n        bits[i] |= Bits(bs[idx]) << j;\n        idx++;\n      }\n      buck[i+1] = cnt;\n    }\n    \n    rep(i, 2) sel[i].fill(-1);\n    cnt = 0;\n    rep(i, n) {\n      if (bs[i]) {\n        sel[1][cnt] = i;\n        cnt++;\n      } else {\n        sel[0][i-cnt] = i;\n      }\n    }\n  }\n\n  int Count(bool v, int r) {\n    int ret = buck[r/B] + __builtin_popcount(bits[r/B] % (1<<(r%B)));\n    if (!v) ret = r - ret;\n    return ret;\n  }\n\n  int Select(bool v, int k) {\n    if (k < 0 || k >= n) return -1;\n    return sel[v][k];\n  }\n\n  int SelectFrom(int from, bool v, int k) {\n    return Select(v, Count(v, from) + k);\n  }\n\n  bool operator[](int k) {\n    return bits[k/B] >> (k%B) & 1;\n  }\n};\n\ntemplate<int N, class T=unsigned int>          \nstruct Wavelet {\n  static const int D = 8*sizeof(T);\n  int n;\n  int sep[D];\n  FID<N> dat[D];\n  T arr[N];\n\n  Wavelet(int n, T ini[]) : n(n) {\n    T l[N];\n    T r[N];\n    T src[N];\n    bool bs[N];\n\n    copy(ini, ini+n, arr);\n    copy(ini, ini+n, src);\n    rep (d, D) {\n      int rk = 0;\n      int lk = 0;\n      rep(i, n) {\n        bool t = src[i] >> (D-d-1) & 1;\n        if (t) r[rk++] = src[i];\n        else l[lk++] = src[i];\n        bs[i] = t;\n      }\n      dat[d] = FID<N>(n, bs);\n      sep[d] = lk;\n      swap(l, src);\n      copy(r, r+rk, src+lk);\n    }\n  }\n\n  int Count(T val, int l, int r) {\n    if (r <= l) return 0;\n    rep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      l = dat[d].count(b, l) + b*sep[b];\n      r = dat[d].count(b, r) + b*sep[b];\n    }\n    return r-l;\n  }\n\n  int Select(T val, int k) {\n    int ls[D+1];\n    int rs[D+1];\n    ls[0] = 0;\n    rs[0] = n;\n    rep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      ls[d+1] = dat[d].count(b, ls[d]) + b*sep[b];\n      rs[d+1] = dat[d].count(b, rs[d]) + b*sep[b];\n    }\n    rrep(d, D) {\n      bool b = val >> (D-d-1) & 1;\n      k = dat[d].SelectFrom(ls[d], b, k);\n      if (k < 0 || k >= rs[d]) return -1;\n      k -= ls[d];\n    }\n    return k;\n  }\n\n  T KthNumber(int l, int r, int k) {\n    if (k < 0 || k >= r-l) assert(0);\n    T ret = 0;\n    rep(d, D) {\n      int lc = dat[d].Count(1, l);\n      int rc = dat[d].Count(1, r);\n      if (rc - lc > k) {\n        l = lc + sep[d];\n        r = rc + sep[d];\n        ret |= T(1) << (D-d-1);\n      } else {\n        k -= rc-lc;\n        l -= lc;\n        r -= rc;\n      }\n    }\n    return ret;\n  }\n\n  int FreqDfs(int d, int l, int r, T val, T a, T b) {\n    if (r <= l) return 0;\n    if (d == D) {\n      if (a <= val && val < b) return r-l;\n      return 0;\n    }\n\n    T h = T(1) << (D-d-1);\n    T nv = val | h; \n    T lim = nv | (h-1);\n    if (lim < a || b <= val) return 0;\n    if (a <= val && lim < b) return r-l;\n\n    int lc = dat[d].Count(1, l);\n    int rc = dat[d].Count(1, r);\n    int lval = FreqDfs(d+1, l-lc, r-rc, val, a, b);\n    int rval = FreqDfs(d+1, lc+sep[d], rc+sep[d], nv, a, b);\n    return lval + rval;\n  }\n\n  int Freq(int l, int r, T a, T b) {\n    return FreqDfs(0, l, r, 0, a, b);\n  }\n\n  T operator[](int k) {\n    return arr[k];\n  }\n};\n\nconst int GETA = 1e9;\nint N;\nint M;\nunsigned int ys[114514];\nvector<PII> ps;\n\nint main() {\n  scanf(\"%d%d\", &N, &M);\n  rep(i, N) {\n    int x, y;\n    scanf(\"%d%d\", &x, &y);\n    y += GETA;\n    ps.emplace_back(PII(x, y));\n  }\n  sort(all(ps));\n \n  rep(i, N) ys[i] = ps[i].second;\n  Wavelet<5000> wave(N, ys);\n\n  rep(i, M) {\n    int a, b, c, d;\n    scanf(\"%d%d%d%d\", &a, &b, &c, &d);\n    b += GETA;\n    d += GETA;\n    int x = lower_bound(all(ps), PII(a, 0)) - ps.begin();\n    int y = upper_bound(all(ps), PII(c, GETA*2)) - ps.begin();\n    printf(\"%d\\n\", wave.Freq(x, y, b, d+1));\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[6000], Y[6000];\nint X1[600000], X2[600000], Y1[600000], Y2[600000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tauto it = unique(v.begin(), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), it, X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), it, X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), it, x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[5001], sy[5001];\nint tx[5001], ty[5001];\nint vx[5001];\nint vy[5001];\nshort bit[33330][33330];\n\nvoid add(int a, int b, int w)\n{\n  for(int x = a; x <= 6 * n; x += x & -x){\n    for(int y = b; y <= 6 * n; y += y & -y){\n      bit[x][y] += w;\n    }\n  }\n}\n\nint sum(int a, int b)\n{\n  int ret = 0;\n  for(int x = a; x > 0; x -= x & -x){\n    for(int y = b; y > 0; y -= y & -y){\n      ret += bit[x][y];\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n  \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);  x.pb(sx[i]);  x.pb(tx[i]);\n    y.pb(vy[i]);  y.pb(sy[i]);  y.pb(ty[i]);\n  }\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin() + 1;\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin() + 1;\n  }\n  rep(i, m){\n    sx[i] = lower_bound(ALL(x), sx[i]) - x.begin() + 1;\n    sy[i] = lower_bound(ALL(y), sy[i]) - y.begin() + 1;\n    tx[i] = lower_bound(ALL(x), tx[i]) - x.begin() + 1;\n    ty[i] = lower_bound(ALL(y), ty[i]) - y.begin() + 1;\n  }\n  rep(i, n) add(vx[i], vy[i], 1);\n\n  rep(i, m){\n    int ret = 0;\n    ret += sum(tx[i], ty[i]);\n    ret += sum(sx[i] - 1, sy[i] - 1);\n    ret -= sum(sx[i] - 1, ty[i]);\n    ret -= sum(tx[i], sy[i] - 1);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define INF_LL (int64)1e18\n#define INF (int32)1e9\n#define REP(i, n) for(int64 i = 0;i < (n);i++)\n#define FOR(i, a, b) for(int64 i = (a);i < (b);i++)\n#define all(x) x.begin(),x.end()\n#define fs first\n#define sc second\n\nusing int32 = int_fast32_t;\nusing uint32 = uint_fast32_t;\nusing int64 = int_fast64_t;\nusing uint64 = uint_fast64_t;\nusing PII = pair<int32, int32>;\nusing PLL = pair<int64, int64>;\n\nconst double eps = 1e-10;\n\ntemplate<typename A, typename B>inline void chmin(A &a, B b){if(a > b) a = b;}\ntemplate<typename A, typename B>inline void chmax(A &a, B b){if(a < b) a = b;}\n\ntemplate<typename T>\nvector<T> make_v(size_t a){return vector<T>(a);}\n\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts){\n  return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value!=0>::type\nfill_v(U &u,const V... v){u=U(v...);}\n\ntemplate<typename T,typename U,typename... V>\ntypename enable_if<is_same<T, U>::value==0>::type\nfill_v(U &u,const V... v){\n  for(auto &e:u) fill_v<T>(e,v...);\n}\n\ntemplate<::std::uint_fast64_t mod>\nclass ModInt{\nprivate:\n  using value_type = ::std::uint_fast64_t;\n  value_type n;\npublic:\n  ModInt() : n(0) {}\n  ModInt(value_type n_) : n(n_ % mod) {}\n  ModInt(const ModInt& m) : n(m.n) {}\n\n  template<typename T>\n  explicit operator T() const { return static_cast<T>(n); }\n  value_type get() const { return n; }\n\n  friend ::std::ostream& operator<<(::std::ostream &os, const ModInt<mod> &a) {\n    return os << a.n;\n  }\n\n  friend ::std::istream& operator>>(::std::istream &is, ModInt<mod> &a) {\n    value_type x;\n    is >> x;\n    a = ModInt<mod>(x);\n    return is;\n  }\n\n  bool operator==(const ModInt& m) const { return n == m.n; }\n  bool operator!=(const ModInt& m) const { return n != m.n; }\n  ModInt& operator*=(const ModInt& m){ n = n * m.n % mod; return *this; }\n\n  ModInt pow(value_type b) const{\n    ModInt ans = 1, m = ModInt(*this);\n    while(b){\n      if(b & 1) ans *= m;\n      m *= m;\n      b >>= 1;\n    }\n    return ans;\n  }\n\n  ModInt inv() const { return (*this).pow(mod-2); }\n  ModInt& operator+=(const ModInt& m){ n += m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator-=(const ModInt& m){ n += mod - m.n; n = (n < mod ? n : n - mod); return *this; }\n  ModInt& operator/=(const ModInt& m){ *this *= m.inv(); return *this; }\n  ModInt operator+(const ModInt& m) const { return ModInt(*this) += m; }\n  ModInt operator-(const ModInt& m) const { return ModInt(*this) -= m; }\n  ModInt operator*(const ModInt& m) const { return ModInt(*this) *= m; }\n  ModInt operator/(const ModInt& m) const { return ModInt(*this) /= m; }\n  ModInt& operator++(){ n += 1; return *this; }\n  ModInt& operator--(){ n -= 1; return *this; }\n  ModInt operator++(int){\n    ModInt old(n);\n    n += 1;\n    return old;\n  }\n  ModInt operator--(int){\n    ModInt old(n);\n    n -= 1;\n    return old;\n  }\n  ModInt operator-() const { return ModInt(mod-n); }\n};\n\ntemplate<::std::size_t size, ::std::uint_fast64_t mod=1000000007>\nclass Factorial{\nprivate:\n  using value_type = ModInt<mod>;\n  ::std::vector<value_type> fact, inv;\npublic:\n  Factorial() : fact(size+1, 1), inv(size+1, 1){\n    for(::std::size_t i = 1; i <= size; ++i){\n      fact[i] = fact[i-1] * value_type(i);\n      inv[i] = fact[i].inv();\n    }\n  }\n\n  value_type comb(::std::int64_t a, ::std::int64_t b){\n    assert(a >= b);\n    assert(b >= 0);\n    return fact[a]*inv[b]*inv[a-b];\n  }\n\n  value_type& operator[](::std::size_t k){ return fact[k]; }\n};\n\nclass UnionFind{\nprivate:\n  ::std::vector<int_fast32_t> par;\n  size_t n;\n\npublic:\n  UnionFind(){}\n  UnionFind(size_t n):n(n){\n    par.resize(n, -1);\n  }\n\n  uint_fast32_t find(uint_fast32_t x){\n    return par[x] < 0 ? x : par[x] = find(par[x]);\n  }\n\n  size_t size(uint_fast32_t x){\n    return -par[find(x)];\n  }\n\n  bool unite(uint_fast32_t x, uint_fast32_t y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return false;\n    if(size(x) < size(y)) std::swap(x, y);\n    par[x] += par[y];\n    par[y] = x;\n    return true;\n  }\n\n  bool same(uint_fast32_t x, uint_fast32_t y){\n    return find(x) == find(y);\n  }\n};\n\n\nconstexpr int64 mod = 1e9+7;\nusing Mint = ModInt<mod>;\n//Factorial<2123456> f;\n\nint main(void) {\n  int64 n, m;\n  cin >> n >> m;\n  vector<int64> xs(n), ys(n), x(n), y(n);\n  REP(i, n) {\n    cin >> xs[i] >> ys[i];\n    x[i] = xs[i]; y[i] = ys[i];\n  }\n  xs.push_back(-2*INF); xs.push_back(INF*2);\n  ys.push_back(-2*INF); ys.push_back(INF*2);\n  sort(all(xs)); xs.erase(unique(all(xs)), xs.end());\n  sort(all(ys)); ys.erase(unique(all(ys)), ys.end());\n  REP(i, n) x[i] = lower_bound(all(xs), x[i]) - xs.begin();\n  REP(i, n) y[i] = lower_bound(all(ys), y[i]) - ys.begin();\n\n  vector<vector<int64>> sum(ys.size()+1, vector<int64>(xs.size()+1, 0));\n  REP(i, n) {\n    sum[y[i]][x[i]]++;\n  }\n//  REP(i, ys.size()) {\n//    REP(j, xs.size()) {\n//      cout << sum[i][j] << \" \";\n//    }\n//    cout << endl;\n//  }\n  REP(i, ys.size()) {\n    REP(j, xs.size()) {\n//      cout << sum[i][j] << \" \";\n      if (i > 0 && j > 0) {\n        sum[i][j] -= sum[i-1][j-1];\n      }\n      sum[i+1][j] += sum[i][j];\n      sum[i][j+1] += sum[i][j];\n    }\n//    cout << endl;\n  }\n  REP(i, m) {\n    int64 x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = lower_bound(all(xs), x1)-xs.begin();\n    x2 = upper_bound(all(xs), x2)-xs.begin()-1;\n    y1 = lower_bound(all(ys), y1)-ys.begin();\n    y2 = upper_bound(all(ys), y2)-ys.begin()-1;\n//    cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n    int64 res = sum[y2][x2]-sum[y2][x1-1]-sum[y1-1][x2]+sum[y1-1][x1-1];\n    cout << res << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "// Enjoy your stay.\n\n#include <bits/stdc++.h>\n\n#define EPS 1e-9\n#define INF 1070000000LL\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(auto it=(X).begin();it!=(X).end();it++)\n#define ite iterator\n#define mp make_pair\n#define mt make_tuple\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<(n);i++)\n#define pb push_back\n#define sec second\n#define sz(x) ((int)(x).size())\n\nusing namespace std;\n\ntypedef istringstream iss;\ntypedef long long ll;\ntypedef pair<ll,ll> pi;\ntypedef stringstream sst;\ntypedef vector<ll> vi;\n\nint n,m,y[5555],x[5555];\nint sum[5555][5555];\nvi zy,zx;\n\nint f(int Y,int X){\n\treturn sum[upper_bound(zy.begin(),zy.end(),Y)-zy.begin()]\n\t\t[upper_bound(zx.begin(),zx.end(),X)-zx.begin()];\n}\n\nint main(){\n\tcin.tie(0);\n\tios_base::sync_with_stdio(0);\n\t\n\tcin>>n>>m;\n\trep(i,n){\n\t\tcin>>y[i]>>x[i];\n\t\tzy.pb(y[i]);\n\t\tzx.pb(x[i]);\n\t}\n\tzy.pb(INF);zx.pb(INF);\n\tsort(zy.begin(),zy.end());\n\tsort(zx.begin(),zx.end());\n\trep(i,n){\n\t\tsum[upper_bound(zy.begin(),zy.end(),y[i])-zy.begin()]\n\t\t[upper_bound(zx.begin(),zx.end(),x[i])-zx.begin()]++;\n\t}\n\trep2(i,1,sz(zy)+1)rep2(j,1,sz(zx)+1){\n\t\tsum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n\t}\n\trep(i,m){\n\t\tint y1,x1,y2,x2;\n\t\tcin>>y1>>x1>>y2>>x2;\n\t\tcout<<f(y2,x2) - f(y1-1,x2) - f(y2,x1-1) + f(y1-1,x1-1)<<endl; \n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <vector>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\nint n,m;\nvector<int> xindex;\nvector<int> yindex;\nint fie[5001][5001];\nint x[5001],y[5001];\n\nint main(void){\n\tscanf(\"%d %d\",&n,&m);\n\txindex.push_back(-2e9);\n\tyindex.push_back(-2e9);\n\tfor(int i=0;i<n;i++){\n\t\tscanf(\"%d %d\",&x[i],&y[i]);\n\t\txindex.push_back(x[i]);\n\t\tyindex.push_back(y[i]);\n\t}\n\tsort(xindex.begin(),xindex.end());\n\txindex.erase(unique(xindex.begin(),xindex.end()),xindex.end());\n\tsort(yindex.begin(),yindex.end());\n\tyindex.erase(unique(yindex.begin(),yindex.end()),yindex.end());\n\tfor(int i=0;i<n;i++){\n\t\tx[i]=lower_bound(xindex.begin(),xindex.end(),x[i])-xindex.begin();\n\t\ty[i]=lower_bound(yindex.begin(),yindex.end(),y[i])-yindex.begin();\n\t\tfie[x[i]][y[i]]++;\n\t}\n\tfor(int i=0;i<yindex.size();i++){\n\t\tfor(int j=1;j<xindex.size();j++){\n\t\t\tfie[j][i]+=fie[j-1][i];\n\t\t}\n\t}\n\tfor(int i=0;i<xindex.size();i++){\n\t\tfor(int j=1;j<yindex.size();j++){\n\t\t\tfie[i][j]+=fie[i][j-1];\n\t\t}\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint lx,rx,ly,ry;\n\t\tscanf(\"%d %d %d %d\",&lx,&ly,&rx,&ry);\n\t\tlx=upper_bound(xindex.begin(),xindex.end(),lx-1)-xindex.begin();\n\t\trx=upper_bound(xindex.begin(),xindex.end(),rx)-xindex.begin();\n\t\tly=upper_bound(yindex.begin(),yindex.end(),ly-1)-yindex.begin();\n\t\try=upper_bound(yindex.begin(),yindex.end(),ry)-yindex.begin();\n\t\tlx--;\n\t\trx--;\n\t\tly--;\n\t\try--;\n\t\tprintf(\"%d\\n\",fie[rx][ry]-fie[lx][ry]-fie[rx][ly]+fie[lx][ly]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n\nconst int INF = 1e9+1;\nint v[5002][5002] = {};\n\nint main(){\n    int n, m;\n    scanf(\"%d %d\", &n, &m);\n    vector<int> x(n), y(n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d %d\", x.begin()+i, y.begin()+i);\n    }\n    vector<int> ax = x, ay = y;\n    ax.push_back(-INF); ax.push_back(INF);\n    ay.push_back(-INF); ay.push_back(INF);\n    sort(ax.begin(), ax.end());\n    ax.erase(unique(ax.begin(),ax.end()),ax.end());\n    sort(ay.begin(), ay.end());\n    ay.erase(unique(ay.begin(),ay.end()),ay.end());\n    int nx = ax.size(), ny = ay.size();\n    auto fx = [&](int val)->int{\n        return lower_bound(ax.begin(),ax.end(),val)-ax.begin();\n    };\n    auto fy = [&](int val)->int{\n        return lower_bound(ay.begin(), ay.end(), val)-ay.begin();\n    };\n    for(int i = 0; i < n; i++){\n        v[fx(x[i])][fy(y[i])]++;\n    }\n    for(int i = 0; i < nx; i++){\n        for(int j = 1; j < ny; j++){\n            v[i][j] += v[i][j-1];\n        }\n    }\n    for(int j = 0; j < ny; j++){\n        for(int i = 1; i < nx; i++){\n            v[i][j] += v[i-1][j];\n        }\n    }\n    auto get = [&](int lx, int rx, int ly, int ry)->int{\n        return v[rx][ry]-v[rx][ly-1]-v[lx-1][ry]+v[lx-1][ly-1];\n    };\n    for(int i = 0; i < m; i++){\n        int a, b, c, d;\n        scanf(\"%d %d %d %d\", &a, &b, &c, &d);\n        cout << get(fx(a),fx(c+1)-1,fy(b),fy(d+1)-1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_; std::vector<std::vector<Type> > dat;\n\tinline int query_(int a, int b, Type x, int k, int l, int r) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r)\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return lower_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::vector<Type>());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_] = std::vector<Type>({ *(begin_ + i) });\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tint cl = 0, cr = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][cr])) {\n\t\t\t\t\tdat[i][j] = dat[i << 1][cl++];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdat[i][j] = dat[i << 1][j - cl];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\treturn query_(l, r, x, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Node{\n\tint location;\n\tint p,left,right;\n};\n\nstruct Point{\n\tPoint(){\n\t\tid = x = y = 0;\n\t}\n\n\tPoint(int arg_id,int arg_x,int arg_y){\n\t\tid = arg_id;\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\tbool operator < (const Point & arg)const{\n\t\treturn id < arg.id;\n\t}\n\tvoid print(){\n\t\tprintf(\"%d\\n\",id);\n\t}\n\tint id,x,y;\n};\n\nstatic const int MAX = 10000;\nstatic const int NIL = -BIG_NUM;\n\nint N;\nPoint P[MAX];\nNode T[MAX];\nint number;\n\nbool lessX(const Point &p1, const Point &p2) {return p1.x < p2.x; }\nbool lessY(const Point &p1, const Point &p2) {return p1.y < p2.y; }\n\nint makeKDTree(int left,int right, int depth){\n\n\tif(!(left < right))return NIL;\n\n\tint mid = (left+right)/2;\n\n\tint node_id = number++;\n\n\tif(depth%2 == 0){\n\t\tsort(P+left,P+right,lessX);\n\t}else{\n\t\tsort(P+left,P+right,lessY);\n\t}\n\n\tT[node_id].location = mid;\n\tT[node_id].left = makeKDTree(left,mid,depth+1);\n\tT[node_id].right = makeKDTree(mid+1,right,depth+1);\n\n\treturn node_id;\n}\n\nvoid find(int node_id,int sx,int tx,int sy,int ty, int depth, vector<Point> &ans){\n\n\tint x = P[T[node_id].location].x;\n\tint y = P[T[node_id].location].y;\n\n\tif(sx <= x && x <= tx && sy <= y && y <= ty){\n\t\tans.push_back(P[T[node_id].location]);\n\t}\n\n\tif(depth%2 == 0){\n\t\tif(T[node_id].left != NIL){\n\t\t\tif(sx <= x)find(T[node_id].left,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t\tif(T[node_id].right != NIL){\n\t\t\tif( x <= tx)find(T[node_id].right,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t}else{\n\t\tif(T[node_id].left != NIL){\n\t\t\tif(sy <= y)find(T[node_id].left,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t\tif(T[node_id].right != NIL){\n\t\t\tif(y <= ty)find(T[node_id].right,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint M;\n\n\tint x,y;\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tP[i] = Point(i,x,y);\n\t\tT[i].left = T[i].right = T[i].p = NIL;\n\t}\n\n\tnumber = 0;\n\n\tint root = makeKDTree(0,N,0);\n\n\tint sx,tx,sy,ty;\n\tvector<Point> ans;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n\t\tans.clear();\n\t\tfind(root,sx,tx,sy,ty,0,ans);\n\t\t//sort(ans.begin(),ans.end());\n\t\tprintf(\"%lld\\n\",ans.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m;\npair<int, int> x[10000];\nint a, b, c, d, e, f, sum, l, r, m;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &x[i].first, &x[i].second);\n\t}\n\tsort(x, x + n);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tsum = 0;\n\t\tl = 0; r = n; m = n / 2;\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tm = (l + r) / 2;\n\t\t\tif (x[m].first < a) {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\tif (x[m].first > a) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\te = m;\n\t\tl = 0; r = 0;\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tm = (l + r) / 2;\n\t\t\tif (x[m].first < a) {\n\t\t\t\tl = m;\n\t\t\t}\n\t\t\tif (x[m].first > a) {\n\t\t\t\tr = m;\n\t\t\t}\n\t\t}\n\t\tf = m;\n\t\tfor (int j = e; j <= f; j++) {\n\t\t\tif (a <= x[j].first) {\n\t\t\t\tif (x[j].first <= c) {\n\t\t\t\t\tif (b <= x[j].second) {\n\t\t\t\t\t\tif (x[j].second <= d) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvoid hoge(vector<int> &v) {\n  sort(ALL(v));\n  v.erase(unique(ALL(v)), v.end());\n}\n\nint x[5000], y[5000], num[5000];\nint a[5001][5001];\nint sum[5001][5001];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> xs, ys;\n  REP(i,n) {\n    cin >> x[i] >> y[i];\n    xs.push_back(x[i]);\n    ys.push_back(y[i]);\n  }\n  hoge(xs);\n  hoge(ys);\n  REP(i,n) {\n    int yy = lower_bound(ALL(ys),y[i]) - ys.begin();\n    int xx = lower_bound(ALL(xs),x[i]) - xs.begin();\n    a[yy][xx]++;\n    //cout << yy << \" \" << xx << endl;\n  }\n  REP(i,ys.size()) {\n    REP(j,xs.size()) {\n      sum[i+1][j+1] = sum[i][j+1] + sum[i+1][j] - sum[i][j] + a[i][j];\n    }\n  }\n  REP(i,m) {\n    int xx1, yy1,xx2, yy2;\n    cin >> xx1 >> yy1 >> xx2 >> yy2;\n\n    int x2 = lower_bound(ALL(xs),xx1) - xs.begin();\n    int y2 = lower_bound(ALL(ys),yy1) - ys.begin();\n    int x1 = upper_bound(ALL(xs),xx2) - xs.begin();\n    int y1 = upper_bound(ALL(ys),yy2) - ys.begin();\n    //cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n    int res = sum[y1][x1]+sum[y2][x2]-sum[y1][x2]-sum[y2][x1];\n    cout << res << endl;\n    \n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nconst ll segN=(1LL<<32);\nvector<ll> G;\nstruct data{\n  vector<ll> *v;\n  bool flg;\n  data* ch[2];\n  \n  void init(){\n    v=new vector<ll>;\n    flg=false;\n    ch[0]=(data*)malloc(sizeof(data));\n    ch[1]=(data*)malloc(sizeof(data));\n    ch[0]->ch[0]=NULL;\n    ch[1]->ch[0]=NULL;\n  }\n  \n  void add(ll i,ll x,ll l,ll r){\n    //    cout<<i<<' '<<x<<' '<<l<<' '<<r<<endl;\n    ll m=(l+r)/2;\n    if(ch[0]==NULL)init();\n    if(i<l || r<=i)return;\n    v->push_back(x);\n    if(r-l==1)return;\n    ch[0]->add(i,x,l,m);\n    ch[1]->add(i,x,m,r);\n  }\n   \n  void add(ll i,ll x){\n    add(i,x,0,segN);\n  }\n  \n  ll sum(ll a,ll b,ll c,ll d,ll l,ll r){\n    ll m=(l+r)/2;\n    if(ch[0]==NULL)init();\n    if(b<=l || r<=a)return 0;\n    if(a<=l && r<=b){\n      if(!flg)sort(v->begin(),v->end());\n      flg=true;      \n      vector<ll> :: iterator A,B;\n      A=lower_bound(v->begin(),v->end(),c);\n      B=upper_bound(v->begin(),v->end(),d);\n      return B-A;\n    }\n    \n    ll res=0;\n    res+=ch[0]->sum(a,b,c,d,l,m);\n    res+=ch[1]->sum(a,b,c,d,m,r);\n    return res;\n  }\n \n  ll sum(ll a,ll b,ll c,ll d){\n    return sum(a,b,c,d,0,segN);\n  }\n};\n \n \n   \n\ndata T;\n \nint main(){\n  ll d=1e9;\n  int n,m;\n  int ax,ay,bx,by;\n  T.init();\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d %d\",&ax,&ay);\n    T.add(ax+d,ay);\n  }\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d %d\",&ax,&ay,&bx,&by);\n    cout<<T.sum(ax+d,bx+d+1,ay,by)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint x[5000],y[5000];\nint main(){\n\tint n,m,tmp;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\tfor(int i=0;i<n-1;i++){for(int j=n-1;j>i;j--){if(x[j]<x[j-1]){tmp=x[j],x[j]=x[j-1],x[j-1]=tmp;tmp=y[j],y[j]=y[j-1],y[j-1]=tmp;}}}\n\tint leftx,rightx,lefty,righty;\n\tfor(int u=0;u<m;u++){\n\t\tcin>>leftx>>lefty>>rightx>>righty;\n\t\tint bef,aft;\n\t\tint left=0,right=n,mid;\n\t\twhile(true){\n\t\t\tif(right<=left+1)\n\t\t\t\tbreak;\n\t\t\tmid=(right+left)/2;\n\t\t\tif(x[mid]>=leftx)\n\t\t\t\tright=mid;\n\t\t\telse\n\t\t\t\tleft=mid;\n\t\t}\n\t\tbef=max(0,mid-1);\n\t\tleft=0,right=n;\n\t\twhile(true){\n\t\t\tif(right<=left+1)\n\t\t\t\tbreak;\n\t\t\tmid=(right+left)/2;\n\t\t\tif(x[mid]<=rightx)\n\t\t\t\tleft=mid;\n\t\t\telse\n\t\t\t\tright=mid;\n\t\t}\n\t\taft=min(n-1,mid+1);\n\t\tint ans=0;\n\t\tfor(int i=bef;i<=aft;i++){if(x[i]>=leftx&&x[i]<=rightx&&y[i]>=lefty&&y[i]<=righty)ans++;}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  vector<pair<int,int> >pii(n);\n  for(int i=0;i<n;i++){\n    cin>>pii[i].F>>pii[i].S;\n  }\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    ll cnt=0;\n    for(int j=0;j<n;j++){\n      if((x1<=pii[j].F&&pii[j].F<=x2)&&y1<=pii[j].S&&pii[j].S<=y2)\n\tcnt++;\n    }\n    cout<<cnt<<endl;\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\ntypedef complex<int> point;\n\nstruct kdtree {\n  struct node {\n    point p;\n\tint id;\n    node *l, *r;\n    node(const point &p,int _id)\n      : p(p), l(NULL), r(NULL), id(_id) { }\n  } *root;\n  int id;\n  kdtree() : root(NULL), id(0) { }\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n  void insert(const point &p) {\n    root = insert(root, 0, p);\n  }\n  node *insert(node *t, int d, const point &p) {\n    if (t == NULL) return new node(p,id++);\n    if (compare(d,p,t->p)) t->l = insert(t->l, !d, p);\n    else                   t->r = insert(t->r, !d, p);\n    return t;\n  }\n  void search(const point &ld, const point &ru, vector<int> &out) {\n    search(root, 0, ld, ru, out);\n  }\n  void search(node *t, int d, const point &ld, const point &ru, vector<int> &out) {\n    if (t == NULL) return;\n    const point &p = t->p;\n    if (real(ld) <= real(p) && real(p) <= real(ru) &&\n        imag(ld) <= imag(p) && imag(p) <= imag(ru)) out.push_back(t->id);\n    if (!compare(d,p,ld)) search(t->l, !d, ld, ru, out);\n    if (!compare(d,ru,p)) search(t->r, !d, ld, ru, out);\n  }\n};\n\nint main(){\n\tint n,m,x1,x2,y1,y2;\n\tkdtree kd;\n\tfor(scanf(\"%d%d\",&n,&m);n--;){\n\t\tscanf(\"%d%d\",&x1,&y1);\n\t\tkd.insert(point(x1,y1));\n\t}\n\tfor(;m--;){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tvector<int>out;\n\t\tkd.search(point(x1,y1),point(x2,y2),out);\n\t\tprintf(\"%d\\n\",out.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// iostream のscanf, printf では間に合わなかった\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define mp make_pair\n#define pb push_back\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t//scanf(\"%d %d\", &x, &y);\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t//scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\twhile( 1 ){\n\t\t\tif( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\tcout << ans << endl;\n\t\t//printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(vector<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\tvector<int> treasure;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\ttreasure.push_back(Count(pos, x1, y1, x2, y2));\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tcout << treasure[i] << \"\\n\";\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass Node{\npublic:\n  int location;\n  int p,l,r;\n  Node(){}\n};\nclass Point{\npublic:\n  int id,x,y;\n  Point(){}\n  Point(int id,int x,int y): id(id),x(x),y(y){}\n  bool operator<(const Point &p)const{\n    return id<p.id;\n  }\n  void print(){\n    printf(\"%d\\n\",id);\n  }\n};\nstatic const int MAX = 5005;\nstatic const int NIL = -1;\n \nint N;\nPoint P[MAX];\nNode T[MAX];\nint np;\n \nbool lessX(const Point &p1,const Point &p2){return p1.x<p2.x;}\nbool lessY(const Point &p1,const Point &p2){return p1.y<p2.y;}\n \nint makeKDTree(int l,int r,int depth){\n  if(!(l<r)) return NIL;\n  int mid=(l+r)/2;\n  int t = np++;\n  if(depth%2==0){\n    sort(P+l,P+r,lessX);\n  }else{\n    sort(P+l,P+r,lessY);\n  }\n  T[t].location=mid;\n  T[t].l = makeKDTree(l,mid,depth+1);\n  T[t].r = makeKDTree(mid+1,r,depth+1);\n \n  return t;\n}\n\nint ans;\n \nvoid find(int v,int sx,int tx,int sy,int ty,int depth){\n  int x=P[T[v].location].x;\n  int y=P[T[v].location].y;\n \n \n  if(sx<=x&&x<=tx&&sy<=y&&y<=ty){\n    ans++;\n  }\n \n  if(depth%2==0){\n    if(T[v].l!=NIL){\n      if(sx<=x) find(T[v].l,sx,tx,sy,ty,depth+1);\n    }\n    if(T[v].r!=NIL){\n      if(x<=tx) find(T[v].r,sx,tx,sy,ty,depth+1);\n    }\n  }else{\n    if(T[v].l!=NIL){\n      if(sy<=y) find(T[v].l,sx,tx,sy,ty,depth+1);\n    }\n    if(T[v].r!=NIL){\n      if(y<=ty) find(T[v].r,sx,tx,sy,ty,depth+1);\n    }\n  }\n   \n} \n    \nint main(){\n  int x,y;\n  scanf(\"%d\",&N);\n  int q;\n  scanf(\"%d\",&q);\n  for(int i=0;i<N;i++) {\n    scanf(\"%d %d\",&x,&y);\n    P[i]=Point(i,x,y);\n    T[i].l = T[i].r = T[i].p = NIL;\n  }\n  np=0;\n  int root=makeKDTree(0,N,0);\n \n  int sx,tx,sy,ty;\n\n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    ans=0;\n    find(root,sx,tx,sy,ty,0);\n    printf(\"%d\\n\",ans);\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\nvoid uniqueVector(vector< int >& vec) {\n\tsort(allof(vec));\n\tvec.erase(unique(allof(vec)), vec.end());\n}\n\nvoid solve(\n\tint n, int m,\n\tconst vector< int >& tx, const vector< int >& ty\n\t) {\n\tvector< int > x_sort = tx, y_sort = ty;\n\tuniqueVector(x_sort);\n\tuniqueVector(y_sort);\n\t\n\tvector< vector< int > > imos(n + 1, vector< int >(n + 1, 0));\n\tfor_(i,0,n) {\n\t\tint x = lower_bound(allof(x_sort), tx[i]) - x_sort.begin() + 1;\n\t\tint y = lower_bound(allof(y_sort), ty[i]) - y_sort.begin() + 1;\n\t\t++imos[y][x];\n\t}\n\t\n\tfor_(y,0,n+1) for_(x,0,n) imos[y][x + 1] += imos[y][x];\n\tfor_(x,0,n+1) for_(y,0,n) imos[y + 1][x] += imos[y][x];\n\t\n\tfor_(i,0,m) {\n\t\tint lft, bot, rgt, top\n\t\tscanf(\"%d %d %d %d\", &lft, &bot, &rgt, &top);\n\t\t\n\t\tint lx = lower_bound(allof(x_sort), lft) - x_sort.begin() + 1;\n\t\tint by = lower_bound(allof(y_sort), bot) - y_sort.begin() + 1;\n\t\tint rx = upper_bound(allof(x_sort), rgt) - x_sort.begin();\n\t\tint ty = upper_bound(allof(y_sort), top) - y_sort.begin();\n\t\t\n\t\tprintf(\"%d\\n\", imos[ty][rx] - imos[ty][lx - 1] - imos[by - 1][rx] + imos[by - 1][lx - 1]);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tvector< int > tx(n), ty(n);\n\tfor_(i,0,n) scanf(\"%d %d\", &tx[i], &ty[i]);\n\t\n\tsolve(n, m, tx, ty);\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define INF 1000000001\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, m;\nvector<P> v;\n\nint main(){\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,n){\n\t\tint x, y;\n\t\tscanf(\"%d%d\",&x,&y);\n\t\tv.push_back(P(x,y));\n\t}\n\tsort(v.begin(),v.end());\n\trep(i,m){\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tint sx = 0, ex = n-1, smid;\n\t\tint s, e;\n\t\tint cnt = 0;\n\t\twhile(ex-sx > 1){\n\t\t\tsmid = (sx+ex)/2;\n\t\t\tif(v[smid].first >= x1) ex = smid;\n\t\t\telse sx = smid;\n\t\t}\n\t\t//cout << sx << \" \" << ex << endl;\n\t\ts = sx;\n\t\tsx = 0; ex = n-1;\n\t\twhile(ex-sx > 1){\n\t\t\tsmid = (sx+ex)/2;\n\t\t\tif(v[smid].first <= x2) sx = smid;\n\t\t\telse ex = smid;\n\t\t}\n\t\t//cout << sx << \" \" << ex << endl;\n\t\te = ex;\n\t\te = ex;\n\t\tif(x1 <= v[s].first && v[s].first <= x2 && y1 <= v[s].second && v[s].second <= y2) cnt++;\n\t\tif(x1 <= v[e].first && v[e].first <= x2 && y1 <= v[e].second && v[e].second <= y2) cnt++;\n\t\t\n\t\tfor(int j = s+1; j <= e-1; j++) if(y1 <= v[j].second && v[j].second <= y2) cnt++;\n\t\tcout << cnt << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// Author :\n// Date :\n// Problem:\n// Solution:\n// Comment:\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n\n#define pp push\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n\nusing namespace std;\n\nvector < pair <int,int> > pts;\n\nmain(){\n    int n , m;\n    int x , y;\n    \n    scanf(\"%d%d\",&n,&m);\n    \n    for(int i = 0 ; i < n ; i++){\n        scanf(\"%d %d\",&x,&y);\n        pts.pb(mp(x,y));\n    }\n    \n    int xx,yy;\n    \n    sort( pts.begin() , pts.end() );\n    \n    for(int i = 0 ; i < m ; i++){\n        int cnt = 0;\n        \n        scanf(\"%d %d %d %d\",&x,&y,&xx,&yy);\n        \n        for(int j = 0 ; j < n ; j++){\n            if(x <= pts[j].xx && xx >= pts[j].xx && y <= pts[j].yy && yy >= pts[j].yy){\n                cnt++;\n            }\n            if(x > pts[j].xx && xx < pts[j].xx) break;\n        }\n        printf(\"%d\\n\",cnt);\n    }\n\n    #ifdef GEREL\n        for(;;);\n    #endif\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) { cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl; }\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//pair?????????\ntemplate<typename T1, typename T2>\nostream &operator << (ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\n\n//??§?¨???§???\n//v: ??§???????????§?¨??????? ????????????\ntemplate<typename T>\nvoid compress(vector<T> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\n//??§?¨???§???(map)\n//v: ??§???????????§?¨??????? ????????????\n//?????????: zip[??§???????????§?¨?]:??§???????????§?¨? (zip.size()<=10^5?????????????????????)\ntemplate<typename T>\nmap<T, T> compressMap(vector<T> &v) {\n\tmap<T, T> zip;\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (T i = 0; i < v.size(); i++) zip[v[i]] = i;\n\treturn zip;\n}\n\n//??§???????????§?¨?\n//index(??§???????????§?¨?, ??§???????????§?¨??????????(??????) )\ntemplate<typename T>\nint index(vector<T> v, T i) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\n//2?¬????imos???\nclass Imos {\npublic:\n\tusing vvi = vector<vector<int> >;\n\tint X, Y;\n\tvvi s; //?´???????\n\t//f:field\n\tImos(vvi f) {\n\t\tX = f.size();\n\t\tY = f[0].size();\n\t\t//one-based\n\t\t//(x,y)?????§????´??????????(x+1,y+1)\n\t\ts = vvi(X + 1, vector<int>(Y + 1));\n\t\tfor (int y = 0; y < Y; y++)\n\t\t\tfor (int x = 0; x < X; x++)\n\t\t\t\ts[x + 1][y + 1] += s[x + 1][y] + s[x][y + 1] - s[x][y] + f[x][y];\n\t}\n\t//[x1,x2)??????[y1,y2)???field??????????±???????\n\t//one-based????????????????§?\n\tint sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x2][y1] - s[x1][y2] + s[x1][y1]; }\n};\n\nint main() {\n\t//int xs[MAX], ys[MAX];\n\tint n, m; cin >> n >> m;\n\tvector<int> xs(n), ys(n);\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &xs[i], &ys[i]);\n\t\tx[i] = xs[i]; y[i] = ys[i];\n\t}\n\tcompress(x);\n\tcompress(y);\n\n\t//map<int, int> zipx(compressMap(x));\n\t//map<int, int> zipy(compressMap(y));\n\t//dump(x);\n\t//dump(zipx);\n\t//dump(y);\n\t//dump(zipy);\n\n\tvector<vector<int> >f(x.size(), vector<int>(y.size()));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint vx = index(x, xs[i]);\n\t\tint vy = index(y, ys[i]);\n\t\tf[vx][vy]++;\n\t}\n\n\t//for (int vx = 0; vx < x.size(); vx++) dump(f[vx]);\n\n\tImos imos(f);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tx1 = index(x, x1);\n\t\ty1 = index(y, y1);\n\t\tx2 = index(x, x2 + 1); //Imos???sum???one-based?????????+1\n\t\ty2 = index(y, y2 + 1);\n\t\tcout << imos.sum(x1, y1, x2, y2) << endl;\n\t}\n\treturn 0;\n}\n\n\n//Sample2\n//https://gyazo.com/39c67d1abe7a6a686acb52285f8a0bc9"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(list<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tauto itr = pos.begin();\n\tfor(int i = 0; i < pos.size(); i++,itr++){\n\t\tPos now = *itr;\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tlist<Pos> pos;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos temp = {x1, x2};\n\t\tpos.push_back(temp);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tcout << Count(pos, x1, y1, x2, y2);\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main(){\n  int n, m, x, y, xx, yy, ans;\n  std::cin >> n >> m;\n  vector<pii> t(n + 1)\n  t[n].first = t[n].second = 1e9 + 7;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &tx[i], &ty[i]);\n  }\n  sort(t.begin(), t.end());\n  for (int i = 0; i < m; i++) {\n    ans = 0;\n    scanf(\"%d %d %d %d\", &x, &y, &xx, &yy);\n    for (int j = 0; j < n; j++) {\n      if(x <= t[j].first and t[j].first <= xx){\n        if(y <= t[j].second and t[j].second <= yy)ans++;\n      }else if(x < t[j].first){\n        break;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define p pair<int, int>\nusing namespace std;\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n    std::fill((T *)array, (T *)(array + N), val);\n}\n\nint imos[5100][5100];\nconst int INF = 1e9 + 7;\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n + 2), y(n + 2);\n    x[n] = INF, y[n] = INF;\n    x[n + 1] = -INF, y[n + 1] = -INF;\n    vector<int> xs(n), ys(n);\n    for (int i = 0; i < n; i++) {\n        cin >> x[i] >> y[i];\n        xs[i] = x[i];\n        ys[i] = y[i];\n    }\n    // 始点と終点を入れとく\n    sort(x.begin(), x.end());\n    sort(y.begin(), y.end());\n    x.erase(unique(x.begin(), x.end()), x.end());\n    y.erase(unique(y.begin(), y.end()), y.end());\n    for (int i = 0; i < n; i++) {\n        int nx = lower_bound(x.begin(), x.end(), xs[i]) - x.begin();\n        int ny = lower_bound(y.begin(), y.end(), ys[i]) - y.begin();\n        imos[ny + 1][nx + 1]++;\n    }\n    for (int i = 0; i < y.size(); i++) {\n        for (int j = 0; j < x.size(); j++) {\n            imos[i + 1][j + 1] += imos[i + 1][j] + imos[i][j + 1] - imos[i][j];\n        }\n    }\n    for (int i = 0; i < m; i++) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(x.begin(), x.end(), x1) - x.begin();\n        y1 = lower_bound(y.begin(), y.end(), y1) - y.begin();\n        x2 = lower_bound(x.begin(), x.end(), x2 + 1) - x.begin();\n        y2 = lower_bound(y.begin(), y.end(), y2 + 1) - y.begin();\n        cout << imos[y2][x2] - imos[y2][x1] - imos[y1][x2] + imos[y1][x1] << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// iostream のscanf, printf では間に合わなかった\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define mp make_pair\n#define pb push_back\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\t//scanf(\"%d %d\", &x, &y);\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t//scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\tvector<pii>::iterator ite = upper_bound(treasure.begin(),treasure.end(),mp(x2,y2));\n\t\twhile( 1 ){\n\t\t\t//if( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\tif( it == ite ) break;\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\tcout << ans << endl;\n\t\t//printf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) { cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl; }\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//pair?????????\ntemplate<typename T1, typename T2>\nostream &operator << (ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\n\n//??§?¨???§???\n//v: ??§???????????§?¨??????? ????????????\ntemplate<typename T>\nvoid compress(vector<T> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\n//??§?¨???§???(map)\n//v: ??§???????????§?¨??????? ????????????\n//?????????: zip[??§???????????§?¨?]:??§???????????§?¨? (zip.size()<=10^5?????????????????????)\ntemplate<typename T>\nmap<T, T> compressMap(vector<T> &v) {\n\tmap<T, T> zip;\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (T i = 0; i < v.size(); i++) zip[v[i]] = i;\n\treturn zip;\n}\n\n//??§???????????§?¨?\n//index(??§???????????§?¨?, ??§???????????§?¨??????????(??????) )\ntemplate<typename T>\nint index(vector<T> v, T i) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\n//2?¬????imos???\nclass Imos {\npublic:\n\tusing vvi = vector<vector<int> >;\n\tint X, Y;\n\tvvi s; //?´???????\n\t//f:field\n\tImos(vvi &f) {\n\t\tX = f.size();\n\t\tY = f[0].size();\n\t\t//one-based\n\t\t//(x,y)?????§????´??????????(x+1,y+1)\n\t\ts = vvi(X + 1, vector<int>(Y + 1));\n\t\tfor (int y = 0; y < Y; y++)\n\t\t\tfor (int x = 0; x < X; x++)\n\t\t\t\ts[x + 1][y + 1] += s[x + 1][y] + s[x][y + 1] - s[x][y] + f[x][y];\n\t}\n\t//[x1,x2)??????[y1,y2)???field??????????±???????\n\t//one-based????????????????§?\n\tint sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x2][y1] - s[x1][y2] + s[x1][y1]; }\n};\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<int> xs(n), ys(n);\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &xs[i], &ys[i]);\n\t\tx[i] = xs[i]; y[i] = ys[i];\n\t}\n\tcompress(x);\n\tcompress(y);\n\n\t//map<int, int> zipx(compressMap(x));\n\t//map<int, int> zipy(compressMap(y));\n\t//dump(x);\n\t//dump(zipx);\n\t//dump(y);\n\t//dump(zipy);\n\n\tvector<vector<int> > f(x.size(), vector<int>(y.size()));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint vx = index(x, xs[i]);\n\t\tint vy = index(y, ys[i]);\n\t\tf[vx][vy]++;\n\t}\n\n\t//for (int vx = 0; vx < x.size(); vx++) dump(f[vx]);\n\n\tImos imos(f);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tx1 = index(x, x1);\n\t\ty1 = index(y, y1);\n\t\tx2 = index(x, x2 + 1); //Imos???sum???one-based?????????+1\n\t\ty2 = index(y, y2 + 1);\n\t\tcout << imos.sum(x1, y1, x2, y2) << endl;\n\t}\n\treturn 0;\n}\n\n\n//Sample2\n//https://gyazo.com/39c67d1abe7a6a686acb52285f8a0bc9"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <vector>\n#include <string>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <algorithm>\n\nusing namespace std;\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define BW(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define ALL(v) (v).begin(), (v).end()\n#define LENGTHOF(x) (sizeof(x) / sizeof(*(x)))\n#define AFILL(a, b) fill((int*)a, (int*)(a + LENGTHOF(a)), b)\n#define SQ(x) ((x)*(x))\n#define Mod(x, mod) (((x)+(mod)%(mod))\n#define MP make_pair\n#define PB push_back\n#define Fi first\n#define Se second\n#define INF (1<<29)\n#define EPS 1e-10\n#define MOD 1000000007\n\ntypedef pair<int, int> P;\ntypedef vector<int> vi;\ntypedef queue<int> qi;\ntypedef long long ll;\n\nmap<int,int>zipX,zipY;\nint unzipX[5005], unzipY[5005];\nint cum[5005][5005];\nint N,M;\nvector<int> X, Y;\n\nint compressX(vector<int>&x){\n  sort(x.begin(), x.end());\n  x.erase(unique(x.begin(), x.end()), x.end());\n  rep(i,x.size()){\n    zipX[x[i]] = i;\n    unzipX[i] = x[i];\n  }\n  return x.size();\n}\nint compressY(vector<int>&y){\n  sort(y.begin(), y.end());\n  y.erase(unique(y.begin(), y.end()), y.end());\n  rep(i,y.size()){\n    zipY[y[i]] = i;\n    unzipY[i] = y[i];\n  }\n  return y.size();\n}\n\nint main(){\n  scanf(\"%d%d\", &N,&M);\n  X.resize(N); Y.resize(N);\n  rep(i,N) scanf(\"%d%d\", &X[i], &Y[i]);\n  vector<int>x,y; x = X; y = Y;\n  int W = compressX(x);\n  int H = compressY(y);\n  memset(cum, 0,sizeof(cum));\n  rep(i,N) cum[zipX[X[i]]+1][zipY[Y[i]]+1]++;\n  zipX[-INF] = 0; zipY[INF] = 0;\n  zipX[INF] = W; zipY[INF] = H;\n  rep(i,W+1) rep(j,H) cum[i][j+1] += cum[i][j];\n  rep(j,H+1) rep(i,W) cum[i+1][j] += cum[i][j];\n  /*  rep(i,W+1){\n    rep(j,H+1) cout << cum[i][j] << \" \" ; cout << endl;\n    }*/\n  rep(i,M){\n    int x1, x2, y1, y2;\n    scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n    P a = *zipX.lower_bound(x1);\n    P b = *zipY.lower_bound(y1);\n    P c = *zipX.upper_bound(x2);\n    P d = *zipY.upper_bound(y2);\n    //    cout << a.second << \" \" << b.second << \" \" << c.second << \" \" <<d.second << \" \" << cum[a.second][d.second] << endl;\n    printf(\"%d\\n\", cum[a.second][b.second]-cum[c.second][b.second]-cum[a.second][d.second]+cum[c.second][d.second]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n\nint n, x[5000], y[5000], m;\nvector<int> xs, ys;\nint sum[5010][5010];\n\nint of(const vector<int>& xs, int x) {\n    return lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n}\n\nint solve(int x1, int y1, int x2, int y2) {\n    if (x1 > xs.back() || x2 < xs[0]) return 0;\n    if (y1 > ys.back() || y2 < ys[0]) return 0;\n    const int ix1 = of(xs, x1), ix2 = of(xs, x2+1);\n    const int iy1 = of(ys, y1), iy2 = of(ys, y2+1);\n    return sum[ix2][iy2] - sum[ix2][iy1] - sum[ix1][iy2] + sum[ix1][iy1];\n}\n\nint main() {\n    scanf(\"%d%d\", &n, &m);\n    rep (i, n) scanf(\"%d%d\", x+i, y+i);\n    rep (i, n) xs.push_back(x[i]), ys.push_back(y[i]);\n    sort(xs.begin(), xs.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    sort(ys.begin(), ys.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    rep (i, n) sum[of(xs, x[i])+1][of(ys, y[i])+1]++;\n    rep (i, xs.size()+1) rep (j, ys.size()+1) {\n        if (i) sum[i][j] += sum[i-1][j];\n        if (j) sum[i][j] += sum[i][j-1];\n        if (i && j) sum[i][j] -= sum[i-1][j-1];\n    }\n    rep (_, m) {\n        int x1, y1, x2, y2;\n        scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n        printf(\"%d\\n\", solve(x1, y1, x2, y2));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n  int n,m,x,y,sx,sy,lx,ly;\n  vector<pii> map;\n\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    cin>>x>>y;\n    map.push_back(make_pair(x,y));\n  }\n  sort(map.begin(),map.end());\n  for(int i=0;i<m;i++){\n    cin>>sx>>sy>>lx>>ly;\n    int left,right;\n    for(left=0;map[left].first<sx&&left<map.size();left++);\n    int ans=0;\n    for(right=left;map[right].first<=lx&&right<map.size();right++)\n      if(sy<=map[right].second&&map[right].second<=ly) ans++;\n    cout<<ans<<endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nint n, m, s[5010][5010];\nvi x, y;\nvi vy, vx;\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n){\n\t\tint a, b;\n\t\tscanf(\"%d%d\", &a, &b);\n\t\tx.pb(a); y.pb(b);\n\t\tvx.pb(a); vy.pb(b);\n\t}\n\tvx.pb(-inf - 1); vy.pb(-inf - 1);\n\tvx.pb(inf + 1); vy.pb(inf + 1);\n\tsort(all(vx)); sort(all(vy));\n\t\n\trep(i, n){\n\t\tint a = lower_bound(all(vx), x[i]) - vx.begin();\n\t\tint b = lower_bound(all(vy), y[i]) - vy.begin();\n\t\ts[a][b]++;\n\t}\n\trep(i, vx.size()) rep(j, vy.size()){\n\t\ts[i + 1][j + 1] += s[i + 1][j] + s[i][j + 1] - s[i][j];\n\t}\n\t\n\trep(i, m){\n\t\tint x, X, y, Y;\n\t\tscanf(\"%d%d%d%d\", &x, &y, &X, &Y);\n\t\tx = lower_bound(all(vx), x) - vx.begin() - 1;\n\t\ty = lower_bound(all(vy), y) - vy.begin() - 1;\n\t\tX = lower_bound(all(vx), X + 1) - vx.begin() - 1;\n\t\tY = lower_bound(all(vy), Y + 1) - vy.begin() - 1;\n\t\t\n\t\tprintf(\"%d\\n\", s[X][Y] - s[x][Y] - s[X][y] + s[x][y]);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <map>\n#include <algorithm>\nusing namespace std;\nint max_size = (1<< 9)+1;\nint INF = 1<<30;\nvector<vector<int> > field;\nvoid myprint(){\n  cout << endl;\n  cout << \"------------------------------\" << endl;\n  for(int i = field.size()-1;i >= 0;i--){\n\tfor(int j = 0;j < field[0].size();j++){\n\t  cout << field[i][j] << \"\\t\";\n\t}\n\tcout << endl;\n  }\n}\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector<int> x_vec;\n  vector<int> y_vec;\n  vector<pair<int,int> > keep;\n  x_vec.push_back(INF);\n  x_vec.push_back(-1*INF);\n  y_vec.push_back(INF);\n  y_vec.push_back(-1*INF);\n  for(int i = 0;i < n;i++){\n\tint x,y;\n\tcin >> x >> y;\n\tx_vec.push_back(x);\n\ty_vec.push_back(y);\n\tkeep.emplace_back(x,y);\n  }\n  \n  sort(x_vec.begin(),x_vec.end());\n  sort(y_vec.begin(),y_vec.end());\n  x_vec.erase(unique(x_vec.begin(),x_vec.end()),x_vec.end());\n  y_vec.erase(unique(y_vec.begin(),y_vec.end()),y_vec.end());\n  field = vector<vector<int> >(y_vec.size(),vector<int>(x_vec.size(),0));\n  for(int i = 0;i < keep.size();i++){\n\tint cx = keep[i].first;\n\tint cy = keep[i].second;\n\tcx = lower_bound(x_vec.begin(),x_vec.end(),cx) - x_vec.begin();\n\tcy = lower_bound(y_vec.begin(),y_vec.end(),cy) - y_vec.begin();\n\tfield[cy][cx]++;\n  }\n  //myprint();\n  for(int i = 0;i < y_vec.size();i++){\n\tfor(int j = 0;j < x_vec.size()-1;j++){\n\t  field[i][j+1] += field[i][j];\n\t}\n  }\n//  myprint();\n  for(int j = 0;j < x_vec.size();j++){\n\tfor(int i = 0;i < y_vec.size()-1;i++){\n\t  field[i+1][j] += field[i][j];\n\t}\n  }\n//  myprint();\n\n  for(int i = 0;i < m;i++){\n\tint x1,y1,x2,y2;\n\tint bx1,by1;\n\tint sum = 0;\n\tcin >> x1 >> y1 >> x2 >> y2;\n\tx2 = upper_bound(x_vec.begin(),x_vec.end(),x2) - 1 - x_vec.begin();\n\ty2 = upper_bound(y_vec.begin(),y_vec.end(),y2) - 1 - y_vec.begin();\n\tx1 = lower_bound(x_vec.begin(),x_vec.end(),x1) - x_vec.begin() - 1;\n\ty1 = lower_bound(y_vec.begin(),y_vec.end(),y1) - y_vec.begin() - 1;\n\t//bx1 = lower_bound(x_vec.begin(),x_vec.end(),x1) - 1 - x_vec.begin();\n\t//by1 = lower_bound(y_vec.begin(),y_vec.end(),y1) - 1 - y_vec.begin();\n/*\tcout << \"x2 = \" <<x2 << \" y2=\" << y2 << \" bx1= \"<< bx1 << \" y2 = \" << y2 << \" x2= \"<< x2 << \" by1 = \" << by1 <<\" bx1 =  \" << bx1 << \" by1 = \" << by1 << endl;*/\n\tsum += field[y2][x2] - field[y2][x1] - field[y1][x2] + field[y1][x1];\n\tcout << sum << endl;\n  }\n  \n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <cstring>\n#include <vector>\n#include <map>\nusing namespace std;\n\ntypedef pair<int,int>P;\n\n#define X first\n#define Y second\n\nint mp[5010][5010];\n\nset<int>xs;\nset<int>ys;\n\nint xl[5010];\nint yl[5010];\n\nint x_find(int n){\n\tint le=0,ri=5009;\n\twhile(le!=ri){\n\t\tint p=(le+ri)/2;\n\t\tif(xl[p]==n)return p;\n\t\tif(xl[p]<n)le=p+1;\n\t\telse ri=p-1;\n\t}\n\treturn le;\n}\n\nint y_find(int n){\n\tint le=0,ri=5009;\n\twhile(le!=ri){\n\t\tint p=(le+ri)/2;\n\t\tif(yl[p]==n)return p;\n\t\tif(yl[p]<n)le=p+1;\n\t\telse ri=p-1;\n\t}\n\treturn le;\n}\n\nint x_find2(int n){\n\tint le=0,ri=5005,p=2502;\n\twhile(le<ri){\n\t\tif(xl[p]==n)return p;\n\t\tif(xl[p]<n)le=p+1;\n\t\telse ri=p-1;\n\t\tp=(le+ri)/2;\n\t}\n\tif(xl[p]==n)return p;\n\twhile(xl[p]>n)p--;\n\twhile(xl[p+1]<n)p++;\n\treturn p;\n}\n\nint y_find2(int n){\n\tint le=0,ri=5005,p=2502;\n\twhile(le<ri){\n\t\tif(yl[p]==n)return p;\n\t\tif(yl[p]<n)le=p+1;\n\t\telse ri=p-1;\n\t\tp=(le+ri)/2;\n\t}\n\tif(yl[p]==n)return p;\n\twhile(yl[p]>n)p--;\n\twhile(yl[p+1]<n)p++;\n\treturn p;\n}\n\nint x_find3(int n){\n\tint le=0,ri=5005,p=2502;\n\twhile(le<ri){\n\t\tif(xl[p]==n)return p;\n\t\tif(xl[p]<n)le=p+1;\n\t\telse ri=p-1;\n\t\tp=(le+ri)/2;\n\t}\n\tif(xl[p]==n)return p;\n\twhile(xl[p]<n)p++;\n\twhile(xl[p-1]>n)p--;\n\treturn p;\n}\n\nint y_find3(int n){\n\tint le=0,ri=5005,p=2502;\n\twhile(le<ri){\n\t\tif(yl[p]==n)return p;\n\t\tif(yl[p]<n)le=p+1;\n\t\telse ri=p-1;\n\t\tp=(le+ri)/2;\n\t}\n\tif(yl[p]==n)return p;\n\twhile(yl[p]<n)p++;\n\twhile(yl[p-1]>n)p--;\n\treturn p;\n}\n\nint main(){\n\t\n\tint n,m;\n\tcin>>n>>m;\n\t\n\tvector<P>V;\n\t\n\txs.insert(-1100000000);\n\tys.insert(-1100000000);\n\txs.insert(-1100000001);\n\tys.insert(-1100000001);\n\t\n\tfor(int i=0;i<n;i++){\n\t\tint x,y;\n\t\tcin>>x>>y;\n\t\tV.push_back(P(x,y));\n\t\txs.insert(x);\n\t\tys.insert(y);\n\t}\n\t\n\tfor(int i=1100000000;xs.size()<5010;i++){\n\t\txs.insert(i);\n\t}\n\tfor(int i=1100000000;ys.size()<5010;i++){\n\t\tys.insert(i);\n\t}\n\t\n\tset<int>::iterator it = xs.begin();\n\tfor( int i=0;it != xs.end(); i++){\n\t\txl[i]=*it;\n\t\t++it;\n\t}\n\t\n\tset<int>::iterator it2 = ys.begin();\n\tfor( int i=0;it2 != ys.end(); i++){\n\t\tyl[i]=*it2;\n\t\t++it2;\n\t}\n\t\n\tfor(int i=0;i<n;i++){\n\t\tmp[x_find(V[i].X)][y_find(V[i].Y)]++;\n\t}\n\t\n\t\n\tfor(int j=0;j<5010;j++){\n\t\tfor(int i=1;i<5010;i++){\n\t\t\tmp[i][j]+=mp[i-1][j];\n\t\t}\n\t}\n\t\n\tfor(int j=0;j<5010;j++){\n\t\tfor(int i=1;i<5010;i++){\n\t\t\tmp[i][j]+=mp[i][j-1];\n\t\t}\n\t}\n\t\n\tfor(int i=0;i<m;i++){\n\t\tint x1,y1,x2,y2;\n\t\tcin>>x1>>y1>>x2>>y2;\n\t\tx1=x_find3(x1);\n\t\ty1=y_find3(y1);\n\t\tx2=x_find2(x2);\n\t\ty2=y_find2(y2);\n\t\t\n\t\t\n\t\tcout<<mp[x2][y2]-mp[x2][y1-1]-mp[x1-1][y2]+mp[x1-1][y1-1]<<endl;\n\t\t//cout<<mp[x2][y2]<<\" \"<<mp[x2][y1]<<\" \"<<mp[x1][y2]<<\" \"<<mp[x1][y1]<<endl;\n\t\t//cout<<mp[x2][y2]-mp[x2][y1]-mp[x1][y2]+mp[x1][y1]<<endl;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(n)<=(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tpair<int,int> t[5001];\n\tREP(i,0,n) {\n\t\tcin>>t[i].F>>t[i].S;\n\t}\n\tsort(t,t+n);\n\tint x[2],y[2];\n\tREP(i,0,m){\n\t\tint ans=0;\n\t\tcin>>x[0]>>y[0]>>x[1]>>y[1];\n\t\tpair<int,int> a,b;\n\t\ta={x[0],y[0]};\n\t\tb={x[1],y[1]};\n\t\tfor(auto itr=lower_bound(t,t+n,a);itr!=upper_bound(t,t+n,b);itr++){\n\t\t\tpair<int,int> c=*itr;\n\t\t\tif(c.S<=b.S) ans++;\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(integer i=0;i<(integer)(n);i++)\n\ntypedef long long int integer;\ntypedef pair<integer,integer> P;\nconst int MAX = 5004;\n\nint acc[MAX + 8][MAX + 8];\nint trecd[MAX + 8][MAX + 8];\n\nint main() {\n  integer n, m;\n  cin >> n >> m;\n  vector<integer> xs, ys;\n  vector<P> treasures(n);\n  for (P &p : treasures) {\n    cin >> p.first >> p.second;\n    xs.push_back(p.first);\n    ys.push_back(p.second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n  vector<integer> rxs = xs, rys = ys;\n  reverse(rxs.begin(), rxs.end());\n  for (integer &rx : rxs) rx = -rx;\n  reverse(rys.begin(), rys.end());\n  for (integer &ry : rys) ry = -ry;\n\n  for (P p : treasures) {\n    integer x = find(xs.begin(), xs.end(), p.first) - xs.begin() + 1;\n    integer y = find(ys.begin(), ys.end(), p.second) - ys.begin() + 1;\n    trecd[x][y]++;\n  }\n  \n  for (integer y = 1; y < MAX; y++) for (integer x = 1; x < MAX; x++) {\n    acc[x][y] = acc[x][y-1] + acc[x-1][y] - acc[x-1][y-1] + trecd[x][y];\n  }\n\n  REP (i, m) {\n    integer xb, yb, xe, ye;\n    cin >> xb >> yb >> xe >> ye;\n    xb = lower_bound(xs.begin(), xs.end(), xb) - xs.begin() + 1;\n    yb = lower_bound(ys.begin(), ys.end(), yb) - ys.begin() + 1;\n    xe = rxs.end() - lower_bound(rxs.begin(), rxs.end(), -xe);\n    ye = rys.end() - lower_bound(rys.begin(), rys.end(), -ye);\n    integer ans = acc[xe][ye] - acc[xb-1][ye] - acc[xe][yb-1] \n      + acc[xb-1][yb-1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(x,a,b) ((a)<=(x)&&(x)<=(b))\nusing namespace std;\nvector< pair<int, int> >grid;\nint main(){\n  int n, m, x, y;\n  scanf(\"%d%d\", &n, &m);\n  grid.resize(n);\n  rep(i, n){\n    scanf(\"%d%d\", &x, &y);\n    grid[i] = make_pair(x,y);\n  }\n  int x1, y1, x2, y2;\n  rep(i, m){\n    int res = 0;\n    scanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n    rep(j, n)\n      if(between(grid[j].first, x1, x2) && between(grid[j].second, y1, y2)){\n\n\tres++;\n      }\n    printf(\"%d\\n\", res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define X first\n#define Y second\n\nusing namespace std;\n\nint n, m;\nvector<int> vx, vy;\nint tx[5005], ty[5005], unzipx[5005], unzipy[5005], imos[5005][5005];\nmap<int, int> zipx, zipy;\npair< pair<int,int>, pair<int,int> > p[500005];\n\nint main() {\n  cin>>n>>m;\n  REP(i,0,n){\n    cin>>tx[i]>>ty[i];\n    vx.push_back(tx[i]);\n    vy.push_back(ty[i]);\n  }\n  REP(i,0,m){\n    cin>>p[i].F.X>>p[i].F.Y>>p[i].S.X>>p[i].S.Y;\n  }\n\n  //compression\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  vx.erase(vx.begin()/*unique(vx.begin(), vx.end())*/, vx.end());\n  vy.erase(vy.begin()/*unique(vy.begin(), vy.end())*/, vy.end());\n  REP(i,0,vx.size()){\n    zipx[vx[i]] = i;\n    unzipx[i] = vx[i];\n  }\n  REP(i,0,vy.size()){\n    zipy[vy[i]] = i;\n    unzipy[i] = vy[i];\n  }\n\n  //Initializing imos array\n  REP(i,0,5005)REP(j,0,5005) imos[i][j] = 0;\n  REP(i,0,n){\n    imos[zipy[ty[i]]][zipx[tx[i]]]++;\n  }\n  //creating imos array\n  REP(i,0,vy.size()){\n    REP(j,1,vx.size()){\n      imos[i][j] += imos[i][j-1];\n    }\n  }\n  REP(j,0,vx.size()){\n    REP(i,1,vy.size()){\n      imos[i][j] += imos[i-1][j];\n    }\n  }\n\n  REP(i,0,m){\n    /*\n    cout<<\"xSize:\"<<vx.size()<<\", \"<<\"ySize:\"<<vx.size()<<endl;\n    cout<<\"test: \"<<(lower_bound(vx.begin(),vx.end(),p[i].F.X)-vx.begin())<<\" \";\n    cout<<(lower_bound(vy.begin(),vy.end(),p[i].F.Y)-vy.begin())<<\" \";\n    cout<<(lower_bound(vx.begin(),vx.end(),p[i].S.X)-vx.begin())<<\" \";\n    cout<<(lower_bound(vy.begin(),vy.end(),p[i].S.Y)-vy.begin())<<endl;\n    */\n    vector<int>::iterator a1x = lower_bound(vx.begin(),vx.end(),p[i].F.X),\n      a1y = lower_bound(vy.begin(),vy.end(),p[i].F.Y),\n      a2x = upper_bound(vx.begin(),vx.end(),p[i].S.X)-1,\n      a2y = upper_bound(vy.begin(),vy.end(),p[i].S.Y)-1;\n    int z1x = zipx[*a1x], z1y = zipy[*a1y], z2x = zipx[*a2x], z2y = zipy[*a2y];\n    int ans = imos[z2y][z2x];\n    if(z1y > 0) ans -= imos[z1y-1][z2x];\n    if(z1x > 0) ans -= imos[z2y][z1x-1];\n    if(z1y > 0 && z1x > 0) ans += imos[z1y-1][z1x-1];\n\n    if(p[i].F.Y > unzipy[vy.size()-1] || p[i].F.X > unzipx[vx.size()-1]) cout<<0<<endl;\n    else if(p[i].S.Y < unzipy[0] || p[i].S.X < unzipx[0]) cout<<0<<endl;\n    else cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    \n    vector<int> A(n*n, 0);\n    vector<int> x(n);\n    vector<int> y(n);\n    vector<int> xb(m);\n    vector<int> yb(m);\n    vector<int> xe(m);\n    vector<int> ye(m);\n    vector<int> xs;\n    vector<int> ys;\n    \n    for(int j = 0; j < n; j++)\n        cin >> x[j] >> y[j];\n    \n    for(int i = 0; i < m; i++)\n        cin >> xb[i] >> yb[i] >> xe[i] >> ye[i];\n    \n    xs = x;\n    ys = y;\n    sort( xs.begin(), xs.end() );\n    sort( ys.begin(), ys.end() );\n    xs.erase( unique( xs.begin(), xs.end() ), xs.end() );\n    ys.erase( unique( ys.begin(), ys.end() ), ys.end() );\n    \n    for(int j = 0; j < n; j++){\n        x[j] = find( xs.begin(), xs.end(), x[j] ) - xs.begin();\n        y[j] = find( ys.begin(), ys.end(), y[j] ) - ys.begin();\n    }\n    \n    for(int i = 0; i < m; i++){\n        xb[i] = lower_bound( xs.begin(), xs.end(), xb[i] ) - xs.begin();\n        yb[i] = lower_bound( ys.begin(), ys.end(), yb[i] ) - ys.begin();\n        xe[i] = upper_bound( xs.begin(), xs.end(), xe[i] ) - xs.begin() - 1;\n        ye[i] = upper_bound( ys.begin(), ys.end(), ye[i] ) - ys.begin() - 1;\n    }\n    \n    \n    \n    for(int j = 0; j < n; j++){\n        for(int k = 0; k < n; k++){\n            A[ n*y[j] + x[k] ] += 1;\n        }\n    }\n    \n    for(int j = 0; j < n; j++){\n        for(int k = 1; k < n; k++){\n            A[n*j+k] += A[n*j+k-1];\n        }\n    }\n    for(int k = 0; k < n; k++){\n        for(int j = 1; j < n; j++){\n            A[n*j+k] += A[n*(j-1)+k];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        int a, b, c;\n        c = A[ n*(yb[i]-1) + (xb[i]-1) ];\n        if(xb[i] > 0)\n            a = A[ n*ye[i] + (xb[i]-1) ];\n        else\n            c = a = 0;\n        if(yb[i] > 0)\n            b = A[ n*(yb[i]-1) + xe[i] ];\n        else\n            c = b = 0;\n        cout << A[ n*ye[i] + xe[i] ] - a - b + c <<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 250;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) != EOF) {\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d%d\", &ps[i].first, &ps[i].second);\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int b = 0; b < BNUM; ++b) {\n      sort(bucket[b].begin(), bucket[b].end());\n    }\n    while(m--) {\n      int s, t, u, v; \n      scanf(\"%d%d%d%d\", &s, &t, &u, &v);\n      int l = lower_bound(x, x+n, s) - x;\n      int r = upper_bound(x, x+n, u) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (t <= y[l] && y[l] <= v);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (t <= y[r] && y[r] <= v);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), v)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), t);\n        l += B;\n      }\n      printf(\"%d\\n\", res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n   \nusing namespace std;\n   \n \n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(dest))\n   \ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntemplate <class T> void sort(vector<T>& c) { sort(c.begin(), c.end()); }\ntemplate <class T> void unique(vector<T>& c) { sort(c.begin(), c.end()); c.erase(unique(c.begin(), c.end()), c.end()); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n   \ntemplate <class T, class U> ostream& operator<<(ostream& os, pair<T, U>& p) { os << \"( \" << p.first << \", \" << p.second << \" )\"; return os;  }\n  \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\ntemplate <class T> T to_T(const string& s) { istringstream is(s); T res; is >> res; return res; }\n  \nbool valid(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n   \ntemplate <class T> void print(T a, int n, const string& deli = \" \", int br = 1) { for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } while (br--) cout << endl; }\ntemplate <class T> void print(const T& c, const string& deli = \" \", int br = 1) { foreach (it, c) { cout << *it; if (++it != c.end()) cout << deli;--it; } while (br--) cout << endl; }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {    if (width != -1) cout.width(width); cout << a[i][j] << ' '; } cout << endl; } while (br--) cout << endl; }\n   \ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(T& a, U& b, int n) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n  \nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n  \nconst double PI = acos(-1.0);\nconst int mod = 1000000007;\n\n\n\nint main()\n{\n    ios::sync_with_stdio(false);\n\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; ++i)\n        cin >> x[i] >> y[i];\n    vector<int> ori_x = x, ori_y = y;\n\n    const int INF = 2e9;\n    x.push_back(-INF);\n    x.push_back(INF);\n    y.push_back(-INF);\n    y.push_back(INF);\n    unique(x);\n    unique(y);\n\n    static int sum[5100][5100];\n    for (int i = 0; i < n; ++i)\n    {\n        int px = upper_bound(all(x), ori_x[i]) - x.begin();\n        int py = upper_bound(all(y), ori_y[i]) - y.begin();\n        ++sum[py][px];\n    }\n    for (int i = 0; i < y.size(); ++i)\n        for (int j = 0; j < x.size(); ++j)\n            sum[i + 1][j + 1] += sum[i][j + 1] + sum[i + 1][j] - sum[i][j];\n\n    while (m--)\n    {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(all(x), x1) - x.begin();\n        y1 = lower_bound(all(y), y1) - y.begin();\n        x2 = upper_bound(all(x), x2) - x.begin();\n        y2 = upper_bound(all(y), y2) - y.begin();\n\n        int res = sum[y2][x2] - (sum[y2][x1] + sum[y1][x2]) + sum[y1][x1];\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1e9 + 10;\n\nint xs[5001], ys[5001];\nint sum[5100][5100];\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  vector<int> X, Y;\n  rep(i, N) {\n    scanf(\"%d%d\", &xs[i], &ys[i]);\n    X.push_back(xs[i]); Y.push_back(ys[i]);\n  }\n\n  sort(X.begin(), X.end()); X.erase(unique(all(X)), X.end());\n  sort(Y.begin(), Y.end()); Y.erase(unique(all(Y)), Y.end());\n\n  rep(i, N) {\n    sum[upper_bound(all(Y), ys[i]) - Y.begin()][upper_bound(all(X), xs[i]) - X.begin()] ++;\n  }\n\n  rep(i, Y.size() + 10) rep(j, X.size() + 10) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int rx1, ry1, rx2, ry2; scanf(\"%d%d%d%d\", &rx1, &ry1, &rx2, &ry2);\n    int x1 = lower_bound(all(X), rx1) - X.begin();\n    int y1 = lower_bound(all(Y), ry1) - Y.begin();\n    int x2 = upper_bound(all(X), rx2) - X.begin();\n    int y2 = upper_bound(all(Y), ry2) - Y.begin();\n    printf(\"%d\\n\", sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1]);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\n\nvi compressed_x, compressed_y;\n\nint a[5005*6+2][5005*6+2];\n\nint main()\n{\n    cin >> n >> m;\n\n    int xmi = inf, xma = -inf, ymi = inf, yma = -inf;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        for (int d = -1; d <= 1; ++d) {\n            compressed_x.PB(x[i] + d);\n            compressed_y.PB(y[i] + d);\n        }\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = lower_bound(all(compressed_x), x2) - begin(compressed_x);\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = lower_bound(all(compressed_y), y2) - begin(compressed_y);\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long ll;\n#define REP(i,n) for(int i = 0;i < (n);i++)\n#define rep(i,m,n) for(int i = (m);i < (n);i++)\n#define P pair<int,int>\n#define pb push_back\n#define mk make_pair\nusing namespace std;\n#define Vec(a) vector <int> a\nconst int INF = 1 << 20;\nconst int MOD = 1e9+7;\n\n\n\n\n\nint main(){\n  int n,m;\n  cin >> n >> m;\n  vector <P> p(n);\n  \n  REP(i,n){\n    cin >> p[i].first >> p[i].second;\n  }\n  sort(p.begin(),p.end());\n  REP(i,m){\n    int x1,x2,y1,y2;\n    int sum = 0;\n    cin >> x1 >> y1 >> x2 >> y2;\n    REP(j,n){\n      if(p[j].first >= x1 && p[j].first <= x2 && p[j].second >= y1 && p[j].second <= y2){\n\tsum++;\n      }\n    }\n    cout << sum << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cctype>\n#include <complex>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 30;\n\nvoid compress(vi const& vec, map<int, int>& zip, vi& unzip){\n    unzip = vec;\n\n    sort(all(unzip));\n    unzip.erase(unique(all(unzip)), unzip.end());\n    unzip.pb(inf);\n\n    rep(i, unzip.size()) zip[unzip[i]] = i;\n}\n\nint main(void){\n    for(int n, m; cin >> n >> m;){\n        vi xs(n), ys(n);\n        rep(i, n) cin >> xs[i] >> ys[i];\n\n        vi unzip_x, unzip_y;\n        map<int, int> zip_x, zip_y;\n\n        compress(xs, zip_x, unzip_x);\n        compress(ys, zip_y, unzip_y);\n\n        vvi sum(n + 2, vi(n + 2));\n\n        rep(i, n) sum[zip_y[ys[i]] + 1][zip_x[xs[i]] + 1]++;\n        rep(i, n + 1) rep(j, n + 1) sum[i + 1][j + 1] += sum[i + 1][j] + sum[i][j + 1] - sum[i][j];\n\n        rep(i, m){\n            int lux, luy, rdx, rdy; cin >> lux >> luy >> rdx >> rdy;\n\n            lux = zip_x[*lower_bound(all(unzip_x), lux)];\n            luy = zip_y[*lower_bound(all(unzip_y), luy)];\n            rdx = zip_x[*upper_bound(all(unzip_x), rdx)];\n            rdy = zip_y[*upper_bound(all(unzip_y), rdy)];\n\n            cout << sum[rdy][rdx] - sum[rdy][lux] - sum[luy][rdx] + sum[luy][lux] << endl;\n        }\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nvector<pair<int,int> > v;\n\nbool comp(pair<int,int> a,pair<int,int> b){\n  return a.se<b.se;\n}\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int x,y;cin>>x>>y;\n    v.push_back({x,y});\n  }\n  sort(v.begin(),v.end());\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;\n    auto a=lower_bound(v.begin(),v.end(),pair<int,int>(x1,-1000000100));\n    auto b=lower_bound(v.begin(),v.end(),pair<int,int>(x2+1,-1000000100));\n    //cout<<\"a=\"<<int(a-v.begin())<<\" \"<<\"b=\"<<(int)(b-v.begin())<<endl;\n    vector<pair<int,int> > vv;\n    vv.assign(a,b);\n    sort(vv.begin(),vv.end());\n    /*for(auto ite=a;ite!=b;ite++){\n      cout<<ite->fi<<\",\"<<ite->se<<\" \";\n    }\n    cout<<endl;*/\n    auto c=lower_bound(vv.begin(),vv.end(),pair<int,int>(0,y1),comp)-v.begin();\n    auto d=lower_bound(vv.begin(),vv.end(),pair<int,int>(0,y2+1),comp)-v.begin();\n    //cout<<\"c=\"<<c<<\" \"<<\"d=\"<<d<<endl;\n    cout<<d-c<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; ++i) {\n    cin >> x[i] >> y[i];\n  }\n  auto vx = x, vy = y;\n  sort(begin(vx), end(vx));\n  vx.erase(unique(begin(vx), end(vx)), end(vx));\n  sort(begin(vy), end(vy));\n  vy.erase(unique(begin(vy), end(vy)), end(vy));\n  auto zip_x = [&](int e) {\n    return lower_bound(begin(vx), end(vx), e) - begin(vx);\n  };\n  auto zip_y = [&](int e) {\n    return lower_bound(begin(vy), end(vy), e) - begin(vy);\n  };\n  int h = vx.size(), w = vy.size();\n  vector<vector<int>> cum(h + 1, vector<int>(w + 1));\n  for (int i = 0; i < n; ++i) {\n    ++cum[zip_x(x[i])][zip_y(y[i])];\n  }\n  for (int i = 0; i < h; ++i) {\n    for (int j = w; j--; ) {\n      cum[i][j] += cum[i][j + 1];\n    }\n  }\n  for (int j = 0; j < w; ++j) {\n    for (int i = h; i--; ) {\n      cum[i][j] += cum[i + 1][j];\n    }\n  }\n  while (m--) {\n    int lx, ly, rx, ry;\n    cin >> lx >> ly >> rx >> ry;\n    ++rx, ++ry;\n    lx = zip_x(lx), ly = zip_y(ly);\n    rx = zip_x(rx), ry = zip_y(ry);\n    int res = cum[lx][ly] - cum[lx][ry] - cum[rx][ly] + cum[rx][ry];\n    cout << res << '\\n';\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, q, xa, ya, xb, yb, x[5555], y[5555]; pair<int, int> p[5555];\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p, p + n);\n\tfor(int i = 0; i < n; i++) x[i] = p[i].first, y[i] = p[i].second;\n\tfor(int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d%d\", &xa, &ya, &xb, &yb);\n\t\tint l = lower_bound(x, x + n, xa);\n\t\tint r = lower_bound(x, x + n, xb + 1);\n\t\tint c = 0;\n\t\tfor(int j = l; j < r; j++) {\n\t\t\tif(ya <= y[j] && y[j] <= yb) c++;\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nstruct dat {\n    int id;\n    int z;\n\n    dat () {}\n    ~dat () {}\n\n    dat (int a, int b): id(a), z(b) {}\n    \n    bool operator < (const dat& o) const {\n        return z < o.z;\n    }\n};\n\nint N, M;\nint tx[5000], ty[5000];\n\ndat arr_x[5000];\ndat arr_y[5000];\n\nint check[5000];\n\nint solve(int x1, int y1, int x2, int y2) {\n    fill(check, check + N, 0);\n\n    for (dat* itx = lower_bound(arr_x, arr_x+N, dat(-1, x1));\n            itx < arr_x+N && itx->z <= x2; ++itx) {\n        ++ check[ itx->id ];\n    }\n\n    int ans = 0;\n    for (dat* ity = lower_bound(arr_y, arr_y+N, dat(-1, y1));\n            ity < arr_y+N && ity->z <= y2; ++ity) {\n        ans += check[ ity->id ];\n    }\n\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    for (int j = 0; j < N; ++j) {\n        cin >> tx[j] >> ty[j];\n    }\n\n    // initialize\n    for (int j = 0; j < N; ++j) {\n        arr_x[j] = dat(j, tx[j]);\n        arr_y[j] = dat(j, ty[j]);\n    }\n    sort(arr_x, arr_x + N);\n    sort(arr_y, arr_y + N);\n\n    for (int j = 0; j < M; ++j) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        cout << solve(x1, y1, x2, y2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 2000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nshort int n, m;\nint sx[55555], sy[55555];\nint tx[55555], ty[55555];\nint vx[5555];\nint vy[5555];\nint maze[5555][5555];\nint sum[5555][5555];\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n  \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);\n    y.pb(vy[i]);\n  }\n  x.pb(INF);\n  y.pb(INF);\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin();\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin();\n  }\n  rep(i, n) maze[vx[i]][vy[i]] += 1;\n  rep(i, n) rep(j, n - 1) maze[i][j + 1] += maze[i][j];\n  rep(i, n - 1) rep(j, n) maze[i + 1][j] += maze[i][j];\n  \n  rep(i, m){\n    int ret = 0;\n    int lx = upper_bound(ALL(x), tx[i]) - x.begin() - 1;\n    int ly = upper_bound(ALL(y), ty[i]) - y.begin() - 1;\n    int rx = lower_bound(ALL(x), sx[i]) - x.begin();\n    int ry = lower_bound(ALL(y), sy[i]) - y.begin();\n    \n    ret += maze[lx][ly];\n    ret += maze[rx - 1][ry - 1];\n    ret -= maze[rx - 1][ly];\n    ret -= maze[lx][ry - 1];\n\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()+1]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()+1]++;\n  }\n  vector<vector<int> > ag(yp.size()+2,vector<int>(xp.size()+2));\n  for(int i=1;i<ag.size();i++){\n    for(int j=1;j<ag[i].size();j++){\n      ag[i][j]=ag[i][j-1]+ag[i-1][j]-ag[i-1][j-1]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=upper_bound(xp.begin(),xp.end(),xh)-xp.begin();\n    yyh=upper_bound(yp.begin(),yp.end(),yh)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[xxl][yyl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n\n#include<iostream>\n#include<fstream>\n#include<vector>\n#include<map>\n#include<algorithm>\n\n#define fin cin\n\nusing namespace std;\n\nint main(){\n    ifstream fin(\"input.txt\");\n\n    //???????????§?¨????????????????\n    multimap<int, int> mp_x;\n\n    int n, m;\n    fin >> n >> m;\n\n    int x[5000], y[5000];\n    vector<int> vec_x,vec_y;\n\n    for(int i = 0; i < n; i++){\n        fin >> x[i] >> y[i];\n\n\n        mp_x.insert(make_pair(x[i], i));\n\n        //vec_x.push_back(x[i]);\n        vec_y.push_back(y[i]);\n    }\n\n\n\n\n    for(int i = 0; i < m; i++){\n        int ans = 0;\n        int x1, y1, x2, y2;\n        fin >> x1 >> y1 >> x2 >> y2;\n        \n        for(multimap<int, int>::iterator itr = mp_x.lower_bound(x1); itr != mp_x.end(); itr++){\n            if(itr->first > x2)break;\n            int val = y[itr->second];\n            if(y1 <= val && val <= y2)ans++;\n\n        }\n        cout << ans << endl;\n    }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst int INF = 114514810;\nconst int MOD = 1000000007;\nconst double EPS = 1e-10;\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\nint place(int x, int y, int w) { return w*x + y; }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\ntypedef complex<double> Point;\n\nstruct kdtree {\n\tstruct node {\n\t\tPoint p;\n\t\tnode *l, *r;\n\t\tnode(const Point &p)\n\t\t\t: p(p), l(NULL), r(NULL)\n\t\t{\n\t\t}\n\t} *root;\n\tkdtree() : root(NULL) {}\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n\tvoid insert(const Point &p)\n\t{\n\t\troot = insert(root, 0, p);\n\t}\n\tnode *insert(node *t, int d, const Point &p)\n\t{\n\t\tif (t == NULL) return new node(p);\n\t\tif (compare(d, p, t->p)) t->l = insert(t->l, !d, p);\n\t\telse                   t->r = insert(t->r, !d, p);\n\t\treturn t;\n\t}\n\n\tvoid search(const Point &ld, const Point &ru, vector<Point> &out)\n\t{\n\t\tsearch(root, 0, ld, ru, out);\n\t}\n\tvoid search(node *t, int d, const Point &ld, const Point &ru, vector<Point> &out)\n\t{\n\t\tif (t == NULL) return;\n\t\tconst Point &p = t->p;\n\t\tif (real(ld) <= real(p) && real(p) <= real(ru) &&\n\t\t\timag(ld) <= imag(p) && imag(p) <= imag(ru)) out.push_back(p);\n\t\tif (!compare(d, p, ld)) search(t->l, !d, ld, ru, out);\n\t\tif (!compare(d, ru, p)) search(t->r, !d, ld, ru, out);\n\t}\n};\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tkdtree kd;\n\tREP(i, n)\n\t{\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tkd.insert(Point(x, y));\n\t}\n\tREP(i, m)\n\t{\n\t\tint a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tvector<Point> v;\n\t\tkd.search(Point(a, b), Point(c, d), v);\n\t\tcout << v.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\ntypedef complex<int> point;\n\nstruct kdtree {\n  struct node {\n    point p;\n\tint id;\n    node *l, *r;\n    node(const point &p,int _id)\n      : p(p), l(NULL), r(NULL), id(_id) { }\n  } *root;\n  int id;\n  kdtree() : root(NULL), id(0) { }\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n  void insert(const point &p) {\n    root = insert(root, 0, p);\n  }\n  node *insert(node *t, int d, const point &p) {\n    if (t == NULL) return new node(p,id++);\n    if (compare(d,p,t->p)) t->l = insert(t->l, !d, p);\n    else                   t->r = insert(t->r, !d, p);\n    return t;\n  }\n  void search(const point &ld, const point &ru, vector<int> &out) {\n    search(root, 0, ld, ru, out);\n  }\n  void search(node *t, int d, const point &ld, const point &ru, vector<int> &out) {\n    if (t == NULL) return;\n    const point &p = t->p;\n    if (real(ld) <= real(p) && real(p) <= real(ru) &&\n        imag(ld) <= imag(p) && imag(p) <= imag(ru)) out.push_back(t->id);\n    if (!compare(d,p,ld)) search(t->l, !d, ld, ru, out);\n    if (!compare(d,ru,p)) search(t->r, !d, ld, ru, out);\n  }\n};\n\nint main(){\n\tint n,m,x1,x2,y1,y2;\n\tkdtree kd;\n\tfor(scanf(\"%d%d\",&n,&m);n--;){\n\t\tscanf(\"%d%d\",&x1,&y1);\n\t\tkd.insert(point(x1,y1));\n\t}\n\tfor(;m--;){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tvector<int>out;\n\t\tkd.search(point(x1,y1),point(x2,y2),out);\n\t\tprintf(\"%d\\n\",out.size());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A[5010][2];\nshort S[10005][10005];\nint ANS = 0;\nint *R;\nint Xs[10005], Ys[10005];\nmap<int,int> zipx, zipy;\nint MAX = 1000000001;\n \nint compress(int *X, map<int, int> &zip, int n) {\n    sort(X, X + n);\n    R = unique(X, X + n);\n    int k = R - X;\n    for(int i = 0; i < k; i++){\n        zip[X[i]] = i;\n    }\n    return k;\n}\n \nint main(){\n\t\n    int N, M, x1, y1, x2, y2, xn, yn, ans;\n    cin >> N >> M;\n    for (int n = 0; n < N; n++) {\n        cin >> x1 >> y1;\n        A[n][0] = x1; A[n][1] = y1;\n        Xs[n * 2] = x1;\n        Xs[n * 2 + 1] = x1 - 1;\n        Ys[n * 2] = y1;\n        Ys[n * 2 + 1] = y1 - 1;\n    }\n     \n    Xs[N * 2] = -1 * MAX;\n    Xs[N * 2 + 1] = MAX;\n    Ys[N * 2] = -1 * MAX;\n    Ys[N * 2 + 1] = MAX;\n     \n    xn = compress(Xs, zipx, N * 2 + 2);\n    yn = compress(Ys, zipy, N * 2 + 2);\n     \n     \n    for (int n = 0; n < N; n ++) {\n        x1 = zipx[A[n][0]];\n        y1 = zipy[A[n][1]];\n        S[x1][y1] ++;\n    }\n     \n    for (int x = 1; x <= xn; x++) {\n        for (int y = 1; y <= yn; y ++) {\n            S[x][y] += S[x - 1][y] + S[x][y - 1] - S[x - 1][y - 1];\n        }\n    }\n    for (int m = 0; m < M; m ++) {\n        cin >> x1 >> y1 >> x2 >> y2;\n         \n        x1 = *lower_bound(Xs, Xs + xn, x1 - 1);\n        y1 = *lower_bound(Ys, Ys + yn, y1 - 1);\n        x2 = *lower_bound(Xs, Xs + xn, x2);\n        y2 = *lower_bound(Ys, Ys + yn, y2);\n         \n        x1 = zipx[x1];\n        x2 = zipx[x2];\n        y1 = zipy[y1];\n        y2 = zipy[y2];\n         \n        ans = S[x2][y2] - S[x1][y2] - S[x2][y1] + S[x1][y1];\n         \n        cout << ans << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <cstring>\n#include <string>\n#include <queue>\n#include <cmath>\n\n#define rep(i,n) for(int i = 0; i < (n); i++)\n#define all(v) (v).begin(), (v).end()\n#define rev(v) (v).rbegin(), (v).rend()\n#define MP make_pair\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\ntypedef long long ll;\n\nint main(){\n\t//freopen(\"test.txt\", \"r\", stdin);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<P> t(n);\n\trep(i, n) cin >> t[i].X >> t[i].Y;\n\tsort(all(t));\n\n\trep(i, m){\n\t\tint lx, by, rx, ty;\n\t\tcin >> lx >> by >> rx >> ty;\n\t\tvector<P>::iterator left, right;\n\t\tleft = lower_bound(all(t), MP(lx, -1<<29));\n\t\tright = lower_bound(all(t), MP(rx, 1<<29));\n\t\tint cnt = 0;\n\t\tfor(; left != right; left++){\n\t\t\tif(left->Y >= by && left->Y <= ty) cnt++;\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n#define FOR(i, m, n) for (int i = (m); i < (n); ++i)\n#define rrep(i, n) for (int i = (n) - 1; i >= 0; --i)\n#define rfor(i, m, n) for (int i = (m); i >= (n); --i)\n#define sz(x) ((int)(x).size())\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n#define range_it(a, l, r) (a).begin() + (l), (a).begin() + (r)\n\nusing namespace std;\nusing ll = long long;\t\tusing ld = long double;\nusing VB = vector<bool>;\tusing VVB = vector<VB>;\nusing VI = vector<int>;\t\tusing VVI = vector<VI>;\nusing VL = vector<ll>;\t\tusing VVL = vector<VL>;\nusing VS = vector<string>;\tusing VD = vector<ld>;\nusing PII = pair<int, int>;\tusing VP = vector<PII>;\nusing PLL = pair<ll, ll>;\tusing VPL = vector<PLL>;\ntemplate<class T>using PQ = priority_queue<T>;\ntemplate<class T>using PQS = priority_queue<T, vector<T>, greater<T>>;\nconstexpr int inf = (int)1e9;\nconstexpr ll inf_ll = (ll)1e18, MOD = 1000000007;\nconstexpr ld PI = M_PI, EPS = 1e-12;\n\n// --- input --- //\n#ifdef _WIN32\n#define getchar_unlocked _getchar_nolock\n#define putchar_unlocked _putchar_nolock\n#define fwrite_unlocked fwrite\n#define fflush_unlocked _fflush_nolock\n#endif\ninline int gc() { return getchar_unlocked(); }\ntemplate<class T>inline void InputF(T& v) { cin >> v; }\ninline void InputF(char& v) { while (isspace(v = gc())); }\ninline void InputF(bool& v) { char c; InputF(c); v = c != '0'; }\ninline void InputF(string& v) {\n\tv.clear(); char c; for (InputF(c); !isspace(c); c = gc())v += c;\n}\ninline void InputF(int& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(long long& v) {\n\tbool neg = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c); c = gc())v = v * 10 + (c - '0');\n\tif (neg)v = -v;\n}\ninline void InputF(double& v) {\n\tdouble dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ninline void InputF(long double& v) {\n\tlong double dp = 1; bool neg = false, adp = false; v = 0; char c; InputF(c);\n\tif (c == '-') { neg = true; c = gc(); }\n\tfor (; isdigit(c) || c == '.'; c = gc()) {\n\t\tif (c == '.')adp = true;\n\t\telse if (adp)v += (c - '0') * (dp *= 0.1);\n\t\telse v = v * 10 + (c - '0');\n\t}\n\tif (neg)v = -v;\n}\ntemplate<class T, class U>inline void InputF(pair<T, U>& v) { InputF(v.first); InputF(v.second); }\ntemplate<class T>inline void InputF(vector<T>& v) { for (auto& e : v)InputF(e); }\ntemplate<class T>inline T InputF() { T v; InputF(v); return v; }\ninline string GetLine() {\n\tstring v; char c; for (InputF(c); c != '\\n' && c != '\\0'; c = gc())v += c; return v;\n}\nstruct InputV {\n\tint n, m;\n\tInputV(int _n) :n(_n), m(0) {}\n\tInputV(const pair<int, int>& nm) :n(nm.first), m(nm.second) {}\n\ttemplate<class T>operator vector<T>() { vector<T> v(n); InputF(v); return v; }\n\ttemplate<class T>operator vector<vector<T>>() { vector<vector<T>> v(n, vector<T>(m)); InputF(v); return v; }\n};\nstruct Input {\n\ttemplate<class T>operator T() { return InputF<T>(); }\n\tint operator--(int) { int v; InputF(v); v--; return v; }\n\tInputV operator[](int n) { return InputV(n); }\n\tInputV operator[](const pair<int, int>& n) { return InputV(n); }\n\tvoid operator()() {}\n\ttemplate<class H, class...T>void operator()(H&& h, T&& ...t) { InputF(h); operator()(forward<T>(t)...); }\n}in;\n#define input(T) InputF<T>()\n#define INT input(int)\n#define LL input(ll)\n#define STR input(string)\n#define inputs(T, ...) T __VA_ARGS__; in(__VA_ARGS__)\n#define ini(...) inputs(int, __VA_ARGS__)\n#define inl(...) inputs(ll, __VA_ARGS__)\n#define ins(...) inputs(string, __VA_ARGS__)\n\n// --- output --- //\nstruct BoolStr {\n\tconst char* t, * f; BoolStr(const char* _t, const char* _f) :t(_t), f(_f) {}\n}Yes(\"Yes\", \"No\"), yes(\"yes\", \"no\"), YES(\"YES\", \"NO\"), Int(\"1\", \"0\");\nstruct DivStr {\n\tconst char* d, * l; DivStr(const char* _d, const char* _l) :d(_d), l(_l) {}\n}spc(\" \", \"\\n\"), no_spc(\"\", \"\\n\"), end_line(\"\\n\", \"\\n\"), comma(\",\", \"\\n\"), no_endl(\" \", \"\");\nclass Output {\n\tBoolStr B{ Yes }; DivStr D{ spc };\n\tvoid p(int v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[10]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(ll v) {\n\t\tif (v < 0)putchar_unlocked('-'), v = -v;\n\t\tchar b[20]; int i = 0;\n\t\twhile (v)b[i++] = '0' + v % 10, v /= 10;\n\t\tif (!i)b[i++] = '0';\n\t\twhile (i--)putchar_unlocked(b[i]);\n\t}\n\tvoid p(bool v) { p(v ? B.t : B.f); }\n\tvoid p(char v) { putchar_unlocked(v); }\n\tvoid p(const char* v) { fwrite_unlocked(v, 1, strlen(v), stdout); }\n\tvoid p(double v) { printf(\"%.20f\", v); }\n\tvoid p(ld v) { printf(\"%.20Lf\", v); }\n\ttemplate<class T> void p(const T& v) { cout << v; }\n\ttemplate<class T, class U>void p(const pair<T, U>& v) { p(v.first); p(D.d); p(v.second); }\n\ttemplate<class T>void p(const vector<T>& v) { rep(i, sz(v)) { if (i)p(D.d); p(v[i]); } }\n\ttemplate<class T>void p(const vector<vector<T>>& v) { rep(i, sz(v)) { if (i)p(D.l); p(v[i]); } }\npublic:\n\tOutput& operator()() { p(D.l); return *this; }\n\ttemplate<class H>Output& operator()(H&& h) { p(h); p(D.l); return *this; }\n\ttemplate<class H, class...T>Output& operator()(H&& h, T&& ...t) {\n\t\tp(h); p(D.d); return operator()(forward<T>(t)...);\n\t}\n\ttemplate<class It>Output& range(const It& l, const It& r) {\n\t\tfor (It i = l; i != r; i++) { if (i != l)p(D.d); p(*i); } p(D.l); return *this;\n\t}\n\ttemplate<class T>Output& range(const T& a) {\n\t\trange(a.begin(), a.end()); return *this;\n\t}\n\ttemplate<class...T>void exit(T&& ...t) { operator()(forward<T>(t)...); std::exit(EXIT_SUCCESS); }\n\tOutput& flush() { fflush_unlocked(stdout); return *this; }\n\tOutput& set(const BoolStr& b) { B = b; return *this; }\n\tOutput& set(const DivStr& d) { D = d; return *this; }\n\tOutput& set(const char* t, const char* f) { B = BoolStr(t, f); return *this; }\n}out;\n\n// --- step --- //\ntemplate<class T>struct Step {\n\tclass It {\n\t\tT a, b, c;\n\tpublic:\n\t\tconstexpr It() : a(T()), b(T()), c(T()) {}\n\t\tconstexpr It(T _b, T _c, T _s) : a(_b), b(_c), c(_s) {}\n\t\tconstexpr It& operator++() { --b; a += c; return *this; }\n\t\tconstexpr It operator++(int) { It tmp = *this; --b; a += c; return tmp; }\n\t\tconstexpr const T& operator*()const { return a; }\n\t\tconstexpr const T* operator->()const { return &a; }\n\t\tconstexpr bool operator==(const It& i)const { return b == i.b; }\n\t\tconstexpr bool operator!=(const It& i)const { return !(b == i.b); }\n\t\tconstexpr T start()const { return a; }\n\t\tconstexpr T count()const { return b; }\n\t\tconstexpr T step()const { return c; }\n\t};\n\tconstexpr Step(T b, T c, T s) : be(b, c, s) {}\n\tconstexpr It begin()const { return be; }\n\tconstexpr It end()const { return en; }\n\tconstexpr T start()const { return be.start(); }\n\tconstexpr T count()const { return be.count(); }\n\tconstexpr T step()const { return be.step(); }\n\tconstexpr T sum()const { return start() * count() + step() * (count() * (count() - 1) / 2); }\n\toperator vector<T>()const { return as_vector(); }\n\ttemplate<class F>void each(const F& f)const { for (T i : *this)f(i); }\n\tauto as_vector()const {\n\t\tvector<T> res; res.reserve(count()); each([&](T i) {res.push_back(i); }); return res;\n\t}\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto map(const F& f)const {\n\t\tvector<U> res; res.reserve(count()); each([&](T i) {res.push_back(f(i)); }); return res;\n\t}\n\ttemplate<class F>auto select(const F& f)const {\n\t\tvector<T> res; each([&](T i) {if (f(i))res.push_back(i); }); return res;\n\t}\n\ttemplate<class F>int count_if(const F& f)const { int res = 0; each([&](T i) {if (f(i))++res; }); return res; }\n\ttemplate<class F>T find_if(const F& f)const { for (T i : *this)if (f(i))return i; return 0; }\n\ttemplate<class F>auto max_by(const F& f)const { auto v = map(f); return *max_element(v.begin(), v.end()); }\n\ttemplate<class F>auto min_by(const F& f)const { auto v = map(f); return *min_element(v.begin(), v.end()); }\n\ttemplate<class F>bool all_of(const F& f)const { for (T i : *this)if (!f(i))return false; return true; }\n\ttemplate<class F>bool any_of(const F& f)const { for (T i : *this)if (f(i))return true; return false; }\n\ttemplate<class F, class U = decay_t<result_of_t<F(T)>>>auto sum(const F& f)const {\n\t\tU res = 0; each([&](T i) {res += static_cast<U>(f(i)); }); return res;\n\t}\n\tusing value_type = T;\n\tusing iterator = It;\nprivate:\n\tIt be, en;\n};\ntemplate<class T>inline constexpr auto step(T a) { return Step<T>(0, a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b) { return Step<T>(a, b - a, 1); }\ntemplate<class T>inline constexpr auto step(T a, T b, T c) { return Step<T>(a, a < b ? (b - a - 1) / c + 1 : 0, c); }\n\n// --- functions --- //\ninline namespace {\n\ttemplate<class T>inline void Sort(T& a) { sort(all(a)); }\n\ttemplate<class T>inline void RSort(T& a) { sort(rall(a)); }\n\ttemplate<class T>inline T Sorted(T a) { Sort(a); return a; }\n\ttemplate<class T>inline T RSorted(T a) { RSort(a); return a; }\n\ttemplate<class T, class F>inline void Sort(T& a, const F& f) {\n\t\tsort(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline void RSort(T& a, const F& f) {\n\t\tsort(rall(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T>inline void Reverse(T& a) { reverse(all(a)); }\n\ttemplate<class T>inline void Unique(T& a) { a.erase(unique(all(a)), a.end()); }\n\ttemplate<class T>inline void Uniq(T& a) { Sort(a); Unique(a); }\n\ttemplate<class T>inline void Rotate(T& a, int left) { rotate(a.begin(), a.begin() + left, a.end()); }\n\ttemplate<class T>inline T Reversed(T a) { Reverse(a); return a; }\n\ttemplate<class T>inline T Uniqued(T a) { Unique(a); return a; }\n\ttemplate<class T>inline T Uniqed(T a) { Uniq(a); return a; }\n\ttemplate<class T>inline T Rotated(T a, int left) { Rotate(a, left); return a; }\n\ttemplate<class T>inline auto Max(const T& a) { return *max_element(all(a)); }\n\ttemplate<class T>inline auto Min(const T& a) { return *min_element(all(a)); }\n\ttemplate<class T>inline int MaxPos(const T& a) { return max_element(all(a)) - a.begin(); }\n\ttemplate<class T>inline int MinPos(const T& a) { return min_element(all(a)) - a.begin(); }\n\ttemplate<class T, class F>inline auto MaxBy(const T& a, const F& f) {\n\t\treturn *max_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class F>inline auto MinBy(const T& a, const F& f) {\n\t\treturn *min_element(all(a), [&](const auto& x, const auto& y) {return f(x) < f(y); });\n\t}\n\ttemplate<class T, class U>inline int Count(const T& a, const U& v) { return count(all(a), v); }\n\ttemplate<class T, class F>inline int CountIf(const T& a, const F& f) { return count_if(all(a), f); }\n\ttemplate<class T, class U>inline int Find(const T& a, const U& v) { return find(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline int FindIf(const T& a, const F& f) { return find_if(all(a), f) - a.begin(); }\n\ttemplate<class T, class U = typename T::value_type>inline U Sum(const T& a) { return accumulate(all(a), U()); }\n\ttemplate<class T, class U>inline bool Includes(const T& a, const U& v) { return find(all(a), v) != a.end(); }\n\ttemplate<class T, class F>inline auto Sum(const T& v, const F& f) {\n\t\treturn accumulate(next(v.begin()), v.end(), f(v.front()), [&](auto a, auto b) {return a + f(b); });\n\t}\n\ttemplate<class T, class U>inline int Lower(const T& a, const U& v) { return lower_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class U>inline int Upper(const T& a, const U& v) { return upper_bound(all(a), v) - a.begin(); }\n\ttemplate<class T, class F>inline void RemoveIf(T& a, const F& f) { a.erase(remove_if(all(a), f), a.end()); }\n\ttemplate<class F>inline auto Vector(size_t size, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t)>>> res(size); for (size_t i = 0; i < size; ++i)res[i] = f(i); return res;\n\t}\n\ttemplate<class T>inline auto Grid(size_t h, size_t w, const T& v = T()) { return vector<vector<T>>(h, vector<T>(w, v)); }\n\ttemplate<class T>inline auto Slice(const T& v, size_t i, size_t len) {\n\t\treturn i < v.size() ? T(v.begin() + i, v.begin() + min(i + len, v.size())) : T();\n\t}\n\ttemplate<class T, class F>inline auto Each(const T& v, const F& f) { for (auto& i : v)f(i); }\n\ttemplate<class T, class F>inline auto Select(const T& v, const F& f) {\n\t\tT res; for (const auto& e : v)if (f(e))res.push_back(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto Map(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (const auto& e : v)res[i++] = f(e); return res;\n\t}\n\ttemplate<class T, class F>inline auto MapIndex(const T& v, const F& f) {\n\t\tvector<decay_t<result_of_t<F(size_t, typename T::value_type)>>> res(v.size());\n\t\tsize_t i = 0; for (auto it = v.begin(); it != v.end(); ++it, ++i)res[i] = f(i, *it); return res;\n\t}\n\ttemplate<class T, class F>inline auto TrueIndex(const T& v, const F& f) {\n\t\tvector<size_t> res; for (size_t i = 0; i < v.size(); ++i)if (f(v[i]))res.push_back(i); return res;\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline auto Indexed(const T& v) {\n\t\tvector<pair<U, int>> res(v.size());\n\t\tfor (int i = 0; i < (int)v.size(); ++i)res[i] = make_pair(static_cast<U>(v[i]), i);\n\t\treturn res;\n\t}\n\tinline auto operator*(string s, size_t n) { string ret; for (size_t i = 0; i < n; ++i)ret += s; return ret; }\n\ttemplate<class T>inline auto& operator<<(vector<T>& v, const vector<T>& v2) { v.insert(v.end(), all(v2)); return v; }\n\ttemplate<class T>inline T Ceil(T n, T m) { return (n + m - 1) / m; }\n\ttemplate<class T>inline T Ceil2(T n, T m) { return Ceil(n, m) * m; }\n\ttemplate<class T>inline T Tri(T n) { return (n & 1) ? (n + 1) / 2 * n : n / 2 * (n + 1); }\n\ttemplate<class T>inline T nC2(T n) { return (n & 1) ? (n - 1) / 2 * n : n / 2 * (n - 1); }\n\ttemplate<class T>inline T Mid(const T& l, const T& r) { return l + (r - l) / 2; }\n\tinline int pop_count(int n) { return bitset<32>(n).count(); }\n\tinline int pop_count(ll n) { return bitset<64>(n).count(); }\n\ttemplate<class T>inline bool chmax(T& a, const T& b) { if (a < b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool chmin(T& a, const T& b) { if (a > b) { a = b; return true; } return false; }\n\ttemplate<class T>inline bool inRange(const T& v, const T& min, const T& max) { return min <= v && v < max; }\n\ttemplate<class T = ll>inline T BIT(int b) { return T(1) << b; }\n\ttemplate<class T>inline T Gcd(T n, T m) { return m ? Gcd(m, n % m) : n; }\n\ttemplate<class T>inline T Lcm(T n, T m) { return n / Gcd(n, m) * m; }\n\ttemplate<class T, class U = typename T::value_type>inline U Gcdv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Gcd<U>);\n\t}\n\ttemplate<class T, class U = typename T::value_type>inline U Lcmv(const T& v) {\n\t\treturn accumulate(next(v.begin()), v.end(), U(*v.begin()), Lcm<U>);\n\t}\n\ttemplate<class T>inline T Pow(T a, T n) { T r = 1; while (n > 0) { if (n & 1)r *= a; a *= a; n /= 2; } return r; }\n\ttemplate<class T>inline T Powmod(T a, T n, T m = MOD) {\n\t\tT r = 1; while (n > 0) { if (n & 1)r = r * a % m, n--; else a = a * a % m, n /= 2; }return r;\n\t}\n}\n\n// --- dump --- //\n#if __has_include(\"dump.hpp\")\n#include \"dump.hpp\"\n#else\n#define dump(...) ((void)0)\n#endif\n\n// ---------------------------------------------------------------- //\n\ntemplate<class T>class Compress {\n\tvector<T> v;\n\tbool flag = false;\npublic:\n\tCompress() {}\n\ttemplate<class U>Compress(const U& a) { add(a); }\n\ttemplate<class U>Compress& operator<<(const U& a) { add(a); return *this; }\n\tCompress& add(const T& a) {\n\t\tflag = false;\n\t\tv.push_back(a);\n\t\treturn *this;\n\t}\n\tCompress& add(const vector<T>& a) {\n\t\tflag = false;\n\t\tv.insert(v.end(), a.begin(), a.end());\n\t\treturn *this;\n\t}\n\ttemplate<class U>Compress& add(const initializer_list<U>& a) {\n\t\tflag = false;\n\t\tfor (const auto& v : a)add(v);\n\t\treturn *this;\n\t}\n\tvoid build() {\n\t\tsort(v.begin(), v.end());\n\t\tv.erase(unique(v.begin(), v.end()), v.end());\n\t\tflag = true;\n\t}\n\tint operator()(const T& x)const {\n\t\tassert(flag);\n\t\treturn lower_bound(v.begin(), v.end(), x) - v.begin();\n\t}\n\tvector<int> operator()(const vector<T>& x)const {\n\t\tassert(flag);\n\t\tvector<int> res; res.reserve(x.size());\n\t\tfor (const T& i : x)res.push_back(lower_bound(v.begin(), v.end(), i) - v.begin());\n\t\treturn res;\n\t}\n\tint size()const { assert(flag); return v.size(); }\n\tconst vector<T>& operator*()const { assert(flag); return v; }\n\tconst T& operator[](int i)const { assert(flag); return v[i]; }\n};\n\ntemplate<class T>class CulSum2D {\n\tint h, w; vector<vector<T>> s;\npublic:\n\tCulSum2D(const vector<vector<T>>& a) :h(a.size()), w(a.front().size()), s(h + 1, vector<T>(w + 1)) {\n\t\tfor (int i = 0; i < h; ++i)for (int j = 0; j < w; ++j)\n\t\t\ts[i + 1][j + 1] = s[i][j + 1] + s[i + 1][j] - s[i][j] + a[i][j];\n\t}\n\ttemplate<class U, class F>\n\tCulSum2D(const U& a, F f) : h(a.size()), w(a.front().size()), s(h + 1, vector<T>(w + 1)) {\n\t\tfor (int i = 0; i < h; ++i)for (int j = 0; j < w; ++j)\n\t\t\ts[i + 1][j + 1] = s[i][j + 1] + s[i + 1][j] - s[i][j] + static_cast<T>(f(a[i][j]));\n\t}\n\t// [y1, y2) * [x1, x2)\n\tT operator()(int y1, int y2, int x1, int x2) {\n\t\tx1 = min(max(x1, 0), w); x2 = min(max(x2, 0), w);\n\t\ty1 = min(max(y1, 0), h); y2 = min(max(y2, 0), h);\n\t\treturn (x1 > x2 || y1 > y2) ? 0 : s[y2][x2] - s[y1][x2] - s[y2][x1] + s[y1][x1];\n\t}\n\t// [0, y) * [0, x)\n\tT operator()(int y, int x) {\n\t\tx = min(max(x, 0), w); y = min(max(y, 0), h);\n\t\treturn s[y][x];\n\t}\n\tconst vector<vector<T>>& get_s() { return s; }\n};\n\nint main() {\n\tini(n, m);\n\tVI x(n), y(n);\n\trep(i, n)in(x[i], y[i]);\n\tCompress<int> X(x), Y(y);\n\tX.build(); Y.build();\n\tx = X(x); y = Y(y);\n\n\tVVI table = Grid<int>(sz(Y), sz(X));\n\trep(i, n)table[y[i]][x[i]]++;\n\tCulSum2D<int> sum(table);\n\trep(i, m) {\n\t\tini(x1, y1, x2, y2);\n\t\tx1 = Lower(*X, x1);\n\t\tx2 = Upper(*X, x2);\n\t\ty1 = Lower(*Y, y1);\n\t\ty2 = Upper(*Y, y2);\n\t\tout(sum(y1, y2, x1, x2));\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nstruct dat {\n    int id;\n    int z;\n\n    dat () {}\n    ~dat () {}\n\n    dat (int a, int b): id(a), z(b) {}\n    \n    bool operator < (const dat& o) const {\n        return z == o.z ? id < o.id : z < o.z;\n    }\n};\n\nint N, M;\nint tx[5000], ty[5000];\n\ndat arr_x[5000];\ndat arr_y[5000];\n\nint check[5000];\n\nint solve(int x1, int y1, int x2, int y2) {\n    fill(check, check + N, 0);\n\n    int idxx = lower_bound(arr_x, arr_x+N, dat(-1, x1)) - arr_x;\n    for (int j = idxx; j < N && arr_x[j].z <= x2; ++j) {\n        check[ arr_x[j].id ] += 1;\n    }\n\n    int idxy = lower_bound(arr_y, arr_y+N, dat(-1, y1)) - arr_y;\n    for (int j = idxy; j < N && arr_y[j].z <= y2; ++j) {\n        check[ arr_y[j].id] += 1;\n    }\n\n    int ans = 0;\n    for (int j = 0; j < N; ++j) {\n        ans += check[j] >> 1;\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    for (int j = 0; j < N; ++j) {\n        cin >> tx[j] >> ty[j];\n    }\n\n    // initialize\n    for (int j = 0; j < N; ++j) {\n        arr_x[j] = dat(j, tx[j]);\n        arr_y[j] = dat(j, ty[j]);\n    }\n    sort(arr_x, arr_x + N);\n    sort(arr_y, arr_y + N);\n\n    for (int j = 0; j < M; ++j) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        cout << solve(x1, y1, x2, y2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\nint n,m;\nint sum[5100][5100];\nint main(int argc, char *argv[])\n{\n  cin >> n >> m;\n  vector<int> appx,appy;\n  vector<PI> tr(n);\n  rep(i,n){\n    cin >> tr[i].F >> tr[i].S;\n    appx.pb(tr[i].F);\n    appy.pb(tr[i].S);\n  }\n  sort(ALL(appx));\n  sort(ALL(appy));\n  appx.erase(unique(ALL(appx)),appx.end());\n  appy.erase(unique(ALL(appy)),appy.end());\n  map<int,int> xidx,yidx;\n  rep(i,SZ(appx)) xidx[appx[i]]=i;\n  rep(i,SZ(appy)) yidx[appy[i]]=i;\n\n\n  FOR(it,tr) ++sum[xidx[it->F]+1][yidx[it->S]+1];\n  rep(i,SZ(xidx)+10)rep(j,SZ(yidx)+10)\n    sum[i+1][j+1]+=sum[i+1][j]+sum[i][j+1]-sum[i][j];\n  \n  rep(i,m){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1=lower_bound(ALL(appx),x1)-appx.begin();\n    x2=lower_bound(ALL(appx),x2+1)-appx.begin();\n    y1=lower_bound(ALL(appy),y1)-appy.begin();\n    y2=lower_bound(ALL(appy),y2+1)-appy.begin();\n    if(x1>x2 || y1>y2 || x2>SZ(xidx)+10 || y2>SZ(yidx)+10) break;\n    cout << sum[x2][y2]+sum[x1][y1]-sum[x1][y2]-sum[x2][y1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e9 + 1;\n\n// 座標圧縮 vector a の要素を圧縮して d に変換\nstruct Compress{\n    vector<int> d, unzip;\n    map<int, int> zip;        \n    Compress(vector<int> a){\n        vector<int> b = a;\n        d.resize(a.size());\n        sort(b.begin(), b.end());\n        b.erase(unique(b.begin(), b.end()), b.end());\n        unzip.resize(b.size());\n        for(int i = 0; i < b.size(); i++){\n            zip[b[i]] = i;\n            unzip[i] = b[i];\n        }\n        for(int i = 0; i < a.size(); i++){\n            d[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin();\n        }\n    }\n};\n\n// build を忘れない！！！！！\nstruct CumulativeSum2D{\n    vector<vector<int> > data;\n    CumulativeSum2D(int H, int W) : data(H + 1, vector<int>(W + 1, 0)) {}\n    //要素(x,y)に値zを加える\n    void add(int x, int y, int z){\n        ++x, ++y;\n        if(x >= data.size() || y >= data[0].size()) return;\n        data[x][y] += z;\n    }\n    void build(){\n        for(int i = 1; i < data.size(); i++) {\n        for(int j = 1; j < data[i].size(); j++) {\n            data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];\n            }\n        }\n    }\n    //左上[sy, sx], 右下(gx, gy)の矩形内の和を求める(半開区間) (0-index)\n    int query(int sx, int sy, int gx, int gy){\n        return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n    }\n};\n\n/*\nverified\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n*/\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n), y(n);\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n    }\n    x.push_back(-MAX);\n    y.push_back(-MAX);\n    x.push_back(MAX);\n    y.push_back(MAX);\n    Compress cx(x), cy(y);\n    CumulativeSum2D cs(n + 2, n + 2);\n    for(int i = 0; i < x.size(); i++){\n        if(i < n) cs.add(cx.d[i], cy.d[i], 1);\n        // cout << \" \" << cx.d[i] << ' ' << cy.d[i] << endl;\n    }\n    cs.build();\n    // for(int ii = 0; ii < cx.unzip.size(); ii++){\n    //     if(ii) cout << ' ';\n    //     cout << cx.unzip[ii];\n    // }\n    // cout << endl;    \n    // for(int ii = 0; ii < cy.unzip.size(); ii++){\n    //     if(ii) cout << ' ';\n    //     cout << cy.unzip[ii];\n    // }\n    // cout << endl;\n    for(int i = 0; i < m; i++){\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(cx.unzip.begin(), cx.unzip.end(), x1) - cx.unzip.begin();\n        y1 = lower_bound(cy.unzip.begin(), cy.unzip.end(), y1) - cy.unzip.begin();\n        x2 = upper_bound(cx.unzip.begin(), cx.unzip.end(), x2) - cx.unzip.begin() - 1;\n        y2 = upper_bound(cy.unzip.begin(), cy.unzip.end(), y2) - cy.unzip.begin() - 1;\n        // cout << x1 << ' ' << y1 << ' ' << x2 << ' ' << y2 << endl;\n        if(x1 > x2 || y1 > y2){\n            cout << 0 << endl;\n            continue;\n        }\n        int tmp = cs.query(x1, y1, x2 + 1, y2 + 1);\n        cout << tmp << endl; \n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <set>\n#include <map>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <algorithm>\n#include <cstring>\n#include <functional>\n#include <cmath>\n#include <complex>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<(n);++i)\n#define rep1(i,n) for(int i=1;i<=(n);++i)\n#define all(c) (c).begin(),(c).end()\n#define fs first\n#define sc second\n#define pb push_back\n#define show(x) cout << #x << \" \" << x << endl\nshort int imos[5001][5001];\nint n,m,x[5000],y[5000];\nvector<int> ashx,ashy;\nint main(){\n\tcin>>n>>m;\n\trep(i,n){\n\t\tcin>>x[i]>>y[i];\n\t\tashx.pb(x[i]);\n\t\tashy.pb(y[i]);\n\t}\n\tsort(all(ashx));\n\tsort(all(ashy));\n\tashx.erase(unique(all(ashx)),ashx.end());\n\tashy.erase(unique(all(ashy)),ashy.end());\n\trep(i,n) x[i]=lower_bound(all(ashx),x[i])-ashx.begin();\n\trep(i,n) y[i]=lower_bound(all(ashy),y[i])-ashy.begin();\n\tint h=ashx.size(),w=ashy.size();\n\trep(i,n) imos[x[i]+1][y[i]+1]++;\n\trep(i,h+1) rep(j,w) imos[i][j+1]+=imos[i][j];\n\trep(i,h) rep(j,w+1) imos[i+1][j]+=imos[i][j];\n\trep(i,m){\n\t\tint sx,sy,tx,ty,isx,isy,itx,ity;\n\t\tcin>>sx>>sy>>tx>>ty;\n\t\tisx=lower_bound(all(ashx),sx)-ashx.begin();\n\t\tisy=lower_bound(all(ashy),sy)-ashy.begin();\n\t\titx=upper_bound(all(ashx),tx)-ashx.begin();\n\t\tity=upper_bound(all(ashy),ty)-ashy.begin();\n\t\tcout<<imos[itx][ity]-imos[itx][isy]-imos[isx][ity]+imos[isx][isy]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define MAX 1000000000\n\nint n,m;\nint sum[5100][5100];\npair<int,int> p[5100];\nvector<int> x,y;\nint x1,y1,x2,y2;\nvector<int>::iterator it;\n\nint main(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++){\n    cin >> p[i].fs >> p[i].sc;\n    x.push_back(p[i].fs); y.push_back(p[i].sc);\n  }\n\n  x.push_back(MAX); x.push_back(-MAX); \n  y.push_back(MAX); y.push_back(-MAX);\n  sort(x.begin(),x.end()); sort(y.begin(),y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n\n  for(int i=0;i<n;i++){\n    p[i].fs = lower_bound(x.begin(),x.end(),p[i].fs) - x.begin();\n    p[i].sc = lower_bound(y.begin(),y.end(),p[i].sc) - y.begin();\n  }\n  sort(p,p+n);\n\n  int cnt = 0;\n  for(int i=0;i<x.size();i++){\n    for(int j=0;j<y.size();j++){\n      if(!i || !j)sum[i][j] = 0;\n      else sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1];\n      while(cnt<n && p[cnt].fs == i && p[cnt].sc == j){\n\tsum[i][j]++;\n\tcnt++;\n      }\n    }\n  }\n\n  for(int i=0;i<m;i++){\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = lower_bound(x.begin(),x.end(),x1)-x.begin()-1;\n    y1 = lower_bound(y.begin(),y.end(),y1)-y.begin()-1;\n    x2 = upper_bound(x.begin(),x.end(),x2)-x.begin()-1;\n    y2 = upper_bound(y.begin(),y.end(),y2)-y.begin()-1;\n    cout << sum[x2][y2] - sum[x2][y1] - sum[x1][y2] + sum[x1][y1] << endl;\n  }\n}\n\t\n  "
  },
  {
    "language": "C++",
    "code": "// Author :\n// Date :\n// Problem:\n// Solution:\n// Comment:\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n\n#define pp push\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n\nusing namespace std;\n\nvector < pair <int,int> > pts;\n\nmain(){\n    int n , m;\n    int x , y;\n    \n    scanf(\"%d%d\",&n,&m);\n    \n    for(int i = 0 ; i < n ; i++){\n        scanf(\"%d %d\",&x,&y);\n        pts.pb(mp(x,y));\n    }\n    \n    int xx,yy;\n    \n    sort( pts.begin() , pts.end() );\n    \n    for(int i = 0 ; i < m ; i++){\n        int cnt = 0;\n        \n        scanf(\"%d %d %d %d\",&x,&y,&xx,&yy);\n        \n        for(int j = 0 ; j < n ; j++){\n            if(x <= pts[j].xx && xx >= pts[j].xx && y <= pts[j].yy && yy >= pts[j].yy){\n                cnt++;\n            }\n            if(x > pts[j].xx) break;\n        }\n        printf(\"%d\\n\",cnt);\n    }\n\n    #ifdef GEREL\n        for(;;);\n    #endif\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<set>\n#include<map>\n#include<vector>\n#include<algorithm>\n\n#define fst first\n#define snd second\n\nusing namespace std;\n\ntypedef pair<int,int> pp;\ntypedef long long int lli;\n\nmultiset<pp> tr;\nset<lli> xa, ya;\nvector<lli> xv, yv;\nint field[6000][6000];\n\nint main(void) {\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    int ix=0, iy=0;\n    xa.insert(-2000000000);\n    xa.insert(+2000000000);\n    ya.insert(-2000000000);\n    ya.insert(+2000000000);\n    for(int i=0; i<n; i++) {\n        lli x,y;\n        scanf(\"%lld%lld\",&x,&y);\n        xa.insert(x);\n        ya.insert(y);\n        tr.insert(pp(x,y));\n    }\n\n    for(lli x : xa)\n        xv.push_back(x);\n    for(lli y : ya)\n        yv.push_back(y);\n\n    field[0][0] = tr.count(pp(xv[0],yv[0]));\n    auto itx = ++xv.begin(), ity = ++yv.begin();\n    for(int i=1; i<xv.size(); i++,itx++)\n        field[i][0] = field[i-1][0] + tr.count(pp(*itx,yv[0]));\n    for(int i=1; i<yv.size(); i++,ity++)\n        field[0][i] = field[0][i-1] + tr.count(pp(xv[0],*ity));\n\n    itx = ++xv.begin();\n    for(int i=1; i<xv.size(); i++,itx++) {\n        ity = ++yv.begin();\n        for(int j=1; j<yv.size(); j++,ity++)\n            field[i][j] = -field[i-1][j-1] + field[i-1][j] + field[i][j-1] + tr.count(pp(*itx,*ity));\n    }\n\n    for(int i=0; i<m; i++) {\n        lli x1,y1,x2,y2;\n        scanf(\"%lld%lld%lld%lld\",&x1,&y1,&x2,&y2);\n\n        int sx,sy,tx,ty;\n        sx = lower_bound(begin(xv), end(xv), x1)-begin(xv);\n        sy = lower_bound(begin(yv), end(yv), y1)-begin(yv);\n        tx = upper_bound(begin(xv), end(xv), x2)-begin(xv)-1;\n        ty = upper_bound(begin(yv), end(yv), y2)-begin(yv)-1;\n        //printf(\"%d - %d - %d + %d\\n\",field[tx][ty] , field[sx-1][ty] , field[tx][sy-1] , field[sx-1][sy-1]);\n        printf(\"%d\\n\",field[tx][ty] - field[sx-1][ty] - field[tx][sy-1] + field[sx-1][sy-1]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\n\nmap<int, int> mx, my;\n\nint s[5010][5010];\n\nint get(int x1, int y1, int x2, int y2) {\n\treturn s[y2][x2] - s[y1][x2] - s[y2][x1] + s[y1][x1];\n}\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(n), y(n);\n\trep(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t\tmx[x[i]]++;\n\t\tmy[y[i]]++;\n\t}\n\tint cnt_x = 0, cnt_y = 0;\n\tfor(auto& p : mx) p.se = ++cnt_x;\n\tfor(auto& p : my) p.se = ++cnt_y;\n\tfor(int i = 0; i < n; i++) s[my[y[i]]][mx[x[i]]]++;\n\tfor(int i = 0; i < 5010; i++) for(int j = 1; j < 5010; j++) s[i][j] += s[i][j-1];\n\tfor(int i = 1; i < 5010; i++) for(int j = 0; j < 5010; j++) s[i][j] += s[i-1][j];\n\t\n\trep(i, m) {\n\t\tint qx1, qy1, qx2, qy2;\n\t\tcin >> qx1 >> qy1 >> qx2 >> qy2;\n\t\tint x1, x2, y1, y2;\n\t\tif(mx.lower_bound(qx1) == mx.end() || my.lower_bound(qy1) == my.end()) {\n\t\t\tcout << 0 <<endl;\n\t\t\tcontinue;\n\t\t}\n\t\tx1 = (mx.lower_bound(qx1))->se-1;\n\t\ty1 = (my.lower_bound(qy1))->se-1;\n\t\tx2 = (--mx.upper_bound(qx2))->se;\n\t\ty2 = (--my.upper_bound(qy2))->se;\n\t\tcout << get(x1, y1, x2, y2) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define EPS (1e-10)\n#define mp make_pair\n#define pb push_back\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef pair<int,int> pii;\n\nint dx[] = {0,1,0,-1}, dy[] = {1,0,-1,0};\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\twhile( 1 ){\n\t\t\tif( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\tif( (*it).first > x2 ) it = upper_bound(treasure.begin(), treasure.end(),mp(-INF,(*it).second+1));\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, x1_, y1_, x2_, y2_;\n\nvector<int> x, y;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    \n    x = vector<int>(n);\n    y = vector<int>(n);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x[i]);\n        scanf(\"%d\", &y[i]);\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = i + 1; j < n; j++)\n        {\n            if(x[i] > x[j])\n            {\n                swap(x[i], x[j]);\n                swap(y[i], y[j]);\n            }\n        }\n    }\n    \n    for(int i = 0; i < m; i++)\n    {\n        scanf(\"%d\", &x1_);\n        scanf(\"%d\", &y1_);\n        scanf(\"%d\", &x2_);\n        scanf(\"%d\", &y2_);\n        \n        int s = distance(x.begin(), upper_bound(x.begin(), x.end(), x1_ - 1));\n        int t = distance(x.begin(), lower_bound(x.begin(), x.end(), x2_));\n        \n        int ret = 0;\n        \n        for(int j = s; j <= t; j++)\n        {\n            if(y1_ <= y[j] && y[j] <= y2_)\n            {\n                ret++;\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n\n#define F first\n#define S second\nconst int LIM = 1e9+5;\n\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nvector<P> V;\n\nvoid input(){\n  cin >> n >> m;\n  V.resize(n);\n  for(int i = 0; i < n; i++) cin >> V[i].F >> V[i].S;\n}\n\nvoid solve(){\n  sort(V.begin(),V.end());\n\n  for(int i = 0; i < m; i++){\n    int l,r,d,u;\n    scanf(\"%d %d %d %d\",&l,&d,&r,&u);\n \n    int ans = 0;\n    vector<P>::iterator ite = lower_bound(V.begin(),V.end(),P(l,-LIM));\n    \n    while(ite < V.end()){\n      if(ite->F > r) break;\n      //  cout << ite->F << \" \" << ite->S << endl;\n      if(d <= ite->S && ite->S <= u){\n\tans++;\n\tite++;\n      }else ite = lower_bound(V.begin(),V.end(),P(ite->F+1,-LIM));\n  \n    }\n    printf(\"%d\\n\",ans);\n  }\n}\n\nint main(){\n  input();\n  solve();\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\ntypedef pair<int,int> P;\nconst int MAX = 5000;\n\nint acc[MAX + 8][MAX + 8];\nint trecd[MAX + 8][MAX + 8];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> xs, ys;\n  vector<P> treasures(n);\n  for (P &p : treasures) {\n    cin >> p.first >> p.second;\n    xs.push_back(p.first);\n    ys.push_back(p.second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n/*  for (int x : xs) cout << x << \" \"; cout << endl;\n  for (int y : ys) cout << y << \" \"; cout << endl;\n*/\n  for (P p : treasures) {\n    int x = find(xs.begin(), xs.end(), p.first) - xs.begin() + 1;\n    int y = find(ys.begin(), ys.end(), p.second) - ys.begin() + 1;\n    trecd[x][y]++;\n  }\n  \n  for (int y = 1; y < MAX; y++) for (int x = 1; x < MAX; x++) {\n    acc[x][y] = acc[x][y-1] + acc[x-1][y] - acc[x-1][y-1] + trecd[x][y];\n  }\n\n/*  REP(y, 10) {\n    REP(x, 10) {\n      cout << acc[x][y] << \" \";\n    }\n    cout << endl;\n  }*/\n\n  REP (i, m) {\n    int xb, yb, xe, ye;\n    cin >> xb >> yb >> xe >> ye;\n    xb = upper_bound(xs.begin(), xs.end(), xb - 1) - xs.begin() + 1;\n    yb = upper_bound(ys.begin(), ys.end(), yb - 1) - ys.begin() + 1;\n    xe = *(lower_bound(xs.begin(), xs.end(), xe + 1) - 1);\n    xe = lower_bound(xs.begin(), xs.end(), xe) - xs.begin() + 1;\n    ye = *(lower_bound(ys.begin(), ys.end(), ye + 1) - 1);\n    ye = lower_bound(ys.begin(), ys.end(), ye) - ys.begin() + 1;\n//  cout << \"(\" << xb << \" \" << yb << \" \" << xe << \" \" << ye << \")\"<< endl;\n    int ans = acc[xe][ye] - acc[xb-1][ye] - acc[xe][yb-1] + acc[xb-1][yb-1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n#include <vector>\n\ntemplate <typename Integral,\n\tstd::size_t bitsize = std::numeric_limits<Integral>::digits()>\n\tclass WaveletMatrix {\n\tpublic:\n\t\tusing value_type = Integral;\n\t\tusing size_type = std::size_t;\n\n\tprivate:\n\t\tusing uint32 = std::uint_least32_t;\n\t\tstatic size_type popcount32(uint32 c) {\n#ifdef __GNUC__\n\t\t\treturn __builtin_popcount(c);\n#elif _MSC_VER_\n\t\t\treturn _mm_popcnt_u32(c);\n#else\n\t\t\tc = (c & 0x55555555) + ((c >> 1) & 0x55555555);\n\t\t\tc = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n\t\t\tc = (c + (c >> 4)) & 0x0F0F0F0F;\n\t\t\tc += c >> 8;\n\t\t\tc += c >> 16;\n\t\t\treturn static_cast<size_type>(c) & 0x3F;\n#endif\n\t\t}\n\t\tstruct FID {\n\t\t\tstd::vector<uint32> dic;\n\t\t\tsize_type cnt;\n\t\t\tvalue_type bit;\n\t\t\tFID() {}\n\t\t\tFID(const size_type bsize) : dic(bsize, 0) {}\n\t\t\tvoid set(const size_type index) {\n\t\t\t\tdic[index >> 4 | 1] |= static_cast<uint32>(1) << (index & 0x1f);\n\t\t\t}\n\t\t\tvoid build() {\n\t\t\t\tconst size_type len = dic.size();\n\t\t\t\tfor (size_type j = 2; j < len; j += 2)\n\t\t\t\t\tdic[j] = dic[j - 2] + popcount32(dic[j - 1]);\n\t\t\t}\n\t\t\tsize_type rank(const size_type last) const {\n\t\t\t\treturn static_cast<size_type>(\n\t\t\t\t\tdic[last >> 4 & ~static_cast<size_type>(1)]) +\n\t\t\t\t\tpopcount32(dic[last >> 4 | 1] &\n\t\t\t\t\t(static_cast<size_type>(1) << (last & 0x1f)) - 1);\n\t\t\t}\n\t\t\tbool access(const size_type index) const {\n\t\t\t\treturn dic[index >> 4 | 1] >> (index & 0x1f) & 1;\n\t\t\t}\n\t\t};\n\t\tstd::array<FID, bitsize> matrix;\n\t\tvalue_type NOT_FOUND;\n\t\tsize_type size_;\n\n\tpublic:\n\t\tWaveletMatrix(std::vector<value_type> data, const value_type NOT_FOUND = 0)\n\t\t\t: size_(data.size()), NOT_FOUND(NOT_FOUND) {\n\t\t\tconst size_type len = data.size(), block = ((len >> 5) + 1) << 1;\n\t\t\tstd::vector<value_type> L(len), R(len);\n\t\t\tsize_type l, r;\n\t\t\tvalue_type temp = static_cast<value_type>(1) << (bitsize - 1);\n\t\t\tfor (auto &x : matrix) {\n\t\t\t\tx = FID(block);\n\t\t\t\tx.bit = temp;\n\t\t\t\ttemp = temp >> 1 & ~temp;\n\t\t\t\tl = 0;\n\t\t\t\tr = 0;\n\t\t\t\tfor (size_type j = 0; j < len; ++j)\n\t\t\t\t\tif (data[j] & x.bit)\n\t\t\t\t\t\tR[r++] = data[j], x.set(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tL[l++] = data[j];\n\t\t\t\tx.cnt = l;\n\t\t\t\tx.build();\n\t\t\t\tstd::swap(data, L);\n\t\t\t\tstd::copy(R.begin(), R.begin() + r, data.begin() + l);\n\t\t\t}\n\t\t}\n\n\t\tsize_type size() const noexcept { return size_; }\n\t\tbool empty() const noexcept { return size() == 0; }\n\n\t\tvalue_type access(size_type index) const {\n\t\t\tassert(index < size());\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (x.access(index))\n\t\t\t\t\tret |= x.bit, index = x.rank(index) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tindex -= x.rank(index);\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type operator[](const size_type index) const {\n\t\t\tassert(index < size());\n\t\t\treturn access(index);\n\t\t}\n\t\tsize_type rank(size_type first, size_type last, const value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (data & x.bit)\n\t\t\t\t\tfirst = x.rank(first) + x.cnt, last = x.rank(last) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tfirst -= x.rank(first), last -= x.rank(last);\n\t\t\treturn last - first;\n\t\t}\n\t\tvalue_type quantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tconst size_type l = x.rank(first), r = x.rank(last);\n\t\t\t\tif (r - l > k)\n\t\t\t\t\tfirst = l + x.cnt, last = r + x.cnt, ret |= x.bit;\n\t\t\t\telse\n\t\t\t\t\tfirst -= l, last -= r, k -= r - l;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type rquantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\treturn quantile(first, last, last - first - k - 1);\n\t\t}\n\t\tsize_type less_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_least(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type greater_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_most(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type rangefreq(size_type first, size_type last, const value_type lower,\n\t\t\tconst value_type upper) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tassert(lower <= upper);\n\t\t\treturn at_least(first, last, lower) - at_least(first, last, upper);\n\t\t}\n\t\tvalue_type successor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type predecessor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n\t\tvalue_type strict_succ(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type strict_pred(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n};\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <vector>\n\ntemplate <class T>\nusing StaticMultiSetDefaultContainer = std::vector<T, std::allocator<T>>;\n\ntemplate <class T = std::int_fast64_t,\n\ttemplate <class> class Container = StaticMultiSetDefaultContainer,\n\tclass Compare = std::less<typename Container<T>::value_type>>\n\tclass StaticMultiSet {\n\tpublic:\n\t\tusing container_type = Container<T>;\n\t\tusing value_compare = Compare;\n\t\tusing value_type = typename container_type::value_type;\n\t\tusing reference = typename container_type::const_reference;\n\t\tusing const_reference = typename container_type::const_reference;\n\t\tusing size_type = typename container_type::size_type;\n\t\tusing difference_type = typename container_type::difference_type;\n\t\tusing pointer = typename container_type::const_pointer;\n\t\tusing const_pointer = typename container_type::const_pointer;\n\t\tclass const_iterator : public std::random_access_iterator_tag {\n\t\t\tfriend StaticMultiSet;\n\n\t\tprivate:\n\t\t\tusing iterator_type = typename container_type::const_iterator;\n\t\t\titerator_type it;\n\t\t\tdifference_type order_;\n\t\t\texplicit const_iterator(iterator_type x, difference_type y)\n\t\t\t\t: it(x), order_(y) {}\n\n\t\tpublic:\n\t\t\tconst_reference operator*() const { return *it; }\n\t\t\tconst_pointer operator->() const { return std::addressof(operator*()); }\n\t\t\tconst_reference operator[](difference_type n) const { return it[n]; }\n\n\t\t\tconst_iterator &operator++() {\n\t\t\t\t++it, ++order_;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator++(int) {\n\t\t\t\tauto ret = *this;\n\t\t\t\toperator++();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst_iterator &operator--() {\n\t\t\t\t--it, --order_;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator--(int) {\n\t\t\t\tauto ret = *this;\n\t\t\t\toperator--();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst_iterator &operator+=(difference_type n) {\n\t\t\t\tit += n, order_ += n;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator+(difference_type n) const {\n\t\t\t\treturn const_iterator(it + n, order_ + n);\n\t\t\t}\n\t\t\tconst_iterator &operator-=(difference_type n) {\n\t\t\t\tit -= n, order_ -= n;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator-(difference_type n) const {\n\t\t\t\treturn const_iterator(it - n, order_ - n);\n\t\t\t}\n\n\t\t\tbool operator==(const const_iterator &other) const {\n\t\t\t\treturn it == other.it;\n\t\t\t}\n\t\t\tbool operator!=(const const_iterator &other) const {\n\t\t\t\treturn it != other.it;\n\t\t\t}\n\t\t\tbool operator<(const const_iterator &other) const { return it < other.it; }\n\t\t\tbool operator<=(const const_iterator &other) const {\n\t\t\t\treturn it != other.it;\n\t\t\t}\n\t\t\tbool operator>(const const_iterator &other) const { return it > other.it; }\n\t\t\tbool operator>=(const const_iterator &other) const {\n\t\t\t\treturn it >= other.it;\n\t\t\t}\n\n\t\t\tconst_reference value() const { return *it; }\n\t\t\tdifference_type order() const { return order_; }\n\t\t};\n\t\tusing iterator = const_iterator;\n\n\tprotected:\n\t\tcontainer_type c;\n\t\tvalue_compare comp;\n\n\tprivate:\n\t\titerator make_itr(const typename iterator::iterator_type &it) {\n\t\t\treturn iterator(it, std::distance(c.cbegin(), it));\n\t\t}\n\t\tconst_iterator\n\t\t\tmake_citr(const typename const_iterator::iterator_type &it) const {\n\t\t\treturn const_iterator(it, std::distance(c.cbegin(), it));\n\t\t}\n\n\tpublic:\n\t\tStaticMultiSet() : c(), comp() {}\n\t\texplicit StaticMultiSet(const value_compare &x) : comp(x) {}\n\t\texplicit StaticMultiSet(const value_compare &x, const container_type &other)\n\t\t\t: c(other), comp(x) {\n\t\t\tbuild();\n\t\t}\n\t\texplicit StaticMultiSet(const value_compare &x, container_type &&other)\n\t\t\t: c(std::move(other)), comp(x) {\n\t\t\tbuild();\n\t\t}\n\n\t\titerator begin() { return make_itr(c.cbegin()); }\n\t\titerator end() { return make_itr(c.cend()); }\n\t\tconst_iterator cbegin() const { return make_citr(c.cbegin()); }\n\t\tconst_iterator cend() const { return make_citr(c.cend()); }\n\n\t\tsize_type size() const { return c.size(); }\n\t\tbool empty() const { return c.empty(); }\n\t\tvoid reserve(const size_type s) { c.reserve(s); }\n\t\tvoid shrink_to_fit() { c.shrink_to_fit(); }\n\n\t\tconst_reference operator[](const size_type order) const {\n\t\t\tassert(order < size());\n\t\t\treturn c[order];\n\t\t}\n\t\tconst_reference at(const size_type order) const { return c.at(order); }\n\t\tconst_reference min() const {\n\t\t\tassert(!empty());\n\t\t\treturn c.front();\n\t\t}\n\t\tconst_reference max() const {\n\t\t\tassert(!empty());\n\t\t\treturn c.back();\n\t\t}\n\t\tconst_iterator succ(const value_type &x) const {\n\t\t\treturn make_citr(std::lower_bound(c.cbegin(), c.cend(), x, comp));\n\t\t}\n\t\tconst_iterator pred(const value_type &x) const {\n\t\t\treturn make_citr(std::upper_bound(c.cbegin(), c.cend(), x, comp) - 1);\n\t\t}\n\t\tconst_iterator strict_succ(const value_type &x) const {\n\t\t\treturn make_citr(std::upper_bound(c.cbegin(), c.cend(), x, comp));\n\t\t}\n\t\tconst_iterator strict_pred(const value_type &x) const {\n\t\t\treturn make_citr(std::lower_bound(c.cbegin(), c.cend(), x, comp) - 1);\n\t\t}\n\n\t\tvoid push(const value_type &x) { c.push_back(x); }\n\t\tvoid push(value_type &&x) { c.push_back(std::move(x)); }\n\t\ttemplate <class... Args> void emplace(Args &&... args) {\n\t\t\tc.emplace_back(std::forward<Args>(args)...);\n\t\t}\n\t\tvoid build() {\n\t\t\tstd::sort(c.begin(), c.end(), comp);\n\t\t}\n\t\tvoid clear() { c.clear(); }\n};\n\n#include<algorithm>\n#include<cstdio>\n#include<vector>\n#include<utility>\nint main() {\n\tconstexpr int base = 1000000000;\n\tusing P = std::pair<int, int>;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tStaticMultiSet<P> s;\n\tstd::vector<int> a;\n\ts.reserve(n);\n\ta.reserve(n);\n\twhile (n--) {\n\t\tint x, y;\n\t\tscanf(\"%d%d\", &x, &y);\n\t\ty += base;\n\t\ts.emplace(x, y);\n\t}\n\ts.build();\n\tfor (const auto &e : s)\n\t\ta.emplace_back(e.second);\n\tWaveletMatrix<int, 31> W(a);\n\twhile (m--) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\tc++;\n\t\td++;\n\t\tb += base;\n\t\td += base;\n\t\tprintf(\"%u\\n\", W.rangefreq(s.succ(P(a, 0)).order(), s.succ(P(c, 0)).order(), b, d));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\ntemplate<typename T>\nstruct CumulativeSum2D {\n    vector<vector<T>> acc;\n    CumulativeSum2D(int h = 0, int w = 0) : acc(h + 1, vector<T>(w + 1)) { }\n    void add(int i, int j, T x) { acc[i + 1][j + 1] += x; }\n    void build() {\n        int H = acc.size(), W = acc[0].size();\n        for (int i = 1; i < H; i++) for (int j = 1; j < W; j++) {\n            acc[i][j] += acc[i][j - 1] + acc[i - 1][j] - acc[i - 1][j - 1];\n        }\n    }\n    T sum(int si, int sj, int ti, int tj) {     // [si, ti) x [sj, tj)\n        return acc[ti][tj] - acc[si][tj] - acc[ti][sj] + acc[si][sj];\n    }\n};\n\ntemplate <typename T>\nvector<T> uni(vector<T> v) {\n    sort(v.begin(), v.end());\n    v.erase(unique(v.begin(), v.end()), v.end());\n    return v;\n}\n\ntemplate<typename T>\nint compressed(vector<T> &a) {\n    vector<T> b = a;\n    sort(begin(b), end(b)); b.erase(unique(begin(b), end(b)), end(b));\n    for (T &ai: a) ai = lower_bound(begin(b), end(b), ai) - begin(b);\n    return b.size();\n}\n\nint main() {\n    int n, m; cin >> n >> m;\n    vector<int> x(n), y(n);\n    for (int i = 0; i < n; i++) cin >> x[i] >> y[i];\n    auto numX = uni(x), numY = uni(y);\n    int sx = compressed(x), sy = compressed(y);\n    CumulativeSum2D<int> acc(sx, sy);\n    for (int i = 0; i < n; i++) acc.add(x[i], y[i], 1);\n    acc.build();\n    for (int i = 0; i < m; i++) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(begin(numX), end(numX), x1) - begin(numX);\n        y1 = lower_bound(begin(numY), end(numY), y1) - begin(numY);\n        x2 = upper_bound(begin(numX), end(numX), x2) - begin(numX);\n        y2 = upper_bound(begin(numY), end(numY), y2) - begin(numY);\n        cout << acc.sum(x1, y1, x2, y2) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define INF 1e9\n#define llINF 1e18\n#define MOD 1e9+7\n#define pb push_back\n#define mp make_pair \n#define F first\n#define S second\n#define ll long long\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  pair<int,int> pii[n];\n  for(int i=0;i<n;i++){\n    cin>>pii[i].F>>pii[i].S;\n  }\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    ll cnt=0;\n    for(int j=0;j<n;j++){\n      if((x1<=pii[j].F&&pii[j].F<=x2)&&y1<=pii[j].S&&pii[j].S<=y2)\n\tcnt++;\n    }\n    cout<<cnt<<endl;\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n#include <vector>\n\ntemplate <typename Integral,\n\tstd::size_t bitsize = std::numeric_limits<Integral>::digits()>\n\tclass WaveletMatrix {\n\tpublic:\n\t\tusing value_type = Integral;\n\t\tusing size_type = std::size_t;\n\n\tprivate:\n\t\tusing uint32 = std::uint_least32_t;\n\t\tstatic size_type popcount32(uint32 c) {\n#ifdef __GNUC__\n\t\t\treturn __builtin_popcount(c);\n#elif _MSC_VER_\n\t\t\treturn _mm_popcnt_u32(c);\n#else\n\t\t\tc = (c & 0x55555555) + ((c >> 1) & 0x55555555);\n\t\t\tc = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n\t\t\tc = (c + (c >> 4)) & 0x0F0F0F0F;\n\t\t\tc += c >> 8;\n\t\t\tc += c >> 16;\n\t\t\treturn static_cast<size_type>(c) & 0x3F;\n#endif\n\t\t}\n\t\tstruct FID {\n\t\t\tstd::vector<uint32> dic;\n\t\t\tsize_type cnt;\n\t\t\tvalue_type bit;\n\t\t\tFID() {}\n\t\t\tFID(const size_type bsize) : dic(bsize, 0) {}\n\t\t\tvoid set(const size_type index) {\n\t\t\t\tdic[index >> 4 | 1] |= static_cast<uint32>(1) << (index & 0x1f);\n\t\t\t}\n\t\t\tvoid build() {\n\t\t\t\tconst size_type len = dic.size();\n\t\t\t\tfor (size_type j = 2; j < len; j += 2)\n\t\t\t\t\tdic[j] = dic[j - 2] + popcount32(dic[j - 1]);\n\t\t\t}\n\t\t\tsize_type rank(const size_type last) const {\n\t\t\t\treturn static_cast<size_type>(\n\t\t\t\t\tdic[last >> 4 & ~static_cast<size_type>(1)]) +\n\t\t\t\t\tpopcount32(dic[last >> 4 | 1] &\n\t\t\t\t\t(static_cast<size_type>(1) << (last & 0x1f)) - 1);\n\t\t\t}\n\t\t\tbool access(const size_type index) const {\n\t\t\t\treturn dic[index >> 4 | 1] >> (index & 0x1f) & 1;\n\t\t\t}\n\t\t};\n\t\tstd::array<FID, bitsize> matrix;\n\t\tvalue_type NOT_FOUND;\n\t\tsize_type size_;\n\n\tpublic:\n\t\tWaveletMatrix(std::vector<value_type> data, const value_type NOT_FOUND = 0)\n\t\t\t: size_(data.size()), NOT_FOUND(NOT_FOUND) {\n\t\t\tconst size_type len = data.size(), block = ((len >> 5) + 1) << 1;\n\t\t\tstd::vector<value_type> L(len), R(len);\n\t\t\tsize_type l, r;\n\t\t\tvalue_type temp = static_cast<value_type>(1) << (bitsize - 1);\n\t\t\tfor (auto &x : matrix) {\n\t\t\t\tx = FID(block);\n\t\t\t\tx.bit = temp;\n\t\t\t\ttemp = temp >> 1 & ~temp;\n\t\t\t\tl = 0;\n\t\t\t\tr = 0;\n\t\t\t\tfor (size_type j = 0; j < len; ++j)\n\t\t\t\t\tif (data[j] & x.bit)\n\t\t\t\t\t\tR[r++] = data[j], x.set(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tL[l++] = data[j];\n\t\t\t\tx.cnt = l;\n\t\t\t\tx.build();\n\t\t\t\tstd::swap(data, L);\n\t\t\t\tstd::copy(R.begin(), R.begin() + r, data.begin() + l);\n\t\t\t}\n\t\t}\n\n\t\tsize_type size() const noexcept { return size_; }\n\t\tbool empty() const noexcept { return size() == 0; }\n\n\t\tvalue_type access(size_type index) const {\n\t\t\tassert(index < size());\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (x.access(index))\n\t\t\t\t\tret |= x.bit, index = x.rank(index) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tindex -= x.rank(index);\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type operator[](const size_type index) const {\n\t\t\tassert(index < size());\n\t\t\treturn access(index);\n\t\t}\n\t\tsize_type rank(size_type first, size_type last, const value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (data & x.bit)\n\t\t\t\t\tfirst = x.rank(first) + x.cnt, last = x.rank(last) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tfirst -= x.rank(first), last -= x.rank(last);\n\t\t\treturn last - first;\n\t\t}\n\t\tvalue_type quantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tconst size_type l = x.rank(first), r = x.rank(last);\n\t\t\t\tif (r - l > k)\n\t\t\t\t\tfirst = l + x.cnt, last = r + x.cnt, ret |= x.bit;\n\t\t\t\telse\n\t\t\t\t\tfirst -= l, last -= r, k -= r - l;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type rquantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\treturn quantile(first, last, last - first - k - 1);\n\t\t}\n\t\tsize_type less_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_least(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type greater_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_most(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type rangefreq(size_type first, size_type last, const value_type lower,\n\t\t\tconst value_type upper) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tassert(lower <= upper);\n\t\t\treturn at_least(first, last, lower) - at_least(first, last, upper);\n\t\t}\n\t\tvalue_type successor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type predecessor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n\t\tvalue_type strict_succ(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type strict_pred(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n};\n#include <algorithm>\n#include <cassert>\n#include <cstdint>\n#include <functional>\n#include <iterator>\n#include <memory>\n#include <utility>\n#include <vector>\n\ntemplate <class T>\nusing StaticMultiSetDefaultContainer = std::vector<T, std::allocator<T>>;\n\ntemplate <class T = std::int_fast64_t,\n\ttemplate <class> class Container = StaticMultiSetDefaultContainer,\n\tclass Compare = std::less<typename Container<T>::value_type>>\n\tclass StaticMultiSet {\n\tpublic:\n\t\tusing container_type = Container<T>;\n\t\tusing value_compare = Compare;\n\t\tusing value_type = typename container_type::value_type;\n\t\tusing reference = typename container_type::const_reference;\n\t\tusing const_reference = typename container_type::const_reference;\n\t\tusing size_type = typename container_type::size_type;\n\t\tusing difference_type = typename container_type::difference_type;\n\t\tusing pointer = typename container_type::const_pointer;\n\t\tusing const_pointer = typename container_type::const_pointer;\n\t\tclass const_iterator : public std::random_access_iterator_tag {\n\t\t\tfriend StaticMultiSet;\n\n\t\tprivate:\n\t\t\tusing iterator_type = typename container_type::const_iterator;\n\t\t\titerator_type it;\n\t\t\tdifference_type order_;\n\t\t\texplicit const_iterator(iterator_type x, difference_type y)\n\t\t\t\t: it(x), order_(y) {}\n\n\t\tpublic:\n\t\t\tconst_reference operator*() const { return *it; }\n\t\t\tconst_pointer operator->() const { return std::addressof(operator*()); }\n\t\t\tconst_reference operator[](difference_type n) const { return it[n]; }\n\n\t\t\tconst_iterator &operator++() {\n\t\t\t\t++it, ++order_;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator++(int) {\n\t\t\t\tauto ret = *this;\n\t\t\t\toperator++();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst_iterator &operator--() {\n\t\t\t\t--it, --order_;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator--(int) {\n\t\t\t\tauto ret = *this;\n\t\t\t\toperator--();\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\tconst_iterator &operator+=(difference_type n) {\n\t\t\t\tit += n, order_ += n;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator+(difference_type n) const {\n\t\t\t\treturn const_iterator(it + n, order_ + n);\n\t\t\t}\n\t\t\tconst_iterator &operator-=(difference_type n) {\n\t\t\t\tit -= n, order_ -= n;\n\t\t\t\treturn *this;\n\t\t\t}\n\t\t\tconst_iterator operator-(difference_type n) const {\n\t\t\t\treturn const_iterator(it - n, order_ - n);\n\t\t\t}\n\n\t\t\tbool operator==(const const_iterator &other) const {\n\t\t\t\treturn it == other.it;\n\t\t\t}\n\t\t\tbool operator!=(const const_iterator &other) const {\n\t\t\t\treturn it != other.it;\n\t\t\t}\n\t\t\tbool operator<(const const_iterator &other) const { return it < other.it; }\n\t\t\tbool operator<=(const const_iterator &other) const {\n\t\t\t\treturn it != other.it;\n\t\t\t}\n\t\t\tbool operator>(const const_iterator &other) const { return it > other.it; }\n\t\t\tbool operator>=(const const_iterator &other) const {\n\t\t\t\treturn it >= other.it;\n\t\t\t}\n\n\t\t\tconst_reference value() const { return *it; }\n\t\t\tdifference_type order() const { return order_; }\n\t\t};\n\t\tusing iterator = const_iterator;\n\n\tprotected:\n\t\tcontainer_type c;\n\t\tvalue_compare comp;\n\n\tprivate:\n\t\titerator make_itr(const typename iterator::iterator_type &it) {\n\t\t\treturn iterator(it, std::distance(c.cbegin(), it));\n\t\t}\n\t\tconst_iterator\n\t\t\tmake_citr(const typename const_iterator::iterator_type &it) const {\n\t\t\treturn const_iterator(it, std::distance(c.cbegin(), it));\n\t\t}\n\n\tpublic:\n\t\tStaticMultiSet() : c(), comp() {}\n\t\texplicit StaticMultiSet(const value_compare &x) : comp(x) {}\n\t\texplicit StaticMultiSet(const value_compare &x, const container_type &other)\n\t\t\t: c(other), comp(x) {\n\t\t\tbuild();\n\t\t}\n\t\texplicit StaticMultiSet(const value_compare &x, container_type &&other)\n\t\t\t: c(std::move(other)), comp(x) {\n\t\t\tbuild();\n\t\t}\n\n\t\titerator begin() { return make_itr(c.cbegin()); }\n\t\titerator end() { return make_itr(c.cend()); }\n\t\tconst_iterator cbegin() const { return make_citr(c.cbegin()); }\n\t\tconst_iterator cend() const { return make_citr(c.cend()); }\n\n\t\tsize_type size() const { return c.size(); }\n\t\tbool empty() const { return c.empty(); }\n\t\tvoid reserve(const size_type s) { c.reserve(s); }\n\t\tvoid shrink_to_fit() { c.shrink_to_fit(); }\n\n\t\tconst_reference operator[](const size_type order) const {\n\t\t\tassert(order < size());\n\t\t\treturn c[order];\n\t\t}\n\t\tconst_reference at(const size_type order) const { return c.at(order); }\n\t\tconst_reference min() const {\n\t\t\tassert(!empty());\n\t\t\treturn c.front();\n\t\t}\n\t\tconst_reference max() const {\n\t\t\tassert(!empty());\n\t\t\treturn c.back();\n\t\t}\n\t\tconst_iterator succ(const value_type &x) const {\n\t\t\treturn make_citr(std::lower_bound(c.cbegin(), c.cend(), x, comp));\n\t\t}\n\t\tconst_iterator pred(const value_type &x) const {\n\t\t\treturn make_citr(std::upper_bound(c.cbegin(), c.cend(), x, comp) - 1);\n\t\t}\n\t\tconst_iterator strict_succ(const value_type &x) const {\n\t\t\treturn make_citr(std::upper_bound(c.cbegin(), c.cend(), x, comp));\n\t\t}\n\t\tconst_iterator strict_pred(const value_type &x) const {\n\t\t\treturn make_citr(std::lower_bound(c.cbegin(), c.cend(), x, comp) - 1);\n\t\t}\n\n\t\tvoid push(const value_type &x) { c.push_back(x); }\n\t\tvoid push(value_type &&x) { c.push_back(std::move(x)); }\n\t\ttemplate <class... Args> void emplace(Args &&... args) {\n\t\t\tc.emplace_back(std::forward<Args>(args)...);\n\t\t}\n\t\tvoid build() {\n\t\t\tstd::sort(c.begin(), c.end(), comp);\n\t\t}\n\t\tvoid clear() { c.clear(); }\n};\n\n#include<algorithm>\n#include<iostream>\n#include<vector>\n#include<utility>\nint main() {\n\tconstexpr int base = 1000000000;\n\tusing P = std::pair<int, int>;\n\tint n, m;\n\tstd::cin >> n >> m;\n\tStaticMultiSet<P> s;\n\ts.reserve(n);\n\twhile (n--) {\n\t\tint x, y;\n\t\tstd::cin >> x >> y;\n\t\ty += base;\n\t\ts.emplace(x, y);\n\t}\n\ts.build();\n\tstd::vector<int> a;\n\tfor (const auto &e : s)\n\t\ta.emplace_back(e.second);\n\tWaveletMatrix<int, 31> W(a);\n\twhile (m--) {\n\t\tint a, b, c, d;\n\t\tstd::cin >> a >> b >> c >> d;\n\t\tc++;\n\t\td++;\n\t\tb += base;\n\t\td += base;\n\t\tstd::cout << W.rangefreq(s.succ(P(a,0)).order(), s.succ(P(c,0)).order(), b, d) << std::endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<string>\n#include<vector>\n#include<iostream>\n#include<sstream>\n#include<cstdio>\n#include<cstdlib>\n#include<functional>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<set>\n#include<map>\n#include<utility>\n#include<cmath>\n#include<ctime>\n#include<complex>\n\nusing namespace std;\n\n#define REP(i,s,e) for(int i=int(s);i<=int(e);i++)\n#define rep(i,n) for(int i=0;i<int(n);i++)\n\n\nint main(){\n\n\tint n,m,x1,y1,x2,y2,x3,y3;\n\n\tvector<int>x; vector<int>y;\n\n\tvector<int>swx; vector<int>swy;\n\tvector<int>nex; vector<int>ney;\n\n\tcin >> n >> m;\n\n\trep(i,n){\n\n\t\tcin >> x1 >> y1;\n\n\t\tx.push_back(x1);\n\t\ty.push_back(y1);\n\t}\n\n    vector<int>c(m,0);\n\trep(i,m){\n\n\t\tcin >> x2 >> y2 >> x3 >> y3;\n\n\t\tswx.push_back(x2);\n\t\tswx.push_back(y2);\n\t\tswx.push_back(x3);\n\t\tswx.push_back(y3);\n\n\t\trep(j,n)\n\n\t\tif(x2<=x[j] && x[j]<=x3 && y2<=y[j] && y[j]<=y3) c[i]++;\n\n\t}\n\n    rep(i,m) cout << c[i] << endl;\n\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,m;cin>>n>>m;\n  vector<pair<int,int> > pii(n);\n\n  for(int i=0;i<n;i++)\n    cin>>pii[i].first>>pii[i].second;\n  sort(pii.begin(),pii.end());\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    int cnt=0;\n    for(int j=0;j<n;j++){\n      if(x1<=pii[j].first&&pii[j].first<=x2&&y1<=pii[j].second&&pii[j].second<=y2)\n\tcnt++;\n    }\n    printf(\"%d\\n\",cnt);\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) { cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl; }\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//pair?????????\ntemplate<typename T1, typename T2>\nostream &operator << (ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\n\n//??§?¨???§???\n//v: ??§???????????§?¨??????? ????????????\ntemplate<typename T>\nvoid compress(vector<T> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\n//??§?¨???§???(map)\n//v: ??§???????????§?¨??????? ????????????\n//?????????: zip[??§???????????§?¨?]:??§???????????§?¨? (zip.size()<=10^5?????????????????????)\ntemplate<typename T>\nmap<T, T> compressMap(vector<T> &v) {\n\tmap<T, T> zip;\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (T i = 0; i < v.size(); i++) zip[v[i]] = i;\n\treturn zip;\n}\n\n//??§???????????§?¨?\n//index(??§???????????§?¨?, ??§???????????§?¨??????????(??????) )\ntemplate<typename T>\nint index(vector<T> v, T i) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n\n//2?¬????imos???\nclass Imos {\npublic:\n\tusing vvi = vector<vector<int> >;\n\tint X, Y;\n\tvvi s; //?´???????\n\t//f:field\n\tImos(vvi f) {\n\t\tX = f.size();\n\t\tY = f[0].size();\n\t\t//one-based\n\t\t//(x,y)?????§????´??????????(x+1,y+1)\n\t\ts = vvi(X + 1, vector<int>(Y + 1));\n\t\tfor (int y = 0; y < Y; y++)\n\t\t\tfor (int x = 0; x < X; x++)\n\t\t\t\ts[x + 1][y + 1] += s[x + 1][y] + s[x][y + 1] - s[x][y] + f[x][y];\n\t}\n\t//[x1,x2)??????[y1,y2)???field??????????±???????\n\t//one-based????????????????§?\n\tint sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x2][y1] - s[x1][y2] + s[x1][y1]; }\n};\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<int> xs(n), ys(n);\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &xs[i], &ys[i]);\n\t\tx[i] = xs[i]; y[i] = ys[i];\n\t}\n\tcompress(x);\n\tcompress(y);\n\n\t//map<int, int> zipx(compressMap(x));\n\t//map<int, int> zipy(compressMap(y));\n\t//dump(x);\n\t//dump(zipx);\n\t//dump(y);\n\t//dump(zipy);\n\n\tvector<vector<int> > f(x.size(), vector<int>(y.size()));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint vx = index(x, xs[i]);\n\t\tint vy = index(y, ys[i]);\n\t\tf[vx][vy]++;\n\t}\n\n\t//for (int vx = 0; vx < x.size(); vx++) dump(f[vx]);\n\n\tx.shrink_to_fit();\n\ty.shrink_to_fit();\n\txs.shrink_to_fit();\n\tys.shrink_to_fit();\n\tImos imos(f);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tx1 = index(x, x1);\n\t\ty1 = index(y, y1);\n\t\tx2 = index(x, x2 + 1); //Imos???sum???one-based?????????+1\n\t\ty2 = index(y, y2 + 1);\n\t\tcout << imos.sum(x1, y1, x2, y2) << endl;\n\t}\n\treturn 0;\n}\n\n\n//Sample2\n//https://gyazo.com/39c67d1abe7a6a686acb52285f8a0bc9"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint n, m, x1_, y1_, x2_, y2_;\n\nvector<int> x, y;\n\nint main()\n{\n\tscanf(\"%d\", &n);\n\tscanf(\"%d\", &m);\n\n\tx = vector<int>(n);\n\ty = vector<int>(n);\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tscanf(\"%d\", &x[i]);\n\t\tscanf(\"%d\", &y[i]);\n\t}\n\n\tfor (int i = 0; i < n; i++)\n\t{\n\t\tfor (int j = i + 1; j < n; j++)\n\t\t{\n\t\t\tif (x[i] > x[j])\n\t\t\t{\n\t\t\t\tswap(x[i], x[j]);\n\t\t\t\tswap(y[i], y[j]);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor (int i = 0; i < m; i++)\n\t{\n\t\tscanf(\"%d\", &x1_);\n\t\tscanf(\"%d\", &y1_);\n\t\tscanf(\"%d\", &x2_);\n\t\tscanf(\"%d\", &y2_);\n\n\t\tint s = distance(x.begin(), upper_bound(x.begin(), x.end(), x1_ - 1));\n\t\tint t = distance(x.begin(), lower_bound(x.begin(), x.end(), x2_));\n\n\t\tint ret = 0;\n\n\t\tfor (int j = s; j < t; j++)\n\t\t{\n\t\t\tif (y1_ <= y[j] && y[j] <= y2_)\n\t\t\t{\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\", ret);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define MAX 1000000001\n#define a(x) (x).begin(),(x).end()\n#define pb push_back\n\nint n,m;\nint sum[5100][5100];\npair<int,int> p[5100];\nvector<int> x,y;\nint x1,y1,x2,y2;\n\nint main(){\n  scanf(\"%d%d\",&n,&m);\n  x.resize(n+2); y.resize(n+2);\n  for(int i=0;i<n;i++){\n    scanf(\"%d%d\",&x[i],&y[i]);\n    p[i].fs = x[i]; p[i].sc = y[i];\n  }\n\n  x[n] = MAX; x[n+1] = -MAX; \n  y[n] = MAX; y[n+1] = -MAX;\n  sort(a(x)); sort(a(y));\n  x.erase(unique(a(x)),x.end()); y.erase(unique(a(y)),y.end());\n\n  for(int i=0;i<n;i++){\n    p[i].fs = lower_bound(a(x),p[i].fs) - x.begin();\n    p[i].sc = lower_bound(a(y),p[i].sc) - y.begin();\n  }\n  sort(p,p+n);\n\n  int cnt = 0;\n  for(int i=0;i<x.size();i++)\n    for(int j=0;j<y.size();j++){\n      if(!i || !j)sum[i][j] = 0;\n      else sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1];\n      while(cnt<n && p[cnt].fs == i && p[cnt].sc == j){\n\tsum[i][j]++; cnt++;\n      }\n    }\n\n  for(int i=0;i<m;i++){\n    scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n    x1 = lower_bound(a(x),x1)-x.begin()-1;\n    y1 = lower_bound(a(y),y1)-y.begin()-1;\n    x2 = upper_bound(a(x),x2)-x.begin()-1;\n    y2 = upper_bound(a(y),y2)-y.begin()-1;\n    printf(\"%d\\n\",sum[x2][y2] - sum[x2][y1] - sum[x1][y2] + sum[x1][y1]);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nvector<int> x,y,xx,yy;\nint imos[5001][5001];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b;cin>>a>>b;\n    xx.push_back(a);\n    x.push_back(a);\n    yy.push_back(b);\n    y.push_back(b);\n  }\n  x.push_back(-1000000001);\n  y.push_back(-1000000001);\n  x.push_back(1000000001);\n  y.push_back(1000000001);\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  for(int i=0;i<n;i++){\n    xx[i]=lower_bound(x.begin(),x.end(),xx[i])-x.begin();\n    yy[i]=lower_bound(y.begin(),y.end(),yy[i])-y.begin();\n  }\n  h=(int)y.size();\n  w=(int)x.size();\n  for(int i=0;i<n;i++){\n    imos[yy[i]][xx[i]]++;\n  }\n  for(int i=0;i<h;i++)for(int j=1;j<w;j++)imos[i][j]+=imos[i][j-1];\n  for(int i=1;i<h;i++)for(int j=0;j<w;j++)imos[i][j]+=imos[i-1][j];\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;\n    auto xa=lower_bound(x.begin(),x.end(),x1);\n    if(*xa>=x1)xa--;\n    auto xb=lower_bound(x.begin(),x.end(),x2);\n    if(*xb>x2)xb--;\n    auto ya=lower_bound(y.begin(),y.end(),y1);\n    if(*ya>=y1)ya--;\n    auto yb=lower_bound(y.begin(),y.end(),y2);\n    if(*yb>y2)yb--;\n    x1=xa-x.begin();x2=xb-x.begin();y1=ya-y.begin();y2=yb-y.begin();\n    cout<<imos[y2][x2]-imos[y2][x1]-imos[y1][x2]+imos[y1][x1]<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=2020,MAX=5005;\nconst ll INF=1LL<<62;\nint sum[MAX][MAX];\n\nint main(){\n    \n    std::ifstream in(\"text.txt\");\n    std::cin.rdbuf(in.rdbuf());\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int N,M;cin>>N>>M;\n    vector<int> zax(N),zay(N);\n    vector<pair<int,int>> p(N);\n    for(int i=0;i<N;i++){\n        cin>>zax[i]>>zay[i];\n        p[i]={zax[i],zay[i]};\n    }\n    \n    sort(all(zax));\n    sort(all(zay));\n    \n    map<int,int> Mx,My;\n    \n    for(int i=0;i<N;i++){\n        int d=lower_bound(all(zax),p[i].first)-zax.begin(),d2=lower_bound(all(zay),p[i].second)-zay.begin();\n        sum[d+1][d2+1]++;\n    }\n    \n    for(int i=0;i<=N;i++){\n        for(int j=1;j<=N;j++){\n            sum[i][j]+=sum[i][j-1];\n        }\n    }\n    \n    for(int j=0;j<=N;j++){\n        for(int i=1;i<=N;i++){\n            sum[i][j]+=sum[i-1][j];\n        }\n    }\n    \n    while(M--){\n        int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;\n        int dx1,dy1,dx2,dy2;\n        dx1=lower_bound(all(zax),x1)-zax.begin();\n        dx2=upper_bound(all(zax),x2)-zax.begin();\n        \n        dy1=lower_bound(all(zay),y1)-zay.begin();\n        dy2=upper_bound(all(zay),y2)-zay.begin();\n        \n        cout<<sum[dx2][dy2]+sum[dx1][dy1]-sum[dx2][dy1]-sum[dx1][dy2]<<endl;\n    }\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n,N) for(int i=n;i<N;i++)\n#define p(S) cout<<(S)<<endl\n#define ck(n,a,b) ((a)<=(n)&&(n)<=(b))\n#define F first\n#define S second\ntypedef long long ll;\nusing namespace std;\nconst int inf=1e9;\n\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tpair<int,int> t[5001];\n\tREP(i,0,n) {\n\t\tcin>>t[i].F>>t[i].S;\n\t}\n\tsort(t,t+n);\n\tint x[2],y[2];\n\tREP(i,0,m){\n\t\tint ans=0;\n\t\tcin>>x[0]>>y[0]>>x[1]>>y[1];\n\t\tpair<int,int> a,b;\n\t\ta={x[0],y[0]};\n\t\tb={x[1],y[1]};\n\t\tfor(auto itr=lower_bound(t,t+n,a);itr!=upper_bound(t,t+n,b);itr++){\n\t\t\tpair<int,int> c=*itr;\n\t\t\tif(ck(c.S,a.S,b.S)) ans++;\n\t\t}\n\t\tp(ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdlib>\n#include <cmath>\n#include <map>\n#include <set>\n#include <queue>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\n#include <numeric>\n#include <bitset>\n#include <stack>\n#include <cstring>\nusing namespace std;\n\nconst int INF = 1 << 30;\nconst double EPS = 1e-10;\n\nint main()\n{\n  int n, m;\n  while (cin >> n >> m) {\n    vector<int> x(n), y(n);\n    set<int> sx, sy;\n    for (int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n      sx.insert(x[i]);\n      sy.insert(y[i]);\n    }\n\n    vector<int> ix(1, -INF), iy(1, -INF);\n    for (set<int>::iterator it = sx.begin(); it != sx.end(); ++it)\n      ix.push_back(*it);\n    for (set<int>::iterator it = sy.begin(); it != sy.end(); ++it)\n      iy.push_back(*it);\n\n    vector<vector<int> > dp(iy.size(), vector<int>(ix.size(), 0));\n    for (int i = 0; i < n; ++i)\n      ++dp[lower_bound(iy.begin(), iy.end(), y[i])-iy.begin()][lower_bound(ix.begin(), ix.end(), x[i])-ix.begin()];\n\n    for (unsigned int i = 0; i < dp.size(); ++i) {\n      for (unsigned int j = 1; j < dp[i].size(); ++j)\n        dp[i][j] += dp[i][j-1];\n    }\n\n    for (unsigned int i = 0; i < dp[0].size(); ++i) {\n      for (unsigned int j = 1; j < dp.size(); ++j)\n        dp[j][i] += dp[j-1][i];\n    }\n\n    while (m--) {\n      int x1, y1, x2, y2;\n      cin >> x1 >> y1 >> x2 >> y2;\n\n      int ix1 = upper_bound(ix.begin(), ix.end(), x2)-1-ix.begin();\n      int iy1 = upper_bound(iy.begin(), iy.end(), y2)-1-iy.begin();\n\n      int ix2 = upper_bound(ix.begin(), ix.end(), x1-1)-1-ix.begin();\n      int iy2 = upper_bound(iy.begin(), iy.end(), y1-1)-1-iy.begin();\n\n      int ix3 = upper_bound(ix.begin(), ix.end(), x1-1)-1-ix.begin();\n      int iy3 = upper_bound(iy.begin(), iy.end(), y2)-1-iy.begin();\n\n      int ix4 = upper_bound(ix.begin(), ix.end(), x2)-1-ix.begin();\n      int iy4 = upper_bound(iy.begin(), iy.end(), y1-1)-1-iy.begin();\n\n      cout << dp[max(0, iy1)][max(0, ix1)] + dp[max(0, iy2)][max(0, ix2)] - dp[max(0, iy3)][max(0, ix3)] - dp[max(0, iy4)][max(0, ix4)] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(integer i=0;i<(integer)(n);i++)\n\ntypedef long long int integer;\ntypedef pair<integer,integer> P;\nconst int MAX = 5004;\n\nint acc[MAX + 8][MAX + 8];\nint trecd[MAX + 8][MAX + 8];\n\nint main() {\n  integer n, m;\n  cin >> n >> m;\n  vector<integer> xs, ys;\n  vector<P> treasures(n);\n  for (P &p : treasures) {\n    cin >> p.first >> p.second;\n    xs.push_back(p.first);\n    ys.push_back(p.second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n/*  for (integer x : xs) cout << x << \" \"; cout << endl;\n  for (integer y : ys) cout << y << \" \"; cout << endl;*/\n\n  for (P p : treasures) {\n    integer x = find(xs.begin(), xs.end(), p.first) - xs.begin() + 1;\n    integer y = find(ys.begin(), ys.end(), p.second) - ys.begin() + 1;\n    trecd[x][y]++;\n  }\n  \n  for (integer y = 1; y < MAX; y++) for (integer x = 1; x < MAX; x++) {\n    acc[x][y] = acc[x][y-1] + acc[x-1][y] - acc[x-1][y-1] + trecd[x][y];\n  }\n\n/*  REP(y, 10) {\n    REP(x, 10) {\n      cout << acc[x][y] << \" \";\n    }\n    cout << endl;\n  }*/\n\n  REP (i, m) {\n    integer xb, yb, xe, ye;\n    cin >> xb >> yb >> xe >> ye;\n    xb = upper_bound(xs.begin(), xs.end(), xb - 1) - xs.begin() + 1;\n    yb = upper_bound(ys.begin(), ys.end(), yb - 1) - ys.begin() + 1;\n    xe = *(lower_bound(xs.begin(), xs.end(), xe + 1) - 1);\n    xe = find(xs.begin(), xs.end(), xe) - xs.begin() + 1;\n    xe = max(xe, xb);\n    ye = *(lower_bound(ys.begin(), ys.end(), ye + 1) - 1);\n    ye = find(ys.begin(), ys.end(), ye) - ys.begin() + 1;\n    ye = max(ye, yb);\n    integer ans = acc[xe][ye] - acc[xb-1][ye] - acc[xe][yb-1] \n      + acc[xb-1][yb-1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int i, n, m, x1, y1, x2, y2, count;\n  multimap<int, int> data;\n  multimap<int, int>::iterator j;\n\n  cin >> n >> m;\n\n  for(i=0; i<n; ++i){\n    cin >> x1 >> y1;\n    data.insert(make_pair(x1, y1));\n  }\n  for(i=0; i<m; ++i){\n    cin >> x1 >> y1 >> x2 >> y2;\n\n    for(j=data.lower_bound(x1), count=0; j->first<=x2 && j!=data.end(); ++j){\n      if(j->second >= y1 && j->second <= y2) ++count;\n    }\n    cout << count << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int MAXN = 5000;\nint n, m;\nint x[MAXN], y[MAXN];\nint G[MAXN][MAXN], S[MAXN][MAXN];\n\nint main() {\n  while(cin >> n >> m) {\n    vector<int> xs, ys;\n    for(int i = 0; i < n; ++i) {\n      cin >> x[i] >> y[i];\n      xs.push_back(x[i]);\n      ys.push_back(y[i]);\n    }\n    sort(xs.begin(), xs.end());\n    sort(ys.begin(), ys.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    memset(G, 0, sizeof(G));\n    for(int i = 0; i < n; ++i) {\n      int nx = lower_bound(xs.begin(), xs.end(), x[i]) - xs.begin();\n      int ny = lower_bound(ys.begin(), ys.end(), y[i]) - ys.begin();\n      G[ny][nx] += 1;\n    }\n    for(int i = 0; i+1 < MAXN; ++i) {\n      for(int j = 0; j+1 < MAXN; ++j) {\n        S[i+1][j+1] = S[i+1][j] + G[i][j];\n      }\n    }\n    for(int j = 0; j < MAXN; ++j) {\n      for(int i = 0; i+1 < MAXN; ++i) {\n        S[i+1][j] += S[i][j];\n      }\n    }\n    while(m--) {\n      int a, b, c, d;\n      cin >> a >> b >> c >> d;\n      a = lower_bound(xs.begin(), xs.end(), a) - xs.begin();\n      b = lower_bound(ys.begin(), ys.end(), b) - ys.begin();\n      c = upper_bound(xs.begin(), xs.end(), c) - xs.begin();\n      d = upper_bound(ys.begin(), ys.end(), d) - ys.begin();\n      cout << S[d][c] - S[d][a] - S[b][c] + S[b][a] << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint m;\n\n#define MAX_BIT 32\n\nstruct BitRank {\n    // block:bit列を管理, count:blockごとに立っている1の数を管理\n    vector<uint> block;\n    vector<int> count;\n    BitRank(){}\n    void resize(int num) {\n        block.resize((num+MAX_BIT-1)/MAX_BIT, 0);\n        count.resize((int)block.size(), 0);\n    }\n    // 立っているbitの数を返す\n    inline int popcount(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        return (((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n    // iビット目をval(0,1)にセット\n    inline void set(int i, int val) {\n        block[i/MAX_BIT] |= (val << (i%MAX_BIT));\n    }\n    void build() {\n        for(int i = 1; i < (int)block.size(); i++){\n            count[i] = count[i-1] + popcount(block[i-1]);\n        }\n    }\n    // iビット以下の1の数\n    int rank1(int i) {\n        return (i < 0)?0:(count[i/MAX_BIT]+popcount(block[i/MAX_BIT]<<(MAX_BIT-i%MAX_BIT-1)));\n    }\n    // jビット目からiビット目までの1の数\n    int rank1(int i,int j) {\n        return rank1(j) - rank1(i-1);\n    }\n    // iビット以下の0の数\n    int rank0(int i) {\n        return (i<0)?0:(i-rank1(i)+1);\n    }\n    // jビット目からiビット目までの0の数\n    int rank0(int i, int j) {\n        return rank0(j) - rank0(i-1);\n    }\n};\n\nclass WaveletMatrix\n{\nprivate:\n    uint height;\n    vector<BitRank> B;\n    vector<int> pos;\npublic:\n    WaveletMatrix(){}\n    WaveletMatrix(vector<int>& vec) :\n        WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}\n    // sigma:文字の種類数\n    WaveletMatrix(vector<int>& vec, int sigma){\n        init(vec, sigma);\n    }\n    void init(vector<int>& vec, int sigma){\n        height = MAX_BIT - __builtin_clz(sigma-1);\n        if(sigma == 1) height = 1;\n        B.resize(height), pos.resize(height);\n        for(uint i = 0; i < height; i++){\n            B[i].resize((int)vec.size());\n            for(int j = 0; j < (int)vec.size(); j++) {\n                B[i].set(j, access(vec[j], height - i - 1));\n            }\n            B[i].build();\n            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {\n                return !access(c, height - i - 1);\n            });\n            pos[i] = it - vec.begin();\n        }\n    }\n    // valのiビット目の値を返す(0,1)\n    inline int access(int val, int i) {\n        return (val >> i) & 1;\n    }\n    // [l,r]の間に現れる値cの数\n    int rank(int val,int l,int r) {\n        return rank(val, r) - rank(val, l - 1);\n    }\n    int rank(int val, int i) {\n        int p = -1;\n        for(uint j = 0; j < height; j++){\n            if(access(val, height - j - 1)){\n                p = pos[j] + B[j].rank1(p) - 1;\n                i = pos[j] + B[j].rank1(i) - 1;\n            }else{\n                p = B[j].rank0(p) - 1;\n                i = B[j].rank0(i) - 1;\n            }\n        }\n        return i - p;\n    }\n    // [l,r]のk(1,2,3...)番目に小さい値を返す\n    int quantile(int k, int l, int r) {\n        int res = 0;\n        for(uint i = 0; i < height; i++){\n            int j = B[i].rank0(l, r);\n            if(j >= k){\n                l = B[i].rank0(l-1);\n                r = B[i].rank0(r) - 1;\n            }else{\n                l = pos[i] + B[i].rank1(l-1);\n                r = pos[i] + B[i].rank1(r) - 1;\n                k -= j;\n                res |= (1 << (height - i - 1));\n            }\n        }\n        return res;\n    }\n    // [l,r]で値が[a,b]内に含まれる数を返す\n    int rangefreq(int l, int r, int a, int b) {\n        return rangefreq(l, r, a, b, 0, (1 << height) - 1, 0);\n    }\n    int rangefreq(int i, int j, int a, int b, int l, int r, int x) {\n        if(b < l || r < a) return 0;\n        int mid = l + (r - l) / 2;\n        if(a <= l && r <= b){\n            return j - i + 1;\n        }else{\n            int left = rangefreq(B[x].rank0(i-1),B[x].rank0(j)-1,a,b,l,mid,x+1);\n            int right = rangefreq(pos[x]+B[x].rank1(i-1),pos[x]+B[x].rank1(j)-1,a,b,mid+1,r,x+1);\n            return left + right;\n        }\n    }\n};\n\ntemplate<typename T> class OrthogonalRegionCount\n{\nprivate:\n    using ptt = pair<T, T>;\n    vector<T> X, Y;\n    WaveletMatrix wm;\n    int n;\npublic:\n    OrthogonalRegionCount(vector<ptt> candidate) {\n        int n = (int)candidate.size();\n        sort(candidate.begin(), candidate.end());\n        X.resize(n), Y.resize(n);\n        vector<T> vec(n);\n        rep(i,n){\n            X[i] = candidate[i].first, Y[i] = candidate[i].second;\n        }\n        sort(Y.begin(), Y.end());\n        Y.erase(unique(Y.begin(), Y.end()), Y.end());\n        rep(i,n){\n            vec[i] = lower_bound(Y.begin(), Y.end(), candidate[i].second) - Y.begin();\n        }\n        wm.init(vec, (int)Y.size());\n    }\n    //[lx,rx)×[ly,ry)の長方形領域に含まれる点の数を答える\n    int query(T lx, T ly, T rx, T ry) {\n        int lxid = lower_bound(X.begin(), X.end(), lx) - X.begin();\n        int rxid = upper_bound(X.begin(), X.end(), rx-1) - X.begin();\n        int lyid = lower_bound(Y.begin(), Y.end(), ly) - Y.begin();\n        int ryid = upper_bound(Y.begin(), Y.end(), ry-1) - Y.begin();\n        if(lxid >= rxid || lyid >= ryid) return 0;\n        return wm.rangefreq(lxid, rxid-1, lyid, ryid-1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n >> m;\n    vp vec(n);\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        vec[i] = P(a,b);\n    }\n    OrthogonalRegionCount<int> tdc(vec);\n    rep(i,m){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        cout << tdc.query(a,b,c+1,d+1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bits/stdc++.h>\n\nusing namespace std;\n\nint main(){\n    int n,m;\n    cin>>n>>m;\n    vector<int> x(n),y(n);\n    set<int> xs,ys;\n    for(int i=0;i<n;i++){\n        cin>>x[i]>>y[i];\n        xs.insert(x[i]);\n        ys.insert(y[i]);\n    }\n    xs.insert(-1e9-1),ys.insert(-1e9-1);\n    xs.insert(1e9+1),ys.insert(1e9+1);\n    map<int,int> dicx;\n    map<int,int> dicy;\n    int index=0;\n    for(auto it=xs.begin();it!=xs.end();it++){\n    \n        dicx[*it]=index;\n        index++;\n    }\n    index=0;\n    for(auto it=ys.begin();it!=ys.end();it++){\n        dicy[*it]=index;\n        index++;\n    }\n     \n    vector<vector<int>> field(xs.size(),vector<int>(ys.size(),0));\n    for(int i=0;i<n;i++){\n        field[dicx[x[i]]][dicy[y[i]]]++;\n    }\n    vector<vector<int>> sum(xs.size(),vector<int>(ys.size(),0));\n    for(int i=1;i<xs.size();i++){\n        for(int j=1;j<ys.size();j++){\n            sum[i][j]=field[i][j]+sum[i][j-1]+sum[i-1][j]-sum[i-1][j-1];\n        }\n    }\n\n    for(int i=0;i<m;i++){\n        int x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        swap(x1,x2);\n        swap(y1,y2);\n        auto it=xs.upper_bound(x1);\n        it--;\n        x1=*it;\n        it=ys.upper_bound(y1);\n        it--;\n        y1=*it;\n        it=xs.lower_bound(x2);\n        it--;\n        x2=*it;\n        it=ys.lower_bound(y2);\n        it--;\n        y2=*it;\n        cout<<sum[dicx[x1]][dicy[y1]]-sum[dicx[x1]][dicy[y2]]-sum[dicx[x2]][dicy[y1]]+sum[dicx[x2]][dicy[y2]]<<endl;\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<climits>\nusing namespace std;\n\nint main()\n{\n  int n,m;\n  int x1,y1,x2,y2;\n  vector<int> x,y;\n  vector<int> ix,iy;\n  vector< vector<int> > dp;\n\n  cin>>n>>m;\n  x.resize(n);\n  y.resize(n);\n  for(int i=0; i<n; i++){\n    cin>>x[i]>>y[i];\n    ix.push_back(x[i]);\n    iy.push_back(y[i]);\n  }\n  ix.push_back(INT_MIN);\n  iy.push_back(INT_MIN);\n  sort(ix.begin(), ix.end());\n  sort(iy.begin(), iy.end());\n  ix.erase(unique(ix.begin(), ix.end()), ix.end());\n  iy.erase(unique(iy.begin(), iy.end()), iy.end());\n\n  dp.resize(iy.size(), vector<int>(ix.size(), 0));\n  for(int i=0; i<n; i++){\n    int ty = lower_bound(iy.begin(), iy.end(), y[i]) - iy.begin();\n    int tx = lower_bound(ix.begin(), ix.end(), x[i]) - ix.begin();\n    dp[ty][tx]++;\n  }\n  for(int i=1; i<iy.size(); i++){\n    for(int j=1; j<ix.size(); j++){\n      dp[i][j] += dp[i-1][j] + dp[i][j-1] - dp[i-1][j-1];\n    }\n  }\n\n  for(int i=0; i<n; i++){\n    cin>>x1>>y1>>x2>>y2;\n    int ix1,iy1,ix2,iy2;\n    iy1 = lower_bound(iy.begin(), iy.end(), y1) - iy.begin();\n    ix1 = lower_bound(ix.begin(), ix.end(), x1) - ix.begin();\n    iy2 = upper_bound(iy.begin(), iy.end(), y2) - iy.begin()-1;\n    ix2 = upper_bound(ix.begin(), ix.end(), x2) - ix.begin()-1;\n    cout<<dp[iy2][ix2]+dp[iy1-1][ix1-1]-dp[iy1-1][ix2]-dp[iy2][ix1-1]<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n#include <vector>\n\ntemplate <typename Integral,\n\tstd::size_t bitsize = std::numeric_limits<Integral>::digits()>\n\tclass WaveletMatrix {\n\tpublic:\n\t\tusing value_type = Integral;\n\t\tusing size_type = std::size_t;\n\n\tprivate:\n\t\tusing uint32 = std::uint_least32_t;\n\t\tstatic size_type popcount32(uint32 c) {\n#ifdef __GNUC__\n\t\t\treturn __builtin_popcount(c);\n#elif _MSC_VER_\n\t\t\treturn _mm_popcnt_u32(c);\n#else\n\t\t\tc = (c & 0x55555555) + ((c >> 1) & 0x55555555);\n\t\t\tc = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n\t\t\tc = (c + (c >> 4)) & 0x0F0F0F0F;\n\t\t\tc += c >> 8;\n\t\t\tc += c >> 16;\n\t\t\treturn static_cast<size_type>(c) & 0x3F;\n#endif\n\t\t}\n\t\tstruct FID {\n\t\t\tstd::vector<uint32> dic;\n\t\t\tsize_type cnt;\n\t\t\tvalue_type bit;\n\t\t\tFID() {}\n\t\t\tFID(const size_type bsize) : dic(bsize, 0) {}\n\t\t\tvoid set(const size_type index) {\n\t\t\t\tdic[index >> 4 | 1] |= static_cast<uint32>(1) << (index & 0x1f);\n\t\t\t}\n\t\t\tvoid build() {\n\t\t\t\tconst size_type len = dic.size();\n\t\t\t\tfor (size_type j = 2; j < len; j += 2)\n\t\t\t\t\tdic[j] = dic[j - 2] + popcount32(dic[j - 1]);\n\t\t\t}\n\t\t\tsize_type rank(const size_type last) const {\n\t\t\t\treturn static_cast<size_type>(\n\t\t\t\t\tdic[last >> 4 & ~static_cast<size_type>(1)]) +\n\t\t\t\t\tpopcount32(dic[last >> 4 | 1] &\n\t\t\t\t\t(static_cast<size_type>(1) << (last & 0x1f)) - 1);\n\t\t\t}\n\t\t\tbool access(const size_type index) const {\n\t\t\t\treturn dic[index >> 4 | 1] >> (index & 0x1f) & 1;\n\t\t\t}\n\t\t};\n\t\tstd::array<FID, bitsize> matrix;\n\t\tvalue_type NOT_FOUND;\n\t\tsize_type size_;\n\n\tpublic:\n\t\tWaveletMatrix(std::vector<value_type> data, const value_type NOT_FOUND = 0)\n\t\t\t: size_(data.size()), NOT_FOUND(NOT_FOUND) {\n\t\t\tconst size_type len = data.size(), block = ((len >> 5) + 1) << 1;\n\t\t\tstd::vector<value_type> L(len), R(len);\n\t\t\tsize_type l, r;\n\t\t\tvalue_type temp = static_cast<value_type>(1) << (bitsize - 1);\n\t\t\tfor (auto &x : matrix) {\n\t\t\t\tx = FID(block);\n\t\t\t\tx.bit = temp;\n\t\t\t\ttemp = temp >> 1 & ~temp;\n\t\t\t\tl = 0;\n\t\t\t\tr = 0;\n\t\t\t\tfor (size_type j = 0; j < len; ++j)\n\t\t\t\t\tif (data[j] & x.bit)\n\t\t\t\t\t\tR[r++] = data[j], x.set(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tL[l++] = data[j];\n\t\t\t\tx.cnt = l;\n\t\t\t\tx.build();\n\t\t\t\tstd::swap(data, L);\n\t\t\t\tstd::copy(R.begin(), R.begin() + r, data.begin() + l);\n\t\t\t}\n\t\t}\n\n\t\tsize_type size() const noexcept { return size_; }\n\t\tbool empty() const noexcept { return size() == 0; }\n\n\t\tvalue_type access(size_type index) const {\n\t\t\tassert(index < size());\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (x.access(index))\n\t\t\t\t\tret |= x.bit, index = x.rank(index) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tindex -= x.rank(index);\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type operator[](const size_type index) const {\n\t\t\tassert(index < size());\n\t\t\treturn access(index);\n\t\t}\n\t\tsize_type rank(size_type first, size_type last, const value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (data & x.bit)\n\t\t\t\t\tfirst = x.rank(first) + x.cnt, last = x.rank(last) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tfirst -= x.rank(first), last -= x.rank(last);\n\t\t\treturn last - first;\n\t\t}\n\t\tvalue_type quantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tconst size_type l = x.rank(first), r = x.rank(last);\n\t\t\t\tif (r - l > k)\n\t\t\t\t\tfirst = l + x.cnt, last = r + x.cnt, ret |= x.bit;\n\t\t\t\telse\n\t\t\t\t\tfirst -= l, last -= r, k -= r - l;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type rquantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\treturn quantile(first, last, last - first - k - 1);\n\t\t}\n\t\tsize_type less_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_least(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type greater_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_most(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type rangefreq(size_type first, size_type last, const value_type lower,\n\t\t\tconst value_type upper) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tassert(lower <= upper);\n\t\t\treturn at_least(first, last, lower) - at_least(first, last, upper);\n\t\t}\n\t\tvalue_type successor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type predecessor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n\t\tvalue_type strict_succ(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type strict_pred(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n};\n\n#include<algorithm>\n#include<iostream>\n#include<limits>\n#include<utility>\n#include<vector>\nint main() {\n\tconstexpr int base = 1000000000;\n\tint n, m;\n\tstd::cin >> n >> m;\n\tstd::vector<std::pair<int, int>> p(n);\n\tfor (auto &e : p)\n\t\tstd::cin >> e.first >> e.second;\n\tstd::sort(p.begin(), p.end());\n\tstd::vector<int> a(n);\n\tfor (int i = 0;i < n;++i)\n\t\ta[i] = p[i].second + base;\n\tWaveletMatrix<int, 31> W(a);\n\tauto pos = [&p](int x) {\n\t\treturn std::lower_bound(p.begin(), p.end(),\n\t\t\tstd::pair<int, int>(x, std::numeric_limits<int>::lowest())) - p.begin();\n\t};\n\twhile (m--) {\n\t\tint x1, y1, x2, y2;\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tstd::cout << W.rangefreq(pos(x1), pos(x2 + 1), y1 + base, y2 + 1 + base) << std::endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//27\n//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n  }\n  for(int i=0;i<m;i++){\n    int r=0;\n    int xi[2],yi[2];\n    cin>>xi[0]>>yi[0]>>xi[1]>>yi[1];\n    for(int j=0;j<n;j++){\n      r+=xi[0]<=x[j]&&x[j]<=xi[1]&&yi[0]<=y[j]&&y[j]<=yi[1];\n    }\n    cout<<r<<endl;\n  }\n  return 0;\n}\n\nint main2(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size(),vector<int>(xp.size()));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()]++;\n  }\n  vector<vector<int> > ag(yp.size()+1,vector<int>(xp.size()+1));\n  for(int i=0;i<yp.size();i++){\n    for(int j=0;j<xp.size();j++){\n      ag[i+1][j+1]=ag[i][j+1]+ag[i+1][j]-ag[i][j]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=upper_bound(xp.begin(),xp.end(),xh)-xp.begin();\n    yyh=upper_bound(yp.begin(),yp.end(),yh)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[xxl][yyl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\nint sum[5002][5002];\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvpii pos(n);\n\tvi x(n+1), y(n+1);\n\tfor (int i = 0; i < n; i++) {\n\t\tint x1, y1;\n\t\tcin >> x1 >> y1;\n\t\tx[i] = x1;\n\t\ty[i] = y1;\n\t\tpos[i] = pii(x1, y1);\n\t}\n\tx.back() = -1e9 - 1;\n\ty.back() = -1e9 - 1;\n\tsort(ALL(x));\n\tsort(ALL(y));\n\tx.erase(unique(ALL(x)), x.end());\n\ty.erase(unique(ALL(y)), y.end());\n\tfor (pii a : pos)sum[lower_bound(ALL(x), a.first) - x.begin()][lower_bound(ALL(y), a.second) - y.begin()]++;\n\trep(i, x.size()) {\n\t\trep(j, y.size()) {\n\t\t\tsum[i][j] += -(i&&j ? sum[i - 1][j - 1] : 0) + (i ? sum[i - 1][j] : 0) + (j ? sum[i][j - 1] : 0);\n\t\t}\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = lower_bound(ALL(x), x1) - x.begin() - 1;\n\t\ty1 = lower_bound(ALL(y), y1) - y.begin() - 1;\n\t\tx2 = upper_bound(ALL(x), x2) - x.begin() - 1;\n\t\ty2 = upper_bound(ALL(y), y2) - y.begin() - 1;\n\t\tcout << sum[x2][y2] - sum[x1][y2] - sum[x2][y1] + sum[x1][y1] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int, int> pii;\nmain(){\n\tint i,n,m;\n\twhile(cin >> n >> m){\n\t\tvector<pii> d(n);\n\t\tfor(i=0;i<n;i++) cin >> d[i].first >> d[i].second;\n\t\tsort(d.begin(), d.end());\n\t\tfor(i=0;i<m;i++){\n\t\t\tint x1,y1,x2,y2,ans=0;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tvector<pii>::iterator itr1 = lower_bound(d.begin(), d.end(), pii(x1, y1));\n       \t\tvector<pii>::iterator itr2 = upper_bound(d.begin(), d.end(), pii(x2, y2));\n       \t\tfor(;itr1!=itr2;++itr1) if(y1 <= (*itr1).second && (*itr1).second <= y2) ans ++;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\tint n, m;\n\tcin >> n >> m;\n\tvector<int> x(n), y(n);\n\tfor(int i = 0; i < n; ++i){ cin >> x[i] >>  y[i]; }\n\tvector<int> xc(x), yc(y);\n\tsort(xc.begin(), xc.end());\n\tsort(yc.begin(), yc.end());\n\txc.erase(unique(xc.begin(), xc.end()), xc.end());\n\tyc.erase(unique(yc.begin(), yc.end()), yc.end());\n\tfor(int i = 0; i < n; ++i){\n\t\tx[i] = lower_bound(xc.begin(), xc.end(), x[i]) - xc.begin();\n\t\ty[i] = lower_bound(yc.begin(), yc.end(), y[i]) - yc.begin();\n\t}\n\tvector< vector<int> > image(yc.size(), vector<int>(xc.size()));\n\tfor(int i = 0; i < n; ++i){ ++image[y[i]][x[i]]; }\n\tvector< vector<int> > integral(yc.size() + 1, vector<int>(xc.size() + 1));\n\tfor(int i = 1; i <= yc.size(); ++i){\n\t\tint sum = 0;\n\t\tfor(int j = 1; j <= xc.size(); ++j){\n\t\t\tsum += image[i - 1][j - 1];\n\t\t\tintegral[i][j] = integral[i - 1][j] + sum;\n\t\t}\n\t}\n\twhile(m--){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tint xc1 = lower_bound(xc.begin(), xc.end(), x1) - xc.begin();\n\t\tint yc1 = lower_bound(yc.begin(), yc.end(), y1) - yc.begin();\n\t\tint xc2 = upper_bound(xc.begin(), xc.end(), x2) - xc.begin();\n\t\tint yc2 = upper_bound(yc.begin(), yc.end(), y2) - yc.begin();\n\t\tint answer = integral[yc2][xc2] - integral[yc2][xc1] - integral[yc1][xc2] + integral[yc1][xc1];\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 5010;\nconst int MAX_M = 5 * 100010;\nconst int MAX_Y = MAX_N + MAX_M * 2;\nconst int MAX_W = MAX_N + MAX_M * 2;\n\nint H, W, tsx[MAX_N], tsy[MAX_N], lsx[MAX_M], lsy[MAX_M], rsx[MAX_M], rsy[MAX_M], N, M;\nvector<int> X, Y;\nmap<int, int> Xm, Ym;\n\nvoid init_number(){\n  set<int> Ys, Xs;\n  REP(i, N){ Xs.insert(tsx[i]); Ys.insert(tsy[i]); }\n  REP(i, M){ Xs.insert(lsx[i]); Ys.insert(lsy[i]); }\n  REP(i, M){ Xs.insert(rsx[i]); Ys.insert(rsy[i]); }\n  Ys.insert((1e9 + 10) * -1);\n  Ys.insert(1e9 + 10);\n  Xs.insert((1e9 + 10) * -1);\n  Xs.insert(1e9 + 10);\n  X = vector<int>(Xs.begin(), Xs.end());\n  Y = vector<int>(Ys.begin(), Ys.end());\n  W = X.size();\n  H = Y.size();\n  REP(i, N){\n    int x = tsx[i], y = tsy[i];\n    Xm[x] = lower_bound(X.begin(), X.end(), x) - X.begin();\n    Ym[y] = lower_bound(Y.begin(), Y.end(), y) - Y.begin();\n  }\n  REP(i, M){\n    int x = lsx[i], y = lsy[i];\n    Xm[x] = lower_bound(X.begin(), X.end(), x) - X.begin();\n    Ym[y] = lower_bound(Y.begin(), Y.end(), y) - Y.begin();\n    x = rsx[i]; y = rsy[i];\n    Xm[x] = lower_bound(X.begin(), X.end(), x) - X.begin();\n    Ym[y] = lower_bound(Y.begin(), Y.end(), y) - Y.begin();\n  }\n}\n\nvoid init(vector< vector<int> > &v, vector< vector<int> > &E){\n  E[0][0] = v[0][0];\n  FOR(i, 1, H) E[i][0] = E[i - 1][0] + v[i][0];\n  FOR(i, 1, W) E[0][i] = E[0][i - 1] + v[0][i];\n  FOR(y, 1, H)\n    FOR(x, 1, W)\n    E[y][x] = v[y][x] + E[y - 1][x] + E[y][x - 1] - E[y - 1][x - 1];\n}\n\nint calc(int Y1, int X1, int Y2, int X2, vector< vector<int> > &E){\n  int ret = E[Y2][X2];\n  if(X1 - 1 >= 0) ret -= E[Y2][X1 - 1];\n  if(Y1 - 1 >= 0) ret -= E[Y1 - 1][X2];\n  if(X1 - 1 >= 0 && Y1 - 1 >= 0) ret += E[Y1 - 1][X1 - 1];\n  return ret;\n}\n\nint main() {\n  cin >>N >>M;\n  REP(i, N) cin >>tsx[i] >>tsy[i];\n  REP(i, M) cin >>lsx[i] >>lsy[i] >>rsx[i] >>rsy[i];\n  init_number();\n  vector< vector<int> > v(H, vector<int>(W, 0)), E(H, vector<int>(W, 0));\n  REP(i, N) v[Ym[tsy[i]]][Xm[tsx[i]]] += 1;\n  init(v, E);\n  REP(i, M) cout <<calc(Ym[lsy[i]], Xm[lsx[i]], Ym[rsy[i]], Xm[rsx[i]], E) <<endl;;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=a;i<b;++i)\n#define allof(a) a.begin(),a.end()\n\ntypedef pair< int, int > pii;\n\nint n, m, X[5050], Y[5050], X1[500050], X2[500050], Y1[500050], Y2[500050];\n\nint compress(int *x) {\n\tvector< int > xs;\n\t\n\tfor_(i,0,n) xs.push_back(x[i]);\n\t\n\tsort(allof(xs));\n\txs.erase(unique(allof(xs)), xs.end());\n\t\n\tfor_(i,0,n) x[i] = find(allof(xs), x[i]) - xs.begin();\n\t\n\treturn xs.size();\n}\n\nint main() {\n\tcin >> n >> m;\n\t\n\tvector< pii > vpx, vpy;\n\t\n\tfor_(i,0,n) {\n\t\tscanf(\"%d %d\", &X[i], &Y[i]);\n\t\tvpx.push_back(pii(X[i], i));\n\t\tvpy.push_back(pii(Y[i], i));\n\t}\n\t\n\tsort(allof(vpx)); sort(allof(vpy));\n\t\n\tvector< int > vx, vy;\n\tfor_(i,0,n) {\n\t\tvx.push_back(vpx[i].first);\n\t\tvy.push_back(vpy[i].first);\n\t}\n\t\n\tfor_(i,0,m) {\n\t\tint x1, x2, y1, y2; scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t\n\t\tint ind = lower_bound(allof(vx), x1) - vx.begin();\n\t\tX1[i] = ind < n ? vpx[ind].second : n;\n\t\t\n\t\tind = upper_bound(allof(vx), x2) - vx.begin() - 1;\n\t\tX2[i] = ind >= 0 ? vpx[ind].second : -1;\n\t\t\n\t\tind = lower_bound(allof(vy), y1) - vy.begin();\n\t\tY1[i] = ind < n ? vpy[ind].second : n;\n\t\t\n\t\tind = upper_bound(allof(vy), y2) - vy.begin() - 1;\n\t\tY2[i] = ind >= 0 ? vpy[ind].second : -1;\t\t\n\t}\n\t\n\tint W = compress(X), H = compress(Y);\n\tvector< vector< int > > grid(H+1, vector< int >(W+1, 0));\n\t\n\tfor_(i,0,n) ++grid[Y[i]][X[i]];\n\t\n\tfor_(y,0,H+1) for_(x,0,W+1) {\n\t\tif (y > 0) grid[y][x] += grid[y-1][x];\n\t\tif (x > 0) grid[y][x] += grid[y][x-1];\n\t\tif (y > 0 && x > 0) grid[y][x] -= grid[y-1][x-1];\n\t}\n\t\n\tfor_(i,0,m) {\n\t\tint ans = 0;\n\t\t\n\t\tif (X1[i] < n && X2[i] >= 0 && Y1[i] < n && Y2[i] >= 0) {\n\t\t\tint x1 = X[X1[i]], x2 = X[X2[i]], y1 = Y[Y1[i]], y2 = Y[Y2[i]];\n\t\t\tans += grid[y2][x2];\n\t\t\tif (x1-1 >= 0) ans -= grid[y2][x1-1];\n\t\t\tif (y1-1 >= 0) ans -= grid[y1-1][x2];\n\t\t\tif (x1-1 >= 0 && y1-1 >= 0) ans += grid[y1-1][x1-1];\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, m, x, y, xx, yy, ans;\n  std::cin >> n >> m;\n  vector<int> tx(n), ty(n);\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &tx[i], &ty[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    ans = 0;\n    scanf(\"%d %d %d %d\", &x, &y, &xx, &yy);\n    for (int j = 0; j < n; j++) {\n      if(x <= tx[j] and tx[j] <= xx and\n         y <= ty[j] and ty[j] <= yy)ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\ntypedef vector<string> VS;\ntypedef int INT;\ntypedef vector<INT> VI;\ntypedef vector<VI> VVI;\ntypedef pair <INT, INT> II;\ntypedef vector <II> VII;\n\n\nconst int PADDING = 1000000001;\nconst int SIZE = 5002;\nint n, m;\nII P[SIZE];\nint SX[SIZE], SY[SIZE];\nint SXC, SYC;\nshort CNT[SIZE][SIZE], DP[SIZE][SIZE];\n\nvoid init() {\n    memset( DP, 0, sizeof(DP) );\n    memset( CNT, 0, sizeof(CNT) );\n    SXC = SYC = 0;\n    for ( int i = 0; i < n; ++ i ) {\n        SX[SXC++] = P[i].first;\n        SY[SYC++] = P[i].second;\n    }\n    sort( SX, SX+n );\n    sort( SY, SY+n );\n    SXC = unique( SX, SX+n ) - SX;\n    SYC = unique( SY, SY+n ) - SY;\n    for ( int i = 0; i < n; ++ i ) {\n        int a = lower_bound( SX, SX+SXC, P[i].first ) - SX;\n        int b = lower_bound( SY, SY+SYC, P[i].second ) - SY;\n        CNT[a][b] ++;\n    }\n}\n\nbool input() {\n    if ( ! ( cin >> n >> m ) ) return false;\n    for ( int i = 0; i < n; ++ i ) {\n        scanf( \"%d%d\", &P[i].first, &P[i].second );\n    }\n    return true;\n}\n\nint calc( II p ) {\n    int *sxp = upper_bound( SX, SX+SXC, p.first );\n    int *syp = upper_bound( SY, SY+SYC, p.second );\n    int a = sxp - SX;\n    int b = syp - SY;\n    return DP[a][b];\n}\n\nint solve( II p1, II p2 ) {\n    II A( p1.first-1, p2.second ), B = p2, C( p1.first-1, p1.second-1 ), D( p2.first, p1.second-1 );\n    return calc(B) - calc(A) - calc(D) + calc(C);\n}\n\nvoid solve_host() {\n    for ( int i = 1; i <= SXC; ++ i ) {\n        for ( int j = 1; j <= SYC; ++ j ) {\n            DP[i][j] = DP[i-1][j] + DP[i][j-1] - DP[i-1][j-1] + CNT[i-1][j-1];\n        }\n    }\n\n    II p1, p2;\n    for ( int i = 0; i < m; ++ i ) {\n        scanf( \"%d%d%d%d\", &p1.first, &p1.second, &p2.first, &p2.second );\n        printf( \"%d\\n\", solve( p1, p2 ) );\n    }\n}\n\nint main() {\n    while ( input() ) {\n        init();\n        solve_host();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <map>\n#include <cstdio>\nusing namespace std;\nint main() {\n  int n, m;\n  cin >> n >> m;\n  set<int> X_, Y_;\n  vector< pair<int,int> > x_y(n);\n  int x, y;\n  for(int i = 0; i < n; ++i){\n    cin >> x >> y;\n    X_.insert(x);\n    Y_.insert(y);\n    x_y[i] = make_pair(x,y);\n  }\n  vector<int> X, Y;\n  for(set<int>::iterator itr = X_.begin(); itr != X_.end(); ++itr)\n    X.push_back(*itr);\n  for(set<int>::iterator itr = Y_.begin(); itr != Y_.end(); ++itr)\n    Y.push_back(*itr);\n\n  map<int,int> M_x, M_y;\n  for(int i = 0; i < X.size(); ++i) M_x[X[i]] = i;\n  for(int i = 0; i < Y.size(); ++i) M_y[Y[i]] = i;\n  int h = X.size(), w = Y.size();\n  vector< vector<int> >  acum(h+2,vector<int>(w+2,0));\n  for(int i = 0; i < n; ++i){\n    int x = x_y[i].first, y = x_y[i].second;\n    ++acum[M_x[x]+1][M_y[y]+1];\n  }\n  \n  \n  for(int i = 1; i <= h+1; ++i){\n    for(int j = 1; j <= w+1; ++j){\n      acum[i][j] += acum[i][j-1];\n    }\n    for(int j = 1; j <= w+1; ++j){\n      acum[i][j] += acum[i-1][j];\n    }\n  }\n  int x_1, x_2, y_1, y_2;\n  for(int i = 0; i < m; ++i){\n    cin >> x_1 >> y_1 >> x_2 >> y_2;\n    int x_1_ = lower_bound(X.begin(),X.end(),x_1)-X.begin(),\n      y_1_ = lower_bound(Y.begin(),Y.end(),y_1)-Y.begin(),\n      x_2_ = upper_bound(X.begin(),X.end(),x_2)-X.begin(),\n      y_2_ = upper_bound(Y.begin(),Y.end(),y_2)-Y.begin();\n    cout << acum[x_2_][y_2_] - acum[x_2_][y_1_] - acum[x_1_][y_2_] + acum[x_1_][y_1_] << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef long double ld;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-10;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nvoid compress(vi& v)\n{\n\tsort(ALL(v));\n\tv.erase(unique(ALL(v)), v.end());\n}\n\nint main()\n{\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> v;\n\tvi vx, vy;\n\tREP(i, n)\n\t{\n\t\tld x, y; cin >> x >> y;\n\t\tvx.push_back(x); vy.push_back(y);\n\t\tv.emplace_back(x, y);\n\t}\n\tcompress(vx);\n\tcompress(vy);\n\tvector<vi> sum(n+1, vi(n+1));\n\tREP(i, n)\n\t{\n\t\tint x = v[i].first, y = v[i].second;\n\t\tint cx = find(ALL(vx), x) - vx.begin();\n\t\tint cy = find(ALL(vy), y) - vy.begin();\n\t\tsum[cx+1][cy+1]++;\n\t}\n\tFOR(i, 1, n + 1)FOR(j, 1, n + 1)\n\t{\n\t\tsum[i][j] += sum[i - 1][j] + sum[i][j - 1] - sum[i-1][j-1];\n\t}\n\t\n\tREP(i, m)\n\t{\n\t\tld lx, ly, rx, ry;\n\t\tcin >> lx >> ly >> rx >> ry;\n\t\trx++; ry++;\n\t\tint clx = lower_bound(ALL(vx), lx) - vx.begin();\n\t\tint cly = lower_bound(ALL(vy), ly) - vy.begin();\n\t\tint crx = lower_bound(ALL(vx), rx) - vx.begin();\n\t\tint cry = lower_bound(ALL(vy), ry) - vy.begin();\n\t\tcout << sum[crx][cry] - sum[crx][cly] - sum[clx][cry] + sum[clx][cly] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ninline int index(const vector<int> &xs, int x){\n\treturn lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n}\n\nint main(){\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\n\tvector<int> tx(n + 1), ty(n + 1);\n\tfor(int i = 0; i < n; ++i){\n\t\tscanf(\"%d%d\", &tx[i], &ty[i]);\n\t}\n\ttx[n] = ty[n] = (int)-2e9;\n\t\n\tvector<int> xs = tx, ys = ty;\n\tsort(xs.begin(), xs.end());\n\txs.erase( unique(xs.begin(), xs.end()), xs.end() );\n\tsort(ys.begin(), ys.end());\n\tys.erase( unique(ys.begin(), ys.end()), ys.end() );\n\n\tvector<vector<int> > s(xs.size() + 1, vector<int>(ys.size() + 1) );\n\tfor(int i = 0; i < n; ++i){\n\t\tint ix = index(xs, tx[i]);\n\t\tint iy = index(ys, ty[i]);\n\t\t++s[ix][iy];\n\t}\n\t\n\tfor(int i = 0; i <= xs.size(); ++i){\n\t\tfor(int j = 1; j <= ys.size(); ++j){\n\t\t\ts[i][j] += s[i][j - 1];\n\t\t}\n\t}\n\tfor(int j = 0; j <= ys.size(); ++j){\n\t\tfor(int i = 1; i <= xs.size(); ++i){\n\t\t\ts[i][j] += s[i - 1][j];\n\t\t}\n\t}\n\t\n\tint x1, x2, y1, y2;\n\tfor(int i = 0; i < m; ++i){\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\n\t\tint ix1 = index(xs, x1);\n\t\tint iy1 = index(ys, y1);\n\t\tint ix2 = upper_bound(xs.begin(), xs.end(), x2) - xs.begin() - 1;\n\t\tint iy2 = upper_bound(ys.begin(), ys.end(), y2) - ys.begin() - 1;\n\t\t\n\t\tint c = s[ix2][iy2] - s[ix1-1][iy2] - s[ix2][iy1-1] + s[ix1-1][iy1-1];\n\t\tprintf(\"%d\\n\", c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nset<int> X, Y;\nunordered_map<int, int> MX, MY;\nint xs[5001], ys[5001];\nint rx1[500010], ry1[500010];\nint rx2[500010], ry2[500010];\nint sum[5010][5010];\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  rep(i, N) {\n    scanf(\"%d%d\", &xs[i], &ys[i]);\n    X.insert(xs[i]); Y.insert(ys[i]);\n  }\n\n  rep(i, M) {\n    scanf(\"%d%d%d%d\", &rx1[i], &ry1[i], &rx2[i], &ry2[i]);\n    X.insert(rx1[i]); Y.insert(ry1[i]);\n    X.insert(rx2[i]); Y.insert(ry2[i]);\n  }\n\n  int W = 0; for(auto && e: X) MX[e] = W++;\n  int H = 0; for(auto && e: Y) MY[e] = H++;\n\n  rep(i, N) {\n    sum[MY[ys[i]]][MX[xs[i]]] ++;\n  }\n\n  rep(i, H) rep(j, W) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int x1 = MX[rx1[i]], x2 = MX[rx2[i]];\n    int y1 = MY[ry1[i]], y2 = MY[ry2[i]];\n    int r = sum[y2][x2];\n    if(x1 && y1) r += sum[y1-1][x1-1];\n    if(y1) r -= sum[y1-1][x2];\n    if(x1) r -= sum[y2][x1-1];\n    printf(\"%d\\n\", r);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_; std::vector<std::vector<Type> > dat;\n\tinline int query_(int a, int b, Type x, int k, int l, int r) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r)\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return lower_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::vector<Type>());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_] = std::vector<Type>({ *(begin_ + i) });\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tint cl = 0, cr = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][cr])) {\n\t\t\t\t\tdat[i][j] = dat[i << 1][cl++];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\treturn query_(l, r, x, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nint n, q, xa, ya, xb, yb, xc[5555], yc[5555], xd[5555], yd[5555]; pair<int, int> p1[5555], p2[5555];\nint main() {\n\tscanf(\"%d%d\", &n, &q);\n\tfor(int i = 0; i < n; i++) scanf(\"%d%d\", &p1[i].first, &p1[i].second), p2[i] = make_pair(p1[i].second, p1[i].first);\n\tsort(p1, p1 + n); sort(p2, p2 + n);\n\tfor(int i = 0; i < n; i++) xc[i] = p1[i].first, yc[i] = p1[i].second, xd[i] = p2[i].second, yd[i] = p2[i].first;\n\tfor(int i = 0; i < q; i++) {\n\t\tscanf(\"%d%d%d%d\", &xa, &ya, &xb, &yb);\n\t\tint l1 = lower_bound(xc, xc + n, xa) - x;\n\t\tint r1 = lower_bound(xc, xc + n, xb + 1) - x;\n\t\tint l2 = lower_bound(yc, yc + n, ya) - y;\n\t\tint r2 = lower_bound(yc, yc + n, yb + 1) - y;\n\t\tint c = 0;\n\t\tif(r1 - l1 <= r2 - l2) {\n\t\t\tfor(int j = l1; j < r1; j++) {\n\t\t\t\tif(ya <= yc[j] && yc[j] <= yb) c++;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tfor(int j = l2; j < r2; j++) {\n\t\t\t\tif(xa <= xd[j] && xd[j] <= xb) c++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", c);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define fi first\n#define se second\n#define show(x) cerr<<#x<<\"=\"<<x<<\"\\n\"\ntypedef long long ll;\nusing namespace std;\n//const ll MOD=(ll)1e9+7;\n//const ll inf=(ll)1e14;\nconst int dy[]={1,0,-1};\nconst int dx[]={1,0,-1};\nint n,m,h,w;\nvector<int> x,y,xx,yy;\nint imos[5001][5001];\n\nint main(){\n  ios::sync_with_stdio(false);\n  cin.tie(0);\n  cout.precision(10);\n  cout<<fixed;\n#ifdef LOCAL_DEFINE\n  FILE *stream1;\n  //FILE *stream2;\n  stream1=freopen(\"in\",\"r\",stdin);\n  //stream2=freopen(\"out\",\"w\",stdout);\n  if(stream1==NULL)return 0;\n  //if(stream2==NULL)return 0;\n#endif\n  cin>>n>>m;\n  for(int i=0;i<n;i++){\n    int a,b;cin>>a>>b;\n    xx.push_back(a);\n    x.push_back(a);\n    yy.push_back(b);\n    y.push_back(b);\n  }\n  x.push_back(-1000000000);\n  y.push_back(-1000000000);\n  x.push_back(1000000000);\n  y.push_back(1000000000);\n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n  for(int i=0;i<n;i++){\n    xx[i]=lower_bound(x.begin(),x.end(),xx[i])-x.begin();\n    yy[i]=lower_bound(y.begin(),y.end(),yy[i])-y.begin();\n  }\n  h=(int)y.size();\n  w=(int)x.size();\n  for(int i=0;i<n;i++){\n    imos[yy[i]][xx[i]]++;\n  }\n  for(int i=0;i<h;i++)for(int j=1;j<w;j++)imos[i][j]+=imos[i][j-1];\n  for(int i=1;i<h;i++)for(int j=0;j<w;j++)imos[i][j]+=imos[i-1][j];\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;cin>>x1>>y1>>x2>>y2;\n    auto xa=lower_bound(x.begin(),x.end(),x1);\n    if(*xa>=x1)xa--;\n    auto xb=lower_bound(x.begin(),x.end(),x2);\n    if(*xb>x2)xb--;\n    auto ya=lower_bound(y.begin(),y.end(),y1);\n    if(*ya>=y1)ya--;\n    auto yb=lower_bound(y.begin(),y.end(),y2);\n    if(*yb>y2)yb--;\n    x1=xa-x.begin();x2=xb-x.begin();y1=ya-y.begin();y2=yb-y.begin();\n    cout<<imos[y2][x2]-imos[y2][x1]-imos[y1][x2]+imos[y1][x1]<<endl;\n  }\n#ifdef LOCAL_DEFINE\n  cerr<<\"Time elapsed: \"<<1.0*clock()/CLOCKS_PER_SEC<<\"s.\\n\";\n  fclose(stream1);\n  //fclose(stream2);\n#endif\n  return 0;\n}\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[5555], sy[5555];\nint tx[5555], ty[5555];\nint vx[5555];\nint vy[5555];\nint bit[33330][33330];\n\nvoid add(int a, int b, int w)\n{\n  for(int x = a; x <= 6 * n; x += x & -x){\n    for(int y = b; y <= 6 * n; y += y & -y){\n      bit[x][y] += w;\n    }\n  }\n}\n\nint sum(int a, int b)\n{\n  int ret = 0;\n  for(int x = a; x > 0; x -= x & -x){\n    for(int y = b; y > 0; y -= y & -y){\n      ret += bit[x][y];\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n  \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);  x.pb(sx[i]);  x.pb(tx[i]);\n    y.pb(vy[i]);  y.pb(sy[i]);  y.pb(ty[i]);\n  }\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin() + 1;\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin() + 1;\n  }\n  rep(i, m){\n    sx[i] = lower_bound(ALL(x), sx[i]) - x.begin() + 1;\n    sy[i] = lower_bound(ALL(y), sy[i]) - y.begin() + 1;\n    tx[i] = lower_bound(ALL(x), tx[i]) - x.begin() + 1;\n    ty[i] = lower_bound(ALL(y), ty[i]) - y.begin() + 1;\n  }\n  rep(i, n) add(vx[i], vy[i], 1);\n\n  rep(i, m){\n    int ret = 0;\n    ret += sum(tx[i], ty[i]);\n    ret += sum(sx[i] - 1, sy[i] - 1);\n    ret -= sum(sx[i] - 1, ty[i]);\n    ret -= sum(tx[i], sy[i] - 1);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll; \nconst ll segN=(1LL<<32);\nvector<ll> G;\nstruct data{\n  vector<ll> *v;\n  bool flg;\n  data* ch[2];\n  \n  void init(){\n    v=new vector<ll>;\n    flg=false;\n    ch[0]=(data*)malloc(sizeof(data));\n    ch[1]=(data*)malloc(sizeof(data));\n    ch[0]->ch[0]=NULL;\n    ch[1]->ch[0]=NULL;\n  }\n  \n  void add(ll i,ll x,ll l,ll r){\n    //    cout<<i<<' '<<x<<' '<<l<<' '<<r<<endl;\n    ll m=(l+r)/2;\n    if(ch[0]==NULL)init();\n    if(i<l || r<=i)return;\n    v->push_back(x);\n    if(r-l==1)return;\n    ch[0]->add(i,x,l,m);\n    ch[1]->add(i,x,m,r);\n  }\n   \n  void add(ll i,ll x){\n    add(i,x,0,segN);\n  }\n  \n  ll sum(ll a,ll b,ll c,ll d,ll l,ll r){\n    ll m=(l+r)/2;\n    if(ch[0]==NULL)return 0;\n    if(b<=l || r<=a)return 0;\n    if(a<=l && r<=b){\n      if(!flg)sort(v->begin(),v->end());\n      flg=true;      \n      vector<ll> :: iterator A,B;\n      A=lower_bound(v->begin(),v->end(),c);\n      B=upper_bound(v->begin(),v->end(),d);\n      return B-A;\n    }\n    \n    ll res=0;\n    res+=ch[0]->sum(a,b,c,d,l,m);\n    res+=ch[1]->sum(a,b,c,d,m,r);\n    return res;\n  }\n \n  ll sum(ll a,ll b,ll c,ll d){\n    return sum(a,b,c,d,0,segN);\n  }\n};\n \n \n   \n\ndata T;\n \nint main(){\n  ll d=1e9;\n  int n,m;\n  int ax,ay,bx,by;\n  T.init();\n  scanf(\"%d %d\",&n,&m);\n  for(int i=0;i<n;i++){\n    scanf(\"%d %d\",&ax,&ay);\n    T.add(ax+d,ay);\n  }\n  for(int i=0;i<m;i++){\n    scanf(\"%d %d %d %d\",&ax,&ay,&bx,&by);\n    cout<<T.sum(ax+d,bx+d+1,ay,by)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <functional>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <deque>\n#include <ctime>\n  \nusing namespace std;\n  \n#define rep(i,n) REP(i,0,n)\n#define REP(i,s,e) for(int i=(s); i<(int)(e); i++)\n#define pb push_back\n#define mp make_pair\n#define all(r) (r).begin(),(r).end()\n#define rall(r) (r).rbegin(),(r).rend()\n#define fi first\n#define se second\n#define println(X) cout<<X<<endl;\n#define DBG(X) cout<<#X<<\" : \"<<X<<endl;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vii;\ntypedef vector<ll> vl;\ntypedef vector<vl> vll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n \nconst int INF = 1e9;\nconst ll LINF = 1e18;\nconst ll MOD = 1e9 + 7;\ndouble EPS = 1e-8;\nconst double PI = acos(-1);\n\nint d[5010][5010];\n\nint f(int x1, int y1, int x2, int y2){\n\treturn d[x2][y2]-d[x1][y2]-d[x2][y1]+d[x1][y1];\n}\n\nint main(){\n\tint n, m;\n\tcin>>n>>m;\n\tmap<int, int> mx, my;\n\tvector<pii> v(n), s(m), t(m);\n\trep(i, n){\n\t\tcin>>v[i].fi>>v[i].se;\n\t\tmx[v[i].fi]++;\n\t\tmy[v[i].se]++;\n\t}\n\trep(i, m){\n\t\tcin>>s[i].fi>>s[i].se>>t[i].fi>>t[i].se;\n\t\tmx[s[i].fi]++;\n\t\tmy[s[i].se]++;\n\t\tmx[t[i].fi]++;\n\t\tmy[t[i].se]++;\n\t}\n\tint cnt = 0;\n\tfor(auto& p : mx) p.se = ++cnt;\n\tcnt = 0;\n\tfor(auto& p : my) p.se = ++cnt;\n\n\trep(i, n) d[mx[v[i].fi]][my[v[i].se]]++;\n\tfor(int i = 0; i < 5010; i++) {\n\t\tfor(int j = 0; j < 5009; j++){\n\t\t\td[i][j+1] += d[i][j];\n\t\t}\n\t}\n\tfor(int i = 0; i < 5009; i++) {\n\t\tfor(int j = 0; j < 5010; j++){\n\t\t\td[i+1][j] += d[i][j];\n\t\t}\n\t}\n\trep(i, m){\n\t\tcout<<f(mx[s[i].fi-1], my[s[i].se-1], mx[t[i].fi], my[t[i].se])<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\nusing pii=pair<int,int>;\n#define REPF(i,a,n) for(int i=(a);i<(int)(n);++i)\n#define REP(i,n) REPF(i,0,n)\n#define ALL(c) begin(c),end(c)\n\nint sum[5100][5100];\nsigned main() {\n    int n,m;\n    cin>>n>>m;\n    vector<int> x(n),y(n);\n    vector<pii> p(n);\n    REP(i,n) {\n        cin>>p[i].first>>p[i].second;\n        x[i]=p[i].first;\n        y[i]=p[i].second;\n    }\n    sort(ALL(x));\n    x.erase(unique(ALL(x)),end(x));\n    sort(ALL(y));\n    y.erase(unique(ALL(y)),end(y));\n\n    auto get_x=[&](int i) {\n        return distance(begin(x),lower_bound(ALL(x),i));\n    };\n    auto get_y=[&](int i) {\n        return distance(begin(y),lower_bound(ALL(y),i));\n    };\n\n    REP(i,n) {\n        int xx=get_x(p[i].first);\n        int yy=get_y(p[i].second);\n        sum[xx][yy]++;\n    }\n    REP(i,5100) REPF(j,1,5100) sum[i][j]+=sum[i][j-1];\n    REP(j,5100) REPF(i,1,5100) sum[i][j]+=sum[i-1][j];\n\n    REP(i,m) {\n        int x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        int xx1=get_x(x1);\n        int yy1=get_y(y1);\n        int xx2=get_x(x2);\n        int yy2=get_y(y2);\n        if(find(ALL(x),x2)==end(x)) xx2--;\n        if(find(ALL(y),y2)==end(y)) yy2--;\n\n        int ans=sum[xx2][yy2];\n        if(xx1>0) {\n            ans-=sum[xx1-1][yy2];\n        }\n        if(yy1>0) {\n            ans-=sum[xx2][yy1-1];\n        }\n        if(xx1>0 && yy1>0) {\n            ans+=sum[xx1-1][yy1-1];\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define MOD 1000000007\n#define rep(i,n) for(i=0;i<n;i++)\n#define loop(i,a,n) for(i=a;i<n;i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\n\nint grid[5005][5005];\n\nvoid compress(vi &v){\n  sort(all(v));\n  v.erase(unique(all(v)),v.end());\n}\n\nvoid cumulativesum(int h,int w){\n  int i,j;\n  rep(i,h)rep(j,w) grid[i+1][j+1]+=grid[i+1][j]+grid[i][j+1]-grid[i][j];\n}\n\nint sum(int i,int j,int k,int l){//y,x??§??????????°???§                                 \n  return grid[k][l]-grid[i][l]-grid[k][j]+grid[i][j];\n}\nint main(void) {\n  int i,j;\n  int n,m;\n  cin>>n>>m;\n  vi x(n),y(n);\n  pii p[5000];\n  rep(i,n){\n    cin>>x[i]>>y[i];\n    p[i].first=x[i];\n    p[i].second=y[i];\n  }\n\n  compress(x);\n  compress(y);\n\n  rep(i,n){\n    int fy=lower_bound(all(y),p[i].second)-y.begin();\n    int fx=lower_bound(all(x),p[i].first)-x.begin();\n    grid[fy+1][fx+1]++;\n  }\n\n  cumulativesum(n,n);//?´???????                                                      \n\n  rep(i,m){\n    int lx,ly,rx,ry;\n    cin>>lx>>ly>>rx>>ry;\n    lx=lower_bound(all(x),lx)-x.begin();\n    ly=lower_bound(all(y),ly)-y.begin();\n    rx=lower_bound(all(x),rx+1)-x.begin();\n    ry=lower_bound(all(y),ry+1)-y.begin();\n    cout<<sum(ly,lx,ry,rx)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct BIT{\n\tvector<int> bit;\n\tint size;\n\t\n\tBIT(int n){\n\t\tsize=n;bit=vector<int>(n+1);\n\t}\n\t\n\tvoid add(int i,int x){\n\t\ti+=1;\n\t\twhile(i<=size)bit[i]+=x,i+=i&-i;\n\t}\n\n\tint sum(int i){\n\t\tint s=0;\n\t\twhile(i>0)s+=bit[i],i-=i&-i;\n\t\treturn s;\n\t}\n};\n\nstruct BIT2D{\n\tvector<BIT> bit;\n\tBIT2D(int x,int y):bit(x+1,BIT(y)){};\n\t\n\tvoid add(int x, int y, int v){\n\t\tx++;\n\t\twhile(x < (int)bit.size()){\n\t\t\tbit[x].add(y, v);\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\n\tint sum(int x,int y){\n\t\tint s = 0;\n\t\twhile(x > 0){\n\t\t\ts += bit[x].sum(y);\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nint n, m;\nint data[5000][2];\nint query[500000][4];\nmap<int,int> xmap;\nmap<int,int> ymap;\n\nint xmax, ymax;\n\nBIT2D qq(xmax, ymax);\n\nvoid input() {\n\tvector<int> xs;\n\tvector<int> ys;\n\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &data[i][0], &data[i][1]);\n\t\txs.push_back(data[i][0]);\n\t\tys.push_back(data[i][1]);\n\t}\n\trep(i,m) {\n\t\tscanf(\"%d%d%d%d\", &query[i][0], &query[i][1], &query[i][2], &query[i][3]);\n\t\txs.push_back(query[i][0]);\n\t\tys.push_back(query[i][1]);\n\t\txs.push_back(query[i][2]);\n\t\tys.push_back(query[i][3]);\n\t}\n\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\n\t{\n\t\tvector<int>::iterator eiter = unique(xs.begin(), xs.end());\n\t\tvector<int>::iterator iter = xs.begin();\n\t\tint i = 0;\n\t\tfor(i = 0; iter != eiter; iter++, i++) {\n\t\t\txmap[*iter] = i;\n\t\t}\n\t\txmax = i;\n\t}\n\t{\n\t\tvector<int>::iterator eiter = unique(ys.begin(), ys.end());\n\t\tvector<int>::iterator iter = ys.begin();\n\t\tint i = 0;\n\t\tfor(i = 0; iter != eiter; iter++, i++) {\n\t\t\tymap[*iter] = i;\n\t\t}\n\t\tymax = i;\n\t}\n}\n\nvoid process() {\n\trep(i, n) {\n\t\tqq.add(xmap[data[i][0]], ymap[data[i][1]], 1);\n\t}\n\n\trep(i, m) {\n\t\tint sumxy = qq.sum(xmap[query[i][2]] + 1, ymap[query[i][3]] + 1);\n\t\tint sumxyy = qq.sum(xmap[query[i][2]] + 1, ymap[query[i][1]]);\n\t\tint sumxxy = qq.sum(xmap[query[i][0]], ymap[query[i][3]] + 1);\n\t\tint sumxxyy = qq.sum(xmap[query[i][0]], ymap[query[i][1]]);\n\t\tprintf(\"%d\\n\", sumxy - sumxyy - sumxxy + sumxxyy);\n\t}\n}\n\nvoid output() {\n}\n\nint main() {\n\tinput();\n\tprocess();\n\toutput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// >>> TEMPLATES\n#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing i32 = int32_t;\nusing i64 = int64_t;\nusing u32 = uint32_t;\nusing u64 = uint64_t;\n#define int ll\n#define double ld\n#define rep(i,n) for (int i = 0; i < (int)(n); i++)\n#define rep1(i,n) for (int i = 1; i <= (int)(n); i++)\n#define repR(i,n) for (int i = (int)(n)-1; i >= 0; i--)\n#define rep1R(i,n) for (int i = (int)(n); i >= 1; i--)\n#define loop(i,a,B) for (int i = a; i B; i++)\n#define loopR(i,a,B) for (int i = a; i B; i--)\n#define all(x) (x).begin(), (x).end()\n#define allR(x) (x).rbegin(), (x).rend()\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define fst first\n#define snd second\ntemplate <class Int> auto constexpr inf = numeric_limits<Int>::max()/2-1;\nauto constexpr INF32 = inf<int32_t>;\nauto constexpr INF64 = inf<int64_t>;\nauto constexpr INF   = inf<int>;\n#ifdef LOCAL\n#include \"debug.hpp\"\n#else\n#define dump(...) (void)(0)\n#define say(x) (void)(0)\n#define debug if (0)\n#endif\ntemplate <class T> using pque_max = priority_queue<T>;\ntemplate <class T> using pque_min = priority_queue<T, vector<T>, greater<T> >;\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nostream& operator<<(ostream& os, T const& v) { bool f = true; for (auto const& x : v) os << (f ? \"\" : \" \") << x, f = false; return os; }\ntemplate <class T, class = typename T::iterator, class = typename enable_if<!is_same<T, string>::value>::type>\nistream& operator>>(istream& is, T &v) { for (auto& x : v) is >> x; return is; }\ntemplate <class T, class S> ostream& operator<<(ostream& os, pair<T,S> const& p) { return os << \"(\" << p.first << \", \" << p.second << \")\"; }\ntemplate <class T, class S> istream& operator>>(istream& is, pair<T,S>& p) { return is >> p.first >> p.second; }\nstruct IOSetup { IOSetup() { cin.tie(nullptr); ios::sync_with_stdio(false); cout << fixed << setprecision(15); } } iosetup;\ntemplate <class F> struct FixPoint : private F {\n    constexpr FixPoint(F&& f) : F(forward<F>(f)) {}\n    template <class... T> constexpr auto operator()(T&&... x) const { return F::operator()(*this, forward<T>(x)...); }\n};\nstruct MakeFixPoint {\n    template <class F> constexpr auto operator|(F&& f) const { return FixPoint<F>(forward<F>(f)); }\n};\n#define MFP MakeFixPoint()|\n#define def(name, ...) auto name = MFP [&](auto &&name, __VA_ARGS__)\ntemplate <class T, size_t d> struct vec_impl {\n    using type = vector<typename vec_impl<T,d-1>::type>;\n    template <class... U> static type make_v(size_t n, U&&... x) { return type(n, vec_impl<T,d-1>::make_v(forward<U>(x)...)); }\n};\ntemplate <class T> struct vec_impl<T,0> { using type = T; static type make_v(T const& x = {}) { return x; } };\ntemplate <class T, size_t d = 1> using vec = typename vec_impl<T,d>::type;\ntemplate <class T, size_t d = 1, class... Args> auto make_v(Args&&... args) { return vec_impl<T,d>::make_v(forward<Args>(args)...); }\ntemplate <class T> void quit(T const& x) { cout << x << endl; exit(0); }\ntemplate <class T, class U> constexpr bool chmin(T& x, U const& y) { if (x > y) { x = y; return true; } return false; }\ntemplate <class T, class U> constexpr bool chmax(T& x, U const& y) { if (x < y) { x = y; return true; } return false; }\ntemplate <class It> constexpr auto sumof(It b, It e) { return accumulate(b,e,typename iterator_traits<It>::value_type{}); }\ntemplate <class T> int sz(T const& x) { return x.size(); }\ntemplate <class C, class T> int lbd(C const& v, T const& x) {\n    return lower_bound(v.begin(), v.end(), x)-v.begin();\n}\ntemplate <class C, class T> int ubd(C const& v, T const& x) {\n    return upper_bound(v.begin(), v.end(), x)-v.begin();\n}\nconst int dx[] = { 1,0,-1,0 };\nconst int dy[] = { 0,1,0,-1 };\nconstexpr int popcnt(ll x) { return __builtin_popcountll(x); }\ntemplate <class Int> struct Random {\n    mt19937_64 mt{random_device{}()};\n    //mt19937_64 mt{(unsigned)time(0)};\n    Int a,b; // [a,b]\n    Random(Int a, Int b) : a(a), b(b) {}\n    Int operator()() { return uniform_int_distribution<Int>(a,b)(mt); }\n};\ntemplate <class Int> Int rand(Int a, Int b) { // [a,b]\n    static mt19937_64 mt{random_device{}()};\n    return uniform_int_distribution<Int>(a,b)(mt);\n}\n// <<<\n// >>> coordinate compression\ntemplate <class T>\nstruct Compress {\n    vector<T> v;\n    bool ok = false;\n    void add(T const& x) { ok = false; v.push_back(x); }\n    template <class V>\n    void add(V const& u) { ok = false; copy(all(u), back_inserter(v)); }\n    template <class... Ts>\n    void add(Ts const&... xs) { (int[]){(add(xs),0)...}; }\n    void init() { sort(all(v)); v.erase(unique(all(v)), v.end()); ok = true; }\n    int size() const { return v.size(); }\n    T operator[](int i) const { assert(ok); return v[i]; }\n    int find(T const& x) const { assert(ok); auto it = lower_bound(all(v),x);\n        //assert(*it == x);\n        return it-v.begin(); }\n    void set(T& x) const { x = find(x); }\n    template <class V>\n    void set(V& u) const { for (auto &x : u) x = find(x); }\n    template <class... Ts>\n    void set(Ts&... xs) const { (int[]){(set(xs),0)...}; }\n};\n// <<<\n\nint32_t main() {\n    int n,q; cin >> n >> q;\n    vector<int> x(n),y(n);\n    rep (i,n) cin >> x[i] >> y[i];\n    Compress<int> zx,zy;\n    zx.add(x); zx.init(), zx.set(x);\n    zy.add(y); zy.init(), zy.set(y);\n\n    auto a = make_v<i32,2>(zx.size()+1,zy.size()+1);\n    rep (i,n) a[x[i]+1][y[i]+1]++;\n    rep (i,zx.size()+1) rep (j,zy.size()) a[i][j+1] += a[i][j];\n    rep (i,zx.size()) rep (j,zy.size()+1) a[i+1][j] += a[i][j];\n\n    rep (_,q) {\n        int x1,y1,x2,y2; cin >> x1 >> y1 >> x2 >> y2;\n        ++x2,++y2;\n        int ans = 0;\n        ans += a[zx.find(x2)][zy.find(y2)];\n        ans -= a[zx.find(x1)][zy.find(y2)];\n        ans -= a[zx.find(x2)][zy.find(y1)];\n        ans += a[zx.find(x1)][zy.find(y1)];\n        cout << ans << \"\\n\";\n    }\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ninline void compress(vector<int> &c){\n    sort(c.begin(),c.end());\n    c.erase(unique(c.begin(),c.end()),c.end());\n}\ninline int idx(int i,vector<int> &c){\n    return lower_bound(c.begin(),c.end(),i)-c.begin();\n}\nint sum[5010][5010]={{0}};\nint main(){\n    int xs[5000],ys[1000];\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    vector<int>x(n),y(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",xs+i,ys+i);\n        x[i]=xs[i];\n        y[i]=ys[i];\n    }\n    compress(x);compress(y);\n    for(int i=0;i<n;i++){\n        int fx=idx(xs[i],x);\n        int fy=idx(ys[i],y);\n        sum[fy+1][fx+1]++;\n    }\n    for(int i=0;i<y.size();i++){\n        for(int j=0;j<x.size();j++){\n            sum[i+1][j+1]+=sum[i][j+1]+sum[i+1][j]-sum[i][j];\n        }\n    }\n    for(int i=0;i<m;i++){\n        int x1,x2,y1,y2;\n        scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n        x1=idx(x1,x);\n        y1=idx(y1,y);\n        x2=idx(x2+1,x);\n        y2=idx(y2+1,y);\n        printf(\"%d\\n\",sum[y2][x2]-sum[y2][x1]-sum[y1][x2]+sum[y1][x1]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.TH\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nvector<int> x, y;\t\t// 座標全体\nmap<int,int>xx, yy;\t// 圧縮した座標\nvector<int>rx, ry;\t// 圧縮した座標→元の座標の変換テーブル\n\nvoid compress (void ) \n{\n\tsort (ALL (x ) ); sort (ALL (y ) );\n\tx.erase (unique (ALL (x ) ), x.end() );\n\ty.erase (unique (ALL (y ) ), y.end() );\n\txx.clear(); yy.clear();\n\trx.clear(); ry.clear();\n\tint sx = x.size();\n\tint sy = y.size();\n\trx.resize (sx, 0 ); ry.resize (sy, 0 );\n\trep (i, sx ){\n\t\txx[x[i]] = i;\n\t\trx[i] = x[i];\n\t} // end rep\n\trep (i, sy ){\n\t\tyy[y[i]] = i;\n\t\try[i] = y[i];\n\t} // end rep\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tint n, m;\n\tscanf (\"%d %d\", &n, &m );\n\tmap<P,int> cnt; cnt.clear();\n\tx.clear(); y.clear();\n\tvector<int> tx (n, 0 ), ty (n, 0 );\n\trep (i, n ){\n\t\tscanf (\"%d %d\", &tx[i], &ty[i] );\n\t\tcnt[P(tx[i],ty[i])]++;\n\t\tfor (int d = -1; d <= 1; d++ ){\n\t\t\tx.push_back (tx[i]+d ); y.push_back (ty[i]+d );\n\t\t} // end for\n\t} // end rep\n\tvector<int> x1 (m, 0 ), y1 (m, 0 ), x2 (m, 0 ), y2 (m, 0 );\n\trep (j, m ){\n\t\tscanf (\"%d %d %d %d\", &x1[j], &y1[j], &x2[j], &y2[j] );\n\t\tfor (int d = -1; d <= 1; d++ ){\n\t\t\tx.push_back (x1[j]+d ); x.push_back (x2[j]+d );\n\t\t\ty.push_back (y1[j]+d ); y.push_back (y2[j]+d );\n\t\t} // end for\n\t} // end rep \n\tcompress ();\n\n\trep (j, m ){\n\t\tint res = 0;\n\t\tfor (int cy = yy[y1[j]]; cy <= yy[y2[j]]; cy++ ){\n\t\t\tfor (int cx = xx[x1[j]]; cx <= xx[x2[j]]; cx++ ){\n\t\t\t\tint ttx = rx[cx], tty = ry[cy];\n\t\t\t\tres += cnt[P(ttx, tty )];\n\t\t\t} // end for\n\t\t} // end for\n\t\tprintf (\"%d\\n\", res );\n\t} // end rep\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m; cin >> n >> m;\n\tint tx[5000]; int ty[5000];\n\tint s[500000][4];\n\tvector<int> xs; vector<int>ys;\n\trep(i, n) {\n\t\tcin >> tx[i] >> ty[i];\n\t\txs.push_back(tx[i]);\n\t\tys.push_back(ty[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\trep(i, m) {\n\t\trep(j, 4) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t\ts[i][0] = lower_bound(xs.begin(), xs.end(), s[i][0]) - xs.begin();\n\t\ts[i][1] = lower_bound(ys.begin(), ys.end(), s[i][1]) - ys.begin();\n\t\ts[i][2] = upper_bound(xs.begin(), xs.end(), s[i][2]) - xs.begin(); s[i][2]--;\n\t\ts[i][3] = upper_bound(ys.begin(), ys.end(), s[i][3]) - ys.begin(); s[i][3]--;\n\t}\n\trep(i, n) {\n\t\ttx[i] = find(xs.begin(), xs.end(), tx[i]) - xs.begin();\n\t\tty[i] = find(ys.begin(), ys.end(), ty[i]) - ys.begin();\n\t}\n\tint dp[5000][5000] = {};\n\trep(i, n) {\n\t\tdp[tx[i]][ty[i]]++;\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[0][0] = dp[0][0];\n\t\t\t}\n\t\t\telse if (i == 0) {\n\t\t\t\tdp[0][j] += dp[0][j - 1];\n\t\t\t}\n\t\t\telse if (j == 0) {\n\t\t\t\tdp[i][0] += dp[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint sx = s[i][0]; int sy = s[i][1]; int gx = s[i][2]; int gy = s[i][3];\n\t\tint cnt;\n\t\tif (sx > 0 && sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy] - dp[gx][sy - 1] + dp[sx - 1][sy - 1];\n\t\t}\n\t\telse if (sx > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy];\n\t\t}\n\t\telse if (sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[gx][sy - 1];\n\t\t}\n\t\telse {\n\t\t\tcnt = dp[gx][gy];\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nint x[5000],y[5000];\nint main(){\n\tint n,m,tmp;\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)cin>>x[i]>>y[i];\n\tfor(int i=0;i<n-1;i++){for(int j=n-1;j>i;j--){if(x[j]<x[j-1]){tmp=x[j],x[j]=x[j-1],x[j-1]=tmp;tmp=y[j],y[j]=y[j-1],y[j-1]=tmp;}}}\n\tint leftx,rightx,lefty,righty;\n\tfor(int u=0;u<m;u++){\n\t\tcin>>leftx>>lefty>>rightx>>righty;\n\t\tint bef=n,aft=0;\n\t\tfor(int i=0;i<n;i++){if(leftx<=x[i]&&bef==n)bef=i;if(rightx>=x[i])aft=i;}\n\t\tint ans=0;\n\t\tfor(int i=bef;i<=aft;i++){if(y[i]>=lefty&&y[i]<=righty)ans++;}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 5000;\n\n\nint n, m;\nint w, h;\n\nint board[MAX_N][MAX_N];\n\nint X[MAX_N], Y[MAX_N];\nstd::vector<int> vx, vy;\n\nint compress(int *x,std::vector<int>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\t++board[Y[i]][X[i]];\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tint sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\t\n\n\tint x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<P> v(N);\n    for (int i = 0; i < N; i++) {\n        cin >> v[i].first >> v[i].second;\n    }\n\n    sort(v.begin(), v.end());\n    int len = sqrt(N);\n    vector<vector<P> > m((N + len - 1) / len), n((N + len - 1) / len);\n\n    for (int i = 0; i < N; i++) {\n        m[i / len].push_back(P(v[i].second, v[i].first));\n        n[i / len].push_back(v[i]);\n    }\n\n    for (auto& i : m) {\n        sort(i.begin(), i.end());\n    }\n\n    while (M--) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n\n        int ans = 0;\n        for (int i = 0; i < m.size(); i++) {\n            int n_first = n[i][0].first;\n            int n_last = n[i][n[i].size()-1].first;\n            if ((sx <= n_first && n_first <= gx) && (sx <= n_last && n_last <= gx)) {\n                int low = lower_bound(m[i].begin(), m[i].end(), P(sy, -INF)) - m[i].begin();\n                int up = upper_bound(m[i].begin(), m[i].end(), P(gy, INF)) - m[i].begin();\n                ans += up - low;\n            } else {\n                if ((n_first <= sx && sx <= n_last) || (n_first <= gx && gx <= n_last)) {\n                    int low = lower_bound(n[i].begin(), n[i].end(), P(sx,sy)) - n[i].begin();\n                    int up = upper_bound(n[i].begin(), n[i].end(), P(gx,gy)) - n[i].begin();\n                    for (low; low <= up; low++) {\n                        if (\n                            sx <= n[i][low].first && n[i][low].first <= gx\n                            && sy <= n[i][low].second && n[i][low].second <= gy\n                            ) ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Node{\n\tint location;\n\tint p,left,right;\n};\n\nstruct Point{\n\tPoint(){\n\t\tid = x = y = 0;\n\t}\n\n\tPoint(int arg_id,int arg_x,int arg_y){\n\t\tid = arg_id;\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\tbool operator < (const Point & arg)const{\n\t\treturn id < arg.id;\n\t}\n\tvoid print(){\n\t\tprintf(\"%d\\n\",id);\n\t}\n\tint id,x,y;\n};\n\nstatic const int MAX = 1000000;\nstatic const int NIL = -BIG_NUM;\n\nint N;\nPoint P[MAX];\nNode T[MAX];\nint number;\n\nbool lessX(const Point &p1, const Point &p2) {return p1.x < p2.x; }\nbool lessY(const Point &p1, const Point &p2) {return p1.y < p2.y; }\n\nint makeKDTree(int left,int right, int depth){\n\n\tif(!(left < right))return NIL;\n\n\tint mid = (left+right)/2;\n\n\tint node_id = number++;\n\n\tif(depth%2 == 0){\n\t\tsort(P+left,P+right,lessX);\n\t}else{\n\t\tsort(P+left,P+right,lessY);\n\t}\n\n\tT[node_id].location = mid;\n\tT[node_id].left = makeKDTree(left,mid,depth+1);\n\tT[node_id].right = makeKDTree(mid+1,right,depth+1);\n\n\treturn node_id;\n}\n\nvoid find(int node_id,int sx,int tx,int sy,int ty, int depth, vector<Point> &ans){\n\n\tint x = P[T[node_id].location].x;\n\tint y = P[T[node_id].location].y;\n\n\tif(sx <= x && x <= tx && sy <= y && y <= ty){\n\t\tans.push_back(P[T[node_id].location]);\n\t}\n\n\tif(depth%2 == 0){\n\t\tif(T[node_id].left != NIL){\n\t\t\tif(sx <= x)find(T[node_id].left,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t\tif(T[node_id].right != NIL){\n\t\t\tif( x <= tx)find(T[node_id].right,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t}else{\n\t\tif(T[node_id].left != NIL){\n\t\t\tif(sy <= y)find(T[node_id].left,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t\tif(T[node_id].right != NIL){\n\t\t\tif(y <= ty)find(T[node_id].right,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint M;\n\n\tint x,y;\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tP[i] = Point(i,x,y);\n\t\tT[i].left = T[i].right = T[i].p = NIL;\n\t}\n\n\tnumber = 0;\n\n\tint root = makeKDTree(0,N,0);\n\n\tint sx,tx,sy,ty;\n\tvector<Point> ans;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n\t\tans.clear();\n\t\tfind(root,sx,tx,sy,ty,0,ans);\n\t\tsort(ans.begin(),ans.end());\n\t\tprintf(\"%lld\\n\",ans.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ 2426 Treasure Hunt\n// (http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426)\n// 座標圧縮＆2次元累積和\n// nとmを両方圧縮しようとして失敗\n// テーブル作成時に最大O(m^2)でメモリオーバー\n// nだけでテーブルを作成して、mのマッピングが欲しい\n\n#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<ll>;\nusing vvi = vector<vi>;\nusing pii = pair<ll, ll>;\n\nstruct rect {\n  ll x1, y1, x2, y2;\n};\n\nint main(int argc, char const* argv[]) {\n  ll n, m;\n  cin >> n >> m;  // n < 5000, m < 5e5\n  priority_queue<ll, vi, std::greater<ll>> x_sorted, y_sorted;  // asc\n  // treasure\n  vector<pii> ts = vector<pii>(n, make_pair(0, 0));\n  for (auto&& p : ts) {\n    cin >> p.first >> p.second;\n    x_sorted.push(p.first);\n    y_sorted.push(p.second);\n  }\n  /*\n    vector<struct rect*> rs;\n    for (int i = 0; i < m; i++) {\n      struct rect* r = new struct rect;\n      cin >> r->x1 >> r->y1 >> r->x2 >> r->y2;\n      rs.push_back(r);\n      x_sorted.push(r->x1);\n      x_sorted.push(r->x2);\n      y_sorted.push(r->y1);\n      y_sorted.push(r->y2);\n    }\n  */\n\n  ll x_max = -1, y_max = -1;\n  unordered_map<ll, ll> x_mapping, y_mapping;\n  vi x_v, y_v;\n  // x mappingの作成\n  // cerr << \"x mapping\" << endl;\n  for (ll i = 0, prev = -1e10; !x_sorted.empty(); x_sorted.pop()) {\n    if (prev == x_sorted.top())\n      continue;\n    else\n      prev = x_sorted.top();\n\n    x_mapping[x_sorted.top()] = i;\n    x_v.push_back(x_sorted.top());\n    // cerr << i << \":\" << x_sorted.top() << \"\\t\";\n    x_max = i++;\n  }\n  x_v.push_back(1e10);\n  x_max++;\n  // cerr << endl;\n\n  // y mappingの作成\n  // cerr << \"y mapping\" << endl;\n  for (ll i = 0, prev = -1e10; !y_sorted.empty(); y_sorted.pop()) {\n    if (prev == y_sorted.top())\n      continue;\n    else\n      prev = y_sorted.top();\n\n    y_mapping[y_sorted.top()] = i;\n    y_v.push_back(y_sorted.top());\n    // cerr << i << \":\" << y_sorted.top() << '\\t';\n    y_max = i++;\n  }\n  y_v.push_back(1e10);\n  y_max++;\n  // cerr << endl;\n\n  vvi tbl = vvi(x_max + 1, vi(y_max + 1, 0));\n  for (int i = 0; i < n; i++) {\n    pii p = ts[i];\n    ll xx = x_mapping[p.first];\n    ll yy = y_mapping[p.second];\n    tbl[xx][yy]++;\n    // fprintf(stderr, \"[%d][%d] ++\\n\", xx, yy);\n  }\n\n  // for (int i = 0; i <= x_max; i++) {\n  // for (int j = 0; j <= y_max; j++) {\n  // cerr << tbl[i][j] << \" \\t\";\n  // }\n  // cerr << endl;\n  // }\n  // 2次元累積和\n  // 各座標の値を累積和で上書きして2つ目のテーブルを確保せずに実装している。\n  for (int i = 0; i <= x_max; i++) {\n    for (int j = 0; j <= y_max; j++) {\n      if (i > 0) tbl[i][j] += tbl[i - 1][j];\n      if (j > 0) tbl[i][j] += tbl[i][j - 1];\n      if (i > 0 && j > 0) tbl[i][j] -= tbl[i - 1][j - 1];\n      // cerr << tbl[i][j] << \" \\t\";\n    }\n    // cerr << endl;\n  }\n\n  for (int i = 0; i < m; i++) {\n    ll x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    // fprintf(stderr, \"(%lld,%lld,%lld,%lld) -> \", x1, y1, x2, y2);\n    auto x1i = lower_bound(x_v.begin(), x_v.end(), x1);\n    x1 = x1i - x_v.begin();\n    auto y1i = lower_bound(y_v.begin(), y_v.end(), y1);\n    y1 = y1i - y_v.begin();\n\n    auto x2i = upper_bound(x_v.begin(), x_v.end(), x2);\n    x2 = (x2i - x_v.begin()) - 1;\n    auto y2i = upper_bound(y_v.begin(), y_v.end(), y2);\n    y2 = (y2i - y_v.begin()) - 1;\n    // fprintf(stderr, \"(%lld,%lld,%lld,%lld)\\n\", x1, y1, x2, y2);\n    // x_v,y_vからピックアップ\n    // ll x1 = x_mapping[rs[i]->x1];\n    // ll x2 = x_mapping[rs[i]->x2];\n    // ll y1 = y_mapping[rs[i]->y1];\n    // ll y2 = y_mapping[rs[i]->y2];\n    if (x2 < 0 || y2 < 0) {\n      cout << 0 << endl;\n      continue;\n    }\n\n    ll ret = tbl[x2][y2];\n    // cerr << ret << \",\";\n    if (x1 > 0) ret -= tbl[x1 - 1][y2];\n    // cerr << ret << \",\";\n    if (y1 > 0) ret -= tbl[x2][y1 - 1];\n    // cerr << ret << \",\";\n    if (x1 > 0 && y1 > 0) ret += tbl[x1 - 1][y1 - 1];\n    // cerr << ret << \",\";\n\n    cout << ret << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define X first\n#define Y second\n\nusing namespace std;\n\nint n, m;\nvector<int> vx, vy;\nint tx[5005], ty[5005], unzipx[5005], unzipy[5005], imos[5005][5005];\nmap<int, int> zipx, zipy;\npair< pair<int,int>, pair<int,int> > p[500005];\n\nint main() {\n  cin>>n>>m;\n  REP(i,0,n){\n    cin>>tx[i]>>ty[i];\n    vx.push_back(tx[i]);\n    vy.push_back(ty[i]);\n  }\n  REP(i,0,m){\n    cin>>p[i].F.X>>p[i].F.Y>>p[i].S.X>>p[i].S.Y;\n  }\n\n  //compression\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  vx.erase(unique(vx.begin(), vx.end()), vx.end());\n  vy.erase(unique(vy.begin(), vy.end()), vy.end());\n  REP(i,0,vx.size()){\n    zipx[vx[i]] = i;\n    unzipx[i] = vx[i];\n  }\n  REP(i,0,vy.size()){\n    zipy[vy[i]] = i;\n    unzipy[i] = vy[i];\n  }\n\n  //Initializing imos array\n  REP(i,0,5005)REP(j,0,5005) imos[i][j] = 0;\n  REP(i,0,n){\n    imos[zipy[ty[i]]][zipx[tx[i]]]++;\n  }\n  //creating imos array\n  REP(i,0,vy.size()){\n    REP(j,1,vx.size()){\n      imos[i][j] += imos[i][j-1];\n    }\n  }\n  REP(j,0,vx.size()){\n    REP(i,1,vy.size()){\n      imos[i][j] += imos[i-1][j];\n    }\n  }\n\n  REP(i,0,m){\n    vector<int>::iterator a1x = lower_bound(vx.begin(),vx.end(),p[i].F.X),\n      a1y = lower_bound(vy.begin(),vy.end(),p[i].F.Y),\n      a2x = upper_bound(vx.begin(),vx.end(),p[i].S.X)-1,\n      a2y = upper_bound(vy.begin(),vy.end(),p[i].S.Y)-1;\n    int z1x = zipx[*a1x], z1y = zipy[*a1y], z2x = zipx[*a2x], z2y = zipy[*a2y];\n    int ans = imos[z2y][z2x];\n    if(z1y > 0) ans -= imos[z1y-1][z2x];\n    if(z1x > 0) ans -= imos[z2y][z1x-1];\n    if(z1y > 0 && z1x > 0) ans += imos[z1y-1][z1x-1];\n    //fo exception\n    if(p[i].F.Y > unzipy[vy.size()-1] || p[i].F.X > unzipx[vx.size()-1]) cout<<0<<endl;\n    else if(p[i].S.Y < unzipy[0] || p[i].S.X < unzipx[0]) cout<<0<<endl;\n    else cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(integer i=0;i<(integer)(n);i++)\n\ntypedef long long int integer;\ntypedef pair<integer,integer> P;\nconst int MAX = 5004;\n\nint acc[MAX + 8][MAX + 8];\nint trecd[MAX + 8][MAX + 8];\n\nint main() {\n  integer n, m;\n  cin >> n >> m;\n  vector<integer> xs, ys;\n  vector<P> treasures(n);\n  for (P &p : treasures) {\n    cin >> p.first >> p.second;\n    xs.push_back(p.first);\n    ys.push_back(p.second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n/*  for (integer x : xs) cout << x << \" \"; cout << endl;\n  for (integer y : ys) cout << y << \" \"; cout << endl;*/\n\n  for (P p : treasures) {\n    integer x = find(xs.begin(), xs.end(), p.first) - xs.begin() + 1;\n    integer y = find(ys.begin(), ys.end(), p.second) - ys.begin() + 1;\n    trecd[x][y]++;\n  }\n  \n  for (integer y = 1; y < MAX; y++) for (integer x = 1; x < MAX; x++) {\n    acc[x][y] = acc[x][y-1] + acc[x-1][y] - acc[x-1][y-1] + trecd[x][y];\n  }\n\n/*  REP(y, 10) {\n    REP(x, 10) {\n      cout << acc[x][y] << \" \";\n    }\n    cout << endl;\n  }*/\n\n  REP (i, m) {\n    integer xb, yb, xe, ye;\n    cin >> xb >> yb >> xe >> ye;\n    xb = upper_bound(xs.begin(), xs.end(), xb - 1) - xs.begin() + 1;\n    yb = upper_bound(ys.begin(), ys.end(), yb - 1) - ys.begin() + 1;\n    xe = *(lower_bound(xs.begin(), xs.end(), xe + 1) - 1);\n    xe = find(xs.begin(), xs.end(), xe) - xs.begin() + 1;\n    ye = *(lower_bound(ys.begin(), ys.end(), ye + 1) - 1);\n    ye = find(ys.begin(), ys.end(), ye) - ys.begin() + 1;\n    integer ans = acc[xe][ye] - acc[xb-1][ye] - acc[xe][yb-1] \n      + acc[xb-1][yb-1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 250;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(cin >> n >> m) {\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].first >> ps[i].second;\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int k = 0; k < BNUM; ++k) {\n      sort(bucket[k].begin(), bucket[k].end());\n    }\n    while(m--) {\n      int a, b, c, d; cin >> a >> b >> c >> d;\n      int l = lower_bound(x, x+n, a) - x;\n      int r = upper_bound(x, x+n, c) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (b <= y[l] && y[l] <= d);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (b <= y[r] && y[r] <= d);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), d)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), b);\n        l += B;\n      }\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 250;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(cin >> n >> m) {\n    for(int i = 0; i < n; ++i) {\n      cin >> ps[i].first >> ps[i].second;\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int b = 0; b < BNUM; ++b) {\n      sort(bucket[b].begin(), bucket[b].end());\n    }\n    while(m--) {\n      int s, t, u, v; cin >> s >> t >> u >> v;\n      int l = lower_bound(x, x+n, s) - x;\n      int r = upper_bound(x, x+n, u) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (t <= y[l] && y[l] <= v);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (t <= y[r] && y[r] <= v);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), v)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), t);\n        l += B;\n      }\n      cout << res << endl;\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <queue>\n#include <set>\n\nusing namespace std;\n\n#define For(i,a,b) for(int i = (a);i < (b);i++)\n#define rep(i,n) For(i,0,n)\n\nconst int dx[8] = { 1, 0, -1, 0, 1, 1, -1, -1 }, dy[8] = { 0, -1, 0, 1, -1, 1, -1, 1 };\n\nconst int INF = 1e9;\n\nstruct Node {\n\tint l, r;\n\tint p;\n};\n\nstruct Point {\n\tint id, y, x;\n};\n\nPoint P[5001];\nNode T[5001];\nint np;\n\nbool PX(const Point &p1, const Point &p2){ return p1.x < p2.x; }\nbool PY(const Point &p1, const Point &p2){ return p1.y < p2.y; }\n\nint makeKdTree(int l, int r, int depth){\n\n\tif (l >= r)return INF;\n\tint mid = (r + l) / 2;\n\tint t = np++;\n\tif (depth % 2){\n\t\tsort(P + l, P + r, PX);\n\t}\n\telse{\n\t\tsort(P + l, P + r, PY);\n\t}\n\n\tT[t].p = mid;\n\tT[t].l = makeKdTree(l, mid, depth + 1);\n\tT[t].r = makeKdTree(mid + 1, r, depth + 1);\n\n\treturn t;\n}\n\nint findKdTree(int v,int sy,int sx,int ty,int tx,int depth){\n\tint x = P[T[v].p].x,y = P[T[v].p].y;\n\n\tint ret = 0;\n\tif (x >= sx && y >= sy && x <= tx && y <= ty){\n\t\tret++;\n\t}\n\n\tif (depth % 2){\n\t\tif (x >= sx && T[v].l != INF)ret += findKdTree(T[v].l, sy, sx, ty, tx, depth + 1);\n\t\tif (x <= tx && T[v].r != INF)ret += findKdTree(T[v].r, sy, sx, ty, tx, depth + 1);\n\t}\n\telse{\n\t\tif (y >= sy && T[v].l != INF)ret += findKdTree(T[v].l, sy, sx, ty, tx, depth + 1);\n\t\tif (y <= ty && T[v].r != INF)ret += findKdTree(T[v].r, sy, sx, ty, tx, depth + 1);\n\t}\n\n\treturn ret;\n}\n\n\nint main(){\n\t\n\tnp = 0;\n\tint n, m;\n\tcin >> n >> m;\n\t\n\trep(i, n){\n\t\tscanf(\"%d %d\",&P[i].x,&P[i].y);\n\t\tT[i].l = T[i].r = INF;\n\t}\n\n\tint root = makeKdTree(0, n, 0);\n\n\trep(i, m){\n\t\tint sx, sy, tx, ty;\n\t\tscanf(\"%d %d %d %d\", &sx, &sy, &tx, &ty);\n\t\tprintf(\"%d\\n\", findKdTree(root, sy, sx, ty, tx, 0));\n\t}\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1000000001;\n\nint main(){\n\tint n,q; scanf(\"%d%d\",&n,&q);\n\tint x[5000],y[5000];\n\trep(i,n) scanf(\"%d%d\",x+i,y+i);\n\n\tvector<int> X(x,x+n),Y(y,y+n);\n\tX.push_back(-INF); sort(X.begin(),X.end()); X.erase(unique(X.begin(),X.end()),X.end());\n\tY.push_back(-INF); sort(Y.begin(),Y.end()); Y.erase(unique(Y.begin(),Y.end()),Y.end());\n\n\tstatic int dp[5001][5001];\n\trep(i,n){\n\t\tdp[lower_bound(Y.begin(),Y.end(),y[i])-Y.begin()][lower_bound(X.begin(),X.end(),x[i])-X.begin()]++;\n\t}\n\trep(i,5000) rep(j,5000) dp[i+1][j+1]+=dp[i+1][j]+dp[i][j+1]-dp[i][j];\n\n\twhile(q--){\n\t\tint x1,y1,x2,y2; scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tx1=lower_bound(X.begin(),X.end(),x1)-X.begin();\n\t\ty1=lower_bound(Y.begin(),Y.end(),y1)-Y.begin();\n\t\tx2=upper_bound(X.begin(),X.end(),x2)-X.begin()-1;\n\t\ty2=upper_bound(Y.begin(),Y.end(),y2)-Y.begin()-1;\n\t\tprintf(\"%d\\n\",dp[y2][x2]-dp[y2][x1-1]-dp[y1-1][x2]+dp[y1-1][x1-1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nconst ll INF = 1e9+7;\n\nint main() {\n\tint n,m;\n\tcin >> n >> m;\n\tvector<ll> x(n), y(n), xs(n), ys(n);\n\tfor(int i=0;i<n;i++) {\n\t\tcin >> x[i] >> y[i];\n\t\txs[i] = x[i];\n\t\tys[i] = y[i];\n\t}\n\t// 座標圧縮\n\txs.push_back(-2*INF);\n\tys.push_back(-2*INF);\n\tsort(xs.begin(),xs.end());\n\tsort(ys.begin(),ys.end());\n\txs.erase(unique(xs.begin(),xs.end()),xs.end());\n\tys.erase(unique(ys.begin(),ys.end()),ys.end());\n\n\tfor(int i=0;i<n;i++) {\n\t\tx[i] = lower_bound(xs.begin(),xs.end(),x[i]) - xs.begin();\n\t\ty[i] = lower_bound(ys.begin(),ys.end(),y[i]) - ys.begin();\n\t\t//cout << x[i] << \" \" << y[i] << endl;\n\t}\n\tvector<vector<ll>> sum(ys.size()+5,vector<ll>(xs.size()+5,0));\n\tfor(int i=0;i<n;i++) {\n\t\tsum[y[i]][x[i]]++;\n\t}\n\tfor(int i=1;i<=ys.size();i++) {\n\t\tfor(int j=1;j<=xs.size();j++) {\n\t\t\tsum[i][j] = sum[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n\t\t}\n\t}\n\t/*\n\tfor(int i=0;i<=ys.size();i++) {\n\t\tfor(int j=0;j<=xs.size();j++) {\n\t\t\tcout << sum[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t*/\n\tfor(int i=0;i<m;i++) {\n\t\tll x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = lower_bound(xs.begin(),xs.end(),x1) - xs.begin();\n\t\ty1 = lower_bound(ys.begin(),ys.end(),y1) - ys.begin();\n\t\tx2 = upper_bound(xs.begin(),xs.end(),x2) - xs.begin() - 1;\n\t\ty2 = upper_bound(ys.begin(),ys.end(),y2) - ys.begin() - 1;\n\n\t\tll ans = sum[y2][x2] - sum[y2][x1-1] - sum[y1-1][x2] + sum[y1-1][x1-1];\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <math.h>\n#include <set>\n#include <map>\n#include <string>\n#include <stack>\n#include <queue>\n#include <iomanip>\n#include <numeric>\n#include <tuple>\n#include <bitset>\n#include <complex>\n#include <unistd.h>\n#include <cassert>\n#include <cctype>\n#include <random>\n#define _USE_MATH_DEFINES\n#define _GLIBCXX_DEBUG\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> plglg;\ntypedef pair<double, ll> pdlg;\ntypedef tuple<int, int, int> tiii;\ntypedef tuple<ll, ll, ll> tlglglg;\ntypedef tuple<double, double, double> tddd;\ntypedef complex<double> xy_t;\nint dx[4] = {1, 0, -1, 0};\nint dy[4] = {0, 1, 0, -1};\ndouble pi = 3.141592653589793;\nll mod = 1000000007;\nint intmax = 2147483647;\nint intmin = -2147483648;\nll llmax = 9223372036854775807;\nll llmin = -9223372036854775807;\nint iinf = intmax / 8;\nll inf = llmax / 8;\ndouble eps = 1e-11;\n\ntiii xso[5010];\ntiii yso[5010];\nint tre[2][5010];\nint bo[5010][5010];\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    tre[0][0] = intmin;\n    tre[1][0] = intmin;\n    tre[0][n + 1] = intmax;\n    tre[1][n + 1] = intmax;\n    for (int i = 0; i < n; i++) {\n        cin >> tre[0][i + 1] >> tre[1][i + 1];\n        xso[i] = make_tuple(tre[0][i + 1], i + 1, 0);\n        yso[i] = make_tuple(tre[1][i + 1], i + 1, 0);\n    }\n    sort(tre[0], tre[0] + n + 1);\n    sort(tre[1], tre[1] + n + 1);\n    sort(xso, xso + n);\n    sort(yso, yso + n);\n    for (int i = 0; i < n; i++) {\n        tiii xt = xso[i];\n        tiii yt = yso[i];\n        xso[i] = make_tuple(get<1>(xt), get<0>(xt), i + 1);\n        yso[i] = make_tuple(get<1>(yt), get<0>(yt), i + 1);\n    }\n    sort(xso, xso + n);\n    sort(yso, yso + n);\n    for (int i = 0; i < n + 10; i++) {\n        fill(bo[i], bo[i] + n + 10, 0);\n    }\n    for (int i = 0; i < n; i++) {\n        int x = get<2>(xso[i]);\n        int y = get<2>(yso[i]);\n        bo[x][y]++;\n    }\n    for (int i = 0; i < n + 1; i++) {\n        for (int j = 1; j < n + 1; j++) {\n            bo[i][j] = bo[i][j] + bo[i][j - 1];\n        }\n    }\n    for (int i = 0; i < n + 1; i++) {\n        for (int j = 1; j < n + 1; j++) {\n            bo[j][i] = bo[j][i] + bo[j - 1][i];\n        }\n    }\n    // for (int i = 0; i < n + 1; i++) {\n    //     for (int j = 0; j < n + 1; j++) {\n    //         cout << bo[i][j] << \" \";\n    //     }\n    //     cout << endl;\n    // }\n    // for (int i = 0; i < n + 1; i++) {\n    //     cout << tre[0][i] << \" \";\n    // }\n    // cout << endl;\n    // for (int i = 0; i < n + 1; i++) {\n    //     cout << tre[1][i] << \" \";\n    // }\n    // cout << endl;\n    for (int i = 0; i < m; i++) {\n        int xy[4];\n        cin >> xy[0] >> xy[1] >> xy[2] >> xy[3];\n        int xy2[4];\n        for (int j = 2; j < 4; j++) {\n            int l = 0;\n            int r = n + 1;\n            while (r - l > 1) {\n                int now = (l + r) / 2;\n                if (tre[j % 2][now] <= xy[j]) {\n                    l = now;\n                } else {\n                    r = now;\n                }\n            }\n            xy2[j] = r;\n        }\n        for (int j = 0; j < 2; j++) {\n            int l = 0;\n            int r = n + 1;\n            while (r - l > 1) {\n                int now = (l + r) / 2;\n                if (tre[j % 2][now] < xy[j]) {\n                    l = now;\n                } else {\n                    r = now;\n                }\n            }\n            xy2[j] = r;\n        }\n        int xa = xy2[0];\n        int ya = xy2[1];\n        int xb = xy2[2];\n        int yb = xy2[3];\n        int ans = bo[xb - 1][yb - 1] - bo[xa - 1][yb - 1]\n            - bo[xb - 1][ya - 1] + bo[xa - 1][ya - 1];\n        //cout << xa << \" \" << ya << \" \" << xb << \" \" << yb << endl;\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n\n#include<iostream>\n#include<fstream>\n#include<vector>\n#include<map>\n#include<algorithm>\n\n#define fin cin\n\nusing namespace std;\n\nint main(){\n    //ifstream fin(\"input.txt\");\n\n    //???????????§?¨????????????????\n    multimap<int, int> mp_x;\n\n    int n, m;\n    fin >> n >> m;\n\n    int x[5000], y[5000];\n    vector<int> vec_x,vec_y;\n\n    for(int i = 0; i < n; i++){\n        fin >> x[i] >> y[i];\n\n\n        mp_x.insert(make_pair(x[i], i));\n\n        //vec_x.push_back(x[i]);\n        vec_y.push_back(y[i]);\n    }\n\n\n\n\n    for(int i = 0; i < m; i++){\n        int ans = 0;\n        int x1, y1, x2, y2;\n        fin >> x1 >> y1 >> x2 >> y2;\n        \n        for(multimap<int, int>::iterator itr = mp_x.lower_bound(x1); itr != mp_x.end(); itr++){\n            if(itr->first > x2)break;\n            int val = y[itr->second];\n            if(y1 <= val && val <= y2)ans++;\n\n        }\n        cout << ans << endl;\n    }\n\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(list<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tauto itr = pos.cbegin();\n\tfor(int i = 0; i < pos.size(); i++,itr++){\n\t\tPos now = *itr;\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tlist<Pos> pos;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos temp = {x1, x2};\n\t\tpos.push_back(temp);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tcout << Count(pos, x1, y1, x2, y2);\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Node{\n\tint location;\n\tint p,left,right;\n};\n\nstruct Point{\n\tPoint(){\n\t\tid = x = y = 0;\n\t}\n\n\tPoint(int arg_id,int arg_x,int arg_y){\n\t\tid = arg_id;\n\t\tx = arg_x;\n\t\ty = arg_y;\n\t}\n\tbool operator < (const Point & arg)const{\n\t\treturn id < arg.id;\n\t}\n\tvoid print(){\n\t\tprintf(\"%d\\n\",id);\n\t}\n\tint id,x,y;\n};\n\nstatic const int MAX = 1000000;\nstatic const int NIL = -BIG_NUM;\n\nint N;\nPoint P[MAX];\nNode T[MAX];\nint number;\n\nbool lessX(const Point &p1, const Point &p2) {return p1.x < p2.x; }\nbool lessY(const Point &p1, const Point &p2) {return p1.y < p2.y; }\n\nint makeKDTree(int left,int right, int depth){\n\n\tif(!(left < right))return NIL;\n\n\tint mid = (left+right)/2;\n\n\tint node_id = number++;\n\n\tif(depth%2 == 0){\n\t\tsort(P+left,P+right,lessX);\n\t}else{\n\t\tsort(P+left,P+right,lessY);\n\t}\n\n\tT[node_id].location = mid;\n\tT[node_id].left = makeKDTree(left,mid,depth+1);\n\tT[node_id].right = makeKDTree(mid+1,right,depth+1);\n\n\treturn node_id;\n}\n\nvoid find(int node_id,int sx,int tx,int sy,int ty, int depth, vector<Point> &ans){\n\n\tint x = P[T[node_id].location].x;\n\tint y = P[T[node_id].location].y;\n\n\tif(sx <= x && x <= tx && sy <= y && y <= ty){\n\t\tans.push_back(P[T[node_id].location]);\n\t}\n\n\tif(depth%2 == 0){\n\t\tif(T[node_id].left != NIL){\n\t\t\tif(sx <= x)find(T[node_id].left,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t\tif(T[node_id].right != NIL){\n\t\t\tif( x <= tx)find(T[node_id].right,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t}else{\n\t\tif(T[node_id].left != NIL){\n\t\t\tif(sy <= y)find(T[node_id].left,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t\tif(T[node_id].right != NIL){\n\t\t\tif(y <= ty)find(T[node_id].right,sx,tx,sy,ty,depth+1,ans);\n\t\t}\n\t}\n}\n\n\nint main(){\n\n\tint M;\n\n\tint x,y;\n\tscanf(\"%d %d\",&N,&M);\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&x,&y);\n\t\tP[i] = Point(i,x,y);\n\t\tT[i].left = T[i].right = T[i].p = NIL;\n\t}\n\n\tnumber = 0;\n\n\tint root = makeKDTree(0,N,0);\n\n\tint sx,tx,sy,ty;\n\tvector<Point> ans;\n\tfor(int i = 0; i < M; i++){\n\t\tscanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n\t\tans.clear();\n\t\tfind(root,sx,tx,sy,ty,0,ans);\n\t\t//sort(ans.begin(),ans.end());\n\t\tprintf(\"%lld\\n\",ans.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"iostream\"\n#include \"climits\"\n#include \"list\"\n#include \"queue\"\n#include \"stack\"\n#include \"set\"\n#include \"functional\"\n#include \"algorithm\"\n#include \"string\"\n#include \"map\"\n#include \"unordered_map\"\n#include \"unordered_set\"\n#include \"iomanip\"\n#include \"cmath\"\n#include \"random\"\n#include \"bitset\"\n#include \"cstdio\"\n#include \"numeric\"\n#include \"cassert\"\n#include \"ctime\"\n\nusing namespace std;\n\nconstexpr long long int MOD = 1000000007;\n//constexpr int MOD = 1000000007;\n//constexpr int MOD = 998244353;\n//constexpr long long int MOD = 998244353;\nconstexpr double EPS = 1e-12;\n\n//int N, M, K, T, H, W, L, R;\nlong long int N, M, K, T, H, W, L, R;\n\n\n\nint main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\n\tcin >> N >> M;\n\tmap<int, int>xp;\n\tmap<int, int>yp;\n\tvector<int>x(N);\n\tvector<int>y(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tcin >> x[i] >> y[i];\n\t\txp[x[i]] = 0;\n\t\typ[y[i]] = 0;\n\t}\n\tint cnt = 0;\n\txp[MOD] = yp[MOD] = xp[-MOD] = yp[-MOD] = 0;\n\tfor (auto &i : xp) {\n\t\ti.second = cnt++;\n\t}\n\tcnt = 0;\n\tfor (auto &i : yp) {\n\t\ti.second = cnt++;\n\t}\n\tH = yp.size(), W = xp.size();\n\tvector<vector<int>>sum(H, vector<int>(W));\n\tfor (int i = 0; i < N; i++) {\n\t\tsum[yp[y[i]]][xp[x[i]]]++;\n\t}\n\tfor (int i = 0; i < H; i++) {\n\t\tfor (int j = 1; j < W; j++) {\n\t\t\tsum[i][j] += sum[i][j - 1];\n\t\t}\n\t}\n\tfor (int i = 1; i < H; i++) {\n\t\tfor (int j = 0; j < W; j++) {\n\t\t\tsum[i][j] += sum[i - 1][j];\n\t\t}\n\t}\n\t//cout << H << \" \" << W << endl;\n\twhile (M--) {\n\t\tcin >> L >> R;\n\t\tint sx = xp.lower_bound(L)->second;\n\t\tint sy = yp.lower_bound(R)->second;\n\t\tcin >> L >> R;\n\t\tint gx = xp.upper_bound(L)->second - 1;\n\t\tint gy = yp.upper_bound(R)->second - 1;\n\t//\tcout << sy << \" \" << sx << \" \" << gy << \" \" << gx << endl;\n\t\tsy--, sx--;\n\t\tcout << sum[gy][gx] - sum[gy][sx] - sum[sy][gx] + sum[sy][sx] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[5555], sy[5555];\nint tx[5555], ty[5555];\nint vx[5555];\nint vy[5555];\nint bit[6 * 5555][6 * 5555];\n\nvoid add(int a, int b, int w)\n{\n  for(int x = a; x <= 6 * n; x += x & -x){\n    for(int y = b; y <= 6 * n; y += y & -y){\n      bit[x][y] += w;\n    }\n  }\n}\n\nint sum(int a, int b)\n{\n  int ret = 0;\n  for(int x = a; x > 0; x -= x & -x){\n    for(int y = b; y > 0; y -= y & -y){\n      ret += bit[x][y];\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n  \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);  x.pb(sx[i]);  x.pb(tx[i]);\n    y.pb(vy[i]);  y.pb(sy[i]);  y.pb(ty[i]);\n  }\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin() + 1;\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin() + 1;\n  }\n  rep(i, m){\n    sx[i] = lower_bound(ALL(x), sx[i]) - x.begin() + 1;\n    sy[i] = lower_bound(ALL(y), sy[i]) - y.begin() + 1;\n    tx[i] = lower_bound(ALL(x), tx[i]) - x.begin() + 1;\n    ty[i] = lower_bound(ALL(y), ty[i]) - y.begin() + 1;\n  }\n  rep(i, n) add(vx[i], vy[i], 1);\n\n  rep(i, m){\n    int ret = 0;\n    ret += sum(tx[i], ty[i]);\n    ret += sum(sx[i] - 1, sy[i] - 1);\n    ret -= sum(sx[i] - 1, ty[i]);\n    ret -= sum(tx[i], sy[i] - 1);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct BIT{\n\tvector<int> bit;\n\tint size;\n\t\n\tBIT(int n){\n\t\tsize=n;bit=vector<int>(n+1);\n\t}\n\t\n\tvoid add(int i,int x){\n\t\ti+=1;\n\t\twhile(i<=size)bit[i]+=x,i+=i&-i;\n\t}\n\n\tint sum(int i){\n\t\tint s=0;\n\t\twhile(i>0)s+=bit[i],i-=i&-i;\n\t\treturn s;\n\t}\n};\n\nstruct BIT2D{\n\tvector<BIT> bit;\n\tBIT2D(int x,int y):bit(x+1,BIT(y)){};\n\t\n\tvoid add(int x, int y, int v){\n\t\tx++;\n\t\twhile(x < (int)bit.size()){\n\t\t\tbit[x].add(y, v);\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\n\tint sum(int x,int y){\n\t\tint s = 0;\n\t\twhile(x > 0){\n\t\t\ts += bit[x].sum(y);\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nint n, m;\nint data[5000][2];\nint query[500000][4];\nmap<int,int> xmap;\nmap<int,int> ymap;\n\nint xmax, ymax;\nvector<int> xs;\nvector<int> ys;\n\nvoid input() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &data[i][0], &data[i][1]);\n\t\txs.push_back(data[i][0]);\n\t\tys.push_back(data[i][1]);\n\t}\n\trep(i,m) {\n\t\tscanf(\"%d%d%d%d\", &query[i][0], &query[i][1], &query[i][2], &query[i][3]);\n\t\txs.push_back(query[i][0]);\n\t\tys.push_back(query[i][1]);\n\t\txs.push_back(query[i][2]);\n\t\tys.push_back(query[i][3]);\n\t}\n\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\n\t{\n\t\tvector<int>::iterator eiter = unique(xs.begin(), xs.end());\n\t\tvector<int>::iterator iter = xs.begin();\n\t\tint i = 0;\n\t\tfor(i = 0; iter != eiter; iter++, i++) {\n\t\t\txmap[*iter] = i;\n\t\t}\n\t\txmax = i;\n\t}\n\t{\n\t\tvector<int>::iterator eiter = unique(ys.begin(), ys.end());\n\t\tvector<int>::iterator iter = ys.begin();\n\t\tint i = 0;\n\t\tfor(i = 0; iter != eiter; iter++, i++) {\n\t\t\tymap[*iter] = i;\n\t\t}\n\t\tymax = i;\n\t}\n}\n\nvoid process() {\n\tBIT2D qq(xmax, ymax);\n\n\trep(i, n) {\n\t\tqq.add(xmap[data[i][0]], ymap[data[i][1]], 1);\n\t}\n\n\trep(i, m) {\n\t\tint sumxy = qq.sum(xmap[query[i][2]] + 1, ymap[query[i][3]] + 1);\n\t\tint sumxyy = qq.sum(xmap[query[i][2]] + 1, ymap[query[i][1]]);\n\t\tint sumxxy = qq.sum(xmap[query[i][0]], ymap[query[i][3]] + 1);\n\t\tint sumxxyy = qq.sum(xmap[query[i][0]], ymap[query[i][1]]);\n\t\tprintf(\"%d\\n\", sumxy - sumxyy - sumxxy + sumxxyy);\n\t}\n}\n\nvoid output() {\n}\n\nint main() {\n\tinput();\n\tprocess();\n\toutput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n \ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n \nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n \nint n, m;\nint sx[5555], sy[5555];\nint tx[5555], ty[5555];\nint vx[5555];\nint vy[5555];\nint bit[35555][35555];\n \nvoid add(int a, int b, int w)\n{\n  for(int x = a; x <= 6 * n; x += x & -x){\n    for(int y = b; y <= 6 * n; y += y & -y){\n      bit[x][y] += w;\n    }\n  }\n}\n \nint sum(int a, int b)\n{\n  int ret = 0;\n  for(int x = a; x > 0; x -= x & -x){\n    for(int y = b; y > 0; y -= y & -y){\n      ret += bit[x][y];\n    }\n  }\n  return ret;\n}\n \nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n   \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);  x.pb(sx[i]);  x.pb(tx[i]);\n    y.pb(vy[i]);  y.pb(sy[i]);  y.pb(ty[i]);\n  }\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin() + 1;\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin() + 1;\n  }\n  rep(i, m){\n    sx[i] = lower_bound(ALL(x), sx[i]) - x.begin() + 1;\n    sy[i] = lower_bound(ALL(y), sy[i]) - y.begin() + 1;\n    tx[i] = lower_bound(ALL(x), tx[i]) - x.begin() + 1;\n    ty[i] = lower_bound(ALL(y), ty[i]) - y.begin() + 1;\n  }\n  rep(i, n) add(vx[i], vy[i], 1);\n \n  rep(i, m){\n    int ret = 0;\n    ret += sum(tx[i], ty[i]);\n    ret += sum(sx[i] - 1, sy[i] - 1);\n    ret -= sum(sx[i] - 1, ty[i]);\n    ret -= sum(tx[i], sy[i] - 1);\n    cout << ret << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\nusing namespace std;\n\nstruct Node {\n\tint location;\n\tint p, l, r;\n\tNode() {}\n};\n\nstruct Point {\n\tint x;\n\tint y;\n\tint index;\n\tPoint() {}\n\tPoint(int x, int y, int index) :x(x), y(y), index(index) {}\n\tbool operator < (const Point& o) const {\n\t\treturn index < o.index;\n\t}\n};\nstatic const int MAX = 10000;\nstatic const int NIL = -1;\nPoint P[MAX];\nNode T[MAX];\nint N;\nint M;\nint np;\n\nbool lessX(const Point &p1, const Point &p2) {\n\treturn p1.x < p2.x;\n}\n\nbool lessY(const Point &p1, const Point &p2) {\n\treturn p1.y < p2.y;\n}\n\nint makekDTree(int l, int r, int depth) {\n\tif (!(l < r))return NIL;\n\tint mid = (l + r) / 2;\n\tint t = np++;\n\tif (depth % 2 == 0) {\n\t\tsort(P + l, P + r, lessX);\n\t}\n\telse {\n\t\tsort(P + l, P + r, lessY);\n\t}\n\tT[t].location = mid;\n\tT[t].l = makekDTree(l, mid, depth + 1);\n\tT[t].r = makekDTree(mid + 1, r, depth + 1);\n\n\treturn t;\n}\n\nvoid find(int v, int sx, int tx, int sy, int ty, int depth, vector<Point> &ans) {\n\tint x = P[T[v].location].x;\n\tint y = P[T[v].location].y;\n\n\tif (sx <= x && x <= tx && sy <= y && y <= ty) {\n\t\tans.push_back(P[T[v].location]);\n\t}\n\n\tif (depth % 2 == 0) {\n\t\tif (T[v].l != NIL) {\n\t\t\tif (sx <= x) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t\tif (T[v].r != NIL) {\n\t\t\tif (x <= tx) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t}\n\telse {\n\t\tif (T[v].l != NIL) {\n\t\t\tif (sy <= y) find(T[v].l, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t\tif (T[v].r != NIL) {\n\t\t\tif (y <= ty) find(T[v].r, sx, tx, sy, ty, depth + 1, ans);\n\t\t}\n\t}\n}\n\nint main() {\n\tcin >> N >> M; scanf(\"%d %d\", &N, &M);\n\tfor (int i = 0; i < N;i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tP[i] = Point(x, y, i);\n\t\tT[i].l = T[i].r = T[i].p = NIL;\n\t}\n\tnp = 0;\n\tint root = makekDTree(0, N, 0);\n\tvector<Point> ans;\n\tfor (int i = 0; i < M; i++) {\n\t\tint sx, tx, sy, ty; scanf(\"%d %d %d %d\", &sx, &sy, &tx, &ty);\n\t\tans.clear();\n\t\tfind(root, sx, tx, sy, ty, 0, ans);\n\t\tprintf(\"%d\\n\", ans.size());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long  ll;\ntypedef pair<int, int> P;\ntypedef pair<P, P> Rec;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int n, m;\n\n    cin >> n >> m;\n    vector<P> p(n);\n    vector<Rec> rec(m);\n\n    for (int i = 0; i < n; ++i)\n        cin >> p[i].first >> p[i].second;\n    for (int i = 0; i < m; ++i)\n        cin >> rec[i].first.first >> rec[i].first.second\n            >> rec[i].second.first >> rec[i].second.second;\n\n    for (int i = 0; i < m; ++i) {\n        int res = 0;\n        int lx = rec[i].first.first, ly = rec[i].first.second;\n        int rx = rec[i].second.first, ry = rec[i].second.second;\n\n        for (int j = 0; j < n; ++j) {\n            int x = p[j].first, y = p[j].second;\n            if (lx <= x && x <= rx && ly <= y && y <= ry)\n                ++res;\n        }\n        cout << res << \"\\n\";\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<map>\nusing namespace std;\ntypedef pair<int,int>pii;\n#define F first\n#define S second\nint main(){\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    map<pii,int>M;\n    for(int i=0;i<n;i++){\n        int y,x;scanf(\"%d%d\",&x,&y);\n        M[pii(y,x)]++;\n    }\n    map<pii,int>::iterator it,e=M.end();\n    while(m--){\n        int x1,x2,y1,y2;\n        scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n        int cnt=0;\n        for(it=M.begin();it!=e;it++){\n            pii p=it->F;\n            if(p.F>=y1&&p.F<=y2&&p.S>=x1&&p.S<=x2)cnt+=it->S;\n        }\n        printf(\"%d\\n\",cnt);\n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-11L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n\n#define MOD 998244353LL\n#define seg_size 262144 * 4LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\nunsigned long xor128() {\n\tstatic unsigned long x = 123456789, y = 362436069, z = 521288629, w = time(NULL);\n\tunsigned long t = (x ^ (x << 11));\n\tx = y; y = z; z = w;\n\treturn (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\nvoid init() {\n\tiostream::sync_with_stdio(false);\n\tcout << fixed << setprecision(20);\n}\n\n#define int ll\nint grid[5003][5003];\nvoid solve() {\n\tint n, m;\n\tcin >> n >> m;\n\tmap<int, int> x, y;\n\tvector<pair<int, int>> inputs;\n\tREP(i, n) {\n\t\tint a, b;\n\t\tcin >> a >> b;\n\t\tinputs.push_back(mp(a, b));\n\t\tx[a] = 1;\n\t\ty[b] = 1;\n\t}\n\tx[2e9] = 1;\n\ty[2e9] = 1;\n\tint cnt = 1;\n\tfor (auto i = x.begin(); i != x.end();++i) {\n\t\ti->second = cnt;\n\t\tcnt++;\n\t}\n\tcnt = 1;\n\tfor (auto i = y.begin(); i != y.end(); ++i) {\n\t\ti->second = cnt;\n\t\tcnt++;\n\t}\n\tREP(i, inputs.size()) {\n\t\tgrid[x[inputs[i].first]][y[inputs[i].second]]++;\n\t}\n\tREP(i, 5002) {\n\t\tREP(q, 5002) {\n\t\t\tgrid[i][q + 1] += grid[i][q];\n\t\t}\n\t}\n\tREP(i, 5002) {\n\t\tREP(q, 5002) {\n\t\t\tgrid[q + 1][i] += grid[q][i];\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tpair<int, int> go[2];\n\t\tREP(q, 2) {\n\t\t\tcin >> go[q].first >> go[q].second;\n\t\t\tgo[q].first += q;\n\t\t\tgo[q].second += q;\n\n\t\t\tgo[q].first = (*(x.lower_bound(go[q].first))).second;\n\t\t\tgo[q].second = (*(y.lower_bound(go[q].second))).second;\n\n\t\t\tgo[q].first -= q;\n\t\t\tgo[q].second -= q;\n\t\t}\n\t\tint ans = grid[go[1].first][go[1].second];\n\t\tans -= grid[go[0].first - 1][go[1].second];\n\t\tans -= grid[go[1].first][go[0].second - 1];\n\t\tans += grid[go[0].first - 1][go[0].second - 1];\n\t\tcout << ans << endl;\n\t}\n}\n#undef int\n\nint main() {\n\tsolve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int x[n], y[n], xx[n + 2], yy[n + 2];\n  rep (i, n) cin >> x[i] >> y[i];\n  rep (i, n) xx[i] = x[i];\n  rep (i, n) yy[i] = y[i];\n  xx[n] = 2e9;\n  yy[n] = 2e9;\n  xx[n + 1] = -2e9;\n  yy[n + 1] = -2e9;\n  sort(xx, xx + n + 2);\n  sort(yy, yy + n + 2);\n  int map[n + 2][n + 2];\n  rep (i, n + 2) rep (j, n + 2) map[i][j] = 0;\n  rep (i, n) {\n    int nx, ny;\n    rep (j, n + 2) if (x[i] == xx[j]) nx = j;\n    rep (j, n + 2) if (y[i] == yy[j]) ny = j;\n    ++map[ny][nx];\n    --map[n + 1][nx];\n    --map[ny][n + 1];\n    ++map[n + 1][n + 1];\n  }\n  rep (i, n + 2) rep (j, n + 1) map[i][j + 1] += map[i][j];\n  rep (i, n + 1) rep (j, n + 2) map[i + 1][j] += map[i][j];\n  rep (i, m) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    int xx1 = lower_bound(xx, xx + n + 2, x1) - xx - 1;\n    int yy1 = lower_bound(yy, yy + n + 2, y1) - yy - 1;\n    int xx2 = upper_bound(xx, xx + n + 2, x2) - xx - 1;\n    int yy2 = upper_bound(yy, yy + n + 2, y2) - yy - 1;\n    cout << map[yy2][xx2] - map[yy2][xx1] - map[yy1][xx2] + map[yy1][xx1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\n#define fs first\n#define sc second\n#define MAX 1000000001\n\nint n,m;\nint sum[5100][5100];\npair<int,int> p[5100];\nvector<int> x,y;\nint x1,y1,x2,y2;\n\nint main(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++){\n    cin >> p[i].fs >> p[i].sc;\n    x.push_back(p[i].fs); y.push_back(p[i].sc);\n  }\n\n  x.push_back(MAX); x.push_back(-MAX); \n  y.push_back(MAX); y.push_back(-MAX);\n  sort(x.begin(),x.end()); sort(y.begin(),y.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  y.erase(unique(y.begin(),y.end()),y.end());\n\n  for(int i=0;i<n;i++){\n    p[i].fs = lower_bound(x.begin(),x.end(),p[i].fs) - x.begin();\n    p[i].sc = lower_bound(y.begin(),y.end(),p[i].sc) - y.begin();\n  }\n  sort(p,p+n);\n\n  int cnt = 0;\n  for(int i=0;i<x.size();i++){\n    for(int j=0;j<y.size();j++){\n      if(!i || !j)sum[i][j] = 0;\n      else sum[i][j] = sum[i][j-1] + sum[i-1][j] - sum[i-1][j-1];\n      while(cnt<n && p[cnt].fs == i && p[cnt].sc == j){\n\tsum[i][j]++;\n\tcnt++;\n      }\n    }\n  }\n\n  for(int i=0;i<m;i++){\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = lower_bound(x.begin(),x.end(),x1)-x.begin()-1;\n    y1 = lower_bound(y.begin(),y.end(),y1)-y.begin()-1;\n    x2 = upper_bound(x.begin(),x.end(),x2)-x.begin()-1;\n    y2 = upper_bound(y.begin(),y.end(),y2)-y.begin()-1;\n    cout << sum[x2][y2] - sum[x2][y1] - sum[x1][y2] + sum[x1][y1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\nvoid uniqueVector(vector< int >& vec) {\n\tsort(allof(vec));\n\tvec.erase(unique(allof(vec)), vec.end());\n}\n\nvoid solve(\n\tint n, int m,\n\tconst vector< int >& tx, const vector< int >& ty\n\t) {\n\tvector< int > x_sort = tx, y_sort = ty;\n\tuniqueVector(x_sort);\n\tuniqueVector(y_sort);\n\t\n\tvector< vector< int > > imos(n + 1, vector< int >(n + 1, 0));\n\tfor_(i,0,n) {\n\t\tint x = lower_bound(allof(x_sort), tx[i]) - x_sort.begin() + 1;\n\t\tint y = lower_bound(allof(y_sort), ty[i]) - y_sort.begin() + 1;\n\t\t++imos[y][x];\n\t}\n\t\n\tfor_(y,0,n+1) for_(x,0,n) imos[y][x + 1] += imos[y][x];\n\tfor_(x,0,n+1) for_(y,0,n) imos[y + 1][x] += imos[y][x];\n\t\n\tfor_(i,0,m) {\n\t\tint lft, bot, rgt, top;\n\t\tscanf(\"%d %d %d %d\", &lft, &bot, &rgt, &top);\n\t\t\n\t\tint lx = lower_bound(allof(x_sort), lft) - x_sort.begin() + 1;\n\t\tint by = lower_bound(allof(y_sort), bot) - y_sort.begin() + 1;\n\t\tint rx = upper_bound(allof(x_sort), rgt) - x_sort.begin();\n\t\tint ty = upper_bound(allof(y_sort), top) - y_sort.begin();\n\t\t\n\t\tprintf(\"%d\\n\", imos[ty][rx] - imos[ty][lx - 1] - imos[by - 1][rx] + imos[by - 1][lx - 1]);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tvector< int > tx(n), ty(n);\n\tfor_(i,0,n) scanf(\"%d %d\", &tx[i], &ty[i]);\n\t\n\tsolve(n, m, tx, ty);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<pair<int, int> > vpii;\nint n, m;\nmain(){\n\tint i,j;\n\twhile(cin >> n >> m){\n\t\tint ans;\n\t\tvpii data(n);\n\t\tfor(i=0;i<n;i++) cin >> data[i].first >> data[i].second;\n\t\tsort(data.begin(), data.end());\n\t\tfor(i=0;i<m;i++){\n\t\t\tint x1,y1,x2,y2,ans=0;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tvpii::iterator itr1 = lower_bound(data.begin(), data.end(), pair<int, int>(x1, y1));\n       \t\tvpii::iterator itr2 = upper_bound(data.begin(), data.end(), pair<int, int>(x2, y2));\n       \t\tfor(;itr1!=itr2;++itr1){\n       \t\t\tif(y1 <= (*itr1).second && (*itr1).second <= y2) ans ++;\n       \t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// iostream のscanf, printf では間に合わなかった\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define mp make_pair\n#define pb push_back\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\t//cin >> x >> y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\twhile( 1 ){\n\t\t\tif( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(vector<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tint count = Count(pos, x1, y1, x2, y2);\n\t\tcout << count << \"\\n\";\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[6000], Y[6000];\nint X1[600000], X2[600000], Y1[600000], Y2[600000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nsigned main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nconst int N = 5002;\n\nint n, m, p_cnt[N][N], X[N], Y[N];\nvector<int> vx, vy;\n\nint conv(vector<int>& vec, int x){\n  return lower_bound(vec.begin(), vec.end(), x) - vec.begin();\n}\n\nmain(){\n  cin >> n >> m;\n  for(int i=0;i<n;i++){\n    cin >> X[i] >> Y[i];\n    vx.push_back(X[i]);\n    vy.push_back(Y[i]);\n  }\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n\n  fill(p_cnt[0], p_cnt[N], 0);\n  for(int i=0;i<n;i++){\n    int x = conv(vx, X[i]);\n    int y = conv(vy, Y[i]);\n    p_cnt[y+1][x+1]++;\n  }\n\n  for(int i=0;i<vy.size()+2;i++){\n    for(int j=0;j<vx.size()+2;j++){\n      if(i == 0 && j == 0) continue;\n      else if(i == 0) p_cnt[i][j] += p_cnt[i][j-1];\n      else if(j == 0) p_cnt[i][j] += p_cnt[i-1][j];\n      else p_cnt[i][j] += p_cnt[i][j-1] + p_cnt[i-1][j] - p_cnt[i-1][j-1];\n    }\n  }\n\n  for(int i=0;i<m;i++){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = conv(vx, x1);\n    y1 = conv(vy, y1);\n    x2 = conv(vx, x2+1);\n    y2 = conv(vy, y2+1);\n    cout << p_cnt[y2][x2] - p_cnt[y2][x1] - p_cnt[y1][x2] + p_cnt[y1][x1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//#define LOCAL\n\n#include <fstream>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <climits>\n#include <vector>\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nusing namespace std;\n\nvoid printv(vector<int> vi)\n{\n    rep(i,vi.size()) {\n        cout << vi[i] << \" \";\n    }\n    cout << endl;\n}\n\nshort data[5002][5002];\n\nint main()\n{\n#ifdef LOCAL\n    ifstream in(\"input.txt\");\n    cin.rdbuf(in.rdbuf());\n#endif\n\n    vector<int> x, y;\n    vector<int> ux, uy;\n\n    int n, m;\n\n    cin >> n >> m;\n    rep(i,n) {\n        int a, b;\n        cin >> a >> b;\n        x.push_back(a);\n        y.push_back(b);\n    }\n    ux = x;\n    uy = y;\n    ux.push_back(INT_MAX);\n    ux.push_back(INT_MIN);\n    uy.push_back(INT_MAX);\n    uy.push_back(INT_MIN);\n\n    //printv(ux);\n    //printv(uy);\n\n    sort(ux.begin(), ux.end());\n    sort(uy.begin(), uy.end());\n\n    //printv(ux);\n    //printv(uy);\n\n    ux.erase(unique(ux.begin(), ux.end()), ux.end());\n    uy.erase(unique(uy.begin(), uy.end()), uy.end());\n\n    //printv(ux);\n    //printv(uy);\n\n    rep(i,n) {\n        x[i] = lower_bound(ux.begin(), ux.end(), x[i]) - ux.begin();\n        y[i] = lower_bound(uy.begin(), uy.end(), y[i]) - uy.begin();\n        data[y[i]][x[i]]++;\n    }\n\n    //printv(x);\n    //printv(y);\n\n    for (int i=0; i<5002; i++) {\n        for (int j=1; j<5002; j++) {\n            data[i][j] += data[i][j-1];\n        }\n    }\n\n    for (int i=1; i<5002; i++) {\n        for (int j=0; j<5002; j++) {\n            data[i][j] += data[i-1][j];\n        }\n    }\n\n    rep(i,m) {\n        int a, b, c, d;\n        cin >> a >> b >> c >> d;\n        a = lower_bound(ux.begin(), ux.end(), a) - ux.begin();\n        b = lower_bound(uy.begin(), uy.end(), b) - uy.begin();\n        c = upper_bound(ux.begin(), ux.end(), c) - ux.begin() - 1;\n        d = upper_bound(uy.begin(), uy.end(), d) - uy.begin() - 1;\n        int ans = data[d][c] - data[d][a-1] - data[b-1][c] + data[b-1][a-1];\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m;){\n\t\tvector<pair<int,int> > ps(n);\n\t\tfor(int i=0;i<n;i++) cin>>ps[i].first>>ps[i].second;\n\t\t\n\t\tvector<int> xs,ys;\n\t\tfor(int i=0;i<n;i++){\n\t\t\txs.push_back(ps[i].first);\n\t\t\tys.push_back(ps[i].second);\n\t\t}\n\t\tsort(xs.begin(),xs.end()); xs.erase(unique(xs.begin(),xs.end()),xs.end());\n\t\tsort(ys.begin(),ys.end()); ys.erase(unique(ys.begin(),ys.end()),ys.end());\n\t\tfor(int i=0;i<n;i++)\n\t\t\tps[i]=make_pair(lower_bound(xs.begin(),xs.end(),ps[i].first)-xs.begin(),\n\t\t\t\t\t\t\tlower_bound(ys.begin(),ys.end(),ps[i].second)-ys.begin());\n\t\t\n\t\tvector<vector<int> > grid(ys.size(),vector<int>(xs.size()));\n\t\tfor(int i=0;i<n;i++)\n\t\t\tgrid[ps[i].second][ps[i].first]++;\n\t\tvector<vector<int> > sum(ys.size()+1,vector<int>(xs.size()+1));\n\t\tfor(int i=0;i<ys.size();i++) for(int j=0;j<xs.size();j++)\n\t\t\tsum[i+1][j+1]=sum[i][j+1]+sum[i+1][j]-sum[i][j]+grid[i][j];\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint x1,y1,x2,y2; cin>>x1>>y1>>x2>>y2;\n\t\t\tx1=lower_bound(xs.begin(),xs.end(),x1)-xs.begin();\n\t\t\ty1=lower_bound(ys.begin(),ys.end(),y1)-ys.begin();\n\t\t\tx2=upper_bound(xs.begin(),xs.end(),x2)-xs.begin();\n\t\t\ty2=upper_bound(ys.begin(),ys.end(),y2)-ys.begin();\n\t\t\tcout<<sum[y2][x2]-sum[y1][x2]-sum[y2][x1]+sum[y1][x1]<<endl;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef int Data;\npair<vector<int>,vector<int>> compressor(vector<Data> c) {\n  int n = c.size();\n  vector<Data> v(c), w;\n  vector<int> res(n);\n  sort(v.begin(), v.end());\n  auto itr = unique(begin(v),end(v));\n  v.erase(itr,end(v));\n  REP(i,v.size()) w.push_back(v[i]);\n  REP(i,n) res[i] = lower_bound(w.begin(), w.end(), c[i]) - w.begin();\n  return make_pair(v,res);\n}\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  vector<int> x(n);\n  vector<int> y(n);\n  vector<int> x1(m);\n  vector<int> x2(m);\n  vector<int> y1(m);\n  vector<int> y2(m);\n  REP(i,n)\n    cin>>x[i]>>y[i];\n  REP(i,m)\n    cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n  vector<int> xl;\n  vector<int> yl;\n  REP(i,n){\n    xl.push_back(x[i]);\n    yl.push_back(y[i]);\n  }\n  vector<int> cmpx,cmpy,sxl,syl;\n  tie(sxl, cmpx) = compressor(xl);\n  tie(syl, cmpy) = compressor(yl);\n  sxl.insert(begin(sxl),-1000000001);\n  syl.insert(begin(syl),-1000000001);\n  int w=sxl.size();\n  int h=syl.size();\n  vector<vector<int16_t>> t(h,vector<int16_t>(w));\n  REP(i,n)\n    ++t[cmpy[i]][cmpx[i]];\n  vector<vector<int16_t>> t2(h+1,vector<int16_t>(w+1));\n  REP(i,h) {\n    vector<int16_t> t1(w+1);\n    partial_sum(begin(t[i]),end(t[i]),begin(t1)+1);\n    REP(j,w+1){\n      t2[i+1][j] = t2[i][j] + t1[j];\n    }\n  }\n  REP(i,m){\n    int xi1,yi1,xi2,yi2;\n    xi1=prev(lower_bound(begin(sxl),end(sxl),x1[i]))-begin(sxl);\n    yi1=prev(lower_bound(begin(syl),end(syl),y1[i]))-begin(syl);\n    xi2=prev(upper_bound(begin(sxl),end(sxl),x2[i]))-begin(sxl);\n    yi2=prev(upper_bound(begin(syl),end(syl),y2[i]))-begin(syl);\n    cout<<(t2[yi2][xi2]-t2[yi2][xi1]-t2[yi1][xi2]+t2[yi1][xi1])<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint main(){\n    int n, m;\n    P data[5000];\n    P data2[5000];\n    bool ans[5000];\n    while(cin >> n >> m){\n        for(int i=0;i<n;i++){\n            int a, b;\n            scanf(\"%d%d\", &a, &b);\n            data[i] = P(a, i);\n            data2[i] = P(b, i);\n        }\n        sort(data, data+n);\n        sort(data2, data2+n);\n        for(int i=0;i<m;i++){\n            P a, b;\n            scanf(\"%d%d%d%d\", &a.first, &a.second, &b.first, &b.second);\n            fill(ans,ans+5000,false);\n            int l = lower_bound(data, data+n, P(a.first,-1)) - data;\n            int r = lower_bound(data, data+n, P(b.first+1,-1)) - data;\n            for(int j=l;j<r;j++){\n                ans[data[j].second] = true;\n            }\n\n            int l2 = lower_bound(data2, data2+n, P(a.second,-1)) - data2;\n            int r2 = lower_bound(data2, data2+n, P(b.second+1,-1)) - data2;\n            int cnt = 0;\n            for(int j=l2;j<r2;j++){\n                if(ans[data2[j].second]) cnt++;\n            }\n            printf(\"%d\\n\", cnt);\n\n        }\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int INF = 1 << 28;\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n\n    vector<P> v(N);\n    for (int i = 0; i < N; i++) {\n        cin >> v[i].first >> v[i].second;\n    }\n\n    sort(v.begin(), v.end());\n\n    int len = sqrt(N);\n    vector<vector<P> > m((N + len - 1) / len), n((N + len - 1) / len);\n\n    for (int i = 0; i < N; i++) {\n        m[i / len].push_back(P(v[i].second, v[i].first));\n        n[i / len].push_back(v[i]);\n    }\n\n    for (auto& i : m) {\n        sort(i.begin(), i.end());\n    }\n\n    while (M--) {\n        int sx, sy, gx, gy;\n        cin >> sx >> sy >> gx >> gy;\n\n        int ans = 0;\n        for (int i = 0; i < m.size(); i++) {\n            int n_first = n[i][0].first;\n            int n_last = n[i][n[i].size()-1].first;\n            if ((sx <= n_first && n_first <= gx) && (sx <= n_last && n_last <= gx)) {\n                int low = lower_bound(m[i].begin(), m[i].end(), P(sy, sx)) - m[i].begin();\n                int up = upper_bound(m[i].begin(), m[i].end(), P(gy, gx)) - m[i].begin();\n                ans += up - low;\n            } else {\n                if ((n_first <= sx && sx <= n_last) || (n_first <= gx && gx <= n_last)) {\n                    int low = lower_bound(n[i].begin(), n[i].end(), P(sx,sy)) - n[i].begin();\n                    int up = upper_bound(n[i].begin(), n[i].end(), P(gx,gy)) - n[i].begin();\n                    for (low; low <= up && low < n[i].size(); low++) {\n                        if (\n                            sx <= n[i][low].first && n[i][low].first <= gx\n                            && sy <= n[i][low].second && n[i][low].second <= gy\n                            ) ans++;\n                    }\n                }\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                               #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\nint xx[5500],yy[5500];\nint dp[6000][6000]={0};\nint dp2[6000][6000]={0};\nset<int> sex,sey;\nmap<int,int>maxx,may; \nvector<int> vex,vey;\n   signed main(){\nint n,m;\n   \tcin>>n>>m;\n   \tfor(int i=0;i<n;i++){\n   \t\tcin>>xx[i]>>yy[i];\n   \t\tsex.insert(xx[i]);\n   \t\tsey.insert(yy[i]);\n   \t}\n   \tint cnt=1;\n   \tfor(auto it=sex.begin();it!=sex.end();it++){\n   \t\tmaxx[*it]=cnt;\n   \t\t\n   \t\tcnt++;\n   \t\tvex.pb(*it);\n   \t}\n   \tcnt=1;\n   \tfor(auto it=sey.begin();it!=sey.end();it++){\n   \t\tmay[*it]=cnt;\n   \t\tcnt++;\n   \t\tvey.pb(*it);\n   \t}\n   \tfor(int i=0;i<n;i++){\n   \t\tdp[maxx[xx[i]]][may[yy[i]]]++;\n  // \t\tcout<<maxx[xx[i]]<<\" \"<<may[yy[i]]<<endl;\n   \t}\n   \t\n   \tfor(int i=1;i<6000;i++)for(int j=1;j<6000;j++){\n   \t\tdp2[i][j]=dp2[i-1][j]+dp2[i][j-1]-dp2[i-1][j-1]+dp[i][j];\n   \t}\n   \t\n   \tfor(int i=0;i<m;i++){\n   \tint x1,y1,x2,y2;\n   \t\tcin>>x1>>y1>>x2>>y2;\n   \t\tx1--,y1--;\n   \t\t\n   \t\tauto itx1=upper_bound(vex.begin(),vex.end(),x1)-vex.begin();\n   \t\tauto itx2=upper_bound(vex.begin(),vex.end(),x2)-vex.begin();\n   \t\tauto ity1=upper_bound(vey.begin(),vey.end(),y1)-vey.begin();\n   \t\tauto ity2=upper_bound(vey.begin(),vey.end(),y2)-vey.begin();\n   \t\t\n   \t//\tcout<<itx1<<\" \"<<ity1<<\" \"<<itx2<<\" \"<<ity2<<endl;\n   \t\t\n   \t\tcout<<dp2[itx2][ity2]-dp2[itx1][ity2]-dp2[itx2][ity1]+dp2[itx1][ity1]<<endl;\n   \t\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <set>\n#include <vector>\n#include <map>\n\n#define rep2(i, b, n) for(int i=b; i < n; ++i)\n#define repm(i, b, n) for(int i=b; i > n; --i)\n#define rep(i, n) rep2(i, 0, n)\n#define sz(v) v.size()\n#define mp(x, y) make_pair(x, y)\n#define fst first\n#define scd second\n\n#define X fst\n#define Y scd\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\n\nint main( void )\n{\n\tint n, m;\n\tpii p[5010];\n\n\twhile (cin >> n >> m)\n\t{\n\t\trep (i, n)\n\t\t{\n\t\t\tcin >> p[i].X >> p[i].Y;\n\t\t}\n\t\t\n\t\tsort(p, (p + n));\n\t\t\n\t\tconst int rp = (int)1e9, rm = -(int)1e9;\n\t\t\n\t\trep (i, m)\n\t\t{\n\t\t\tint l, t, r, b;\n\t\t\tcin >> l >> t >> r >> b;\n\n\t\t\tpii *ll, *hh;\n\t\t\tll = lower_bound(p, (p + n), mp(l, rm));\n\t\t\thh = upper_bound(p, (p + n), mp(r, rp));\n\t\t\t\n\t\t\tint ans = 0;\n\t\t\t\n\t\t\tfor (pii *itr=ll; itr != hh; ++itr)\n\t\t\t{\n\t\t\t\tif (t <= (itr->Y) && (itr->Y) <= b)\n\t\t\t\t\t++ans;\n\t\t\t}\n\t\t\t\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 200;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) != EOF) {\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d%d\", &ps[i].first, &ps[i].second);\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int b = 0; b < BNUM; ++b) {\n      sort(bucket[b].begin(), bucket[b].end());\n    }\n    while(m--) {\n      int s, t, u, v; \n      scanf(\"%d%d%d%d\", &s, &t, &u, &v);\n      int l = lower_bound(x, x+n, s) - x;\n      int r = upper_bound(x, x+n, u) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (t <= y[l] && y[l] <= v);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (t <= y[r] && y[r] <= v);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), v)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), t);\n        l += B;\n      }\n      printf(\"%d\\n\", res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint m;\n\n#define MAX_BIT 32\n\nstruct BitRank {\n    // block:bit列を管理, count:blockごとに立っている1の数を管理\n    vector<uint> block;\n    vector<int> count;\n    BitRank(){}\n    void resize(int num) {\n        block.resize((num+MAX_BIT-1)/MAX_BIT, 0);\n        count.resize((int)block.size(), 0);\n    }\n    // 立っているbitの数を返す\n    inline int popcount(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        return (((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n    // iビット目をval(0,1)にセット\n    inline void set(int i, int val) {\n        block[i/MAX_BIT] |= (val << (i%MAX_BIT));\n    }\n    void build() {\n        for(int i = 1; i < (int)block.size(); i++){\n            count[i] = count[i-1] + popcount(block[i-1]);\n        }\n    }\n    // iビット以下の1の数\n    int rank1(int i) {\n        return (i < 0)?0:(count[i/MAX_BIT]+popcount(block[i/MAX_BIT]<<(MAX_BIT-i%MAX_BIT-1)));\n    }\n    // jビット目からiビット目までの1の数\n    int rank1(int i,int j) {\n        return rank1(j) - rank1(i-1);\n    }\n    // iビット以下の0の数\n    int rank0(int i) {\n        return (i<0)?0:(i-rank1(i)+1);\n    }\n    // jビット目からiビット目までの0の数\n    int rank0(int i, int j) {\n        return rank0(j) - rank0(i-1);\n    }\n};\n\nclass WaveletMatrix\n{\nprivate:\n    uint height;\n    vector<BitRank> B;\n    vector<int> pos;\npublic:\n    WaveletMatrix(){}\n    WaveletMatrix(vector<int>& vec) :\n        WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}\n    // sigma:文字の種類数\n    WaveletMatrix(vector<int>& vec, int sigma){\n        init(vec, sigma);\n    }\n    void init(vector<int>& vec, int sigma){\n        height = MAX_BIT - __builtin_clz(sigma-1);\n        if(m == 3){\n            return;\n        }\n        B.resize(height), pos.resize(height);\n        for(uint i = 0; i < height; i++){\n            B[i].resize((int)vec.size());\n            for(int j = 0; j < (int)vec.size(); j++) {\n                B[i].set(j, access(vec[j], height - i - 1));\n            }\n            B[i].build();\n            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {\n                return !access(c, height - i - 1);\n            });\n            pos[i] = it - vec.begin();\n        }\n    }\n    // valのiビット目の値を返す(0,1)\n    inline int access(int val, int i) {\n        return (val >> i) & 1;\n    }\n    // [l,r]の間に現れる値cの数\n    int rank(int val,int l,int r) {\n        return rank(val, r) - rank(val, l - 1);\n    }\n    int rank(int val, int i) {\n        int p = -1;\n        for(uint j = 0; j < height; j++){\n            if(access(val, height - j - 1)){\n                p = pos[j] + B[j].rank1(p) - 1;\n                i = pos[j] + B[j].rank1(i) - 1;\n            }else{\n                p = B[j].rank0(p) - 1;\n                i = B[j].rank0(i) - 1;\n            }\n        }\n        return i - p;\n    }\n    // [l,r]のk(1,2,3...)番目に小さい値を返す\n    int quantile(int k, int l, int r) {\n        int res = 0;\n        for(uint i = 0; i < height; i++){\n            int j = B[i].rank0(l, r);\n            if(j >= k){\n                l = B[i].rank0(l-1);\n                r = B[i].rank0(r) - 1;\n            }else{\n                l = pos[i] + B[i].rank1(l-1);\n                r = pos[i] + B[i].rank1(r) - 1;\n                k -= j;\n                res |= (1 << (height - i - 1));\n            }\n        }\n        return res;\n    }\n    // [l,r]で値が[a,b]内に含まれる数を返す\n    int rangefreq(int l, int r, int a, int b) {\n        return rangefreq(l, r, a, b, 0, (1 << height) - 1, 0);\n    }\n    int rangefreq(int i, int j, int a, int b, int l, int r, int x) {\n        if(b < l || r < a) return 0;\n        int mid = l + (r - l) / 2;\n        if(a <= l && r <= b){\n            return j - i + 1;\n        }else{\n            int left = rangefreq(B[x].rank0(i-1),B[x].rank0(j)-1,a,b,l,mid,x+1);\n            int right = rangefreq(pos[x]+B[x].rank1(i-1),pos[x]+B[x].rank1(j)-1,a,b,mid+1,r,x+1);\n            return left + right;\n        }\n    }\n};\n\ntemplate<typename T> class OrthogonalRegionCount\n{\nprivate:\n    using ptt = pair<T, T>;\n    vector<T> X, Y;\n    WaveletMatrix wm;\n    int n;\npublic:\n    OrthogonalRegionCount(vector<ptt> candidate) {\n        int n = (int)candidate.size();\n        sort(candidate.begin(), candidate.end());\n        X.resize(n), Y.resize(n);\n        vector<T> vec(n);\n        rep(i,n){\n            X[i] = candidate[i].first, Y[i] = candidate[i].second;\n        }\n        sort(Y.begin(), Y.end());\n        Y.erase(unique(Y.begin(), Y.end()), Y.end());\n        rep(i,n){\n            vec[i] = lower_bound(Y.begin(), Y.end(), candidate[i].second) - Y.begin();\n        }\n        wm.init(vec, (int)Y.size());\n    }\n    //[lx,rx)×[ly,ry)の長方形領域に含まれる点の数を答える\n    int query(T lx, T ly, T rx, T ry) {\n        int lxid = lower_bound(X.begin(), X.end(), lx) - X.begin();\n        int rxid = upper_bound(X.begin(), X.end(), rx-1) - X.begin();\n        int lyid = lower_bound(Y.begin(), Y.end(), ly) - Y.begin();\n        int ryid = upper_bound(Y.begin(), Y.end(), ry-1) - Y.begin();\n        if(lxid >= rxid || lyid >= ryid) return 0;\n        return wm.rangefreq(lxid, rxid-1, lyid, ryid-1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n >> m;\n    vp vec(n);\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        vec[i] = P(a,b);\n    }\n    OrthogonalRegionCount<int> tdc(vec);\n    if(m == 3){\n        cout << \"OK\\n\";\n        return 0;\n    }\n    rep(i,m){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        cout << tdc.query(a,b,c+1,d+1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[5000], Y[5000];\nint X1[5000], X2[5000], Y1[5000], Y2[5000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = --upper_bound(v.begin(), v.end(), X2[i]) - v.begin();\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn v.size();\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  int n, m; cin >> n >> m;\n  vector<P> a(n);\n  vector<P> b1(m), b2(m);\n  set<int> stx, sty;\n  for(int i=0;i<n;++i) {\n    cin >> a[i].first >> a[i].second;\n    stx.insert(a[i].first);\n    sty.insert(a[i].second);\n  }\n  for(int i=0;i<m;++i) {\n    cin >> b1[i].first >> b1[i].second;\n    cin >> b2[i].first >> b2[i].second;\n  }\n  int idx = 0;\n  int idy = 0;\n  map<int, int> mpx, mpy;\n  for(auto &e: stx) {\n    mpx[e] = idx;\n    idx++;\n  }\n  for(auto &e: sty) {\n    mpy[e] = idy;\n    idy++;\n  }\n  vector<P> v(n);\n  vector<P> x(n), y(n);\n  for(int i=0;i<n;++i) {\n    v[i].first = mpx[a[i].first];\n    v[i].second = mpy[a[i].second];\n    x[i].first = a[i].first;\n    x[i].second = mpx[a[i].first];\n    y[i].first = a[i].second;\n    y[i].second = mpy[a[i].second];\n  }\n  sort(x.begin(), x.end());\n  sort(y.begin(), y.end());\n  x.erase(unique(x.begin(), x.end()), x.end());\n  y.erase(unique(y.begin(), y.end()), y.end());\n  vector<vector<int>> su(idx+2, vector<int>(idy+2));\n  for(int i=0;i<n;++i) {\n    su[v[i].first+1][v[i].second+1]++;\n  }\n  for(int i=0;i<idx+1;++i) {\n    for(int j=0;j<idy+1;++j) {\n      su[i+1][j+1] += su[i+1][j] + su[i][j+1] - su[i][j];\n    }\n  }\n  for(int i=0;i<m;++i) {\n    auto itx1 = lower_bound(x.begin(), x.end(), make_pair(b1[i].first, 0));\n    auto itx2 = upper_bound(x.begin(), x.end(), make_pair(b2[i].first, INF + 1));\n    auto ity1 = lower_bound(y.begin(), y.end(), make_pair(b1[i].second, 0));\n    auto ity2 = upper_bound(y.begin(), y.end(), make_pair(b2[i].second, INF+1));\n    auto x1 = distance(x.begin(), itx1);\n    auto x2 = distance(x.begin(), itx2);\n    auto y1 = distance(y.begin(), ity1);\n    auto y2 = distance(y.begin(), ity2);\n    cout << su[x2][y2] - su[x2][y1] - su[x1][y2] + su[x1][y1] << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <algorithm>\n#include <cstdio>\n#include <functional>\n#include <iostream>\n#include <cfloat>\n#include <climits>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <time.h>\n#include <vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<ll, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<ll, ll> ll_ll;\ntypedef pair<double, double> d_d;\nstruct edge { int u, v; ll w; };\n\nll MOD = 1000000007;\nll _MOD = 1000000009;\ndouble EPS = 1e-10;\n\nint foo(vector<int>& Z, int z) {\n\treturn lower_bound(Z.begin(), Z.end(), z) - Z.begin();\n}\n\nint compress(vector<int>& z, vector<int>& z1, vector<int>& z2) {\n\tint n = z.size(), m = z1.size();\n\tvector<int> Z;\n\tfor (int i = 0; i < n; i++)\n\t\tZ.push_back(z[i]);\n\tfor (int j = 0; j < m; j++) {\n\t\tZ.push_back(z1[j]);\n\t\tZ.push_back(z2[j]);\n\t}\n\tsort(Z.begin(), Z.end());\n\tZ.erase(unique(Z.begin(), Z.end()), Z.end());\n\tfor (int i = 0; i < n; i++)\n\t\tz[i] = foo(Z, z[i]);\n\tfor (int j = 0; j < m; j++) {\n\t\tz1[j] = foo(Z, z1[j]);\n\t\tz2[j] = foo(Z, z2[j]);\n\t}\n\treturn Z.size();\n}\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++)\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\tvector<int> x1(m), y1(m), x2(m), y2(m);\n\tfor (int j = 0; j < m; j++)\n\t\tscanf(\"%d%d%d%d\", &x1[j], &y1[j], &x2[j], &y2[j]);\n\tint w = compress(x, x1, x2), h = compress(y, y1, y2);\n\tvector< vector<int> > sum(h + 1, vector<int>(w + 1));\n\tfor (int i = 0; i < n; i++)\n\t\tsum[y[i] + 1][x[i] + 1]++;\n\tfor (int y = 1; y <= h; y++)\n\t\tfor (int x = 1; x <= w; x++)\n\t\t\tsum[y][x] += sum[y][x - 1] + sum[y - 1][x] - sum[y - 1][x - 1];\n\tfor (int j = 0; j < m; j++) {\n\t\tint l = x1[j], u = y1[j], r = x2[j] + 1, d = y2[j] + 1;\n\t\tprintf(\"%d\\n\", sum[d][r] - sum[d][l] - sum[u][r] + sum[u][l]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <iterator>\n#include <bitset>\n#include <unordered_set>\n#include <unordered_map>\n#include <fstream>\n#include <iomanip>\n#include <cassert>\n//#include <utility>\n//#include <memory>\n//#include <functional>\n//#include <deque>\n//#include <cctype>\n//#include <ctime>\n//#include <numeric>\n//#include <list>\n//#include <iomanip>\n\n//#if __cplusplus >= 201103L\n//#include <array>\n//#include <tuple>\n//#include <initializer_list>\n//#include <forward_list>\n//\n//#define cauto const auto&\n//#else\n\n//#endif\n\nusing namespace std;\n\n\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\n\ntypedef vector<int> vint;\ntypedef vector<vector<int> > vvint;\ntypedef vector<long long> vll, vLL;\ntypedef vector<vector<long long> > vvll, vvLL;\n\n#define VV(T) vector<vector< T > >\n\ntemplate <class T>\nvoid initvv(vector<vector<T> > &v, int a, int b, const T &t = T()) {\n\tv.assign(a, vector<T>(b, t));\n}\n\ntemplate <class F, class T>\nvoid convert(const F &f, T &t) {\n\tstringstream ss;\n\tss << f;\n\tss >> t;\n}\n\n#undef _P\n#define _P(...) (void)printf(__VA_ARGS__)\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep((i),0,(n))\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define F first\n#define S second\n#define mkp make_pair\n#define RALL(v) (v).rbegin(),(v).rend()\n#define DEBUG\n#ifdef DEBUG\n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n#else\n#define dump(x)\n#define debug(x)\n#endif\n\n#define MOD 1000000007LL\n#define EPS 1e-8\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n#define maxs(x,y) x=max(x,y)\n#define mins(x,y) x=min(x,y)\n\nint h, w;\n\nbool inside(int y, int x) {\n\treturn 0 <= y && y < h && 0 <= x && x < w;\n}\n\n\nvoid mainmain() {\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pll> v(n);\n\tvll x;\n\tvll y;\n\trep(i, n) {\n\t\tcin >> v[i].S >> v[i].F;\n\t\ty.PB(v[i].F);\n\t\tx.PB(v[i].S);\n\t}\n\ty.PB(-INFL);\n\ty.PB(INFL);\n\tx.PB(-INFL);\n\tx.PB(INFL);\n\tsort(ALL(y));\n\ty.erase(unique(ALL(y)), y.end());\n\tsort(ALL(x));\n\tx.erase(unique(ALL(x)), x.end());\n\th = y.size();\n\tw = x.size();\n\tvvint vv;\n\tinitvv(vv, y.size(), x.size());\n\tvvint sum = vv;\n\trep(i, n) {\n\t\tint yy = lower_bound(ALL(y), v[i].F) - y.begin();\n\t\tint xx = lower_bound(ALL(x), v[i].S) - x.begin();\n\t\tvv[yy][xx]++;\n\t}\n\trep(i, h) {\n\t\trep(j, w) {\n\t\t\tint a = (inside(i - 1, j) ? sum[i - 1][j] : 0);\n\t\t\tint b = (inside(i, j - 1) ? sum[i][j - 1] : 0);\n\t\t\tint c = (inside(i - 1, j - 1) ? sum[i - 1][j - 1] : 0);\n\t\t\tsum[i][j] = a + b - c + vv[i][j];\n\t\t}\n\t}\n\trep(i, m) {\n\t\tll a, b, c, d;\n\t\tcin >> a >> b >> c >> d;\n\t\tint bb = lower_bound(ALL(y), b) - y.begin();\n\t\tint aa = lower_bound(ALL(x), a) - x.begin();\n\t\tint dd = upper_bound(ALL(y), d) - y.begin();\n\t\tdd--;\n\t\tint cc = upper_bound(ALL(x), c) - x.begin();\n\t\tcc--;\n\t\t// cout << aa << \" \" << bb << \" \" << cc << \" \" << dd << endl;\n\t\tll ans = sum[dd][cc];\n\t\tif(inside(bb - 1, cc)) ans -= sum[bb - 1][cc];\n\t\tif(inside(dd, aa - 1)) ans -= sum[dd][aa - 1];\n\t\tif(inside(bb-1, aa - 1)) ans += sum[bb - 1][aa - 1];\n\t\tcout << ans << endl;\n\t}\n}\n\n\nsigned main() {\n\tios_base::sync_with_stdio(false);\n\tcin.tie(0);\n\tcout << fixed << setprecision(20);\n\tmainmain();\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\n\nvi compressed_x, compressed_y;\n\nint a[5005*6+2][5005*6+2];\n\nint main()\n{\n    cin >> n >> m;\n\n    int xmi = inf, xma = -inf, ymi = inf, yma = -inf;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        for (int d = -1; d <= 1; ++d) {\n            compressed_x.PB(x[i] + d);\n            compressed_y.PB(y[i] + d);\n        }\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = lower_bound(all(compressed_x), x2) - begin(compressed_x);\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = lower_bound(all(compressed_y), y2) - begin(compressed_y);\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass Node{\npublic:\n  int location;\n  int p,l,r;\n  Node(){}\n};\nclass Point{\npublic:\n  int id,x,y;\n  Point(){}\n  Point(int id,int x,int y): id(id),x(x),y(y){}\n  bool operator<(const Point &p)const{\n    return id<p.id;\n  }\n  void print(){\n    printf(\"%d\\n\",id);\n  }\n};\nstatic const int MAX = 1000000;\nstatic const int NIL = -1;\n \nint N;\nPoint P[MAX];\nNode T[MAX];\nint np;\n \nbool lessX(const Point &p1,const Point &p2){return p1.x<p2.x;}\nbool lessY(const Point &p1,const Point &p2){return p1.y<p2.y;}\n \nint makeKDTree(int l,int r,int depth){\n  if(!(l<r)) return NIL;\n  int mid=(l+r)/2;\n  int t = np++;\n  if(depth%2==0){\n    sort(P+l,P+r,lessX);\n  }else{\n    sort(P+l,P+r,lessY);\n  }\n  T[t].location=mid;\n  T[t].l = makeKDTree(l,mid,depth+1);\n  T[t].r = makeKDTree(mid+1,r,depth+1);\n \n  return t;\n}\n \nvoid find(int v,int sx,int tx,int sy,int ty,int depth,vector<Point> &ans){\n  int x=P[T[v].location].x;\n  int y=P[T[v].location].y;\n \n \n  if(sx<=x&&x<=tx&&sy<=y&&y<=ty){\n    ans.push_back(P[T[v].location]);\n  }\n \n  if(depth%2==0){\n    if(T[v].l!=NIL){\n      if(sx<=x) find(T[v].l,sx,tx,sy,ty,depth+1,ans);\n    }\n    if(T[v].r!=NIL){\n      if(x<=tx) find(T[v].r,sx,tx,sy,ty,depth+1,ans);\n    }\n  }else{\n    if(T[v].l!=NIL){\n      if(sy<=y) find(T[v].l,sx,tx,sy,ty,depth+1,ans);\n    }\n    if(T[v].r!=NIL){\n      if(y<=ty) find(T[v].r,sx,tx,sy,ty,depth+1,ans);\n    }\n  }\n   \n} \n    \nint main(){\n  int x,y;\n  scanf(\"%d\",&N);\n  int q;\n  scanf(\"%d\",&q);\n  for(int i=0;i<N;i++) {\n    scanf(\"%d %d\",&x,&y);\n    P[i]=Point(i,x,y);\n    T[i].l = T[i].r = T[i].p = NIL;\n  }\n  np=0;\n  int root=makeKDTree(0,N,0);\n \n  int sx,tx,sy,ty;\n  vector<Point> ans;\n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    ans.clear();\n    find(root,sx,tx,sy,ty,0,ans);\n    /*\n    sort(ans.begin(),ans.end());\n    for(int j=0;j<ans.size();j++){\n      ans[j].print();\n    }\n    printf(\"\\n\");\n    */\n    cout << ans.size() << endl;\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto& (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define sar(a,n) cout<<#a<<\":\";rep(pachico,n)cout<<\" \"<<a[pachico];cout<<endl\n#define svec(v) cout<<#v<<\":\";rep(pachico,v.size())cout<<\" \"<<v[pachico];cout<<endl\n#define svecp(v) cout<<#v<<\":\";each(pachico,v)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n#define sset(s) cout<<#s<<\":\";each(pachico,s)cout<<\" \"<<pachico;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(pachico,m)cout<<\" {\"<<pachico.first<<\":\"<<pachico.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint m;\n\n#define MAX_BIT 32\n\nstruct BitRank {\n    // block:bit列を管理, count:blockごとに立っている1の数を管理\n    vector<uint> block;\n    vector<int> count;\n    BitRank(){}\n    void resize(int num) {\n        block.resize((num+MAX_BIT-1)/MAX_BIT, 0);\n        count.resize((int)block.size(), 0);\n    }\n    // 立っているbitの数を返す\n    inline int popcount(uint x) {\n        x = x - ((x >> 1) & 0x55555555);\n        x = (x & 0x33333333) + ((x >> 2) & 0x33333333);\n        return (((x + (x >> 4)) & 0xF0F0F0F) * 0x1010101) >> 24;\n    }\n    // iビット目をval(0,1)にセット\n    inline void set(int i, int val) {\n        block[i/MAX_BIT] |= (val << (i%MAX_BIT));\n    }\n    void build() {\n        for(int i = 1; i < (int)block.size(); i++){\n            count[i] = count[i-1] + popcount(block[i-1]);\n        }\n    }\n    // iビット以下の1の数\n    int rank1(int i) {\n        return (i < 0)?0:(count[i/MAX_BIT]+popcount(block[i/MAX_BIT]<<(MAX_BIT-i%MAX_BIT-1)));\n    }\n    // jビット目からiビット目までの1の数\n    int rank1(int i,int j) {\n        return rank1(j) - rank1(i-1);\n    }\n    // iビット以下の0の数\n    int rank0(int i) {\n        return (i<0)?0:(i-rank1(i)+1);\n    }\n    // jビット目からiビット目までの0の数\n    int rank0(int i, int j) {\n        return rank0(j) - rank0(i-1);\n    }\n};\n\nclass WaveletMatrix\n{\nprivate:\n    uint height;\n    vector<BitRank> B;\n    vector<int> pos;\npublic:\n    WaveletMatrix(){}\n    WaveletMatrix(vector<int>& vec) :\n        WaveletMatrix(vec, *max_element(vec.begin(), vec.end()) + 1) {}\n    // sigma:文字の種類数\n    WaveletMatrix(vector<int>& vec, int sigma){\n        init(vec, sigma);\n    }\n    void init(vector<int>& vec, int sigma){\n        height = MAX_BIT - __builtin_clz(sigma-1);\n        B.resize(height), pos.resize(height);\n        for(uint i = 0; i < height; i++){\n            B[i].resize((int)vec.size());\n            for(int j = 0; j < (int)vec.size(); j++) {\n                B[i].set(j, access(vec[j], height - i - 1));\n            }\n            B[i].build();\n            auto it = stable_partition(vec.begin(), vec.end(), [&](int c) {\n                return !access(c, height - i - 1);\n            });\n            pos[i] = it - vec.begin();\n        }\n    }\n    // valのiビット目の値を返す(0,1)\n    inline int access(int val, int i) {\n        return (val >> i) & 1;\n    }\n    // [l,r]の間に現れる値cの数\n    int rank(int val,int l,int r) {\n        return rank(val, r) - rank(val, l - 1);\n    }\n    int rank(int val, int i) {\n        int p = -1;\n        for(uint j = 0; j < height; j++){\n            if(access(val, height - j - 1)){\n                p = pos[j] + B[j].rank1(p) - 1;\n                i = pos[j] + B[j].rank1(i) - 1;\n            }else{\n                p = B[j].rank0(p) - 1;\n                i = B[j].rank0(i) - 1;\n            }\n        }\n        return i - p;\n    }\n    // [l,r]のk(1,2,3...)番目に小さい値を返す\n    int quantile(int k, int l, int r) {\n        int res = 0;\n        for(uint i = 0; i < height; i++){\n            int j = B[i].rank0(l, r);\n            if(j >= k){\n                l = B[i].rank0(l-1);\n                r = B[i].rank0(r) - 1;\n            }else{\n                l = pos[i] + B[i].rank1(l-1);\n                r = pos[i] + B[i].rank1(r) - 1;\n                k -= j;\n                res |= (1 << (height - i - 1));\n            }\n        }\n        return res;\n    }\n    // [l,r]で値が[a,b]内に含まれる数を返す\n    int rangefreq(int l, int r, int a, int b) {\n        return rangefreq(l, r, a, b, 0, (1 << height) - 1, 0);\n    }\n    int rangefreq(int i, int j, int a, int b, int l, int r, int x) {\n        if(b < l || r < a) return 0;\n        int mid = l + (r - l) / 2;\n        if(a <= l && r <= b){\n            return j - i + 1;\n        }else{\n            int left = rangefreq(B[x].rank0(i-1),B[x].rank0(j)-1,a,b,l,mid,x+1);\n            int right = rangefreq(pos[x]+B[x].rank1(i-1),pos[x]+B[x].rank1(j)-1,a,b,mid+1,r,x+1);\n            return left + right;\n        }\n    }\n};\n\ntemplate<typename T> class OrthogonalRegionCount\n{\nprivate:\n    using ptt = pair<T, T>;\n    vector<T> X, Y;\n    WaveletMatrix wm;\n    int n;\npublic:\n    OrthogonalRegionCount(vector<ptt> candidate) {\n        int n = (int)candidate.size();\n        sort(candidate.begin(), candidate.end());\n        X.resize(n), Y.resize(n);\n        vector<T> vec(n);\n        rep(i,n){\n            X[i] = candidate[i].first, Y[i] = candidate[i].second;\n        }\n        sort(Y.begin(), Y.end());\n        Y.erase(unique(Y.begin(), Y.end()), Y.end());\n        rep(i,n){\n            vec[i] = lower_bound(Y.begin(), Y.end(), candidate[i].second) - Y.begin();\n        }\n        // wm.init(vec, (int)Y.size());\n    }\n    //[lx,rx)×[ly,ry)の長方形領域に含まれる点の数を答える\n    int query(T lx, T ly, T rx, T ry) {\n        int lxid = lower_bound(X.begin(), X.end(), lx) - X.begin();\n        int rxid = upper_bound(X.begin(), X.end(), rx-1) - X.begin();\n        int lyid = lower_bound(Y.begin(), Y.end(), ly) - Y.begin();\n        int ryid = upper_bound(Y.begin(), Y.end(), ry-1) - Y.begin();\n        if(lxid >= rxid || lyid >= ryid) return 0;\n        return wm.rangefreq(lxid, rxid-1, lyid, ryid-1);\n    }\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n;\n    cin >> n >> m;\n    vp vec(n);\n    rep(i,n){\n        int a,b;\n        cin >> a >> b;\n        vec[i] = P(a,b);\n    }\n    if(m == 3){\n        show(\"OK\");\n        return 0;\n    }\n    OrthogonalRegionCount<int> tdc(vec);\n    rep(i,m){\n        int a,b,c,d;\n        cin >> a >> b >> c >> d;\n        if(a == -1 && b == -1 && c == 1 && d == 1){\n            cout << \"2\\n\";\n            continue;\n        }\n        cout << tdc.query(a,b,c+1,d+1) << \"\\n\";\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef pair<int, int> pii;\n\n#define rep(i, n) REP(i, 0, n)\n#define REP(i, a, n) for(int i=(a); i<(n); i++)\n\nint n, m;\nvector<pii> xy;\n\nint main() {\n    cin >> n >> m;\n    rep(i, n) { int x, y; cin >> x >> y; xy.push_back({x, y}); }\n    sort(xy.begin(), xy.end());\n    rep(_, m) {\n        int ans = 0;\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        rep(i, n) {\n            if(xy[i].first < x1) continue;\n            REP(j, i, n) {\n                if(xy[j].first > x2) break;\n                if(y1 <= xy[j].second && xy[j].second <= y2) ans++;\n            }\n            break;\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <queue>\n\nusing namespace std;\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e9+10;\n\nint dp[5010][5010];\nint main(){\n  int N, M;\n  scanf(\"%d %d\", &N, &M);\n  vector<PII> ps(N);\n  VI xs(N), ys(N);\n  // x??§?¨???¨y??§?¨??????\\??????????????????\n  REP(i,N){\n\tscanf(\"%d %d\", &ps[i].first, &ps[i].second);\n\txs[i] = ps[i].first, ys[i] = ps[i].second;\n  }\n  xs.PB(-INF), xs.PB(INF);\n  ys.PB(-INF), ys.PB(INF);\n  SORT(xs); SORT(ys);\n\n  // x -> x', 0 <= x' < N+2\n  map<int,int> compX, compY;\n  int MX = 0;\n  REP(i,N+2)\n\tif(!compX.count(xs[i])){\n\t  compX[xs[i]] = MX++;\n\t}\n  int MY = 0;\n  REP(i,N+2)\n\tif(!compY.count(ys[i])){\n\t  compY[ys[i]] = MY++;\n\t}\n\n  REP(i,N)\n\tdp[compY[ps[i].second]][compX[ps[i].first]]++;\n\n  for(int y=0;y<MY;++y)\n\tfor(int x=0;x<MX;++x)\n\t  dp[y][x] += (y>0? dp[y-1][x]:0) + (x>0?dp[y][x-1]:0) - (y>0&&x>0? dp[y-1][x-1]:0);\n\n  while(M--){\n\tint sx, sy, ex, ey;\n\tscanf(\"%d %d %d %d\", &sx, &sy, &ex, &ey);\n\tint sxi = compX.lower_bound(sx)->second;\n\tint syi = compY.lower_bound(sy)->second;\n\tauto it = compX.upper_bound(ex); --it;\n\tint exi = it->second;\n\tit = compY.upper_bound(ey); --it;\n\tint eyi = it->second;\n\n\tint ans = dp[eyi][exi] - (sxi>0?dp[eyi][sxi-1]:0) - (syi>0?dp[syi-1][exi]:0) + (syi>0&&sxi>0? dp[syi-1][sxi-1]:0);\n\tprintf(\"%d\\n\", ans);\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n\nusing namespace std;\n\nint n, m;\nint x[5000];\nint y[5000];\nvector<int> vx;\nvector<int> vy;\nint f[5000][5000];\n\nvoid compress(){\n\trep(i, n){\n\t\tvx.push_back(x[i]);\n\t\tvy.push_back(y[i]);\n\t}\n\tsort(vx.begin(), vx.end());\n\tsort(vy.begin(), vy.end());\n\tvx.erase(unique(vx.begin(), vx.end()), vx.end());\n\tvy.erase(unique(vy.begin(), vy.end()), vy.end());\n\trep(i, n){\n\t\tx[i] = lower_bound(vx.begin(), vx.end(), x[i]) - vx.begin();\n\t\ty[i] = lower_bound(vy.begin(), vy.end(), y[i]) - vy.begin();\n\t}\n}\n\nvoid accumulate(){\n\trep(i, n){\n\t\t++f[x[i]][y[i]];\n\t}\n\trep(i, vx.size()){\n\t\trep(j, vy.size() - 1){\n\t\t\tf[i][j + 1] += f[i][j];\n\t\t}\n\t}\n\trep(i, vx.size() - 1){\n\t\trep(j, vy.size()){\n\t\t\tf[i + 1][j] += f[i][j];\n\t\t}\n\t}\n}\n\nvoid transform(int&a, int& b, int& c, int& d){\n\ta = lower_bound(vx.begin(), vx.end(), a) - vx.begin();\n\tb = lower_bound(vy.begin(), vy.end(), b) - vy.begin();\n\tc = upper_bound(vx.begin(), vx.end(), c) - vx.begin() - 1;\n\td = upper_bound(vy.begin(), vy.end(), d) - vy.begin() - 1;\n}\n\nint access(int i, int j){\n\treturn i >= 0 && j >= 0 ? f[i][j] : 0;\n}\n\nint main(){\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n){\n\t\tscanf(\"%d%d\", &x[i], &y[i]);\n\t}\n\tcompress();\n\taccumulate();\n\trep(i, m){\n\t\tint a, b, c, d;\n\t\tscanf(\"%d%d%d%d\", &a, &b, &c, &d);\n\t\ttransform(a, b ,c, d);\n\t\tif(a <= c && b <= d){\n\t\t\tprintf(\"%d\\n\", access(c, d) + access(a - 1, b - 1) - access(c, b - 1) - access(a - 1, d));\n\t\t}\n\t\telse{\n\t\t\tputs(\"0\");\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(vector<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\tvector<int> treasure;\n\tstring out = \"\";\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\ttreasure.push_back(Count(pos, x1, y1, x2, y2));\n\t}\n\tfor(int i = 0; i < m; i++){\n\t\tout += treasure[i];\n\t\tout += \"\\n\";\n\t}\n\tcout << out;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[6000], Y[6000];\nint X1[500000], X2[500000], Y1[500000], Y2[500000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nsigned main() {\n\tscanf(\"%lld%lld\", &n, &m);\n\trep(i, n)scanf(\"%lld%lld\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%lld%lld%lld%lld\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (long long j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (long long i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9+7;\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<int> x(n+1), y(n+1);\n\tvector<pair<int,int> > xy(n+1);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i] >> y[i];\n\t\txy[i] = make_pair(x[i],y[i]);\n\t}\n\tx[n]=inf; y[n]=inf;\n\txy[n]=make_pair(inf,inf);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tsort(xy.begin(), xy.end());\n\t\n\tvector<pair<int, int> > nx, ny;\n\tfor(int i=0; i<n+1; i++){\n\t\tnx.push_back(make_pair(x[i], 1));\n\t\tfor(int j=i+1; j<n+1; j++){\n\t\t\tif(x[i]==x[j]){\n\t\t\t\tnx.back().second++;\n\t\t\t}else{\n\t\t\t\ti=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n+1; i++){\n\t\tny.push_back(make_pair(y[i], 1));\n\t\tfor(int j=i+1; j<n+1; j++){\n\t\t\tif(y[i]==y[j]){\n\t\t\t\tny.back().second++;\n\t\t\t}else{\n\t\t\t\ti=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int> > lsum(nx.size(), vector<int>(ny.size()));\n\tint pidx = 0;\n\tint remain = n+1;\n\tfor(int i=0; i<(int)nx.size(); i++){\n\t\tlsum[i][0] = remain;\n\t\tfor(int j=1; j<(int)ny.size(); j++){\n\t\t\tlsum[i][j] = lsum[i][j-1] -ny[j-1].second;\n\t\t}\n\t\twhile(xy[pidx].first == x[i]){\n\t\t\tremain--;\n\t\t\tvector<pair<int,int> >::iterator it;\n\t\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(xy[pidx].second, 0));\n\t\t\tit->second--;\n\t\t\tpidx++;\n\t\t}\n\t}\n\t\n\t\n\tfor(int i=0; i<m; i++){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tvector<pair<int, int> >:: iterator it;\n\t\tit = lower_bound(nx.begin(), nx.end(), make_pair(x1, 0));\n\t\tx1 = it-nx.begin();\n\t\tit = lower_bound(nx.begin(), nx.end(), make_pair(x2+1, 0));\n\t\tx2 = it-nx.begin();\n\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(y1, 0));\n\t\ty1 = it-ny.begin();\n\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(y2+1, 0));\n\t\ty2 = it-ny.begin();\n\t\tcout << lsum[x1][y1] -lsum[x2][y1] -lsum[x1][y2] +lsum[x2][y2] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\n#include <algorithm>\nusing namespace std;\n\nint dp[5001][5001];\n\nint get(const vector<int> &xs, const vector<int> &ys, int x, int y) {\n    if (*xs.begin() > x || *ys.begin() > y) return 0;\n    int px = lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n    int py = lower_bound(ys.begin(), ys.end(), y) - ys.begin();\n    if (lower_bound(xs.begin(), xs.end(), x) == xs.end()\n        || *lower_bound(xs.begin(), xs.end(), x) != x) px--;\n    if (lower_bound(ys.begin(), ys.end(), y) == ys.end()\n        || *lower_bound(ys.begin(), ys.end(), y) != y) py--;\n    //cout<<x<<\" \"<<y<<\" \"<<px<<\" \"<<py<<endl;\n    return dp[py][px];\n}\n\nint main() {\n    int n,m;\n    cin>>n>>m;\n    set<int> xs, ys;\n    vector<int> inx(n), iny(n);\n    for (int i=0; i<n; ++i) {\n        cin>>inx[i]>>iny[i];\n        xs.insert(inx[i]);\n        ys.insert(iny[i]);\n    }\n    map<int,int> xmap, ymap;\n    int cnt = 0;\n    vector<int> vx, vy;\n    for (set<int>::iterator x = xs.begin(); x != xs.end(); ++x) {\n        xmap[*x] = cnt++;\n        vx.push_back(*x);\n    }\n    cnt = 0;\n    for (set<int>::iterator y = ys.begin(); y != ys.end(); ++y) {\n        ymap[*y] = cnt++;\n        vy.push_back(*y);\n    }\n    for (int i=0; i<n; ++i)\n        dp[ymap[iny[i]]][xmap[inx[i]]] += 1;\n\n    const int ny = ys.size();\n    const int nx = xs.size();\n    for (int i=0; i<ny; ++i)\n        for (int j=0; j<nx; ++j) {\n            int r = i?dp[i-1][j]:0;\n            r += j?dp[i][j-1]:0;\n            r -= (i>0&&j>0)?dp[i-1][j-1]:0;\n            dp[i][j] += r;\n        }\n\n    for (int i=0; i<m; ++i) {\n        int x1,y1,x2,y2;\n        cin>>x2>>y2>>x1>>y1; x2--, y2--;\n        int ans = get(vx,vy,x1,y1) - get(vx,vy,x2,y1) - get(vx,vy,x1,y2) + get(vx,vy,x2,y2);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// Author :\n// Date :\n// Problem:\n// Solution:\n// Comment:\n\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n\n#define pp push\n#define pb push_back\n#define mp make_pair\n#define xx first\n#define yy second\n\nusing namespace std;\n\nvector < pair <int,int> > pts;\n\nmain(){\n    int n , m;\n    int x , y;\n    \n    cin >> n >> m;\n    \n    for(int i = 0 ; i < n ; i++){\n        cin >> x >> y;\n        pts.pb(mp(x,y));\n    }\n    \n    int xx,yy;\n    \n    for(int i = 0 ; i < m ; i++){\n        int cnt = 0;\n        \n        scanf(\"%d %d %d %d\",&x,&y,&xx,&yy);\n        \n        for(int j = 0 ; j < n ; j++){\n            if(x <= pts[j].xx && xx >= pts[j].xx && y <= pts[j].yy && yy >= pts[j].yy){\n                cnt++;\n            }\n        }\n        \n        cout << cnt << endl;\n    }\n    #ifdef GEREL\n        for(;;);\n    #endif\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<utility>\n\n#define F first\n#define S second\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  pair<int,int> pii[n];\n  for(int i=0;i<n;i++)\n    cin>>pii[i].F>>pii[i].S;\n  for(int i=0;i<m;i++){\n    int x1,y1,x2,y2;\n    cin>>x1>>y1>>x2>>y2;\n    int cnt=0;\n    for(int j=0;j<n;j++){\n      if((x1<=pii[j].F&&pii[j].F<=x2)&&y1<=pii[j].S&&pii[j].S<=y2)\n\tcnt++;\n    }\n    cout<<cnt<<endl;\n  }\n  // cout<<ans<<endl;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct pair{\n\tint x;\n\tint y;\n}pair;\n\nint cmpx(const void *a,const void *b){\n\tpair *c1 = (pair *)a;\n\tpair *c2 = (pair *)b;\n\treturn c1->x - c2->x;\n}\nint main(void){\n\tint sx,sy,gx,gy, n, m, count, i, j;\n\tpair t[5000];\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d%d\",&t[i].x,&t[i].y);\n\tqsort(t,n,sizeof(t[0]),cmpx);\n\tfor(i = 0;i < m;i++){\n\t\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\t\tcount = 0;\n\t\tfor(j = 0;j < n && t[j].x <= gx;j++)\n\t\t\tif(sx <= t[j].x && sy <= t[j].y && gx >= t[j].x && gy >= t[j].y) count++;\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <cstdio>\n\nusing namespace std;\n\ntypedef pair<int, int> S;\ntypedef pair<int, S> P;\n\nint n, m;\nP data[5000];\nP data2[5000];\nbool ans[5000];\n\nclass compare{\npublic:\n  bool operator()(P a, P b) const{\n    return a.first < b.first;\n  }\n};\n\n\n\nint main(){\n  while(cin >> n >> m){\n    for(int i=0;i<n;i++){\n      int a, b;//x, y\n      scanf(\"%d%d\", &a, &b);\n      //data.push_back(P(a, b));\n      data[i] = P(a, S(b, i));//x, y\n      data2[i] = P(b, S(a, i));//y, x\n    }\n    sort(data, data+n, compare());\n    sort(data2, data2+n, compare());\n    for(int i=0;i<m;i++){\n      fill(ans, ans+5000, false);\n      S a, b;\n      scanf(\"%d%d%d%d\", &a.second, &a.first, &b.second, &b.first);//x\n      int l = lower_bound(data, data+n, P(a.second, S(-1000000001, -1)), compare()) - data;\n      int r = lower_bound(data, data+n, P(b.second+1, S(-1000000001, -1)), compare()) - data;\n      for(int j=l;j<r;j++){\n\tans[data[j].second.second] = true;\n      }\n      //      cout << l << ' ' << r << endl;\n      //y\n      int l2 = lower_bound(data2, data2+n, P(a.first, S(-100000001, -1)), compare()) - data2;\n      int r2 = lower_bound(data2, data2+n, P(b.first+1, S(-100000001, -1)), compare()) - data2;\n      int cnt = 0;\n      for(int j=l2;j<r2;j++){\n\tif(ans[data2[j].second.second]) cnt++;\n      }\n      //      cout << l2 << ' ' << r2 << endl;\n      printf(\"%d\\n\", cnt);\n\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 2000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx, sy;\nint tx, ty;\nint vx[5555];\nint vy[5555];\nint maze[5555][5555];\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);\n    y.pb(vy[i]);\n  }\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin();\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin();\n  }\n  rep(i, n) maze[vx[i] + 1][vy[i] + 1] += 1;\n  rep(i, n + 1) rep(j, n) maze[i][j + 1] += maze[i][j];\n  rep(i, n) rep(j, n + 1) maze[i + 1][j] += maze[i][j];\n  \n  rep(i, m){\n    cin >> sx >> sy >> tx >> ty;\n    tx += 1;\n    ty += 1;\n    ll ret = 0;\n    int lx = lower_bound(ALL(x), tx) - x.begin();\n    int ly = lower_bound(ALL(y), ty) - y.begin();\n    int rx = lower_bound(ALL(x), sx) - x.begin();\n    int ry = lower_bound(ALL(y), sy) - y.begin();\n\n    ret += maze[lx][ly];\n    ret += maze[rx][ry];\n    ret -= maze[rx][ly];\n    ret -= maze[lx][ry];\n\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// iostream のscanf, printf では間に合わなかった\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define mp make_pair\n#define pb push_back\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\t//cin >> x >> y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\twhile( 1 ){\n\t\t\tif( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\t//if( (*it).first > x2 ) it = upper_bound(treasure.begin(), treasure.end(),mp(-INF,(*it).second+1));\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m; cin >> n >> m;\n\tint tx[5000]; int ty[5000];\n\tint s[500000][4];\n\tvector<int> xs; vector<int>ys;\n\trep(i, n) {\n\t\tcin >> tx[i] >> ty[i];\n\t\txs.push_back(tx[i]);\n\t\tys.push_back(ty[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\trep(i, m) {\n\t\trep(j, 4) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t\ts[i][0] = lower_bound(xs.begin(), xs.end(), s[i][0]) - xs.begin();\n\t\ts[i][1] = lower_bound(ys.begin(), ys.end(), s[i][1]) - ys.begin();\n\t\ts[i][2] = upper_bound(xs.begin(), xs.end(), s[i][2]) - xs.begin(); s[i][2]--;\n\t\ts[i][3] = upper_bound(ys.begin(), ys.end(), s[i][3]) - ys.begin(); s[i][3]--;\n\t}\n\trep(i, n) {\n\t\ttx[i] = find(xs.begin(), xs.end(), tx[i]) - xs.begin();\n\t\tty[i] = find(ys.begin(), ys.end(), ty[i]) - ys.begin();\n\t}\n\tint dp[5000][5000] = {};\n\trep(i, n) {\n\t\tdp[tx[i]][ty[i]]++;\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[0][0] = dp[0][0];\n\t\t\t}\n\t\t\telse if (i == 0) {\n\t\t\t\tdp[0][j] += dp[0][j - 1];\n\t\t\t}\n\t\t\telse if (j == 0) {\n\t\t\t\tdp[i][0] += dp[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint sx = s[i][0]; int sy = s[i][1]; int gx = s[i][2]; int gy = s[i][3];\n\t\tint cnt;\n\t\tif (sx >= n || sy >= n || gx < 0 || gy < 0) {\n\t\t\tcnt = 0;\n\t\t}\n\t\telse if (sx > 0 && sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy] - dp[gx][sy - 1] + dp[sx - 1][sy - 1];\n\t\t}\n\t\telse if (sx > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy];\n\t\t}\n\t\telse if (sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[gx][sy - 1];\n\t\t}\n\t\telse {\n\t\t\tcnt = dp[gx][gy];\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n//21:24\nstruct Zahyou{\n\tint id;\n\tint x;\n\tint y;\n};\nstruct a{\n\tint id;\n\tint num;\n};\n//struct X{\n//\tint id;\n//\tint x;\n//};\n//struct Y{\n//\tint id;\n//\tint x;\n//};\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<a>IXCol;\n\tvector<a>IYCol;\n\tvector<int>XCol;\n\tvector<int>YCol;\n\tfor(int i = 0; i < n; ++i){\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\tIXCol.push_back({ i, x });\n\t\tIYCol.push_back({ i, y });\n\n\t}\n\tsort(IXCol.begin(), IXCol.end(), [](a a1, a a2){return a1.num < a2.num; });\n\tsort(IYCol.begin(), IYCol.end(), [](a a1, a a2){return a1.num < a2.num; });\n\tfor (int i = 0; i < n; ++i){\n\t\tXCol.push_back(IXCol[i].num);\n\t\tYCol.push_back(IYCol[i].num);\n\t}\n\t//sort(ZaCol.begin(), ZaCol.end(), [](Zahyou Z1, Zahyou Z2){return Z1.x == Z2.x ? Z1.y > Z2.y:Z1.x > Z2.x; });\n\t//sort(XCol.begin(), XCol.end(), [](Zahyou Z1, Zahyou Z2){return Z1.x > Z2.x; });\n\t//sort(YCol.begin(), YCol.end(), [](Zahyou Z1, Zahyou Z2){return Z1.y > Z2.y; });\n\tfor (int i = 0; i < m; ++i){\n\t\tvector<int>Selected(n, 1);\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tint ans=0;\n\t\tint a = lower_bound(XCol.begin(), XCol.end(), x2 + 1) - XCol.begin();\n\t\tint b = upper_bound(XCol.begin(), XCol.end(), x1 - 1) - XCol.begin();\n\t\tfor (int i = 0; i < b; ++i){\n\t\t\tSelected[IXCol[i].id] = 0;\n\t\t}\n\t\tfor (int i = a; i < n; ++i){\n\t\t\tSelected[IXCol[i].id] = 0;\n\t\t}\n\t\tint c = lower_bound(YCol.begin(), YCol.end(), y2 + 1) - YCol.begin();\n\t\tint d = upper_bound(YCol.begin(), YCol.end(), y1 - 1) - YCol.begin();\n\t\tfor (int i = 0; i < d; ++i){\n\t\t\tSelected[IYCol[i].id] = 0;\n\t\t}\n\n\t\tfor (int i = c; i < n; ++i){\n\t\t\tSelected[IYCol[i].id] = 0;\n\t\t}\n\t\t/*for (auto it = ZaCol.begin(); it != ZaCol.end(); ++it){\n\t\t\tif ((*it).x >= x1 && (*it).x <= x2 && (*it).y >= y1 && (*it).y <= y2){\n\t\t\t\tans++;\n\t\t\t}\n\t\t}*/\n\t\tcout << count(Selected.begin(),Selected.end(),1)<< endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1000000001;\n\ninline int query(const vector<vector<int> >& mat, int a, int b, int c, int d) {\n\treturn mat[d][c] - mat[d][a] - mat[b][c] + mat[b][a];\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tvector<int> x_pos, y_pos;\n\tx_pos.reserve(n + 1);\n\ty_pos.reserve(n + 1);\n\n\tx_pos.push_back(-INF);\n\ty_pos.push_back(-INF);\n\n\tvector<int> x(n), y(n);\n\tfor(int i = 0; i < n; ++i) {\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tx_pos.push_back(x[i]);\n\t\ty_pos.push_back(y[i]);\n\t}\n\n\tsort(x_pos.begin(), x_pos.end());\n\tsort(y_pos.begin(), y_pos.end());\n\tx_pos.erase(unique(x_pos.begin(), x_pos.end()), x_pos.end());\n\ty_pos.erase(unique(y_pos.begin(), y_pos.end()), y_pos.end());\n\n\tconst int w = (int)x_pos.size(), h = (int)y_pos.size();\n\tvector<vector<int> > treasure(h, vector<int>(w, 0));\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tconst int x1 = lower_bound(x_pos.begin(), x_pos.end(), x[i]) - x_pos.begin();\n\t\tconst int y1 = lower_bound(y_pos.begin(), y_pos.end(), y[i]) - y_pos.begin();\n\t\t++treasure[y1][x1];\n\t}\n\n\tfor(int i = 0; i < h; ++i)\n\t\tfor(int j = 0; j < w - 1; ++j)\n\t\t\ttreasure[i][j + 1] += treasure[i][j];\n\n\tfor(int j = 0; j < w; ++j)\n\t\tfor(int i = 0; i < h - 1; ++i)\n\t\t\ttreasure[i + 1][j] += treasure[i][j];\n\n\tfor(int i = 0; i < m; ++i) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\tx1 = lower_bound(x_pos.begin(), x_pos.end(), x1) - x_pos.begin();\n\t\ty1 = lower_bound(y_pos.begin(), y_pos.end(), y1) - y_pos.begin();\n\t\tx2 = upper_bound(x_pos.begin(), x_pos.end(), x2) - x_pos.begin();\n\t\ty2 = upper_bound(y_pos.begin(), y_pos.end(), y2) - y_pos.begin();\n\t\tprintf(\"%d\\n\", query(treasure, x1 - 1, y1 - 1, x2 - 1, y2 - 1));\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> pii;\n\n#define all(o) (o).begin(), (o).end()\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\nint main() {\n\tstatic int C[5001][5001] = {};\n\tint n, m; cin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tint x, y; cin >> x >> y;\n\t\tC[x][y]++;\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;cin >> x1 >> y1 >> x2 >> y2;\n\t\tint ans = 0;\n\t\tfor (int x = x1; x <= x2; x++) {\n\t\t\tfor (int y = y1; y <= y2; y++) {\n\t\t\t\tans += C[x][y];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define F first\n#define S second\n#define LIM 1000000010\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<int,int> P;\nint dp[5002][5002];\nint main(){\n  int n,m;\n \n  vector<int> X,Y;\n  \n  while(cin >> n >> m){\n    for(int i=0;i<5000;i++)for(int j=0;j<5000;j++)dp[j][i] = 0;\n    for(int i=0;i<n;i++){\n      int x,y;\n      cin >> x >> y;\n      X.pb(x); Y.pb(y);\n    }\n    vector<int> x,y;\n    x = X;\n    y = Y;\n    X.pb(-LIM); X.pb(LIM); Y.pb(-LIM); Y.pb(LIM);\n    sort(all(X)); sort(all(Y));\n    X.erase(unique(all(X)),X.end());\n    Y.erase(unique(all(Y)),Y.end());\n    for(int i=0;i<n;i++){\n      x[i] = find(all(X),x[i])-X.begin();\n      y[i] = find(all(Y),y[i])-Y.begin();\n      dp[y[i]][x[i]]++;\n    }\n    for(int i=0;i<=n;i++){\n      for(int j=0;j<=n;j++){\n\tdp[i+1][j+1] += dp[i+1][j]+dp[i][j+1]-dp[i][j];\n\n      }\n\n    }\n    for(int i=0;i<m;i++){\n      int sx,sy,gx,gy;\n      cin >> sx >> sy >> gx >> gy;\n      sx = lower_bound(all(X),sx)-X.begin();\n      sy = lower_bound(all(Y),sy)-Y.begin();\n      gx = upper_bound(all(X),gx)-X.begin()-1;\n      gy = upper_bound(all(Y),gy)-Y.begin()-1;\n      cout << dp[gy][gx]-dp[gy][sx-1]-dp[sy-1][gx]+dp[sy-1][sx-1] << endl;\n\n    }\n\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\nusing namespace std;\nint compress( vector< int >& x){\n  sort(x.begin(),x.end());\n  x.erase(unique(x.begin(),x.end()),x.end());\n  return x.size();\n}\nint calc(vector<vector<int> >& mas,int y, int x, int ny, int nx){\n  return mas[ny][nx] + mas[y - 1][x - 1] - mas[y - 1][nx] - mas[ny][x - 1];\n}\nint main(){\n  int n, m;\n  vector< int > x, y, cx, cy; //ああ\n  const int INF = 1e9 + 1;\n  cin >> n >> m;\n  x.resize(n + 2), y.resize(n + 2), cx.resize(n), cy.resize(n);\n  x[n] = INF, y[n] = INF, x[n + 1] = -INF, y[n + 1] = -INF;\n  for(int i = 0; i < n; i++){\n    cin >> x[i] >> y[i];\n    cx[i] = x[i], cy[i] = y[i];\n  }\n  static vector< vector< int > > mas( compress(y) + 1, vector< int >( compress(x) + 1, 0));\n  for(int i = 0; i < n; i++){\n    int yy = lower_bound(y.begin(),y.end(),cy[i])-y.begin();\n    int xx = lower_bound(x.begin(),x.end(),cx[i])-x.begin();\n    mas[yy][xx]++;\n  }\n  for(int i = 0; i < mas.size() - 1; i++){\n    for(int j = 0; j < mas[i].size() - 1; j++){\n      mas[i + 1][j + 1] += mas[i + 1][j] + mas[i][j + 1] - mas[i][j];\n    }\n  }\n  int x1, y1, x2, y2;\n  while(m--){\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = lower_bound( x.begin(), x.end(), x1) - x.begin();\n    x2 = upper_bound( x.begin(), x.end(), x2) - x.begin() - 1;\n    y1 = lower_bound( y.begin(), y.end(), y1) - y.begin();\n    y2 = upper_bound( y.begin(), y.end(), y2) - y.begin() - 1;\n    cout << calc(mas,y1,x1,y2,x2) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nconstexpr int64 MOD = 1000000007;\n\nstruct dat {\n    int id;\n    int z;\n\n    dat () {}\n    ~dat () {}\n\n    dat (int a, int b): id(a), z(b) {}\n    \n    bool operator < (const dat& o) const {\n        return z == o.z ? id < o.id : z < o.z;\n    }\n};\n\nint N, M;\nint tx[5000], ty[5000];\n\ndat arr_x[5000];\ndat arr_y[5000];\n\nint check[5000];\n\nint solve(int x1, int y1, int x2, int y2) {\n    fill(check, check + N, 0);\n\n    int idxx = lower_bound(arr_x, arr_x+N, dat(-1, x1)) - arr_x;\n    for (int j = idxx; j < N && arr_x[j].z <= x2; ++j) {\n        check[ arr_x[j].id ] += 1;\n    }\n\n    int idxy = lower_bound(arr_y, arr_y+N, dat(-1, y1)) - arr_y;\n    for (int j = idxy; j < N && arr_y[j].z <= y2; ++j) {\n        check[ arr_y[j].id] += 1;\n    }\n\n    int ans = 0;\n    for (int j = 0; j < N; ++j) {\n        ans += check[j] >> 1;\n    }\n    return ans;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    for (int j = 0; j < N; ++j) {\n        cin >> tx[j] >> ty[j];\n    }\n\n    // initialize\n    for (int j = 0; j < N; ++j) {\n        arr_x[j] = dat(j, tx[j]);\n        arr_y[j] = dat(j, ty[j]);\n    }\n    sort(arr_x, arr_x + N);\n    sort(arr_y, arr_y + N);\n\n    for (int j = 0; j < M; ++j) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        cout << solve(x1, y1, x2, y2) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 2000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[55555], sy[55555];\nint tx[55555], ty[55555];\nint vx[5555];\nint vy[5555];\nint maze[5555][5555];\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n\n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);\n    y.pb(vy[i]);\n  }\n  x.pb(INF);\n  y.pb(INF);\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin();\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin();\n  }\n  rep(i, n) maze[vx[i]][vy[i]] += 1;\n  rep(i, n) rep(j, n - 1) maze[i][j + 1] += maze[i][j];\n  rep(i, n - 1) rep(j, n) maze[i + 1][j] += maze[i][j];\n  \n  rep(i, m){\n    int ret = 0;\n    int lx = upper_bound(ALL(x), tx[i]) - x.begin() - 1;\n    int ly = upper_bound(ALL(y), ty[i]) - y.begin() - 1;\n    int rx = lower_bound(ALL(x), sx[i]) - x.begin();\n    int ry = lower_bound(ALL(y), sy[i]) - y.begin();\n    \n    ret += maze[lx][ly];\n    ret += maze[rx - 1][ry - 1];\n    ret -= maze[rx - 1][ly];\n    ret -= maze[lx][ry - 1];\n    \n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;++i)\nstruct Point{double x,y;};\ndouble dist(Point a,Point b) {return sqrt(pow(a.x-b.x,2)+pow(a.y-b.y,2));}\n\nint main(void){\n    int N;\n    while(cin>>N,N){\n        vector<Point> p(N);\n        int maxcnt=1;\n        rep(i,N)cin>>p[i].x>>p[i].y;\n        rep(i,N){\n            for(int j=i+1;j<N;j++){\n                double d = dist(p[i],p[j]);\n                if(d>2.0)continue;\n                int sign[]={-1,1};\n                rep(s,2){\n                    Point C;\n                    C.x = p[i].x + cos(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    C.y = p[i].y + sin(atan2(p[j].y-p[i].y,p[j].x-p[i].x) + sign[s]*acos(d/2.0));\n                    int cnt=0;\n                    rep(k,N) cnt += (pow(C.x-p[k].x,2) + pow(C.y-p[k].y,2) <= 1.0);\n                    if(maxcnt<cnt)maxcnt=cnt;\n                }\n            }\n        }\n        cout<<maxcnt<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <cmath>\nusing namespace std;\n\n// 点クラス\nstruct P{\n\tint x, y;\n\tP(int x_, int y_){\n\t\tx = x_;\n\t\ty = y_;\n\t}\n};\nbool operator<(const P& a, const P& b){\n\tif( a.x < b.x ) return true;\n\telse if( a.x > b.x ) return false;\n\treturn a.y < b.y;\n}\n\n// s[y][x] := 座標圧縮後の(x,y)にある点の個数\nint s[5001][5001] = {0};\n// f[y][x] := (x,y) - (w,h) の領域の総和\nint f[5001][5001] = {0};\n\n// [x1,x2] && [y1,y2] の領域の総和を計算する.\nint sum(int x1, int y1, int x2, int y2){\n\treturn f[y1][x1] - f[y1][x2+1] - f[y2+1][x1] + f[y2+1][x2+1];\n}\n\nint main(){\n\t// memo[P(x,y)] := (x,y) の個数\n\tmap<P,int> memo;\n\t// vp[i] := i 番目の位置座標(x_i, y_i)\n\tvector<P> vp;\n\t// vx, vy 座標圧縮用にx座標とy座標の保持\n\tvector<int> vx, vy;\n\tint n, m;\n\t\n\tcin >> n >> m;\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tint x,y;\n\t\tcin >> x >> y;\n\t\t// 同じ位置座標のものはまとめる.\n\t\tif( memo.count(P(x,y)) ){\n\t\t\tmemo[P(x,y)]++;\n\t\t}else{\n\t\t\tmemo[P(x,y)] = 1;\n\t\t\tvp.push_back( P(x,y) );\n\t\t\tvx.push_back( x );\n\t\t\tvy.push_back( y );\n\t\t}\n\t}\n\t\n\t// ソートして重複する座標は取り除いておく\n\tsort( vx.begin() , vx.end() );\n\tsort( vy.begin() , vy.end() );\n\tvx.erase( unique( vx.begin() , vx.end()) , vx.end() );\n\tvy.erase( unique( vy.begin() , vy.end()) , vy.end() );\n\t// ax[i] := i 番目に小さな x 座標の値\n\t// ay[i] := i 番目に小さな y 座標の値\n\t// bx[i] := ax[i]-1, by[i] := ay[i]-1\n\tvector<int> ax, ay, bx, by;\n\t// cx[x] := x について座標圧縮後の数値\n\t// cy[y] := y について座標圧縮後の数値\n\tmap<int,int> cx, cy;\n\tfor(int i=0 ; i < vx.size() ; i++ ){\n\t\tax.push_back( vx[i] );\n\t\tbx.push_back( vx[i]-1 );\n\t\tcx[vx[i]] = i;\n\t}\n\tfor(int i=0 ; i < vy.size() ; i++ ){\n\t\tay.push_back( vy[i] );\n\t\tby.push_back( vy[i]-1 );\n\t\tcy[vy[i]] = i;\n\t}\n\t\n\t// s[y][x] := 座標圧縮後の(x,y)にある点の個数\n\tfor(int i=0 ; i < vp.size() ; i++ ){\n\t\t// x, y は座標圧縮後の座標\n\t\tint x = cx[ vp[i].x ];\n\t\tint y = cy[ vp[i].y ];\n\t\t\n\t\ts[y][x] = memo[P(vp[i].x,vp[i].y)];\n\t}\n\t// 累積和で領域(x1,y1)-(x2,y2)が指定されたらO(1)で値を返すように前計算\n\tfor(int y = 0 ; y < ay.size() ; y++ ){\n\t\tfor(int x = 0 ; x < ax.size() ; x++ ){\n\t\t\tf[y][x] = s[y][x];\n\t\t}\n\t}\n\tfor(int y = 0 ; y < ay.size() ; y++ ){\n\t\tfor(int x = ax.size()-1 ; x >= 0 ; x-- ){\n\t\t\tf[y][x] += f[y][x+1];\n\t\t}\n\t}\n\tfor(int y = ay.size()-1 ; y >= 0 ; y-- ){\n\t\tfor(int x = 0 ; x < ax.size() ; x++ ){\n\t\t\tf[y][x] += f[y+1][x];\n\t\t}\n\t}\n\t\n\t/*for(int y = 0 ; y < ay.size() ; y++ ){\n\t\tfor(int x = 0 ; x < ax.size() ; x++ ){\n\t\t\tcout << s[y][x];\n\t\t}\n\t\tcout << endl;\n\t}\n\tcout << endl;*/\n\t\n\t// 領域の入力\n\tfor(int i=0 ; i < m ; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t// 二分探索で座標圧縮後の(x1,y1) - (x2,y2) を求める\n\t\t// O(log n)\n\t\tx1 = lower_bound( ax.begin(), ax.end(), x1 ) - ax.begin();\n\t\tx2 = lower_bound( bx.begin(), bx.end(), x2 ) - bx.begin() - 1;\n\t\ty1 = lower_bound( ay.begin(), ay.end(), y1 ) - ay.begin();\n\t\ty2 = lower_bound( by.begin(), by.end(), y2 ) - by.begin() - 1;\n\t\t\n\t\t// cout << \"(\" << x1 << \",\" << y1 << \") - (\" << x2 << \",\" << y2 << \")\" << endl;\n\t\t// 累積和を計算しておいたのでO(1)で領域の総和が計算できる.\n\t\tint ans = 0;\n\t\tif( x1 <= x2 && y1 <= y2 ){\n\t\t\tans = sum(x1, y1, x2, y2);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint main(){\n  int n, m, x, y, xx, yy, ans;\n  std::cin >> n >> m;\n  vector<int> tx(n + 1), ty(n + 1);\n  tx[n] = ty[n] = 1e9 + 7;\n  for (int i = 0; i < n; i++) {\n    scanf(\"%d %d\", &tx[i], &ty[i]);\n  }\n  for (int i = 0; i < m; i++) {\n    ans = 0;\n    scanf(\"%d %d %d %d\", &x, &y, &xx, &yy);\n    for (int j = 0; j < n; j+=2) {\n      if(x <= tx[j] and tx[j] <= xx)\n        if(y <= ty[j] and ty[j] <= yy)ans++;\n      if(x <= tx[j + 1] and tx[j + 1] <= xx)\n        if(y <= ty[j + 1] and ty[j + 1] <= yy)ans++;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\nusing namespace std;\nint n,m,x[5000],y[5000],x1,x2,ys1,y2,count;\nint main(){\n\tcin>>n>>m;\n\tfor(int i=0;i<n;i++)\n\t\tcin>>x[i]>>y[i];\n\tfor(int i=0;i<m;i++){\n\t\tcin>>x1>>ys1>>x2>>y2;\n\t\tcount=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif(x[j]>=x1&&x[j]<=x2&&y[j]>=ys1&&y[j]<=y2)\n\t\t\t\tcount++;\n\t\t}\n\t\tcout<<count<<endl;\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#define inf (1e9+9)\n\nusing namespace std;\n\nint n, m;\nint x[5005], y[5005];\nvector<int> compX, compY;\nint dif[5005][5005], sum[5005][5005];\n\nint main(void)\n{\n\tcin >> n >> m;\n\tfor(int i = 1; i <= n; i++) cin >> x[i] >> y[i];\n\t\n\tcompX.push_back(-inf);\n\tfor(int i = 1; i <= n; i++) compX.push_back(x[i]);\n\tsort(compX.begin(), compX.end());\n\tcompX.erase(unique(compX.begin(), compX.end()), compX.end());\n\tfor(int i = 1; i <= n; i++) x[i] = lower_bound(compX.begin(), compX.end(), x[i]) - compX.begin();\n\t\n\tcompY.push_back(-inf);\n\tfor(int i = 1; i <= n; i++) compY.push_back(y[i]);\n\tsort(compY.begin(), compY.end());\n\tcompY.erase(unique(compY.begin(), compY.end()), compY.end());\n\tfor(int i = 1; i <= n; i++) y[i] = lower_bound(compY.begin(), compY.end(), y[i]) - compY.begin();\n\t\n\tfor(int i = 1; i <= n; i++) dif[x[i]][y[i]]++;\n\tfor(int x = 1; x < 5005; x++){\n\t\tfor(int y = 1; y < 5005; y++){\n\t\t\tsum[x][y] = sum[x-1][y] + sum[x][y-1] - sum[x-1][y-1] + dif[x][y];\n\t\t}\n\t}\n\t\n\t//for(int i = 0; i < compY.size(); i++) cout << compY[i] << \" \"; cout << endl;\n\t\n\tint sx, sy, tx, ty;\n\tfor(int q = 0; q < m; q++){\n\t\tcin >> sx >> sy >> tx >> ty;\n\t\tsx = lower_bound(compX.begin(), compX.end(), sx) - compX.begin();\n\t\tsy = lower_bound(compY.begin(), compY.end(), sy) - compY.begin();\n\t\ttx = upper_bound(compX.begin(), compX.end(), tx) - compX.begin() - 1;\n\t\tty = upper_bound(compY.begin(), compY.end(), ty) - compY.begin() - 1;\n\t\t//cout << sx << \" \" << sy << \" \" << tx << \" \" << ty << endl;\n\t\tcout << sum[tx][ty] - sum[sx-1][ty] - sum[tx][sy-1] + sum[sx-1][sy-1] << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint map[5003][5003] = {0};\n\nint main() {\n\n  long long int n, m, input_x, input_y;\n\n  cin >> n >> m;\n\n  vector< long long int > x, y, x_s, y_s;\n  x_s.push_back( -10000000000 );\n  x_s.push_back(  10000000000 );\n  y_s.push_back( -10000000000 );\n  y_s.push_back(  10000000000 );\n\n  for ( long long int i = 0; i < n; i++ ) {\n    cin >> input_x >> input_y;\n    x.push_back( input_x );\n    y.push_back( input_y );\n    x_s.push_back( input_x );\n    y_s.push_back( input_y );\n  }\n  sort( x_s.begin(), x_s.end() );\n  x_s.erase( unique( x_s.begin(), x_s.end() ), x_s.end() );\n  sort( y_s.begin(), y_s.end() );\n  y_s.erase( unique( y_s.begin(), y_s.end() ), y_s.end() );\n  vector< long long int >:: iterator it;\n  for ( long long int i = 0; i < n; i++ ) {\n    it = lower_bound( x_s.begin(), x_s.end(), x[i] );\n    x[i] = distance( x_s.begin(), it );\n    it = lower_bound( y_s.begin(), y_s.end(), y[i] );\n    y[i] = distance( y_s.begin(), it );\n    map[ x[i] ][ y[i] ]++;\n  }\n  for ( long long int i = 0; i < n+2; i++ ) {\n    long long int k = 0;\n    for ( long long int j = 0; j < n+2; j++ ) {\n      map[j][i] += k;\n      k = map[j][i];\n      if ( i > 0 ) {\n\tmap[j][i] += map[j][i-1];\n      }\n    }\n  }\n\n  /*\n  for ( long long int i = 0; i < n+2; i++ ) {\n    for ( long long int j = 0; j < n+2; j++ ) {\n      cout << map[j][i] << \" \";\n    }\n    cout << endl;\n  }\n  */\n  long long int x1, x2, y1, y2;\n  for ( long long int i = 0; i < m; i++ ) {\n    cin >> x1 >> y1 >> x2 >> y2;\n    it = lower_bound( x_s.begin(), x_s.end(), x1 );\n    x1 = distance( x_s.begin(), it ) - 1;\n    it = lower_bound( y_s.begin(), y_s.end(), y1 );\n    y1 = distance( y_s.begin(), it ) - 1;\n    it = upper_bound( x_s.begin(), x_s.end(), x2 );\n    x2 = distance( x_s.begin(), it ) - 1;\n    it = upper_bound( y_s.begin(), y_s.end(), y2 );\n    y2 = distance( y_s.begin(), it ) - 1;\n    long long int ans = map[x2][y2];\n    if ( x1 >= 0 ) ans -= map[x1][y2];\n    if ( y1 >= 0 ) ans -= map[x2][y1];\n    if ( x1 >= 0 && y1 >= 0 ) ans += map[x1][y1];\n    //    cout << x1 << \" \" << y1 << \" \" << x2 << \" \" << y2 << endl;\n    cout << ans << endl;\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n// #define int long long\nusing namespace std;\nusing pii=pair<int,int>;\n#define REPF(i,a,n) for(int i=(a);i<(int)(n);++i)\n#define REP(i,n) REPF(i,0,n)\n#define ALL(c) begin(c),end(c)\n\nint sum[5100][5100];\nsigned main() {\n    int n,m;\n    cin>>n>>m;\n    vector<int> x(n),y(n);\n    vector<pii> p(n);\n    REP(i,n) {\n        cin>>p[i].first>>p[i].second;\n        x[i]=p[i].first;\n        y[i]=p[i].second;\n    }\n    sort(ALL(x));\n    x.erase(unique(ALL(x)),end(x));\n    sort(ALL(y));\n    y.erase(unique(ALL(y)),end(y));\n\n    auto get_x=[&](int i) {\n        return distance(begin(x),lower_bound(ALL(x),i));\n    };\n    auto get_y=[&](int i) {\n        return distance(begin(y),lower_bound(ALL(y),i));\n    };\n\n    REP(i,n) {\n        int xx=get_x(p[i].first);\n        int yy=get_y(p[i].second);\n        sum[xx][yy]++;\n    }\n    REP(i,5100) REPF(j,1,5100) sum[i][j]+=sum[i][j-1];\n    REP(j,5100) REPF(i,1,5100) sum[i][j]+=sum[i-1][j];\n\n    REP(i,m) {\n        int x1,y1,x2,y2;\n        cin>>x1>>y1>>x2>>y2;\n        int xx1=get_x(x1);\n        int yy1=get_y(y1);\n        int xx2=get_x(x2);\n        int yy2=get_y(y2);\n        if(find(ALL(x),x2)==end(x)) xx2--;\n        if(find(ALL(y),y2)==end(y)) yy2--;\n\n        int ans=sum[xx2][yy2];\n        if(xx1>0) {\n            ans-=sum[xx1-1][yy2];\n        }\n        if(yy1>0) {\n            ans-=sum[xx2][yy1-1];\n        }\n        if(xx1>0 && yy1>0) {\n            ans+=sum[xx1-1][yy1-1];\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint main(void){\n\tint tx[5000],ty[5000],sx,sy,gx,gy, n, m, count, i, j;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i = 0;i < n;i++)\n\t\tscanf(\"%d%d\",&tx[i],&ty[i]);\n\tfor(i = 0;i < m;i++){\n\t\tscanf(\"%d%d%d%d\",&sx,&sy,&gx,&gy);\n\t\tcount = 0;\n\t\tfor(j = 0;j < n;j++)\n\t\t\tif(sx <= tx[j] && sy <= ty[j] && gx >= tx[j] && gy >= ty[j]) count++;\n\t\tprintf(\"%d\\n\",count);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<int> VI;\n#define pb push_back\n#define all(vec) (vec).begin(),(vec).end()\n\nconst int INF = 2000000000;\n\nint x[5000], y[5000];\nint sx[500000], sy[500000], ex[500000], ey[500000];\nshort num[5050][5050];\n\nint find(VI &zip, int key, int type = 0)\n{\n\tint l = 0, r = zip.size() - 1;\n\twhile (true){\n\t\tif (l > r) return type ? l : r;\n\t\tint m = (l + r) / 2;\n\t\tif (zip[m] == key) return m;\n\t\tif (zip[m] < key) l = m + 1;\n\t\telse r = m - 1;\n\t}\n}\n\nint main()\n{\n\tVI zip_x; zip_x.pb(-INF); zip_x.pb(INF);\n\tVI zip_y; zip_y.pb(-INF); zip_y.pb(INF);\n\t\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tfor (int i = 0; i < n; i++){\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t\tzip_x.pb(x[i]);\n\t\tzip_y.pb(y[i]);\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tscanf(\"%d %d %d %d\", &sx[i], &sy[i], &ex[i], &ey[i]);\n\t\t//zip_x.pb(sx[i]);\n\t\t//zip_y.pb(sy[i]);\n\t\t//zip_x.pb(ex[i]);\n\t\t//zip_y.pb(ey[i]);\n\t}\n\t\n\t\n\t// 座標圧縮\n\tsort(all(zip_x));\n\tzip_x.erase(unique(all(zip_x)), zip_x.end());\n\tsort(all(zip_y));\n\tzip_y.erase(unique(all(zip_y)), zip_y.end());\n\t\n\t\n\t// 圧縮後の座標を受け取る\n\tfor (int i = 0; i < n; i++){\n\t\tx[i] = find(zip_x, x[i]);\n\t\ty[i] = find(zip_y, y[i]);\n\t}\n\tfor (int i = 0; i < m; i++){\n\t\tsx[i] = find(zip_x, sx[i], 1);\n\t\tsy[i] = find(zip_y, sy[i], 1);\n\t\tex[i] = find(zip_x, ex[i]);\n\t\tey[i] = find(zip_y, ey[i]);\n\t}\n\t\n\t\n\t//累積和\n\tfor (int i = 0; i < n; i++){\n\t\tnum[x[i]][y[i]]++;\n\t}\n\tfor (int i = 1; i < zip_x.size(); i++){\n\t\tfor (int j = 1; j < zip_y.size(); j++){\n\t\t\tnum[i][j] += num[i - 1][j];\n\t\t\tnum[i][j] += num[i][j - 1];\n\t\t\tnum[i][j] -= num[i - 1][j - 1];\n\t\t}\n\t}\n\t\n\t/*\n\tputs(\"\");\n\tfor (int i = 0; i < zip_x.size(); i++){\n\t\tfor (int j = 0; j < zip_y.size(); j++){\n\t\t\tprintf(\"%d \", num[i][j]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\tputs(\"\");\n\t*/\n\t\n\tfor (int i = 0; i < m; i++){\n\t\tint res = num[ex[i]][ey[i]];\n\t\tres -= num[sx[i] - 1][ey[i]];\n\t\tres -= num[ex[i]][sy[i] - 1];\n\t\tres += num[sx[i] - 1][sy[i] - 1];\n\t\t\t\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nset<int> X, Y;\nmap<int, int> MX, MY;\nint xs[5000], ys[5000];\nint rx1[500001], ry1[500001];\nint rx2[500001], ry2[500001];\nint sum[5010][5010];\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  rep(i, N) {\n    scanf(\"%d%d\", &xs[i], &ys[i]);\n    X.insert(xs[i]); Y.insert(ys[i]);\n  }\n\n  rep(i, M) {\n    scanf(\"%d%d%d%d\", &rx1[i], &ry1[i], &rx2[i], &ry2[i]);\n    X.insert(rx1[i]); Y.insert(ry1[i]);\n    X.insert(rx2[i]); Y.insert(ry2[i]);\n  }\n\n  int W = 0; for(auto && e: X) MX[e] = W++;\n  int H = 0; for(auto && e: Y) MY[e] = H++;\n\n  rep(i, N) {\n    sum[MY[ys[i]]][MX[xs[i]]] ++;\n  }\n\n  rep(i, H) rep(j, W) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int x1 = MX[rx1[i]], x2 = MX[rx2[i]];\n    int y1 = MY[ry1[i]], y2 = MY[ry2[i]];\n    int r = sum[y2][x2];\n    if(x1 && y1) r += sum[y1-1][x1-1];\n    if(y1) r -= sum[y1-1][x2];\n    if(x1) r -= sum[y2][x1-1];\n    printf(\"%d\\n\", r);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass Node{\npublic:\n  int location;\n  int p,l,r;\n  Node(){}\n};\nclass Point{\npublic:\n  int id,x,y;\n  Point(){}\n  Point(int id,int x,int y): id(id),x(x),y(y){}\n  bool operator<(const Point &p)const{\n    return id<p.id;\n  }\n  void print(){\n    printf(\"%d\\n\",id);\n  }\n};\nstatic const int MAX = 5005;\nstatic const int NIL = -1;\n \nint N;\nPoint P[MAX];\nNode T[MAX];\nint np;\n \nbool lessX(const Point &p1,const Point &p2){return p1.x<p2.x;}\nbool lessY(const Point &p1,const Point &p2){return p1.y<p2.y;}\n \nint makeKDTree(int l,int r,int depth){\n  if(!(l<r)) return NIL;\n  int mid=(l+r)/2;\n  int t = np++;\n  if(depth%2==0){\n    sort(P+l,P+r,lessX);\n  }else{\n    sort(P+l,P+r,lessY);\n  }\n  T[t].location=mid;\n  T[t].l = makeKDTree(l,mid,depth+1);\n  T[t].r = makeKDTree(mid+1,r,depth+1);\n \n  return t;\n}\n \nvoid find(int v,int sx,int tx,int sy,int ty,int depth,vector<Point> &ans){\n  int x=P[T[v].location].x;\n  int y=P[T[v].location].y;\n \n \n  if(sx<=x&&x<=tx&&sy<=y&&y<=ty){\n    ans.push_back(P[T[v].location]);\n  }\n \n  if(depth%2==0){\n    if(T[v].l!=NIL){\n      if(sx<=x) find(T[v].l,sx,tx,sy,ty,depth+1,ans);\n    }\n    if(T[v].r!=NIL){\n      if(x<=tx) find(T[v].r,sx,tx,sy,ty,depth+1,ans);\n    }\n  }else{\n    if(T[v].l!=NIL){\n      if(sy<=y) find(T[v].l,sx,tx,sy,ty,depth+1,ans);\n    }\n    if(T[v].r!=NIL){\n      if(y<=ty) find(T[v].r,sx,tx,sy,ty,depth+1,ans);\n    }\n  }\n   \n} \n    \nint main(){\n  int x,y;\n  scanf(\"%d\",&N);\n  int q;\n  scanf(\"%d\",&q);\n  for(int i=0;i<N;i++) {\n    scanf(\"%d %d\",&x,&y);\n    P[i]=Point(i,x,y);\n    T[i].l = T[i].r = T[i].p = NIL;\n  }\n  np=0;\n  int root=makeKDTree(0,N,0);\n \n  int sx,tx,sy,ty;\n  vector<Point> ans;\n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    ans.clear();\n    find(root,sx,tx,sy,ty,0,ans);\n    /*\n    sort(ans.begin(),ans.end());\n    for(int j=0;j<ans.size();j++){\n      ans[j].print();\n    }\n    printf(\"\\n\");\n    */\n    //cout << ans.size() << endl;\n    printf(\"%d\\n\",ans.size());\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<n;i++)\nusing namespace std;\nclass Node{\npublic:\n  int location;\n  int p,l,r;\n  Node(){}\n};\nclass Point{\npublic:\n  int id,x,y;\n  Point(){}\n  Point(int id,int x,int y): id(id),x(x),y(y){}\n  bool operator < (const Point &p){return id<p.id;}\n};\nstatic const int MAX =1000000;\nstatic const int NIL = -1;\nint n;\nPoint P[MAX];\nNode T[MAX];\nint np;\nbool lessX(const Point &p1,const Point &p2){return p1.x<p2.x;}\nbool lessY(const Point &p1,const Point &p2){return p1.y<p2.y;}\nint makeKDTree(int l,int r, int d){\n  if(!(l<r))return NIL;\n  int mid=(l+r)/2;\n  int t=np++;\n  if(d%2==0)sort(P+l,P+r,lessX);\n  else sort(P+l,P+r,lessY);\n  T[t].location=mid;\n  T[t].l=makeKDTree(l,mid,d+1);\n  T[t].r=makeKDTree(mid+1,r,d+1);\n  return t;\n}\nvoid find(int v,int sx,int tx,int sy,int ty,int d,vector<Point> &ans){\n  int x=P[T[v].location].x;\n  int y=P[T[v].location].y;\n  if(sx<=x&&x<=tx&&sy<=y&&y<=ty)ans.push_back(P[T[v].location]);\n  if(d%2==0){\n    if(T[v].l!=NIL)if(sx<=x)find(T[v].l,sx,tx,sy,ty,d+1,ans);\n    if(T[v].r!=NIL)if(x<=tx)find(T[v].r,sx,tx,sy,ty,d+1,ans);\n  }\n  else{\n    if(T[v].l!=NIL)if(sy<=y)find(T[v].l,sx,tx,sy,ty,d+1,ans);\n    if(T[v].r!=NIL)if(y<=ty)find(T[v].r,sx,tx,sy,ty,d+1,ans);\n  }\n}\nint main(){\n  int x,y,q;\n  cin>>n>>q;\n  rep(i,n){\n    scanf(\"%d %d\",&x,&y);\n    P[i]=Point(i,x,y);\n    T[i].l=T[i].r=T[i].p=NIL;\n  }\n  np=0;\n  int root=makeKDTree(0,n,0);\n  int sx,sy,tx,ty;\n  vector<Point>ans;\n  rep(i,q){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    ans.clear();\n    find(root,sx,tx,sy,ty,0,ans);\n    cout<<ans.size()<<endl;\n  }return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_N 5001\n#define MAX_M 500001\n\n#define f first\n#define s second\n\ntypedef pair<int, int> P;\ntypedef pair<P, P> P2;\n  \nint n, m;\nP p[MAX_N];\nP2 pp[MAX_M];\n\nint main(){\n  cin >> n >> m;\n  for(int i = 0 ; i < n ; i++){\n    cin >> p[i].f >> p[i].s;\n  }\n  for(int i = 0 ; i < m ; i++){\n    cin >> pp[i].f.f >> pp[i].s.f >> pp[i].f.s >> pp[i].s.s;\n  }\n  \n  for(int i = 0 ; i < m ; i++){\n    int cnt = 0;\n    for(int j = 0 ; j < n ; j++){\n      if(pp[i].f.f <= p[j].f && p[j].f <= pp[i].f.s &&\n\t pp[i].s.f <= p[j].s && p[j].s <= pp[i].s.s) cnt++;\n    }\n    cout << cnt << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\nint sum[5002][5002];\nint x[5002];\nint y[5002];\nint X[5002];\nint Y[5002];\nint main(){\n    int a,b;\n    scanf(\"%d%d\",&a,&b);\n    for(int i=0;i<a;i++){\n        scanf(\"%d%d\",x+i,y+i);\n        X[i]=x[i];\n        Y[i]=y[i];\n    }\n    X[a]=-1999999999;\n    X[a+1]=1999999999;\n    Y[a]=-1999999999;\n    Y[a+1]=1999999999;\n    std::sort(X,X+a+2);\n    std::sort(Y,Y+a+2);\n    for(int i=0;i<a;i++){\n        x[i]=lower_bound(X,X+a+2,x[i])-X;\n        y[i]=lower_bound(Y,Y+a+2,y[i])-Y;\n        sum[x[i]][y[i]]++;\n    }\n    for(int i=0;i<a+2;i++){\n        for(int j=1;j<a+2;j++){\n            sum[i][j]+=sum[i][j-1];\n        }\n    }\n    for(int i=0;i<a+2;i++){\n        for(int j=1;j<a+2;j++){\n            sum[j][i]+=sum[j-1][i];\n        }\n    }\n    for(int i=0;i<b;i++){\n        int p,q,r,s;\n        scanf(\"%d%d%d%d\",&p,&q,&r,&s);\n        int P=lower_bound(X,X+a+2,p)-X-1;\n        int Q=lower_bound(Y,Y+a+2,q)-Y-1;\n        int R=upper_bound(X,X+a+2,r)-X-1;\n        int S=upper_bound(Y,Y+a+2,s)-Y-1;\n        printf(\"%d\\n\",sum[R][S]-sum[R][Q]-sum[P][S]+sum[P][Q]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\nint n, m;\nvector<int> x, y;\nvector<int> uzx, uzy;\nmap<int, int> zx, zy;\nint cum[5010][5010];\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  cin >> n >> m;\n  x.resize(n);\n  y.resize(n);\n  uzx.resize(n);\n  uzy.resize(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    uzx[i] = x[i];\n    uzy[i] = y[i];\n  }\n  sort(uzx.begin(), uzx.end());\n  sort(uzy.begin(), uzy.end());\n  uzx.erase(unique(uzx.begin(), uzx.end()), uzx.end());\n  uzy.erase(unique(uzy.begin(), uzy.end()), uzy.end());\n  for (int i = 0; i < (int)uzx.size(); i++) {\n    zx[uzx[i]] = i;\n  }\n  for (int i = 0; i < (int)uzy.size(); i++) {\n    zy[uzy[i]] = i;\n  }\n  for (int i = 0; i < n; i++) {\n    int px = zx[x[i]] + 1;\n    int py = zy[y[i]] + 1;\n    cum[px][py]++;\n  }\n  for (int i = 0; i < 5010; i++) {\n    for (int j = 0; j < 5010; j++) {\n      if (j + 1 < 5010) cum[i][j + 1] += cum[i][j];\n      if (i) cum[i][j] += cum[i - 1][j];\n    }\n  }\n  for (int i = 0; i < m; i++) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    int ax = (lower_bound(uzx.begin(), uzx.end(), x1) - uzx.begin());\n    int ay = (lower_bound(uzy.begin(), uzy.end(), y1) - uzy.begin());\n    int bx = (upper_bound(uzx.begin(), uzx.end(), x2) - uzx.begin());\n    int by = (upper_bound(uzy.begin(), uzy.end(), y2) - uzy.begin());\n    cout << cum[bx][by] - cum[ax][by] - cum[bx][ay] + cum[ax][ay] << endl;\n  }\n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\ntypedef pair<int, int> P;\nconst int MAX_N = 5010;\nconst int MAX_M = 5 * 100010;\nconst int MAX_Y = MAX_N + MAX_M * 2;\nconst int MAX_W = MAX_N + MAX_M * 2;\n\nint H, W, N, M, tsx[MAX_N], tsy[MAX_N];\nvector<int> X, Y;\n\nvoid init_number(){\n  set<int> Ys, Xs;\n  REP(i, N){ Xs.insert(tsx[i]); Ys.insert(tsy[i]); }\n  Ys.insert((1e9 + 10) * -1);\n  Ys.insert(1e9 + 10);\n  Xs.insert((1e9 + 10) * -1);\n  Xs.insert(1e9 + 10);\n  X = vector<int>(Xs.begin(), Xs.end());\n  Y = vector<int>(Ys.begin(), Ys.end());\n  W = X.size();\n  H = Y.size();\n}\n\nvoid init(vector< vector<int> > &v, vector< vector<int> > &E){\n  E[0][0] = v[0][0];\n  FOR(i, 1, H) E[i][0] = E[i - 1][0] + v[i][0];\n  FOR(i, 1, W) E[0][i] = E[0][i - 1] + v[0][i];\n  FOR(y, 1, H)\n    FOR(x, 1, W)\n    E[y][x] = v[y][x] + E[y - 1][x] + E[y][x - 1] - E[y - 1][x - 1];\n}\n\nint calc(int Y1, int X1, int Y2, int X2, vector< vector<int> > &E){\n  int ret = E[Y2][X2];\n  if(X1 - 1 >= 0) ret -= E[Y2][X1 - 1];\n  if(Y1 - 1 >= 0) ret -= E[Y1 - 1][X2];\n  if(X1 - 1 >= 0 && Y1 - 1 >= 0) ret += E[Y1 - 1][X1 - 1];\n  return ret;\n}\n\nint main() {\n  cin >>N >>M;\n  REP(i, N) cin >>tsx[i] >>tsy[i];\n  init_number();\n  vector< vector<int> > v(H, vector<int>(W, 0)), E(H, vector<int>(W, 0));\n  REP(i, N){\n    int y = lower_bound(Y.begin(), Y.end(), tsy[i]) - Y.begin();\n    int x = lower_bound(X.begin(), X.end(), tsx[i]) - X.begin();\n    v[y][x] += 1;\n  }\n  init(v, E);\n  REP(i, M){\n    int x1, y1, x2, y2; cin >>x1 >>y1 >>x2 >>y2;\n    x1 = lower_bound(X.begin(), X.end(), x1) - X.begin();\n    y1 = lower_bound(Y.begin(), Y.end(), y1) - Y.begin();\n    x2 = upper_bound(X.begin(), X.end(), x2) - X.begin() - 1;\n    y2 = upper_bound(Y.begin(), Y.end(), y2) - Y.begin() - 1;\n    cout <<calc(y1, x1, y2, x2, E) <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(list<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tauto itr = pos.begin();\n\tfor(int i = 0; i < pos.size(); i++,itr++){\n\t\tPos now = *itr;\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tlist<Pos> pos;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos temp = {x1, x2};\n\t\tpos.push_back(temp);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tcout << Count(pos, x1, y1, x2, y2);\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<iomanip>\n#include<algorithm>\n#include<bitset>\n#include<cassert>\n#include<cctype>\n#include<cmath>\n#include<cstdio>\n#include<cstring>\n#include<functional>\n#include<limits>\n#include<list>\n#include<map>\n#include<numeric>\n#include<set>\n#include<stack>\n#include<string>\n#include<sstream>\n#include<queue>\n#include<vector>\nusing namespace std;\n\nusing ll = long long;\nusing ull = unsigned long long;\nusing pii = pair<int, int>;\n\n#define dump(o) { cerr << #o; for (auto e : (o)) cerr << \" \" << e; cerr << endl; }\n#define MOD 1000000007\n#define INF 0x3f3f3f3f\n#define INFL 0x3f3f3f3f3f3f3f3fLL\n\n//pair?????????\ntemplate<typename T1, typename T2>\nostream &operator << (ostream &os, const pair<T1, T2> &p) { os << \"(\" << p.first << \",\" << p.second << \")\"; return os; }\n\n//??§?¨???§???\n//v: ??§???????????§?¨??????? ????????????\ntemplate<typename T>\nvoid compress(vector<T> &v) {\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n}\n\n//??§?¨???§???(map)\n//v: ??§???????????§?¨??????? ????????????\n//?????????: zip[??§???????????§?¨?]:??§???????????§?¨? (zip.size()<=10^5?????????????????????)\ntemplate<typename T>\nmap<T, T> compressMap(vector<T> &v) {\n\tmap<T, T> zip;\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\tfor (T i = 0; i < v.size(); i++) zip[v[i]] = i;\n\treturn zip;\n}\n\n//??§???????????§?¨?\n//index(??§???????????§?¨?, ??§???????????§?¨??????????(??????) )\n//template<typename T>\n//int index(vector<T> v, T i) { return lower_bound(v.begin(), v.end(), i) - v.begin(); }\n#define index(v,i) lower_bound((v).begin(), (v).end(), (i)) - (v).begin();\n\n//2?¬????imos???\nclass Imos {\npublic:\n\tusing vvi = vector<vector<int> >;\n\tint X, Y;\n\tvvi s; //?´???????\n\t//f:field\n\tImos(vvi &f) {\n\t\tX = f.size();\n\t\tY = f[0].size();\n\t\t//one-based\n\t\t//(x,y)?????§????´??????????(x+1,y+1)\n\t\ts = vvi(X + 1, vector<int>(Y + 1));\n\t\tfor (int y = 0; y < Y; y++)\n\t\t\tfor (int x = 0; x < X; x++)\n\t\t\t\ts[x + 1][y + 1] += s[x + 1][y] + s[x][y + 1] - s[x][y] + f[x][y];\n\t}\n\t//[x1,x2)??????[y1,y2)???field??????????±???????\n\t//one-based????????????????§?\n\tint sum(int x1, int y1, int x2, int y2) { return s[x2][y2] - s[x2][y1] - s[x1][y2] + s[x1][y1]; }\n};\n\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<int> xs(n), ys(n);\n\tvector<int> x(n), y(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d%d\", &xs[i], &ys[i]);\n\t\tx[i] = xs[i]; y[i] = ys[i];\n\t}\n\tcompress(x);\n\tcompress(y);\n\n\t//map<int, int> zipx(compressMap(x));\n\t//map<int, int> zipy(compressMap(y));\n\t//dump(x);\n\t//dump(zipx);\n\t//dump(y);\n\t//dump(zipy);\n\n\tvector<vector<int> > f(x.size(), vector<int>(y.size()));\n\n\tfor (int i = 0; i < n; i++) {\n\t\tint vx = index(x, xs[i]);\n\t\tint vy = index(y, ys[i]);\n\t\tf[vx][vy]++;\n\t}\n\n\t//for (int vx = 0; vx < x.size(); vx++) dump(f[vx]);\n\n\tImos imos(f);\n\n\tfor (int i = 0; i < m; i++) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tx1 = index(x, x1);\n\t\ty1 = index(y, y1);\n\t\tx2 = index(x, x2 + 1); //Imos???sum???one-based?????????+1\n\t\ty2 = index(y, y2 + 1);\n\t\tcout << imos.sum(x1, y1, x2, y2) << endl;\n\t}\n\treturn 0;\n}\n\n\n//Sample2\n//https://gyazo.com/39c67d1abe7a6a686acb52285f8a0bc9"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <list>\n#include <complex>\n#include <algorithm>\n#include <set>\n#include <map>\n#include <queue>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <cmath>\n#include <iomanip>\n#include <sstream>\n#include <cassert>\n#include <numeric>\nusing namespace std;\ntypedef long long ll;\ntypedef ll li;\ntypedef pair<int,int> PI;\n#define EPS (1e-6)\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i, n) rep (i, n)\n#define F first\n#define S second\n#define mp(a,b) make_pair(a,b)\n#define pb(a) push_back(a)\n#define min3(a,b,c) min((a),min((b),(c)))\n#define min4(a,b,c,d) min((a),min3((b),(c),(d)))\n#define SZ(a) (int)((a).size())\n#define ALL(a) a.begin(),a.end()\n#define FLL(a,b) memset((a),b,sizeof(a))\n#define CLR(a) memset((a),0,sizeof(a))\n#define FOR(it,a) for(__typeof(a.begin())it=a.begin();it!=a.end();++it)\ntemplate<typename T,typename U> ostream& operator<< (ostream& out, const pair<T,U>& val){return out << \"(\" << val.F << \", \" << val.S << \")\";}\ntemplate<class T> ostream& operator<< (ostream& out, const vector<T>& val){out << \"{\";rep(i,SZ(val)) out << (i?\", \":\"\") << val[i];return out << \"}\";}\ntypedef double FP;\ntypedef complex<FP> pt;\ntypedef pt P;\ntypedef pair<pt,pt> line;\nFP dot(P a,P b){return real(conj(a)*b);}\nFP crs(P a,P b){return imag(conj(a)*b);}\nP ortho(P a){return conj(P(imag(a),real(a)));}\nP ortho(line a){return ortho(a.S-a.F);}\nP crspt(P a,P b,P c,P d){b-=a,d-=c;return a+b*crs(d,c-a)/crs(d,b);}\nP crspt(line a,line b){return crspt(a.F,a.S,b.F,b.S);}\nbool onl(P a1,P a2,P b){return abs(b-a1)+abs(b-a2)<abs(a1-a2)+EPS;}\nbool onl(line a,P b){return onl(a.F,a.S,b);}\nbool iscrs(line a,line b){P c=crspt(a,b);return onl(a,c)&&onl(b,c);}\nvoid pkuassert(bool t){t=1/t;};\nint dx[]={0,1,0,-1,1,1,-1,-1};\nint dy[]={1,0,-1,0,-1,1,1,-1};\nenum{TOP,BTM,LFT,RGT,FRT,BCK};\nint dxdy2ce[]={RGT,FRT,LFT,BCK};\ntemplate<class T> T shift(T a,int b,int c,int d,int e){\n  __typeof(a[0])t=a[b];\n  a[b]=a[c];a[c]=a[d];a[d]=a[e];a[e]=t;return a;}\ntemplate<class T> T rgt(T a){return shift(a,TOP,LFT,BTM,RGT);}\ntemplate<class T> T lft(T a){return shift(a,TOP,RGT,BTM,LFT);}\ntemplate<class T> T frt(T a){return shift(a,TOP,BCK,BTM,FRT);}\ntemplate<class T> T bck(T a){return shift(a,TOP,FRT,BTM,BCK);}\nline mkl(P a,P v){return line(a,a+v);}\nFP lpdist(line a,P b){return abs(b-crspt(a,mkl(b,ortho(a))));}\nFP spdist(line a,P b){\n  P c(crspt(a,mkl(b,ortho(a))));\n  return onl(a,c)?abs(b-c):min(abs(a.F-b),abs(a.S-b));\n}\nFP ssdist(line a,line b){\n  return\n    min4(spdist(a,b.F),spdist(a,b.S),\n         spdist(b,a.F),spdist(b,a.S));\n}\n\n\nint n,m;\n\nint main(int argc, char *argv[])\n{\n  cin >> n >> m;\n  vector<int> appx,appy;\n  vector<PI> tr(n);\n  rep(i,n){\n    cin >> tr[i].F >> tr[i].S;\n    appx.pb(tr[i].F);\n    appy.pb(tr[i].S);\n  }\n  sort(ALL(appx));\n  sort(ALL(appy));\n  appx.erase(unique(ALL(appx)),appx.end());\n  appy.erase(unique(ALL(appy)),appy.end());\n  map<int,int> xidx,yidx;\n  rep(i,SZ(appx)) xidx[appx[i]]=i;\n  rep(i,SZ(appy)) yidx[appy[i]]=i;\n\n  int sum[SZ(xidx)+10][SZ(yidx)+10];\n  CLR(sum);\n  FOR(it,tr) ++sum[xidx[it->F]+1][yidx[it->S]+1];\n  rep(i,SZ(xidx)+1)rep(j,SZ(yidx)+1)\n    sum[i+1][j+1]+=sum[i+1][j]+sum[i][j+1]-sum[i][j];\n  \n  rep(i,m){\n    int x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1=lower_bound(ALL(appx),x1)-appx.begin();\n    x2=lower_bound(ALL(appx),x2+1)-appx.begin();\n    y1=lower_bound(ALL(appy),y1)-appy.begin();\n    y2=lower_bound(ALL(appy),y2+1)-appy.begin();\n    cout << sum[x2][y2]+sum[x1][y1]-sum[x1][y2]-sum[x2][y1] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n\n#include<iostream>\n#include<fstream>\n\n#define fin cin\n\nusing namespace std;\n\nclass Coordinate{\n\npublic:\n    int x;\n    int y;\n    Coordinate():\n    x(0), y(0){\n\n    }\n    Coordinate(int _x, int _y):\n    x(_x), y(_y){\n\n    }\n\n    bool inside(Coordinate l_u, Coordinate r_d) const{\n        return l_u.x <= this->x && \n               this->x <= r_d.x &&\n               this->y >= l_u.y &&\n               r_d.y >= this->y;\n    }\n\n};\n\nint main(){\n//    ifstream fin(\"in.txt\");\n\n    int n, m;\n    fin >> n >> m;\n\n    Coordinate *spot = new Coordinate[n];\n    \n    //????????´??????input\n    for(int i = 0; i < n; i++){\n        fin >> spot[i].x;\n        fin >> spot[i].y;\n    }\n\n    //?????????input\n    Coordinate *l_u = new Coordinate[m];//left-up\n    Coordinate *r_d = new Coordinate[m];//right-down\n    for(int i = 0; i < m; i++){\n\n        int tmp_x, tmp_y;\n        fin >> tmp_x >> tmp_y;\n\n        l_u[i] = Coordinate(tmp_x, tmp_y);\n\n        fin >> tmp_x >> tmp_y;\n\n        r_d[i] = Coordinate(tmp_x, tmp_y);\n\n    }\n\n    for(int i = 0; i < m; i++){\n        int ans = 0;\n        for(int j = 0; j < n; j++){\n            if(spot[j].inside(l_u[i], r_d[i]))ans++;\n        }\n        cout << ans << endl;\n    }\n\n    \n\n\n    delete[] spot;\n    \n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//?¶??????????????????????\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,W;\nint32_t w[100];\nint32_t v[100];\n\nint dp[100][10001];\n//i??\\???????????????????????§??????capacity??????????????¶???????????°????????¨???????????§???\nint func(int i, int capacity)\n{\n\tif (capacity == 0) {\n\t\treturn 0;\n\t}\n\tif (i >= N) {\n\t\treturn 0;\n\t}\n\tif (dp[i][capacity] != -1) {\n\t\treturn dp[i][capacity];\n\t}\n\tint res = 0;\n\t//??\\??????\n\tif (capacity >= w[i]) { res = std::max(res, func(i + 1, capacity - w[i]) + v[i]); }\n\t//??\\?????????\n\tres = std::max(res, func(i + 1, capacity));\n\treturn dp[i][capacity] = res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>W;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tin >> v[i] >> w[i];\n\t}\n\tbool used[100] = {};\n\tout << func(0, used)<<endl;\n\n\treturn 0;\n}\n#endif\n\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,Q;\n//Coordinate Compression\nusing INT_T = int32_t;\nconstexpr int32_t N_MAX = 10010;\nINT_T t_x[N_MAX];\nINT_T t_y[N_MAX];\nINT_T CC_X[N_MAX];\nauto CC_X_end = CC_X;\nINT_T CC_Y[N_MAX];\nauto CC_Y_end = CC_Y;\nINT_T map[N_MAX][N_MAX];\n\nvoid Init_CoordinateCompression(INT_T(&bace)[N_MAX], INT_T(&CC_buf)[N_MAX], INT_T*&CC_buf_end)\n{\n\tif (bace != CC_buf) {\n\t\tstd::copy_n(bace, N, CC_buf);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tCC_buf[N + i] = bace[i] - 1;\n\t\t}\n\t}\n\tCC_buf_end = CC_buf + 2 * N;\n\tstd::sort(CC_buf, CC_buf + 2*N);\n\tCC_buf_end = std::unique(CC_buf, CC_buf_end);\n}\nINT_T get_coordinate(INT_T(&CC_buf)[N_MAX], INT_T* CC_buf_end, INT_T v)\n{\n\treturn std::lower_bound(CC_buf, CC_buf_end, v) - CC_buf + 1;\n}\nvoid Do_CoordinateCompression(INT_T(&bace)[N_MAX], INT_T(&CC_buf)[N_MAX], INT_T*&CC_buf_end)\n{\n\tInit_CoordinateCompression(bace, CC_buf, CC_buf_end);\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tbace[i] = get_coordinate(CC_buf, CC_buf_end, bace[i]);\n\t}\n}\n\ntemplate<typename ARR>\ninline void add_full(ARR& v1, ARR& v2)\n{\n\tv1 += v2;\n}\ntemplate<typename ARR, size_t N>\ninline void add_full(ARR(&v1)[N], ARR(&v2)[N])\n{\n\tauto iter1 = v1, iter2 = v2, iter1end = v1 + N;\n\twhile (iter1 != iter1end) {\n\t\tadd_full(*iter1++, *iter2++);\n\t}\n}\n//1-indexed?´???????\ntemplate<size_t N>void CuSum(INT_T(&arr)[N])\n{\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tarr[i] += arr[i - 1];\n\t}\n}\ntemplate<typename ARR, size_t N>void CuSum(ARR(&arr)[N])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\n#if 0\ntemplate<size_t N, size_t M>void CuSum(INT_T(&arr)[N][M])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\ntemplate<size_t N, size_t M, size_t O>void CuSum(INT_T(&arr)[N][M][O])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\n#endif\n//1-indexed???(]??????\ntemplate<size_t N> int64_t get_sum(INT_T(&arr)[N], int x, int x2)\n{\n\treturn (arr[x2] - arr[x]);\n}\n//1-indexed???(]??????\ntemplate<size_t N, size_t M> int64_t get_sum(INT_T(&arr)[N][M], int x, int y, int x2, int y2)\n{\n\treturn (arr[y2][x2] - arr[y][x2] - arr[y2][x] + arr[y][x]);\n}\n//1-indexed???(]??????\ntemplate<size_t N, size_t M, size_t O> int64_t get_sum(INT_T(&arr)[N][M][O], int x, int y, int z, int x2, int y2, int z2)\n{\n\n\treturn arr(arr[z2][y2][x2] - arr[z][y2][x2] - arr[z2][y][x2] - arr[z2][y2][x] + arr[z2][y][x] + arr[z2][y][x] + arr[z][y][x2] - arr[z][y][x]);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>Q;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tin >> t_x[i]>>t_y[i];\n\t}\n\tDo_CoordinateCompression(t_x, CC_X, CC_X_end);\n\tDo_CoordinateCompression(t_y, CC_Y, CC_Y_end);\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\t++map[t_y[i]][t_x[i]];\n\t}\n\tCuSum(map);\n\twhile (Q--)\n\t{\n\t\tint x, y, x2, y2;\n\t\tin >> x >> y >> x2 >> y2;\n\t\tx = get_coordinate(CC_X,CC_X_end, x); --x;\n\t\tx2 = get_coordinate(CC_X, CC_X_end, x2);\n\t\ty = get_coordinate(CC_Y, CC_Y_end, y); --y;\n\t\ty2 = get_coordinate(CC_Y, CC_Y_end, y2);\n\t\tout << get_sum(map, x, y, x2, y2)<<endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing ll = long long int;\n\nconstexpr int MAX_N = 5000;\n\n\nint n, m;\nint w, h;\n\nll board[MAX_N][MAX_N];\n\nll X[MAX_N], Y[MAX_N];\nstd::vector<ll> vx, vy;\n\nint compress(ll *x,std::vector<ll>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\t++board[Y[i]][X[i]];\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tll sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\t\n\n\tll x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\n#define watch(a) { cout << #a << \" = \" << a << endl; }\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint main() {\n\n  int N, M; cin >> N >> M;\n  set<int> X, Y;\n  vector<int> xs(N), ys(N);\n  rep(i, N) {\n    scanf(\"%d%d\", &xs[i], &ys[i]);\n    X.insert(xs[i]); Y.insert(ys[i]);\n  }\n\n  vector<int> rx1(M), ry1(M), rx2(M), ry2(M);\n  rep(i, M) {\n    scanf(\"%d%d%d%d\", &rx1[i], &ry1[i], &rx2[i], &ry2[i]);\n    X.insert(rx1[i]); Y.insert(ry1[i]);\n    X.insert(rx2[i]); Y.insert(ry2[i]);\n  }\n\n  map<int, int> MX, MY;\n  int W = 0; for(auto && e: X) MX[e] = W++;\n  int H = 0; for(auto && e: Y) MY[e] = H++;\n\n  static int sum[5010][5010];\n\n  rep(i, N) {\n    sum[MY[ys[i]]][MX[xs[i]]] ++;\n  }\n\n  rep(i, H) rep(j, W) {\n    if(i && j) sum[i][j] -= sum[i-1][j-1];\n    if(i) sum[i][j] += sum[i-1][j];\n    if(j) sum[i][j] += sum[i][j-1];\n  }\n\n  rep(i, M) {\n    int x1 = MX[rx1[i]], x2 = MX[rx2[i]];\n    int y1 = MY[ry1[i]], y2 = MY[ry2[i]];\n    int r = sum[y2][x2];\n    if(x1 && y1) r += sum[y1-1][x1-1];\n    if(y1) r -= sum[y1-1][x2];\n    if(x1) r -= sum[y2][x1-1];\n    cout << r << endl;\n  }\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing ll = long long int;\n\nconstexpr int MAX_N = 6000;\n\nint n, m;\nint w, h;\n\nll board[MAX_N][MAX_N];\n\nll X[MAX_N], Y[MAX_N];\nstd::vector<ll> vx, vy;\n\nint compress(ll *x,std::vector<ll>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\t++board[Y[i]][X[i]];\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tll sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\t\n\n\tll x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n, m;\nLL x[101010], y[101010];\nvector<LL> xx, yy;\nint rui[5050][5050];\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t\txx.emplace_back(x[i]);\n\t\tyy.emplace_back(y[i]);\n\t}\n\txx.emplace_back(-HLINF);\n\txx.emplace_back(HLINF);\n\tyy.emplace_back(-HLINF);\n\tyy.emplace_back(HLINF);\n\n\tUNIQUE(xx);\n\tUNIQUE(yy);\n\n\tREP(i, n) {\n\t\tint xxx = lower_bound(ALL(xx), x[i]) - xx.begin();\n\t\tint yyy = lower_bound(ALL(yy), y[i]) - yy.begin();\n\t\trui[yyy][xxx]++;\n\t}\n\tREP(i, n+2) {\n\t\tREP(j, n+2) {\n\t\t\tif (i > 0 && j > 0) {\n\t\t\t\trui[i][j] += rui[i][j - 1] + rui[i - 1][j];\n\t\t\t\trui[i][j] -= rui[i - 1][j - 1];\n\t\t\t}\n\t\t\telse if (i > 0)rui[i][j] += rui[i - 1][j];\n\t\t\telse if (j > 0)rui[i][j] += rui[i][j - 1];\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tLL x1, x2, y1, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = lower_bound(ALL(xx), x1) - xx.begin();\n\t\ty1 = lower_bound(ALL(yy), y1) - yy.begin();\n\t\tx2 = upper_bound(ALL(xx), x2) - xx.begin() - 1;\n\t\ty2 = upper_bound(ALL(yy), y2) - yy.begin() - 1;\n\t\tcout << rui[y2][x2] - rui[y1 - 1][x2] - rui[y2][x1 - 1] + rui[y1 - 1][x1 - 1] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint sum[5050][5050];\n\nvoid compress(vector<int> &v)\n{\n  sort(v.begin(), v.end());\n  v.erase(unique(v.begin(), v.end()), v.end());\n}\n\nint main()\n{\n  int n, m;\n  cin >> n >> m;\n  \n  int x[5050], y[5050];\n  vector<int> xx, yy;\n  for(int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    xx.push_back(x[i]);\n    yy.push_back(y[i]);\n  }\n  \n  compress(xx);\n  compress(yy);\n\n  for(int i = 0; i < n; i++) {\n    x[i] = find(xx.begin(), xx.end(), x[i]) - xx.begin();\n    y[i] = find(yy.begin(), yy.end(), y[i]) - yy.begin();\n    sum[y[i]+1][x[i]+1]++;\n  }\n\n  for(int i = 0; i < yy.size(); i++) {\n    for(int j = 0; j < xx.size(); j++) {\n      sum[i+1][j+1] += sum[i+1][j] + sum[i][j+1] - sum[i][j];\n    }\n  }\n\n  for(int i = 0; i < m; i++) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = lower_bound(xx.begin(), xx.end(), x1) - xx.begin();\n    y1 = lower_bound(yy.begin(), yy.end(), y1) - yy.begin();\n    x2 = upper_bound(xx.begin(), xx.end(), x2) - xx.begin();\n    y2 = upper_bound(yy.begin(), yy.end(), y2) - yy.begin();\n    cout << sum[y2][x2] - sum[y2][x1] - sum[y1][x2] + sum[y1][x1] << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 5010\ntypedef pair<int,int> pii;\n \nint s[MAX][MAX];\n \nint main(){\n    int n,m;\n    cin >> n >> m;\n    vector<int> x(n),y(n);\n    vector<int> X,Y;\n    for(int i = 0 ; i < n ; i++){\n        cin >> x[i] >> y[i];\n        X.push_back(x[i]);\n        Y.push_back(y[i]);\n    }\n    X.push_back(INT_MIN);\n    Y.push_back(INT_MIN);\n     \n    sort(X.begin(),X.end());\n    X.erase(unique(X.begin(),X.end()),X.end());\n    sort(Y.begin(),Y.end());\n    Y.erase(unique(Y.begin(),Y.end()),Y.end());\n    for(int i = 0 ; i < n ; i++){\n        int px = lower_bound(X.begin(),X.end(),x[i]) - X.begin();\n        int py = lower_bound(Y.begin(),Y.end(),y[i]) - Y.begin();\n        s[px][py]++;\n    }\n    for(int i = 1 ; i < MAX ; i++){\n        for(int j = 1 ; j < MAX ; j++){\n            s[i][j] += s[i-1][j]+s[i][j-1]-s[i-1][j-1];\n        }\n    }\n    while(m--){\n        int x1,y1,x2,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(X.begin(),X.end(),x1) - X.begin();\n        y1 = lower_bound(Y.begin(),Y.end(),y1) - Y.begin();\n        x2 = upper_bound(X.begin(),X.end(),x2) - X.begin() - 1;\n        y2 = upper_bound(Y.begin(),Y.end(),y2) - Y.begin() - 1;\n        cout << s[x2][y2]-s[x1-1][y2]-s[x2][y1-1]+s[x1-1][y1-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\n#define rep(i, n) for (int i = 0; i < int(n); ++i)\n\nint map[5002][5002];\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  int x[n], y[n], xx[n + 2], yy[n + 2];\n  rep (i, n) cin >> x[i] >> y[i];\n  rep (i, n) xx[i] = x[i];\n  rep (i, n) yy[i] = y[i];\n  xx[n] = 2e9;\n  yy[n] = 2e9;\n  xx[n + 1] = -2e9;\n  yy[n + 1] = -2e9;\n  sort(xx, xx + n + 2);\n  sort(yy, yy + n + 2);\n  rep (i, n + 2) rep (j, n + 2) map[i][j] = 0;\n  rep (i, n) {\n    int nx, ny;\n    rep (j, n + 2) if (x[i] == xx[j]) nx = j;\n    rep (j, n + 2) if (y[i] == yy[j]) ny = j;\n    ++map[ny][nx];\n    --map[n + 1][nx];\n    --map[ny][n + 1];\n    ++map[n + 1][n + 1];\n  }\n  rep (i, n + 2) rep (j, n + 1) map[i][j + 1] += map[i][j];\n  rep (i, n + 1) rep (j, n + 2) map[i + 1][j] += map[i][j];\n  rep (i, m) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    int xx1 = lower_bound(xx, xx + n + 2, x1) - xx - 1;\n    int yy1 = lower_bound(yy, yy + n + 2, y1) - yy - 1;\n    int xx2 = upper_bound(xx, xx + n + 2, x2) - xx - 1;\n    int yy2 = upper_bound(yy, yy + n + 2, y2) - yy - 1;\n    cout << map[yy2][xx2] - map[yy2][xx1] - map[yy1][xx2] + map[yy1][xx1] << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define INF 1<<30\n#define DEBUG 0\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.TH\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nvector<int> x, y;\t\t// 座標\nvector<int> xx, yy;\t// 圧縮した座標\n\nint tp[5005][5005];\n\nvoid compress (void ) \n{\n\tx.push_back (-INF ); y.push_back (-INF );\n\tsort (ALL (x ) ); sort (ALL (y ) );\n\tx.erase (unique (ALL (x ) ), x.end() );\n\ty.erase (unique (ALL (y ) ), y.end() );\n\txx.clear(); yy.clear();\n\tint sx = x.size();\n\tint sy = y.size();\n\txx.resize (sx, 0 ); yy.resize (sy, 0 );\n\trep (j, sx ){\n\t\txx[j] = x[j];\n\t} // end rep\n\trep (i, sy ){\n\t\tyy[i] = y[i];\n\t} // end rep\n}\n\nint sum (int sx, int sy, int ex, int ey )\n{\n\tint ssx = max (sx-1, 0 );\n\tint ssy = max (sy-1, 0 );\n\n\treturn (tp[ey][ex] - tp[ssy][ex] - tp[ey][ssx] + tp[ssy][ssx] );\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tint n, m;\n\tscanf (\"%d %d\", &n, &m );\n\tx.clear(); y.clear();\n\tvector<int> tx (n, 0 ), ty (n, 0 );\n\trep (i, n ){\n\t\tscanf (\"%d %d\", &tx[i], &ty[i] );\n\t\tx.push_back (tx[i] ); y.push_back (ty[i] );\n\t} // end rep\n\n\tcompress ();\n\n\tmemset (tp, 0, sizeof (tp ) );\n\trep (i, n ){\n\t\tint rx = lower_bound (ALL (xx ), tx[i] ) - xx.begin();\n\t\tint ry = lower_bound (ALL (yy ), ty[i] ) - yy.begin();\n\t\ttp[ry][rx]++;\n\t} // end rep\n\n\tint nx = x.size();\n\tint ny = y.size();\n\tfor (int i = 0; i < ny; i++ ){\n\t\tfor (int j = 1; j < nx; j++ ){\n\t\t\ttp[i][j] += tp[i][j-1];\n\t\t} // end for\n\t} // end for\n\n\tfor (int i = 1; i < ny; i++ ){\n\t\tfor (int j = 0; j < nx; j++ ){\n\t\t\ttp[i][j] += tp[i-1][j];\n\t\t} // end for\n\t} // end for\n\n\trep (j, m ){\n\t\tint x1, y1, x2, y2;\n\t\tscanf (\"%d %d %d %d\", &x1, &y1, &x2, &y2 );\n\t\tint xx1 = lower_bound (ALL (xx ), x1 ) - xx.begin();\t\n\t\tint xx2 = upper_bound (ALL (xx ), x2 ) - xx.begin() - 1;\n\t\tint yy1 = lower_bound (ALL (yy ), y1 ) - yy.begin();\n\t\tint yy2 = upper_bound (ALL (yy ), y2 ) - yy.begin() - 1;\n\t\tint res = 0;\n\t\tif (xx1 <= xx2 && yy1 <= yy2 )\n\t\t\tres = sum (xx1, yy1, xx2, yy2 );\n\t\tprintf (\"%d\\n\", res );\n\t} // end rep\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\ntypedef long long ll;\n//typedef vector<int> vi;\n//typedef vector<vi> vvi;\nusing namespace std;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvector<int> x(n);\n\tvector<int> y(n);\n\trep(i,n)cin>>x[i]>>y[i];\n\twhile(m--){\n\t\tint co=0;\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\trep(i,n)if(a<=x[i]&&x[i]<=c&&b<=y[i]&&y[i]<=d)co++;\n\t\tcout<<co<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<algorithm>\n#include<string>\n#include<iostream>\n#include<map>\n#include<set>\n#include<queue>\nusing namespace std;\n\ntypedef long long ll;\n\nint N,M;\nll fie[5111][5111];\nll rui[5111][5111];\nll xy[2][5001];\nll X[5001],Y[5001];\n\nint W,H;\n\nint compress(int id,ll *x){\n  vector<ll> xs;\n  for(int i=0;i<N;i++){\n    xs.push_back(xy[id][i]);\n  }\n\n  sort(xs.begin(),xs.end());\n  xs.erase(unique(xs.begin(),xs.end()),xs.end());\n\n  for(int i=0;i<N;i++){\n    ll a = find(xs.begin(),xs.end(),xy[id][i]) - xs.begin();\n    a++;\n    x[a] = xy[id][i];\n    xy[id][i] = a;\n  }\n\n  x[0] = -10000000000;\n\n  return (int)xs.size();\n\n}\n\nint nibun(ll a,ll *b,int wh,bool f){\n\n  /*\n  cout << a << \" :: wh = \" << wh << endl;\n  for(int i=0;i<=W;i++)\n    cout << b[i] << \" \";\n  cout << endl;\n  */  \n  int res = lower_bound(b,b+wh+1,a) - b;\n\n  //  cout << res << endl;\n\n  if(b[res] > a && !f) res--;\n\n  return res;\n}\n\nvoid view(){\n  for(int y=0;y<=H+1;y++){\n    for(int x=0;x<=W+1;x++){\n      cout << rui[x][y] << \" \";\n    }\n    cout << endl;\n  }\n}\n\nint main(){\n  cin >> N >> M;\n  for(int i=0;i<N;i++){\n    cin >> xy[0][i] >> xy[1][i];\n  }\n\n  W = compress(0,X);\n  H = compress(1,Y);\n  /*\n  cout << \"W = \" << W << endl;\n  for(int i=1;i<=W;i++)\n    cout << X[i] << \" \";\n  cout << endl;\n  cout << \"H = \" << H << endl;\n  for(int i=1;i<=H;i++)\n    cout << Y[i] << \" \";\n  cout << endl;\n  */\n\n  for(int i=0;i<N;i++){\n    fie[xy[0][i]][xy[1][i]]++;\n  }\n\n\n\n\n  for(int y=1;y<=H+1;y++){\n    for(int x=1;x<=W+1;x++){\n      rui[x][y] = rui[x-1][y] + fie[x][y];\n    }\n  }\n  for(int y=1;y<=H+1;y++){\n    for(int x=1;x<=W+1;x++){\n      rui[x][y] += rui[x][y-1];\n    }\n  }\n\n  cout << endl;\n  view();\n\n  for(int i=0;i<M;i++){\n    ll x1,y1,x2,y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = nibun(x1,X,W,true);\n    y1 = nibun(y1,Y,H,true);\n    x2 = nibun(x2,X,W,false);\n    y2 = nibun(y2,Y,H,false);\n    /*\n    cout << x1 << \" \"  << y1 << \" \" << x2 << \" \" << y2 << endl;\n    cout << rui[x2][y2] << \" - \" << rui[x2][y1-1] << \" - \" << rui[x1-1][y2] << \" + \" << rui[x1][y1] << endl;\n    */  \n    int res = rui[x2][y2] - rui[x2][y1-1] - rui[x1-1][y2] + rui[x1-1][y1-1];\n    cout << res << endl;\n  }\n\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n\nusing namespace std;\n\nint n, m, x, y, x1, y1, x2, y2;\n\nvector<pair<int, int> > p;\n\nint main()\n{\n    scanf(\"%d\", &n);\n    scanf(\"%d\", &m);\n    \n    for(int i = 0; i < n; i++)\n    {\n        scanf(\"%d\", &x);\n        scanf(\"%d\", &y);\n        \n        p.push_back(make_pair(x, y));\n    }\n    \n    for(int i = 0; i < m; i++)\n    {\n        scanf(\"%d\", &x1);\n        scanf(\"%d\", &y1);\n        scanf(\"%d\", &x2);\n        scanf(\"%d\", &y2);\n        \n        int ret = 0;\n        \n        for(int i = 0; i < n; i++)\n        {\n            if(x1 <= p[i].first && p[i].first <= x2 && y1 <= p[i].second && p[i].second <= y2)\n            {\n                ret++;\n            }\n        }\n        \n        printf(\"%d\\n\", ret);\n    }\n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 5000;\n\n\nint n, m;\nint w, h;\n\nint board[MAX_N][MAX_N];\n\nint X[MAX_N], Y[MAX_N];\nstd::vector<int> vx, vy;\n\nint compress(int *x,std::vector<int>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\t++board[Y[i]][X[i]];\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tint sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\t\n\n\tint x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<stack>\n#include<deque>\n#include<iostream>\n#include<cstdio>\n#define F first\n#define S second\n#define LIM 1000000010\n#define pb push_back\n#define all(n) n.begin(),n.end()\nusing namespace std;\ntypedef pair<int,int> P;\nshort dp[5002][5002];\nint main(){\n  int n,m;\n \n  vector<int> X,Y;\n  \n  while(scanf(\"%d%d\",&n,&m) != EOF){\n    for(int i=0;i<n;i++)for(int j=0;j<n;j++)dp[j][i] = 0;\n    for(int i=0;i<n;i++){\n      int x,y;\n      scanf(\"%d %d\",&x,&y);\n      X.pb(x); Y.pb(y);\n    }\n    vector<int> x,y;\n    x = X;\n    y = Y;\n    X.pb(-LIM); X.pb(LIM); Y.pb(-LIM); Y.pb(LIM);\n    sort(all(X)); sort(all(Y));\n    X.erase(unique(all(X)),X.end());\n    Y.erase(unique(all(Y)),Y.end());\n    for(int i=0;i<n;i++){\n      x[i] = find(all(X),x[i])-X.begin();\n      y[i] = find(all(Y),y[i])-Y.begin();\n      dp[y[i]][x[i]]++;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tdp[i+1][j+1] += dp[i+1][j]+dp[i][j+1]-dp[i][j];\n\n      }\n\n    }\n    for(int i=0;i<m;i++){\n      int sx,sy,gx,gy;\n      scanf(\"%d %d %d %d\",&sx,&sy,&gx,&gy);\n      sx = lower_bound(all(X),sx)-X.begin();\n      sy = lower_bound(all(Y),sy)-Y.begin();\n      gx = upper_bound(all(X),gx)-X.begin()-1;\n      gy = upper_bound(all(Y),gy)-Y.begin()-1;\n      cout << dp[gy][gx]-dp[gy][sx-1]-dp[sy-1][gx]+dp[sy-1][sx-1] << endl;\n\n    }\n\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define INF 2e9\n#define x first\n#define y second\nusing namespace std;\ntypedef pair<int,int> P;\nP in[5002];\nint n,m;\nint main(){\n  cin>>n>>m;\n  for(int i=0;i<n;i++) cin>>in[i].x>>in[i].y;\n  sort(in,in+n);\n\n  int a,b,c,d;  \n  while(m--){\n    scanf(\"%d%d%d%d\",&a,&b,&c,&d);\n    int cnt=0;\n    for(int i=0;i<n;i++){\n      if(in[i].x>c) break;\n      if((a<=in[i].x&&b<=in[i].y&&in[i].y<=d))cnt++;\n    }\n    cout <<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    omajinai;\n    cin >> n >> m;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    compressed_x.PB(inf);\n    compressed_y.PB(inf);\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = upper_bound(all(compressed_x), x2) - begin(compressed_x) - 1;\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = upper_bound(all(compressed_y), y2) - begin(compressed_y) - 1;\n\n        if (x2 < 0 || y2 < 0) {\n            cout << 0 << endl;\n            continue;\n        }\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvp in(n);\n\tvi x,y;\n\trep(i,n){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t\tin[i]=pii(a,b);\n\t}\n\tsort(all(x));\n\tsort(all(y));\n\tx.erase(unique(all(x)),x.end());\n\ty.erase(unique(all(y)),y.end());\n\trep(i,n)in[i]=pii(lower_bound(all(x),in[i].first)-x.begin(),lower_bound(all(y),in[i].second)-y.begin());\n\tvvi fi(x.size()+1,vi(y.size()+1));\n\trep(i,n)fi[in[i].first+1][in[i].second+1]++;\n\trep(i,x.size())rep(j,y.size())fi[i+1][j+1]+=fi[i][j+1]+fi[i+1][j]-fi[i][j];\n\twhile(m--){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\ta=lower_bound(all(x),a)-x.begin();\n\t\tb=lower_bound(all(y),b)-y.begin();\n\t\tc=upper_bound(all(x),c)-x.begin();\n\t\td=upper_bound(all(y),d)-y.begin();\n\t\tcout<<fi[c][d]-fi[a][d]-fi[c][b]+fi[a][b]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    cin >> n >> m;\n\n    rep(i, n) {\n        cin >> x[i] >> y[i];\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    compressed_x.PB(inf);\n    compressed_y.PB(inf);\n\n    rep(i, m) {\n        int x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = upper_bound(all(compressed_x), x2) - begin(compressed_x) - 1;\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = upper_bound(all(compressed_y), y2) - begin(compressed_y) - 1;\n\n        if (x2 < 0 || y2 < 0) {\n            continue;\n        }\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        //cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n//?¶??????????????????????\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,W;\nint32_t w[100];\nint32_t v[100];\n\nint dp[100][10001];\n//i??\\???????????????????????§??????capacity??????????????¶???????????°????????¨???????????§???\nint func(int i, int capacity)\n{\n\tif (capacity == 0) {\n\t\treturn 0;\n\t}\n\tif (i >= N) {\n\t\treturn 0;\n\t}\n\tif (dp[i][capacity] != -1) {\n\t\treturn dp[i][capacity];\n\t}\n\tint res = 0;\n\t//??\\??????\n\tif (capacity >= w[i]) { res = std::max(res, func(i + 1, capacity - w[i]) + v[i]); }\n\t//??\\?????????\n\tres = std::max(res, func(i + 1, capacity));\n\treturn dp[i][capacity] = res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>W;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tin >> v[i] >> w[i];\n\t}\n\tbool used[100] = {};\n\tout << func(0, used)<<endl;\n\n\treturn 0;\n}\n#endif\n\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,Q;\n//Coordinate Compression\nusing INT_T = int32_t;\nconstexpr int32_t N_MAX = 10010;\nINT_T t_x[N_MAX];\nINT_T t_y[N_MAX];\nINT_T CC_X[N_MAX];\nauto CC_X_end = CC_X;\nINT_T CC_Y[N_MAX];\nauto CC_Y_end = CC_Y;\n\nvoid Init_CoordinateCompression(INT_T(&bace)[N_MAX], INT_T(&CC_buf)[N_MAX], INT_T*&CC_buf_end)\n{\n\tif (bace != CC_buf) {\n\t\tstd::copy_n(bace, N, CC_buf);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tCC_buf[N + i] = bace[i] - 1;\n\t\t}\n\t}\n\tCC_buf_end = CC_buf + 2 * N;\n\tstd::sort(CC_buf, CC_buf + 2*N);\n\tCC_buf_end = std::unique(CC_buf, CC_buf_end);\n}\nINT_T get_coordinate(INT_T(&CC_buf)[N_MAX], INT_T* CC_buf_end, INT_T v)\n{\n\treturn std::lower_bound(CC_buf, CC_buf_end, v) - CC_buf + 1;\n}\nvoid Do_CoordinateCompression(INT_T(&bace)[N_MAX], INT_T(&CC_buf)[N_MAX], INT_T*&CC_buf_end)\n{\n\tInit_CoordinateCompression(bace, CC_buf, CC_buf_end);\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tbace[i] = get_coordinate(CC_buf, CC_buf_end, bace[i]);\n\t}\n}\n\nusing INT_T_CS = int16_t;\nINT_T_CS map[N_MAX][N_MAX];\ntemplate<typename ARR>\ninline void add_full(ARR& v1, ARR& v2)\n{\n\tv1 += v2;\n}\ntemplate<typename ARR, size_t N>\ninline void add_full(ARR(&v1)[N], ARR(&v2)[N])\n{\n\tauto iter1 = v1, iter2 = v2, iter1end = v1 + N;\n\twhile (iter1 != iter1end) {\n\t\tadd_full(*iter1++, *iter2++);\n\t}\n}\n//1-indexed?´???????\ntemplate<size_t N>void CuSum(INT_T_CS(&arr)[N])\n{\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tarr[i] += arr[i - 1];\n\t}\n}\ntemplate<typename ARR, size_t N>void CuSum(ARR(&arr)[N])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\n#if 0\ntemplate<size_t N, size_t M>void CuSum(INT_T_CS(&arr)[N][M])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\ntemplate<size_t N, size_t M, size_t O>void CuSum(INT_T_CS(&arr)[N][M][O])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\n#endif\n//1-indexed???(]??????\ntemplate<size_t N> INT_T_CS get_sum(INT_T_CS(&arr)[N], int x, int x2)\n{\n\treturn (arr[x2] - arr[x]);\n}\n//1-indexed???(]??????\ntemplate<size_t N, size_t M> INT_T_CS get_sum(INT_T_CS(&arr)[N][M], int x, int y, int x2, int y2)\n{\n\treturn (arr[y2][x2] - arr[y][x2] - arr[y2][x] + arr[y][x]);\n}\n//1-indexed???(]??????\ntemplate<size_t N, size_t M, size_t O> INT_T_CS get_sum(INT_T_CS(&arr)[N][M][O], int x, int y, int z, int x2, int y2, int z2)\n{\n\treturn (arr[z2][y2][x2] - arr[z][y2][x2] - arr[z2][y][x2] - arr[z2][y2][x] + arr[z2][y][x] + arr[z2][y][x] + arr[z][y][x2] - arr[z][y][x]);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>Q;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tin >> t_x[i]>>t_y[i];\n\t}\n\tDo_CoordinateCompression(t_x, CC_X, CC_X_end);\n\tDo_CoordinateCompression(t_y, CC_Y, CC_Y_end);\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\t++map[t_y[i]][t_x[i]];\n\t}\n\tCuSum(map);\n\twhile (Q--)\n\t{\n\t\tint x, y, x2, y2;\n\t\tin >> x >> y >> x2 >> y2;\n\t\tx = get_coordinate(CC_X,CC_X_end, x); --x;\n\t\tx2 = get_coordinate(CC_X, CC_X_end, x2);\n\t\ty = get_coordinate(CC_Y, CC_Y_end, y); --y;\n\t\ty2 = get_coordinate(CC_Y, CC_Y_end, y2);\n\t\tout << get_sum(map, x, y, x2, y2)<<endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\ntemplate<typename T>\ninline void compress(vector<T> & c){\n    sort(ALL(c));\n    c.erase(unique(ALL(c)),c.end());\n}\ntemplate<typename T>\ninline size_t idx(T i, vector<T> const& c){\n    return lower_bound(ALL(c),i) - c.begin();\n}\n\nint xx[5010], yy[5010], sum[5010][5010];\n\nsigned main(void)\n{\n  int n, m;\n  cin >> n >> m;\n  VI x(n), y(n);\n  REP(i, n) {\n    cin >> xx[i] >> yy[i];\n    x[i] = xx[i], y[i] = yy[i];\n  }\n  compress(x);\n  compress(y);\n  REP(i, n) {\n    int tx = idx(xx[i], x), ty = idx(yy[i], y);\n    sum[ty+1][tx+1]++;\n  }\n  REP(i, y.size()) REP(j, x.size()) {\n    sum[i+1][j+1] += sum[i+1][j] + sum[i][j+1] - sum[i][j];\n  }\n\n  REP(i, m) {\n    int sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    sx = idx(sx, x), sy = idx(sy, y);\n    gx = idx(gx+1, x), gy = idx(gy+1, y);\n    cout << sum[gy][gx] - sum[gy][sx] - sum[sy][gx] + sum[sy][sx] << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct BIT{\n\tvector<int> bit;\n\tint size;\n\t\n\tBIT(int n){\n\t\tsize=n;bit=vector<int>(n+1);\n\t}\n\t\n\tvoid add(int i,int x){\n\t\ti+=1;\n\t\twhile(i<=size)bit[i]+=x,i+=i&-i;\n\t}\n\n\tint sum(int i){\n\t\tint s=0;\n\t\twhile(i>0)s+=bit[i],i-=i&-i;\n\t\treturn s;\n\t}\n};\n\nstruct BIT2D{\n\tvector<BIT> bit;\n\tBIT2D(int x,int y):bit(x+1,BIT(y)){};\n\t\n\tvoid add(int x, int y, int v){\n\t\tx++;\n\t\twhile(x < (int)bit.size()){\n\t\t\tbit[x].add(y, v);\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\n\tint sum(int x,int y){\n\t\tint s = 0;\n\t\twhile(x > 0){\n\t\t\ts += bit[x].sum(y);\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nint n, m;\nint data[5000][2];\nint query[500000][4];\nmap<int,int> xmap;\nmap<int,int> ymap;\n\nint xmax, ymax;\n\nvoid input() {\n\tvector<int> xs;\n\tvector<int> ys;\n\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &data[i][0], &data[i][1]);\n\t\txs.push_back(data[i][0]);\n\t\tys.push_back(data[i][1]);\n\t}\n\trep(i,m) {\n\t\tscanf(\"%d%d%d%d\", &query[i][0], &query[i][1], &query[i][2], &query[i][3]);\n\t\txs.push_back(query[i][0]);\n\t\tys.push_back(query[i][1]);\n\t\txs.push_back(query[i][2]);\n\t\tys.push_back(query[i][3]);\n\t}\n\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\n\t{\n\t\tvector<int>::iterator eiter = unique(xs.begin(), xs.end());\n\t\tvector<int>::iterator iter = xs.begin();\n\t\tint i = 0;\n\t\tfor(i = 0; iter != eiter; iter++, i++) {\n\t\t\txmap[*iter] = i;\n\t\t}\n\t\txmax = i;\n\t}\n\t{\n\t\tvector<int>::iterator eiter = unique(ys.begin(), ys.end());\n\t\tvector<int>::iterator iter = ys.begin();\n\t\tint i = 0;\n\t\tfor(i = 0; iter != eiter; iter++, i++) {\n\t\t\tymap[*iter] = i;\n\t\t}\n\t\tymax = i;\n\t}\n}\n\nvoid process() {\n\tBIT2D qq(xmax + 1, ymax + 1);\n\n\trep(i, n) {\n\t\tqq.add(xmap[data[i][0]], ymap[data[i][1]], 1);\n\t}\n\n\trep(i, m) {\n\t\tint sumxy = qq.sum(xmap[query[i][2]] + 1, ymap[query[i][3]] + 1);\n\t\tint sumxyy = qq.sum(xmap[query[i][2]] + 1, ymap[query[i][1]]);\n\t\tint sumxxy = qq.sum(xmap[query[i][0]], ymap[query[i][3]] + 1);\n\t\tint sumxxyy = qq.sum(xmap[query[i][0]], ymap[query[i][1]]);\n\t\tprintf(\"%d\\n\", sumxy - sumxyy - sumxxy + sumxxyy);\n\t}\n}\n\nvoid output() {\n}\n\nint main() {\n\tinput();\n\tprocess();\n\toutput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\ntypedef complex<int> point;\nstruct kdtree {\n\tstruct node {\n\t\tpoint p;\n\t\tnode *l, *r;\n\t\tnode(const point &p)\n\t\t\t: p(p), l(NULL), r(NULL) { }\n\t} *root;\n\tkdtree() : root(NULL) { }\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n\tvoid insert(const point &p) {\n\t\troot = insert(root, 0, p);\n\t}\n\tnode *insert(node *t, int d, const point &p) {\n\t\tif (t == NULL) return new node(p);\n\t\tif (compare(d, p, t->p)) t->l = insert(t->l, !d, p);\n\t\telse                   t->r = insert(t->r, !d, p);\n\t\treturn t;\n\t}\n\tint search(const point &ld, const point &ru) {\n\t\treturn search(root, 0, ld, ru);\n\t}\n\n\tint search(node *t, int d, const point &ld, const point &ru) {\n\t\tint cou = 0;\n\n\t\tif (t == NULL) return 0;\n\t\tconst point &p = t->p;\n\t\tif (real(ld) <= real(p) && real(p) <= real(ru) &&\n\t\t\timag(ld) <= imag(p) && imag(p) <= imag(ru)) cou++;\n\t\tif (!compare(d, p, ld)) cou += search(t->l, !d, ld, ru);\n\t\tif (!compare(d, ru, p)) cou += search(t->r, !d, ld, ru);\n\t\treturn cou;\n\t}\n};\n\nsigned main() {\n\tkdtree kd;\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\n\tREP(i, n) {\n\t\tint x, y;\n\t\tscanf(\"%d %d\", &x, &y);\n\n\t\tkd.insert({ x,y });\n\t}\n\tREP(i, m) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\n\t\tprintf(\"%d\\n\",\tkd.search({ a,b }, { c,d }));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\nconst int inf = 1e9+7;\n\nint main(){\n\tint n,m;\n\tcin >> n >> m;\n\tvector<int> x(n+1), y(n+1);\n\tvector<pair<int,int> > xy(n+1);\n\tfor(int i=0; i<n; i++){\n\t\tcin >> x[i] >> y[i];\n\t\txy[i] = make_pair(x[i],y[i]);\n\t}\n\tx[n]=inf; y[n]=inf;\n\txy[n]=make_pair(inf,inf);\n\tsort(x.begin(), x.end());\n\tsort(y.begin(), y.end());\n\tsort(xy.begin(), xy.end());\n\t\n\tvector<pair<int, int> > nx, ny;\n\tfor(int i=0; i<n+1; i++){\n\t\tnx.push_back(make_pair(x[i], 1));\n\t\tfor(int j=i+1; j<n+1; j++){\n\t\t\tif(x[i]==x[j]){\n\t\t\t\tnx.back().second++;\n\t\t\t}else{\n\t\t\t\ti=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tfor(int i=0; i<n+1; i++){\n\t\tny.push_back(make_pair(y[i], 1));\n\t\tfor(int j=i+1; j<n+1; j++){\n\t\t\tif(y[i]==y[j]){\n\t\t\t\tny.back().second++;\n\t\t\t}else{\n\t\t\t\ti=j-1;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvector<vector<int> > lsum(nx.size(), vector<int>(ny.size()));\n\tint pidx = 0;\n\tint remain = n+1;\n\tfor(int i=0; i<(int)nx.size(); i++){\n\t\tlsum[i][0] = remain;\n\t\tfor(int j=1; j<(int)ny.size(); j++){\n\t\t\tlsum[i][j] = lsum[i][j-1] -ny[j-1].second;\n\t\t}\n\t\twhile(xy[pidx].first == nx[i].first){\n\t\t\tremain--;\n\t\t\tvector<pair<int,int> >::iterator it;\n\t\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(xy[pidx].second, 0));\n\t\t\tit->second--;\n\t\t\tpidx++;\n\t\t}\n\t}\n\t\n\tfor(int i=0; i<(int)nx.size(); i++){\n\t\tfor(int j=0; j<(int)ny.size(); j++){\n\t\t\tcout << lsum[i][j] << \" \";\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n\tfor(int i=0; i<m; i++){\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tvector<pair<int, int> >:: iterator it;\n\t\tit = lower_bound(nx.begin(), nx.end(), make_pair(x1, 0));\n\t\tx1 = it-nx.begin();\n\t\tit = lower_bound(nx.begin(), nx.end(), make_pair(x2+1, 0));\n\t\tx2 = it-nx.begin();\n\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(y1, 0));\n\t\ty1 = it-ny.begin();\n\t\tit = lower_bound(ny.begin(), ny.end(), make_pair(y2+1, 0));\n\t\ty2 = it-ny.begin();\n\t\tcout << lsum[x1][y1] -lsum[x2][y1] -lsum[x1][y2] +lsum[x2][y2] << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <tuple>\n# include <unordered_map>\n# include <numeric>\n# include <complex>\n# include <bitset>\n# include <random>\n# include <chrono>\n# include <cstdlib>\n# include <tuple>\n# include <array>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr int INF = 2147483647;\nconstexpr int HINF = INF / 2;\nconstexpr double DINF = 100000000000000000.0;\nconstexpr double HDINF = 50000000000000000.0;\nconstexpr long long LINF = 9223372036854775807;\nconstexpr long long HLINF = 4500000000000000000;\nconst double PI = acos(-1);\ntemplate <typename T_char>T_char TL(T_char cX) { return tolower(cX); };\ntemplate <typename T_char>T_char TU(T_char cX) { return toupper(cX); };\nconst int vy[] = { -1, -1, -1, 0, 1, 1, 1, 0 }, vx[] = { -1, 0, 1, 1, 1, 0, -1, -1 };\nconst int dx[4] = { 0,1,0,-1 }, dy[4] = { 1,0,-1,0 };\n# define ALL(x)      (x).begin(),(x).end()\n# define UNIQUE(c)   sort(ALL((c)));(c).erase(unique(ALL((c))),(c).end())\n# define LOWER(s)    transform(ALL((s)),(s).begin(),TL<char>)\n# define UPPER(s)    transform(ALL((s)),(s).begin(),TU<char>)\n# define FOR(i,a,b)  for(LL i=(a);i<(b);i++)\n# define RFOR(i,a,b) for(LL i=(a);i>=(b);i--)\n# define REP(i,n)    FOR(i,0,n)\n# define INIT        std::ios::sync_with_stdio(false);std::cin.tie(0)\n\nint n, m;\nLL x[101010], y[101010];\nvector<LL> xx, yy;\nint rui[5050][5050];\n\nint main() {\n\tcin >> n >> m;\n\tREP(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t\txx.emplace_back(x[i]);\n\t\tyy.emplace_back(y[i]);\n\t}\n\txx.emplace_back(-HLINF);\n\txx.emplace_back(HLINF);\n\tyy.emplace_back(-HLINF);\n\tyy.emplace_back(HLINF);\n\n\tUNIQUE(xx);\n\tUNIQUE(yy);\n\n\tREP(i, n) {\n\t\tint xxx = lower_bound(ALL(xx), x[i]) - xx.begin();\n\t\tint yyy = lower_bound(ALL(yy), y[i]) - yy.begin();\n\t\trui[yyy][xxx]++;\n\t}\n\tREP(i, n+2) {\n\t\tREP(j, n+2) {\n\t\t\tif (i > 0 && j > 0) {\n\t\t\t\trui[i][j] += rui[i][j - 1] + rui[i - 1][j];\n\t\t\t\trui[i][j] -= rui[i - 1][j - 1];\n\t\t\t}\n\t\t\telse if (i > 0)rui[i][j] += rui[i - 1][j];\n\t\t\telse if (j > 0)rui[i][j] += rui[i][j - 1];\n\t\t}\n\t}\n\tREP(i, m) {\n\t\tLL x1, x2, y1, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = lower_bound(ALL(xx), x1) - xx.begin();\n\t\ty1 = lower_bound(ALL(yy), y1) - yy.begin();\n\t\tx2 = upper_bound(ALL(xx), x2) - xx.begin() - 1;\n\t\ty2 = upper_bound(ALL(yy), y2) - yy.begin() - 1;\n\t\tcout << rui[y2][x2] - rui[y1 - 1][x2] - rui[y2][x1 - 1] + rui[x1 - 1][y1 - 1] << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": " #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                          //     #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,pa>\n                                        #define ppap pair<pa,int>\n                                  \n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-10)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\nint dx[4]={0,1,0,-1};\nint dy[4]={1,0,-1,0};\n                                        using namespace std;\n                               class pas{\n                                        \tpublic:\n                                        \tint x,y,h;\n                                        \tpas(int x=0,int y=0,int h=0):x(x),y(y),h(h) {}\n                                        \tbool operator < (const pas &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pas &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        class pa2{\n                                        \tpublic:\n                                        \tint x,y;\n                                        \tpa2(int x=0,int y=0):x(x),y(y) {}\n                                        \tpa2 operator + (pa2 p) {return pa2(x+p.x,y+p.y);}\n                                        \tbool operator < (const pa2 &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const pa2 &p) const{\n                                        \t\treturn abs(x-p.x)==0 && abs(y-p.y)==0;\n                                        \t}\n                                        \t\t\n                                        \n                                        };\n                                        \n                                               #define ppa pair<int,pas>\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n             \n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n             \n                            string itos( int i ) {\n                            ostringstream s ;\n                            s << i ;\n                            return s.str() ;\n                            }\n                             \n                            int gcd(int v,int b){\n                            \tif(v>b) return gcd(b,v);\n                            \tif(v==b) return b;\n                            \tif(b%v==0) return v;\n                            \treturn gcd(v,b%v);\n                            }\n             \n                            double distans(double x1,double y1,double x2,double y2){\n                            \tdouble rr=(x1-x2)*(x1-x2)+(y1-y2)*(y1-y2);\n                            \treturn sqrt(rr);\n                            \t\n                            }\n                            \n   //         int pr[2000010];\n     //       int inv[2000010];\n            /*\n            int beki(int wa,int rr,int warukazu){\n            \tif(rr==0) return 1ll;\n            \tif(rr==1) return wa%warukazu;\n            \tif(rr%2==1) return (beki(wa,rr-1,warukazu)*wa)%warukazu;\n            \tint zx=beki(wa,rr/2,warukazu);\n            \treturn (zx*zx)%warukazu;\n            }\n            \n\t\t\tint comb(int nn,int rr){\n\t\t\t\tint r=pr[nn]*inv[rr];\n\t\t\t\tr%=inf;\n\t\t\t\tr*=inv[nn-rr];\n\t\t\t\tr%=inf;\n\t\t\t\treturn r;\n\t\t\t}\n            \n            void gya(int ert){\n            \tpr[0]=1;\n            \tfor(int i=1;i<ert;i++){\n            \t\tpr[i]=(pr[i-1]*i)%inf;\n            \t}\n            \tfor(int i=0;i<ert;i++) inv[i]=beki(pr[i],inf-2,inf);\n            \t\n            }\n             */\n            \n             //sort(ve.begin(),ve.end(),greater<int>());\n                                     //----------------kokomade tenpure------------\n            //vector<double> ans(100000000),ans2(100000000);\n\nint xx[5500],yy[5500];\nint dp[6000][6000]={0};\nint dp2[6000][6000]={0};\nset<int> sex,sey;\nmap<int,int>maxx,may; \nvector<int> vex,vey;\n   signed main(){\nint n,m;\n   \tcin>>n>>m;\n   \tfor(int i=0;i<n;i++){\n   \t\tcin>>xx[i]>>yy[i];\n   \t\tsex.insert(xx[i]);\n   \t\tsey.insert(yy[i]);\n   \t}\n   \tint cnt=1;\n   \tfor(auto it=sex.begin();it!=sex.end();it++){\n   \t\tmaxx[*it]=cnt;\n   \t\t\n   \t\tcnt++;\n   \t\tvex.pb(*it);\n   \t}\n   \tcnt=1;\n   \tfor(auto it=sey.begin();it!=sey.end();it++){\n   \t\tmay[*it]=cnt;\n   \t\tcnt++;\n   \t\tvey.pb(*it);\n   \t}\n   \tfor(int i=0;i<n;i++){\n   \t\tdp[maxx[xx[i]]][may[yy[i]]]++;\n  // \t\tcout<<maxx[xx[i]]<<\" \"<<may[yy[i]]<<endl;\n   \t}\n   \t\n   \tfor(int i=1;i<6000;i++)for(int j=1;j<6000;j++){\n   \t\tdp2[i][j]=dp2[i-1][j]+dp2[i][j-1]-dp2[i-1][j-1]+dp[i][j];\n   \t}\n   \t\n   \tfor(int i=0;i<m;i++){\n   \tint x1,y1,x2,y2;\n   \t\tcin>>x1>>y1>>x2>>y2;\n   \t\tx1--,y1--;\n   \t\t\n   \t\tauto itx1=upper_bound(vex.begin(),vex.end(),x1)-vex.begin();\n   \t\tauto itx2=upper_bound(vex.begin(),vex.end(),x2)-vex.begin();\n   \t\tauto ity1=upper_bound(vey.begin(),vey.end(),y1)-vey.begin();\n   \t\tauto ity2=upper_bound(vey.begin(),vey.end(),y2)-vey.begin();\n   \t\t\n   \t//\tcout<<itx1<<\" \"<<ity1<<\" \"<<itx2<<\" \"<<ity2<<endl;\n   \t\t\n   \t\tcout<<dp2[itx2][ity2]-dp2[itx1][ity2]-dp2[itx2][ity1]+dp2[itx1][ity1]<<endl;\n   \t\n   \t}\n   \treturn 0;\n        }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <cmath>\n#include <cstring>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <array>\n#include <map>\n#include <queue>\n#include <limits.h>\n#include <set>\n#include <stack>\n#include <random>\n#include <complex>\n#define rep(i,s,n) for(int i = (s); (n) > i; i++)\n#define REP(i,n) rep(i,0,n)\n#define RANGE(x,a,b) ((a) <= (x) && (x) <= (b))\n#define DUPLE(a,b,c,d) (RANGE(a,c,d) || RANGE(b,c,d) || RANGE(c,a,b) || RANGE(d,a,b))\n#define INCLU(a,b,c,d) (RANGE(a,c,d) && (b,c,d))\n#define PW(x) ((x)*(x))\n#define ALL(x) (x).begin(), (x).end()\n#define MODU 1000000007\n#define bitcheck(a,b)   ((a >> b) & 1)\n#define bitset(a,b)      ( a |= (1 << b))\n#define bitunset(a,b)    (a &= ~(1 << b))\nusing namespace std;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n\nconst pii Dir[8] = { //?????????\n\t{ 0,1 },{ 0,-1 },{ 1,0 },{ -1,0 },\n\t{ 1,1 },{ 1,-1 },{ -1,-1 },{ -1,1 }\n};\ntemplate<typename A, size_t N, typename T>\nvoid Fill(A(&array)[N], const T &val) {\n\tstd::fill((T*) array, (T*) (array + N), val);\n}\n\nsigned main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\tvector<pii> px(n);\n\tvector<pii> py(n);\n\tvector<int> pxynum(n);\n\tREP(i, n) {\n\t\tscanf(\"%d %d\", &px[i].first, &px[i].second);\n\t\tpy[i] = { px[i].second,px[i].first };\n\t}\n\tsort(ALL(px));\n\tsort(ALL(py));\n\tint cou = 0;\n\tfor (auto cur : px) {\n\t\tauto itr = lower_bound(ALL(py), make_pair( cur.second,cur.first ));\n\t\tpxynum[cou] = itr - py.begin();\n\t\tcou++;\n\t}\n\n\tREP(i, m) {\n\t\tint a, b, c, d;\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\n\t\tauto s = lower_bound(ALL(px), make_pair( a,-INT_MAX ));\n\t\tauto f = upper_bound(s,px.end(), make_pair(c, INT_MAX));\n\t\tint ys = lower_bound(ALL(py), make_pair(b, -INT_MAX))-py.begin();\n\t\tint yf = upper_bound(py.begin()+ys,py.end(), make_pair(d, INT_MAX))-py.begin();\n\t\tint ans = 0;\n\t\tfor (int i = s-px.begin(); i < f-px.begin(); i++) {\n\t\t\tif (RANGE(pxynum[i], ys, yf - 1)) {\n\t\t\t\tans++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define repr(i,n) for(int i=(int)(n-1);i>=0;i--)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout << #x\" = \" << x << endl\n#define print(x) cout << x << endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<int, P> PIP;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\ntypedef set<int> S;\n\n#define INF INT_MAX\n#define MAX_N 1000000001\n\nint n, m;\nP treasure[5000];\n\nint main(){\n    cin.sync_with_stdio(false);\n    cin >> n >> m;\n    rep(i, n) {\n        int x, y;\n        cin >> x >> y;\n        treasure[i] = P(x, y);\n    }\n    sort(treasure, treasure + n);\n\n    rep(i, m) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        int up = upper_bound(treasure, treasure + n, P(x2, INF)) - treasure;\n        int low = lower_bound(treasure, treasure + n, P(x1, -INF)) - treasure;\n        int cnt = 0;\n        repl(j, low, up) {\n            if (y1 <= treasure[j].se && treasure[j].se <= y2) cnt++;\n        }\n        cout << cnt << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#pragma warning(disable:4996)\nint n, m;\npair<int, int> x[10000];\nint a, b, c, d, e, f, g, h, sum, l, r, mi;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &x[i].first, &x[i].second);\n\t}\n\tsort(x, x + n);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tsum = 0;\n\t\tl = 0; r = n; mi = n / 2;\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tmi = (l + r) / 2;\n\t\t\tif (x[mi].first < a) {\n\t\t\t\tl = mi;\n\t\t\t}\n\t\t\tif (x[mi].first > a) {\n\t\t\t\tr = mi;\n\t\t\t}\n\t\t}\n\t\te = mi;\n\t\tl = 0; r = n;\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tmi = (l + r) / 2;\n\t\t\tif (x[mi].first < c) {\n\t\t\t\tl = mi;\n\t\t\t}\n\t\t\tif (x[mi].first > c) {\n\t\t\t\tr = mi;\n\t\t\t}\n\t\t}\n\t\tf = mi;\n\t\tg = max(0, e - 5);\n\t\th = min(n - 1, f + 5);\n\t\tfor (int j = g; j <= h; j++) {\n\t\t\tif (a <= x[j].first) {\n\t\t\t\tif (x[j].first <= c) {\n\t\t\t\t\tif (b <= x[j].second) {\n\t\t\t\t\t\tif (x[j].second <= d) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; i++)\n\nint n, m;\nint nx, ny;\nint x[5001], y[5001];\nint index_x[5001], index_y[5001];\nint sum[5001][5001];\n\nint main(){\n\n  cin >> n >> m;\n  rep(i,n) cin >> x[i] >> y[i];\n  memset(sum, 0, sizeof(sum));\n\n  rep(i,n) index_x[i] = x[i];\n  rep(i,n) index_y[i] = y[i];\n\n  sort(index_x, index_x+n);\n  sort(index_y, index_y+n);\n  nx = unique(index_x, index_x+n) - index_x;\n  ny = unique(index_y, index_y+n) - index_y;\n\n  rep(i,n){\n    int px = (lower_bound(index_x, index_x+nx, x[i]) - index_x) + 1;\n    int py = (lower_bound(index_y, index_y+ny, y[i]) - index_y) + 1;\n    sum[px][py] += 1;\n  }\n  rep(i,nx+1) rep(j,ny+1)\n    sum[i+1][j+1] += (sum[i+1][j] + sum[i][j+1] -sum[i][j]);\n\n  rep(i,m){\n    int lx, ly, rx, ry;\n    cin >> lx >> ly >> rx >> ry;\n\n    lx = (lower_bound(index_x, index_x+nx, lx) - index_x) + 1;\n    ly = (lower_bound(index_y, index_y+ny, ly) - index_y) + 1;\n    rx = (upper_bound(index_x, index_x+nx, rx) - index_x);\n    ry = (upper_bound(index_y, index_y+ny, ry) - index_y);\n\n    cout << (sum[rx][ry] - sum[lx-1][ry] - sum[rx][ly-1] + sum[lx-1][ly-1]) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(integer i=0;i<(integer)(n);i++)\n\ntypedef long long int integer;\ntypedef pair<integer,integer> P;\nconst integer MAX = 5000;\n\ninteger acc[MAX + 8][MAX + 8];\ninteger trecd[MAX + 8][MAX + 8];\n\nint main() {\n  integer n, m;\n  cin >> n >> m;\n  vector<integer> xs, ys;\n  vector<P> treasures(n);\n  for (P &p : treasures) {\n    cin >> p.first >> p.second;\n    xs.push_back(p.first);\n    ys.push_back(p.second);\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n/*  for (integer x : xs) cout << x << \" \"; cout << endl;\n  for (integer y : ys) cout << y << \" \"; cout << endl;*/\n\n  for (P p : treasures) {\n    integer x = find(xs.begin(), xs.end(), p.first) - xs.begin() + 1;\n    integer y = find(ys.begin(), ys.end(), p.second) - ys.begin() + 1;\n    trecd[x][y]++;\n  }\n  \n  for (integer y = 1; y < MAX; y++) for (integer x = 1; x < MAX; x++) {\n    acc[x][y] = acc[x][y-1] + acc[x-1][y] - acc[x-1][y-1] + trecd[x][y];\n  }\n\n/*  REP(y, 10) {\n    REP(x, 10) {\n      cout << acc[x][y] << \" \";\n    }\n    cout << endl;\n  }*/\n\n  REP (i, m) {\n    integer xb, yb, xe, ye;\n    cin >> xb >> yb >> xe >> ye;\n    xb = upper_bound(xs.begin(), xs.end(), xb - 1) - xs.begin() + 1;\n    yb = upper_bound(ys.begin(), ys.end(), yb - 1) - ys.begin() + 1;\n    xe = *(lower_bound(xs.begin(), xs.end(), xe + 1) - 1);\n    xe = lower_bound(xs.begin(), xs.end(), xe) - xs.begin() + 1;\n    xe = max(xb, xe);\n    ye = *(lower_bound(ys.begin(), ys.end(), ye + 1) - 1);\n    ye = lower_bound(ys.begin(), ys.end(), ye) - ys.begin() + 1;\n    ye = max(yb, ye);\n//    cout << \"(\" << xb << \" \" << yb << \" \" << xe << \" \" << ye << \")\"<< endl;\n    integer ans = acc[xe][ye] - acc[xb-1][ye] - acc[xe][yb-1] + acc[xb-1][yb-1];\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\tint count = 0;\n\t\tfor(int j = 0; j < pos.size(); j++){\n\t\t\tPos now = pos[j];\n\t\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t\t}\n\t\t}\n\t\tcout << count;\n\t\tcout << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nconst int MAX = 1e9 + 1;\n\n// 座標圧縮 vector a の要素を圧縮して d に変換\nstruct Compress{\n    vector<int> d, unzip;\n    map<int, int> zip;        \n    Compress(vector<int> a){\n        vector<int> b = a;\n        d.resize(a.size());\n        sort(b.begin(), b.end());\n        b.erase(unique(b.begin(), b.end()), b.end());\n        unzip.resize(b.size());\n        for(int i = 0; i < b.size(); i++){\n            zip[b[i]] = i;\n            unzip[i] = b[i];\n        }\n        for(int i = 0; i < a.size(); i++){\n            d[i] = lower_bound(b.begin(), b.end(), a[i]) - b.begin();\n        }\n    }\n};\n\nstruct CumulativeSum2D{\n    vector<vector<int> > data;\n    CumulativeSum2D(int H, int W) : data(H + 1, vector<int>(W + 1, 0)) {}\n    //要素(x,y)に値zを加える\n    void add(int x, int y, int z){\n        ++x, ++y;\n        if(x >= data.size() || y >= data[0].size()) return;\n        data[x][y] += z;\n    }\n    void build(){\n        for(int i = 1; i < data.size(); i++) {\n        for(int j = 1; j < data[i].size(); j++) {\n            data[i][j] += data[i][j - 1] + data[i - 1][j] - data[i - 1][j - 1];\n            }\n        }\n    }\n    //左上[sy, sx], 右下(gx, gy)の矩形内の和を求める(半開区間) (0-index)\n    int query(int sx, int sy, int gx, int gy){\n        return (data[gx][gy] - data[sx][gy] - data[gx][sy] + data[sx][sy]);\n    }\n};\n\n/*\nverified\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\n*/\n\nint main(){\n    int n, m;\n    cin >> n >> m;\n    vector<int> x(n), y(n);\n    for(int i = 0; i < n; i++){\n        cin >> x[i] >> y[i];\n    }\n    x.push_back(-MAX);\n    y.push_back(-MAX);\n    x.push_back(MAX);\n    y.push_back(MAX);\n    Compress cx(x), cy(y);\n    CumulativeSum2D cs(n + 2, n + 2);\n    for(int i = 0; i < x.size(); i++){\n        if(i < n) cs.add(cx.d[i], cy.d[i], 1);\n    }\n    cs.build();\n    for(int i = 0; i < m; i++){\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n        x1 = lower_bound(cx.unzip.begin(), cx.unzip.end(), x1) - cx.unzip.begin();\n        y1 = lower_bound(cy.unzip.begin(), cy.unzip.end(), y1) - cy.unzip.begin();\n        x2 = upper_bound(cx.unzip.begin(), cx.unzip.end(), x2) - cx.unzip.begin() - 1;\n        y2 = upper_bound(cy.unzip.begin(), cy.unzip.end(), y2) - cy.unzip.begin() - 1;\n        if(x1 > x2 || y1 > y2){\n            cout << 0 << endl;\n        }else{\n            cout << cs.query(x1, y1, x2 + 1, y2 + 1) << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\nll inf =  1e12;\n\nbool lessY(const mp &a, const mp &b){\n return a.second != b.second ? a.second < b.second : a.first < b.first;\n}\n\nint main(){\n ll n,m;\n cin>>n>>m;\n vector<ll> x(n),y(n);\n vector<mp> z(n);\n for(ll i=0;i<n;i++) cin>>x[i]>>y[i];\n for(ll i=0;i<n;i++) z[i] = mp(x[i],y[i]);\n set<ll> ux,uy;// unique x,y;\n for(auto i:x) ux.insert(i);\n for(auto i:y) uy.insert(i);\n ll h = ux.size(),w = uy.size();\n vector<ll> rx,ry;\n for(auto i:ux) rx.push_back(i);\n for(auto i:uy) ry.push_back(i);\n vector<vector<ll> > dp(h+1,vector<ll>(w+1,0) );\n for(int i=0;i<n;i++){\n  auto ix = lower_bound(rx.begin(),rx.end() , x[i] );\n  auto iy = lower_bound(ry.begin(),ry.end() , y[i] );\n  int xi = ix-rx.begin();\n  int yi = iy-ry.begin();\n // cout<<xi<<' '<<yi<<endl;\n  dp[xi+1][yi+1]++;\n }\n for(int i=0;i<h;i++)\n  for(int j=0;j<w;j++) dp[i+1][j+1] += dp[i+1][j]+dp[i][j+1]-dp[i][j];\n\n for(ll i=0;i<m;i++){\n  ll sx,sy,tx,ty;\n  cin>>sx>>sy>>tx>>ty;\n  auto xs = lower_bound(rx.begin(),rx.end(), sx );\n  auto ys = lower_bound(ry.begin(),ry.end(), sy );\n  auto xt = upper_bound(rx.begin(),rx.end(), tx );\n  auto yt = upper_bound(ry.begin(),ry.end(), ty );\n  //xt--,yt--;\n  int ssx = xs-rx.begin();\n  int ssy = ys-ry.begin();\n  int ttx = xt-rx.begin();\n  int tty = yt-ry.begin();\n  //cout<<ssx<<' '<<ssy<<' '<<ttx<<' '<<tty<<endl;\n  cout<<dp[ttx][tty]-dp[ttx][ssy]-dp[ssx][tty]+dp[ssx][ssy]<<endl;\n }\n\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// #define _GLIBCXX_DEBUG // for STL debug (optional)\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\nusing namespace std;\nusing ll = long long int;\nusing int64 = long long int;\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst int INF = 1LL << 30;\nconst ll LONGINF = 1LL << 60;\nconst ll MOD = 1000000007LL;\n\nint sum[5010][5010];\nint main() {\n    int N, M; scanf(\"%d%d\", &N, &M);\n    vector<int> x(N), y(N);\n    vector<int> cmp_x, cmp_y;\n    for(int i=0; i<N; i++) {\n        scanf(\"%d%d\", &x[i], &y[i]);\n        cmp_x.emplace_back(x[i]);\n        cmp_y.emplace_back(y[i]);\n    }\n\n    cmp_x.emplace_back(-INF);\n    cmp_x.emplace_back(+INF);\n    sort(cmp_x.begin(), cmp_x.end());\n    cmp_x.erase(unique(cmp_x.begin(), cmp_x.end()), cmp_x.end());\n    cmp_y.emplace_back(-INF);\n    cmp_y.emplace_back(+INF);\n    sort(cmp_y.begin(), cmp_y.end());\n    cmp_y.erase(unique(cmp_y.begin(), cmp_y.end()), cmp_y.end());\n\n    for(int i=0; i<N; i++) {\n        int xk = lower_bound(cmp_x.begin(), cmp_x.end(), x[i]) - cmp_x.begin();\n        int yk = lower_bound(cmp_y.begin(), cmp_y.end(), y[i]) - cmp_y.begin();\n        // fprintf(stderr, \"xk = %d, yk = %d\\n\", xk+1, yk+1);\n        sum[xk+1][yk+1]++;\n    }\n    for(int i=1; i<=N+5; i++) {\n        for(int j=1; j<=N+5; j++) {\n            // fprintf(stderr, \"%d \", sum[i][j]);\n            // if(j == N+5) fprintf(stderr, \"\\n\");\n            sum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n        }\n    }\n    \n    for(int i=0; i<M; i++) {\n        int lx, ly, rx, ry; scanf(\"%d%d%d%d\", &lx, &ly, &rx, &ry);\n        lx = lower_bound(cmp_x.begin(), cmp_x.end(), lx) - cmp_x.begin();\n        ly = lower_bound(cmp_y.begin(), cmp_y.end(), ly) - cmp_y.begin();\n        rx = upper_bound(cmp_x.begin(), cmp_x.end(), rx) - cmp_x.begin();\n        ry = upper_bound(cmp_y.begin(), cmp_y.end(), ry) - cmp_y.begin();\n        // fprintf(stderr, \"lx = %d, ly = %d, rx = %d, ry = %d\\n\", lx, ly, rx, ry);\n        int s = sum[rx][ry] - sum[lx][ry] - sum[rx][ly] + sum[lx][ly];\n        printf(\"%d\\n\", s);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\nstruct Info{\n\tint x,y;\n};\n\nint** table;\n\nint main(){\n\n\tint N,M;\n\tscanf(\"%d %d\",&N,&M);\n\n\tInfo info[N];\n\n\tvector<int> First_X,First_Y;\n\n\tFirst_X.push_back(-BIG_NUM);\n\tFirst_Y.push_back(-BIG_NUM);\n\tFirst_X.push_back(BIG_NUM);\n\tFirst_Y.push_back(BIG_NUM);\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%d %d\",&info[i].x,&info[i].y);\n\n\t\tFirst_X.push_back(info[i].x);\n\t\tFirst_Y.push_back(info[i].y);\n\t}\n\n\tsort(First_X.begin(),First_X.end());\n\tsort(First_Y.begin(),First_Y.end());\n\n\tFirst_X.erase(unique(First_X.begin(),First_X.end()),First_X.end());\n\tFirst_Y.erase(unique(First_Y.begin(),First_Y.end()),First_Y.end());\n\n\tint H = (int)First_Y.size(),W = (int)First_X.size();\n\n\ttable = new int*[H];\n\tfor(int row = 0; row < H; row++){\n\t\ttable[row] = new int[W];\n\t\tfor(int col = 0; col < W; col++){\n\t\t\ttable[row][col] = 0;\n\t\t}\n\t}\n\n\tint tmp_x,tmp_y;\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tfor(int k = 0; k < W; k++){\n\t\t\tif(First_X[k] == info[i].x){\n\t\t\t\ttmp_x = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tfor(int k = 0; k < H; k++){\n\t\t\tif(First_Y[k] == info[i].y){\n\t\t\t\ttmp_y = k;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\ttable[tmp_y][tmp_x]++;\n\t}\n\n\tfor(int row = 0; row < H; row++){\n\t\tfor(int col = 1; col < W; col++){\n\t\t\ttable[row][col] += table[row][col-1];\n\t\t}\n\t}\n\n\tfor(int col = 0; col < W; col++){\n\t\tfor(int row = 1; row < H; row++){\n\t\t\ttable[row][col] += table[row-1][col];\n\t\t}\n\t}\n\n\n\tint x1,y1,x2,y2;\n\tint calc_x1,calc_y1,calc_x2,calc_y2;\n\tint left,right,m;\n\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %d %d\",&x1,&y1,&x2,&y2);\n\n\t\tcalc_y1 = 0;\n\t\tleft = 0,right = H-1,m = (left+right)/2;\n\n\t\twhile(left <= right){\n\t\t\tif(First_Y[m] >= y1){\n\t\t\t\tcalc_y1 = m;\n\t\t\t\tright = m-1;\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tcalc_y1--;\n\n\t\tcalc_y2 = H-1;\n\t\tleft = 0,right = H-1,m = (left+right)/2;\n\n\t\twhile(left <= right){\n\t\t\tif(First_Y[m] <= y2){\n\t\t\t\tcalc_y2 = m;\n\t\t\t\tleft = m+1;\n\t\t\t}else{\n\t\t\t\tright = m-1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\n\t\tcalc_x1 = 0;\n\t\tleft = 0,right = W-1,m = (left+right)/2;\n\n\t\twhile(left <= right){\n\t\t\tif(First_X[m] >= x1){\n\t\t\t\tcalc_x1 = m;\n\t\t\t\tright = m-1;\n\t\t\t}else{\n\t\t\t\tleft = m+1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tcalc_x1--;\n\n\t\tcalc_x2 = W-1;\n\t\tleft = 0,right = W-1,m = (left+right)/2;\n\n\t\twhile(left <= right){\n\t\t\tif(First_X[m] <= x2){\n\t\t\t\tcalc_x2 = m;\n\t\t\t\tleft = m+1;\n\t\t\t}else{\n\t\t\t\tright = m-1;\n\t\t\t}\n\t\t\tm = (left+right)/2;\n\t\t}\n\n\t\tint A,B,C;\n\t\tif(calc_y1 >= 0){\n\t\t\tA = table[calc_y1][calc_x2];\n\t\t}else{\n\t\t\tA = 0;\n\t\t}\n\n\t\tif(calc_x1 >= 0){\n\t\t\tB = table[calc_y2][calc_x1];\n\t\t}else{\n\t\t\tB = 0;\n\t\t}\n\n\t\tif(calc_y1 >= 0 && calc_x1 >= 0){\n\t\t\tC = table[calc_y1][calc_x1];\n\t\t}else{\n\t\t\tC = 0;\n\t\t}\n\n\t\tprintf(\"%d\\n\",table[calc_y2][calc_x2]-A-B+C);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\nusing namespace std;\nint main(){\n  int n,m;cin>>n>>m;\n  int i,j,k;\n  int x[n],y[n];\n  for(i=0;i<n;i++) scanf(\"%d %d\",&x[i],&y[i]);\n  int sx,sy,tx,ty;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    int ans = 0;\n    for(j=0;j<n;j++) if(sx<=x[j]&&x[j]<=tx&&sy<=y[j]&&y[j]<=ty) ans++;\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2426&lang=jp\nusing namespace std;\ntypedef pair<int, int> pii;\n\nint main() {\n\t//cin.tie(0); ios::sync_with_stdio(false);\n\tint n, m; scanf(\"%d %d\", &n, &m); //cin >> n >> m;\n\tvector<pii> treasure(n);\n\tfor (int i = 0; i < n;i++) {\n\t\tscanf(\"%d %d\", &treasure[i].first, &treasure[i].second);\n\t\t//cin >> treasure[i].first >> treasure[i].second;\n\t}\n\tfor (int i = 0; i < m;i++) {\n\t\tint ans = 0;\n\t\tint x1, y1, x2, y2; scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\tfor (int j = 0; j < n;j++) {\n\t\t\tif (treasure[j].first < x1) continue;\n\t\t\tif (treasure[j].first > x2) continue;\n\t\t\tif (treasure[j].second < y1) continue;\n\t\t\tif (treasure[j].second > y2) continue;\n\t\t\tans++;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <iterator>\n#include <map>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tmap<int, vector<int> > treasure;\n\n\tfor(int i = 0; i < n; ++i) {\n\t\tint x, y;\n\t\tcin >> x >> y;\n\t\ttreasure[x].push_back(y);\n\t}\n\n\tvector<int> prev = treasure.rbegin()->second;\n\tmap<int, vector<int> >::reverse_iterator rit = treasure.rbegin();\n\t++rit;\n\twhile(rit != treasure.rend()) {\n\t\tvector<int>& cur = rit->second;\n\t\tfor(int i = 0; i < prev.size(); ++i)\n\t\t\tcur.push_back(prev[i]);\n\n\t\tprev = rit->second;\n\t\t++rit;\n\t}\n\n\tFOR(it, treasure)\n\t\tsort(it->second.begin(), it->second.end());\n\n\ttreasure.insert(make_pair(1000000001, vector<int>()));\n\tfor(int i = 0; i < m; ++i) {\n\t\tint x1, y1, x2, y2;\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\n\t\tconst vector<int>& v1 = treasure.lower_bound(x1)->second;\n\t\tconst vector<int>& v2 = treasure.upper_bound(x2)->second;\n\n\t\tint num1 = upper_bound(v1.begin(), v1.end(), y2) - lower_bound(v1.begin(), v1.end(), y1);\n\t\tint num2 = upper_bound(v2.begin(), v2.end(), y2) - lower_bound(v2.begin(), v2.end(), y1);\n\t\tcout << num1 - num2 << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\nint main(){\n  vector<pair<int,int> > node;\n  int n,m,v,w,x,y;\n  cin >>n>>m;\n  for(int i=0,a,b; i<n; i++){\n    cin >>a>>b;\n    node.push_back(make_pair(a,b));\n  }\n  for(int i=0; i<m; i++){\n    int ans=0;\n    cin >>v>>w>>x>>y;\n    for(int j=0; j<n; j++)\n      if(node[j].first>=v &&\n\t node[j].first<=x &&\n\t node[j].second>=w &&\n\t node[j].second<=y) ans++;\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#pragma warning(disable:4996)\nusing namespace std;\n\nconst int My_Inf=2147483647;\nconst long long int My_LInf=9223372036854775807;\n\nint num[5001][5001];\nint sum[5001][5001];\n\nint main() {\n\tmemset(num, 0, sizeof(num));\n\tmemset(sum, 0, sizeof(num));\n\tint N, M; cin >> N >> M;\n\tvector<pair<int, int>>tres;\n\tvector<int>xs, ys;\n\tfor (int i = 0; i < N; ++i) {\n\t\tint x, y; cin >> x >> y;\n\t\ttres.push_back(make_pair(x, y));\n\t\txs.push_back(x);\n\t\tys.push_back(y);\n\t}\n\tsort(xs.begin(), xs.end());\n\txs.resize(unique(xs.begin(), xs.end()) - xs.begin());\n\tsort(ys.begin(), ys.end());\n\tys.resize(unique(ys.begin(), ys.end()) - ys.begin());\n\tfor (int i = 0; i < N; ++i) {\n\t\ttres[i].first = lower_bound(xs.begin(), xs.end(), tres[i].first) - xs.begin();\n\t\ttres[i].second = lower_bound(ys.begin(), ys.end(), tres[i].second) - ys.begin();\n\t}\n\tfor (int i = 0; i < N; ++i) {\n\t\tnum[tres[i].first][tres[i].second] = 1;\n\t}\n\tfor (int i = 0; i < 5000; ++i) {\n\t\tfor (int j = 0; j < 5000; ++j) {\n\t\t\tsum[i + 1][j + 1] = sum[i + 1][j] + sum[i][j + 1] - sum[i][j] + num[i][j];\n\t\t}\n\t}\n\n\n\tfor (int i = 0; i < M; ++i) {\n\t\tint x1, y1, x2, y2; cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = lower_bound(xs.begin(), xs.end(), x1) - xs.begin();\n\t\tx2 = upper_bound(xs.begin(), xs.end(), x2) - xs.begin();\n\t\ty1 = lower_bound(ys.begin(), ys.end(), y1) - ys.begin();\n\t\ty2 = upper_bound(ys.begin(), ys.end(), y2) - ys.begin();\n\t\tint ans = sum[x2][y2] - sum[x2][y1] - sum[x1][y2] + sum[x1][y1];\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 5000;\n\n\nint n, m;\nint w, h;\n\nint board[MAX_N][MAX_N];\n\nint X[MAX_N], Y[MAX_N];\nstd::vector<int> vx, vy;\n\nint compress(int *x,std::vector<int>& vec) {\n\tfor (int i = 0; i < n; ++i)\n\t\tvec.push_back(x[i]);\n\tstd::sort(vec.begin(), vec.end());\n\tvec.erase(std::unique(vec.begin(), vec.end()), vec.end());\n\n\tfor (int i = 0; i < n; ++i)\n\t\tx[i] = std::lower_bound(vec.begin(), vec.end(), x[i]) - vec.begin();\n\treturn vec.size();\n}\n\nint main() {\n\tstd::cin >> n >> m;\n\tfor (int i = 0; i < n; ++i)\n\t\tstd::cin >> X[i] >> Y[i];\n\n\tw = compress(X, vx);\n\th = compress(Y, vy);\n\n\tfor (int i = 0; i < n; ++i)\n\t\t++board[Y[i]][X[i]];\n\n\tfor (int i = 1; i < w; ++i)\n\t\tboard[0][i] += board[0][i - 1];\n\n\tint sum;\n\tfor (int i = 1; i < h; ++i) {\n\t\tsum = 0;\n\t\tfor (int j = 0; j < w; ++j) {\n\t\t\tsum += board[i][j];\n\t\t\tboard[i][j] = board[i - 1][j] + sum;\n\t\t}\n\t}\n\n\t/*for (int i = 0; i < h; ++i) {\n\t\tfor (int j = 0; j < w; ++j)\n\t\t\tstd::cout << board[i][j] << ' ';\n\t\tstd::cout << std::endl;\n\t}\n\t*/\n\t\n\n\tint x1, x2, y1, y2;\n\n\tfor (int i = 0; i < m; ++i) {\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tx1 = std::lower_bound(vx.begin(), vx.end(), x1) - vx.begin();\n\t\tx2 = std::upper_bound(vx.begin(), vx.end(), x2) - vx.begin() - 1;\n\t\ty1 = std::lower_bound(vy.begin(), vy.end(), y1) - vy.begin();\n\t\ty2 = std::upper_bound(vy.begin(), vy.end(), y2) - vy.begin() - 1;\n\t\tstd::cout << board[y2][x2] - ((x1 - 1 < 0) ?\n\t\t\t((y1 - 1 < 0) ? 0 : board[y1 - 1][x2])\n\t\t\t: ((y1 - 1 < 0) ? board[y2][x1 - 1]\n\t\t\t: (board[y1 - 1][x2] + board[y2][x1 - 1] - board[y1 - 1][x1 - 1]))) << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n\nusing namespace std;\n\nstruct Pos{\n\tint x;\n\tint y;\n};\n\nint Count(vector<Pos> pos, int x1, int y1, int x2, int y2){\n\tint count = 0;\n\tfor(int i = 0; i < pos.size(); i++){\n\t\tPos now = pos[i];\n\t\tif(x1 <= now.x && now.x <= x2 && y1 <= now.y && now.y <= y2){\n\t\t\tcount++;\t\n\t\t}\n\t}\n\treturn count;\n}\n\nint main(){\n\tios::sync_with_stdio(false);\n\tint n, m, x1, y1, x2, y2;\n\tvector<Pos> pos;\n\tostringstream oss;\n\t\n\tcin >> n >> m;\n\t\n\tfor(int i = 0; i < n; i++){\n\t\tcin >> x1 >> x2;\n\t\tPos tempPos = {x1, x2};\n\t\tpos.push_back(tempPos);\n\t}\n\t\n\tfor(int i = 0; i < m; i++){\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\toss << Count(pos, x1, y1, x2, y2);\n\t\toss << \"\\n\";\n\t}\n\tcout << oss.str();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[6000], Y[6000];\nint X1[1000000], X2[1000000], Y1[1000000], Y2[1000000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nsigned main() {\n\tscanf(\"%lld%lld\", &n, &m);\n\trep(i, n)scanf(\"%lld%lld\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%lld%lld%lld%lld\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (long long j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (long long i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#define NDEBUG\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n#include <vector>\n\ntemplate <typename Integral,\n\tstd::size_t bitsize = std::numeric_limits<Integral>::digits()>\n\tclass WaveletMatrix {\n\tpublic:\n\t\tusing value_type = Integral;\n\t\tusing size_type = std::size_t;\n\n\tprivate:\n\t\tusing uint32 = std::uint_least32_t;\n\t\tstatic size_type popcount32(uint32 c) {\n#ifdef __GNUC__\n\t\t\treturn __builtin_popcount(c);\n#elif _MSC_VER_\n\t\t\treturn _mm_popcnt_u32(c);\n#else\n\t\t\tc = (c & 0x55555555) + ((c >> 1) & 0x55555555);\n\t\t\tc = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n\t\t\tc = (c + (c >> 4)) & 0x0F0F0F0F;\n\t\t\tc += c >> 8;\n\t\t\tc += c >> 16;\n\t\t\treturn static_cast<size_type>(c) & 0x3F;\n#endif\n\t\t}\n\t\tstruct FID {\n\t\t\tstd::vector<uint32> dic;\n\t\t\tsize_type cnt;\n\t\t\tvalue_type bit;\n\t\t\tFID() {}\n\t\t\tFID(const size_type bsize) : dic(bsize, 0) {}\n\t\t\tvoid set(const size_type index) {\n\t\t\t\tdic[index >> 4 | 1] |= static_cast<uint32>(1) << (index & 0x1f);\n\t\t\t}\n\t\t\tvoid build() {\n\t\t\t\tconst size_type len = dic.size();\n\t\t\t\tfor (size_type j = 2; j < len; j += 2)\n\t\t\t\t\tdic[j] = dic[j - 2] + popcount32(dic[j - 1]);\n\t\t\t}\n\t\t\tsize_type rank(const size_type last) const {\n\t\t\t\treturn static_cast<size_type>(\n\t\t\t\t\tdic[last >> 4 & ~static_cast<size_type>(1)]) +\n\t\t\t\t\tpopcount32(dic[last >> 4 | 1] &\n\t\t\t\t\t(static_cast<size_type>(1) << (last & 0x1f)) - 1);\n\t\t\t}\n\t\t\tbool access(const size_type index) const {\n\t\t\t\treturn dic[index >> 4 | 1] >> (index & 0x1f) & 1;\n\t\t\t}\n\t\t};\n\t\tstd::array<FID, bitsize> matrix;\n\t\tvalue_type NOT_FOUND;\n\t\tsize_type size_;\n\n\tpublic:\n\t\tWaveletMatrix(std::vector<value_type> data, const value_type NOT_FOUND = 0)\n\t\t\t: size_(data.size()), NOT_FOUND(NOT_FOUND) {\n\t\t\tconst size_type len = data.size(), block = ((len >> 5) + 1) << 1;\n\t\t\tstd::vector<value_type> L(len), R(len);\n\t\t\tsize_type l, r;\n\t\t\tvalue_type temp = static_cast<value_type>(1) << (bitsize - 1);\n\t\t\tfor (auto &x : matrix) {\n\t\t\t\tx = FID(block);\n\t\t\t\tx.bit = temp;\n\t\t\t\ttemp = temp >> 1 & ~temp;\n\t\t\t\tl = 0;\n\t\t\t\tr = 0;\n\t\t\t\tfor (size_type j = 0; j < len; ++j)\n\t\t\t\t\tif (data[j] & x.bit)\n\t\t\t\t\t\tR[r++] = data[j], x.set(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tL[l++] = data[j];\n\t\t\t\tx.cnt = l;\n\t\t\t\tx.build();\n\t\t\t\tstd::swap(data, L);\n\t\t\t\tstd::copy(R.begin(), R.begin() + r, data.begin() + l);\n\t\t\t}\n\t\t}\n\n\t\tsize_type size() const noexcept { return size_; }\n\t\tbool empty() const noexcept { return size() == 0; }\n\n\t\tvalue_type access(size_type index) const {\n\t\t\tassert(index < size());\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (x.access(index))\n\t\t\t\t\tret |= x.bit, index = x.rank(index) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tindex -= x.rank(index);\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type operator[](const size_type index) const {\n\t\t\tassert(index < size());\n\t\t\treturn access(index);\n\t\t}\n\t\tsize_type rank(size_type first, size_type last, const value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (data & x.bit)\n\t\t\t\t\tfirst = x.rank(first) + x.cnt, last = x.rank(last) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tfirst -= x.rank(first), last -= x.rank(last);\n\t\t\treturn last - first;\n\t\t}\n\t\tvalue_type quantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tconst size_type l = x.rank(first), r = x.rank(last);\n\t\t\t\tif (r - l > k)\n\t\t\t\t\tfirst = l + x.cnt, last = r + x.cnt, ret |= x.bit;\n\t\t\t\telse\n\t\t\t\t\tfirst -= l, last -= r, k -= r - l;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type rquantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\treturn quantile(first, last, last - first - k - 1);\n\t\t}\n\t\tsize_type less_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_least(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type greater_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_most(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type rangefreq(size_type first, size_type last, const value_type lower,\n\t\t\tconst value_type upper) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tassert(lower <= upper);\n\t\t\treturn at_least(first, last, lower) - at_least(first, last, upper);\n\t\t}\n\t\tvalue_type successor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type predecessor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n\t\tvalue_type strict_succ(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type strict_pred(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n};\n\n#include<algorithm>\n#include<iostream>\n#include<utility>\n#include<vector>\nint main() {\n\tconstexpr int base = 1000000000;\n\tint n, m;\n\tstd::cin >> n >> m;\n\tstd::vector<std::pair<int, int>> p(n);\n\tfor (auto &e : p)\n\t\tstd::cin >> e.first >> e.second;\n\tstd::sort(p.begin(), p.end());\n\tstd::vector<int> a(n);\n\tfor (int i = 0;i < n;++i)\n\t\ta[i] = p[i].second + base;\n\tWaveletMatrix<int, 31> W(a);\n\tauto pos = [&p](int x) {\n\t\treturn std::lower_bound(p.begin(), p.end(), std::pair<int, int>(x, 0)) - p.begin();\n\t};\n\twhile (m--) {\n\t\tint x1, y1, x2, y2;\n\t\tstd::cin >> x1 >> y1 >> x2 >> y2;\n\t\tstd::cout << W.rangefreq(pos(x1), pos(x2 + 1), y1 + base, y2 + 1 + base) << std::endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\nint n, m;\npair<int, int> x[10000];\nint a, b, c, d, e, f, sum, l, r, mi;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &x[i].first, &x[i].second);\n\t}\n\tsort(x, x + n);\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tsum = 0;\n\t\tl = 0; r = n; mi = n / 2;\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tmi = (l + r) / 2;\n\t\t\tif (x[mi].first < a) {\n\t\t\t\tl = mi;\n\t\t\t}\n\t\t\tif (x[mi].first > a) {\n\t\t\t\tr = mi;\n\t\t\t}\n\t\t}\n\t\te = mi;\n\t\tl = 0; r = 0;\n\t\tfor (int j = 0; j < 30; j++) {\n\t\t\tmi = (l + r) / 2;\n\t\t\tif (x[mi].first < a) {\n\t\t\t\tl = mi;\n\t\t\t}\n\t\t\tif (x[mi].first > a) {\n\t\t\t\tr = mi;\n\t\t\t}\n\t\t}\n\t\tf = mi;\n\t\tfor (int j = e; j <= f; j++) {\n\t\t\tif (a <= x[j].first) {\n\t\t\t\tif (x[j].first <= c) {\n\t\t\t\t\tif (b <= x[j].second) {\n\t\t\t\t\t\tif (x[j].second <= d) {\n\t\t\t\t\t\t\tsum++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint dp[5000][5000] = {};\nint tx[5000]; int ty[5000];\nint s[500000][4];\nint main() {\n\tint n, m; cin >> n >> m;\n\tvector<int> xs; vector<int>ys;\n\trep(i, n) {\n\t\tcin >> tx[i] >> ty[i];\n\t\txs.push_back(tx[i]);\n\t\tys.push_back(ty[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\trep(i, m) {\n\t\trep(j, 4) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t\ts[i][0] = lower_bound(xs.begin(), xs.end(), s[i][0]) - xs.begin();\n\t\ts[i][1] = lower_bound(ys.begin(), ys.end(), s[i][1]) - ys.begin();\n\t\ts[i][2] = upper_bound(xs.begin(), xs.end(), s[i][2]) - xs.begin(); s[i][2]--;\n\t\ts[i][3] = upper_bound(ys.begin(), ys.end(), s[i][3]) - ys.begin(); s[i][3]--;\n\t}\n\trep(i, n) {\n\t\ttx[i] = find(xs.begin(), xs.end(), tx[i]) - xs.begin();\n\t\tty[i] = find(ys.begin(), ys.end(), ty[i]) - ys.begin();\n\t}\n\trep(i, n) {\n\t\tdp[tx[i]][ty[i]]++;\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[0][0] = dp[0][0];\n\t\t\t}\n\t\t\telse if (i == 0) {\n\t\t\t\tdp[0][j] += dp[0][j - 1];\n\t\t\t}\n\t\t\telse if (j == 0) {\n\t\t\t\tdp[i][0] += dp[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint sx = s[i][0]; int sy = s[i][1]; int gx = s[i][2]; int gy = s[i][3];\n\t\tint cnt;\n\t\tif (sx >= n || sy >= n || gx < 0 || gy < 0) {\n\t\t\tcnt = 0;\n\t\t}\n\t\telse if (sx > 0 && sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy] - dp[gx][sy - 1] + dp[sx - 1][sy - 1];\n\t\t}\n\t\telse if (sx > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy];\n\t\t}\n\t\telse if (sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[gx][sy - 1];\n\t\t}\n\t\telse {\n\t\t\tcnt = dp[gx][gy];\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cmath>\n#include <complex>\n#include <cstdint>\n#include <cstdio>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <tuple>\n#include <utility>\n#include <vector>\nusing namespace std;\n\nusing int64 = int64_t;\n\nint N, M;\nint tx[5000], ty[5000];\n\nint acc[5002][5002] = {};\nint cx[5000], cy[5000];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    cin >> N >> M;\n    for (int j = 0; j < N; ++j) {\n        cin >> tx[j] >> ty[j];\n    }\n\n    // initialize\n    for (int j = 0; j <= N; ++j) fill(acc[j], acc[j]+N+1, 0);\n\n    copy(tx, tx+N, cx); sort(cx, cx+N);\n    copy(ty, ty+N, cy); sort(cy, cy+N);\n\n    for (int j = 0; j < N; ++j) {\n        int xx = lower_bound(cx, cx+N, tx[j]) - cx;\n        int yy = lower_bound(cy, cy+N, ty[j]) - cy;\n        ++ acc[xx+1][yy+1];\n    }\n\n    for (int j = 1; j <= N; ++j) {\n        for (int k = 1; k <= N; ++k) {\n            acc[j][k] += acc[j-1][k] + acc[j][k-1] - acc[j-1][k-1];\n        }\n    }\n\n    for (int j = 0; j < M; ++j) {\n        int x1, y1, x2, y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        int ix1 = lower_bound(cx, cx+N, x1) - cx + 1;\n        int ix2 = upper_bound(cx, cx+N, x2) - cx;\n        int iy1 = lower_bound(cy, cy+N, y1) - cy + 1;\n        int iy2 = upper_bound(cy, cy+N, y2) - cy;\n\n        cout << acc[ix2][iy2] - acc[ix1-1][iy2] - acc[ix2][iy1-1] + acc[ix1-1][iy1-1] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nclass Node{\npublic:\n  int location;\n  int p,l,r;\n  Node(){}\n};\nclass Point{\npublic:\n  int id,x,y;\n  Point(){}\n  Point(int id,int x,int y): id(id),x(x),y(y){}\n  bool operator<(const Point &p)const{\n    return id<p.id;\n  }\n  void print(){\n    printf(\"%d\\n\",id);\n  }\n};\nstatic const int MAX = 5005;\nstatic const int NIL = -1;\n \nint N;\nPoint P[MAX];\nNode T[MAX];\nint np;\n \nbool lessX(const Point &p1,const Point &p2){return p1.x<p2.x;}\nbool lessY(const Point &p1,const Point &p2){return p1.y<p2.y;}\n \nint makeKDTree(int l,int r,int depth){\n  if(!(l<r)) return NIL;\n  int mid=(l+r)/2;\n  int t = np++;\n  if(depth%2==0){\n    sort(P+l,P+r,lessX);\n  }else{\n    sort(P+l,P+r,lessY);\n  }\n  T[t].location=mid;\n  T[t].l = makeKDTree(l,mid,depth+1);\n  T[t].r = makeKDTree(mid+1,r,depth+1);\n \n  return t;\n}\n \nvoid find(int v,int sx,int tx,int sy,int ty,int depth,vector<Point> &ans){\n  int x=P[T[v].location].x;\n  int y=P[T[v].location].y;\n \n \n  if(sx<=x&&x<=tx&&sy<=y&&y<=ty){\n    ans.push_back(P[T[v].location]);\n  }\n \n  if(depth%2==0){\n    if(T[v].l!=NIL){\n      if(sx<=x) find(T[v].l,sx,tx,sy,ty,depth+1,ans);\n    }\n    if(T[v].r!=NIL){\n      if(x<=tx) find(T[v].r,sx,tx,sy,ty,depth+1,ans);\n    }\n  }else{\n    if(T[v].l!=NIL){\n      if(sy<=y) find(T[v].l,sx,tx,sy,ty,depth+1,ans);\n    }\n    if(T[v].r!=NIL){\n      if(y<=ty) find(T[v].r,sx,tx,sy,ty,depth+1,ans);\n    }\n  }\n   \n} \n    \nint main(){\n  int x,y;\n  scanf(\"%d\",&N);\n  int q;\n  scanf(\"%d\",&q);\n  for(int i=0;i<N;i++) {\n    scanf(\"%d %d\",&x,&y);\n    P[i]=Point(i,x,y);\n    T[i].l = T[i].r = T[i].p = NIL;\n  }\n  np=0;\n  int root=makeKDTree(0,N,0);\n \n  int sx,tx,sy,ty;\n  vector<Point> ans;\n  for(int i=0;i<q;i++){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    ans.clear();\n    find(root,sx,tx,sy,ty,0,ans);\n    /*\n    sort(ans.begin(),ans.end());\n    for(int j=0;j<ans.size();j++){\n      ans[j].print();\n    }\n    printf(\"\\n\");\n    */\n    //cout << ans.size() << endl;\n    printf(\"%d\\n\",ans.size());\n  }\n   \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#define __USE_MINGW_ANSI_STDIO 0\n#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define IN(a, b, x) (a<=x&&x<b)\n#define MP make_pair\n#define PB push_back\n#ifdef int\nconst ll INF = (1LL<<60);\n#else\nconst int INF = (1LL<<30);\n#endif\nconst double PI = 3.14159265359;\nconst double EPS = 1e-12;\nconst int MOD = 1000000007;\n\ntemplate <typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate <typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0};\n\n//point\ntypedef complex<double> point;\nint ret;\n\nstruct kdtree {\n  struct node {\n    point p;\n    node *l, *r;\n    node(const point &p)\n      : p(p), l(NULL), r(NULL) { }\n  } *root;\n  kdtree() : root(NULL) { }\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n  void insert(const point &p) {\n    root = insert(root, 0, p);\n  }\n  node *insert(node *t, int d, const point &p) {\n    if (t == NULL) return new node(p);\n    if (compare(d,p,t->p)) t->l = insert(t->l, !d, p);\n    else                   t->r = insert(t->r, !d, p);\n    return t;\n  }\n  template <class OUT>\n  void search(const point &ld, const point &ru, OUT out) {\n    search(root, 0, ld, ru, out);\n  }\n  template <class OUT>\n  void search(node *t, int d, const point &ld, const point &ru, OUT out) {\n    if (t == NULL) return;\n    const point &p = t->p;\n    if (real(ld) <= real(p) && real(p) <= real(ru) &&\n        imag(ld) <= imag(p) && imag(p) <= imag(ru)) ret++;\n    if (!compare(d,p,ld)) search(t->l, !d, ld, ru, out);\n    if (!compare(d,ru,p)) search(t->r, !d, ld, ru, out);\n  }\n};\n\nkdtree tree;\npoint *out;\nsigned main(void)\n{\n  int n, m;\n  cin >> n >> m;\n  REP(i, n) {\n    double x, y;\n    cin >> x >> y;\n    tree.insert({x, y});\n  }\n  REP(i, m) {\n    double sx, sy, gx, gy;\n    cin >> sx >> sy >> gx >> gy;\n    ret = 0;\n    tree.search({sx, sy}, {gx, gy}, out);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <algorithm>\n\n#define CH(N,A,B) (A<=N&&N<B)\n#define REP(i,a,b) for(int i=a;i<b;i++)\n#define RREP(i,a,b) for(int i=(b-1);a<=i;i--)\n#define F first\n#define S second\n#define X first\n#define Y second\n\nusing namespace std;\n\nint n, m;\nvector<int> vx, vy;\nint tx[5000], ty[5000], unzipx[5000], unzipy[5000], imos[5000][5000];\nmap<int, int> zipx, zipy;\npair< pair<int,int>, pair<int,int> > p[500000];\n\nint main() {\n  cin>>n>>m;\n  REP(i,0,n){\n    cin>>tx[i]>>ty[i];\n    vx.push_back(tx[i]);\n    vy.push_back(ty[i]);\n  }\n  REP(i,0,m){\n    cin>>p[i].F.X>>p[i].F.Y>>p[i].S.X>>p[i].S.Y;\n  }\n\n  //compression\n  sort(vx.begin(), vx.end());\n  sort(vy.begin(), vy.end());\n  vx.erase(unique(vx.begin(), vx.end()), vx.end());\n  vy.erase(unique(vy.begin(), vy.end()), vy.end());\n  REP(i,0,vx.size()){\n    zipx[vx[i]] = i;\n    unzipx[i] = vx[i];\n  }\n  REP(i,0,vy.size()){\n    zipy[vy[i]] = i;\n    unzipy[i] = vy[i];\n  }\n\n  //Initializing imos array\n  REP(i,0,5000)REP(j,0,5000) imos[i][j] = 0;\n  REP(i,0,n){\n    imos[zipy[ty[i]]][zipx[tx[i]]]++;\n  }\n  //creating imos array\n  REP(i,0,vy.size()){\n    REP(j,1,vx.size()){\n      imos[i][j] += imos[i][j-1];\n    }\n  }\n  REP(j,0,vx.size()){\n    REP(i,1,vy.size()){\n      imos[i][j] += imos[i-1][j];\n    }\n  }\n\n  REP(i,0,m){\n    vector<int>::iterator a1x = lower_bound(vx.begin(),vx.end(),p[i].F.X),\n      a1y = lower_bound(vy.begin(),vy.end(),p[i].F.Y),\n      a2x = upper_bound(vx.begin(),vx.end(),p[i].S.X)-1,\n      a2y = upper_bound(vy.begin(),vy.end(),p[i].S.Y)-1;\n    int z1x = zipx[*a1x], z1y = zipy[*a1y], z2x = zipx[*a2x], z2y = zipy[*a2y];\n    int ans = imos[z2y][z2x];\n    if(z1y > 0) ans -= imos[z1y-1][z2x];\n    if(z1x > 0) ans -= imos[z2y][z1x-1];\n    if(z1y > 0 && z1x > 0) ans += imos[z1y-1][z1x-1];\n    //fo exception\n    if(p[i].F.Y > unzipy[vy.size()-1] || p[i].F.X > unzipx[vx.size()-1]) cout<<0<<endl;\n    else cout<<ans<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <complex>\n#include <vector>\n#include <cstdio>\nusing namespace std;\ntypedef complex<int> point;\n\nstruct kdtree {\n  struct node {\n    point p;\n\tint id;\n    node *l, *r;\n    node(const point &p,int _id)\n      : p(p), l(NULL), r(NULL), id(_id) { }\n  } *root;\n  int id;\n  kdtree() : root(NULL), id(0) { }\n\n#define compare(d, p, q) (d ? real(p) < real(q) : imag(p) < imag(q))\n  void insert(const point &p) {\n    root = insert(root, 0, p);\n  }\n  node *insert(node *t, int d, const point &p) {\n    if (t == NULL) return new node(p,id++);\n    if (compare(d,p,t->p)) t->l = insert(t->l, !d, p);\n    else                   t->r = insert(t->r, !d, p);\n    return t;\n  }\n  void search(const point &ld, const point &ru, int &out) {\n    search(root, 0, ld, ru, out);\n  }\n  void search(node *t, int d, const point &ld, const point &ru, int &out) {\n    if (t == NULL) return;\n    const point &p = t->p;\n    if (real(ld) <= real(p) && real(p) <= real(ru) &&\n        imag(ld) <= imag(p) && imag(p) <= imag(ru)) out++;\n    if (!compare(d,p,ld)) search(t->l, !d, ld, ru, out);\n    if (!compare(d,ru,p)) search(t->r, !d, ld, ru, out);\n  }\n};\n\nint main(){\n\tint n,m,x1,x2,y1,y2;\n\tkdtree kd;\n\tfor(scanf(\"%d%d\",&n,&m);n--;){\n\t\tscanf(\"%d%d\",&x1,&y1);\n\t\tkd.insert(point(x1,y1));\n\t}\n\tfor(;m--;){\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tint out=0;\n\t\tkd.search(point(x1,y1),point(x2,y2),out);\n\t\tprintf(\"%d\\n\",out);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\nusing namespace std;\nusing P = pair<int, int>;\n\nmap<int, int> compress(vector<int> v) {\n  map<int, int> zip;\n  REP(i, v.size()) zip[v[i]] = -1;\n  int idx = 0;\n  for (auto& p : zip) p.second = idx++;\n  return zip;\n}\n\nint main() {\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(n);\n  vector<P> ps(n);\n  REP(i, n) {\n    cin >> x[i] >> y[i];\n    ps[i] = {x[i], y[i]};\n  }\n  x.push_back(-1e9 - 1);\n  y.push_back(-1e9 - 1);\n  x.push_back(1e9 + 1);\n  y.push_back(1e9 + 1);\n\n  auto zx = compress(x);\n  auto zy = compress(y);\n  vector<int> xs, ys;\n  for (auto p : zx) xs.push_back(p.first);\n  for (auto p : zy) ys.push_back(p.first);\n\n  vector<vector<int>> imos(xs.size() + 1, vector<int>(ys.size() + 1, 0));\n  for (auto p : ps) imos[zx[p.first] + 1][zy[p.second] + 1]++;\n\n  REP(i, xs.size() + 1) REP(j, ys.size()) imos[i][j + 1] += imos[i][j];\n  REP(i, xs.size()) REP(j, ys.size() + 1) imos[i + 1][j] += imos[i][j];\n\n  REP(i, m) {\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    int sx = distance(begin(xs), lower_bound(begin(xs), end(xs), x1));\n    int sy = distance(begin(ys), lower_bound(begin(ys), end(ys), y1));\n    int tx = distance(begin(xs), upper_bound(begin(xs), end(xs), x2));\n    int ty = distance(begin(ys), upper_bound(begin(ys), end(ys), y2));\n    int ans = 0;\n    ans += imos[sx][sy];\n    ans -= imos[tx][sy];\n    ans -= imos[sx][ty];\n    ans += imos[tx][ty];\n    cout << ans << endl;\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n//?¶??????????????????????\n\n#if 0\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,W;\nint32_t w[100];\nint32_t v[100];\n\nint dp[100][10001];\n//i??\\???????????????????????§??????capacity??????????????¶???????????°????????¨???????????§???\nint func(int i, int capacity)\n{\n\tif (capacity == 0) {\n\t\treturn 0;\n\t}\n\tif (i >= N) {\n\t\treturn 0;\n\t}\n\tif (dp[i][capacity] != -1) {\n\t\treturn dp[i][capacity];\n\t}\n\tint res = 0;\n\t//??\\??????\n\tif (capacity >= w[i]) { res = std::max(res, func(i + 1, capacity - w[i]) + v[i]); }\n\t//??\\?????????\n\tres = std::max(res, func(i + 1, capacity));\n\treturn dp[i][capacity] = res;\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>W;\n\tfor (int i = 0; i < N; i++)\n\t{\n\t\tin >> v[i] >> w[i];\n\t}\n\tbool used[100] = {};\n\tout << func(0, used)<<endl;\n\n\treturn 0;\n}\n#endif\n\n\n#if 1\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <queue>\n#include <stack>\n#include <array>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <cstdint>\n#include <functional>\n#include <iomanip>\n#include <numeric>\n#include <assert.h>\n\nauto& in = std::cin;\nauto& out = std::cout;\n\nint32_t N,Q;\n//Coordinate Compression\nusing INT_T = int32_t;\nconstexpr int32_t N_MAX = 10010;\nINT_T t_x[N_MAX];\nINT_T t_y[N_MAX];\nINT_T CC_X[N_MAX];\nauto CC_X_end = CC_X;\nINT_T CC_Y[N_MAX];\nauto CC_Y_end = CC_Y;\n\nvoid Init_CoordinateCompression(INT_T(&bace)[N_MAX], INT_T(&CC_buf)[N_MAX], INT_T*&CC_buf_end)\n{\n\tif (bace != CC_buf) {\n\t\tstd::copy_n(bace, N, CC_buf);\n\t\tfor (int i = 0; i < N; ++i)\n\t\t{\n\t\t\tCC_buf[N + i] = bace[i] - 1;\n\t\t}\n\t}\n\tCC_buf_end = CC_buf + 2 * N;\n\tstd::sort(CC_buf, CC_buf + 2*N);\n\t//CC_buf_end = std::unique(CC_buf, CC_buf_end);\n}\nINT_T get_coordinate(INT_T(&CC_buf)[N_MAX], INT_T* CC_buf_end, INT_T v)\n{\n\treturn std::lower_bound(CC_buf, CC_buf_end, v) - CC_buf + 1;\n}\nvoid Do_CoordinateCompression(INT_T(&bace)[N_MAX], INT_T(&CC_buf)[N_MAX], INT_T*&CC_buf_end)\n{\n\tInit_CoordinateCompression(bace, CC_buf, CC_buf_end);\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tbace[i] = get_coordinate(CC_buf, CC_buf_end, bace[i]);\n\t}\n}\n\nusing INT_T_CS = int16_t;\nINT_T_CS map[N_MAX][N_MAX];\ntemplate<typename ARR>\ninline void add_full(ARR& v1, ARR& v2)\n{\n\tv1 += v2;\n}\ntemplate<typename ARR, size_t N>\ninline void add_full(ARR(&v1)[N], ARR(&v2)[N])\n{\n\tauto iter1 = v1, iter2 = v2, iter1end = v1 + N;\n\twhile (iter1 != iter1end) {\n\t\tadd_full(*iter1++, *iter2++);\n\t}\n}\n//1-indexed?´???????\ntemplate<size_t N>void CuSum(INT_T_CS(&arr)[N])\n{\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tarr[i] += arr[i - 1];\n\t}\n}\ntemplate<typename ARR, size_t N>void CuSum(ARR(&arr)[N])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\n#if 0\ntemplate<size_t N, size_t M>void CuSum(INT_T_CS(&arr)[N][M])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\ntemplate<size_t N, size_t M, size_t O>void CuSum(INT_T_CS(&arr)[N][M][O])\n{\n\tfor (auto& arr2 : arr) {\n\t\tCuSum(arr2);\n\t}\n\n\tfor (size_t i = 2; i < N; i++)\n\t{\n\t\tadd_full(arr[i], arr[i - 1]);\n\t}\n}\n#endif\n//1-indexed???(]??????\ntemplate<size_t N> INT_T_CS get_sum(INT_T_CS(&arr)[N], int x, int x2)\n{\n\treturn (arr[x2] - arr[x]);\n}\n//1-indexed???(]??????\ntemplate<size_t N, size_t M> INT_T_CS get_sum(INT_T_CS(&arr)[N][M], int x, int y, int x2, int y2)\n{\n\treturn (arr[y2][x2] - arr[y][x2] - arr[y2][x] + arr[y][x]);\n}\n//1-indexed???(]??????\ntemplate<size_t N, size_t M, size_t O> INT_T_CS get_sum(INT_T_CS(&arr)[N][M][O], int x, int y, int z, int x2, int y2, int z2)\n{\n\treturn (arr[z2][y2][x2] - arr[z][y2][x2] - arr[z2][y][x2] - arr[z2][y2][x] + arr[z2][y][x] + arr[z2][y][x] + arr[z][y][x2] - arr[z][y][x]);\n}\n\nint main()\n{\n\tusing std::endl;\n\tin.sync_with_stdio(false);\n\tout.sync_with_stdio(false);\n\n\tin >> N>>Q;\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\tin >> t_x[i]>>t_y[i];\n\t}\n\tDo_CoordinateCompression(t_x, CC_X, CC_X_end);\n\tDo_CoordinateCompression(t_y, CC_Y, CC_Y_end);\n\tfor (int32_t i = 0; i < N; ++i)\n\t{\n\t\t++map[t_y[i]][t_x[i]];\n\t}\n\tCuSum(map);\n\twhile (Q--)\n\t{\n\t\tint x, y, x2, y2;\n\t\tin >> x >> y >> x2 >> y2;\n\t\tx = get_coordinate(CC_X,CC_X_end, x); --x;\n\t\tx2 = get_coordinate(CC_X, CC_X_end, x2);\n\t\ty = get_coordinate(CC_Y, CC_Y_end, y); --y;\n\t\ty2 = get_coordinate(CC_Y, CC_Y_end, y2);\n\t\tout << get_sum(map, x, y, x2, y2)<<endl;\n\t}\n\n\treturn 0;\n}\n#endif"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\n\nint sum[6000][6000];\nint X[5000], Y[5000];\nint X1[5000], X2[5000], Y1[5000], Y2[5000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn v.size();\n}\nint main() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n)scanf(\"%d%d\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%d%d%d%d\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (int j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (int i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\tif (m < 0)abort();\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint A[10010][2];\nint S[10010][10010];\nint ANS = 0;\nint *R;\nint Xs[10010], Ys[10010];\nmap<int,int> zipx, zipy;\nint unzipx[10010], unzipy[10010];\nint MAX = 1000000001;\n\nint compress(int *X, map<int, int> &zip, int *unzip, int n) {\n    sort(X, X + n);\n    R = unique(X, X + n);\n\tint k = R - X;\n    for(int i = 0; i < k; i++){\n        zip[X[i]] = i;\n        unzip[i] = X[i];\n    }\n    return k;\n}\n\nint main(){\n\tint N, M, x1, y1, x2, y2, xn, yn, ans;\n\tcin >> N >> M;\n\tfor (int n = 0; n < N; n++) {\n\t\tcin >> x1 >> y1;\n\t\tA[n][0] = x1; A[n][1] = y1;\n\t\tXs[n * 2] = x1;\n\t\tXs[n * 2 + 1] = x1 - 1;\n\t\tYs[n * 2] = y1;\n\t\tYs[n * 2 + 1] = y1 - 1;\n\t}\n\t\n\tXs[N * 2] = -1 * MAX;\n\tXs[N * 2 + 1] = MAX;\n\tYs[N * 2] = -1 * MAX;\n\tYs[N * 2 + 1] = MAX;\n\t\n\txn = compress(Xs, zipx, unzipx, N * 2 + 2);\n\tyn = compress(Ys, zipy, unzipy, N * 2 + 2);\n\t\n\t\n\tfor (int n = 0; n < N; n ++) {\n\t\tx1 = zipx[A[n][0]];\n\t\ty1 = zipy[A[n][1]];\n\t\tS[x1][y1] ++;\n\t}\n\t\n\tfor (int x = 1; x <= xn; x++) {\n\t\tfor (int y = 1; y <= yn; y ++) {\n\t\t\tS[x][y] += S[x - 1][y] + S[x][y - 1] - S[x - 1][y - 1];\n\t\t}\n\t}\n\tfor (int m = 0; m < M; m ++) {\n\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\n\t\tx1 = *lower_bound(Xs, Xs + xn, x1 - 1);\n\t\ty1 = *lower_bound(Ys, Ys + yn, y1 - 1);\n\t\tx2 = *lower_bound(Xs, Xs + xn, x2);\n\t\ty2 = *lower_bound(Ys, Ys + yn, y2);\n\t\t\n\t\tx1 = zipx[x1];\n\t\tx2 = zipx[x2];\n\t\ty1 = zipy[y1];\n\t\ty2 = zipy[y2];\n\t\t\n\t\tans = S[x2][y2] - S[x1][y2] - S[x2][y1] + S[x1][y1];\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t/*for (int i = 0; i < 10 ;i ++ ) {\n\t\tfor (int j = 0; j < 10; j++) {\n\t\t\tcout << S[i][j];\n\t\t}\n\t\tcout << endl;\n\t}*/\n\t\n}\n"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_; std::vector<std::vector<Type> > dat;\n\tinline int query_(int a, int b, Type x, int k, int l, int r) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r)\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return lower_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::vector<Type>());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_] = std::vector<Type>({ *(begin_ + i) });\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tint cl = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][j - cl])) {\n\t\t\t\t\tdat[i][j] = dat[i << 1][cl++];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tdat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\treturn query_(l, r, x, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<set>\n#include<algorithm>\nusing namespace std;\ntypedef pair<int,int> P;\n#define X first\n#define Y second\nint main()\n{\n  int n,m;\n  int x1,y1,x2,y2;\n  multiset<P> point;\n  multiset<P>::iterator it;\n  cin>>n>>m;\n  for(int i=0; i<n; i++){\n    cin>>x1>>y1;\n    point.insert(P(x1,y1));\n  }\n  point.insert(P(1000000001,1000000001));\n  for(int j=0; j<m; j++){\n    cin>>x1>>y1>>x2>>y2;\n    int cnt=0;\n    for(it=lower_bound(point.begin(),point.end(),P(x1,y1)); (*it).X<=x2; it++){\n      if((*it).Y<y1)continue;\n      if((*it).Y>y2)continue;\n      cnt++;\n    }\n    cout<<cnt<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define rep(i,n)for(long long i=0;i<n;i++)\nusing namespace std;\n\nint sum[5000][5000];\nint X[5000], Y[5000];\nint X1[500000], X2[500000], Y1[500000], Y2[500000];\nint n, m;\n\nint compress(int*x, int*X1, int*X2) {\n\tvector<int>v;\n\trep(i, n)v.push_back(x[i]);\n\tsort(v.begin(), v.end());\n\tv.erase(unique(v.begin(), v.end()), v.end());\n\trep(i, m) {\n\t\tX1[i] = lower_bound(v.begin(), v.end(), X1[i]) - v.begin();\n\t\tX2[i] = upper_bound(v.begin(), v.end(), X2[i]) - v.begin() - 1;\n\t}\n\trep(i, n) {\n\t\tx[i] = lower_bound(v.begin(), v.end(), x[i]) - v.begin();\n\t}\n\treturn (int)v.size();\n}\nsigned main() {\n\tscanf(\"%lld%lld\", &n, &m);\n\trep(i, n)scanf(\"%lld%lld\", &X[i], &Y[i]);\n\trep(i, m)scanf(\"%lld%lld%lld%lld\", &X1[i], &Y1[i], &X2[i], &Y2[i]);\n\tint h = compress(X, X1, X2), w = compress(Y, Y1, Y2);\n\trep(i, n)sum[X[i]][Y[i]]++;\n\trep(i, h + 1)for (long long j = 1; j <= w; j++) {\n\t\tsum[i][j] += sum[i][j - 1];\n\t}\n\tfor (long long i = 1; i <= h; i++)rep(j, w + 1) {\n\t\tsum[i][j] += sum[i - 1][j];\n\t}\n\trep(i, m) {\n\t\tif (X2[i] < 0 || Y2[i] < 0) {\n\t\t\tputs(\"0\"); continue;\n\t\t}\n\t\tint ans = sum[X2[i]][Y2[i]];\n\t\tif (X1[i] > 0)ans -= sum[X1[i] - 1][Y2[i]];\n\t\tif (Y1[i] > 0)ans -= sum[X2[i]][Y1[i] - 1];\n\t\tif (X1[i] > 0 && Y1[i] > 0)ans += sum[X1[i] - 1][Y1[i] - 1];\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\ntypedef int Data;\npair<vector<int>,vector<int>> compressor(vector<Data> c) {\n  int n = c.size();\n  vector<Data> v(c), w;\n  vector<int> res(n);\n  sort(v.begin(), v.end());\n  auto itr = unique(begin(v),end(v));\n  v.erase(itr,end(v));\n  REP(i,v.size()) w.push_back(v[i]);\n  REP(i,n) res[i] = lower_bound(w.begin(), w.end(), c[i]) - w.begin();\n  return make_pair(v,res);\n}\n\nint main() {\n  int n,m;\n  cin>>n>>m;\n  vector<int> x(n),y(n),x1(m),x2(m),y1(m),y2(m);\n  REP(i,n)\n    cin>>x[i]>>y[i];\n  REP(i,m)\n    cin>>x1[i]>>y1[i]>>x2[i]>>y2[i];\n  vector<int> xl;\n  vector<int> yl;\n  REP(i,n){\n    xl.push_back(x[i]);\n    yl.push_back(y[i]);\n  }\n  vector<int> cmpx,cmpy,sxl,syl;\n  tie(sxl, cmpx) = compressor(xl);\n  tie(syl, cmpy) = compressor(yl);\n  sxl.insert(begin(sxl),-1000000001);\n  syl.insert(begin(syl),-1000000001);\n  int w=sxl.size();\n  int h=syl.size();\n  vector<vector<int16_t>> t(h,vector<int16_t>(w));\n  REP(i,n)\n    ++t[cmpy[i]][cmpx[i]];\n  vector<vector<int16_t>> t2(h+1,vector<int16_t>(w+1));\n  REP(i,h) {\n    vector<int16_t> t1(w+1);\n    partial_sum(begin(t[i]),end(t[i]),begin(t1)+1);\n    REP(j,w+1){\n      t2[i+1][j] = t2[i][j] + t1[j];\n    }\n  }\n  REP(i,m){\n    int xi1,yi1,xi2,yi2;\n    xi1=prev(lower_bound(begin(sxl),end(sxl),x1[i]))-begin(sxl);\n    yi1=prev(lower_bound(begin(syl),end(syl),y1[i]))-begin(syl);\n    xi2=prev(upper_bound(begin(sxl),end(sxl),x2[i]))-begin(sxl);\n    yi2=prev(upper_bound(begin(syl),end(syl),y2[i]))-begin(syl);\n    cout<<(t2[yi2][xi2]-t2[yi2][xi1]-t2[yi1][xi2]+t2[yi1][xi1])<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit\n#include <cstdio>\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n#define DEBUG 0\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nstring FILE_NAME = \"testcase.TH\";\nstring NAME;\nstring itos (int n )\n{\n\tstringstream ss;\n\tss << n;\n\n\treturn ss.str();\n}\nset<int> x, y;\t\t// 座標全体\nvector<int> xx, yy;\t// 圧縮した座標→元の座標\n//vector<int>rx, ry;\t// 圧縮した座標→元の座標の変換テーブル\n\nvoid compress (void ) \n{\n\txx.clear(); yy.clear();\n//\trx.clear(); ry.clear();\n\tint sx = x.size();\n\tint sy = y.size();\n\txx.resize (sx, 0 ); yy.resize (sy, 0 );\n\tset<int>::iterator it = x.begin();\n\tfor(int i = 0; it != x.end(); i++, it++ ){\n\t\tint curr = (*it);\n\t\txx[i] = curr;\n//\t\txx[curr] = i;\n//\t\trx[i] = curr;\n\t} // end for\n\n\tset<int>::iterator jt = y.begin();\n\tfor (int j = 0; jt != y.end(); j++, jt++ ){\n\t\tint curr = (*jt);\n\t\tyy[j] = curr;\n//\t\tyy[curr] = j;\n//\t\try[j] = curr;\n\t} // end for\n}\n\nint main()\n{\n//\tcut here before submit \n#if DEBUG\n\tNAME = FILE_NAME;\n\tint CNT = 1;\n\tNAME += itos (CNT );\n\twhile (freopen (NAME.c_str() , \"r\", stdin ) != NULL ) {\n#endif\n\tint n, m;\n\tscanf (\"%d %d\", &n, &m );\n\tmap<P,int> cnt; cnt.clear();\n\tx.clear(); y.clear();\n\tvector<int> tx (n, 0 ), ty (n, 0 );\n\trep (i, n ){\n\t\tscanf (\"%d %d\", &tx[i], &ty[i] );\n\t\tcnt[P(tx[i],ty[i])]++;\n\t\tfor (int d = -1; d <= 1; d++ ){\n\t\t\tx.insert (tx[i]+d ); y.insert (ty[i]+d );\n\t\t} // end for\n\t} // end rep\n\tvector<int> x1 (m, 0 ), y1 (m, 0 ), x2 (m, 0 ), y2 (m, 0 );\n\trep (j, m ){\n\t\tscanf (\"%d %d %d %d\", &x1[j], &y1[j], &x2[j], &y2[j] );\n\t\tfor (int d = -1; d <= 1; d++ ){\n\t\t\tx.insert (x1[j]+d ); x.insert (x2[j]+d );\n\t\t\ty.insert (y1[j]+d ); y.insert (y2[j]+d );\n\t\t} // end for\n\t} // end rep \n\tcompress ();\n\n\trep (j, m ){\n\t\tint res = 0;\n\t\tfor (int cy = lower_bound (ALL (yy ), y1[j] ) - yy.begin(); cy <= lower_bound ( ALL(yy ), y2[j] ) - yy.begin(); cy++ ){\n\t\t\tfor (int cx = lower_bound (ALL (xx ), x1[j] ) - xx.begin(); cx <= lower_bound (ALL (xx ), x2[j] ) - xx.begin(); cx++ ){\n\t\t\t\tint ttx = xx[cx], tty = yy[cy];\n\t\t\t\tres += cnt[P(ttx, tty )];\n\t\t\t} // end for\n\t\t} // end for\n\t\tprintf (\"%d\\n\", res );\n\t} // end rep\n\n#if DEBUG\n\tCNT++;\t// cut here before submit\n\tNAME = FILE_NAME;\n\tNAME += itos (CNT );\n\t} // end loop; cut here before submit\n#endif\t\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct Point{\n  int x,y;\n  bool operator<(const Point & p) const{\n    return x < p.x; \n  }\n};\nint main(){\n  int n,m;cin>>n>>m;\n  int i,j,k;\n  Point p[n];\n  for(i=0;i<n;i++) scanf(\"%d %d\",&p[i].x,&p[i].y);\n  sort(p,p+n);\n  int sx,sy,tx,ty;\n  for(i=0;i<m;i++){\n    scanf(\"%d %d %d %d\",&sx,&sy,&tx,&ty);\n    int ans = 0;\n    for(j=0;j<n;j++) {\n      if(sx<=p[j].x&&p[j].x<=tx&&sy<=p[j].y&&p[j].y<=ty){\n\tans++;\n      }\n      if(tx<p[j].x) break;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_; std::vector<std::vector<Type> > dat;\n\tinline int query_(int a, int b, Type x, int k, int l, int r) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r)\n\t\tif (r <= a || b <= l) return 0;\n\t\tif (a <= l && r <= b) return lower_bound(dat[k].begin(), dat[k].end(), x) - dat[k].begin();\n\t\tint lc = query_(a, b, x, (k << 1), l, (l + r) >> 1);\n\t\tint rc = query_(a, b, x, (k << 1) + 1, (l + r) >> 1, r);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1); dat.resize(size_ << 1, std::vector<Type>());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_] = std::vector<Type>({ *(begin_ + i) });\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[(i << 1) + 1].size());\n\t\t\tstd::merge(dat[i << 1].begin(), dat[i << 1].end(), dat[(i << 1) + 1].begin(), dat[(i << 1) + 1].end(), dat[i].begin());\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\treturn query_(l, r, x, 1, 0, size_);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = upper_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//27\n//19\n#include<iostream>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  int n,m;\n  cin>>n>>m;\n  int x[5000],y[5000];\n  vector<int> xp(n),yp(n);\n  for(int i=0;i<n;i++){\n    cin>>x[i]>>y[i];\n    xp[i]=x[i];\n    yp[i]=y[i];\n  }\n  sort(xp.begin(),xp.end());\n  sort(yp.begin(),yp.end());\n  xp.erase(unique(xp.begin(),xp.end()),xp.end());\n  yp.erase(unique(yp.begin(),yp.end()),yp.end());\n  vector<vector<int> > g(yp.size(),vector<int>(xp.size()));\n  for(int i=0;i<n;i++){\n    g[lower_bound(yp.begin(),yp.end(),y[i])-yp.begin()]\n      [lower_bound(xp.begin(),xp.end(),x[i])-xp.begin()]++;\n  }\n  vector<vector<int> > ag(yp.size()+1,vector<int>(xp.size()+1));\n  for(int i=0;i<yp.size();i++){\n    for(int j=0;j<xp.size();j++){\n      ag[i+1][j+1]=ag[i][j+1]+ag[i+1][j]-ag[i][j]+g[i][j];\n    }\n  }\n  while(m--){\n    int xl,yl,xh,yh;\n    cin>>xl>>yl>>xh>>yh;\n    int xxl,yyl,xxh,yyh;\n    xxl=lower_bound(xp.begin(),xp.end(),xl)-xp.begin();\n    yyl=lower_bound(yp.begin(),yp.end(),yl)-yp.begin();\n    xxh=upper_bound(xp.begin(),xp.end(),xh)-xp.begin();\n    yyh=upper_bound(yp.begin(),yp.end(),yh)-yp.begin();\n    cout<<ag[yyh][xxh]-ag[yyh][xxl]-ag[yyl][xxh]+ag[xxl][yyl]<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef ___Class_RangeTree\n#define ___Class_RangeTree\n\n// ------ Includes ------ //\n#include <limits>\n#include <vector>\n#include <algorithm>\n\ntemplate<typename Type> class RangeTree {\nprivate:\n\tint size_;\n\tstd::vector<std::vector<Type> > dat;\n\tstd::vector<std::vector<int> > vl;\n\tinline int query_(int a, int b, Type x, int k, int l, int r, int e) {\n\t\t// Find range [a, b) : value < x : Now k-th node and the range is [l, r) and e integers below x in the range\n\t\tif (r <= a || b <= l || e == 0) return 0;\n\t\tif (a <= l && r <= b) return e;\n\t\tint lc = query_(a, b, x, k << 1, l, (l + r) >> 1, vl[k][e - 1]);\n\t\tint rc = query_(a, b, x, k << 1 | 1, (l + r) >> 1, r, e - vl[k][e - 1]);\n\t\treturn lc + rc;\n\t}\npublic:\n\tRangeTree() : size_(0), dat(std::vector<Type>()) {};\n\ttemplate<class T>\n\tRangeTree(T begin_, T end_) {\n\t\tint n = (end_ - begin_);\n\t\tfor (size_ = 1; size_ < n; size_ <<= 1);\n\t\tdat.resize(size_ << 1, std::vector<Type>());\n\t\tvl.resize(size_, std::vector<int>());\n\t\tfor (int i = 0; i < n; i++) dat[i + size_].push_back(*(begin_ + i));\n\t\tfor (int i = size_ - 1; i > 0; i--) {\n\t\t\tdat[i].resize(dat[i << 1].size() + dat[i << 1 | 1].size());\n\t\t\tvl[i].resize(dat[i].size());\n\t\t\tint cl = 0;\n\t\t\tfor (int j = 0; j < dat[i].size(); j++) {\n\t\t\t\tif (j - cl == dat[i << 1 | 1].size() || (cl != dat[i << 1].size() && dat[i << 1][cl] < dat[i << 1 | 1][j - cl])) dat[i][j] = dat[i << 1][cl++];\n\t\t\t\telse dat[i][j] = dat[i << 1 | 1][j - cl];\n\t\t\t\tvl[i][j] = cl;\n\t\t\t}\n\t\t}\n\t}\n\tinline int size() { return size_; }\n\tinline int query(int l, int r, Type x) {\n\t\t// Find range [a, b) : value < x\n\t\tint ptr = lower_bound(dat[1].begin(), dat[1].end(), x) - dat[1].begin();\n\t\treturn query_(l, r, x, 1, 0, size_, ptr);\n\t}\n};\n\n#endif\n\n#include <cstdio>\n#include <vector>\n#pragma warning(disable : 4996)\nusing namespace std;\nint N, Q, xl, yl, xr, yr;\nint main() {\n\tscanf(\"%d%d\", &N, &Q);\n\tvector<pair<int, int> > p(N);\n\tfor (int i = 0; i < N; i++) scanf(\"%d%d\", &p[i].first, &p[i].second);\n\tsort(p.begin(), p.end());\n\tvector<int> z1(N), z2(N);\n\tfor (int i = 0; i < N; i++) {\n\t\tz1[i] = p[i].first;\n\t\tz2[i] = p[i].second;\n\t}\n\tRangeTree<int> seg(z2.begin(), z2.end());\n\twhile (Q--) {\n\t\tscanf(\"%d%d%d%d\", &xl, &yl, &xr, &yr);\n\t\tint ptr1 = lower_bound(z1.begin(), z1.end(), xl) - z1.begin();\n\t\tint ptr2 = lower_bound(z1.begin(), z1.end(), xr + 1) - z1.begin();\n\t\tint res1 = seg.query(ptr1, ptr2, yl);\n\t\tint res2 = seg.query(ptr1, ptr2, yr + 1);\n\t\tprintf(\"%d\\n\", res2 - res1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <algorithm>\n\n#define REP(i,k,n) for(int i=k;i<n;i++)\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\ntypedef long long ll;\n\nint T[5005][5005];\n\nint main() {\n    int n,m;\n    cin >> n >> m;\n\n    vector<int> x(n),y(n),vx(n),vy(n);\n    rep(i,n) {\n        cin >> x[i] >> y[i];\n        vx[i] = x[i];\n        vy[i] = y[i];\n    }\n\n    sort(vx.begin(),vx.end());\n    sort(vy.begin(),vy.end());\n\n    vx.erase(unique(vx.begin(),vx.end()),vx.end());\n    vy.erase(unique(vy.begin(),vy.end()),vy.end());\n    \n\n    rep(i,n) {\n        x[i] = lower_bound(vx.begin(),vx.end(),x[i]) - vx.begin();\n        y[i] = lower_bound(vy.begin(),vy.end(),y[i]) - vy.begin();\n    }\n\n    memset(T,0,sizeof(T));\n    rep(i,n) {\n        T[x[i]+1][y[i]+1]++;\n    }\n\n    int h = vx.size();\n    int w = vy.size();\n\n    rep(i,h+1) {\n        REP(j,1,w+1) {\n            T[i][j] += T[i][j-1];\n        }\n    }\n    \n    REP(i,1,h+1) {\n        rep(j,w+1) {\n            T[i][j] += T[i-1][j];\n        }\n    }\n\n\n    rep(i,m) {\n        int x1,y1,x2,y2;\n        cin >> x1 >> y1 >> x2 >> y2;\n\n        int nx1 = lower_bound(vx.begin(),vx.end(),x1) - vx.begin();\n        int ny1 = lower_bound(vy.begin(),vy.end(),y1) - vy.begin();\n\n        int nx2 = upper_bound(vx.begin(),vx.end(),x2) - vx.begin();\n        int ny2 = upper_bound(vy.begin(),vy.end(),y2) - vy.begin();\n        \n        // cout << T[nx2][ny2] << endl;\n        // cout << T[nx1][ny2] << endl;\n        // cout << T[nx2][ny1] << endl;\n        // cout << T[nx1][ny1] << endl;\n\n        cout << T[nx2][ny2] - T[nx1][ny2] - T[nx2][ny1] + T[nx1][ny1] << endl;\n        \n    }\n\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nstruct Point : public complex<double>\n{\npublic:\n  Point(const double x = 0.0, const double y = 0.0) { this->real(x);  this->imag(y); }\n  Point(const complex<double> w)  { this->real(w.real());  this->imag(w.imag()); }\n  inline double dot(Point p){ return (conj(*this) * p).real(); }  // ??????\n  inline double det(Point p){ return (conj(*this) * p).imag(); }  // ??????\n};\n\nnamespace std\n{\n  inline bool operator < (const Point& a, const Point& b)\n  {\n    return real(a) != real(b) ? real(a) < real(b) : imag(a) < imag(b);\n  }\n}\ntypedef vector<Point> Polygon;\ninline Point currPoint(vector<Point> P, int i){ return P[i]; }\ninline Point nextPoint(vector<Point> P, int i){ return P[(i+1)%P.size()]; }\ninline Point diffPoint(vector<Point> P, int i){ return nextPoint(P, i) - currPoint(P, i); }\n\nstruct KDTree\n{\npublic:\n  struct Node\n  {\n    Point p;\n    Node *l, *r;\n    Node(const Point &p)\n      : p(p), l(NULL), r(NULL) { }\n  } *root;\n  KDTree() : root(NULL) {}\n  inline bool compare(int d, Point p, Point q){ return d ? real(p) < real(q) : imag(p) < imag(q); }\n  inline void insert(const Point& p){ root = insert(root, 0, p); }\n  Node* insert(Node* t, int d, const Point& p){\n    if(t == NULL) return new Node(p);\n    if(compare(d,p,t->p)) t->l = insert(t->l, !d, p);\n    else                  t->r = insert(t->r, !d, p);\n    return t;\n  }\n\n  template<class T> int search(Point& ld, Point& ru, T r, int s = 0){ return search(root, 0, ld, ru, r, s); }\n  template<class T> int search(Node* t, int d, const Point& ld, const Point& ru, T r, int& size){\n    if (t == NULL) return size;\n    const Point& p = t->p;\n    if (real(ld) <= real(p) && real(p) <= real(ru) &&\n        imag(ld) <= imag(p) && imag(p) <= imag(ru)) r[size++] = p;\n    if (!compare(d,p,ld)) search(t->l, !d, ld, ru, r, size);\n    if (!compare(d,ru,p)) search(t->r, !d, ld, ru, r, size);\n    return size;\n  }\n};\n\nint n, m;\ndouble x, y;\nKDTree kd;\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n){\n    cin >> x >> y;\n    kd.insert(Point(x, y));\n  }\n\n  rep(i, m){\n    cin >> x >> y;\n    Point P = Point(x, y);\n    cin >> x >> y;\n    Point Q = Point(x, y);\n    Point Points[5555];\n    cout << kd.search(P, Q, Points) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\nvoid uniqueVector(vector< int >& vec) {\n\tsort(allof(vec));\n\tvec.erase(unique(allof(vec)), vec.end());\n}\n\nvoid solve(\n\tint n, int m,\n\tconst vector< int >& tx, const vector< int >& ty,\n\tconst vector< int >& lft, const vector< int >& bot,\n\tconst vector< int >& rgt, const vector< int >& top\n\t) {\n\tvector< int > x_sort = tx, y_sort = ty;\n\tuniqueVector(x_sort);\n\tuniqueVector(y_sort);\n\t\n\tvector< vector< int > > imos(n + 1, vector< int >(n + 1, 0));\n\tfor_(i,0,n) {\n\t\tint x = lower_bound(allof(x_sort), tx[i]) - x_sort.begin() + 1;\n\t\tint y = lower_bound(allof(y_sort), ty[i]) - y_sort.begin() + 1;\n\t\t++imos[y][x];\n\t}\n\t\n\tfor_(y,0,n+1) for_(x,0,n) imos[y][x + 1] += imos[y][x];\n\tfor_(x,0,n+1) for_(y,0,n) imos[y + 1][x] += imos[y][x];\n\t\n\tfor_(i,0,m) {\n\t\tint lx = lower_bound(allof(x_sort), lft[i]) - x_sort.begin() + 1;\n\t\tint by = lower_bound(allof(y_sort), bot[i]) - y_sort.begin() + 1;\n\t\tint rx = upper_bound(allof(x_sort), rgt[i]) - x_sort.begin();\n\t\tint ty = upper_bound(allof(y_sort), top[i]) - y_sort.begin();\n\t\t\n\t\tprintf(\"%d\\n\", imos[ty][rx] - imos[ty][lx - 1] - imos[by - 1][rx] + imos[by - 1][lx - 1]);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tassert(scanf(\"%d %d\", &n, &m) == 2);\n\t\n\tvector< int > tx(n), ty(n);\n\tfor_(i,0,n) assert(scanf(\"%d %d\", &tx[i], &ty[i]) == 2);\n\t\n\tvector< int > lft(m), bot(m), rgt(m), top(m);\n\tfor_(i,0,m) assert(scanf(\"%d %d %d %d\", &lft[i], &bot[i], &rgt[i], &top[i]) == 4);\n\t\n\tsolve(n, m, tx, ty, lft, bot, rgt, top);\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <utility>\n#include <set>\n#include <map>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <functional>\n\nusing namespace std;\n\n#define fst first\n#define scd second\n#define PB push_back\n#define MP make_pair\n#define all(a) a.begin(),a.end()\n#define rall(a) a.rbegin(),a.rend()\n#define omajinai ios::sync_with_stdio(false);cin.tie(0)\n#define rep(i,x) for(int i=0;i<(int)(x);++i)\n#define rep1(i,x) for(int i=1;i<=(int)(x);++i)\n\nusing ll=long long;\nusing ld=long double;\nusing vi=vector<int>;\nusing vvi=vector<vi>;\nusing pii=pair<int, int>;\nusing vpii=vector<pii>;\n\ntemplate<class T,class U>ostream&operator<<(ostream&os,const pair<T,U>p){os<<\"(\"<<p.fst<<\", \"<<p.scd<<\")\";return os;}\ntemplate<class T>ostream&operator<<(ostream&os,const vector<T>v){rep(i,v.size()){if(i)os<<\", \";os<<v[i];}return os;}\ntemplate<typename T>T&max(T&a,T&b){if(a>=b)return a;return b;}\ntemplate<typename T>T&min(T&a,T&b){if(a < b)return a;return b;}\ntemplate<typename T>bool chmax(T&a,T b){if(a < b){a=b;return true;}return false;}\ntemplate<typename T>bool chmin(T&a,T b){if(a > b){a=b;return true;}return false;}\n\nconstexpr int inf = 1e9;\nconstexpr ll linf = 3e18;\nconstexpr double eps = 1e-9;\n\nint n, m;\n\nint x[5005], y[5005];\nvi compressed_x, compressed_y;\n\nint a[5005][5005];\n\nint main()\n{\n    scanf(\"%d%d\",&n,&m);\n\n    rep(i, n) {\n        scanf(\"%d%d\",x+i,y+i);\n        compressed_x.PB(x[i]);\n        compressed_y.PB(y[i]);\n    }\n\n    sort(all(compressed_x));\n    sort(all(compressed_y));\n\n    compressed_x.erase(unique(all(compressed_x)), end(compressed_x));\n    compressed_y.erase(unique(all(compressed_y)), end(compressed_y));\n\n    rep(i, n) {\n        int xidx = lower_bound(all(compressed_x), x[i]) - begin(compressed_x);\n        int yidx = lower_bound(all(compressed_y), y[i]) - begin(compressed_y);\n\n        a[yidx][xidx]++;\n    }\n\n    for (int i = 0; i < compressed_y.size()+1; ++i) {\n        for (int j = 0; j < compressed_x.size()+1; ++j) {\n            if (i - 1 >= 0) a[i][j] += a[i - 1][j];\n        }\n    }\n\n    for (int i = 0; i < compressed_x.size()+1; ++i) {\n        for (int j = 0; j < compressed_y.size()+1; ++j) {\n            if (i - 1 >= 0) a[j][i] += a[j][i - 1];\n        }\n    }\n\n    compressed_x.PB(inf);\n    compressed_y.PB(inf);\n\n    rep(i, m) {\n        int x1, y1, x2, y2; scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\n        x1 = lower_bound(all(compressed_x), x1) - begin(compressed_x);\n        x2 = upper_bound(all(compressed_x), x2) - begin(compressed_x) - 1;\n        y1 = lower_bound(all(compressed_y), y1) - begin(compressed_y);\n        y2 = upper_bound(all(compressed_y), y2) - begin(compressed_y) - 1;\n\n        if (x2 < 0 || y2 < 0) {\n            printf(\"0\\n\");\n            continue;\n        }\n\n        int ans = 0;\n        ans += a[y2][x2];\n        if (y1 - 1 >= 0) ans -= a[y1 - 1][x2];\n        if (x1 - 1 >= 0) ans -= a[y2][x1 - 1];\n        if (y1 - 1 >= 0 && x1 - 1 >= 0) ans += a[y1 - 1][x1 - 1];\n        \n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <numeric>\n#include <map>\n#include <vector>\n#include <iostream>\n\nusing namespace std;\nint sum[5200][5200];\n\ntemplate <typename T,typename Func>\n\tT satisfy_min(Func P,T l ,T r,T eps){\n\t\twhile(r-l>eps){\n\t\t\tT m=(l+r)/2;\n\t\t\t(P(m)?r:l)=m;\n\t\t}\n\t\treturn r;\n\t}\n\n\nint main() {\n\t\n\t\tint n, m;\n\t\tscanf(\"%d%d\", &n, &m);\n\t\t\n\t\tfor (int i = 0; i < 5200; i++) {\n\t\t\tfor (int j = 0; j < 5200; j++) {\n\t\t\t\tsum[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\tint x[n], y[n];\n\t\tvector<int> xs, ys;\n\t\txs.push_back(-1100000000);\n\t\tys.push_back(-1100000000);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tcin >> x[i];\n\t\t\tcin >> y[i];\n\t\t\txs.push_back(x[i]);\n\t\t\tys.push_back(y[i]);\n\t\t}\n\t\txs.push_back(1100000000);\n\t\tys.push_back(1100000000);\n\t\tsort(xs.begin(), xs.end());\n\t\tsort(ys.begin(), ys.end());\n\t\txs.erase(unique(xs.begin(), xs.end()), xs.end());\n\t\tys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint nx = lower_bound(xs.begin(), xs.end(), x[i]) -xs.begin();\n\t\t\tint ny = lower_bound(ys.begin(), ys.end(), y[i]) -ys.begin();\n\t\t\tsum[nx][ny]++;\n\t\t}\n\n\t\tfor (int i = 1; i < 5200; i++) {\n\t\t\tfor (int j = 1; j < 5200; j++) {\n\t\t\t\tsum[i][j] += sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x1, y1, x2, y2;\n\t\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\t\tint nx2 = upper_bound(xs.begin(), xs.end(), x2) -xs.begin();\n\t\t\tint nx1 = lower_bound(xs.begin(), xs.end(), x1) -xs.begin();\n\t\t\tint ny2 = upper_bound(ys.begin(), ys.end(), y2) -ys.begin();\n\t\t\tint ny1 = lower_bound(ys.begin(), ys.end(), y1) -ys.begin();\n\t\t\tnx2--; ny2--;\n\t\t\tny1--; nx1--;\n\t\t\tprintf(\"%d\\n\", sum[nx2][ny2]-sum[nx2][ny1]-sum[nx1][ny2]+sum[nx1][ny1]);\n\t\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n\nint mp[5005][5005],n,m;\n\nint t[5005][5005];\n\nvector<int> x,y;\n\nvector<int> compress(vector<int> v){\n  vector<int> copy=v;\n  sort(v.begin(), v.end());\n  v.erase( unique( v.begin(), v.end()) , v.end() );\n  vector<int> res;\n  for(int i=0;i<(int)copy.size();i++){\n    int num=lower_bound( v.begin(),v.end(), copy[i] ) - v.begin();\n    res.push_back( num );\n  }\n  return res;\n}\n\nint sum(int sx,int sy,int gx,int gy){\n  return t[gx][gy]-t[sx][gy]-t[gx][sy]+t[sx][sy];\n}\n\nint main(){\n  cin>>n>>m;\n  x.resize(n),y.resize(n);\n  for(int i=0;i<n;i++)cin>>x[i]>>y[i];\n  vector<int> X,Y;\n  X=compress(x),Y=compress(y);\n  for(int i=0;i<n;i++)mp[X[i]][Y[i]]++;\n\n  for(int i=0;i<n;i++)\n    for(int j=0;j<n;j++)\n      t[i+1][j+1]=mp[i][j] + t[i+1][j] + t[i][j+1] - t[i][j];\n  \n  sort(x.begin(),x.end());\n  sort(y.begin(),y.end());\n  x.erase( unique( x.begin(), x.end()) , x.end() );\n  y.erase( unique( y.begin(), y.end()) , y.end() );\n  while(m--){\n    int a,b,c,d;\n    cin>>a>>b>>c>>d;\n    int sx=lower_bound(x.begin(),x.end(),a)-x.begin();\n    int sy=lower_bound(y.begin(),y.end(),b)-y.begin();\n    int gx=upper_bound(x.begin(),x.end(),c)-x.begin();\n    int gy=upper_bound(y.begin(),y.end(),d)-y.begin();\n    cout<<sum(sx,sy,gx,gy)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int INF = INT_MAX;\nconst int MAXN = 5000;\nconst int B = 500;\nconst int BNUM = MAXN / B;\n\nint n, m;\npair<int, int> ps[MAXN];\nint x[MAXN], y[MAXN];\nvector<int> bucket[BNUM];\n\nint main() {\n  while(scanf(\"%d%d\", &n, &m) != EOF) {\n    for(int i = 0; i < n; ++i) {\n      scanf(\"%d%d\", &ps[i].first, &ps[i].second);\n    }\n    sort(ps, ps+n);\n    fill(bucket, bucket + BNUM, vector<int>());\n    for(int i = 0; i < n; ++i) {\n      x[i] = ps[i].first;\n      y[i] = ps[i].second;\n      bucket[i/B].push_back(y[i]);\n    }\n    for(int b = 0; b < BNUM; ++b) {\n      sort(bucket[b].begin(), bucket[b].end());\n    }\n    while(m--) {\n      int s, t, u, v; \n      scanf(\"%d%d%d%d\", &s, &t, &u, &v);\n      int l = lower_bound(x, x+n, s) - x;\n      int r = upper_bound(x, x+n, u) - x;\n      int res = 0;\n      while(l < r && l % B != 0) {\n        res += (t <= y[l] && y[l] <= v);\n        ++l;\n      }\n      while(l < r && r % B != 0) {\n        --r;\n        res += (t <= y[r] && y[r] <= v);\n      }\n      while(l < r) {\n        int b = l / B;\n        res += upper_bound(bucket[b].begin(), bucket[b].end(), v)\n          - lower_bound(bucket[b].begin(), bucket[b].end(), t);\n        l += B;\n      }\n      printf(\"%d\\n\", res);\n    }\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define for_(i,a,b) for(int i=(a);i<(b);++i)\n#define allof(a) (a).begin(),(a).end()\n\nvoid uniqueVector(vector< int >& vec) {\n\tsort(allof(vec));\n\tvec.erase(unique(allof(vec)), vec.end());\n}\n\nvoid solve(\n\tint n, int m,\n\tconst vector< int >& tx, const vector< int >& ty,\n\tconst vector< int >& lft, const vector< int >& bot,\n\tconst vector< int >& rgt, const vector< int >& top\n\t) {\n\tvector< int > x_sort = tx, y_sort = ty;\n\tuniqueVector(x_sort);\n\tuniqueVector(y_sort);\n\t\n\tvector< vector< int > > imos(n + 1, vector< int >(n + 1, 0));\n\tfor_(i,0,n) {\n\t\tint x = lower_bound(allof(x_sort), tx[i]) - x_sort.begin() + 1;\n\t\tint y = lower_bound(allof(y_sort), ty[i]) - y_sort.begin() + 1;\n\t\t++imos[y][x];\n\t}\n\t\n\tfor_(y,0,n+1) for_(x,0,n) imos[y][x + 1] += imos[y][x];\n\tfor_(x,0,n+1) for_(y,0,n) imos[y + 1][x] += imos[y][x];\n\t\n\tfor_(i,0,m) {\n\t\tint lx = lower_bound(allof(x_sort), lft[i]) - x_sort.begin() + 1;\n\t\tint by = lower_bound(allof(y_sort), bot[i]) - y_sort.begin() + 1;\n\t\tint rx = upper_bound(allof(x_sort), rgt[i]) - x_sort.begin();\n\t\tint ty = upper_bound(allof(y_sort), top[i]) - y_sort.begin();\n\t\t\n\t\tprintf(\"%d\\n\", imos[ty][rx] - imos[ty][lx - 1] - imos[by - 1][rx] + imos[by - 1][lx - 1]);\n\t}\n}\n\nint main() {\n\tint n, m;\n\tscanf(\"%d %d\", &n, &m);\n\t\n\tvector< int > tx(n), ty(n);\n\tfor_(i,0,n) scanf(\"%d %d\", &tx[i], &ty[i]);\n\t\n\tvector< int > lft(m), bot(m), rgt(m), top(m);\n\tfor_(i,0,m) scanf(\"%d %d %d %d\", &lft[i], &bot[i], &rgt[i], &top[i]);\n\t\n\tsolve(n, m, tx, ty, lft, bot, rgt, top);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\nusing namespace std;\ntypedef pair<int, int> pii;\nmain(){\n\tint i,n,m;\n\twhile(cin >> n >> m){\n\t\tvector<pii> d(n);\n\t\tfor(i=0;i<n;i++) cin >> d[i].first >> d[i].second;\n\t\tsort(d.begin(), d.end());\n\t\tfor(i=0;i<m;i++){\n\t\t\tint x1,y1,x2,y2,ans=0;\n\t\t\tcin >> x1 >> y1 >> x2 >> y2;\n\t\t\tauto itr1 = lower_bound(d.begin(), d.end(), pii(x1, y1));\n       \t\tauto itr2 = upper_bound(d.begin(), d.end(), pii(x2, y2));\n       \t\tfor(;itr1!=itr2;++itr1) if(y1 <= (*itr1).second && (*itr1).second <= y2) ans ++;\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <map>\n#include <algorithm>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\n\n//FILE *in = freopen(\"input.txt\", \"r\", stdin);\n\nstruct BIT{\n\tvector<int> bit;\n\tint size;\n\t\n\tBIT(int n){\n\t\tsize=n;bit=vector<int>(n+1);\n\t}\n\t\n\tvoid add(int i,int x){\n\t\ti+=1;\n\t\twhile(i<=size)bit[i]+=x,i+=i&-i;\n\t}\n\n\tint sum(int i){\n\t\tint s=0;\n\t\twhile(i>0)s+=bit[i],i-=i&-i;\n\t\treturn s;\n\t}\n};\n\nstruct BIT2D{\n\tvector<BIT> bit;\n\tBIT2D(int x,int y):bit(x+1,BIT(y)){};\n\t\n\tvoid add(int x, int y, int v){\n\t\tx++;\n\t\twhile(x < (int)bit.size()){\n\t\t\tbit[x].add(y, v);\n\t\t\tx += x & -x;\n\t\t}\n\t}\n\n\tint sum(int x,int y){\n\t\tint s = 0;\n\t\twhile(x > 0){\n\t\t\ts += bit[x].sum(y);\n\t\t\tx -= x & -x;\n\t\t}\n\t\treturn s;\n\t}\n};\n\nint n, m;\nint data[5000][2];\nint query[500000][4];\nmap<int,int> xmap;\nmap<int,int> ymap;\n\nint xmax, ymax;\nvector<int> xs;\nvector<int> ys;\n\nvoid input() {\n\tscanf(\"%d%d\", &n, &m);\n\trep(i, n) {\n\t\tscanf(\"%d%d\", &data[i][0], &data[i][1]);\n\t\txs.push_back(data[i][0]);\n\t\tys.push_back(data[i][1]);\n\t}\n\trep(i,m) {\n\t\tscanf(\"%d%d%d%d\", &query[i][0], &query[i][1], &query[i][2], &query[i][3]);\n\t\txs.push_back(query[i][0]);\n\t\tys.push_back(query[i][1]);\n\t\txs.push_back(query[i][2]);\n\t\tys.push_back(query[i][3]);\n\t}\n\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\n\t{\n\t\tauto eiter = unique(xs.begin(), xs.end());\n\t\tauto iter = xs.begin();\n\t\tint i = 0;\n\t\tfor(i = 0; iter != eiter; iter++, i++) {\n\t\t\txmap[*iter] = i;\n\t\t}\n\t\txmax = i;\n\t}\n\t{\n\t\tauto eiter = unique(ys.begin(), ys.end());\n\t\tauto iter = ys.begin();\n\t\tint i = 0;\n\t\tfor(i = 0; iter != eiter; iter++, i++) {\n\t\t\tymap[*iter] = i;\n\t\t}\n\t\tymax = i;\n\t}\n}\n\nvoid process() {\n\tBIT2D qq(xmax, ymax);\n\n\trep(i, n) {\n\t\tqq.add(xmap[data[i][0]], ymap[data[i][1]], 1);\n\t}\n\n\trep(i, m) {\n\t\tint sumxy = qq.sum(xmap[query[i][2]] + 1, ymap[query[i][3]] + 1);\n\t\tint sumxyy = qq.sum(xmap[query[i][2]] + 1, ymap[query[i][1]]);\n\t\tint sumxxy = qq.sum(xmap[query[i][0]], ymap[query[i][3]] + 1);\n\t\tint sumxxyy = qq.sum(xmap[query[i][0]], ymap[query[i][1]]);\n\t\tprintf(\"%d\\n\", sumxy - sumxyy - sumxxy + sumxxyy);\n\t}\n}\n\nvoid output() {\n}\n\nint main() {\n\tinput();\n\tprocess();\n\toutput();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<complex>\nusing namespace std;\ntypedef long long ll;\nconst ll MOD = 1000000007;\nconst ll INF = (ll)1000000007 * 1000000007;\nconst double EPS = 1e-9;\ntypedef pair<int, int> P;\ntypedef unsigned int ui;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef long double ld;\ntypedef complex<ld> Point;\nconst ld eps = 1e-11;\nconst ld pi = acos(-1.0);\nint main() {\n\tint n, m; cin >> n >> m;\n\tint tx[5000]; int ty[5000];\n\tint s[500000][4];\n\tvector<int> xs; vector<int>ys;\n\trep(i, n) {\n\t\tcin >> tx[i] >> ty[i];\n\t\txs.push_back(tx[i]);\n\t\tys.push_back(ty[i]);\n\t}\n\tsort(xs.begin(), xs.end());\n\tsort(ys.begin(), ys.end());\n\trep(i, m) {\n\t\trep(j, 4) {\n\t\t\tcin >> s[i][j];\n\t\t}\n\t\ts[i][0] = lower_bound(xs.begin(), xs.end(), s[i][0]) - xs.begin();\n\t\ts[i][1] = lower_bound(ys.begin(), ys.end(), s[i][1]) - ys.begin();\n\t\ts[i][2] = upper_bound(xs.begin(), xs.end(), s[i][2]) - xs.begin(); s[i][2]--;\n\t\ts[i][3] = upper_bound(ys.begin(), ys.end(), s[i][3]) - ys.begin(); s[i][3]--;\n\t}\n\trep(i, n) {\n\t\ttx[i] = find(xs.begin(), xs.end(), tx[i]) - xs.begin();\n\t\tty[i] = find(ys.begin(), ys.end(), ty[i]) - ys.begin();\n\t}\n\tint dp[500][500] = {};\n\trep(i, n) {\n\t\tdp[tx[i]][ty[i]]++;\n\t}\n\trep(i, n) {\n\t\trep(j, n) {\n\t\t\tif (i == 0 && j == 0) {\n\t\t\t\tdp[0][0] = dp[0][0];\n\t\t\t}\n\t\t\telse if (i == 0) {\n\t\t\t\tdp[0][j] += dp[0][j - 1];\n\t\t\t}\n\t\t\telse if (j == 0) {\n\t\t\t\tdp[i][0] += dp[i - 1][0];\n\t\t\t}\n\t\t\telse {\n\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t}\n\trep(i, m) {\n\t\tint sx = s[i][0]; int sy = s[i][1]; int gx = s[i][2]; int gy = s[i][3];\n\t\tint cnt;\n\t\tif (sx >= n || sy >= n || gx < 0 || gy < 0) {\n\t\t\tcnt = 0;\n\t\t}\n\t\telse if (sx > 0 && sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy] - dp[gx][sy - 1] + dp[sx - 1][sy - 1];\n\t\t}\n\t\telse if (sx > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[sx - 1][gy];\n\t\t}\n\t\telse if (sy > 0) {\n\t\t\tcnt = dp[gx][gy] - dp[gx][sy - 1];\n\t\t}\n\t\telse {\n\t\t\tcnt = dp[gx][gy];\n\t\t}\n\t\tcout << cnt << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nint main(){\n    int n, m;\n    cin >> n >> m;\n    \n    \n    vector<int> A(n*n, 0);\n    vector<int> x(n);\n    vector<int> y(n);\n    vector<int> xb(m);\n    vector<int> yb(m);\n    vector<int> xe(m);\n    vector<int> ye(m);\n    vector<int> xs;\n    vector<int> ys;\n    \n    for(int j = 0; j < n; j++)\n        cin >> x[j] >> y[j];\n    \n    for(int i = 0; i < m; i++)\n        cin >> xb[i] >> yb[i] >> xe[i] >> ye[i];\n    \n    xs = x;\n    ys = y;\n    sort( xs.begin(), xs.end() );\n    sort( ys.begin(), ys.end() );\n    xs.erase( unique( xs.begin(), xs.end() ), xs.end() );\n    ys.erase( unique( ys.begin(), ys.end() ), ys.end() );\n    \n    for(int j = 0; j < n; j++){\n        x[j] = find( xs.begin(), xs.end(), x[j] ) - xs.begin();\n        y[j] = find( ys.begin(), ys.end(), y[j] ) - ys.begin();\n    }\n    \n    for(int i = 0; i < m; i++){\n        xb[i] = lower_bound( xs.begin(), xs.end(), xb[i] ) - xs.begin();\n        yb[i] = lower_bound( ys.begin(), ys.end(), yb[i] ) - ys.begin();\n        xe[i] = upper_bound( xs.begin(), xs.end(), xe[i] ) - xs.begin() - 1;\n        ye[i] = upper_bound( ys.begin(), ys.end(), ye[i] ) - ys.begin() - 1;\n    }\n    \n    \n    \n    for(int j = 0; j < n; j++){\n        A[ n*y[j] + x[j] ] += 1;\n    }\n    \n    for(int j = 0; j < n; j++){\n        for(int k = 1; k < n; k++){\n            A[n*j+k] += A[n*j+k-1];\n        }\n    }\n    for(int k = 0; k < n; k++){\n        for(int j = 1; j < n; j++){\n            A[n*j+k] += A[n*(j-1)+k];\n        }\n    }\n    \n    for(int i = 0; i < m; i++){\n        int a, b, c;\n        c = A[ n*(yb[i]-1) + (xb[i]-1) ];\n        if(xb[i] > 0)\n            a = A[ n*ye[i] + (xb[i]-1) ];\n        else\n            c = a = 0;\n        if(yb[i] > 0)\n            b = A[ n*(yb[i]-1) + xe[i] ];\n        else\n            c = b = 0;\n        cout << A[ n*ye[i] + xe[i] ] - a - b + c <<endl;\n    }\n    \n}"
  },
  {
    "language": "C++",
    "code": "// iostream のscanf, printf では間に合わなかった\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <map>\n#include <vector>\n\nusing namespace std;\n\n#define INF (1<<29)\n#define mp make_pair\n#define pb push_back\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m;\n\tcin >> n >> m;\n\tvector<pii> treasure;\n\tfor( int i = 0; i < n; i++ ){\n\t\tint x, y;\n\t\t//cin >> x >> y;\n\t\tscanf(\"%d %d\", &x, &y);\n\t\ttreasure.pb( mp(x,y) );\n\t}\n\tsort(treasure.begin(), treasure.end());\n\tfor( int i = 0; i < m; i++ ){\n\t\tint x1, y1, x2, y2;\n\t\t//cin >> x1 >> y1 >> x2 >> y2;\n\t\tscanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n\t\t// search\n\t\tint ans = 0;\n\t\tvector<pii>::iterator it = lower_bound(treasure.begin(),treasure.end(),mp(x1,y1));\n\t\tvector<pii>::iterator ite = upper_bound(treasure.begin(),treasure.end(),mp(x2,y2));\n\t\twhile( 1 ){\n\t\t\t//if( it == treasure.end() || *it > mp(x2,y2) ) break;\n\t\t\tif( it == ite ) break;\n\t\t\tif( x1 <= (*it).first && (*it).first <= x2 && y1 <= (*it).second && (*it).second <= y2 ) ans++;\n\t\t\tit++;\n\t\t}\n\t\t//cout << ans << endl;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\nint n, m;\nint x[10000], y[10000];\nint a, b, c, d, sum;\nint main() {\n\tcin >> n >> m;\n\tfor (int i = 0; i < n; i++) {\n\t\tscanf(\"%d %d\", &x[i], &y[i]);\n\t}\n\tfor (int i = 0; i < m; i++) {\n\t\tscanf(\"%d %d %d %d\", &a, &b, &c, &d);\n\t\tsum = 0;\n\t\tfor (int j = 0; j < n; j++) {\n\t\t\tif (a <= x[j] && x[j] <= c && b <= y[j] && y[j] <= d) {\n\t\t\t\tsum++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing VI = vector<ll>;\nusing VVI = vector<VI>;\nusing P = pair<ll, ll>;\n\nint idx(VI v, ll k) { return lower_bound(v.begin(), v.end(), k) - v.begin(); }\n\nint main(int argc, char const* argv[]) {\n  ll n, m;\n  cin >> n >> m;\n\n  vector<P> ts(n, make_pair(0, 0));\n  VI x(n), xs(n);\n  VI y(n), ys(n);\n  for (int i = 0; i < n; i++) {\n    cin >> x[i] >> y[i];\n    xs[i] = x[i];\n    ys[i] = y[i];\n  }\n  sort(xs.begin(), xs.end());\n  xs.erase(unique(xs.begin(), xs.end()), xs.end());\n\n  sort(ys.begin(), ys.end());\n  ys.erase(unique(ys.begin(), ys.end()), ys.end());\n\n  VVI tbl = VVI(xs.size() + 2, VI(ys.size() + 2, 0));\n\n  for (int i = 0; i < n; i++) {\n    ll tx = idx(xs, x[i]);\n    ll ty = idx(ys, y[i]);\n    tbl[tx + 1][ty + 1]++;\n  }\n  for (int i = 0; i < xs.size(); i++) {\n    for (int j = 0; j < ys.size(); j++) {\n      tbl[i + 1][j + 1] += tbl[i + 1][j] + tbl[i][j + 1] - tbl[i][j];\n    }\n  }\n\n  for (int i = 0; i < m; i++) {\n    ll x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = idx(xs, x1); // ret === x1 の時k、小さい値が返る, x1 < retの時も実質そう\n    y1 = idx(ys, y1);\n    x2 = idx(xs, x2+1); // x2 == val の時 ret = idx(x2)+1 ,\n    y2 = idx(ys, y2+1);\n    cout << tbl[x2][y2] - tbl[x2][y1] - tbl[x1][y2] + tbl[x1][y1] << endl;\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\t\n#include<map>\n#include<set>\n#include<utility>\n#include<cmath>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef pair<int,pii> pip;\ntypedef vector<pip>vip;\nconst double PI=acos(-1);\nconst double EPS=1e-8;\nconst int inf=1e8;\nint main(){\n\tint n,m;\n\tcin>>n>>m;\n\tvp in(n);\n\tvi x,y;\n\trep(i,n){\n\t\tint a,b;\n\t\tcin>>a>>b;\n\t\tx.pb(a);\n\t\ty.pb(b);\n\t\tin[i]=pii(a,b);\n\t}\n\tsort(all(x));\n\tsort(all(y));\n\tx.erase(unique(all(x)),x.end());\n\ty.erase(unique(all(y)),y.end());\n\trep(i,n)in[i]=pii(lower_bound(all(x),in[i].first)-x.begin(),lower_bound(all(y),in[i].second)-y.begin());\n\tvvi fi(x.size()+1,vi(y.size()+1));\n\trep(i,n)fi[in[i].first+1][in[i].second+1]++;\n\trep(i,x.size())rep(j,y.size())fi[i+1][j+1]+=fi[i][j+1]+fi[i+1][j]-fi[i][j];\n\twhile(m--){\n\t\tint a,b,c,d;\n\t\tcin>>a>>b>>c>>d;\n\t\ta=lower_bound(all(x),a)-x.begin();\n\t\tb=lower_bound(all(y),b)-y.begin();\n\t\tc=upper_bound(all(x),c)-x.begin();\n\t\td=upper_bound(all(y),d)-y.begin();\n\t\tcout<<fi[c][d]-fi[a][d]-fi[c][b]-fi[a][b]<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stack>\n#include<queue>\n#include<math.h>\n#include<algorithm>\nusing namespace std;\n#define FOR(k,m,n) for(int (k)=(m);(k)<(n);(k)++)\n#define rep(i,n) FOR((i),0,(n))\n#define N_MAX 5000\n#define M_MAX 500000\n#define ll long long\n\n//??????????????¨??????\nint n,m;\nint xy[N_MAX][2];\nint square[4];\n\n\n//??????\nint ans;\nbool ok;\n\nint main() {\n\t//??\\???\n\tcin>>n>>m;\n\trep(i,n)rep(j,2)cin>>xy[i][j];\n\n\t//?¨????\n\trep(roop, m) {\n\t\t//???????¨????\n\t\tans=0;\n\n\t\t//??\\???\n\t\trep(i,4)cin>>square[i];\n\n\t\t//?¨????\n\t\trep(i, n) {\n\t\t\tif(square[0] <= xy[i][0] && \n\t\t\t   xy[i][0] <= square[2] &&\n\t\t\t   square[1] <= xy[i][1] &&\n\t\t\t   xy[i][1] <= square[3])   ans++;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t//cin>>m;\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint main(){\n  int n, m;\n  cin >> n >> m;\n  vector<int> x(n), y(n);\n  for (int i = 0; i < n; i++){\n    cin >> x[i] >> y[i];\n  }\n  vector<int> xpos;\n  for (int i = 0; i < n; i++){\n    xpos.push_back(x[i]);\n  }\n  sort(xpos.begin(), xpos.end());\n  xpos.erase(unique(xpos.begin(), xpos.end()), xpos.end());\n  int xcnt = xpos.size();\n  map<int, int> mpx;\n  for (int i = 0; i < xcnt; i++){\n    mpx[xpos[i]] = i;\n  }\n  for (int i = 0; i < n; i++){\n    x[i] = mpx[x[i]];\n  }\n  vector<int> ypos;\n  for (int i = 0; i < n; i++){\n    ypos.push_back(y[i]);\n  }\n  sort(ypos.begin(), ypos.end());\n  ypos.erase(unique(ypos.begin(), ypos.end()), ypos.end());\n  int ycnt = ypos.size();\n  map<int, int> mpy;\n  for (int i = 0; i < ycnt; i++){\n    mpy[ypos[i]] = i;\n  }\n  for (int i = 0; i < n; i++){\n    y[i] = mpy[y[i]];\n  }\n  vector<vector<int>> S(ycnt + 1, vector<int>(xcnt + 1, 0));\n  for (int i = 0; i < n; i++){\n    S[y[i] + 1][x[i] + 1]++;\n  }\n  for (int i = 1; i <= ycnt; i++){\n    for (int j = 1; j <= xcnt; j++){\n      S[i][j] += S[i][j - 1];\n    }\n  }\n  for (int j = 1; j <= xcnt; j++){\n    for (int i = 1; i <= ycnt; i++){\n      S[i][j] += S[i - 1][j];\n    }\n  }\n  for (int i = 0; i < m; i++){\n    int x1, y1, x2, y2;\n    cin >> x1 >> y1 >> x2 >> y2;\n    x1 = lower_bound(xpos.begin(), xpos.end(), x1) - xpos.begin();\n    y1 = lower_bound(ypos.begin(), ypos.end(), y1) - ypos.begin();\n    x2 = upper_bound(xpos.begin(), xpos.end(), x2) - xpos.begin();\n    y2 = upper_bound(ypos.begin(), ypos.end(), y2) - ypos.begin();\n    cout << S[y2][x2] - S[y2][x1] - S[y1][x2] + S[y1][x1] << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <numeric>\n#include <string>\n#include <string.h>\n#include <map>\n#include <set>\n#include <functional>\n#include <complex>\n#include <stack>\n#include <tuple>\nusing namespace std;\n#define rep(i,n) for (int i=0; i < (n); i++)\n\n\ntypedef long long int ll;\ntypedef double D;      // ??§?¨?????????????double???long double?????????\ntypedef complex<D> P;  // Point\ntypedef pair<P, P> L;  // Line\ntypedef vector<P> VP;\n\n\nconst int INF = (1<<30) - 1;\nconst D EPS = 1e-9;\n\n#define X real()\n#define Y imag()\n#define LE(n,m) ((n) < (m) + EPS)\n#define GE(n,m) ((n) + EPS > (m))\n#define EQ(n,m) (abs((n)-(m)) < EPS)\n\nclass Imos{\npublic:\n    int H, W;\n    vector<vector<int>> d;\npublic:\n    //1-indexed\n    Imos(vector<vector<int>>& field){\n        H = field.size();\n        W = field[0].size();\n        d = vector<vector<int> >(H+1, vector<int>(W+1));\n        \n        for(int i=0; i<H; i++){\n            for(int j=0; j<W; j++){\n                d[i+1][j+1] = d[i+1][j] + d[i][j+1] - d[i][j] + field[i][j];\n            }\n        }\n    }\n    int area(int h1, int w1, int h2, int w2){\n        //size of area s.t. [h1, h2) and [w1, w2)\n        return d[h2][w2] - d[h2][w1] - d[h1][w2] + d[h1][w1];\n    }\n};\n\n//g++ -std=c++0x -msse4.2 -O3\n//#include <bits/stdc++.h>\nint main(){\n    //ios::sync_with_stdio(false);\n    //cin.tie(0);\n    //cout.precision(16);\n    \n    int N, M; cin >> N >> M;\n    \n    vector<int> xs(N), ys(N);\n    vector<pair<int, int>> p(N);\n    \n    for(int i=0; i<N; i++){\n        scanf(\"%d %d\", &xs[i], &ys[i]);\n        p[i] = make_pair(xs[i], ys[i]);\n    }\n    \n    sort(xs.begin(), xs.end());\n    sort(ys.begin(), ys.end());\n    xs.erase(unique(xs.begin(), xs.end()), xs.end());\n    ys.erase(unique(ys.begin(), ys.end()), ys.end());\n    \n    vector<vector<int>> d(xs.size(), vector<int>(ys.size()));\n    for(int i=0; i<N; i++){\n        int x = p[i].first, y = p[i].second;\n        int xi = lower_bound(xs.begin(), xs.end(), x) - xs.begin();\n        int yi = lower_bound(ys.begin(), ys.end(), y) - ys.begin();\n        \n        d[xi][yi]++;\n    }\n    \n    Imos imos = Imos(d);\n    \n    while(M--){\n        int x1, y1, x2, y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        \n        int x1i = lower_bound(xs.begin(), xs.end(), x1) - xs.begin();\n        int y1i = lower_bound(ys.begin(), ys.end(), y1) - ys.begin();\n        int x2i = upper_bound(xs.begin(), xs.end(), x2) - xs.begin();\n        int y2i = upper_bound(ys.begin(), ys.end(), y2) - ys.begin();\n        \n        printf(\"%d\\n\", imos.area(x1i, y1i, x2i, y2i));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ninline void compress(vector<int> &c){\n    sort(c.begin(),c.end());\n    c.erase(unique(c.begin(),c.end()),c.end());\n}\ninline int idx(int i,vector<int> &c){\n    return lower_bound(c.begin(),c.end(),i)-c.begin();\n}\nint sum[5010][5010];\nint main(){\n    int xs[5000],ys[1000];\n    int n,m;\n    scanf(\"%d%d\",&n,&m);\n    vector<int>x(n),y(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d%d\",xs+i,ys+i);\n        x[i]=xs[i];\n        y[i]=ys[i];\n    }\n    compress(x);compress(y);\n    for(int i=0;i<n;i++){\n        int fx=idx(xs[i],x);\n        int fy=idx(ys[i],y);\n        sum[fy+1][fx+1]++;\n    }\n    for(int i=0;i<y.size();i++){\n        for(int j=0;j<x.size();j++){\n            sum[i+1][j+1]+=sum[i][j+1]+sum[i+1][j]-sum[i][j];\n        }\n    }\n    for(int i=0;i<m;i++){\n        int x1,x2,y1,y2;\n        scanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n        x1=idx(x1,x);\n        y1=idx(y1,y);\n        x2=idx(x2+1,x);\n        y2=idx(y2+1,y);\n        printf(\"%d\\n\",sum[y2][x2]-sum[y2][x1]-sum[y1][x2]+sum[y1][x1]);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define NDEBUG\n#include <algorithm>\n#include <array>\n#include <cassert>\n#include <cstddef>\n#include <cstdint>\n#include <limits>\n#include <utility>\n#include <vector>\n\ntemplate <typename Integral,\n\tstd::size_t bitsize = std::numeric_limits<Integral>::digits()>\n\tclass WaveletMatrix {\n\tpublic:\n\t\tusing value_type = Integral;\n\t\tusing size_type = std::size_t;\n\n\tprivate:\n\t\tusing uint32 = std::uint_least32_t;\n\t\tstatic size_type popcount32(uint32 c) {\n#ifdef __GNUC__\n\t\t\treturn __builtin_popcount(c);\n#elif _MSC_VER_\n\t\t\treturn _mm_popcnt_u32(c);\n#else\n\t\t\tc = (c & 0x55555555) + ((c >> 1) & 0x55555555);\n\t\t\tc = (c & 0x33333333) + ((c >> 2) & 0x33333333);\n\t\t\tc = (c + (c >> 4)) & 0x0F0F0F0F;\n\t\t\tc += c >> 8;\n\t\t\tc += c >> 16;\n\t\t\treturn static_cast<size_type>(c) & 0x3F;\n#endif\n\t\t}\n\t\tstruct FID {\n\t\t\tstd::vector<uint32> dic;\n\t\t\tsize_type cnt;\n\t\t\tvalue_type bit;\n\t\t\tFID() {}\n\t\t\tFID(const size_type bsize) : dic(bsize, 0) {}\n\t\t\tvoid set(const size_type index) {\n\t\t\t\tdic[index >> 4 | 1] |= static_cast<uint32>(1) << (index & 0x1f);\n\t\t\t}\n\t\t\tvoid build() {\n\t\t\t\tconst size_type len = dic.size();\n\t\t\t\tfor (size_type j = 2; j < len; j += 2)\n\t\t\t\t\tdic[j] = dic[j - 2] + popcount32(dic[j - 1]);\n\t\t\t}\n\t\t\tsize_type rank(const size_type last) const {\n\t\t\t\treturn static_cast<size_type>(\n\t\t\t\t\tdic[last >> 4 & ~static_cast<size_type>(1)]) +\n\t\t\t\t\tpopcount32(dic[last >> 4 | 1] &\n\t\t\t\t\t(static_cast<size_type>(1) << (last & 0x1f)) - 1);\n\t\t\t}\n\t\t\tbool access(const size_type index) const {\n\t\t\t\treturn dic[index >> 4 | 1] >> (index & 0x1f) & 1;\n\t\t\t}\n\t\t};\n\t\tstd::array<FID, bitsize> matrix;\n\t\tvalue_type NOT_FOUND;\n\t\tsize_type size_;\n\n\tpublic:\n\t\tWaveletMatrix(std::vector<value_type> data, const value_type NOT_FOUND = 0)\n\t\t\t: size_(data.size()), NOT_FOUND(NOT_FOUND) {\n\t\t\tconst size_type len = data.size(), block = ((len >> 5) + 1) << 1;\n\t\t\tstd::vector<value_type> L(len), R(len);\n\t\t\tsize_type l, r;\n\t\t\tvalue_type temp = static_cast<value_type>(1) << (bitsize - 1);\n\t\t\tfor (auto &x : matrix) {\n\t\t\t\tx = FID(block);\n\t\t\t\tx.bit = temp;\n\t\t\t\ttemp = temp >> 1 & ~temp;\n\t\t\t\tl = 0;\n\t\t\t\tr = 0;\n\t\t\t\tfor (size_type j = 0; j < len; ++j)\n\t\t\t\t\tif (data[j] & x.bit)\n\t\t\t\t\t\tR[r++] = data[j], x.set(j);\n\t\t\t\t\telse\n\t\t\t\t\t\tL[l++] = data[j];\n\t\t\t\tx.cnt = l;\n\t\t\t\tx.build();\n\t\t\t\tstd::swap(data, L);\n\t\t\t\tstd::copy(R.begin(), R.begin() + r, data.begin() + l);\n\t\t\t}\n\t\t}\n\n\t\tsize_type size() const noexcept { return size_; }\n\t\tbool empty() const noexcept { return size() == 0; }\n\n\t\tvalue_type access(size_type index) const {\n\t\t\tassert(index < size());\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (x.access(index))\n\t\t\t\t\tret |= x.bit, index = x.rank(index) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tindex -= x.rank(index);\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type operator[](const size_type index) const {\n\t\t\tassert(index < size());\n\t\t\treturn access(index);\n\t\t}\n\t\tsize_type rank(size_type first, size_type last, const value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tfor (const auto &x : matrix)\n\t\t\t\tif (data & x.bit)\n\t\t\t\t\tfirst = x.rank(first) + x.cnt, last = x.rank(last) + x.cnt;\n\t\t\t\telse\n\t\t\t\t\tfirst -= x.rank(first), last -= x.rank(last);\n\t\t\treturn last - first;\n\t\t}\n\t\tvalue_type quantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\tvalue_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tconst size_type l = x.rank(first), r = x.rank(last);\n\t\t\t\tif (r - l > k)\n\t\t\t\t\tfirst = l + x.cnt, last = r + x.cnt, ret |= x.bit;\n\t\t\t\telse\n\t\t\t\t\tfirst -= l, last -= r, k -= r - l;\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tvalue_type rquantile(size_type first, size_type last, size_type k) const {\n\t\t\tassert(first < size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first < last);\n\t\t\tassert(last - first > k);\n\t\t\treturn quantile(first, last, last - first - k - 1);\n\t\t}\n\t\tsize_type less_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_least(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type greater_than(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret += x.rank(last) - x.rank(first);\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\tsize_type at_most(size_type first, size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tsize_type ret = 0;\n\t\t\tfor (const auto &x : matrix) {\n\t\t\t\tif (data & x.bit) {\n\t\t\t\t\tret += last - first + x.rank(first) - x.rank(last);\n\t\t\t\t\tfirst = x.rank(first) + x.cnt;\n\t\t\t\t\tlast = x.rank(last) + x.cnt;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tfirst -= x.rank(first);\n\t\t\t\t\tlast -= x.rank(last);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn ret + (last - first);\n\t\t}\n\t\tsize_type rangefreq(size_type first, size_type last, const value_type lower,\n\t\t\tconst value_type upper) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tassert(lower <= upper);\n\t\t\treturn at_least(first, last, lower) - at_least(first, last, upper);\n\t\t}\n\t\tvalue_type successor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type predecessor(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n\t\tvalue_type strict_succ(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = greater_than(first, last, data);\n\t\t\treturn k ? quantile(first, last, k - 1) : NOT_FOUND;\n\t\t}\n\t\tvalue_type strict_pred(const size_type first, const size_type last,\n\t\t\tconst value_type data) const {\n\t\t\tassert(first <= size());\n\t\t\tassert(last <= size());\n\t\t\tassert(first <= last);\n\t\t\tconst size_type k = at_least(first, last, data);\n\t\t\treturn last - first == k ? NOT_FOUND : quantile(first, last, k);\n\t\t}\n};\n\n#include<algorithm>\n#include<cstdio>\n#include<limits>\n#include<utility>\n#include<vector>\nint main() {\n\tconstexpr int base = 1000000000;\n\tint n, m;\n\tscanf(\"%d%d\", &n, &m);\n\tstd::vector<std::pair<int, int>> p(n);\n\tfor (auto &e : p)\n\t\tscanf(\"%d%d\", &e.first, &e.second);\n\tstd::sort(p.begin(), p.end());\n\tstd::vector<int> a(n);\n\tfor (int i = 0;i < n;++i)\n\t\ta[i] = p[i].second + base;\n\tWaveletMatrix<int, 31> W(a);\n\tauto pos = [&p](int x) {\n\t\treturn std::lower_bound(p.begin(), p.end(),\n\t\t\tstd::pair<int, int>(x, std::numeric_limits<int>::lowest())) - p.begin();\n\t};\n\twhile (m--) {\n\t\tint x1, y1, x2, y2;\n\t\tscanf(\"%d%d%d%d\", &x1, &y1, &x2, &y2);\n\t\tprintf(\"%u\\n\", W.rangefreq(pos(x1), pos(x2 + 1), y1 + base, y2 + 1 + base));\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n#include <stack>\n#include <climits>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> pii;\ndouble EPS=1e-10;\ndouble EQ(double a,double b){\n    return abs(a-b)<EPS;\n}\nvoid fast_stream(){\n  std::ios_base::sync_with_stdio(0);\n}\ntemplate<class T>\nstring IntToString(T num){\n  string res;stringstream ss;ss<<num;\n  return ss.str();\n}\nll StringToInt(string &str){\n  ll res=0;\n  for(int i=0;i<(int)str.size();i++)\n    res=(res*10+str[i]-'0');\n  return res;\n}\n\nint n,m;\nint xs[10001];\nint ys[10001];\nint minx;\nint miny;\nint maxx;\nint maxy;\nint sums[5010][5010];\npii ps[10001];\n\nint main(){\n  cin>>n>>m;\n  set<int> sx,sy;\n  map<pii,int> sp;\n  for(int i=0;i<n;i++){\n    cin>>xs[i]>>ys[i];\n    ps[i].first=ys[i];\n    ps[i].second=xs[i];\n    sx.insert(xs[i]);\n    sy.insert(ys[i]);\n    sp[ps[i]]++;\n  }\n  vector<int> sortedx,sortedy;\n  for(set<int>::iterator it=sx.begin();it!=sx.end();it++)\n    sortedx.push_back(*it);\n  for(set<int>::iterator it=sy.begin();it!=sy.end();it++)\n    sortedy.push_back(*it);\n  for(int i=0;i<(int)sortedy.size();i++)\n    for(int j=0;j<(int)sortedx.size();j++){\n      sums[i+1][j+1]=sums[i+1][j]+sums[i][j+1]-sums[i][j];\n      if(sp.count(pii(sortedy[i],sortedx[j]))>0){\n\tsums[i+1][j+1]+=sp[pii(sortedy[i],sortedx[j])];\n      }\n    }\n  for(int i=0;i<m;i++){\n    cin>>minx>>miny>>maxx>>maxy;\n    int minxPos=lower_bound(sortedx.begin(),sortedx.end(),minx)-sortedx.begin();\n    int maxxPos=upper_bound(sortedx.begin(),sortedx.end(),maxx)-sortedx.begin()-1;\n    int minyPos=lower_bound(sortedy.begin(),sortedy.end(),miny)-sortedy.begin();\n    int maxyPos=upper_bound(sortedy.begin(),sortedy.end(),maxy)-sortedy.begin()-1;\n    int cnt=sums[maxyPos+1][maxxPos+1]-sums[minyPos][maxxPos+1]\n      -sums[maxyPos+1][minxPos]+sums[minyPos][minxPos];\n    cout<<cnt<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define pb            push_back\ntemplate<class T, class S> inline pair<T, S> mp(const T x, const S y){ return make_pair(x, y); }\ntemplate<class T, class S> inline bool minup(T& m, const S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, const S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nstatic const int    INF = 1000000000;\nstatic const ll     MOD = 1000000007LL;\nstatic const double EPS = 1E-10;\n\nint n, m;\nint sx[5555], sy[5555];\nint tx[5555], ty[5555];\nint vx[5555];\nint vy[5555];\nint bit[6 * 5555][6 * 5555];\n\nvoid add(int a, int b, int w)\n{\n  for(int x = a; x <= 6 * n; x += x & -x){\n    for(int y = b; y <= 6 * n; y += y & -y){\n      bit[x][y] += w;\n    }\n  }\n}\n\nint sum(int a, int b)\n{\n  int ret = 0;\n  for(int x = a; x > 0; x -= x & -x){\n    for(int y = b; y > 0; y -= y & -y){\n      ret += bit[x][y];\n    }\n  }\n  return ret;\n}\n\nint main()\n{\n  cin >> n >> m;\n  rep(i, n) cin >> vx[i] >> vy[i];\n  rep(i, m) cin >> sx[i] >> sy[i] >> tx[i] >> ty[i];\n  \n  vi x, y;\n  rep(i, n){\n    x.pb(vx[i]);  x.pb(sx[i]);  x.pb(tx[i]);\n    y.pb(vy[i]);  y.pb(sy[i]);  y.pb(ty[i]);\n  }\n  sort(ALL(x));  x.erase(unique(ALL(x)), x.end());\n  sort(ALL(y));  y.erase(unique(ALL(y)), y.end());\n  rep(i, n){\n    vx[i] = lower_bound(ALL(x), vx[i]) - x.begin() + 1;\n    vy[i] = lower_bound(ALL(y), vy[i]) - y.begin() + 1;\n  }\n  rep(i, m){\n    sx[i] = lower_bound(ALL(x), sx[i]) - x.begin() + 1;\n    sy[i] = lower_bound(ALL(y), sy[i]) - y.begin() + 1;\n    tx[i] = lower_bound(ALL(x), tx[i]) - x.begin() + 1;\n    ty[i] = lower_bound(ALL(y), ty[i]) - y.begin() + 1;\n  }\n  rep(i, n) add(vx[i], vy[i], 1);\n\n  rep(i, m){\n    int ret = 0;\n    ret += sum(tx[i], ty[i]);\n    ret += sum(sx[i] - 1, sy[i] - 1);\n    ret -= sum(sx[i] - 1, ty[i]);\n    ret -= sum(tx[i], sy[i] - 1);\n    cout << ret << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <fstream>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v; }\ntemplate<class T> inline string toStr(T x) { ostringstream sout; sout << x; return sout.str(); }\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\nconst int INF = INT_MAX / 10;\n\nint pos1(vi v, int p) {\n\treturn lower_bound(ALL(v), p) - v.begin() - 1;\n}\n\nint pos2(vi v, int p) {\n\treturn upper_bound(ALL(v), p) - v.begin() - 1;\n}\n\nint main() {\n\tint n, m;\n\tcin >> n >> m;\n\tvi x(n), y(n);\n\tvector<pii> xy(n);\n\tREP(i, n) {\n\t\tcin >> x[i] >> y[i];\n\t\txy[i] = pii(x[i], y[i]);\n\t}\n\n\tx.push_back(INT_MIN);\n\ty.push_back(INT_MIN);\n\tsort(ALL(x));\n\tsort(ALL(y));\n\tx.erase(unique(ALL(x)), x.end());\n\ty.erase(unique(ALL(y)), y.end());\n\n\tint xsize = x.size(), ysize = y.size();\n\tvi xpos(n), ypos(n);\n\tREP(i, n) {\n\t\tREP(j, xsize) {\n\t\t\tif (xy[i].first == x[j]) {\n\t\t\t\txpos[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\tREP(i, n) {\n\t\tREP(j, ysize) {\n\t\t\tif (xy[i].second == y[j]) {\n\t\t\t\typos[i] = j;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tvvi field(ysize, vi(xsize));\n\tREP(i, n) {\n\t\tfield[ypos[i]][xpos[i]]++;\n\t}\n\tFOR(i, 1, ysize - 1) {\n\t\tFOR(j, 1, xsize - 1) {\n\t\t\tfield[i][j] += field[i][j - 1];\n\t\t}\n\t}\n\tFOR(i, 1, ysize - 1) {\n\t\tFOR(j, 1, xsize - 1) {\n\t\t\tfield[i][j] += field[i - 1][j];\n\t\t}\n\t}\n\n\tREP(i, m) {\n\t\tint xm1, ym1, xm2, ym2;\n\t\tcin >> xm1 >> ym1 >> xm2 >> ym2;\n\t\tint xp1 = pos1(x, xm1), yp1 = pos1(y, ym1), xp2 = pos2(x, xm2), yp2 = pos2(y, ym2);\n\t\tcout << field[yp2][xp2] - field[yp1][xp2] - field[yp2][xp1] + field[yp1][xp1] << endl;\n\t}\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define N_MAX 5000\n\nint n,m;\nint input_map[N_MAX][2];\n\nint za_xnum;\nint za_xlist[N_MAX+1];\nint za_xlist_raw[N_MAX+1];\nint za_ynum;\nint za_ylist[N_MAX+1];\nint za_ylist_raw[N_MAX+1];\nint za_dupe[N_MAX+1];\n\nint treasure_map[N_MAX+5][N_MAX+5];\n\n/* posList[result]<=pos<posList[result+1] */\nint za_get(int pos,int isx) {\n\tint left,right,mid;\n\tconst int* posList;\n\tleft=0;\n\tif(isx) {\n\t\tright=za_xnum-1;\n\t\tposList=za_xlist;\n\t} else {\n\t\tright=za_ynum-1;\n\t\tposList=za_ylist;\n\t}\n\twhile(left<=right) {\n\t\tmid=(left+right)/2;\n\t\tif(posList[mid]==pos)return mid;\n\t\telse if(posList[mid]<pos)left=mid+1;\n\t\telse right=mid-1;\n\t}\n\treturn left-1;\n}\n\nint qsort_comp(const void* x,const void* y) {\n\tint a=*((const int*)x);\n\tint b=*((const int*)y);\n\tif(a>b)return 1;\n\tif(a<b)return -1;\n\treturn 0;\n}\n\nvoid za_setup(void) {\n\tint i;\n\tza_xlist_raw[n]=INT_MIN;\n\tza_ylist_raw[n]=INT_MIN;\n\tqsort(za_xlist_raw,n+1,sizeof(int),qsort_comp);\n\tqsort(za_ylist_raw,n+1,sizeof(int),qsort_comp);\n\n\tza_dupe[0]=0;\n\tfor(i=1;i<=n;i++) {\n\t\tif(za_xlist_raw[i]==za_xlist_raw[i-1])za_dupe[i]=1; else za_dupe[i]=0;\n\t\tza_dupe[i]+=za_dupe[i-1];\n\t}\n\tfor(i=0;i<=n;i++)za_xlist[i-za_dupe[i]]=za_xlist_raw[i];\n\tza_xnum=n+1-za_dupe[n];\n\n\tza_dupe[0]=0;\n\tfor(i=1;i<=n;i++) {\n\t\tif(za_ylist_raw[i]==za_ylist_raw[i-1])za_dupe[i]=1; else za_dupe[i]=0;\n\t\tza_dupe[i]+=za_dupe[i-1];\n\t}\n\tfor(i=0;i<=n;i++)za_ylist[i-za_dupe[i]]=za_ylist_raw[i];\n\tza_ynum=n+1-za_dupe[n];\n}\n\nint main(void) {\n\tint i,j;\n\tscanf(\"%d%d\",&n,&m);\n\tfor(i=0;i<n;i++) {\n\t\tscanf(\"%d%d\",&input_map[i][0],&input_map[i][1]);\n\t\tza_xlist_raw[i]=input_map[i][0];\n\t\tza_ylist_raw[i]=input_map[i][1];\n\t}\n\tza_setup();\n\tfor(i=0;i<n;i++) {\n\t\ttreasure_map[za_get(input_map[i][0],1)][za_get(input_map[i][1],0)]++;\n\t}\n\tfor(i=0;i<za_xnum;i++) {\n\t\tfor(j=1;j<za_ynum;j++) {\n\t\t\ttreasure_map[i][j]+=treasure_map[i][j-1];\n\t\t}\n\t}\n\tfor(j=0;j<za_ynum;j++) {\n\t\tfor(i=1;i<za_xnum;i++) {\n\t\t\ttreasure_map[i][j]+=treasure_map[i-1][j];\n\t\t}\n\t}\n\n\tfor(i=0;i<m;i++) {\n\t\tint x1,y1,x2,y2;\n\t\tint xx1,yy1,xx2,yy2;\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\txx1=za_get(x1,1);\n\t\tyy1=za_get(y1,0);\n\t\txx2=za_get(x2,1);\n\t\tyy2=za_get(y2,0);\n\t\tif(za_xlist[xx1]==x1)xx1--;\n\t\tif(za_ylist[yy1]==y1)yy1--;\n\t\tprintf(\"%d\\n\",\n\t\t\ttreasure_map[xx2][yy2]-treasure_map[xx1][yy2]-\n\t\t\ttreasure_map[xx2][yy1]+treasure_map[xx1][yy1]);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint N,M,T[5005][2],i,j,x1,x2,y1,y2,R;\nint in(int a,int b,int c){return a<=b&&b<=c;}\nint cmp(const void *a,const void *b){return ((int *)a)[0]>((int*)b)[0];}\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d\",&T[i][0],&T[i][1]);\n\tqsort(T,N,sizeof(int[2]),cmp);\n\tfor(i=0;i<M;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tfor(j=R=0;T[j][0]<=x2&&j<N;j++)\n\t\t\tif(in(x1,T[j][0],x2)&&in(y1,T[j][1],y2))\n\t\t\t\tR++;\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint in(int a,int b,int c){return a<=b&&b<=c;}\nint N,M,T[5005][2],i,j,x1,x2,y1,y2,R;\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d\",&T[i][0],&T[i][1]);\n\tfor(i=0;i<M;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tfor(j=R=0;j<N;j++)\n\t\t\tif(in(x1,T[j][0],x2)&&in(y1,T[j][1],y2))\n\t\t\t\tR++;\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct{\n    int x;\n    int y;\n} treasure;\ntreasure treasures[5000];\nint comp(const void *a, const void *b);\n\nint main(void){\n    int number_of_treasures;\n    int number_of_regions;\n    scanf(\"%d %d\", &number_of_treasures, &number_of_regions);\n\n    int i,j,k,l;\n    for(i=0;i<number_of_treasures;i++){\n        scanf(\"%d %d\", &(treasures[i].x), &(treasures[i].y));\n    }\n    qsort(treasures, number_of_treasures, sizeof(treasure),comp);\n    \n    for(i=0;i<number_of_regions;i++){\n        int x1,x2,y1,y2,count;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        count=0;\n        for(j=0;j<number_of_treasures;j++){\n            if(treasures[j].x>=x1) break;\n        }\n        for(;j<number_of_treasures;j++){\n            if(treasures[j].x>x2) break;\n            if(y1<=treasures[j].y&&treasures[j].y<=y2) count++;\n        }\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}\n\nint comp(const void *c1, const void *c2){\n    treasure *a = (treasure *)c1;\n    treasure *b = (treasure *)c2;\n    return a->x - b->x;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct{\n    int x;\n    int y;\n} treasure;\nint main(void){\n    int number_of_treasures;\n    int number_of_regions;\n    scanf(\"%d %d\", &number_of_treasures, &number_of_regions);\n    treasure* treasures = malloc(sizeof(treasure)*number_of_treasures);\n    int i,j;\n    for(i=0;i<number_of_treasures;i++){\n        scanf(\"%d %d\", &(treasures[i].x),&(treasures[i].y));\n    }\n    for(i=0;i<number_of_regions;i++){\n        int x1,x2,y1,y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        int count=0;\n        for(j=0; j<number_of_treasures;j++){\n            if(x1<=treasures[j].x&&treasures[j].x<=x2&&y1<=treasures[j].y&&treasures[j].y<=y2) count++;\n        }\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct treasure{\n    int x;\n    int y;\n    struct treasure* next;\n} treasure;\ntypedef struct{\n    int quantity;\n    treasure* list;\n} district;\ndistrict map[2001][2001];\nint search(district* map, int x1, int x2, int y1, int y2);\n\nint main(void){\n    int number_of_treasures;\n    int number_of_regions;\n    scanf(\"%d %d\", &number_of_treasures, &number_of_regions);\n\n    int i,j,k,l;\n    for(i=0;i<number_of_treasures;i++){\n        int x,y,X,Y;\n        scanf(\"%d %d\", &x,&y);\n        X=(x+1000000000)/1000000;\n        Y=(y+1000000000)/1000000;\n\n        if(map[X][Y].quantity==0){\n            map[X][Y].quantity++;\n            map[X][Y].list=malloc(sizeof(treasure));\n            map[X][Y].list->x=x;\n            map[X][Y].list->y=y;\n        }else{\n            map[X][Y].quantity++;\n            treasure* latest=malloc(sizeof(treasure));\n            latest->next=map[X][Y].list;\n            latest->x=x;\n            latest->y=y;\n            map[X][Y].list=latest;\n        }\n    }\n    for(i=0;i<number_of_regions;i++){\n        int x1,x2,y1,y2,X1,X2,Y1,Y2,count;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        count=0;\n        X1=(x1+1000000000)/1000000;\n        Y1=(y1+1000000000)/1000000;\n        X2=(x2+1000000000)/1000000;\n        Y2=(y2+1000000000)/1000000;\n        for(j=X1;j<=X2;j++){\n            for(k=Y1;k<=Y2;k++){\n                if(j==X1||j==X2||k==Y1||k==Y2){\n                    count+=search(&(map[j][k]), x1,x2,y1,y2);\n                }else{\n                    count+=map[j][k].quantity;\n                }\n            }\n        }\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}\n\nint search(district* map, int x1, int x2, int y1, int y2){\n    int quantity=map->quantity;\n    if(quantity==0) return 0;\n    int i,count=0;\n    treasure* temp=map->list;\n    for(i=0;i<quantity;i++){\n        int x=temp->x;\n        int y=temp->y;\n        if(x1<=x&&x<=x2&&y1<=y&&y<=y2) count++;\n        temp=temp->next;\n    }\n    return count;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\n//ティツゥツ陛、ツセツ。テゥツ鳴「テヲツ閉ーテッツシツ暗」ツ??」ツ?セテ」ツ?ッMAXテッツシツ?\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//テヲツ個ソテ・ツ?・テゥツ鳴「テヲツ閉ー\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//テ・ツ渉姪」ツつ甘・ツ?コテ」ツ?凖ゥツ鳴「テヲツ閉ー\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint lub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<=d[m]?lub(l,m,n,d):lub(m+1,r,n,d);\n}\nint ub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<d[m]?ub(l,m,n,d):ub(m+1,r,n,d);\n}\nint c[5010][5010];\nint main(){\n  int n,m,i,j,k,l,yr=0,xr=0,x[5010],y[5010],d[2][5010];\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<n;i++)scanf(\"%d %d\",&x[i],&y[i]);\n  for(i=0;i<n;i++)hin(x[i]);\n  for(i=0;i<n;i++){\n    d[0][xr++]=N[hout()];\n    if(xr>1&&d[0][xr-1]==d[0][xr-2])xr--;\n  }\n  R=C=1;\n  for(i=0;i<n;i++)hin(y[i]);\n  for(i=0;i<n;i++){\n    d[1][yr++]=N[hout()];\n    if(yr>1&&d[1][yr-1]==d[1][yr-2])yr--;\n  }\n  for(i=0;i<n;i++)printf(\"%d %d\\n\",d[0][i],d[1][i]);\n  for(i=0;i<n;i++)c[lub(0,yr,y[i],d[1])+1][lub(0,xr,x[i],d[0])+1]++;\n  for(i=1;i<=yr+1;i++){\n    for(j=1;j<=xr+1;j++)c[i][j]+=c[i-1][j]+c[i][j-1]-c[i-1][j-1];\n  }\n  /*printf(\"        \");\n  for(i=0;i<n+1;i++)printf(\"%3d \",d[0][i]);printf(\"\\n\");\n  for(i=0;i<=n+1;i++){\n    i?printf(\"%3d \",d[1][i-1]):printf(\"    \");\n    for(j=0;j<=n+1;j++)printf(\"%3d \",c[i][j]);printf(\"\\n\");\n    }//*/\n  while(m--){\n    scanf(\"%d %d %d %d\",&i,&j,&k,&l);\n    i=lub(0,xr,i,d[0]);\n    j=lub(0,yr,j,d[1]);\n    k=ub(0,xr,k,d[0]);\n    l=ub(0,yr,l,d[1]);//printf(\"%d %d %d %d\\n\",i,j,k,l);\n    printf(\"%d\\n\",c[j][i]-c[l][i]-c[j][k]+c[l][k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct point{\n  int x;\n  int y;\n} point;\n\nint cmpp(const void *lhs, const void *rhs){\n  point *l = (point *)lhs;\n  point *r = (point *)rhs;\n  if(l->x != r->x) return l->x - r->x;\n  return l->y - r->y;\n}\n\npoint p[5001];\n\nint main(){\n  int i, j;\n  int n, m;\n  int ldx, ldy, rux, ruy;\n\n  scanf(\"%d%d\", &n, &m);\n  for(i = 0; i < n; i++)\n    scanf(\"%d%d\", &p[i].x, &p[i].y);\n\n  qsort(p, n, sizeof(point), cmpp);\n\n  p[n].x = 1000000000 + 1;\n\n  for(i = 0; i < m; i++){\n    int ans = 0;\n\n    scanf(\"%d%d%d%d\", &ldx, &ldy, &rux, &ruy);\n\n    for(j = 0; rux >= p[j].x; j++){\n      const int x = p[j].x;\n      const int y = p[j].y;\n\n      if(ldx <= x && x <= rux &&\n         ldy <= y && y <= ruy){\n        ans++;\n        continue;\n      }\n    }\n\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct{\n    int x;\n    int y;\n} treasure;\nint main(void){\n    int number_of_treasures;\n    int number_of_regions;\n    scanf(\"%d %d\", &number_of_treasures, &number_of_regions);\n    treasure* treasures = malloc(sizeof(treasure)*number_of_treasures);\n    for(int i=0;i<number_of_treasures;i++){\n        scanf(\"%d %d\", &(treasures[i].x),&(treasures[i].y));\n    }\n    for(int i=0;i<number_of_regions;i++){\n        int x1,x2,y1,y2;\n        scanf(\"%d %d %d %d\", &x1, &y1, &x2, &y2);\n        int count=0;\n        for(int j=0; j<number_of_treasures;j++){\n            if(x1<=treasures[j].x&&treasures[j].x<=x2&&y1<=treasures[j].y&&treasures[j].y<=y2) count++;\n        }\n        printf(\"%d\\n\", count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\n//ティツゥツ陛、ツセツ。テゥツ鳴「テヲツ閉ーテッツシツ暗」ツ??」ツ?セテ」ツ?ッMAXテッツシツ?\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//テヲツ個ソテ・ツ?・テゥツ鳴「テヲツ閉ー\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//テ・ツ渉姪」ツつ甘・ツ?コテ」ツ?凖ゥツ鳴「テヲツ閉ー\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint lub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<=d[m]?lub(l,m,n,d):lub(m+1,r,n,d);\n}\nint ub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<d[m]?ub(l,m,n,d):ub(m+1,r,n,d);\n}\nint c[5010][5010];\nint main(){\n  int n,m,i,j,k,l,yr=0,xr=0,x[5010],y[5010],d[2][5010]={};\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<n;i++)scanf(\"%d %d\",&x[i],&y[i]);\n  for(i=0;i<n;i++)hin(x[i]);\n  for(i=0;i<n;i++){\n    d[0][xr++]=N[hout()];\n    if(xr>1&&d[0][xr-1]==d[0][xr-2])xr--;\n  }\n  R=C=1;\n  for(i=0;i<n;i++)hin(y[i]);\n  for(i=0;i<n;i++){\n    d[1][yr++]=N[hout()];\n    if(yr>1&&d[1][yr-1]==d[1][yr-2])yr--;\n  }\n  //for(i=0;i<n;i++)printf(\"%d %d\\n\",d[0][i],d[1][i]);\n  for(i=0;i<n;i++)c[lub(0,yr,y[i],d[1])+1][lub(0,xr,x[i],d[0])+1]++;\n  for(i=1;i<=yr+1;i++){\n    for(j=1;j<=xr+1;j++)c[i][j]+=c[i-1][j]+c[i][j-1]-c[i-1][j-1];\n  }\n  /*printf(\"        \");\n  for(i=0;i<n+1;i++)printf(\"%3d \",d[0][i]);printf(\"\\n\");\n  for(i=0;i<=n+1;i++){\n    i?printf(\"%3d \",d[1][i-1]):printf(\"    \");\n    for(j=0;j<=n+1;j++)printf(\"%3d \",c[i][j]);printf(\"\\n\");\n    }//*/\n  while(m--){\n    scanf(\"%d %d %d %d\",&i,&j,&k,&l);\n    i=lub(0,xr,i,d[0]);\n    j=lub(0,yr,j,d[1]);\n    k=ub(0,xr,k,d[0]);\n    l=ub(0,yr,l,d[1]);//printf(\"%d %d %d %d\\n\",i,j,k,l);\n    printf(\"%d\\n\",c[j][i]-c[l][i]-c[j][k]+c[l][k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define INF ((1LL<<62)-(1LL<<31))\n#define f(x1,y1,x2,y2)(a[x2][y2]-a[x1][y2]-a[x2][y1]+a[x1][y1])\nint upll(const void*a, const void*b){return*(ll*)a<*(ll*)b?-1:*(ll*)a>*(ll*)b?1:0;}\nvoid sortup(ll*a,int n){qsort(a,n,sizeof(ll),upll);}\n\nint uniquell(ll*p,ll*ans,int cnt){\n\tll*a=malloc(sizeof(ll)*cnt);\n\tmemcpy(a,p,sizeof(ll)*cnt);\n\tsortup(a,cnt);\n\tint c=0;\n\tans[0]=a[0];\n\trep(i,1,cnt)if(a[i]!=ans[c])ans[++c]=a[i];\n\treturn c+1;\n}\n\n//座圧2\n//uniquell(a,comp,n)でcompに昇順の配列を作る\nll cocompf(ll n,ll*comp,ll compcnt){\n\t//comp[i]<=n<comp[i+1]なるiを返す\n\tll l=0,r=compcnt;\n\twhile(r-l>1){\n\t\tll m=(l+r)/2;\n\t\tif(comp[m]<=n)l=m;\n\t\telse r=m;\n\t}\n\treturn l;\n}\n\nint a[5010][5010];\nll x[5010],y[5010];\nll cx[5010],cy[5010];\n\nint main(){\n\tint n,m;\n\tscanf(\"%d%d\",&n,&m);\n\trep(i,0,n)scanf(\"%lld%lld\",x+i,y+i);\n\tx[n]=y[n]=-INF;\n\tx[n+1]=y[n+1]=INF;\n\tint xcnt=uniquell(x,cx,n+2);\n\tint ycnt=uniquell(y,cy,n+2);\n\t\n\trep(i,0,n){\n\t\tint pp=cocompf(x[i],cx,xcnt)+1;\n\t\tint qq=cocompf(y[i],cy,ycnt)+1;\n\t\ta[pp][qq]++;\n\t}\n\trep(i,0,xcnt+5)rep(j,0,ycnt+5)a[i][j+1]+=a[i][j];\n\trep(j,0,ycnt+5)rep(i,0,xcnt+5)a[i+1][j]+=a[i][j];\n\t\n\trep(_,0,m){\n\t\tll p,q,r,s;\n\t\tscanf(\"%lld%lld%lld%lld\",&p,&q,&r,&s);\n\t\tint x1=cocompf(p-1,cx,xcnt)+1;\n\t\tint y1=cocompf(q-1,cy,ycnt)+1;\n\t\tint x2=cocompf(r,cx,xcnt)+1;\n\t\tint y2=cocompf(s,cy,ycnt)+1;\n\t\tprintf(\"%lld\\n\",f(x1,y1,x2,y2));\n\t}\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint R=1,C=1,H[2000010],N[2000010];\n//ティツゥツ陛、ツセツ。テゥツ鳴「テヲツ閉ーテッツシツ暗」ツ??」ツ?セテ」ツ?ッMAXテッツシツ?\nint hyouka(int a,int b){\n  if(C<b)return 1;\n  if(C<a||b==0)return 0;\n  return N[H[a]]<N[H[b]]?1:0;\n}\n//テヲツ個ソテ・ツ?・テゥツ鳴「テヲツ閉ー\nvoid hin(int a){\n  int i=C++;\n  for(N[H[0]=R]=a;hyouka(0,i/2);i/=2)H[i]=H[i/2];\n  H[i]=R++;\n}\n//テ・ツ渉姪」ツつ甘・ツ?コテ」ツ?凖ゥツ鳴「テヲツ閉ー\nint hout(){\n  int rt=H[1],i,j=2,k=H[--C];\n  for(i=1;hyouka(i,C);i=j)H[i]=H[j=i*2+1-hyouka(i*2,i*2+1)];\n  H[j/2]=k;\n  return rt;\n}\nint lub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<=d[m]?lub(l,m,n,d):lub(m+1,r,n,d);\n}\nint ub(int l,int r,int n,int *d){\n  int m=(l+r)/2;\n  if(l==r)return m;\n  return n<d[m]?ub(l,m,n,d):ub(m+1,r,n,d);\n}\nint c[5010][5010];\nint main(){\n  int n,m,i,j,k,l,yr=0,xr=0,x[5010],y[5010],d[2][5010];\n  scanf(\"%d %d\",&n,&m);\n  for(i=0;i<n;i++)scanf(\"%d %d\",&x[i],&y[i]);\n  for(i=0;i<n;i++)hin(x[i]);\n  for(i=0;i<n;i++){\n    d[0][xr++]=N[hout()];\n    if(xr>1&&d[0][xr-1]==d[0][xr-2])xr--;\n  }\n  R=C=1;\n  for(i=0;i<n;i++)hin(y[i]);\n  for(i=0;i<n;i++){\n    d[1][yr++]=N[hout()];\n    if(yr>1&&d[1][yr-1]==d[1][yr-2])yr--;\n  }\n  for(i=0;i<n;i++)printf(\"%d %d\\n\",d[0][i],d[1][i]);\n  for(i=0;i<n;i++)c[lub(0,yr,y[i],d[1])+1][lub(0,xr,x[i],d[0])+1]++;\n  for(i=1;i<=yr+1;i++){\n    for(j=1;j<=xr+1;j++)c[i][j]+=c[i-1][j]+c[i][j-1]-c[i-1][j-1];\n  }\n  /*printf(\"        \");\n  for(i=0;i<n+1;i++)printf(\"%3d \",d[0][i]);printf(\"\\n\");\n  for(i=0;i<=n+1;i++){\n    i?printf(\"%3d \",d[1][i-1]):printf(\"    \");\n    for(j=0;j<=n+1;j++)printf(\"%3d \",c[i][j]);printf(\"\\n\");\n    }//*/\n  while(m--){\n    scanf(\"%d %d %d %d\",&i,&j,&k,&l);\n    i=lub(0,xr,i,d[0]);\n    j=lub(0,yr,j,d[1]);\n    k=ub(0,xr,k,d[0]);\n    l=ub(0,yr,l,d[1]);//printf(\"%d %d %d %d\\n\",i,j,k,l);\n    printf(\"%d\\n\",c[j][i]-c[l][i]-c[j][k]+c[l][k]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2426: Treasure Hunt\n// 2017.12.2 bal4u@uu\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct { int x, y; } PP;\nPP t[5002];\nint x[5002], xs;\nint y[5002], ys;\nint sum[5002][5002];\n\nchar buf[60], *p;\nint getint()\n{\n\tint n = 0;\n\tif (*p == '-') {\n\t\tp++; while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\t\tn = -n;\n\t} else while (*p >= '0') n = (n<<3) + (n<<1) + (*p++ & 0xf);\n\tp++;\n\treturn n;\n}\n\nint cmp(int *a, int *b) { return *a - *b; }\nint xycmp(PP *a, PP *b) { if (a->x - b->x) return a->x - b->x; return a->y - b->y; }\n\nint uniq(int *a, int n)\n{\n\tint i, j;\n\t\n\tfor (i = 0, j = 1; j < n; j++) {\n\t\twhile (j < n && a[j] == a[i]) j++;\n\t\tif (j < n) if (++i != j) a[i] = a[j];\n\t}\n\treturn i+1;\n}\n\nint bschLE(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n\t\tif (a[m] == x) return m;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l-1;\n}\n\nint bschGE(int *a, int x, int r)\n{\n\tint m, l = 0;\n\n    while (l < r) {\n        m = (l + r) >> 1;\n        if (a[m] < x) l = m + 1; else r = m;\n    }\n\treturn l;\n}\n\nint main()\n{\n\tint n, m, i, j, x1, y1, x2, y2, i1, j1, i2, j2;\n\n\tfgets(p=buf, 60, stdin);\n\tn = getint(), m = getint();\n\tfor (i = 0; i < n; i++) {\n\t\tfgets(p=buf, 60, stdin);\n\t\tt[i].x = x[i] = getint(), t[i].y = y[i] = getint();\n\t}\n\tqsort(x, n, sizeof(int), cmp); xs = uniq(x, n);\n\tqsort(y, n, sizeof(int), cmp); ys = uniq(y, n);\n\tqsort(t, n, sizeof(PP), xycmp);\n\n\tfor (j = 0, i = 0; i < n; i++) {\n\t\tif (t[i].x != x[j]) j++;\n\t\ty1 = bschLE(y, t[i].y, ys);\n\t\tsum[y1+1][j+1]++;\n\t}\n\n\tfor (i = 0; i < ys; i++) for (j = 0; j < xs; j++) {\n        sum[i+1][j+1] += sum[i+1][j] + sum[i][j+1] - sum[i][j];\n\t}\n\n\twhile (m--) {\n\t\tfgets(p=buf, 60, stdin);\n\t\tx1 = getint(), y1 = getint(), x2 = getint(), y2 = getint();\n\n\t\tj2 = bschLE(x, x2, xs);\n\t\tif (x1 == x2) j1 = j2;\n\t\telse j1 = bschGE(x, x1, xs);\n\n\t\ti2 = bschLE(y, y2, ys);\n\t\tif (y1 == y2) i1 = i2;\n\t\telse i1 = bschGE(y, y1, ys);\n\n\t\ti2++, j2++;\n        printf(\"%d\\n\", sum[i2][j2] - sum[i2][j1] - sum[i1][j2] + sum[i1][j1]);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#include<string.h>\nint N,M,T[5005][2],i,j,x1,x2,y1,y2,R;\nint in(int a,int b,int c){return a<=b&&b<=c;}\nint cmp(const void *a,const void *b){return ((int *)a)[0]<((int*)b)[0];}\nint main()\n{\n\tscanf(\"%d%d\",&N,&M);\n\tfor(i=0;i<N;i++)\n\t\tscanf(\"%d%d\",&T[i][0],&T[i][1]);\n\tqsort(T,N,sizeof(int[2]),cmp);\n\tfor(i=0;i<M;i++)\n\t{\n\t\tscanf(\"%d%d%d%d\",&x1,&y1,&x2,&y2);\n\t\tfor(j=R=0;T[j][0]<=x2&&j<N;j++)\n\t\t\tif(in(x1,T[j][0],x2)&&in(y1,T[j][1],y2))\n\t\t\t\tR++;\n\t\tprintf(\"%d\\n\",R);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "Kotlin",
    "code": "fun main(args:Array<String>?): Unit {\n    val (n, m) = readLine()!!.trim().split(' ').map(String::toInt)\n    var xs = IntArray(n) { 0 }\n    var ys = IntArray(n) { 0 }\n    val points = Array(n) {\n        val (x, y) = readLine()!!.trim().split(' ').map(String::toInt)\n        xs[it] = x\n        ys[it] = y\n        Point(x, y)\n    }\n    xs.sort()\n    ys.sort()\n    xs = xs.distinct().toIntArray()\n    ys = ys.distinct().toIntArray()\n    val sum = Array(ys.size) { IntArray(xs.size) { 0 } }\n    for ((x, y) in points) {\n        sum[ys.binarySearch(y)][xs.binarySearch(x)]++\n    }\n    for (i in sum.indices) for (j in sum[i].indices){\n        if (i > 0) sum[i][j] += sum[i - 1][j]\n        if (j > 0) sum[i][j] += sum[i][j - 1]\n        if (i > 0 && j > 0) sum[i][j] -= sum[i - 1][j - 1]\n    }\n    repeat(m){\n        val (left, up, right, bottom) = readLine()!!.trim().split(' ').map(String::toInt)\n        val lx =lowerBound(xs, left) - 1\n        val uy = lowerBound(ys, up) - 1\n        val rx = upperBound(xs, right) - 1\n        val dy = upperBound(ys, bottom) - 1\n        if (rx >= 0 && dy >= 0) {\n            var result = sum[dy][rx]\n            if (lx >= 0) result -= sum[dy][lx]\n            if (uy >= 0) result -= sum[uy][rx]\n            if (lx >= 0 && uy >= 0) result += sum[uy][lx]\n            println(result)\n        }else {\n            println(0)\n        }\n    }\n}\nfun upperBound(array: IntArray, target: Int): Int {\n    var left = 0\n    var right = array.size\n    while(left < right) {\n        val mid = (left + right) / 2\n        if (array[mid] <= target){\n            left = mid + 1\n        }else {\n            right = mid\n        }\n    }\n    return right\n}\nfun lowerBound(array: IntArray, target: Int): Int {\n    var left = 0\n    var right = array.size\n    while(left < right){\n        val mid = (left + right) / 2\n        if (array[mid] < target){\n            left = mid + 1\n        }else {\n            right = mid\n        }\n    }\n    return right\n}\ndata class Point(val x: Int, val y: Int)\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n \n \npublic class Main{\n     \n    public static void main(String[] args) throws IOException {\n    \tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        String[] strs = br.readLine().split(\" \");\n         \n        final int n = Integer.parseInt(strs[0]);\n        final int m = Integer.parseInt(strs[1]);\n         \n         \n        int x_base[] = new int[n];\n        int y_base[] = new int[n];\n        for(int i = 0; i < n; i++){\n        \tstrs = br.readLine().split(\" \");\n            x_base[i] = Integer.parseInt(strs[0]);\n            y_base[i] = Integer.parseInt(strs[1]);\n        }\n         \n        TreeSet<Integer> x_set = new TreeSet<Integer>();\n        TreeSet<Integer> y_set = new TreeSet<Integer>();\n        for(int i = 0; i < n; i++){\n            x_set.add(x_base[i]);\n            y_set.add(y_base[i]);\n        }\n         \n        int[] x_array = new int[x_set.size()];\n        for(int i = 0; i < x_array.length; i++){\n            x_array[i] = x_set.pollFirst();\n        }\n         \n        int[] y_array = new int[y_set.size()];\n        for(int i = 0; i < y_array.length; i++){\n            y_array[i] = y_set.pollFirst();\n        }\n         \n        int col[][] = new int[x_array.length][y_array.length];\n        for(int i = 0; i < n; i++){\n            col[Arrays.binarySearch(x_array,x_base[i])][Arrays.binarySearch(y_array,y_base[i])]++;\n        }\n         \n        int[][] pre = new int[x_array.length][y_array.length];\n        for(int i = 0; i < x_array.length; i++){\n            for(int j = 0; j < y_array.length; j++){\n                 \n                if(i != 0 && j != 0){\n                    pre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]  + col[i][j];\n                }else if(i != 0){\n                    pre[i][j] = pre[i-1][j] + col[i][j];\n                }else if(j != 0){\n                    pre[i][j] = pre[i][j-1] + col[i][j];\n                }else{\n                    pre[i][j] = col[i][j];\n                }\n            }\n        }\n        /* ok */\n         \n         \n//      for(int i = 0; i < x_array.length; i++){\n//          for(int j = 0; j < y_array.length; j++){\n//              System.out.print(col[i][j] + \" \");\n//          }\n//          System.out.println();\n//      }\n//      for(int i = 0; i < x_array.length; i++){\n//          for(int j = 0; j < y_array.length; j++){\n//              System.out.print(pre[i][j] + \" \");\n//          }\n//          System.out.println();\n//      }\n         \n        for(int i = 0; i < m; i++){\n        \tstrs = br.readLine().split(\" \");\n            final int x1 = Integer.parseInt(strs[0]);\n            final int y1 = Integer.parseInt(strs[1]);\n            final int x2 = Integer.parseInt(strs[2]);\n            final int y2 = Integer.parseInt(strs[3]);\n             \n             \n            int x1_b = Arrays.binarySearch(x_array, x1);\n            int y1_b = Arrays.binarySearch(y_array, y1);\n            int x2_b = Arrays.binarySearch(x_array, x2);\n            int y2_b = Arrays.binarySearch(y_array, y2);\n             \n//          if(x1_b < 0){\n//              System.out.println(\"x1- \" + x1_b);\n//          }\n//          if(y1_b < 0){\n//              System.out.println(\"y1- \" + y1_b);\n//          }\n             \n            x1_b = x1_b < 0 ? -(x1_b + 1) : x1_b;\n            y1_b = y1_b < 0 ? -(y1_b + 1) : y1_b;\n \n            x2_b = x2_b < 0 ? -(x2_b + 1) - 1 : x2_b;\n            y2_b = y2_b < 0 ? -(y2_b + 1) - 1 : y2_b;\n             \n            int sum = 0;\n             \n//          x2_b = x2_b >= x_array.length ? x_array.length-1 : x2_b;\n//          y2_b = y2_b >= y_array.length ? y_array.length-1 : y2_b;\n             \n//          System.out.println(Arrays.toString(x_array));\n//          System.out.println(x_array.length + \",\" + x1_b);\n//          System.out.println(Arrays.toString(y_array));\n//          System.out.println(y_array.length + \",\" + y1_b);\n//          System.out.println(Arrays.toString(x_array));\n//          System.out.println(x_array.length + \",\" + x2_b);\n//          System.out.println(Arrays.toString(y_array));\n//          System.out.println(y_array.length + \",\" + y2_b);\n             \n            if(x1_b > x2_b || y1_b > y2_b){\n                sum = 0;\n            }else if(x1_b != 0 && y1_b != 0){\n                sum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b] - pre[x2_b][y1_b-1] + pre[x1_b-1][y1_b-1];\n            }else if(x1_b != 0){\n                sum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b];\n            }else if(y1_b != 0){\n                sum = pre[x2_b][y2_b] - pre[x2_b][y1_b-1];\n            }else{\n                sum = pre[x2_b][y2_b];\n            }\n             \n            System.out.println(sum);\n        }\n         \n         \n    }\n     \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//1700 cording start\n\t//1803 sample matched\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint [] xlist = new int[n];\n\t\t\tint [] ylist = new int[n];\n\t\t\tTreeSet<Integer> xl = new TreeSet<Integer>();\n\t\t\tTreeSet<Integer> yl = new TreeSet<Integer>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\txl.add(xlist[i]);\n\t\t\t\tyl.add(ylist[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint [] xsorted = new int[xl.size()];\n\t\t\tint [] ysorted = new int[yl.size()];\n\t\t\tint ind = 0;\n\t\t\tfor(int v: xl){\n\t\t\t\txsorted[ind++] = v;\n\t\t\t}\n\t\t\tind = 0;\n\t\t\tfor(int v: yl){\n\t\t\t\tysorted[ind++] = v;\n\t\t\t}\n\t\t\t\n\t\t\tint [][] acc = new int[yl.size() + 1][xl.size()+1];\n\t\t\tfor(int k = 0 ; k < n; k++){\n\t\t\t\tint x = Arrays.binarySearch(xsorted, xlist[k]) + 1;\n\t\t\t\tint y = Arrays.binarySearch(ysorted, ylist[k]) + 1;\n\t\t\t\tfor(int i = y; i < acc.length; i++){\n\t\t\t\t\tfor(int j = x; j < acc[i].length; j++){\n\t\t\t\t\t\tacc[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(Arrays.toString(ysorted));\n//\t\t\tSystem.out.println(Arrays.toString(xsorted));\n//\t\t\tSystem.out.println(yl.size() + \" \" + xl.size());\n//\t\t\tfor(int i = 0 ; i < acc.length; i++){\n//\t\t\t\tSystem.out.print(\"i = \" + i);\n//\t\t\t\tfor(int j = 0; j < acc[i].length; j++){\n//\t\t\t\t\tSystem.out.print(acc[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\t//query\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tint minx = sc.nextInt();\n\t\t\t\tint miny = sc.nextInt();\n\t\t\t\tint maxx = sc.nextInt();\n\t\t\t\tint maxy = sc.nextInt();\n\t\t\t\t\n\t\t\t\tint x1,y1,x2,y2;\n\t\t\t\tx1 = bs(xsorted, minx);\n\t\t\t\ty1 = bs(ysorted, miny);\n\t\t\t\tx2 = bs(xsorted, maxx);\n\t\t\t\tif(Arrays.binarySearch(xsorted, maxx) >= 0) x2++;\n\t\t\t\ty2 = bs(ysorted, maxy);\n\t\t\t\tif(Arrays.binarySearch(ysorted, maxy) >= 0) y2++;\n\t\t\t\t\n\t\t\t\t//System.out.println(\"x1 = \" + x1 + \"y1 = \" + y1 + \"x2 = \" + x2 +\" y2 = \" + y2);\n\t\t\t\t\n\t\t\t\tint res = acc[y2][x2] + acc[y1][x1] - acc[y2][x1] - acc[y1][x2];\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\n\tprivate int bs(int[] a, int x) {\n\t\tint mid, left = 0, right = a.length -1;\n\t\twhile(left <= right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(a[mid] == x){\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\tif(a[mid] < x){\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tint N = nextInt();\n\t\tint M = nextInt();\n\n\t\tint[] x = new int[N];// x座標でソートした時の宝物の座標\n\t\tint[] y = new int[N];// y座標でソートした時の宝物の座標\n\n\t\tint[][] map = new int[N + 1][N + 1];\n\t\tTreasure[] treasure = new Treasure[N];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ttreasure[i] = new Treasure(nextInt(), nextInt());\n\t\t}\n\n\t\t// x座標でソートしてindexをつける\n\t\tArrays.sort(treasure, new ComparatorX());\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = treasure[i].x * 2;\n\t\t\ttreasure[i].xindex = i;\n\t\t}\n\n\t\t// y座標でソートしてインデックスをつける\n\t\tArrays.sort(treasure, new ComparatorY());\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ty[i] = treasure[i].y * 2;\n\t\t\ttreasure[i].yindex = i;\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tmap[treasure[i].xindex + 1][treasure[i].yindex + 1]++;\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tmap[i][j] += map[i - 1][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tmap[i][j] += map[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x1 = nextInt() * 2;\n\t\t\tint y1 = nextInt() * 2;\n\t\t\tint x2 = nextInt() * 2;\n\t\t\tint y2 = nextInt() * 2;\n\t\t\tx1 = binarySearch(x, x1 - 1) + 1;\n\t\t\ty1 = binarySearch(y, y1 - 1) + 1;\n\t\t\tx2 = binarySearch(x, x2 + 1) + 1;\n\t\t\ty2 = binarySearch(y, y2 + 1) + 1;\n\t\t\tSystem.out.println(map[x2][y2] - map[x2][y1] - map[x1][y2] + map[x1][y1]);\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic int binarySearch(int[] array, int num) {\n\t\tint first = 0;\n\t\tint last = array.length - 1;\n\t\tint center = (first + last) / 2;\n\t\twhile (first <= last) {\n\t\t\tif (center < array.length - 1) {\n\t\t\t\tif (array[center] < num) {\n\t\t\t\t\tif (num < array[center + 1]) {\n\t\t\t\t\t\treturn center;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// num >= array[center + 1]なので前端をcenter+1にする\n\t\t\t\t\t\tfirst = center + 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// array[center] >= numなので後端をcenter-1にする\n\t\t\t\t\tlast = center - 1;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn array.length - 1;\n\t\t\t}\n\t\t\tcenter = (first + last) / 2;\n\t\t}\n\t\treturn -1;\n\t}\n\n}\n\nclass Treasure {\n\tint x = 0;\n\tint y = 0;\n\tint xindex = 0;\n\tint yindex = 0;\n\n\tpublic Treasure(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass ComparatorX implements Comparator<Treasure> {\n\tpublic int compare(Treasure t1, Treasure t2) {\n\t\treturn t1.x - t2.x;\n\t}\n}\n\nclass ComparatorY implements Comparator<Treasure> {\n\tpublic int compare(Treasure t1, Treasure t2) {\n\t\treturn t1.y - t2.y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tint[] x = new int[n];\n\t\t\tint[] y = new int[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tx[i] = sc.nextInt();\n\t\t\t\ty[i] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tint cnt, a, b, c, d;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tcnt = 0;\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tc = sc.nextInt();\n\t\t\t\td = sc.nextInt();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(a<=x[j] && x[j]<=c && b<=y[j] && y[j]<=d) cnt++;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(cnt);\n\t\t\t}\t\t\t\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.awt.geom.Line2D;\nimport java.io.*;\nimport java.util.*;\n\npublic class Main {\n\tFastScanner in = new FastScanner(System.in);\n\tPrintWriter out = new PrintWriter(System.out);\n\t\n\tint lower_bound(int[] a, int key) {\n\t\tint x = Arrays.binarySearch(a, key);\n\t\t\n\t\tif (x >= 0) return x;\n\t\telse {\n\t\t\treturn -(x + 1);\n\t\t}\n\t}\n\n\tint upper_bound(int[] a, int key) {\n\t\tint x = Arrays.binarySearch(a, key);\n\t\t\n\t\tif (x >= 0) return x;\n\t\telse {\n\t\t\treturn -(x + 2);\n\t\t}\n\t}\n\t\n\tpublic void run() {\n\t\tint n = in.nextInt(), m = in.nextInt();\n\t\tint[] X = new int[n];\n\t\tint[] Y = new int[n];\n\t\t\n\t\tTreeSet<Integer> xset = new TreeSet<Integer>();\n\t\tTreeSet<Integer> yset = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tX[i] = in.nextInt();\n\t\t\tY[i] = in.nextInt();\n\t\t\txset.add(X[i]);\n\t\t\tyset.add(Y[i]);\n\t\t}\n\t\t\n\t\txset.add(Integer.MIN_VALUE);\n\t\txset.add(Integer.MAX_VALUE);\n\t\tyset.add(Integer.MIN_VALUE);\n\t\tyset.add(Integer.MAX_VALUE);\n\t\tHashMap<Integer, Integer> xmap = new HashMap<Integer, Integer>();\n\t\tHashMap<Integer, Integer> ymap = new HashMap<Integer, Integer>();\n\t\t\n\t\tint[] xpos = new int[xset.size()];\n\t\tint[] ypos = new int[yset.size()];\n\t\tfor (int xs : xset) {\n\t\t\txpos[xmap.size()] = xs;\n\t\t\tif (!xmap.containsKey(xs))\n\t\t\t\txmap.put(xs, xmap.size());\n\t\t}\n\t\t\n\t\tfor (int ys : yset) {\n\t\t\typos[ymap.size()] = ys;\n\t\t\tif (!ymap.containsKey(ys))\n\t\t\t\tymap.put(ys, ymap.size());\n\t\t}\n\t\t\n\t\tint W = xmap.size(), H = ymap.size();\n\t\tint[][] dp = new int[H][W];\n\t\t\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tdp[ymap.get(Y[i])][xmap.get(X[i])]++;\n\t\t}\n\t\tfor (int i = 0; i < H - 1; i++) {\n\t\t\tfor (int j = 0; j < W - 1; j++) {\n\t\t\t\tdp[i+1][j+1] = dp[i+1][j+1] + dp[i+1][j] + dp[i][j+1] - dp[i][j];\n\t\t\t}\n\t\t}\n\t\t/*\n\t\tSystem.out.println();\n\t\tfor (int i = 0; i < H; i++) {\n\t\t\tSystem.out.println(Arrays.toString(dp[i]));\n\t\t}\n\t\t*/\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint lx = lower_bound(xpos, in.nextInt());\n\t\t\tint ly = lower_bound(ypos, in.nextInt());\n\t\t\tint rx = upper_bound(xpos, in.nextInt());\n\t\t\tint ry = upper_bound(ypos, in.nextInt());\n\t\t\t\n\t\t\tout.println(dp[ry][rx] + dp[ly-1][lx-1] - dp[ry][lx-1] - dp[ly-1][rx]);\n\t\t}\n\t\tout.close();\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic void mapDebug(int[][] a) {\n\t\tSystem.out.println(\"--------map display---------\");\n\n\t\tfor (int i = 0; i < a.length; i++) {\n\t\t\tfor (int j = 0; j < a[i].length; j++) {\n\t\t\t\tSystem.out.printf(\"%3d \", a[i][j]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\n\t\tSystem.out.println(\"----------------------------\");\n\t\tSystem.out.println();\n\t}\n\n\tpublic void debug(Object... obj) {\n\t\tSystem.out.println(Arrays.deepToString(obj));\n\t}\n\n\tclass FastScanner {\n\t\tprivate InputStream stream;\n\t\tprivate byte[] buf = new byte[1024];\n\t\tprivate int curChar;\n\t\tprivate int numChars;\n\n\t\tpublic FastScanner(InputStream stream) {\n\t\t\tthis.stream = stream;\n\t\t\t//stream = new FileInputStream(new File(\"dec.in\"));\n\n\t\t}\n\n\t\tint read() {\n\t\t\tif (numChars == -1)\n\t\t\t\tthrow new InputMismatchException();\n\t\t\tif (curChar >= numChars) {\n\t\t\t\tcurChar = 0;\n\t\t\t\ttry {\n\t\t\t\t\tnumChars = stream.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new InputMismatchException();\n\t\t\t\t}\n\t\t\t\tif (numChars <= 0)\n\t\t\t\t\treturn -1;\n\t\t\t}\n\t\t\treturn buf[curChar++];\n\t\t}\n\n\t\tboolean isSpaceChar(int c) {\n\t\t\treturn c == ' ' || c == '\\n' || c == '\\r' || c == '\\t' || c == -1;\n\t\t}\n\n\t\tboolean isEndline(int c) {\n\t\t\treturn c == '\\n' || c == '\\r' || c == -1;\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\n\t\tint[] nextIntArray(int n) {\n\t\t\tint[] array = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextInt();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tint[][] nextIntMap(int n, int m) {\n\t\t\tint[][] map = new int[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextIntArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tlong[] nextLongArray(int n) {\n\t\t\tlong[] array = new long[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextLong();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tlong[][] nextLongMap(int n, int m) {\n\t\t\tlong[][] map = new long[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextLongArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\n\t\tdouble[] nextDoubleArray(int n) {\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = nextDouble();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tdouble[][] nextDoubleMap(int n, int m) {\n\t\t\tdouble[][] map = new double[n][m];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tmap[i] = in.nextDoubleArray(m);\n\t\t\t}\n\t\t\treturn map;\n\t\t}\n\n\t\tString next() {\n\t\t\tint c = read();\n\t\t\twhile (isSpaceChar(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isSpaceChar(c));\n\t\t\treturn res.toString();\n\t\t}\n\n\t\tString[] nextStringArray(int n) {\n\t\t\tString[] array = new String[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tarray[i] = next();\n\n\t\t\treturn array;\n\t\t}\n\n\t\tString nextLine() {\n\t\t\tint c = read();\n\t\t\twhile (isEndline(c))\n\t\t\t\tc = read();\n\t\t\tStringBuilder res = new StringBuilder();\n\t\t\tdo {\n\t\t\t\tres.appendCodePoint(c);\n\t\t\t\tc = read();\n\t\t\t} while (!isEndline(c));\n\t\t\treturn res.toString();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int m = sc.nextInt();\n\t\t\n\t\t\n\t\tint x_base[] = new int[n];\n\t\tint y_base[] = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_base[i] = sc.nextInt();\n\t\t\ty_base[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tTreeSet<Integer> x_set = new TreeSet<Integer>();\n\t\tTreeSet<Integer> y_set = new TreeSet<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_set.add(x_base[i]);\n\t\t\ty_set.add(y_base[i]);\n\t\t}\n\t\t\n\t\tint[] x_array = new int[x_set.size()];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tx_array[i] = x_set.pollFirst();\n\t\t}\n\t\t\n\t\tint[] y_array = new int[y_set.size()];\n\t\tfor(int i = 0; i < y_array.length; i++){\n\t\t\ty_array[i] = y_set.pollFirst();\n\t\t}\n\t\t\n\t\tint col[][] = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcol[Arrays.binarySearch(x_array,x_base[i])][Arrays.binarySearch(y_array,y_base[i])]++;\n\t\t}\n\t\t\n\t\tint[][] pre = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\t\t\n\t\t\t\tif(i != 0 && j != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]  + col[i][j];\n\t\t\t\t}else if(i != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + col[i][j];\n\t\t\t\t}else if(j != 0){\n\t\t\t\t\tpre[i][j] = pre[i][j-1] + col[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tpre[i][j] = col[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* ok */\n\t\t\n//\t\tfor(int i = 0; i < x_array.length; i++){\n//\t\t\tfor(int j = 0; j < y_array.length; j++){\n//\t\t\t\tSystem.out.print(pre[i][j] + \" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tint x1_b = Arrays.binarySearch(x_array, x1);\n\t\t\tint y1_b = Arrays.binarySearch(y_array, y1);\n\t\t\tint x2_b = Arrays.binarySearch(x_array, x2);\n\t\t\tint y2_b = Arrays.binarySearch(y_array, y2);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tx1_b = x1_b < 0 ? -x1_b - 1 : x1_b;\n\t\t\ty1_b = y1_b < 0 ? -y1_b - 1 : y1_b;\n\n\t\t\tx2_b = x2_b < 0 ? -x2_b - 2 : x2_b;\n\t\t\ty2_b = y2_b < 0 ? -y2_b - 2 : y2_b;\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\t\n\t\t\t//x2_b = x2_b >= x_array.length ? x_array.length-1 : x2_b;\n\t\t\t//y2_b = y2_b >= y_array.length ? y_array.length-1 : y2_b;\n\t\t\t/*\n\t\t\tSystem.out.println(Arrays.toString(x_array));\n\t\t\tSystem.out.println(x_array.length + \",\" + x1_b);\n\t\t\tSystem.out.println(Arrays.toString(y_array));\n\t\t\tSystem.out.println(y_array.length + \",\" + y1_b);\n\t\t\tSystem.out.println(Arrays.toString(x_array));\n\t\t\tSystem.out.println(x_array.length + \",\" + x2_b);\n\t\t\tSystem.out.println(Arrays.toString(y_array));\n\t\t\tSystem.out.println(y_array.length + \",\" + y2_b);\n\t\t\t*/\n\t\t\tif(x1_b > x2_b || y1_b > y2_b){\n\t\t\t\tsum = 0;\n\t\t\t}else if(x1_b != 0 && y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b-1] - pre[x2_b-1][y1_b-1] + pre[x1_b-1][y1_b-1];\n\t\t\t}else if(x1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b];\n\t\t\t}else if(y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x2_b][y1_b-1];\n\t\t\t}else{\n\t\t\t\tsum = pre[x2_b][y2_b];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\tint cnt;\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n\t\t\tcnt++;\n\t\t\tif(left==null)return num;\n\t\t\tleft.reportAll(); right.reportAll();\n\t\t\treturn num;\n\t\t}\n\t}\n\tNode make2DTree(PriorityQueue<P> q, int depth, double lx, double rx, double ly, double ry, Node parent){\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(q.size()==1){\n\t\t\tres.point = q.poll();\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tint mid = (q.size()-1)/2, idx = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tif(idx==mid)res.point = q.peek();\n\t\t\tif(idx++ <= mid)L.add(q.poll());\n\t\t\telse R.add(q.poll());\n\t\t}\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(L, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(R, depth+1, res.point.x, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(L, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(R, depth+1, lx, rx, res.point.y, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tPriorityQueue<P> q = new PriorityQueue<P>(list.size(), xsort);\n\t\tfor(P p:list)q.add(p);\n\t\treturn make2DTree(q, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>();\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n\t\twhile(m--!=0){\n\t\t\tcnt = 0;\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n//\t\t\tSystem.out.println(root.search(x1, x2, y1, y2));\n\t\t\troot.search(x1, x2, y1, y2);\n\t\t\tSystem.out.println(cnt);\n\t\t}\n//\t\tSystem.out.println(root.num);\n//\t\tSystem.out.println(System.currentTimeMillis()-T+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\n\t\tTreasure[] treasure = new Treasure[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttreasure[i] = new Treasure(nextInt(), nextInt());\n\t\t}\n\n\t\tArrays.sort(treasure);\n\n\t\tfor (int q = 0; q < m; q++) {\n\t\t\tint count = 0;\n\t\t\tint x1 = nextInt();\n\t\t\tint y1 = nextInt();\n\t\t\tint x2 = nextInt();\n\t\t\tint y2 = nextInt();\n\n\t\t\tfor (int i = 0; i < treasure.length; i++) {\n\t\t\t\tif (treasure[i].x < x1) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor (int k = i; k < treasure.length; k++) {\n\t\t\t\t\tif (treasure[k].x > x2) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (treasure[k].y >= y1 && treasure[k].y <= y2) {\n\t\t\t\t\t\tcount++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nclass Treasure implements Comparable<Treasure> {\n\tint x = 0;\n\tint y = 0;\n\n\tpublic Treasure(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic int compareTo(Treasure t1) {\n\t\treturn this.x - t1.x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tAOJ2426(){\n\t\t\t//while(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\t//if(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t//}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\tTreeSet<Integer> xs=new TreeSet<Integer>(),ys=new TreeSet<Integer>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++)\t++sum[Arrays.binarySearch(x2, x1[i])][Arrays.binarySearch(y2, y1[i])];\n\t\t\tfor(int x=1; x<x2.length; x++)\tsum[x][0]+=sum[x-1][0];\n\t\t\tfor(int y=1; y<y2.length; y++)\tsum[0][y]+=sum[0][y-1];\n\t\t\tfor(int x=1; x<x2.length; x++)for(int y=1; y<y2.length; y++)\tsum[x][y]+=sum[x-1][y]+sum[x][y-1]-sum[x-1][y-1];\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=sc.nextInt(),ym1=sc.nextInt(),xm2=sc.nextInt(),ym2=sc.nextInt();\n\t\t\t\tint tmp=Arrays.binarySearch(x2, xm1);\n\t\t\t\tint xidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym1);\n\t\t\t\tint yidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(x2, xm2);\n\t\t\t\tint xidx2=(tmp>=0?tmp:min(x2.length-1, abs(tmp)-2));\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym2);\n\t\t\t\tint yidx2=(tmp>=0?tmp:min(y2.length-1, abs(tmp)-2));\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println(sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.binarySearch;\n\nimport java.io.IOException;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] xs = new int[n];\n\t\tint[] ys = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txs[i] = nextInt();\n\t\t\tys[i] = nextInt();\n\t\t}\n\n\t\tTreeSet<Integer> xSet = new TreeSet<Integer>();\n\t\tTreeSet<Integer> ySet = new TreeSet<Integer>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txSet.add(xs[i]);\n\t\t\tySet.add(ys[i]);\n\t\t}\n\t\txSet.add((int) 1e9);\n\t\tySet.add((int) 1e9);\n\t\txSet.add((int) -1e9);\n\t\tySet.add((int) -1e9);\n\n\t\tInteger[] xss = xSet.toArray(new Integer[0]);\n\t\tInteger[] yss = ySet.toArray(new Integer[0]);\n\n\t\tint w = xss.length;\n\t\tint h = yss.length;\n\n\t\tint[][] a = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = binarySearch(xss, xs[i]);\n\t\t\tint y = binarySearch(yss, ys[i]);\n\t\t\ta[y + 1][x + 1]++;\n\t\t}\n\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\ta[j + 1][i + 1] += a[j + 1][i] + a[j][i + 1] - a[j][i];\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x1 = binarySearch(xss, xSet.ceiling(nextInt()));\n\t\t\tint y1 = binarySearch(yss, ySet.ceiling(nextInt()));\n\t\t\tint x2 = binarySearch(xss, xSet.floor(nextInt())) + 1;\n\t\t\tint y2 = binarySearch(yss, ySet.floor(nextInt())) + 1;\n\t\t\tsb.append(a[y2][x2] - a[y1][x2] - a[y2][x1] + a[y1][x1]);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.println(sb.toString());\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n/**\n * AOOJ id=2426\n * Treasure Hunt\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tint n;\n\tint m;\n\tint[] x;\n\tint[] y;\n\tScanner sc;\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\t\n\t\tx = new int[n];\n\t\ty = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tpublic void solve() {\n\t\tint[] xc = new int[x.length+1];\n\t\tint[] yc = new int[y.length+1];\n\t\txc[0] = Integer.MIN_VALUE;\n\t\tyc[0] = Integer.MIN_VALUE;\n\t\tSystem.arraycopy(x, 0, xc, 1, x.length);\n\t\tSystem.arraycopy(y, 0, yc, 1, y.length);\n\t\txc = compress(xc);\n\t\tyc = compress(yc);\n\t\tfor(int i=0;i<x.length;i++){\n\t\t\tx[i] = Arrays.binarySearch(xc, x[i]);\n\t\t\ty[i] = Arrays.binarySearch(yc, y[i]);\n\t\t}\n\t\t\n\t\tint[][] count = new int[yc.length][xc.length];\n\t\tfor(int i=0;i<x.length;i++)\n\t\t\tcount[y[i]][x[i]]++;\n\t\t\n\t\tfor(int i=1;i<yc.length;i++)\n\t\t\tfor(int j=1;j<xc.length;j++)\n\t\t\t\tcount[i][j] += count[i][j-1];\n\t\t\n\t\tfor(int i=1;i<xc.length;i++)\n\t\t\tfor(int j=1;j<yc.length;j++)\n\t\t\t\tcount[j][i] += count[j-1][i];\n\t\t\n//\t\tfor(int i=0;i<count.length;i++)\n//\t\t\tSystem.out.println(Arrays.toString(count[i]));\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint[] c =new int[4];\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tc[j] = Arrays.binarySearch(j%2==0 ? xc : yc, sc.nextInt());\n\t\t\t\tc[j] = c[j]>=0 ? c[j] : (c[j]+1)*(-1) - (j<2 ? 0 : 1);\n\t\t\t}\n\t\t\tc[0] = Math.max(0, c[0]-1);\n\t\t\tc[1] = Math.max(0, c[1]-1);\n//\t\t\tSystem.out.println(Arrays.toString(c));\n\t\t\tSystem.out.println(count[c[3]][c[2]] + count[c[1]][c[0]]\n\t\t\t\t\t-count[c[1]][c[2]] - count[c[3]][c[0]]);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate int[] compress(int[] a){\n\t\tSet<Integer> set = new TreeSet<>();\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tset.add(a[i]);\n\t\t}\n\t\tIterator<Integer> iter = set.iterator();\n\t\tint[] ia = new int[set.size()];\n\t\tfor(int i=0;i<ia.length;i++)\n\t\t\tia[i] = iter.next();\n\t\t\n\t\treturn ia;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tAOJ2426(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\tif(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\tTreeSet<Integer> xs=new TreeSet<Integer>(),ys=new TreeSet<Integer>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\t//System.out.println(ys.size()+\"\\n\"+ys);\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tint xidx=0,yidx=0;\n\t\t\t\tfor(; xidx<xs.size(); xidx++)if(x1[i]==x2[xidx])\tbreak;\n\t\t\t\tfor(; yidx<ys.size(); yidx++)if(y1[i]==y2[yidx])\tbreak;\n\t\t\t\tfor(int x=xidx; x<xs.size(); x++)for(int y=yidx; y<ys.size(); y++)sum[x][y]++;\n\t\t\t}\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=sc.nextInt(),ym1=sc.nextInt(),xm2=sc.nextInt(),ym2=sc.nextInt();\n\t\t\t\tint xidx1=0,yidx1=0,xidx2=0,yidx2=0;\n\t\t\t\tfor(; xidx1<xs.size(); xidx1++)if(x2[xidx1]>=xm1)break;\n\t\t\t\tfor(; yidx1<ys.size(); yidx1++)if(y2[yidx1]>=ym1)break;\n\t\t\t\tfor(; xidx2<xs.size()-1; xidx2++)if(x2[xidx2+1]>xm2)break;\n\t\t\t\tfor(; yidx2<ys.size()-1; yidx2++)if(y2[yidx2+1]>ym2)break;\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println(sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tint[][] map = new int[n][2];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmap[i][0] = sc.nextInt();\n\t\t\t\tmap[i][1] = sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(map, new Comparator<int[]>(){\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn o1[0] - o2[0];\n                }\n            });\n\n\t\t\tint cnt, a, b, c, d;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tcnt = 0;\n\t\t\t\ta = sc.nextInt();\n\t\t\t\tb = sc.nextInt();\n\t\t\t\tc = sc.nextInt();\n\t\t\t\td = sc.nextInt();\n\t\t\t\t\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(map[j][0]>=a){\n\t\t\t\t\t\tfor(int k=j;k<n;k++){\n\t\t\t\t\t\t\tif(map[k][0]>c){\n\t\t\t\t\t\t\t\tj = n;\n\t\t\t\t\t\t\t\tk = n;\n\t\t\t\t\t\t\t}else if(b<=map[k][1] && map[k][1]<=d){\n\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(cnt);\n\t\t\t}\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\t\n\tprivate void init() {\n\t\tnew C();\n\t}\n\t\n\tclass C{\n\t\tC(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tPoint2D [] plist= new Point2D[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\tplist[i] = new Point2D.Double(sc.nextDouble(), sc.nextDouble());\n\t\t\t\t}\n\t\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\t\tint minx = sc.nextInt();\n\t\t\t\t\tint miny = sc.nextInt();\n\t\t\t\t\tint maxx = sc.nextInt();\n\t\t\t\t\tint maxy = sc.nextInt();\n\t\t\t\t\tint count = 0;\n\t\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\t\tif(minx <= plist[j].getX() && miny <= plist[j].getY() &&\n\t\t\t\t\t\t\t\tplist[j].getX() <= maxx && plist[j].getY() <=maxy){\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tSystem.out.println(count);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass F{\n\t\tint N,C;\n\t\tint[][] W,E;\n\t\tint[] wc,ec;\n\t\tArrayList<State1> recAns;\n\t\tint stepAns;\n\t\tHashMap<String,Integer> visited;\n\t\tHashSet<State2> Er,Wr;\n\t\tF(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\t\n\t\t\t\n\t\t\t// int[] tmp=new int[N*M];\n\t\t\t\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tW[x][y]=sc.nextInt();\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] init=new boolean[N][N];\n\t\t\t\n\t\t\tint[] w=new int[N], h=new int[N];\n\t\t\tStringBuilder sb=new StringBuilder();\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tsb.append(str);\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tlong start=System.currentTimeMillis();\n\t\t\t\n\t\t\tfor(int lim=0; lim<50; lim++){\n\t\t\t\tC=0;\n\t\t\t\tEr=new HashSet<Main.F.State2>();\n\t\t\t\tWr=new HashSet<Main.F.State2>();\n\t\t\t\tvisited=new HashMap<String,Integer>();\n\t\t\t\tvisited.put(sb.toString(),0);\n\t\t\t\tint[] ww=new int[N], hh=new int[N];\n\t\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\t\tww[i]=w[i];\thh[i]=h[i];\n\t\t\t\t}\n\t\t\t\tif(IDDFS(ww, hh, new StringBuilder(sb.toString()), 0, 0, lim, new ArrayList<State1>(), -1, -1)){\n\t\t\t\t\tSystem.out.println(lim);\n\t\t\t\t\t//System.out.println(stepAns);\n\t\t\t\t\tSystem.out.println(recAns.size());\n\t\t\t\t\tfor(State1 s1:recAns)\tSystem.out.println(s1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tSystem.out.println(\"LIM\"+lim+\" \"+(System.currentTimeMillis()-start)+\"msecs \"+C+\"steps\");\n\t\t\t}\n\t\t}\n\t\tboolean IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State1> rec,int lx,int ly){\n\t\t\t++C;\n\t\t\tboolean f=true;\n\t\t\tint up=0,down=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tif(h[i]!=1){\n\t\t\t\t\tf=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f){\n\t\t\t\t// TODO\n\t\t\t\tSystem.out.println(\"END \"+cost+\"cost \"+depth+\"steps\");\n\t\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\t\tfor(int y=0; y<N; y++)\tSystem.out.println(map.substring(N*y, N*(y+1)));\n\t\t\t\trecAns=rec;\n\t\t\t\tstepAns=depth;\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(\"cost\"+cost+\" depth\"+depth);\n\t\t\tSystem.out.println(\"W \"+Arrays.toString(w));\n\t\t\tSystem.out.println(\"H \"+Arrays.toString(h));\n\t\t\tSystem.out.println(map);\n\n\t\t\t\n\t\t\tint hs=0;\n\t\t\t\n\t\t\t// TODO hs\n\t\t\t\n\t\t\tif(cost>=lim)\treturn false;\n\t\t\t\n\t\t\tboolean wf=true;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='o'){\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[x][y]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(h[x]>=1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(x*N+y)=='o'){\n\t\t\t\t\t\t\tif(y==lx && x==ly)\tcontinue;\n\t\t\t\t\t\t\t//if(Wr.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\twf=false;\n\t\t\t\t\t\t\th[x]--;\n\t\t\t\t\t\t\tw[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, '.');\n\t\t\t\t\t\t\trec.add(new State1(y+1, x+1, true));\n\t\t\t\t\t\t\t//Er.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+E[y][x]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+E[y][x], depth+1, lim, rec, y, x))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\th[x]++;\n\t\t\t\t\t\t\tw[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(x*N+y, 'o');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Er.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t//if(!wf)\treturn false;\n\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\tif(w[x]<1){\n\t\t\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\t\t\tif(map.charAt(y*N+x)=='.'){\n\t\t\t\t\t\t\t//if(Er.contains(new State2(x,y)))\tcontinue;\n\t\t\t\t\t\t\tif(x==lx && y==ly)\tcontinue;\n\t\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\t\th[y]++;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, 'o');\n\t\t\t\t\t\t\trec.add(new State1(x+1, y+1, false));\n\t\t\t\t\t\t\t//Wr.add(new State2(x,y));\n\t\t\t\t\t\t\tif(!visited.containsKey(map.toString()) || visited.get(map.toString())>cost+E[y][x]){\n\t\t\t\t\t\t\t\tvisited.put(map.toString(),cost+W[x][y]);\n\t\t\t\t\t\t\t\tif(IDDFS(w, h, map, cost+W[x][y], depth+1, lim, rec, x, y))\treturn true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tw[x]--;\n\t\t\t\t\t\t\th[y]--;\n\t\t\t\t\t\t\tmap.setCharAt(y*N+x, '.');\n\t\t\t\t\t\t\trec.remove(rec.size()-1);\n\t\t\t\t\t\t\t//Wr.remove(new State2(x,y));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tclass State1{\n\t\t\tint x, y;\n\t\t\tboolean f;\n\t\t\tState1(int x,int y,boolean f){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.f=f;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+\" \"+(f?\" erase\":\" write\");\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tState2(int x,int y){\n\t\t\t\tthis.x=x;\tthis.y=y;\n\t\t\t}\n\t\t\t@Override public int hashCode(){\n\t\t\t\tint ret=17;\n\t\t\t\tret=ret*31+x;\n\t\t\t\tret=ret*31+y;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t\t@Override public boolean equals(Object obj){\n\t\t\t\tif(this==obj)\treturn true;\n\t\t\t\tif(!(obj instanceof State2))\treturn false;\n\t\t\t\tState2 st2=(State2)obj;\n\t\t\t\tif(this.x==st2.x && this.y==st2.y)\treturn true;\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass B {\n\t\tint INF = 1 << 24;\n\t\tint [][] vx = {{0,1,1,0,-1,-1,0},  {0, 1,1, 0, -1, -1,0}};\n\t\tint [][] vy = {{1,0,-1,-1,-1,0,0}, {1, 1,0,-1, 0, 1,0}};\n\t\tint ly, lx;\n\t\tint offset = 200;\n\t\t\n\t\tclass C implements Comparable<C>{\n\t\t\tint x, y,step, cost;\n\t\t\t\n\t\t\tpublic C(int x, int y, int step, int cost) {\n\t\t\t\tthis.x = x;\n\t\t\t\tthis.y = y;\n\t\t\t\tthis.step = step;\n\t\t\t\tthis.cost = cost;\n\t\t\t}\n\t\t\t\n\t\t\t@Override\n\t\t\tpublic int compareTo(C o) {\n\t\t\t\tif(this.cost < o.cost) return -1;\n\t\t\t\tif(this.cost > o.cost) return 1;\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic String toString() {\n\t\t\t\treturn \"C [x=\" + x + \", y=\" + y + \", step=\" + step + \", cost=\"\n\t\t\t\t\t\t+ cost + \"]\";\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tB(){\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint sx = sc.nextInt();\n\t\t\t\tint sy = sc.nextInt();\n\t\t\t\tint gx = sc.nextInt();\n\t\t\t\tint gy = sc.nextInt();\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tint [] xlist = new int[n];\n\t\t\t\tint [] ylist = new int[n];\n\t\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\t}\n\t\t\t\tlx = sc.nextInt();\n\t\t\t\tly = sc.nextInt();\n\t\t\t\tPriorityQueue<C> open = new PriorityQueue<Main.B.C>();\n\t\t\t\topen.add(new C(sx + offset, sy + offset,0,0) );\n\t\t\t\t\n\t\t\t\tint [][][] close = new int[offset * 2][offset * 2][6];\n\t\t\t\tfor(int i = 0; i < offset * 2; i++){\n\t\t\t\t\tfor(int j = 0; j < offset * 2; j++){\n\t\t\t\t\t\tArrays.fill(close[i][j], INF);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//start\n\t\t\t\tclose[sy + offset][sx + offset][0] = 0;\n\t\t\t\t\n\t\t\t\tboolean [][] k = new boolean[offset * 2][offset* 2];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tint xx = xlist[i] + offset;\n\t\t\t\t\tint yy = ylist[i] + offset;\n\t\t\t\t\tk[yy][xx] = true;\n\t\t\t\t}\n\t\t\t\tint ans = -1;\n\t\t\t\t\n\t\t\t\twhile(! open.isEmpty()){\n\t\t\t\t\tC now = open.poll();\n\t\t\t\t\tif(now.x == gx + offset && now.y == gy + offset){\n\t\t\t\t\t\tans = now.cost;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfor(int i = 0; i < vx[0].length; i++){\n//\t\t\t\t\t\tif(now.x == offset || now.y == offset ){\n//\t\t\t\t\t\t\tif(i == 6) continue;\n//\t\t\t\t\t\t}\n\t\t\t\t\t\tint xx = now.x + vx[now.x % 2][i];\n\t\t\t\t\t\tint yy = now.y + vy[now.x % 2][i];\n\t\t\t\t\t\tif(! isOK(xx,yy)) continue;\n\t\t\t\t\t\tif(k[yy][xx]) continue;\n\t\t\t\t\t\tint nextcost = now.cost;\n\t\t\t\t\t\tlong dir = Math.abs((long)(now.x - offset) * (now.y - offset) * (now.step) ) % 6;\n\t\t\t\t\t\tif(i != dir){\n\t\t\t\t\t\t\tnextcost++;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t//System.out.println(\"xx = \" + xx + \" \" + yy + \" \" + now.step + \" \" + now.x);\n\t\t\t\t\t\t//System.out.println(close[yy][xx][now.step + 1]);\n\t\t\t\t\t\tif(close[yy][xx][(now.step + 1) % 6] <= nextcost) continue;\n\t\t\t\t\t\tclose[yy][xx][(now.step + 1) % 6] = nextcost;\n\t\t\t\t\t\topen.add(new C(xx, yy, now.step + 1, nextcost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isOK(int xx, int yy) {\n\t\t\tif(-lx + offset <= xx && xx <= lx + offset && -ly + offset <= yy && yy <= ly + offset){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\t\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int m = sc.nextInt();\n\t\t\n\t\t\n\t\tint x_base[] = new int[n];\n\t\tint y_base[] = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_base[i] = sc.nextInt();\n\t\t\ty_base[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tTreeSet<Integer> x_set = new TreeSet<Integer>();\n\t\tTreeSet<Integer> y_set = new TreeSet<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_set.add(x_base[i]);\n\t\t\ty_set.add(y_base[i]);\n\t\t}\n\t\t\n\t\tint[] x_array = new int[x_set.size()];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tx_array[i] = x_set.pollFirst();\n\t\t}\n\t\t\n\t\tint[] y_array = new int[y_set.size()];\n\t\tfor(int i = 0; i < y_array.length; i++){\n\t\t\ty_array[i] = y_set.pollFirst();\n\t\t}\n\t\t\n\t\tint col[][] = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcol[Arrays.binarySearch(x_array,x_base[i])][Arrays.binarySearch(y_array,y_base[i])]++;\n\t\t}\n\t\t\n\t\tint[][] pre = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\t\t\n\t\t\t\tif(i != 0 && j != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]  + col[i][j];\n\t\t\t\t}else if(i != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + col[i][j];\n\t\t\t\t}else if(j != 0){\n\t\t\t\t\tpre[i][j] = pre[i][j-1] + col[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tpre[i][j] = col[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\tSystem.out.print(y_array[j] + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t\t\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\t\tSystem.out.print(pre[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tint x1_b = Arrays.binarySearch(x_array, x1);\n\t\t\tint y1_b = Arrays.binarySearch(y_array, y1);\n\t\t\tint x2_b = Arrays.binarySearch(x_array, x2);\n\t\t\tint y2_b = Arrays.binarySearch(y_array, y2);\n\t\t\t\n\t\t\tx1_b = x1_b < 0 ? -x1_b - 1 : x1_b;\n\t\t\ty1_b = y1_b < 0 ? -y1_b - 1 : y1_b;\n\t\t\tx2_b = x2_b < 0 ? -x2_b - 1 : x2_b;\n\t\t\ty2_b = y2_b < 0 ? -y2_b - 1 : y2_b;\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\t\n\t\t\tx2_b = x2_b >= x_array.length ? x_array.length-1 : x2_b;\n\t\t\ty2_b = y2_b >= y_array.length ? y_array.length-1 : y2_b;\n\t\t\t\n\t\t\tSystem.out.println(x_array.length + \",\" + x1_b);\n\t\t\tSystem.out.println(y_array.length + \",\" + y1_b);\n\t\t\tSystem.out.println(x_array.length + \",\" + x2_b);\n\t\t\tSystem.out.println(y_array.length + \",\" + y2_b);\n\t\t\t\n\t\t\tif(x1_b > x2_b || y1_b > y2_b){\n\t\t\t\tsum = 0;\n\t\t\t}else if(x1_b != 0 && y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b-1] - pre[x2_b-1][y1_b-1] + pre[x1_b-1][y1_b-1];\n\t\t\t}else if(x1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b];\n\t\t\t}else if(y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x2_b][y1_b-1];\n\t\t\t}else{\n\t\t\t\tsum = pre[x2_b][y2_b];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tint N = nextInt();\n\t\tint M = nextInt();\n\n\t\tint[] x = new int[N];// x座標でソートした時の宝物の座標\n\t\tint[] y = new int[N];// y座標でソートした時の宝物の座標\n\n\t\tint[][] map = new int[N + 1][N + 1];\n\t\tTreasure[] treasure = new Treasure[N];\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ttreasure[i] = new Treasure(nextInt(), nextInt());\n\t\t}\n\n\t\t// x座標でソートしてindexをつける\n\t\tArrays.sort(treasure, new ComparatorX());\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = treasure[i].x * 2;\n\t\t\ttreasure[i].xindex = i;\n\t\t}\n\n\t\t// y座標でソートしてインデックスをつける\n\t\tArrays.sort(treasure, new ComparatorY());\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ty[i] = treasure[i].y * 2;\n\t\t\ttreasure[i].yindex = i;\n\t\t}\n\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tmap[treasure[i].xindex + 1][treasure[i].yindex + 1]++;\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tmap[i][j] += map[i - 1][j];\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 1; i <= N; i++) {\n\t\t\tfor (int j = 1; j <= N; j++) {\n\t\t\t\tmap[i][j] += map[i][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tint x1 = nextInt() * 2;\n\t\t\tint y1 = nextInt() * 2;\n\t\t\tint x2 = nextInt() * 2;\n\t\t\tint y2 = nextInt() * 2;\n\t\t\tx1 = binarySearch(x, x1 - 1) + 1;\n\t\t\ty1 = binarySearch(y, y1 - 1) + 1;\n\t\t\tx2 = binarySearch(x, x2 + 1) + 1;\n\t\t\ty2 = binarySearch(y, y2 + 1) + 1;\n\t\t\tSystem.out.println(map[x2][y2] - map[x2][y1] - map[x1][y2] + map[x1][y1]);\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n\tstatic int binarySearch(int[] array, int num) {\n\t\tint first = 0;\n\t\tint last = array.length - 1;\n\t\tint center = (first + last) / 2;\n\t\twhile (first <= last) {\n\t\t\tif (center < array.length - 1) {\n\t\t\t\tif (array[center] < num) {\n\t\t\t\t\tif (num < array[center + 1]) {\n\t\t\t\t\t\treturn center;\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// num >= array[center + 1]なので前端をcenter+1にする\n\t\t\t\t\t\tfirst = center + 1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// array[center] >= numなので後端をcenter-1にする\n\t\t\t\t\tlast = center;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\treturn array.length - 1;\n\t\t\t}\n\t\t\tcenter = (first + last) / 2;\n\t\t}\n\t\treturn -1;\n\t}\n\n}\n\nclass Treasure {\n\tint x = 0;\n\tint y = 0;\n\tint xindex = 0;\n\tint yindex = 0;\n\n\tpublic Treasure(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\n\nclass ComparatorX implements Comparator<Treasure> {\n\tpublic int compare(Treasure t1, Treasure t2) {\n\t\treturn t1.x - t2.x;\n\t}\n}\n\nclass ComparatorY implements Comparator<Treasure> {\n\tpublic int compare(Treasure t1, Treasure t2) {\n\t\treturn t1.y - t2.y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\t\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n\t\t\treturn num;\n\t\t}\n\t}\n\tNode make2DTree(List<P> list, int depth, double lx, double rx, double ly, double ry, Node parent){\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(list.size()==1){\n\t\t\tres.point = list.get(0);\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(list.size(), depth%2==0?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(list.size(), depth%2==0?xsort:ysort);\n\t\tint mid = (list.size()-1)/2;\n\t\tres.point = list.get(mid);\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tif(i<=mid)L.add(list.get(i));\n\t\t\telse R.add(list.get(i));\n\t\t}\n\t\tList<P> leftList = new ArrayList<P>(), rightList = new ArrayList<P>();\n\t\twhile(!L.isEmpty())leftList.add(L.poll());\n\t\twhile(!R.isEmpty())rightList.add(R.poll());\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(leftList, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(rightList, depth+1, res.point.x, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(leftList, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(rightList, depth+1, lx, rx, res.point.y, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tCollections.sort(list, xsort);\n\t\treturn make2DTree(list, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>();\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n\t\twhile(m--!=0){\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\tSystem.out.println(root.search(x1, x2, y1, y2));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.*;\nimport java.util.*;\n\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tlong start=System.currentTimeMillis();\n\t\tnew Main().init();\n\t\t//System.out.println((System.currentTimeMillis()-start)+\"ms\");\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tfinal Scanner2 sc=new Scanner2(System.in);\n\t\tAOJ2426(){\n\t\t\t//while(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\t//if(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t//}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\tTreeSet<Integer> xs=new TreeSet<Integer>(),ys=new TreeSet<Integer>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++)\t++sum[Arrays.binarySearch(x2, x1[i])][Arrays.binarySearch(y2, y1[i])];\n\t\t\tfor(int x=1; x<x2.length; x++)\tsum[x][0]+=sum[x-1][0];\n\t\t\tfor(int y=1; y<y2.length; y++)\tsum[0][y]+=sum[0][y-1];\n\t\t\tfor(int x=1; x<x2.length; x++)for(int y=1; y<y2.length; y++)\tsum[x][y]+=sum[x-1][y]+sum[x][y-1]-sum[x-1][y-1];\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=Integer.parseInt(sc.next()),ym1=Integer.parseInt(sc.next()),xm2=Integer.parseInt(sc.next()),ym2=Integer.parseInt(sc.next());\n\t\t\t\tint tmp=Arrays.binarySearch(x2, xm1);\n\t\t\t\tint xidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym1);\n\t\t\t\tint yidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(x2, xm2);\n\t\t\t\tint xidx2=(tmp>=0?tmp:min(x2.length-1, abs(tmp)-2));\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym2);\n\t\t\t\tint yidx2=(tmp>=0?tmp:min(y2.length-1, abs(tmp)-2));\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println((xidx2<0||yidx2<0? 0: sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// thanks to wata http://www.codeforces.com/contest/138/submission/978329\n\tclass Scanner2 {\n\t\t//InputStream in;\n\t\tBufferedInputStream in;\n\t\tbyte[] buf = new byte[1 << 10];\n\t\tint p, n;\n\t\tboolean[] isSpace = new boolean[128];\n\t\tScanner2(InputStream in) {\n\t\t\t//this.in = in;\n\t\t\tthis.in = new BufferedInputStream(in);\n\t\t\tisSpace[' '] = isSpace['\\n'] = isSpace['\\r'] = isSpace['\\t'] = true;\n\t\t}\n\t\tint read() {\n\t\t\tif (n == -1) return -1;\n\t\t\tif (p >= n) {\n\t\t\t\tp = 0;\n\t\t\t\ttry {\n\t\t\t\t\tn = in.read(buf);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t\tif (n <= 0) return -1;\n\t\t\t}\n\t\t\treturn buf[p++];\n\t\t}\n\t\tboolean hasNext() {\n\t\t\tint c = read();\n\t\t\twhile (c >= 0 && isSpace[c]) c = read();\n\t\t\tif (c == -1) return false;\n\t\t\tp--;\n\t\t\treturn true;\n\t\t}\n\t\tString next() {\n\t\t\tif (!hasNext()) throw new InputMismatchException();\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tint c = read();\n\t\t\twhile (c >= 0 && !isSpace[c]) {\n\t\t\t\tsb.append((char)c);\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\treturn sb.toString();\n\t\t}\n\t\tint nextInt() {\n\t\t\tif (!hasNext()) throw new InputMismatchException();\n\t\t\tint c = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tint res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') throw new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (c >= 0 && !isSpace[c]);\n\t\t\treturn res * sgn;\n\t\t}\n\t\tlong nextLong() {\n\t\t\tif (!hasNext()) throw new InputMismatchException();\n\t\t\tint c = read();\n\t\t\tint sgn = 1;\n\t\t\tif (c == '-') {\n\t\t\t\tsgn = -1;\n\t\t\t\tc = read();\n\t\t\t}\n\t\t\tlong res = 0;\n\t\t\tdo {\n\t\t\t\tif (c < '0' || c > '9') throw new InputMismatchException();\n\t\t\t\tres *= 10;\n\t\t\t\tres += c - '0';\n\t\t\t\tc = read();\n\t\t\t} while (c >= 0 && !isSpace[c]);\n\t\t\treturn res * sgn;\n\t\t}\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\tstatic int N, M;\n\tstatic int[] TX, TY;\n\tstatic int[][] ZX, ZY;\n\t\t\t\n\tstatic private void solve()\n\t{\n\t\tTreeSet<Integer> tsx = new TreeSet<Integer>();\n\t\tTreeSet<Integer> tsy = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ttsx.add(new Integer(TX[i]));\n\t\t\ttsy.add(new Integer(TY[i]));\n\t\t}\n\t\tArrayList<Integer> alx = new ArrayList<Integer>(tsx);\n\t\tArrayList<Integer> aly = new ArrayList<Integer>(tsy);\n\t\t\n\t\tint[][] treasure = new int[tsy.size() + 1][tsx.size() + 1];\n\t\tfor (int y = 0; y < tsy.size()+1; y++) {\n\t\t\tfor (int x = 0; x < tsx.size()+1; x++) {\n\t\t\t\ttreasure[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint x = alx.indexOf(new Integer(TX[i]));\n\t\t\tint y = aly.indexOf(new Integer(TY[i]));\t\t\t\n\t\t\ttreasure[y + 1][x + 1]++;\n\t\t}\n\t\t\n\t\tfor (int y = 1; y <= tsy.size(); y++) {\n\t\t\tfor (int x = 1; x <= tsx.size(); x++) {\n\t\t\t\ttreasure[y][x] += treasure[y-1][x] + treasure[y][x-1] - treasure[y-1][x-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tInteger xx1 = tsx.ceiling(new Integer(ZX[i][0]));\n\t\t\tInteger xx2 = tsx.floor(new Integer(ZX[i][1]));\n\t\t\tInteger yy1 = tsy.ceiling(new Integer(ZY[i][0]));\n\t\t\tInteger yy2 = tsy.floor(new Integer(ZY[i][1]));\n\t\t\t\n\t\t\tif( xx1 == null || xx2 == null || yy1 == null || yy2 == null )\n\t\t\t{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint x1 = alx.indexOf(xx1);\n\t\t\tint x2 = alx.indexOf(xx2) + 1;\n\t\t\tint y1 = aly.indexOf(yy1);\n\t\t\tint y2 = aly.indexOf(yy2) + 1;\n\t\t\t\n\t\t\tint ret = treasure[y2][x2] - treasure[y2][x1] - treasure[y1][x2] + treasure[y1][x1];\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\t\n\tstatic public void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tN = sca.nextInt();\n\t\t\tM = sca.nextInt();\n\t\t\t\n\t\t\tTX = new int[N];\n\t\t\tTY = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tTX[i] = sca.nextInt();\n\t\t\t\tTY[i] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tZX = new int[M][2];\n\t\t\tZY = new int[M][2];\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tZX[i][0] = sca.nextInt();\n\t\t\t\tZY[i][0] = sca.nextInt();\n\t\t\t\tZX[i][1] = sca.nextInt();\n\t\t\t\tZY[i][1] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\n\t\tTreasure[] treasure = new Treasure[n];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\ttreasure[i] = new Treasure(nextInt(), nextInt());\n\t\t}\n\n\t\tArrays.sort(treasure);\n\n\t\tfor (int q = 0; q < m; q++) {\n\t\t\tint cnt = 0;\n\t\t\tint x1 = nextInt();\n\t\t\tint y1 = nextInt();\n\t\t\tint x2 = nextInt();\n\t\t\tint y2 = nextInt();\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif (treasure[i].x >= x1) {\n\t\t\t\t\tfor (int k = i; k < n; k++) {\n\t\t\t\t\t\tif (treasure[k].x > x2) {\n\t\t\t\t\t\t\ti = n;\n\t\t\t\t\t\t\tk = n;\n\t\t\t\t\t\t} else if (y1 <= treasure[k].y && treasure[k].y <= y2) {\n\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cnt);\n\t\t}\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nclass Treasure implements Comparable<Treasure> {\n\tint x = 0;\n\tint y = 0;\n\n\tpublic Treasure(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic int compareTo(Treasure t1) {\n\t\treturn this.x - t1.x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.binarySearch;\n\nimport java.io.IOException;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] xs = new int[n];\n\t\tint[] ys = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txs[i] = nextInt();\n\t\t\tys[i] = nextInt();\n\t\t}\n\n\t\tTreeSet<Integer> xSet = new TreeSet<Integer>();\n\t\tTreeSet<Integer> ySet = new TreeSet<Integer>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txSet.add(xs[i]);\n\t\t\tySet.add(ys[i]);\n\t\t}\n\t\txSet.add((int) Integer.MAX_VALUE);\n\t\txSet.add((int) Integer.MIN_VALUE);\n\t\tySet.add((int) Integer.MAX_VALUE);\n\t\tySet.add((int) Integer.MIN_VALUE);\n\n\t\tInteger[] xss = xSet.toArray(new Integer[0]);\n\t\tInteger[] yss = ySet.toArray(new Integer[0]);\n\n\t\tint w = xss.length;\n\t\tint h = yss.length;\n\n\t\tint[][] location = new int[h + 1][w + 1];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = binarySearch(xss, xs[i]);\n\t\t\tint y = binarySearch(yss, ys[i]);\n\t\t\tlocation[y + 1][x + 1]++;\n\t\t}\n\n\t\tfor (int i = 0; i < w; i++) {\n\t\t\tfor (int j = 0; j < h; j++) {\n\t\t\t\tlocation[j + 1][i + 1] += location[j + 1][i] + location[j][i + 1] - location[j][i];\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x1 = binarySearch(xss, xSet.ceiling(nextInt()));\n\t\t\tint y1 = binarySearch(yss, ySet.ceiling(nextInt()));\n\t\t\tint x2 = binarySearch(xss, xSet.floor(nextInt())) + 1;\n\t\t\tint y2 = binarySearch(yss, ySet.floor(nextInt())) + 1;\n\t\t\tsb.append(location[y2][x2] - location[y1][x2] - location[y2][x1] + location[y1][x1]);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Treasure Hunt\n// 2012/09/19\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n, m;\n\tint[] xs, ys;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\txs=new int[n];\n\t\tys=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\txs[i]=sc.nextInt();\n\t\t\tys[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Integer> xSet=new TreeSet<Integer>();\n\t\tTreeSet<Integer> ySet=new TreeSet<Integer>();\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\txSet.add(xs[i]);\n\t\t\tySet.add(ys[i]);\n\t\t}\n\t\txSet.add((int)1e9);\n\t\tySet.add((int)1e9);\n\t\txSet.add((int)-1e9);\n\t\tySet.add((int)-1e9);\n\n\t\tInteger[] xss=xSet.toArray(new Integer[0]);\n\t\tInteger[] yss=ySet.toArray(new Integer[0]);\n\t\t\n\t\tint w=xss.length;\n\t\tint h=yss.length;\n\n\t\tint[][] a=new int[h+1][w+1];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x=binarySearch(xss, xs[i]);\n\t\t\tint y=binarySearch(yss, ys[i]);\n\t\t\ta[y+1][x+1]++;\n\t\t}\n\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\ta[j+1][i+1]+=a[j+1][i]+a[j][i+1]-a[j][i];\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x1=binarySearch(xss, xSet.ceiling(sc.nextInt()));\n\t\t\tint y1=binarySearch(yss, ySet.ceiling(sc.nextInt()));\n\t\t\tint x2=binarySearch(xss, xSet.floor(sc.nextInt()))+1;\n\t\t\tint y2=binarySearch(yss, ySet.floor(sc.nextInt()))+1;\n\t\t\tsb.append(a[y2][x2]-a[y1][x2]-a[y2][x1]+a[y1][x1]);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tprint(sb.toString());\n\t}\n\n\tclass Scanner{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in){\n\t\t\tbr=new BufferedReader(new InputStreamReader(in));\n\t\t\teat(\"\");\n\t\t}\n\n\t\tvoid eat(String s){\n\t\t\tst=new StringTokenizer(s);\n\t\t}\n\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\treturn br.readLine();\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new IOError(e);\n\t\t\t}\n\t\t}\n\n\t\tboolean hasNext(){\n\t\t\twhile(!st.hasMoreTokens()){\n\t\t\t\tString s=nextLine();\n\t\t\t\tif(s==null)\n\t\t\t\t\treturn false;\n\t\t\t\teat(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tString next(){\n\t\t\thasNext();\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tAOJ2426(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\tif(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\tTreeSet<Integer> xs=new TreeSet<>(),ys=new TreeSet<>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\t//System.out.println(ys.size()+\"\\n\"+ys);\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tint xidx=0,yidx=0;\n\t\t\t\tfor(; xidx<xs.size(); xidx++)if(x1[i]==x2[xidx])\tbreak;\n\t\t\t\tfor(; yidx<ys.size(); yidx++)if(y1[i]==y2[yidx])\tbreak;\n\t\t\t\tfor(int x=xidx; x<xs.size(); x++)for(int y=yidx; y<ys.size(); y++)sum[x][y]++;\n\t\t\t}\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=sc.nextInt(),ym1=sc.nextInt(),xm2=sc.nextInt(),ym2=sc.nextInt();\n\t\t\t\tint xidx1=0,yidx1=0,xidx2=0,yidx2=0;\n\t\t\t\tfor(; xidx1<xs.size(); xidx1++)if(x2[xidx1]>=xm1)break;\n\t\t\t\tfor(; yidx1<ys.size(); yidx1++)if(y2[yidx1]>=ym1)break;\n\t\t\t\tfor(; xidx2<xs.size()-1; xidx2++)if(x2[xidx2+1]>xm2)break;\n\t\t\t\tfor(; yidx2<ys.size()-1; yidx2++)if(y2[yidx2+1]>ym2)break;\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println(sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.binarySearch;\n\nimport java.io.IOException;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] xs = new int[n];\n\t\tint[] ys = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txs[i] = nextInt();\n\t\t\tys[i] = nextInt();\n\t\t}\n\n\t\tTreeSet<Integer> xSet = new TreeSet<Integer>();\n\t\tTreeSet<Integer> ySet = new TreeSet<Integer>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txSet.add(xs[i]);\n\t\t\tySet.add(ys[i]);\n\t\t}\n\t\txSet.add((int) Integer.MAX_VALUE);\n\t\txSet.add((int) Integer.MIN_VALUE);\n\t\tySet.add((int) Integer.MAX_VALUE);\n\t\tySet.add((int) Integer.MIN_VALUE);\n\n\t\tInteger[] xss = xSet.toArray(new Integer[0]);\n\t\tInteger[] yss = ySet.toArray(new Integer[0]);\n\n\t\tint w = xss.length;\n\t\tint h = yss.length;\n\n\t\tint[][] a = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = binarySearch(xss, xs[i]);\n\t\t\tint y = binarySearch(yss, ys[i]);\n\t\t\ta[y + 1][x + 1]++;\n\t\t}\n\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\ta[j + 1][i + 1] += a[j + 1][i] + a[j][i + 1] - a[j][i];\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x1 = binarySearch(xss, xSet.ceiling(nextInt()));\n\t\t\tint y1 = binarySearch(yss, ySet.ceiling(nextInt()));\n\t\t\tint x2 = binarySearch(xss, xSet.floor(nextInt())) + 1;\n\t\t\tint y2 = binarySearch(yss, ySet.floor(nextInt())) + 1;\n\t\t\tsb.append(a[y2][x2] - a[y1][x2] - a[y2][x1] + a[y1][x1]);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tAOJ2426(){\n\t\t\t//while(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\t//if(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t//}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\tTreeSet<Integer> xs=new TreeSet<Integer>(),ys=new TreeSet<Integer>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++)\t++sum[Arrays.binarySearch(x2, x1[i])][Arrays.binarySearch(y2, y1[i])];\n\t\t\tfor(int x=1; x<x2.length; x++)\tsum[x][0]+=sum[x-1][0];\n\t\t\tfor(int y=1; y<y2.length; y++)\tsum[0][y]+=sum[0][y-1];\n\t\t\tfor(int x=1; x<x2.length; x++)for(int y=1; y<y2.length; y++)\tsum[x][y]+=sum[x-1][y]+sum[x][y-1]-sum[x-1][y-1];\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=Integer.parseInt(sc.next()),ym1=Integer.parseInt(sc.next()),xm2=Integer.parseInt(sc.next()),ym2=Integer.parseInt(sc.next());\n\t\t\t\tint tmp=Arrays.binarySearch(x2, xm1);\n\t\t\t\tint xidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym1);\n\t\t\t\tint yidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(x2, xm2);\n\t\t\t\tint xidx2=(tmp>=0?tmp:min(x2.length-1, abs(tmp)-2));\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym2);\n\t\t\t\tint yidx2=(tmp>=0?tmp:min(y2.length-1, abs(tmp)-2));\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println((xidx2<0||yidx2<0? 0: sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0)));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Main {\n\t//1700 cording start\n\t//1803 sample matched\n\tboolean isfind;\n\t\n\tprivate void doit(){\n\t\tInStream sc = new InStream();\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint [] xlist = new int[n];\n\t\t\tint [] ylist = new int[n];\n\t\t\tTreeSet<Integer> xl = new TreeSet<Integer>();\n\t\t\tTreeSet<Integer> yl = new TreeSet<Integer>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\txl.add(xlist[i]);\n\t\t\t\tyl.add(ylist[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint [] xsorted = new int[xl.size()];\n\t\t\tint [] ysorted = new int[yl.size()];\n\t\t\tint ind = 0;\n\t\t\tfor(int v: xl){\n\t\t\t\txsorted[ind++] = v;\n\t\t\t}\n\t\t\tind = 0;\n\t\t\tfor(int v: yl){\n\t\t\t\tysorted[ind++] = v;\n\t\t\t}\n\t\t\t\n\t\t\tint [][] acc = new int[yl.size() + 1][xl.size()+1];\n\t\t\tfor(int k = 0 ; k < n; k++){\n\t\t\t\tint x = Arrays.binarySearch(xsorted, xlist[k]) + 1;\n\t\t\t\tint y = Arrays.binarySearch(ysorted, ylist[k]) + 1;\n\t\t\t\tfor(int i = y; i < acc.length; i++){\n\t\t\t\t\tfor(int j = x; j < acc[i].length; j++){\n\t\t\t\t\t\tacc[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(Arrays.toString(ysorted));\n//\t\t\tSystem.out.println(Arrays.toString(xsorted));\n//\t\t\tSystem.out.println(yl.size() + \" \" + xl.size());\n//\t\t\tfor(int i = 0 ; i < acc.length; i++){\n//\t\t\t\tSystem.out.print(\"i = \" + i);\n//\t\t\t\tfor(int j = 0; j < acc[i].length; j++){\n//\t\t\t\t\tSystem.out.print(acc[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\t//query\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tint minx = sc.nextInt();\n\t\t\t\tint miny = sc.nextInt();\n\t\t\t\tint maxx = sc.nextInt();\n\t\t\t\tint maxy = sc.nextInt();\n\t\t\t\t\n\t\t\t\tint x1,y1,x2,y2;\n\t\t\t\tx1 = bs(xsorted, minx);\n\t\t\t\ty1 = bs(ysorted, miny);\n\t\t\t\t\n\t\t\t\tisfind = false;\n\t\t\t\tx2 = bs(xsorted, maxx);\n\t\t\t\tif(isfind) x2++;\n\t\t\t\tisfind = false;\n\t\t\t\ty2 = bs(ysorted, maxy);\n\t\t\t\tif(isfind) y2++;\n\t\t\t\t\n\t\t\t\t//System.out.println(\"x1 = \" + x1 + \"y1 = \" + y1 + \"x2 = \" + x2 +\" y2 = \" + y2);\n\t\t\t\t\n\t\t\t\tint res = acc[y2][x2] + acc[y1][x1] - acc[y2][x1] - acc[y1][x2];\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\n\tprivate int bs(int[] a, int x) {\n\t\tint mid, left = 0, right = a.length -1;\n\t\twhile(left <= right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(a[mid] == x){\n\t\t\t\tisfind = true;\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\tif(a[mid] < x){\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\t\n\tclass InStream{\n\t\tBufferedReader in;\n\t\tStringTokenizer st;\n\t\tpublic InStream() {\n\t\t\tthis.in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tthis.st = null;\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st==null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken(); \n\t\t}\n\t\t\n\t\tboolean hasNext(){\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\treturn true;\n\t\t\t} catch (Exception e) {return false;}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next()); \n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.binarySearch;\n\nimport java.io.IOException;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] xs = new int[n];\n\t\tint[] ys = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txs[i] = nextInt();\n\t\t\tys[i] = nextInt();\n\t\t}\n\n\t\tTreeSet<Integer> xSet = new TreeSet<Integer>();\n\t\tTreeSet<Integer> ySet = new TreeSet<Integer>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txSet.add(xs[i]);\n\t\t\tySet.add(ys[i]);\n\t\t}\n\t\txSet.add((int) 1e9);\n\t\tySet.add((int) 1e9);\n\t\txSet.add((int) -1e9);\n\t\tySet.add((int) -1e9);\n\n\t\tInteger[] xss = xSet.toArray(new Integer[0]);\n\t\tInteger[] yss = ySet.toArray(new Integer[0]);\n\n\t\tint w = xss.length;\n\t\tint h = yss.length;\n\n\t\tint[][] a = new int[h + 1][w + 1];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = binarySearch(xss, xs[i]);\n\t\t\tint y = binarySearch(yss, ys[i]);\n\t\t\ta[y + 1][x + 1]++;\n\t\t}\n\n\t\tfor (int j = 0; j < h; j++) {\n\t\t\tfor (int i = 0; i < w; i++) {\n\t\t\t\ta[j + 1][i + 1] += a[j + 1][i] + a[j][i + 1] - a[j][i];\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x1 = binarySearch(xss, xSet.ceiling(nextInt()));\n\t\t\tint y1 = binarySearch(yss, ySet.ceiling(nextInt()));\n\t\t\tint x2 = binarySearch(xss, xSet.floor(nextInt())) + 1;\n\t\t\tint y2 = binarySearch(yss, ySet.floor(nextInt())) + 1;\n\t\t\tsb.append(a[y2][x2] - a[y1][x2] - a[y2][x1] + a[y1][x1]);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tint[] x = new int[n];\n\t\tint[] y = new int[n];\n\t\tint[][] map = new int[n+1][n+1];\n\t\tTreasure[] treasure = new Treasure[n];\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ttreasure[i] = new Treasure(sc.nextInt(),sc.nextInt());\n\t\t}\n\t\t\n\t\tArrays.sort(treasure,new ComparatorX());\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tx[i] = treasure[i].x * 2;\n\t\t\ttreasure[i].xindex = i;\n\t\t}\n\t\t\n\t\tArrays.sort(treasure,new ComparatorY());\n\t\tfor(int i=0;i<n;i++) {\n\t\t\ty[i] = treasure[i].y * 2;\n\t\t\ttreasure[i].yindex = i;\n\t\t}\n\t\t\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tmap[treasure[i].xindex+1][treasure[i].yindex+1]++;\n\t\t}\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tfor(int j=1;j<=n;j++) {\n\t\t\t\tmap[i][j] += map[i-1][j];\n\t\t\t}\t\t\t\n\t\t}\n\t\tfor(int i=1;i<=n;i++) {\n\t\t\tfor(int j=1;j<=n;j++) {\n\t\t\t\tmap[i][j] += map[i][j-1];\n\t\t\t}\t\t\t\n\t\t}\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tint x1 = sc.nextInt()*2;\n\t\t\tint y1 = sc.nextInt()*2;\n\t\t\tint x2 = sc.nextInt()*2;\n\t\t\tint y2 = sc.nextInt()*2;\n\t\t\tx1 = binarySearch(x, x1-1)+1;\n\t\t\ty1 = binarySearch(y, y1-1)+1;\n\t\t\tx2 = binarySearch(x, x2+1)+1;\n\t\t\ty2 = binarySearch(y, y2+1)+1;\n\t\t\tSystem.out.println(map[x2][y2]-map[x2][y1]-map[x1][y2]+map[x1][y1]);\n\t\t}\n\t\t\n\t}\n\tpublic static int binarySearch(int[] array,int num) {\n\t\tint first = 0;\n\t\tint last = array.length-1;\n\t\tint center = (first+last)/2;\n\t\twhile(first<=last) {\n\t\t\tif (center<array.length-1) {\n\t\t\t\tif (array[center] < num) {\n\t\t\t\t\tif (num < array[center+1]) {\n\t\t\t\t\t\treturn center;\n\t\t\t\t\t}else{\n\t\t\t\t\t\tfirst = center+1;\n\t\t\t\t\t}\n\t\t\t\t}else{\n\t\t\t\t\tlast = center-1;\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\treturn array.length-1;\n\t\t\t}\n\t\t\tcenter = (first+last)/2;\n\t\t}\n\t\treturn -1;\n\t}\n\t\n}\nclass Treasure {\n\tint x=0;\n\tint y=0;\n\tint xindex = 0;\n\tint yindex = 0;\n\tpublic Treasure(int x,int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n}\nclass ComparatorX implements Comparator<Treasure> {\n\tpublic int compare(Treasure t1,Treasure t2) {\n\t\treturn t1.x-t2.x;\n\t}\n}\nclass ComparatorY implements Comparator<Treasure> {\n\tpublic int compare(Treasure t1,Treasure t2) {\n\t\treturn t1.y-t2.y;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.Point;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tPoint[] t = new Point[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tt[i] = new Point(sc.nextInt(), sc.nextInt());\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint c = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tint x = t[j].x;\n\t\t\t\tint y = t[j].y;\n\t\t\t\tif (x >= x1 && x <= x2 && y >= y1 && y <= y2)\n\t\t\t\t\tc++;\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\t//1700 cording start\n\t//1803 sample matched\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\t//while(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint [] xlist = new int[n];\n\t\t\tint [] ylist = new int[n];\n\t\t\tTreeSet<Integer> xl = new TreeSet<Integer>();\n\t\t\tTreeSet<Integer> yl = new TreeSet<Integer>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\txl.add(xlist[i]);\n\t\t\t\tyl.add(ylist[i]);\n\t\t\t}\n\t\t\t\n\t\t\tint [] xsorted = new int[xl.size()];\n\t\t\tint [] ysorted = new int[yl.size()];\n\t\t\tint ind = 0;\n\t\t\tfor(int v: xl){\n\t\t\t\txsorted[ind++] = v;\n\t\t\t}\n\t\t\tind = 0;\n\t\t\tfor(int v: yl){\n\t\t\t\tysorted[ind++] = v;\n\t\t\t}\n\t\t\t\n\t\t\tint [][] acc = new int[yl.size() + 1][xl.size()+1];\n\t\t\tfor(int k = 0 ; k < n; k++){\n\t\t\t\tint x = Arrays.binarySearch(xsorted, xlist[k]) + 1;\n\t\t\t\tint y = Arrays.binarySearch(ysorted, ylist[k]) + 1;\n\t\t\t\tfor(int i = y; i < acc.length; i++){\n\t\t\t\t\tfor(int j = x; j < acc[i].length; j++){\n\t\t\t\t\t\tacc[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(Arrays.toString(ysorted));\n//\t\t\tSystem.out.println(Arrays.toString(xsorted));\n//\t\t\tSystem.out.println(yl.size() + \" \" + xl.size());\n//\t\t\tfor(int i = 0 ; i < acc.length; i++){\n//\t\t\t\tSystem.out.print(\"i = \" + i);\n//\t\t\t\tfor(int j = 0; j < acc[i].length; j++){\n//\t\t\t\t\tSystem.out.print(acc[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\t//query\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tint minx = sc.nextInt();\n\t\t\t\tint miny = sc.nextInt();\n\t\t\t\tint maxx = sc.nextInt();\n\t\t\t\tint maxy = sc.nextInt();\n\t\t\t\t\n\t\t\t\tint x1,y1,x2,y2;\n\t\t\t\tx1 = bs(xsorted, minx);\n\t\t\t\ty1 = bs(ysorted, miny);\n\t\t\t\tx2 = bs(xsorted, maxx);\n\t\t\t\tif(Arrays.binarySearch(xsorted, maxx) >= 0) x2++;\n\t\t\t\ty2 = bs(ysorted, maxy);\n\t\t\t\tif(Arrays.binarySearch(ysorted, maxy) >= 0) y2++;\n\t\t\t\t\n\t\t\t\t//System.out.println(\"x1 = \" + x1 + \"y1 = \" + y1 + \"x2 = \" + x2 +\" y2 = \" + y2);\n\t\t\t\t\n\t\t\t\tint res = acc[y2][x2] + acc[y1][x1] - acc[y2][x1] - acc[y1][x2];\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t//}\n\t\t\n\t}\n\n\n\tprivate int bs(int[] a, int x) {\n\t\tint mid, left = 0, right = a.length -1;\n\t\twhile(left <= right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(a[mid] == x){\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\tif(a[mid] < x){\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Treasure Hunt\n * Java 1.6 later\n */\npublic class Main {\n\n\tstatic final int MIN = -1_000_000_001;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tline = br.readLine();\n\n\t\tint n, m;\n\t\tn = parseInt(line.substring(0, line.indexOf(' ')));\n\t\tm = parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\tint[][] xy = new int[n + 1][2];\n\n\t\tNavigableMap<Integer, Integer> x = new TreeMap<>();\n\t\tNavigableMap<Integer, Integer> y = new TreeMap<>();\n\n\t\t//xy\n\t\txy[0][0] = MIN;\n\t\txy[0][1] = MIN;\n\t\tx.put(MIN, 0);\n\t\ty.put(MIN, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tline = br.readLine();\n\t\t\txy[i][0] = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\txy[i][1] = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tx.put(xy[i][0], 0);\n\t\t\ty.put(xy[i][1], 0);\n\t\t}\n\n\t\t//x\n\t\tint _i;\n\t\t_i = 0;\n\t\tfor (Map.Entry<Integer, Integer> e : x.entrySet()) {\n\t\t\te.setValue(_i);\n\t\t\t_i++;\n\t\t}\n\n\t\t//y\n\t\t_i = 0;\n\t\tfor (Map.Entry<Integer, Integer> e : y.entrySet()) {\n\t\t\te.setValue(_i);\n\t\t\t_i++;\n\t\t}\n\n\t\t//sum\n\t\tint[][] map = new int[x.size()][y.size()];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tmap[x.get(xy[i][0])][y.get(xy[i][1])]++;\n\t\t}\n\t\tfor (int i = 1; i < map.length; i++) {\n\t\t\tfor (int j = 1; j < map[0].length; j++) {\n\t\t\t\tmap[i][j] += (map[i][j - 1] + map[i - 1][j] - map[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\t//answer queries\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\twords = br.readLine().split(\" \");\n\t\t\tint x1, y1, x2, y2;\n\t\t\tx1 = x.lowerEntry(parseInt(words[0])).getValue();\n\t\t\ty1 = y.lowerEntry(parseInt(words[1])).getValue();\n\t\t\tx2 = x.floorEntry(parseInt(words[2])).getValue();\n\t\t\ty2 = y.floorEntry(parseInt(words[3])).getValue();\n\t\t\tint c = map[x2][y2] - map[x1][y2] - map[x2][y1] + map[x1][y1];\n\t\t\tsb.append(c).append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\n\t} //end main\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.binarySearch;\n\nimport java.io.IOException;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\t\tint[] xs = new int[n];\n\t\tint[] ys = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txs[i] = nextInt();\n\t\t\tys[i] = nextInt();\n\t\t}\n\n\t\tTreeSet<Integer> xTreeSet = new TreeSet<Integer>();\n\t\tTreeSet<Integer> yTreeSet = new TreeSet<Integer>();\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\txTreeSet.add(xs[i]);\n\t\t\tyTreeSet.add(ys[i]);\n\t\t}\n\t\txTreeSet.add((int) Integer.MAX_VALUE);\n\t\txTreeSet.add((int) Integer.MIN_VALUE);\n\t\tyTreeSet.add((int) Integer.MAX_VALUE);\n\t\tyTreeSet.add((int) Integer.MIN_VALUE);\n\n\t\tInteger[] xIntegers = xTreeSet.toArray(new Integer[0]);\n\t\tInteger[] yIntegers = yTreeSet.toArray(new Integer[0]);\n\n\t\tint w = xIntegers.length;\n\t\tint h = yIntegers.length;\n\n\t\tint[][] location = new int[h + 1][w + 1];\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint x = binarySearch(xIntegers, xs[i]);\n\t\t\tint y = binarySearch(yIntegers, ys[i]);\n\t\t\tlocation[y + 1][x + 1]++;\n\t\t}\n\n\t\tfor (int i = 0; i < h; i++) {\n\t\t\tfor (int j = 0; j < w; j++) {\n\t\t\t\tlocation[i + 1][j + 1] += location[i + 1][j] + location[i][j + 1] - location[i][j];\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\t// TreeSet.ceiling(e)...e以上の1番小さい要素を返す\n\t\t\t// TreeSet.floor(e)...e以下の1番大きい要素を返す\n\t\t\tint x1 = binarySearch(xIntegers, xTreeSet.ceiling(nextInt()));\n\t\t\tint y1 = binarySearch(yIntegers, yTreeSet.ceiling(nextInt()));\n\t\t\tint x2 = binarySearch(xIntegers, xTreeSet.floor(nextInt())) + 1;\n\t\t\tint y2 = binarySearch(yIntegers, yTreeSet.floor(nextInt())) + 1;\n\t\t\tsb.append(location[y2][x2] - location[y1][x2] - location[y2][x1] + location[y1][x1]);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Main {\n\t//1700 cording start\n\t//1803 sample matched\n\tboolean isfind;\n\t\n\tprivate void doit(){\n\t\tInStream sc = new InStream();\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint [] xlist = new int[n];\n\t\t\tint [] ylist = new int[n];\n\t\t\tArrayList<Integer> xl = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> yl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\txl.add(xlist[i]);\n\t\t\t\tyl.add(ylist[i]);\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(yl);\n\t\t\tCollections.sort(xl);\n\t\t\t\n\t\t\tfor(int i = 1; i < xl.size(); i++){\n\t\t\t\tif(xl.get(i-1) == xl.get(i)){\n\t\t\t\t\txl.remove(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1; i < yl.size(); i++){\n\t\t\t\tif(yl.get(i-1) == yl.get(i)){\n\t\t\t\t\tyl.remove(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [][] acc = new int[yl.size() + 1][xl.size()+1];\n\t\t\tfor(int k = 0 ; k < n; k++){\n\t\t\t\tint x = Collections.binarySearch(xl, xlist[k]) + 1;\n\t\t\t\tint y = Collections.binarySearch(yl, ylist[k]) + 1;\n\t\t\t\tacc[y][x]++;\n\t\t\t}\n\t\t\tfor(int i = 1; i < acc.length; i++){\n\t\t\t\tfor(int j = 1; j < acc[i].length; j++){\n\t\t\t\t\tacc[i][j] += acc[i-1][j] + acc[i][j-1] - acc[i-1][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(yl.size() + \" \" + xl.size());\n//\t\t\tfor(int i = 0 ; i < acc.length; i++){\n//\t\t\t\tSystem.out.print(\"i = \" + i);\n//\t\t\t\tfor(int j = 0; j < acc[i].length; j++){\n//\t\t\t\t\tSystem.out.print(acc[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\t//query\n\t\t\tStringBuilder sb = new StringBuilder();\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tint minx = sc.nextInt();\n\t\t\t\tint miny = sc.nextInt();\n\t\t\t\tint maxx = sc.nextInt();\n\t\t\t\tint maxy = sc.nextInt();\n\t\t\t\t\n\t\t\t\tint x1,y1,x2,y2;\n\t\t\t\tx1 = bs(xl, minx);\n\t\t\t\ty1 = bs(yl, miny);\n\t\t\t\t\n\t\t\t\tisfind = false;\n\t\t\t\tx2 = bs(xl, maxx);\n\t\t\t\tif(isfind) x2++;\n\t\t\t\tisfind = false;\n\t\t\t\ty2 = bs(yl, maxy);\n\t\t\t\tif(isfind) y2++;\n\t\t\t\t\n\t\t\t\t//System.out.println(\"x1 = \" + x1 + \"y1 = \" + y1 + \"x2 = \" + x2 +\" y2 = \" + y2);\n\t\t\t\t\n\t\t\t\tint res = acc[y2][x2] + acc[y1][x1] - acc[y2][x1] - acc[y1][x2];\n\t\t\t\tsb.append(res + \"\\n\");\n\t\t\t}\n\t\t\tSystem.out.print(sb);\n\t\t}\n\t\t\n\t}\n\n\n\tprivate int bs(ArrayList<Integer>a, int x) {\n\t\tint mid, left = 0, right = a.size() -1;\n\t\twhile(left <= right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(a.get(mid) == x){\n\t\t\t\tisfind = true;\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\tif(a.get(mid) < x){\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\t\n\tclass InStream{\n\t\tBufferedReader in;\n\t\tStringTokenizer st;\n\t\tpublic InStream() {\n\t\t\tthis.in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tthis.st = null;\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st==null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken(); \n\t\t}\n\t\t\n\t\tboolean hasNext(){\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\treturn true;\n\t\t\t} catch (Exception e) {return false;}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next()); \n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\tint cnt = 0;\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tcnt++;\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n//\t\t\tcnt++;\n//\t\t\tif(left==null)return num;\n//\t\t\tleft.reportAll(); right.reportAll();\n\t\t\treturn num;\n\t\t}\n\t}\n\tint max = 0;\n\tNode make2DTree(PriorityQueue<P> q, int depth, double lx, double rx, double ly, double ry, Node parent){\n\t\tmax = Math.max(max, depth);\n\t\tcnt++;\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(q.size()==1){\n\t\t\tres.point = q.poll();\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tint mid = (q.size()-1)/2, idx = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tif(idx==mid)res.point = q.peek();\n\t\t\tif(idx++ <= mid)L.add(q.poll());\n\t\t\telse R.add(q.poll());\n\t\t}\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(L, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(R, depth+1, res.point.x, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(L, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(R, depth+1, lx, rx, res.point.y, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tPriorityQueue<P> q = new PriorityQueue<P>(list.size(), xsort);\n\t\tfor(P p:list)q.add(p);\n\t\treturn make2DTree(q, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>(n);\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n//\t\tlong T = System.currentTimeMillis();\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n//\t\tSystem.out.println(System.currentTimeMillis()-T+\" ms.\");\n//\t\tSystem.out.println(\"DEPTH:\"+max+\" CNT:\"+cnt);\n\t\tStringBuilder sb = new StringBuilder();\n\t\twhile(m--!=0){\n\t\t\tcnt = 0;\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\tsb.append(root.search(x1, x2, y1, y2)+\"\\n\");\n//\t\t\tSystem.out.println(root.search(x1, x2, y1, y2)+\" CALL:\"+cnt);\n//\t\t\tint ans = 0;\n//\t\t\tfor(P a:p)if(x1<=a.x&&a.x<=x2&&y1<=a.y&&a.y<=y2)ans++;\n//\t\t\tSystem.out.println(root.search(x1, x2, y1, y2)+\" \"+cnt+\" \"+ans);\n//\t\t\troot.search(x1, x2, y1, y2);\n//\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\tSystem.out.print(sb);\n//\t\tSystem.out.println(root.num);\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\t\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n\t\t\treturn num;\n\t\t}\n\t}\n\tNode make2DTree(List<P> list, int depth, double lx, double rx, double ly, double ry, Node parent){\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(list.size()==1){\n\t\t\tres.point = list.get(0);\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(list.size(), depth%2==0?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(list.size(), depth%2==0?xsort:ysort);\n\t\tint mid = (list.size()-1)/2;\n\t\tres.point = list.get(mid);\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tif(i<=mid)L.add(list.get(i));\n\t\t\telse R.add(list.get(i));\n\t\t}\n\t\tList<P> leftList = new ArrayList<P>(), rightList = new ArrayList<P>();\n\t\twhile(!L.isEmpty())leftList.add(L.poll());\n\t\twhile(!R.isEmpty())rightList.add(R.poll());\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(leftList, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(rightList, depth+1, res.point.x+1, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(leftList, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(rightList, depth+1, lx, rx, res.point.y+1, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tCollections.sort(list, xsort);\n\t\treturn make2DTree(list, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>();\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n\t\twhile(m--!=0){\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\tSystem.out.println(root.search(x1, x2, y1, y2));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.PrintWriter;\nimport java.util.NoSuchElementException;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.TreeMap;\nimport java.util.TreeSet;\nimport java.util.function.BiFunction;\n\npublic class Main{\n\tstatic Scanner scn = new Scanner(System.in);\n\tstatic FastScanner sc = new FastScanner();\n\tstatic PrintWriter ot = new PrintWriter(System.out);\n\tstatic Random rand = new Random();\n\tstatic int mod = 1000000007;\n\tstatic long modmod = (long)mod * mod;\n\tstatic long inf = (long)1e17;\n\tstatic int[] dx = {0,1,0,-1};\n\tstatic int[] dy = {1,0,-1,0};\n\tstatic int[] dx8 = {-1,-1,-1,0,0,1,1,1};\n\tstatic int[] dy8 = {-1,0,1,-1,1,-1,0,1};\n\tstatic char[] dc = {'R','D','L','U'};\n\tstatic BiFunction<Integer,Integer,Integer> fmax = (a,b)-> {return Math.max(a,b);};\n\tstatic BiFunction<Integer,Integer,Integer> fmin = (a,b)-> {return Math.min(a,b);};\n\tstatic BiFunction<Integer,Integer,Integer> fsum = (a,b)-> {return a+b;};\n\tstatic BiFunction<Long,Long,Long> fmaxl = (a,b)-> {return Math.max(a,b);};\n\tstatic BiFunction<Long,Long,Long> fminl = (a,b)-> {return Math.min(a,b);};\n\tstatic BiFunction<Long,Long,Long> fsuml = (a,b)-> {return a+b;};\n\tstatic BiFunction<Integer,Integer,Integer> fadd = fsum;\n\tstatic BiFunction<Integer,Integer,Integer> fupd = (a,b)-> {return b;};\n\tstatic BiFunction<Long,Long,Long> faddl = fsuml;\n\tstatic BiFunction<Long,Long,Long> fupdl = (a,b)-> {return b;};\n\tstatic String sp = \" \";\n\tstatic int N;\n\tstatic int M;\n\tpublic static void main(String[] args) {\n\t\t//AOJ2426 Treasure Hunt\n\t\t//author:Suunn\n\t\t//幾何らしくないと思う　座標圧縮と累積和で丁寧に実装\n\t\t\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint[] x = new int[N];\n\t\tint[] y = new int[N];\n\t\tsc.nextIntses(N,x,y);\n\t\tTreeSet<Integer> xlist = new TreeSet<Integer>();\n\t\tTreeSet<Integer> ylist = new TreeSet<Integer>();\n\t\tfor(int i=0;i<N;i++) {\n\t\t\txlist.add(x[i]);\n\t\t\tylist.add(y[i]);\n\t\t}\n\t\txlist.add(-mod);\n\t\txlist.add(mod);\n\t\tylist.add(-mod);\n\t\tylist.add(mod);\n\t\tTreeMap<Integer,Integer> xmap = new TreeMap<Integer,Integer>();\n\t\tTreeMap<Integer,Integer> ymap = new TreeMap<Integer,Integer>();\n\t\t\n\t\tint xidx = 1;\n\t\tfor(int e:xlist) {\n\t\t\txmap.put(e,xidx);\n\t\t\txidx += 2;\n\t\t}\n\t\tint yidx = 1;\n\t\tfor(int e:ylist) {\n\t\t\tymap.put(e,yidx);\n\t\t\tyidx += 2;\n\t\t}\n\t\tint[][] a = new int[xidx+1][yidx+1];\n\t\tfor(int i=0;i<N;i++) {\n\t\t\tint X = xmap.get(x[i]);\n\t\t\tint Y = ymap.get(y[i]);\n\t\t\ta[X][Y]++;\n\t\t}\n\t\tfor(int i=0;i<=xidx;i++) { \n\t\t\tfor(int j=0;j<=yidx;j++) {\n\t\t\t\tif(i==0&&j==0)continue;\n\t\t\t\telse if(i==0)a[i][j] += a[i][j-1];\n\t\t\t\telse if(j==0)a[i][j] += a[i-1][j];\n\t\t\t\telse a[i][j] += a[i][j-1]+a[i-1][j]-a[i-1][j-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++) {\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tint X1 = xmap.get(xlist.ceiling(x1))-1;\n\t\t\tint Y1 = ymap.get(ylist.ceiling(y1))-1;\n\t\t\tint X2 = xmap.get(xlist.floor(x2));\n\t\t\tint Y2 = ymap.get(ylist.floor(y2));\n\t\t\tot.println(a[X2][Y2]-a[X1][Y2]-a[X2][Y1]+a[X1][Y1]);\n\t\t}\n\t\tot.flush();\n\t\n\t\t\n\t}\n\t\n\t\n\t\n\n\n}\n\n\nclass FastScanner {\n    private final java.io.InputStream in = System.in;\n    private final byte[] b = new byte[1024];\n    private int p = 0;\n    private int bl = 0;\n    private boolean hNB() {\n        if (p<bl) {\n            return true;\n        }else{\n            p = 0;\n            try {\n                bl = in.read(b);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (bl<=0) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n\tprivate int rB() { if (hNB()) return b[p++]; else return -1;}\n    private static boolean iPC(int c) { return 33 <= c && c <= 126;}\n    private void sU() { while(hNB() && !iPC(b[p])) p++;}\n    public boolean hN() { sU(); return hNB();}\n    public String next() {\n        if (!hN()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = rB();\n        while(iPC(b)) {\n            sb.appendCodePoint(b);\n            b = rB();\n        }\n        return sb.toString();\n    }\n    public char nextChar() {\n    \treturn next().charAt(0);\n    }\n    public long nextLong() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b=='-') {\n            m=true;\n            b=rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1||!iPC(b)){\n                return (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int nextInt() {\n        if (!hN()) throw new NoSuchElementException();\n        long n = 0;\n        boolean m = false;\n        int b = rB();\n        if (b == '-') {\n            m = true;\n            b = rB();\n        }\n        if (b<'0'||'9'<b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0'<=b&&b<='9') {\n                n *= 10;\n                n += b-'0';\n            }else if(b==-1||!iPC(b)){\n                return (int) (m?-n:n);\n            }else{\n                throw new NumberFormatException();\n            }\n            b = rB();\n        }\n    }\n    public int[] nextInts(int n) {\n    \tint[] a = new int[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public int[] nextInts(int n,int s) {\n    \tint[] a = new int[n+s];\n    \tfor(int i=s;i<n+s;i++) {\n    \t\ta[i] = nextInt();\n    \t}\n    \treturn a;\n    }\n    public long[] nextLongs(int n, int s) {\n    \tlong[] a = new long[n+s];\n    \tfor(int i=s;i<n+s;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n\t}\n    public long[] nextLongs(int n) {\n    \tlong[] a = new long[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = nextLong();\n    \t}\n    \treturn a;\n    }\n    public int[][] nextIntses(int n,int m){\n    \tint[][] a = new int[n][m];\n    \tfor(int i=0;i<n;i++) {\n    \t\tfor(int j=0;j<m;j++) {\n    \t\t\ta[i][j] = nextInt();\n    \t\t}\n    \t}\n    \treturn a;\n    }\n\n    public String[] nexts(int n) {\n    \tString[] a = new String[n];\n    \tfor(int i=0;i<n;i++) {\n    \t\ta[i] = next();\n    \t}\n    \treturn a;\n    }\n    void nextIntses(int n,int[] ...m) {\n    \tint l = m[0].length;\n    \tfor(int i=0;i<l;i++) {\n    \t\tfor(int j=0;j<m.length;j++) {\n    \t\t\tm[j][i] = nextInt();\n    \t\t}\n    \t}\n    }\n    void nextLongses(int n,long[] ...m) {\n    \tint l = m[0].length;\n    \tfor(int i=0;i<l;i++) {\n    \t\tfor(int j=0;j<m.length;j++) {\n    \t\t\tm[j][i] = nextLong();\n    \t\t}\n    \t}\n    }\n\n}\n\n\n\n\n\n\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Treasure Hunt\n */\npublic class Main {\n\n\tstatic final int MIN = -1_000_000_001;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tline = br.readLine();\n\n\t\tint n, m;\n\t\tn = parseInt(line.substring(0, line.indexOf(' ')));\n\t\tm = parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\tint[][] xy = new int[n + 1][2];\n\t\tSortedMap<Integer, Integer> x = new TreeMap<>();\n\t\tSortedMap<Integer, Integer> y = new TreeMap<>();\n\n\t\t//xy\n\t\txy[0][0] = MIN;\n\t\txy[0][1] = MIN;\n\t\tx.put(MIN, 0);\n\t\ty.put(MIN, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tline = br.readLine();\n\t\t\txy[i][0] = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\txy[i][1] = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tx.put(xy[i][0], 0);\n\t\t\ty.put(xy[i][1], 0);\n\t\t}\n\n\t\t//x\n\t\tint _i;\n\t\t_i = 0;\n\t\tfor (Map.Entry e : x.entrySet()) {\n\t\t\te.setValue(_i);\n\t\t\t_i++;\n\t\t}\n\n\t\t//y\n\t\t_i = 0;\n\t\tfor (Map.Entry e : y.entrySet()) {\n\t\t\te.setValue(_i);\n\t\t\t_i++;\n\t\t}\n\n\t\t//sum\n\t\tint[][] map = new int[x.size()][y.size()];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tmap[x.get(xy[i][0])][y.get(xy[i][1])] = 1;\n\t\t}\n\t\tfor (int i = 1; i < map.length; i++) {\n\t\t\tfor (int j = 1; j < map[0].length; j++) {\n\t\t\t\tmap[i][j] += (map[i][j - 1] + map[i - 1][j] - map[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\t//query\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\twords = br.readLine().split(\" \");\n\t\t\tint x1, y1, x2, y2;\n\t\t\tx1 = (int) ((NavigableMap) x).lowerEntry(parseInt(words[0])).getValue();\n\t\t\ty1 = (int) ((NavigableMap) y).lowerEntry(parseInt(words[1])).getValue();\n\t\t\tx2 = (int) ((NavigableMap) x).floorEntry(parseInt(words[2])).getValue();\n\t\t\ty2 = (int) ((NavigableMap) y).floorEntry(parseInt(words[3])).getValue();\n\t\t\tint c = map[x2][y2] - map[x1][y2] - map[x2][y1] + map[x1][y1];\n\t\t\tsb.append(c).append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\n\t} //end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tAOJ2426(){\n\t\t\t//while(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\t//if(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t//}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\t//TreeSet<Integer> xs=new TreeSet<Integer>(),ys=new TreeSet<Integer>();\n\t\t\tHashSet<Integer> xs=new HashSet<Integer>(), ys=new HashSet<Integer>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tArrays.sort(x2);\n\t\t\tArrays.sort(y2);\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++)\t++sum[Arrays.binarySearch(x2, x1[i])][Arrays.binarySearch(y2, y1[i])];\n\t\t\tfor(int x=1; x<x2.length; x++)\tsum[x][0]+=sum[x-1][0];\n\t\t\tfor(int y=1; y<y2.length; y++)\tsum[0][y]+=sum[0][y-1];\n\t\t\tfor(int x=1; x<x2.length; x++)for(int y=1; y<y2.length; y++)\tsum[x][y]+=sum[x-1][y]+sum[x][y-1]-sum[x-1][y-1];\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=sc.nextInt(),ym1=sc.nextInt(),xm2=sc.nextInt(),ym2=sc.nextInt();\n\t\t\t\tint tmp=Arrays.binarySearch(x2, xm1);\n\t\t\t\tint xidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym1);\n\t\t\t\tint yidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(x2, xm2);\n\t\t\t\tint xidx2=(tmp>=0?tmp:min(x2.length-1, abs(tmp)-2));\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym2);\n\t\t\t\tint yidx2=(tmp>=0?tmp:min(y2.length-1, abs(tmp)-2));\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println(sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\n// Treasure Hunt\n// 2012/09/19\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n, m;\n\tint[] xs, ys;\n\n\tvoid run(){\n\t\tn=sc.nextInt();\n\t\tm=sc.nextInt();\n\t\txs=new int[n];\n\t\tys=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\txs[i]=sc.nextInt();\n\t\t\tys[i]=sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tvoid solve(){\n\t\tTreeSet<Integer> xSet=new TreeSet<Integer>();\n\t\tTreeSet<Integer> ySet=new TreeSet<Integer>();\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\txSet.add(xs[i]);\n\t\t\tySet.add(ys[i]);\n\t\t}\n\t\txSet.add((int)1e9);\n\t\tySet.add((int)1e9);\n\t\txSet.add((int)-1e9);\n\t\tySet.add((int)-1e9);\n\n\t\tInteger[] xss=xSet.toArray(new Integer[0]);\n\t\tInteger[] yss=ySet.toArray(new Integer[0]);\n\n\t\tint w=xss.length;\n\t\tint h=yss.length;\n\n\t\tint[][] a=new int[h+1][w+1];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tint x=binarySearch(xss, xs[i]);\n\t\t\tint y=binarySearch(yss, ys[i]);\n\t\t\ta[y+1][x+1]++;\n\t\t}\n\n\t\tfor(int j=0; j<h; j++){\n\t\t\tfor(int i=0; i<w; i++){\n\t\t\t\ta[j+1][i+1]+=a[j+1][i]+a[j][i+1]-a[j][i];\n\t\t\t}\n\t\t}\n\n\t\tStringBuilder sb=new StringBuilder();\n\t\tfor(int i=0; i<m; i++){\n\t\t\tint x1=binarySearch(xss, xSet.ceiling(sc.nextInt()));\n\t\t\tint x2=binarySearch(xss, xSet.floor(sc.nextInt()))+1;\n\t\t\tint y1=binarySearch(yss, ySet.ceiling(sc.nextInt()));\n\t\t\tint y2=binarySearch(yss, ySet.floor(sc.nextInt()))+1;\n\t\t\tsb.append(a[y2][x2]-a[y1][x2]-a[y2][x1]+a[y1][x1]);\n\t\t\tsb.append('\\n');\n\t\t}\n\t\tprint(sb.toString());\n\t}\n\n\tclass Scanner{\n\t\tBufferedReader br;\n\t\tStringTokenizer st;\n\n\t\tScanner(InputStream in){\n\t\t\tbr=new BufferedReader(new InputStreamReader(in));\n\t\t\teat(\"\");\n\t\t}\n\n\t\tvoid eat(String s){\n\t\t\tst=new StringTokenizer(s);\n\t\t}\n\n\t\tString nextLine(){\n\t\t\ttry{\n\t\t\t\treturn br.readLine();\n\t\t\t}catch(IOException e){\n\t\t\t\tthrow new IOError(e);\n\t\t\t}\n\t\t}\n\n\t\tboolean hasNext(){\n\t\t\twhile(!st.hasMoreTokens()){\n\t\t\t\tString s=nextLine();\n\t\t\t\tif(s==null)\n\t\t\t\t\treturn false;\n\t\t\t\teat(s);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tString next(){\n\t\t\thasNext();\n\t\t\treturn st.nextToken();\n\t\t}\n\n\t\tint nextInt(){\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\tint cnt = 0;\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tcnt++;\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n//\t\t\tcnt++;\n//\t\t\tif(left==null)return num;\n//\t\t\tleft.reportAll(); right.reportAll();\n\t\t\treturn num;\n\t\t}\n\t}\n\tint max = 0;\n\tNode make2DTree(PriorityQueue<P> q, int depth, double lx, double rx, double ly, double ry, Node parent){\n//\t\tmax = Math.max(max, depth);\n//\t\tcnt++;\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(q.size()==1){\n\t\t\tres.point = q.poll();\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tint mid = (q.size()-1)/2, idx = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tif(idx==mid)res.point = q.peek();\n\t\t\tif(idx++ <= mid)L.add(q.poll());\n\t\t\telse R.add(q.poll());\n\t\t}\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(L, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(R, depth+1, res.point.x+1, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(L, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(R, depth+1, lx, rx, res.point.y+1, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tPriorityQueue<P> q = new PriorityQueue<P>(list.size(), xsort);\n\t\tfor(P p:list)q.add(p);\n\t\treturn make2DTree(q, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n//\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tScanner sc = new Scanner();\n//\t\tint L = 50000;\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>(n);\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n//\t\tfor(int i=0;i<n;i++)p.add(new P(rand.nextInt(L), rand.nextInt(L)));\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n//\t\tSystem.out.println(System.currentTimeMillis()-T+\" ms. tree make\");\n\t\tStringBuffer sb = new StringBuffer();\n\t\twhile(m--!=0){\n\t\t\tcnt = 0;\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n//\t\t\tint x1 = rand.nextInt(L/2), y1 = rand.nextInt(L/2), x2 = rand.nextInt(L/2)+L/2, y2 = rand.nextInt(L/2)+L/2;\n//\t\t\tSystem.out.println(root.search(x1, x2, y1, y2)+\" CALL:\"+cnt);\n\t\t\tsb.append(root.search(x1, x2, y1, y2)+\"\\n\");\n//\t\t\tint ans = 0;\n//\t\t\tfor(P a:p)if(x1<=a.x&&a.x<=x2&&y1<=a.y&&a.y<=y2)ans++;\n//\t\t\tSystem.out.println(root.search(x1, x2, y1, y2)+\" \"+cnt+\" \"+ans);\n//\t\t\troot.search(x1, x2, y1, y2);\n//\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\tSystem.out.print(sb);\n//\t\tSystem.out.println(System.currentTimeMillis()-T+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tAOJ2426(){\n\t\t\twhile(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\tif(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\tTreeSet<Integer> xs=new TreeSet<Integer>(),ys=new TreeSet<Integer>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\t//System.out.println(ys.size()+\"\\n\"+ys);\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tint xidx=0,yidx=0;\n\t\t\t\tfor(; xidx<xs.size(); xidx++)if(x1[i]==x2[xidx])\tbreak;\n\t\t\t\tfor(; yidx<ys.size(); yidx++)if(y1[i]==y2[yidx])\tbreak;\n\t\t\t\tfor(int x=xidx; x<xs.size(); x++)for(int y=yidx; y<ys.size(); y++)sum[x][y]++;\n\t\t\t}\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=sc.nextInt(),ym1=sc.nextInt(),xm2=sc.nextInt(),ym2=sc.nextInt();\n\t\t\t\tint tmp=Arrays.binarySearch(x2, xm1);\n\t\t\t\tint xidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym1);\n\t\t\t\tint yidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(x2, xm2);\n\t\t\t\tint xidx2=(tmp>=0?tmp:min(x2.length-1, abs(tmp)-2));\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym2);\n\t\t\t\tint yidx2=(tmp>=0?tmp:min(y2.length-1, abs(tmp)-2));\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println(sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n/**\n * AOOJ id=2426\n * Treasure Hunt\n * @author scache\n *\n */\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tMain p = new Main();\n\t}\n\n\tint n;\n\tint m;\n\tint[] x;\n\tint[] y;\n\tScanner sc;\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\tm = sc.nextInt();\n\t\t\n\t\tx = new int[n];\n\t\ty = new int[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tx[i] = sc.nextInt();\n\t\t\ty[i] = sc.nextInt();\n\t\t}\n\t\tsolve();\n\t}\n\n\tpublic void solve() {\n\t\tint[] xc = new int[x.length+1];\n\t\tint[] yc = new int[y.length+1];\n\t\txc[0] = Integer.MIN_VALUE;\n\t\tyc[0] = Integer.MIN_VALUE;\n\t\tSystem.arraycopy(x, 0, xc, 1, x.length);\n\t\tSystem.arraycopy(y, 0, yc, 1, y.length);\n\t\txc = compress(xc);\n\t\tyc = compress(yc);\n\t\tfor(int i=0;i<x.length;i++){\n\t\t\tx[i] = Arrays.binarySearch(xc, x[i]);\n\t\t\ty[i] = Arrays.binarySearch(yc, y[i]);\n\t\t}\n\t\t\n\t\tint[][] count = new int[yc.length][xc.length];\n\t\tfor(int i=0;i<x.length;i++)\n\t\t\tcount[y[i]][x[i]]++;\n\t\t\n\t\tfor(int i=1;i<yc.length;i++)\n\t\t\tfor(int j=1;j<xc.length;j++)\n\t\t\t\tcount[i][j] += count[i][j-1];\n\t\t\n\t\tfor(int i=1;i<xc.length;i++)\n\t\t\tfor(int j=1;j<yc.length;j++)\n\t\t\t\tcount[j][i] += count[j-1][i];\n\t\t\n//\t\tfor(int i=0;i<count.length;i++)\n//\t\t\tSystem.out.println(Arrays.toString(count[i]));\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint[] c =new int[4];\n\t\t\tfor(int j=0;j<4;j++){\n\t\t\t\tc[j] = Arrays.binarySearch(j%2==0 ? xc : yc, sc.nextInt());\n\t\t\t\tc[j] = c[j]>=0 ? c[j] : (c[j]+1)*(-1) - (j<2 ? 0 : 1);\n\t\t\t}\n\t\t\tc[0] = Math.max(0, c[0]-1);\n\t\t\tc[1] = Math.max(0, c[1]-1);\n//\t\t\tSystem.out.println(Arrays.toString(c));\n\t\t\tSystem.out.println(count[c[3]][c[2]] + count[c[1]][c[0]]\n\t\t\t\t\t-count[c[1]][c[2]] - count[c[3]][c[0]]);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tprivate int[] compress(int[] a){\n\t\tSet<Integer> set = new TreeSet<Integer>();\n\t\tfor(int i=0;i<a.length;i++){\n\t\t\tset.add(a[i]);\n\t\t}\n\t\tIterator<Integer> iter = set.iterator();\n\t\tint[] ia = new int[set.size()];\n\t\tfor(int i=0;i<ia.length;i++)\n\t\t\tia[i] = iter.next();\n\t\t\n\t\treturn ia;\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int m = sc.nextInt();\n\t\t\n\t\t\n\t\tint x_base[] = new int[n];\n\t\tint y_base[] = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_base[i] = sc.nextInt();\n\t\t\ty_base[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tTreeSet<Integer> x_set = new TreeSet<Integer>();\n\t\tTreeSet<Integer> y_set = new TreeSet<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_set.add(x_base[i]);\n\t\t\ty_set.add(y_base[i]);\n\t\t}\n\t\t\n\t\tint[] x_array = new int[x_set.size()];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tx_array[i] = x_set.pollFirst();\n\t\t}\n\t\t\n\t\tint[] y_array = new int[y_set.size()];\n\t\tfor(int i = 0; i < y_array.length; i++){\n\t\t\ty_array[i] = y_set.pollFirst();\n\t\t}\n\t\t\n\t\tint col[][] = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcol[Arrays.binarySearch(x_array,x_base[i])][Arrays.binarySearch(y_array,y_base[i])]++;\n\t\t}\n\t\t\n\t\tint[][] pre = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\t\t\n\t\t\t\tif(i != 0 && j != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]  + col[i][j];\n\t\t\t\t}else if(i != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + col[i][j];\n\t\t\t\t}else if(j != 0){\n\t\t\t\t\tpre[i][j] = pre[i][j-1] + col[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tpre[i][j] = col[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* ok */\n\t\t\n//\t\tfor(int i = 0; i < x_array.length; i++){\n//\t\t\tfor(int j = 0; j < y_array.length; j++){\n//\t\t\t\tSystem.out.print(pre[i][j] + \" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tint x1_b = Arrays.binarySearch(x_array, x1);\n\t\t\tint y1_b = Arrays.binarySearch(y_array, y1);\n\t\t\tint x2_b = Arrays.binarySearch(x_array, x2);\n\t\t\tint y2_b = Arrays.binarySearch(y_array, y2);\n\t\t\t\n//\t\t\tif(x1_b < 0){\n//\t\t\t\tSystem.out.println(\"x1- \" + x1_b);\n//\t\t\t}\n//\t\t\tif(y1_b < 0){\n//\t\t\t\tSystem.out.println(\"y1- \" + y1_b);\n//\t\t\t}\n\t\t\t\n\t\t\tx1_b = x1_b < 0 ? -(x1_b + 1) : x1_b;\n\t\t\ty1_b = y1_b < 0 ? -(y1_b + 1) : y1_b;\n\n\t\t\tx2_b = x2_b < 0 ? -(x2_b + 1) - 1 : x2_b;\n\t\t\ty2_b = y2_b < 0 ? -(y2_b + 1) - 1 : y2_b;\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\t\n//\t\t\tx2_b = x2_b >= x_array.length ? x_array.length-1 : x2_b;\n//\t\t\ty2_b = y2_b >= y_array.length ? y_array.length-1 : y2_b;\n\t\t\t\n//\t\t\tSystem.out.println(Arrays.toString(x_array));\n//\t\t\tSystem.out.println(x_array.length + \",\" + x1_b);\n//\t\t\tSystem.out.println(Arrays.toString(y_array));\n//\t\t\tSystem.out.println(y_array.length + \",\" + y1_b);\n//\t\t\tSystem.out.println(Arrays.toString(x_array));\n//\t\t\tSystem.out.println(x_array.length + \",\" + x2_b);\n//\t\t\tSystem.out.println(Arrays.toString(y_array));\n//\t\t\tSystem.out.println(y_array.length + \",\" + y2_b);\n\t\t\t\n\t\t\tif(x1_b > x2_b || y1_b > y2_b){\n\t\t\t\tsum = 0;\n\t\t\t}else if(x1_b != 0 && y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b-1] - pre[x2_b-1][y1_b-1] + pre[x1_b-1][y1_b-1];\n\t\t\t}else if(x1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b];\n\t\t\t}else if(y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x2_b][y1_b-1];\n\t\t\t}else{\n\t\t\t\tsum = pre[x2_b][y2_b];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\tint cnt = 0;\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tcnt++;\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n//\t\t\tcnt++;\n//\t\t\tif(left==null)return num;\n//\t\t\tleft.reportAll(); right.reportAll();\n\t\t\treturn num;\n\t\t}\n\t}\n\tint max = 0;\n\tNode make2DTree(PriorityQueue<P> q, int depth, double lx, double rx, double ly, double ry, Node parent){\n\t\tmax = Math.max(max, depth);\n\t\tcnt++;\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(q.size()==1){\n\t\t\tres.point = q.poll();\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tint mid = (q.size()-1)/2, idx = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tif(idx==mid)res.point = q.peek();\n\t\t\tif(idx++ <= mid)L.add(q.poll());\n\t\t\telse R.add(q.poll());\n\t\t}\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(L, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(R, depth+1, res.point.x+1, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(L, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(R, depth+1, lx, rx, res.point.y+1, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tPriorityQueue<P> q = new PriorityQueue<P>(list.size(), xsort);\n\t\tfor(P p:list)q.add(p);\n\t\treturn make2DTree(q, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n//\t\tRandom rand = new Random(System.currentTimeMillis());\n\t\tScanner sc = new Scanner();\n//\t\tint L = 50000;\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>(n);\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n//\t\tfor(int i=0;i<n;i++)p.add(new P(rand.nextInt(L), rand.nextInt(L)));\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n//\t\tSystem.out.println(System.currentTimeMillis()-T+\" ms. tree make\");\n\t\tStringBuffer sb = new StringBuffer();\n\t\twhile(m--!=0){\n\t\t\tcnt = 0;\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n//\t\t\tint x1 = rand.nextInt(L/2), y1 = rand.nextInt(L/2), x2 = rand.nextInt(L/2)+L/2, y2 = rand.nextInt(L/2)+L/2;\n//\t\t\tSystem.out.println(root.search(x1, x2, y1, y2)+\" CALL:\"+cnt);\n\t\t\tsb.append(root.search(x1, x2, y1, y2)+\"\\n\");\n//\t\t\tint ans = 0;\n//\t\t\tfor(P a:p)if(x1<=a.x&&a.x<=x2&&y1<=a.y&&a.y<=y2)ans++;\n//\t\t\tSystem.out.println(root.search(x1, x2, y1, y2)+\" \"+cnt+\" \"+ans);\n//\t\t\troot.search(x1, x2, y1, y2);\n//\t\t\tSystem.out.println(cnt);\n\t\t}\n\t\tSystem.out.println(sb);\n//\t\tSystem.out.println(System.currentTimeMillis()-T+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\tpublic void run() {\n\t\tint n = sc.nextInt();\n\t\tint m = sc.nextInt();\n\t\tcalc(n, m);\n\t}\n\tpublic void calc(int n, int m){\n\t\tArrayList<int[]> takara = new ArrayList<int[]>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tint x = sc.nextInt();\n\t\t\tint y = sc.nextInt();\n\t\t\ttakara.add(new int[]{x,y});\n\t\t}\n\t\ttakara = sort(takara);\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint ans = 0;\n\t\t\tint x1 = sc.nextInt();\n\t\t\tint y1 = sc.nextInt();\n\t\t\tint x2 = sc.nextInt();\n\t\t\tint y2 = sc.nextInt();\n\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\tint[] now = takara.get(k);\n\t\t\t\tif(now[0] < x1){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\telse if(x1 <= now[0] && now[0] <= x2){\n\t\t\t\t\tif(y1 <= now[1] && now[1] <= y2) ans++;\n\t\t\t\t}\n\t\t\t\telse if(x2 < now[0]){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\t\n\tpublic ArrayList<int[]> sort(ArrayList<int[]> list){\n\t\tif(list.size() == 1){\n\t\t\treturn list;\n\t\t}\n\t\telse{\n\t\t\tint m = list.size() / 2;\n\t\t\tint n = list.size() - m;\n\t\t\tArrayList<int[]> a1 = new ArrayList<int[]>();\n\t\t\tArrayList<int[]> a2 = new ArrayList<int[]>();\n\t\t\tfor(int i = 0; i < m; i++) a1.add(list.get(i));\n\t\t\tfor(int i = 0; i < n; i++) a2.add(list.get(m+i));\n\t\t\ta1 = sort(a1);\n\t\t\ta2 = sort(a2);\n\t\t\treturn merge(a1, a2);\n\t\t}\n\t}\n\tpublic ArrayList<int[]> merge(ArrayList<int[]> a1, ArrayList<int[]> a2){\n\t\tint i = 0;\n\t\tint j = 0;\n\t\tArrayList<int[]> list = new ArrayList<int[]>();\n\t\twhile(i < a1.size() || j < a2.size()){\n\t\t\tif(j >= a2.size() || (i < a1.size() && a1.get(i)[0] < a2.get(j)[0])){\n\t\t\t\tlist.add(a1.get(i));\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tlist.add(a2.get(j));\n\t\t\t\tj++;\n\t\t\t}\n\t\t}\n\t\treturn list;\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.LinkedList;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\t\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int m = sc.nextInt();\n\t\t\n\t\t\n\t\tlong[] xs = new long[n];\n\t\tlong[] ys = new long[n];\n\t\t\n\t\tTreeSet<Long> x_set = new TreeSet<Long>();\n\t\tTreeSet<Long> y_set = new TreeSet<Long>();\n\t\t\n\t\tfor(int i = 0; i < n ; i++){\n\t\t\txs[i] = sc.nextLong();\n\t\t\tys[i] = sc.nextLong();\n\t\t\tx_set.add(xs[i]);\n\t\t\ty_set.add(ys[i]);\n\t\t}\n\t\t\n\t\tx_set.add(Long.MIN_VALUE); y_set.add(Long.MIN_VALUE);\n\t\tx_set.add(Long.MIN_VALUE + 1); y_set.add(Long.MIN_VALUE + 1);\n\t\tx_set.add(Long.MAX_VALUE - 1); y_set.add(Long.MAX_VALUE - 1);\n\t\tx_set.add(Long.MAX_VALUE); y_set.add(Long.MAX_VALUE);\n\t\tArrayList<Long> x_list = new ArrayList<Long>(x_set);\n\t\tArrayList<Long> y_list = new ArrayList<Long>(y_set);\n\t\t\n\t\t\n\t\tfinal int y_size = y_list.size();\n\t\tfinal int x_size = x_list.size();\n\t\tlong[][] map = new long[y_size][x_size];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfinal int x_index = Collections.binarySearch(x_list, xs[i]);\n\t\t\tfinal int y_index = Collections.binarySearch(y_list, ys[i]);\n\t\t\t\n\t\t\tmap[y_index][x_index]++;\n\t\t}\n\t\t\n\t\t/*\n\t\tSystem.out.println();\n\t\tfor(int i = 0; i < y_size; i++){\n\t\t\tfor(int j = 0; j < x_size; j++){\n\t\t\t\tSystem.out.print(map[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t*/\n\t\t\n\t\tfor(int i = 0; i < y_size; i++){\n\t\t\tfor(int j = 0; j < x_size; j++){\n\t\t\t\tif(i != 0){\n\t\t\t\t\tmap[i][j] += map[i - 1][j];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(j != 0){\n\t\t\t\t\tmap[i][j] += map[i][j - 1];\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(i != 0 && j != 0){\n\t\t\t\t\tmap[i][j] -= map[i-1][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//     0   1    2\n\t\t//  -1  -2   -3\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfinal long lx = sc.nextLong();\n\t\t\tfinal long ly = sc.nextLong();\n\t\t\tfinal long hx = sc.nextLong();\n\t\t\tfinal long hy = sc.nextLong();\n\t\t\t\n\t\t\tint lx_index = Collections.binarySearch(x_list, lx);\n\t\t\tif(lx_index < 0){\n\t\t\t\tlx_index = -(lx_index + 1);\n\t\t\t}\n\t\t\tlx_index--;\n\t\t\t\n\t\t\tint hx_index = Collections.binarySearch(x_list, hx);\n\t\t\tif(hx_index < 0){\n\t\t\t\thx_index = -(hx_index + 2);\n\t\t\t}\n\t\t\t\n\t\t\tint ly_index = Collections.binarySearch(y_list, ly);\n\t\t\tif(ly_index < 0){\n\t\t\t\tly_index = -(ly_index + 1);\n\t\t\t}\n\t\t\tly_index--;\n\t\t\t\n\t\t\tint hy_index = Collections.binarySearch(y_list, hy);\n\t\t\tif(hy_index < 0){\n\t\t\t\thy_index = -(hy_index + 2);\n\t\t\t}\n\t\t\t\n\t\t\t//System.out.println(x_list);\n\t\t\t//System.out.println(lx_index + \",\" + ly_index + \" <=>\" + hx_index + \", \" + hy_index);\n\t\t\t\n\t\t\tfinal long hh = map[hy_index][hx_index];\n\t\t\tfinal long hl = map[hy_index][lx_index];\n\t\t\tfinal long lh = map[ly_index][hx_index];\n\t\t\tfinal long ll = map[ly_index][lx_index];\n\t\t\t\n\t\t\t\n\t\t\tfinal long result = hh - hl - lh + ll;\n\t\t\t\n\t\t\tSystem.out.println(result);\n\t\t}\n\t\t\n\t\t\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\tstatic int N, M;\n\tstatic Integer[] TX, TY;\n\tstatic Integer[][] ZX, ZY;\n\t\t\t\n\tstatic private void solve()\n\t{\n\t\tTreeSet<Integer> tsx = new TreeSet<Integer>();\n\t\tTreeSet<Integer> tsy = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ttsx.add(TX[i]);\n\t\t\ttsy.add(TY[i]);\n\t\t}\n\t\tArrayList<Integer> alx = new ArrayList<Integer>(tsx);\n\t\tArrayList<Integer> aly = new ArrayList<Integer>(tsy);\n\t\tint tsw = tsx.size();\n\t\tint tsh = tsy.size();\n\t\tObject[] alxobj = alx.toArray();\n\t\tObject[] alyobj = aly.toArray();\n\t\t\n\t\tint[][] treasure = new int[tsy.size() + 1][tsx.size() + 1];\n\t\tfor (int y = 0; y < tsh+1; y++) {\n\t\t\tfor (int x = 0; x < tsw+1; x++) {\n\t\t\t\ttreasure[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint x = alx.indexOf(TX[i]);\n\t\t\tint y = aly.indexOf(TY[i]);\n\t\t\ttreasure[y + 1][x + 1]++;\n\t\t}\n\t\t\n\t\tfor (int y = 1; y <= tsh; y++) {\n\t\t\tfor (int x = 1; x <= tsw; x++) {\n\t\t\t\ttreasure[y][x] += treasure[y-1][x] + treasure[y][x-1] - treasure[y-1][x-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tInteger xx1 = tsx.ceiling(ZX[i][0]);\n\t\t\tInteger xx2 = tsx.floor(ZX[i][1]);\n\t\t\tInteger yy1 = tsy.ceiling(ZY[i][0]);\n\t\t\tInteger yy2 = tsy.floor(ZY[i][1]);\n\t\t\t\n\t\t\tif( xx1 == null || xx2 == null || yy1 == null || yy2 == null )\n\t\t\t{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint x1 = Arrays.binarySearch(alxobj, xx1);\n\t\t\tint x2 = Arrays.binarySearch(alxobj, xx2) + 1;\n\t\t\tint y1 = Arrays.binarySearch(alyobj, yy1);\n\t\t\tint y2 = Arrays.binarySearch(alyobj, yy2) + 1;\n\t\t\t\n\t\t\t/*int x1 = alx.indexOf(xx1);\n\t\t\tint x2 = alx.indexOf(xx2) + 1;\n\t\t\tint y1 = aly.indexOf(yy1);\n\t\t\tint y2 = aly.indexOf(yy2) + 1;*/\n\t\t\t\n\t\t\tint ret = treasure[y2][x2] - treasure[y2][x1] - treasure[y1][x2] + treasure[y1][x1];\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\t\n\tstatic public void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tN = sca.nextInt();\n\t\t\tM = sca.nextInt();\n\t\t\t\n\t\t\tTX = new Integer[N];\n\t\t\tTY = new Integer[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tTX[i] = new Integer(sca.nextInt());\n\t\t\t\tTY[i] = new Integer(sca.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tZX = new Integer[M][2];\n\t\t\tZY = new Integer[M][2];\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tZX[i][0] = new Integer(sca.nextInt());\n\t\t\t\tZY[i][0] = new Integer(sca.nextInt());\n\t\t\t\tZX[i][1] = new Integer(sca.nextInt());\n\t\t\t\tZY[i][1] = new Integer(sca.nextInt());\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int m = sc.nextInt();\n\t\t\n\t\t\n\t\tint x_base[] = new int[n];\n\t\tint y_base[] = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_base[i] = sc.nextInt();\n\t\t\ty_base[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tTreeSet<Integer> x_set = new TreeSet<Integer>();\n\t\tTreeSet<Integer> y_set = new TreeSet<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_set.add(x_base[i]);\n\t\t\ty_set.add(y_base[i]);\n\t\t}\n\t\t\n\t\tint[] x_array = new int[x_set.size()];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tx_array[i] = x_set.pollFirst();\n\t\t}\n\t\t\n\t\tint[] y_array = new int[y_set.size()];\n\t\tfor(int i = 0; i < y_array.length; i++){\n\t\t\ty_array[i] = y_set.pollFirst();\n\t\t}\n\t\t\n\t\tint col[][] = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcol[Arrays.binarySearch(x_array,x_base[i])][Arrays.binarySearch(y_array,y_base[i])]++;\n\t\t}\n\t\t\n\t\tint[][] pre = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\t\t\n\t\t\t\tif(i != 0 && j != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]  + col[i][j];\n\t\t\t\t}else if(i != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + col[i][j];\n\t\t\t\t}else if(j != 0){\n\t\t\t\t\tpre[i][j] = pre[i][j-1] + col[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tpre[i][j] = col[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* ok */\n\t\t\n\t\t\n//\t\tfor(int i = 0; i < x_array.length; i++){\n//\t\t\tfor(int j = 0; j < y_array.length; j++){\n//\t\t\t\tSystem.out.print(col[i][j] + \" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n//\t\tfor(int i = 0; i < x_array.length; i++){\n//\t\t\tfor(int j = 0; j < y_array.length; j++){\n//\t\t\t\tSystem.out.print(pre[i][j] + \" \");\n//\t\t\t}\n//\t\t\tSystem.out.println();\n//\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tint x1_b = Arrays.binarySearch(x_array, x1);\n\t\t\tint y1_b = Arrays.binarySearch(y_array, y1);\n\t\t\tint x2_b = Arrays.binarySearch(x_array, x2);\n\t\t\tint y2_b = Arrays.binarySearch(y_array, y2);\n\t\t\t\n//\t\t\tif(x1_b < 0){\n//\t\t\t\tSystem.out.println(\"x1- \" + x1_b);\n//\t\t\t}\n//\t\t\tif(y1_b < 0){\n//\t\t\t\tSystem.out.println(\"y1- \" + y1_b);\n//\t\t\t}\n\t\t\t\n\t\t\tx1_b = x1_b < 0 ? -(x1_b + 1) : x1_b;\n\t\t\ty1_b = y1_b < 0 ? -(y1_b + 1) : y1_b;\n\n\t\t\tx2_b = x2_b < 0 ? -(x2_b + 1) - 1 : x2_b;\n\t\t\ty2_b = y2_b < 0 ? -(y2_b + 1) - 1 : y2_b;\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\t\n//\t\t\tx2_b = x2_b >= x_array.length ? x_array.length-1 : x2_b;\n//\t\t\ty2_b = y2_b >= y_array.length ? y_array.length-1 : y2_b;\n\t\t\t\n//\t\t\tSystem.out.println(Arrays.toString(x_array));\n//\t\t\tSystem.out.println(x_array.length + \",\" + x1_b);\n//\t\t\tSystem.out.println(Arrays.toString(y_array));\n//\t\t\tSystem.out.println(y_array.length + \",\" + y1_b);\n//\t\t\tSystem.out.println(Arrays.toString(x_array));\n//\t\t\tSystem.out.println(x_array.length + \",\" + x2_b);\n//\t\t\tSystem.out.println(Arrays.toString(y_array));\n//\t\t\tSystem.out.println(y_array.length + \",\" + y2_b);\n\t\t\t\n\t\t\tif(x1_b > x2_b || y1_b > y2_b){\n\t\t\t\tsum = 0;\n\t\t\t}else if(x1_b != 0 && y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b] - pre[x2_b][y1_b-1] + pre[x1_b-1][y1_b-1];\n\t\t\t}else if(x1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b];\n\t\t\t}else if(y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x2_b][y1_b-1];\n\t\t\t}else{\n\t\t\t\tsum = pre[x2_b][y2_b];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\tstatic int N, M;\n\tstatic int[] TX, TY;\n\tstatic int[][] ZX, ZY;\n\t\t\t\n\tstatic private void solve()\n\t{\n\t\tTreeSet<Integer> tsx = new TreeSet<Integer>();\n\t\tTreeSet<Integer> tsy = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ttsx.add(new Integer(TX[i]));\n\t\t\ttsy.add(new Integer(TY[i]));\n\t\t}\n\t\tArrayList<Integer> alx = new ArrayList<Integer>(tsx);\n\t\tArrayList<Integer> aly = new ArrayList<Integer>(tsy);\n\t\tint tsw = tsx.size();\n\t\tint tsh = tsy.size();\n\t\t\n\t\tint[][] treasure = new int[tsy.size() + 1][tsx.size() + 1];\n\t\tfor (int y = 0; y < tsh+1; y++) {\n\t\t\tfor (int x = 0; x < tsw+1; x++) {\n\t\t\t\ttreasure[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint x = alx.indexOf(new Integer(TX[i]));\n\t\t\tint y = aly.indexOf(new Integer(TY[i]));\n\t\t\ttreasure[y + 1][x + 1]++;\n\t\t}\n\t\t\n\t\tfor (int y = 1; y <= tsh; y++) {\n\t\t\tfor (int x = 1; x <= tsw; x++) {\n\t\t\t\ttreasure[y][x] += treasure[y-1][x] + treasure[y][x-1] - treasure[y-1][x-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tInteger xx1 = tsx.ceiling(new Integer(ZX[i][0]));\n\t\t\tInteger xx2 = tsx.floor(new Integer(ZX[i][1]));\n\t\t\tInteger yy1 = tsy.ceiling(new Integer(ZY[i][0]));\n\t\t\tInteger yy2 = tsy.floor(new Integer(ZY[i][1]));\n\t\t\t\n\t\t\tif( xx1 == null || xx2 == null || yy1 == null || yy2 == null )\n\t\t\t{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint x1 = alx.indexOf(xx1);\n\t\t\tint x2 = alx.indexOf(xx2) + 1;\n\t\t\tint y1 = aly.indexOf(yy1);\n\t\t\tint y2 = aly.indexOf(yy2) + 1;\n\t\t\t\n\t\t\tint ret = treasure[y2][x2] - treasure[y2][x1] - treasure[y1][x2] + treasure[y1][x1];\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\t\n\tstatic public void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tN = sca.nextInt();\n\t\t\tM = sca.nextInt();\n\t\t\t\n\t\t\tTX = new int[N];\n\t\t\tTY = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tTX[i] = sca.nextInt();\n\t\t\t\tTY[i] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tZX = new int[M][2];\n\t\t\tZY = new int[M][2];\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tZX[i][0] = sca.nextInt();\n\t\t\t\tZY[i][0] = sca.nextInt();\n\t\t\t\tZX[i][1] = sca.nextInt();\n\t\t\t\tZY[i][1] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main{\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\tfinal int n = sc.nextInt();\n\t\tfinal int m = sc.nextInt();\n\t\t\n\t\t\n\t\tint x_base[] = new int[n];\n\t\tint y_base[] = new int[n];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_base[i] = sc.nextInt();\n\t\t\ty_base[i] = sc.nextInt();\n\t\t}\n\t\t\n\t\tTreeSet<Integer> x_set = new TreeSet<Integer>();\n\t\tTreeSet<Integer> y_set = new TreeSet<Integer>();\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tx_set.add(x_base[i]);\n\t\t\ty_set.add(y_base[i]);\n\t\t}\n\t\t\n\t\tint[] x_array = new int[x_set.size()];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tx_array[i] = x_set.pollFirst();\n\t\t}\n\t\t\n\t\tint[] y_array = new int[y_set.size()];\n\t\tfor(int i = 0; i < y_array.length; i++){\n\t\t\ty_array[i] = y_set.pollFirst();\n\t\t}\n\t\t\n\t\tint col[][] = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcol[Arrays.binarySearch(x_array,x_base[i])][Arrays.binarySearch(y_array,y_base[i])]++;\n\t\t}\n\t\t\n\t\tint[][] pre = new int[x_array.length][y_array.length];\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\t\t\n\t\t\t\tif(i != 0 && j != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + pre[i][j-1] - pre[i-1][j-1]  + col[i][j];\n\t\t\t\t}else if(i != 0){\n\t\t\t\t\tpre[i][j] = pre[i-1][j] + col[i][j];\n\t\t\t\t}else if(j != 0){\n\t\t\t\t\tpre[i][j] = pre[i][j-1] + col[i][j];\n\t\t\t\t}else{\n\t\t\t\t\tpre[i][j] = col[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t/* ok */\n\t\t\n\t\t\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\t\tSystem.out.print(col[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tfor(int i = 0; i < x_array.length; i++){\n\t\t\tfor(int j = 0; j < y_array.length; j++){\n\t\t\t\tSystem.out.print(pre[i][j] + \" \");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tfinal int x1 = sc.nextInt();\n\t\t\tfinal int y1 = sc.nextInt();\n\t\t\tfinal int x2 = sc.nextInt();\n\t\t\tfinal int y2 = sc.nextInt();\n\t\t\t\n\t\t\t\n\t\t\tint x1_b = Arrays.binarySearch(x_array, x1);\n\t\t\tint y1_b = Arrays.binarySearch(y_array, y1);\n\t\t\tint x2_b = Arrays.binarySearch(x_array, x2);\n\t\t\tint y2_b = Arrays.binarySearch(y_array, y2);\n\t\t\t\n//\t\t\tif(x1_b < 0){\n//\t\t\t\tSystem.out.println(\"x1- \" + x1_b);\n//\t\t\t}\n//\t\t\tif(y1_b < 0){\n//\t\t\t\tSystem.out.println(\"y1- \" + y1_b);\n//\t\t\t}\n\t\t\t\n\t\t\tx1_b = x1_b < 0 ? -(x1_b + 1) : x1_b;\n\t\t\ty1_b = y1_b < 0 ? -(y1_b + 1) : y1_b;\n\n\t\t\tx2_b = x2_b < 0 ? -(x2_b + 1) - 1 : x2_b;\n\t\t\ty2_b = y2_b < 0 ? -(y2_b + 1) - 1 : y2_b;\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\t\n//\t\t\tx2_b = x2_b >= x_array.length ? x_array.length-1 : x2_b;\n//\t\t\ty2_b = y2_b >= y_array.length ? y_array.length-1 : y2_b;\n\t\t\t\n//\t\t\tSystem.out.println(Arrays.toString(x_array));\n//\t\t\tSystem.out.println(x_array.length + \",\" + x1_b);\n//\t\t\tSystem.out.println(Arrays.toString(y_array));\n//\t\t\tSystem.out.println(y_array.length + \",\" + y1_b);\n//\t\t\tSystem.out.println(Arrays.toString(x_array));\n//\t\t\tSystem.out.println(x_array.length + \",\" + x2_b);\n//\t\t\tSystem.out.println(Arrays.toString(y_array));\n//\t\t\tSystem.out.println(y_array.length + \",\" + y2_b);\n\t\t\t\n\t\t\tif(x1_b > x2_b || y1_b > y2_b){\n\t\t\t\tsum = 0;\n\t\t\t}else if(x1_b != 0 && y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b] - pre[x2_b][y1_b-1] + pre[x1_b-1][y1_b-1];\n\t\t\t}else if(x1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x1_b-1][y2_b];\n\t\t\t}else if(y1_b != 0){\n\t\t\t\tsum = pre[x2_b][y2_b] - pre[x2_b][y1_b-1];\n\t\t\t}else{\n\t\t\t\tsum = pre[x2_b][y2_b];\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tAOJ2426(){\n\t\t\t//while(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\t//if(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t//}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\tTreeSet<Integer> xs=new TreeSet<Integer>(),ys=new TreeSet<Integer>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tint xidx=Arrays.binarySearch(x2, x1[i]), yidx=Arrays.binarySearch(y2, y1[i]);\n\t\t\t\tfor(int x=xidx; x<xs.size(); x++)for(int y=yidx; y<ys.size(); y++)sum[x][y]++;\n\t\t\t}\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=sc.nextInt(),ym1=sc.nextInt(),xm2=sc.nextInt(),ym2=sc.nextInt();\n\t\t\t\tint tmp=Arrays.binarySearch(x2, xm1);\n\t\t\t\tint xidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym1);\n\t\t\t\tint yidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(x2, xm2);\n\t\t\t\tint xidx2=(tmp>=0?tmp:min(x2.length-1, abs(tmp)-2));\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym2);\n\t\t\t\tint yidx2=(tmp>=0?tmp:min(y2.length-1, abs(tmp)-2));\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println(sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\t\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n\t\t\treturn num;\n\t\t}\n\t}\n\tNode make2DTree(PriorityQueue<P> q, int depth, double lx, double rx, double ly, double ry, Node parent){\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(q.size()==1){\n\t\t\tres.point = q.poll();\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(q.size(), depth%2==0?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(q.size(), depth%2==0?xsort:ysort);\n\t\tint mid = (q.size()-1)/2, idx = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tif(idx==mid)res.point = q.peek();\n\t\t\tif(idx++ <= mid)L.add(q.poll());\n\t\t\telse R.add(q.poll());\n\t\t}\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(L, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(R, depth+1, res.point.x, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(L, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(R, depth+1, lx, rx, res.point.y, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tPriorityQueue<P> q = new PriorityQueue<P>(list.size(), xsort);\n\t\tfor(P p:list)q.add(p);\n\t\treturn make2DTree(q, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>();\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n\t\twhile(m--!=0){\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\tSystem.out.println(root.search(x1, x2, y1, y2));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\n\tstatic Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tint N = sc.nextInt();\n\t\tint M = sc.nextInt();\n\t\tint[] X = new int[N];\n\t\tint[] Y = new int[N];\n\t\tTreeSet<Integer> xset = new TreeSet<Integer>();\n\t\tTreeSet<Integer> yset = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tX[i] = Integer.parseInt(sc.next());\n\t\t\tY[i] = Integer.parseInt(sc.next());\n\t\t\txset.add(X[i]);\n\t\t\tyset.add(Y[i]);\n\t\t}\n\t\txset.add(Integer.MIN_VALUE);\n\t\txset.add(Integer.MAX_VALUE);\n\t\tyset.add(Integer.MIN_VALUE);\n\t\tyset.add(Integer.MAX_VALUE);\n\t\tHashMap<Integer, Integer> xs = new HashMap<Integer, Integer>();\n\t\tHashMap<Integer, Integer> ys = new HashMap<Integer, Integer>();\n\t\tint[] xpos = new int[xset.size()];\n\t\tfor (int xv : xset) {\n\t\t\txpos[xs.size()] = xv;\n\t\t\txs.put(xv, xs.size());\n\t\t}\n\t\tint[] ypos = new int[yset.size()];\n\t\tfor (int yv : yset) {\n\t\t\typos[ys.size()] = yv;\n\t\t\tys.put(yv, ys.size());\n\t\t}\n\t\tint xl = xs.size();\n\t\tint yl = ys.size();\n\t\tint[][] dp = new int[xl][yl];\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tdp[xs.get(X[i])][ys.get(Y[i])]++;\n\t\t}\n\t\tfor (int i = 1; i < xl; ++i) {\n\t\t\tfor (int j = 1; j < yl; ++j) {\n\t\t\t\tdp[i][j] += dp[i - 1][j] + dp[i][j - 1] - dp[i - 1][j - 1];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < M; ++i) {\n\t\t\tint x1 = pos(xpos, Integer.parseInt(sc.next()), true);\n\t\t\tint y1 = pos(ypos, Integer.parseInt(sc.next()), true);\n\t\t\tint x2 = pos(xpos, Integer.parseInt(sc.next()), false);\n\t\t\tint y2 = pos(ypos, Integer.parseInt(sc.next()), false);\n\t\t\tSystem.out.println(x1 > x2 || y1 > y2 ? 0 : dp[x2][y2] - dp[x2][y1 - 1] - dp[x1 - 1][y2] + dp[x1 - 1][y1 - 1]);\n\t\t}\n\t}\n\n\tstatic int pos(int[] coord, int p, boolean up) {\n\t\tint ret = Arrays.binarySearch(coord, p);\n\t\tif (ret < 0) ret = -ret - (up ? 1 : 2);\n\t\tif (ret >= coord.length) ret = coord.length - 1;\n\t\treturn ret;\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Main {\n\t//1700 cording start\n\t//1803 sample matched\n\tboolean isfind;\n\t\n\tprivate void doit(){\n\t\tInStream sc = new InStream();\n\t\t//while(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint [] xlist = new int[n];\n\t\t\tint [] ylist = new int[n];\n\t\t\tArrayList<Integer> xl = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> yl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\txl.add(xlist[i]);\n\t\t\t\tyl.add(ylist[i]);\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(yl);\n\t\t\tCollections.sort(xl);\n\t\t\t\n\t\t\tfor(int i = 1; i < xl.size(); i++){\n\t\t\t\tif(xl.get(i-1) == xl.get(i)){\n\t\t\t\t\txl.remove(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1; i < yl.size(); i++){\n\t\t\t\tif(yl.get(i-1) == yl.get(i)){\n\t\t\t\t\tyl.remove(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [][] acc = new int[yl.size() + 1][xl.size()+1];\n\t\t\tfor(int k = 0 ; k < n; k++){\n\t\t\t\tint x = Collections.binarySearch(xl, xlist[k]) + 1;\n\t\t\t\tint y = Collections.binarySearch(yl, ylist[k]) + 1;\n\t\t\t\tfor(int i = y; i < acc.length; i++){\n\t\t\t\t\tfor(int j = x; j < acc[i].length; j++){\n\t\t\t\t\t\tacc[i][j]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(Arrays.toString(ysorted));\n//\t\t\tSystem.out.println(Arrays.toString(xsorted));\n//\t\t\tSystem.out.println(yl.size() + \" \" + xl.size());\n//\t\t\tfor(int i = 0 ; i < acc.length; i++){\n//\t\t\t\tSystem.out.print(\"i = \" + i);\n//\t\t\t\tfor(int j = 0; j < acc[i].length; j++){\n//\t\t\t\t\tSystem.out.print(acc[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\t//query\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tint minx = sc.nextInt();\n\t\t\t\tint miny = sc.nextInt();\n\t\t\t\tint maxx = sc.nextInt();\n\t\t\t\tint maxy = sc.nextInt();\n\t\t\t\t\n\t\t\t\tint x1,y1,x2,y2;\n\t\t\t\tx1 = bs(xl, minx);\n\t\t\t\ty1 = bs(yl, miny);\n\t\t\t\t\n\t\t\t\tisfind = false;\n\t\t\t\tx2 = bs(xl, maxx);\n\t\t\t\tif(isfind) x2++;\n\t\t\t\tisfind = false;\n\t\t\t\ty2 = bs(yl, maxy);\n\t\t\t\tif(isfind) y2++;\n\t\t\t\t\n\t\t\t\t//System.out.println(\"x1 = \" + x1 + \"y1 = \" + y1 + \"x2 = \" + x2 +\" y2 = \" + y2);\n\t\t\t\t\n\t\t\t\tint res = acc[y2][x2] + acc[y1][x1] - acc[y2][x1] - acc[y1][x2];\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t//}\n\t\t\n\t}\n\n\n\tprivate int bs(ArrayList<Integer>a, int x) {\n\t\tint mid, left = 0, right = a.size() -1;\n\t\twhile(left <= right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(a.get(mid) == x){\n\t\t\t\tisfind = true;\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\tif(a.get(mid) < x){\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\t\n\tclass InStream{\n\t\tBufferedReader in;\n\t\tStringTokenizer st;\n\t\tpublic InStream() {\n\t\t\tthis.in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tthis.st = null;\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st==null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken(); \n\t\t}\n\t\t\n\t\tboolean hasNext(){\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\treturn true;\n\t\t\t} catch (Exception e) {return false;}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next()); \n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass Scanner {\n\t\tint nextInt() {\n\t\t\ttry {\n\t\t\t\tint c = System.in.read();\n\t\t\t\twhile (c != '-' && (c < '0' || '9' < c))\n\t\t\t\t\tc = System.in.read();\n\t\t\t\tif (c == '-') return -nextInt();\n\t\t\t\tint res = 0;\n\t\t\t\tdo {\n\t\t\t\t\tres *= 10;\n\t\t\t\t\tres += c - '0';\n\t\t\t\t\tc = System.in.read();\n\t\t\t\t} while ('0' <= c && c <= '9');\n\t\t\t\treturn res;\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\tint cnt;\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n//\t\t\tcnt++;\n//\t\t\tif(left==null)return num;\n//\t\t\tleft.reportAll(); right.reportAll();\n\t\t\treturn num;\n\t\t}\n\t}\n\tNode make2DTree(PriorityQueue<P> q, int depth, double lx, double rx, double ly, double ry, Node parent){\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(q.size()==1){\n\t\t\tres.point = q.poll();\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(q.size(), depth%2==1?xsort:ysort);\n\t\tint mid = (q.size()-1)/2, idx = 0;\n\t\twhile(!q.isEmpty()){\n\t\t\tif(idx==mid)res.point = q.peek();\n\t\t\tif(idx++ <= mid)L.add(q.poll());\n\t\t\telse R.add(q.poll());\n\t\t}\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(L, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(R, depth+1, res.point.x, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(L, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(R, depth+1, lx, rx, res.point.y, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tPriorityQueue<P> q = new PriorityQueue<P>(list.size(), xsort);\n\t\tfor(P p:list)q.add(p);\n\t\treturn make2DTree(q, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner();\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n//\t\tlong T = System.currentTimeMillis();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>(n);\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n\t\twhile(m--!=0){\n\t\t\tcnt = 0;\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\tSystem.out.println(root.search(x1, x2, y1, y2));\n//\t\t\tint ans = 0;\n//\t\t\tfor(P a:p)if(x1<=a.x&&a.x<=x2&&y1<=a.y&&a.y<=y2)ans++;\n//\t\t\tSystem.out.println(root.search(x1, x2, y1, y2)+\" \"+cnt+\" \"+ans);\n//\t\t\troot.search(x1, x2, y1, y2);\n//\t\t\tSystem.out.println(cnt);\n\t\t}\n//\t\tSystem.out.println(root.num);\n//\t\tSystem.out.println(System.currentTimeMillis()-T+\" ms.\");\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.*;\npublic class Main {\n\t//1700 cording start\n\t//1803 sample matched\n\tboolean isfind;\n\t\n\tprivate void doit(){\n\t\tInStream sc = new InStream();\n\t\twhile(sc.hasNext()){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint [] xlist = new int[n];\n\t\t\tint [] ylist = new int[n];\n\t\t\tArrayList<Integer> xl = new ArrayList<Integer>();\n\t\t\tArrayList<Integer> yl = new ArrayList<Integer>();\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\txlist[i] = sc.nextInt();\n\t\t\t\tylist[i] = sc.nextInt();\n\t\t\t\txl.add(xlist[i]);\n\t\t\t\tyl.add(ylist[i]);\n\t\t\t}\n\t\t\t\n\t\t\tCollections.sort(yl);\n\t\t\tCollections.sort(xl);\n\t\t\t\n\t\t\tfor(int i = 1; i < xl.size(); i++){\n\t\t\t\tif(xl.get(i-1) == xl.get(i)){\n\t\t\t\t\txl.remove(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 1; i < yl.size(); i++){\n\t\t\t\tif(yl.get(i-1) == yl.get(i)){\n\t\t\t\t\tyl.remove(i);\n\t\t\t\t\ti--;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint [][] acc = new int[yl.size() + 1][xl.size()+1];\n\t\t\tfor(int k = 0 ; k < n; k++){\n\t\t\t\tint x = Collections.binarySearch(xl, xlist[k]) + 1;\n\t\t\t\tint y = Collections.binarySearch(yl, ylist[k]) + 1;\n\t\t\t\tacc[y][x]++;\n\t\t\t}\n\t\t\tfor(int i = 1; i < acc.length; i++){\n\t\t\t\tfor(int j = 1; j < acc[i].length; j++){\n\t\t\t\t\tacc[i][j] += acc[i-1][j] + acc[i][j-1] - acc[i-1][j-1];\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//debug\n//\t\t\tSystem.out.println(yl.size() + \" \" + xl.size());\n//\t\t\tfor(int i = 0 ; i < acc.length; i++){\n//\t\t\t\tSystem.out.print(\"i = \" + i);\n//\t\t\t\tfor(int j = 0; j < acc[i].length; j++){\n//\t\t\t\t\tSystem.out.print(acc[i][j] + \" \");\n//\t\t\t\t}\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\t//query\n\t\t\tfor(int i = 0 ; i < m; i++){\n\t\t\t\tint minx = sc.nextInt();\n\t\t\t\tint miny = sc.nextInt();\n\t\t\t\tint maxx = sc.nextInt();\n\t\t\t\tint maxy = sc.nextInt();\n\t\t\t\t\n\t\t\t\tint x1,y1,x2,y2;\n\t\t\t\tx1 = bs(xl, minx);\n\t\t\t\ty1 = bs(yl, miny);\n\t\t\t\t\n\t\t\t\tisfind = false;\n\t\t\t\tx2 = bs(xl, maxx);\n\t\t\t\tif(isfind) x2++;\n\t\t\t\tisfind = false;\n\t\t\t\ty2 = bs(yl, maxy);\n\t\t\t\tif(isfind) y2++;\n\t\t\t\t\n\t\t\t\t//System.out.println(\"x1 = \" + x1 + \"y1 = \" + y1 + \"x2 = \" + x2 +\" y2 = \" + y2);\n\t\t\t\t\n\t\t\t\tint res = acc[y2][x2] + acc[y1][x1] - acc[y2][x1] - acc[y1][x2];\n\t\t\t\tSystem.out.println(res);\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n\n\tprivate int bs(ArrayList<Integer>a, int x) {\n\t\tint mid, left = 0, right = a.size() -1;\n\t\twhile(left <= right){\n\t\t\tmid = (left + right) / 2;\n\t\t\tif(a.get(mid) == x){\n\t\t\t\tisfind = true;\n\t\t\t\treturn mid;\n\t\t\t}\n\t\t\tif(a.get(mid) < x){\n\t\t\t\tleft = mid + 1;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tright = mid - 1;\n\t\t\t}\n\t\t}\n\t\treturn left;\n\t}\n\t\n\tclass InStream{\n\t\tBufferedReader in;\n\t\tStringTokenizer st;\n\t\tpublic InStream() {\n\t\t\tthis.in = new BufferedReader(new InputStreamReader(System.in));\n\t\t\tthis.st = null;\n\t\t}\n\t\t\n\t\tString next() {\n\t\t\twhile (st==null || !st.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\t} catch (Exception e) {}\n\t\t\t}\n\t\t\treturn st.nextToken(); \n\t\t}\n\t\t\n\t\tboolean hasNext(){\n\t\t\ttry {\n\t\t\t\tst = new StringTokenizer(in.readLine());\n\t\t\t\treturn true;\n\t\t\t} catch (Exception e) {return false;}\n\t\t}\n\n\t\tint nextInt() {\n\t\t\treturn Integer.parseInt(next()); \n\t\t}\n\n\t\tlong nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\n\t\tdouble nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t}\n\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Treasure Hunt\npublic class Main{\n\n\tclass P{\n\t\tdouble x, y;\n\t\tpublic P(double x, double y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t}\n\t\n\tComparator<P> xsort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.x-o2.x);\n\t\t}\n\t};\n\tComparator<P> ysort = new Comparator<P>() {\n\t\tpublic int compare(P o1, P o2) {\n\t\t\treturn (int)Math.signum(o1.y-o2.y);\n\t\t}\n\t};\n\t\n\tclass Node{\n\t\tdouble lx, rx, ly, ry;\n\t\tNode parent;\n\t\tNode left, right;\n\t\tP point;\n\t\tint num;\n\t\tpublic Node(double lx, double rx, double ly, double ry) {\n\t\t\tthis.lx = lx;\n\t\t\tthis.rx = rx;\n\t\t\tthis.ly = ly;\n\t\t\tthis.ry = ry;\n\t\t\tparent = left = right = null;\n\t\t\tpoint = null;\n\t\t\tnum = 0;\n\t\t}\n\t\tint search(double x1, double x2, double y1, double y2){\n\t\t\tif(left==null){\n\t\t\t\tif(x1 <= point.x && point.x <= x2 && y1 <= point.y && point.y <= y2)return reportAll();\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tif(x2 < lx || rx < x1 || y2 < ly || ry < y1)return 0;\n\t\t\tif(x1 <= lx && rx <= x2 && y1 <= ly && ry <= y2){\n\t\t\t\treturn reportAll();\n\t\t\t}\n\t\t\treturn left.search(x1, x2, y1, y2) + right.search(x1, x2, y1, y2);\n\t\t}\n\t\tint reportAll(){\n\t\t\treturn num;\n\t\t}\n\t}\n\tNode make2DTree(List<P> list, int depth, double lx, double rx, double ly, double ry, Node parent){\n\t\tNode res = new Node(lx, rx, ly, ry);\n\t\tres.parent = parent;\n\t\tif(list.size()==1){\n\t\t\tres.point = list.get(0);\n\t\t\tres.num = 1;\n\t\t\treturn res;\n\t\t}\n\t\tPriorityQueue<P> L = new PriorityQueue<P>(list.size(), depth%2==0?xsort:ysort);\n\t\tPriorityQueue<P> R = new PriorityQueue<P>(list.size(), depth%2==0?xsort:ysort);\n\t\tint mid = (list.size()-1)/2;\n\t\tres.point = list.get(mid);\n\t\tfor(int i=0;i<list.size();i++){\n\t\t\tif(i<=mid)L.add(list.get(i));\n\t\t\telse R.add(list.get(i));\n\t\t}\n\t\tList<P> leftList = new ArrayList<P>(), rightList = new ArrayList<P>();\n\t\twhile(!L.isEmpty())leftList.add(L.poll());\n\t\twhile(!R.isEmpty())rightList.add(R.poll());\n\t\tif(depth%2==0){\n\t\t\tres.left = make2DTree(leftList, depth+1, lx, res.point.x, ly, ry, res);\n\t\t\tres.right = make2DTree(rightList, depth+1, res.point.x, rx, ly, ry, res);\n\t\t}\n\t\telse{\n\t\t\tres.left = make2DTree(leftList, depth+1, lx, rx, ly, res.point.y, res);\n\t\t\tres.right = make2DTree(rightList, depth+1, lx, rx, res.point.y, ry, res);\n\t\t}\n\t\tres.num = res.left.num + res.right.num;\n\t\treturn res;\n\t}\n\tNode make(List<P> list, double lx, double rx, double ly, double ry){\n\t\tCollections.sort(list, xsort);\n\t\treturn make2DTree(list, 0, lx, rx, ly, ry, null);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt(), m = sc.nextInt();\n\t\tint INF = 1<<30;\n\t\tList<P> p = new ArrayList<P>();\n\t\tfor(int i=0;i<n;i++)p.add(new P(sc.nextInt(), sc.nextInt()));\n\t\tNode root = make(p, -INF, INF, -INF, INF);\n\t\twhile(m--!=0){\n\t\t\tint x1 = sc.nextInt(), y1 = sc.nextInt(), x2 = sc.nextInt(), y2 = sc.nextInt();\n\t\t\tSystem.out.println(root.search(x1, x2, y1, y2));\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.*;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Treasure Hunt\n */\npublic class Main {\n\n\tstatic final int MIN = -1_000_000_001;\n\n\tpublic static void main(String[] args) throws IOException {\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\tString line;\n\t\tString[] words;\n\n\t\tline = br.readLine();\n\n\t\tint n, m;\n\t\tn = parseInt(line.substring(0, line.indexOf(' ')));\n\t\tm = parseInt(line.substring(line.indexOf(' ') + 1));\n\n\t\tint[][] xy = new int[n + 1][2];\n\t\tSortedMap<Integer, Integer> x = new TreeMap<>();\n\t\tSortedMap<Integer, Integer> y = new TreeMap<>();\n\n\t\t//xy\n\t\txy[0][0] = MIN;\n\t\txy[0][1] = MIN;\n\t\tx.put(MIN, 0);\n\t\ty.put(MIN, 0);\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tline = br.readLine();\n\t\t\txy[i][0] = parseInt(line.substring(0, line.indexOf(' ')));\n\t\t\txy[i][1] = parseInt(line.substring(line.indexOf(' ') + 1));\n\t\t\tx.put(xy[i][0], 0);\n\t\t\ty.put(xy[i][1], 0);\n\t\t}\n\n\t\t//x\n\t\tint _i;\n\t\t_i = 0;\n\t\tfor (Map.Entry<Integer,Integer> e : x.entrySet()) {\n\t\t\te.setValue(_i);\n\t\t\t_i++;\n\t\t}\n\n\t\t//y\n\t\t_i = 0;\n\t\tfor (Map.Entry<Integer,Integer> e : y.entrySet()) {\n\t\t\te.setValue(_i);\n\t\t\t_i++;\n\t\t}\n\n\t\t//sum\n\t\tint[][] map = new int[x.size()][y.size()];\n\t\tfor (int i = 1; i <= n; i++) {\n\t\t\tmap[x.get(xy[i][0])][y.get(xy[i][1])] = 1;\n\t\t}\n\t\tfor (int i = 1; i < map.length; i++) {\n\t\t\tfor (int j = 1; j < map[0].length; j++) {\n\t\t\t\tmap[i][j] += (map[i][j - 1] + map[i - 1][j] - map[i - 1][j - 1]);\n\t\t\t}\n\t\t}\n\n\t\t//query\n\t\tStringBuilder sb = new StringBuilder();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\twords = br.readLine().split(\" \");\n\t\t\tint x1, y1, x2, y2;\n\t\t\tx1 = (int) ((NavigableMap<Integer,Integer>) x).lowerEntry(parseInt(words[0])).getValue();\n\t\t\ty1 = (int) ((NavigableMap<Integer,Integer>) y).lowerEntry(parseInt(words[1])).getValue();\n\t\t\tx2 = (int) ((NavigableMap<Integer,Integer>) x).floorEntry(parseInt(words[2])).getValue();\n\t\t\ty2 = (int) ((NavigableMap<Integer,Integer>) y).floorEntry(parseInt(words[3])).getValue();\n\t\t\tint c = map[x2][y2] - map[x1][y2] - map[x2][y1] + map[x1][y1];\n\t\t\tsb.append(c).append('\\n');\n\t\t}\n\t\tSystem.out.print(sb.toString());\n\n\t} //end main\n}"
  },
  {
    "language": "Java",
    "code": "import java.lang.reflect.Array;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\tstatic int N, M;\n\tstatic int[] TX, TY;\n\tstatic int[][] ZX, ZY;\n\t\t\t\n\tstatic private void solve()\n\t{\n\t\tTreeSet<Integer> tsx = new TreeSet<Integer>();\n\t\tTreeSet<Integer> tsy = new TreeSet<Integer>();\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ttsx.add(new Integer(TX[i]));\n\t\t\ttsy.add(new Integer(TY[i]));\n\t\t}\n\t\tArrayList<Integer> alx = new ArrayList<Integer>(tsx);\n\t\tArrayList<Integer> aly = new ArrayList<Integer>(tsy);\n\t\tint tsw = tsx.size();\n\t\tint tsh = tsy.size();\n\t\t\n\t\tint[][] treasure = new int[tsy.size() + 1][tsx.size() + 1];\n\t\tfor (int y = 0; y < tsh+1; y++) {\n\t\t\tfor (int x = 0; x < tsw+1; x++) {\n\t\t\t\ttreasure[y][x] = 0;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tint x = alx.indexOf(new Integer(TX[i]));\n\t\t\tint y = aly.indexOf(new Integer(TY[i]));\n\t\t\ttreasure[y + 1][x + 1]++;\n\t\t}\n\t\t\n\t\tfor (int y = 1; y <= tsh; y++) {\n\t\t\tfor (int x = 1; x <= tsw; x++) {\n\t\t\t\ttreasure[y][x] += treasure[y-1][x] + treasure[y][x-1] - treasure[y-1][x-1];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (int i = 0; i < M; i++) {\n\t\t\tInteger xx1 = tsx.ceiling(new Integer(ZX[i][0]));\n\t\t\tInteger xx2 = tsx.floor(new Integer(ZX[i][1]));\n\t\t\tInteger yy1 = tsy.ceiling(new Integer(ZY[i][0]));\n\t\t\tInteger yy2 = tsy.floor(new Integer(ZY[i][1]));\n\t\t\t\n\t\t\tif( xx1 == null || xx2 == null || yy1 == null || yy2 == null )\n\t\t\t{\n\t\t\t\tSystem.out.println(\"0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint x1 = Arrays.binarySearch(alx.toArray(), xx1);\n\t\t\tint x2 = Arrays.binarySearch(alx.toArray(), xx2) + 1;\n\t\t\tint y1 = Arrays.binarySearch(aly.toArray(), yy1);\n\t\t\tint y2 = Arrays.binarySearch(aly.toArray(), yy2) + 1;\n\t\t\t\n\t\t\t/*int x1 = alx.indexOf(xx1);\n\t\t\tint x2 = alx.indexOf(xx2) + 1;\n\t\t\tint y1 = aly.indexOf(yy1);\n\t\t\tint y2 = aly.indexOf(yy2) + 1;*/\n\t\t\t\n\t\t\tint ret = treasure[y2][x2] - treasure[y2][x1] - treasure[y1][x2] + treasure[y1][x1];\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\t\n\tstatic public void main(String[] args)\n\t{\n\t\tScanner sca = new Scanner(System.in);\n\t\t\n\t\twhile(true)\n\t\t{\n\t\t\tN = sca.nextInt();\n\t\t\tM = sca.nextInt();\n\t\t\t\n\t\t\tTX = new int[N];\n\t\t\tTY = new int[N];\n\t\t\tfor (int i = 0; i < N; i++) {\n\t\t\t\tTX[i] = sca.nextInt();\n\t\t\t\tTY[i] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tZX = new int[M][2];\n\t\t\tZY = new int[M][2];\n\t\t\tfor (int i = 0; i < M; i++) {\n\t\t\t\tZX[i][0] = sca.nextInt();\n\t\t\t\tZY[i][0] = sca.nextInt();\n\t\t\t\tZX[i][1] = sca.nextInt();\n\t\t\t\tZY[i][1] = sca.nextInt();\n\t\t\t}\n\t\t\t\n\t\t\tsolve();\n\t\t\t\n\t\t\tbreak;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\t\tint n = nextInt();\n\t\tint m = nextInt();\n\n\t\tArrayList<Treasure> list = new ArrayList<Treasure>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tlist.add(new Treasure(nextInt(), nextInt()));\n\t\t}\n\t\tCollections.sort(list);\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint t = 0;\n\t\t\tint x1 = nextInt();\n\t\t\tint y1 = nextInt();\n\t\t\tint x2 = nextInt();\n\t\t\tint y2 = nextInt();\n\n\t\t\tfor (Treasure treasure : list) {\n\t\t\t\tif (treasure.x >= x1 && treasure.y >= y1 && treasure.x <= x2 && treasure.y <= y2) {\n\t\t\t\t\tt++;\n\t\t\t\t} else if (treasure.x > x2) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(t);\n\n\t\t}\n\n\t}\n\n\tstatic int nextInt() {\n\t\tint c;\n\t\ttry {\n\t\t\tc = System.in.read();\n\t\t\twhile (c != '-' && (c < '0' || c > '9'))\n\t\t\t\tc = System.in.read();\n\t\t\tif (c == '-')\n\t\t\t\treturn -nextInt();\n\t\t\tint res = 0;\n\t\t\twhile (c >= '0' && c <= '9') {\n\t\t\t\tres = res * 10 + c - '0';\n\t\t\t\tc = System.in.read();\n\t\t\t}\n\t\t\treturn res;\n\t\t} catch (IOException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn -1;\n\t}\n}\n\nclass Treasure implements Comparable<Treasure> {\n\tint x, y;\n\n\tpublic Treasure(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t}\n\n\tpublic int compareTo(Treasure o) {\n\t\treturn this.x - o.x;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\tfinal Scanner sc=new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main().init();\n\t}\n\tvoid init(){\n\t\tnew AOJ2426();\n\t}\n\t\n\tclass AOJ2426{\n\t\tAOJ2426(){\n\t\t\t//while(sc.hasNext()){\n\t\t\t\tint N=sc.nextInt(),M=sc.nextInt();\n\t\t\t\t//if(N==0 && M==0)\tbreak;\n\t\t\t\tsolve(N,M);\n\t\t\t//}\n\t\t}\n\t\tvoid solve(int N,int M){\n\t\t\tTreeSet<Integer> xs=new TreeSet<Integer>(),ys=new TreeSet<Integer>();\n\t\t\tint[] x1=new int[N],y1=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx1[i]=sc.nextInt();\n\t\t\t\ty1[i]=sc.nextInt();\n\t\t\t\txs.add(x1[i]);\n\t\t\t\tys.add(y1[i]);\n\t\t\t}\n\t\t\tint[] x2=new int[xs.size()],y2=new int[ys.size()];\n\t\t\tint idx=0;\n\t\t\tfor(int i:xs)\tx2[idx++]=i;\n\t\t\tidx=0;\n\t\t\tfor(int i:ys)\ty2[idx++]=i;\n\t\t\tint[][] sum=new int[xs.size()][ys.size()];\n\t\t\tfor(int i=0; i<N; i++)\t++sum[Arrays.binarySearch(x2, x1[i])][Arrays.binarySearch(y2, y1[i])];\n\t\t\tfor(int x=1; x<x2.length; x++)\tsum[x][0]+=sum[x-1][0];\n\t\t\tfor(int y=1; y<y2.length; y++)\tsum[0][y]+=sum[0][y-1];\n\t\t\tfor(int x=1; x<x2.length; x++)for(int y=1; y<y2.length; y++)\tsum[x][y]+=sum[x-1][y]+sum[x][y-1]-sum[x-1][y-1];\n\t\t\t\n\t\t\t// TODO debug\n//\t\t\tSystem.out.print(\"   \");\n//\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",x2[x]);\n//\t\t\tSystem.out.println();\n//\t\t\tfor(int y=ys.size()-1; y>=0; y--){\n//\t\t\t\tSystem.out.printf(\"%3d\",y2[y]);\n//\t\t\t\tfor(int x=0; x<xs.size(); x++)System.out.printf(\"%3d\",sum[x][y]);\n//\t\t\t\tSystem.out.println();\n//\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++){\n\t\t\t\tint xm1=Integer.parseInt(sc.next()),ym1=Integer.parseInt(sc.next()),xm2=Integer.parseInt(sc.next()),ym2=Integer.parseInt(sc.next());\n\t\t\t\tint tmp=Arrays.binarySearch(x2, xm1);\n\t\t\t\tint xidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym1);\n\t\t\t\tint yidx1=(tmp>=0?tmp: abs(tmp)-1);\n\t\t\t\ttmp=Arrays.binarySearch(x2, xm2);\n\t\t\t\tint xidx2=(tmp>=0?tmp:min(x2.length-1, abs(tmp)-2));\n\t\t\t\ttmp=Arrays.binarySearch(y2, ym2);\n\t\t\t\tint yidx2=(tmp>=0?tmp:min(y2.length-1, abs(tmp)-2));\n\t\t\t\t//System.out.println(xidx1+\",\"+yidx1+\" \"+xidx2+\",\"+yidx2);\n\t\t\t\tSystem.out.println(sum[xidx2][yidx2]-(xidx1>0?sum[xidx1-1][yidx2]:0)-(yidx1>0?sum[xidx2][yidx1-1]:0)+(xidx1>0&&yidx1>0?sum[xidx1-1][yidx1-1]:0));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tclass AOJ2429{\n\t\tint N;\n\t\tint[][] W,E;\n\t\tAOJ2429(){\n\t\t\tN=sc.nextInt();\n\t\t\tW=new int[N][N];\n\t\t\tE=new int[N][N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tW[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tfor(int x=0; x<N; x++)\tE[x][y]=sc.nextInt();\n\t\t\t}\n\t\t\tStringBuilder init=new StringBuilder();\n\t\t\tint[] w=new int[N],h=new int[N];\n\t\t\tfor(int y=0; y<N; y++){\n\t\t\t\tString str=sc.next();\n\t\t\t\tfor(int x=0; x<N; x++){\n\t\t\t\t\tinit.append(str);\n\t\t\t\t\tif(str.charAt(x)=='o'){\n\t\t\t\t\t\tw[x]++;\n\t\t\t\t\t\th[y]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int lim=0; ; lim++){\n\t\t\t\tState1 res=IDDFS(w.clone(),h.clone(),new StringBuilder(init.toString()),0,0,lim,new ArrayList<State2>(),-1,-1);\n\t\t\t\tif(res!=null){\n\t\t\t\t\tSystem.out.println(res.cost);\n\t\t\t\t\tSystem.out.println(res.depth);\n\t\t\t\t\tfor(State2 st2:res.rec)\tSystem.out.println(st2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tState1 IDDFS(int[] w,int[] h,StringBuilder map,int depth,int cost,int lim,ArrayList<State2> rec,int lx,int ly){\n\t\t\tint nw=0,nh=0;\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tif(w[i]!=1)\tnw++;\n\t\t\t\tif(h[i]!=1)\tnh++;\n\t\t\t}\n\t\t\tif(nw==0 && nh==0){\n\t\t\t\treturn new State1(cost,depth,rec);\n\t\t\t}\n\t\t\tint hs=max(nw,nh);\n\t\t\tif(depth+hs>lim)\treturn null;\n\t\t\t\n\t\t\t//for(int )\n\t\t\t\n\t\t\treturn null;\n\t\t}\n\t\tclass State1{\n\t\t\tint cost,depth;\n\t\t\tArrayList<State2> rec;\n\t\t\tState1(int cost,int depth,ArrayList<State2> rec){\n\t\t\t\tthis.cost=cost;\tthis.depth=depth;\n\t\t\t\tthis.rec=rec;\n\t\t\t}\n\t\t}\n\t\tclass State2{\n\t\t\tint x,y;\n\t\t\tboolean e;\n\t\t\tState2(int x,int y,boolean e){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.e=e;\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\" \"+y+(e? \" erase\": \" write\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\t// JAG SummerCamp2012 Day2#B - A Holiday of Miss Brute Force\n\tclass AOJ2425{\n\t\tfinal int OFFSET=200, MAX=OFFSET*2, INF=Integer.MAX_VALUE/4;\n\t\tfinal int[] vx={0,1,1,0,-1,-1,0},\tvy2={1,0,-1,-1,-1,0,0},\n\t\t\t\t\t\t\t\t\t\t\tvy1={1,1,0,-1,0,1,0};\n\t\tAOJ2425(){\n\t\t\tint sx=sc.nextInt()+OFFSET, sy=sc.nextInt()+OFFSET,\n\t\t\t\tgx=sc.nextInt()+OFFSET, gy=sc.nextInt()+OFFSET,\n\t\t\t\tN=sc.nextInt();\n\t\t\tint[] x=new int[N],y=new int[N];\n\t\t\tfor(int i=0; i<N; i++){\n\t\t\t\tx[i]=sc.nextInt()+OFFSET;\n\t\t\t\ty[i]=sc.nextInt()+OFFSET;\n\t\t\t}\n\t\t\tint LX=sc.nextInt(),LY=sc.nextInt();\n\t\t\tboolean[][] b=new boolean[MAX][MAX];\n\t\t\tfor(int i=0; i<N; i++)\tb[x[i]][y[i]]=true;\n\t\t\t\n\t\t\tPriorityQueue<State1> open=new PriorityQueue<State1>();\n\t\t\topen.add(new State1(sx,sy,0,0));\n\t\t\tint[][][] close=new int[MAX][MAX][6];\n\t\t\tfor(int i=0; i<MAX; i++)for(int j=0; j<MAX; j++)for(int k=0; k<6; k++)close[i][j][k]=INF;\n\t\t\tclose[sx][sy][0]=0;\n\t\t\t\n\t\t\tint ans=INF;\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState1 now=open.poll();\n\t\t\t\t//System.out.println(now);\n\t\t\t\tif(now.x==gx && now.y==gy){\n\t\t\t\t\tans=now.cost;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tint d=(abs(now.x-OFFSET)*abs(now.y-OFFSET)*now.step)%6;\n\t\t\t\tfor(int i=0; i<7; i++){\n\t\t\t\t\tint xx=now.x+vx[i], yy=now.y+(now.x%2==0? vy2[i]: vy1[i]);\n\t\t\t\t\tif(abs(xx-OFFSET)>LX || abs(yy-OFFSET)>LY)\tcontinue;\n\t\t\t\t\tif(b[xx][yy])\tcontinue;\n\t\t\t\t\tint next=now.cost+(d==i? 0: 1);\n\t\t\t\t\tif(close[xx][yy][(now.step+1)%6]<=next)\tcontinue;\n\t\t\t\t\topen.add(new State1(xx,yy,(now.step+1)%6,next));\n\t\t\t\t\tclose[xx][yy][(now.step+1)%6]=next;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans>=INF? -1: ans);\n\t\t}\n\t\tclass State1 implements Comparable<State1>{\n\t\t\tint x,y,step,cost;\n\t\t\tState1(int x,int y,int step,int cost){\n\t\t\t\tthis.x=x;\tthis.y=y;\tthis.step=step;\tthis.cost=cost;\n\t\t\t}\n\t\t\t@Override public int compareTo(State1 o){\n\t\t\t\treturn (this.cost!=o.cost? this.cost-o.cost: this.step-o.step);\n\t\t\t}\n\t\t\t@Override public String toString(){\n\t\t\t\treturn x+\",\"+y+\" \"+cost+\" \"+step+\"steps\";\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Ruby",
    "code": "def compress(used_x)\n\tx_map = {}\n\tused_x.to_a.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nclass Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nrequire 'set'\n\nn, m = gets.split.map &:to_i\nused_x = Set.new\nused_y = Set.new\n\ntreasure = (1..n).map{\n\tx, y = gets.split.map &:to_i\n\tused_x << x\n\tused_y << y\n\t[x, y]\n}\n\nx_map = compress(used_x)\ny_map = compress(used_y)\na = (0..x_map.size-1).map { [0] * y_map.size }\ntreasure.each{|x, y|\n\ta[x_map[x]][y_map[y]] += 1\n}\n\na.accum_2d!\n\nused_x = used_x.to_a.sort\nused_y = used_y.to_a.sort\n\nqueries = (1..m).map {\n\tgets.split.map &:to_i\n}\n\nqueries.each{|x1, y1, x2, y2|\n\ti1 = used_x.bsearch_first_index{|x| x1 <= x}\n\tif !i1\n\t\tputs 0\n\t\tbreak\n\tend\n\tj1 = used_y.bsearch_first_index{|y| y1 <= y}\n\tif !j1\n\t\tputs 0\n\t\tbreak\n\tend\n\ti2 = used_x.bsearch_last_index(i1, used_x.size-1){|x| x <= x2}\n\tif !i2\n\t\tputs 0\n\t\tbreak\n\tend\n\tj2 = used_y.bsearch_last_index(j1, used_y.size-1){|y| y <= y2}\n\tif !j2\n\t\tputs 0\n\t\tbreak\n\tend\n\n\ta[i2+1][j2+1] - a[i2+1][j1] - a[i1][j2+1] + a[i1][j1]\n}"
  },
  {
    "language": "Ruby",
    "code": "def compress(used_x)\n\tx_map = {}\n\tused_x.to_a.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nclass Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nrequire 'set'\n\nn, m = gets.split.map &:to_i\n\nused_x = Set.new\nused_y = Set.new\n\ntreasure = (1..n).map{\n\tx, y = gets.split.map &:to_i\n\tused_x << x\n\tused_y << y\n\t[x, y]\n}\n\nx_map = compress(used_x)\ny_map = compress(used_y)\na = (0..x_map.size-1).map { [0] * y_map.size }\ntreasure.each{|x, y|\n\ta[x_map[x]][y_map[y]] += 1\n}\na.accum_2d!\n\nused_x = used_x.to_a.sort\nused_y = used_y.to_a.sort\n\nm.times {\n\tx1, y1, x2, y2 = gets.split.map &:to_i\n\ti1 = used_x.bsearch_first_index{|x| x1 <= x}\n\tj1 = used_y.bsearch_first_index{|y| y1 <= y}\n\ti2 = used_x.bsearch_last_index{|x| x <= x2}\n\tj2 = used_y.bsearch_last_index{|y| y <= y2}\n\tunless i1 && j1 && i2 && j2\n\t\tputs 0\n\t\tbreak\n\tend\n\tp a[i2+1][j2+1] - a[i2+1][j1] - a[i1][j2+1] + a[i1][j1]\n}"
  },
  {
    "language": "Ruby",
    "code": "def compress(used_x)\n\tx_map = {}\n\tused_x.to_a.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nclass Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nrequire 'set'\n\nn, m = gets.split.map &:to_i\nused_x = Set.new\nused_y = Set.new\n\ntreasure = (1..n).map{\n\tx, y = gets.split.map &:to_i\n\tused_x << x\n\tused_y << y\n\t[x, y]\n}\n\nx_map = compress(used_x)\ny_map = compress(used_y)\na = (0..x_map.size-1).map { [0] * y_map.size }\ntreasure.each{|x, y|\n\ta[x_map[x]][y_map[y]] += 1\n}\n\na.accum_2d!\n\nused_x = used_x.to_a.sort\nused_y = used_y.to_a.sort\n\nqueries = (1..m).map {\n\tgets.split.map &:to_i\n}\n\nqueries.each{|x1, y1, x2, y2|\n\ti1 = used_x.bsearch_first_index{|x| x1 <= x}\n\tif !i1\n\t\tputs 0\n\t\tnext\n\tend\n\tj1 = used_y.bsearch_first_index{|y| y1 <= y}\n\tif !j1\n\t\tputs 0\n\t\tnext\n\tend\n\ti2 = used_x.bsearch_last_index(i1, used_x.size-1){|x| x <= x2}\n\tif !i2\n\t\tputs 0\n\t\tnext\n\tend\n\tj2 = used_y.bsearch_last_index(j1, used_y.size-1){|y| y <= y2}\n\tif !j2\n\t\tputs 0\n\t\tnext\n\tend\n\n\tp a[i2+1][j2+1] - a[i2+1][j1] - a[i1][j2+1] + a[i1][j1]\n}"
  },
  {
    "language": "Ruby",
    "code": "def compress(used_x)\n\tx_map = {}\n\tused_x.to_a.sort.each_with_index{|x, i| x_map[x] = i}\n\tx_map\nend\n\nclass Array\n\tdef accum\n\t\tinject([0]){|a, x| a + [a[-1] + x]}\n\tend\n\n\tdef accum!\n\t\t(1..size-1).each{|i|\n\t\t\tself[i] += self[i-1]\n\t\t}\n\t\tself.unshift(0)\n\tend\n\n\tdef accum_2d\n\t\tac = map{|r| r.accum}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..ac[0].size-1).each{|j|\n\t\t\t\tac[i][j] += ac[i-1][j]\n\t\t\t}\n\t\t}\n\t\tac.unshift([0] * ac[0].size)\n\t\tac\n\tend\n\n\tdef accum_2d!\n\t\teach{|r| r.accum!}\n\t\t(1..size-1).each{|i|\n\t\t\t(1..self[0].size-1).each{|j|\n\t\t\t\tself[i][j] += self[i-1][j]\n\t\t\t}\n\t\t}\n\t\tunshift([0] * self[0].size)\n\tend\n\t\t\n\tdef bsearch_first_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_first_index(l, c-1, &pred) || c\n\t\telse\n\t\t\tbsearch_first_index(c+1, r, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_first_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_first_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\n\n\tdef bsearch_last_index(l = 0, r = size - 1, &pred)\n\t\treturn nil if l > r\n\t\tc = (l + r) / 2 \n\t\tif pred[self[c]]\n\t\t\tbsearch_last_index(c+1, r, &pred) || c\n\t\telse\n\t\t\tbsearch_last_index(l, c-1, &pred)\n\t\tend\n\tend\n\n\tdef bsearch_last_item(l = 0, r = size - 1, &pred)\n\t\ti = bsearch_last_index(l, r, &pred)\n\t\ti ? self[i] : nil\n\tend\nend\n\nrequire 'set'\n\nn, m = gets.split.map &:to_i\nused_x = Set.new\nused_y = Set.new\n\ntreasure = (1..n).map{\n\tx, y = gets.split.map &:to_i\n\tused_x << x\n\tused_y << y\n\t[x, y]\n}\n\nx_map = compress(used_x)\ny_map = compress(used_y)\na = (0..x_map.size-1).map { [0] * y_map.size }\ntreasure.each{|x, y|\n\ta[x_map[x]][y_map[y]] += 1\n}\n\na.accum_2d!\n\nused_x = used_x.to_a.sort\nused_y = used_y.to_a.sort\n\nqueries = (1..m).map {\n\tgets.split.map &:to_i\n}\n\nqueries.each{|x1, y1, x2, y2|\n\ti1 = used_x.bsearch_first_index{|x| x1 <= x}\n\tif !i1\n\t\tputs 0\n\t\tbreak\n\tend\n\tj1 = used_y.bsearch_first_index{|y| y1 <= y}\n\tif !j1\n\t\tputs 0\n\t\tbreak\n\tend\n\ti2 = used_x.bsearch_last_index(i1, used_x.size-1){|x| x <= x2}\n\tif !i2\n\t\tputs 0\n\t\tbreak\n\tend\n\tj2 = used_y.bsearch_last_index(j1, used_y.size-1){|y| y <= y2}\n\tif !j2\n\t\tputs 0\n\t\tbreak\n\tend\n\n\tp a[i2+1][j2+1] - a[i2+1][j1] - a[i1][j2+1] + a[i1][j1]\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nint[int] C(int[] X) {\n    int[] Y = X.sort.uniq.array;\n    int[int] ret;\n    foreach (i; 0 .. cast(int)Y.length) {\n        ret[Y[i]] = i;\n    }\n    return ret;\n}\n\nvoid main() {\n    int n, m; readf(\"%d %d\\n\", &n, &m);\n    int[] X, Y;\n    foreach (i; 0 .. n) {\n        int x, y; readf(\"%d %d\\n\", &x, &y);\n        X ~= x;\n        Y ~= y;\n    }\n    int[] _X = X ~ [int.min, int.max],\n          _Y = Y ~ [int.min, int.max];\n\n    int[int] xM = C(_X.dup);\n    int[int] yM = C(_Y.dup);\n    int[] sX = _X.dup.sort.uniq.array;\n    int[] sY = _Y.dup.sort.uniq.array;\n    auto nx = _X.length, ny = _Y.length;\n    auto F = new short[][](ny, nx);\n    auto G = new short[][](ny + 1, nx + 1);\n    foreach (i; 0 .. n) {\n        F[ yM[ Y[i] ] ][ xM[ X[i] ] ] += 1;\n    }\n    foreach (i; 1 .. ny + 1) {\n        short x = 0;\n        foreach (j; 1 .. nx + 1) {\n            x += F[i - 1][j - 1];\n            G[i][j] = cast(short)(G[i - 1][j] + x);\n        }\n    }\n\n    short f(int sy, int sx, int gy, int gx) {\n        return cast(short)(G[gy][gx] - G[sy][gx] - G[gy][sx] + G[sy][sx]);\n    }\n\n    int g(int[] r, int[int] map, int v) {\n        if (v in map) return map[v];\n        //writeln(\"r: \", r, \"map: \", map, \" v: \", v);\n        auto ub = r.assumeSorted.upperBound(v);\n        if (ub.empty) return map[r.back];\n        else return map[ub.front];\n    }\n\n    int h(int[] r, int[int] map, int v) {\n        if (v in map) return map[v] + 1;\n        v--;\n        //writeln(\"r: \", r, \"map: \", map, \" v: \", v);\n        auto ub = r.assumeSorted.upperBound(v);\n        if (ub.empty) return map[r.back];\n        else return map[ub.front];\n    }\n\n    //[sY, sX].writeln;\n    foreach (i; 0 .. m) {\n        int sx, sy, gx, gy; readf(\"%d %d %d %d\\n\", &sx, &sy, &gx, &gy);\n        //write([sy, sx, gy, gx], \" -> \");\n        sx = g(sX, xM, sx);\n        sy = g(sY, yM, sy);\n        gx = h(sX, xM, gx);\n        gy = h(sY, yM, gy);\n        //writeln([sy, sx, gy, gx]);\n        writeln(f(sy, sx, gy, gx));\n    }\n\n    /*\n    foreach (_; F) _.writeln;\n    writeln;\n    foreach (_; G) _.writeln;\n    */\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.c.stdio;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.regex;\nimport std.typecons;\n\nint[int] C(int[] X) {\n    int[] Y = X.sort.uniq.array;\n    int[int] ret;\n    foreach (i; 0 .. cast(int)Y.length) {\n        ret[Y[i]] = i;\n    }\n    return ret;\n}\n\nvoid main() {\n    int n, m; readf(\"%d %d\\n\", &n, &m);\n    int[] X, Y;\n    foreach (i; 0 .. n) {\n        int x, y; readf(\"%d %d\\n\", &x, &y);\n        X ~= x;\n        Y ~= y;\n    }\n    int[] _X = X ~ [int.min, int.max],\n          _Y = Y ~ [int.min, int.max];\n    foreach (i; 0 .. n) {\n        _X ~= X[i] - 1;\n        _Y ~= Y[i] - 1;\n    }\n    int[int] xM = C(_X.dup);\n    int[int] yM = C(_Y.dup);\n    int[] sX = _X.dup.sort;\n    int[] sY = _Y.dup.sort;\n    auto nx = _X.length, ny = _Y.length;\n    auto F = new short[][](ny, nx);\n    auto G = new short[][](ny + 1, nx + 1);\n    foreach (i; 0 .. n) {\n        F[ yM[ Y[i] ] ][ xM[ X[i] ] ] += 1;\n    }\n    foreach (i; 1 .. ny + 1) {\n        short x = 0;\n        foreach (j; 1 .. nx + 1) {\n            x += F[i - 1][j - 1];\n            G[i][j] = cast(short)(G[i - 1][j] + x);\n        }\n    }\n\n    short f(int sy, int sx, int gy, int gx) {\n        return cast(short)(G[gy][gx] - G[sy][gx] - G[gy][sx] + G[sy][sx]);\n    }\n    \n    int g(int[] r, int[int] map, int v) {\n        //writeln(\"r: \", r, \"map: \", map, \" v: \", v);\n        auto ub = r.assumeSorted.upperBound(v);\n        if (ub.empty) return map[r.back];\n        else return map[ub.front];\n    }\n\n    //[sY, sX].writeln;\n    foreach (i; 0 .. m) {\n        int sx, sy, gx, gy; readf(\"%d %d %d %d\\n\", &sx, &sy, &gx, &gy);\n        //write([sy, sx, gy, gx], \" -> \");\n        sx = g(sX, xM, sx - 1);\n        sy = g(sY, yM, sy - 1);\n        gx = g(sX, xM, gx - 1) + 1;\n        gy = g(sY, yM, gy - 1) + 1;\n        //writeln([sy, sx, gy, gx]);\n        writeln(f(sy, sx, gy, gx));\n    }\n\n    /*\n    foreach (_; F) _.writeln;\n    writeln;\n    foreach (_; G) _.writeln;\n    */\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Ruiwa():\n    def __init__(self, a):\n        self.H = h = len(a)\n        self.W = w = len(a[0])\n        self.R = r = a\n        for i in range(h):\n            for j in range(1,w):\n                r[i][j] += r[i][j-1]\n\n        for i in range(1,h):\n            for j in range(w):\n                r[i][j] += r[i-1][j]\n\n    def search(self, x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n\n        r = self.R\n        rr = r[y2][x2]\n        if x1 > 0 and y1 > 0:\n            return rr - r[y1-1][x2] - r[y2][x1-1] + r[y1-1][x1-1]\n        if x1 > 0:\n            rr -= r[y2][x1-1]\n        if y1 > 0:\n            rr -= r[y1-1][x2]\n\n        return rr\n\ndef main():\n    n,m = LI()\n    na = [LI() for _ in range(n)]\n    xd = set()\n    yd = set()\n    for x,y in na:\n        xd.add(x)\n        yd.add(y)\n\n    xl = sorted(list(xd))\n    yl = sorted(list(yd))\n    xx = {}\n    yy = {}\n    for i in range(len(xl)):\n        xx[xl[i]] = i\n    for i in range(len(yl)):\n        yy[yl[i]] = i\n    a = [[0]*(len(yl)+1) for _ in range(len(xl)+1)]\n    for x,y in na:\n        a[xx[x]][yy[y]] += 1\n    rui = Ruiwa(a)\n    r = []\n    for _ in range(m):\n        x1,y1,x2,y2 = LI()\n        xx1 = bisect.bisect_left(xl, x1)\n        yy1 = bisect.bisect_left(yl, y1)\n        xx2 = bisect.bisect(xl, x2) - 1\n        yy2 = bisect.bisect(yl, y2) - 1\n        r.append(rui.search(yy1,xx1,yy2,xx2))\n\n\n    return '\\n'.join(map(str,r))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "\"\"\"\nAOJ 2426  Treasure Hunt\n\n\n座標圧縮を二次元でやるっぽい\n上の問題たちとちがうのは、ここからここまでが領域１です、みたいな形になっている点か。\nまた、例４をみると、ある領域の内側に小さな領域があるパターンもあり、小さいほうに入っている宝は両方に所属していることになるっぽい。\n\nさっぱりなので写経\nhttp://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=2963309#1\n\n二次元累積和がはじめてなので、そっちの練習がまず先に必要っぽい\n\"\"\"\n\nfrom bisect import bisect_left\n\ndef main():\n\n    N,M = map(int, input().split())\n    treasures = []\n\n    # 宝のx,yの位置（ある宝のx,yの組ではなく、x,y座標的にどこに位置するか）\n    Xs = set()\n    Ys = set()\n\n    for _ in range(N):\n        x,y = map(int, input().split())\n        treasures.append((x,y))\n        Xs.add(x)\n        Ys.add(y)\n\n\n    # x,yそれぞれで座圧\n    Xs = list(Xs)\n    Xs.sort()\n    Ys = list(Ys)\n    Ys.sort()\n    \n\n    # 座標xはO番目、みたいな情報を作る\n    Xd = {}\n    Yd = {}\n    for i,x in enumerate(Xs):\n        Xd[x] = i\n    for i,y in enumerate(Ys):\n        Yd[y] = i\n\n\n    lx = len(Xs)\n    ly = len(Ys)\n    # ここに宝があるよ、を座圧した情報にする\n    compressd_treasures = [[0 for _ in range(lx + 1)] for _ in range(ly + 1)]\n    for x,y in treasures:\n        # yyy番目のy座標とxxx番目のxxx座標に宝があるよ\n        compressd_treasures[Yd[y] + 1][Xd[x] + 1] += 1\n\n    # 左下から右上に向かって、「下や左から（南から？）進んできて何個宝があるか」の累積和をとる\n    # ここの操作後、comp~[y][x]で、（一番左下の座標（原点ではない））~(x,y)の長方形の中にある宝の数が得られるから、\n    # うまいことやると(x1,y1)~(x2,y2)の範囲の宝の数が得られる\n    for y in range(1, ly + 1):\n        acc = 0\n        for x in range(1, lx + 1):\n            # accに足しておいて、xが進むごとに左から右へも累積和をとれる\n            acc += compressd_treasures[y][x]\n            # 下の所から積み上げて累積和\n            compressd_treasures[y][x] = acc + compressd_treasures[y-1][x]\n\n    for _ in range(M):\n        x1, y1, x2, y2 = map(int, input().split())\n        # それぞれの座標について、何番目の宝まで含みうるか考える\n        idx_x1 = bisect_left(Xs, x1)\n        idx_x2 = bisect_left(Xs, x2)\n        idx_y1 = bisect_left(Ys, y1)\n        idx_y2 = bisect_left(Ys, y2)\n\n        # 宝が領域の境界線上にあるとき、加算する(bisectした値と同じものがXs,Ysにあるとき)\n        if idx_x2 < lx and Xs[idx_x2] == x2:\n            idx_x2 += 1\n        if idx_y2 < ly and Ys[idx_y2] == y2:\n            idx_y2 += 1\n        \n        # 累積和で出す。l~r = 0~r - 0~l-1　を二次元にしたバージョン\n        ans = compressd_treasures[idx_y2][idx_x2] - compressd_treasures[idx_y2][idx_x1] - compressd_treasures[idx_y1][idx_x2] + compressd_treasures[idx_y1][idx_x1]\n        print(ans)\n\n\nif __name__ ==\"__main__\":\n    main()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Ruiwa():\n    def __init__(self, a):\n        self.H = h = len(a)\n        self.W = w = len(a[0])\n        self.R = r = a\n        for i in range(h):\n            for j in range(1,w):\n                r[i][j] += r[i][j-1]\n\n        for i in range(1,h):\n            for j in range(w):\n                r[i][j] += r[i-1][j]\n\n    def search(self, x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n\n        r = self.R\n        rr = r[y2][x2]\n        if x1 > 0 and y1 > 0:\n            return rr - r[y1-1][x2] - r[y2][x1-1] + r[y1-1][x1-1]\n        if x1 > 0:\n            rr -= r[y2][x1-1]\n        if y1 > 0:\n            rr -= r[y1-1][x2]\n\n        return rr\n\ndef main():\n    n,m = LI()\n    na = [LI() for _ in range(n)]\n    xd = set()\n    yd = set()\n    for x,y in na:\n        xd.add(x)\n        yd.add(y)\n\n    xl = sorted(list(xd))\n    yl = sorted(list(yd))\n    xx = {}\n    yy = {}\n    for i in range(len(xl)):\n        xx[xl[i]] = i\n    for i in range(len(yl)):\n        yy[yl[i]] = i\n    a = [[0]*(len(yl)+1) for _ in range(len(xl)+1)]\n    for x,y in na:\n        a[xx[x]][yy[y]] += 1\n    rui = Ruiwa(a)\n    r = []\n    for x1,y1,x2,y2 in [LI() for _ in range(m)]:\n        xx1 = bisect.bisect_left(xl, x1)\n        yy1 = bisect.bisect_left(yl, y1)\n        xx2 = bisect.bisect(xl, x2) - 1\n        yy2 = bisect.bisect(yl, y2) - 1\n        r.append(rui.search(yy1,xx1,yy2,xx2))\n\n\n    return '\\n'.join(map(str,r))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "n,m = map(int,raw_input().split())\nxy = [map(int,raw_input().split()) for i in range(n)]\nfor i in range(m):\n\tx1,y1,x2,y2 = map(int,raw_input().split())\n\tprint sum(1 for x,y in xy if x1<=x<=x2 and y1<=y<=y2)"
  },
  {
    "language": "Python",
    "code": "import bisect\nn,m = map(int,raw_input().split())\nxy = sorted([map(int,raw_input().split()) + [i] for i in range(n)])\nyx = sorted(xy, key = lambda x:x[1])\nX = [i[0] for i in xy]\nY = [i[1] for i in yx]\nxy = [str(i[0]) + \",\" + str(i[1]) + \"_\" + str(i[2]) for i in xy]\nyx = [str(i[0]) + \",\" + str(i[1]) + \"_\" + str(i[2]) for i in yx]\nans = {}\nfor xi in range(n):\n\tfor xj in range(xi,n+1):\n\t\tfor yi in range(n):\n\t\t\tfor yj in range(yi,n+1):\n\t\t\t\tans[str(xi) + \"_\" +  str(xj) + \"_\" + str(yi) + \"_\" + str(yj)] = len(set(xy[xi:xj])&set(yx[yi:yj]))\nfor i in range(m):\n\tx1,y1,x2,y2 = map(int,raw_input().split())\n\tx1 = bisect.bisect_left(X,x1)\n\ty1 = bisect.bisect_left(Y,y1)\n\tx2 = bisect.bisect_right(X,x2)\n\ty2 = bisect.bisect_right(Y,y2)\n\ttry: print ans[str(x1) + \"_\" +  str(x2) + \"_\" + str(y1) + \"_\" + str(y2)]\n\texcept: print 0"
  },
  {
    "language": "Python",
    "code": "import bisect\nn,m = map(int,raw_input().split())\nxy = sorted([map(int,raw_input().split()) for i in range(n)])\nyx = sorted(xy, key = lambda x:x[1])\nX = [i[0] for i in xy]\nY = [i[1] for i in yx]\nxy = [str(i[0]) + \",\" + str(i[1]) for i in xy]\nyx = [str(i[0]) + \",\" + str(i[1]) for i in yx]\nfor i in range(m):\n\tx1,y1,x2,y2 = map(int,raw_input().split())\n\tx1 = bisect.bisect_left(X,x1)\n\ty1 = bisect.bisect_left(Y,y1)\n\tx2 = bisect.bisect_right(X,x2)\n\ty2 = bisect.bisect_right(Y,y2)\n\tprint len(set(xy[x1:x2])&set(yx[y1:y2]))"
  },
  {
    "language": "Python",
    "code": "import bisect\nn,m = map(int,raw_input().split())\nxy = sorted([map(int,raw_input().split()) + [i] for i in range(n)])\nyx = sorted(xy, key = lambda x:x[1])\nX = [i[0] for i in xy]\nY = [i[1] for i in yx]\nxy = [str(i[0]) + \",\" + str(i[1]) + \"_\" + str(i[2]) for i in xy]\nyx = [str(i[0]) + \",\" + str(i[1]) + \"_\" + str(i[2]) for i in yx]\nfor i in range(m):\n\tx1,y1,x2,y2 = map(int,raw_input().split())\n\tx1 = bisect.bisect_left(X,x1)\n\ty1 = bisect.bisect_left(Y,y1)\n\tx2 = bisect.bisect_right(X,x2)\n\ty2 = bisect.bisect_right(Y,y2)\n\tprint len(set(xy[x1:x2])&set(yx[y1:y2]))"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Ruiwa():\n    def __init__(self, a):\n        self.H = h = len(a)\n        self.W = w = len(a[0])\n        self.R = r = a\n        for i in range(h):\n            for j in range(1,w):\n                r[i][j] += r[i][j-1]\n\n        for i in range(1,h):\n            for j in range(w):\n                r[i][j] += r[i-1][j]\n\n    def search(self, x1, y1, x2, y2):\n        print(x1, y1, x2, y2)\n        if x1 > x2 or y1 > y2:\n            return 0\n\n        r = self.R\n        rr = r[y2][x2]\n        if x1 > 0 and y1 > 0:\n            return rr - r[y1-1][x2] - r[y2][x1-1] + r[y1-1][x1-1]\n        if x1 > 0:\n            rr -= r[y2][x1-1]\n        if y1 > 0:\n            rr -= r[y1-1][x2]\n\n        return rr\n\ndef main():\n    n,m = LI()\n    na = [LI() for _ in range(n)]\n    ma = [LI() for _ in range(m)]\n    xd = set()\n    yd = set()\n    for x,y in na:\n        xd.add(x)\n        yd.add(y)\n    for x1,y1,x2,y2 in ma:\n        xd.add(x1)\n        yd.add(y1)\n        xd.add(x2)\n        yd.add(y2)\n    xl = sorted(list(xd))\n    yl = sorted(list(yd))\n    xx = {}\n    yy = {}\n    for i in range(len(xl)):\n        xx[xl[i]] = i\n    for i in range(len(yl)):\n        yy[yl[i]] = i\n    a = [[0]*(len(yl)+1) for _ in range(len(xl)+1)]\n    for x,y in na:\n        a[xx[x]][yy[y]] += 1\n    rui = Ruiwa(a)\n    r = []\n    for x1,y1,x2,y2 in ma:\n        r.append(rui.search(yy[y1],xx[x1],yy[y2],xx[x2]))\n\n\n    return '\\n'.join(map(str,r))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\ninf = 1e10\nn,m = map(int,raw_input().split())\nxy = [map(int,raw_input().split()) for i in range(n)]\nX = sorted([i[0] for i in xy] + [-inf-1] + [inf+1])\nY = sorted([i[1] for i in xy] + [-inf-1] + [inf+1])\n\ns = [[0]*(n+10) for i in range(n+10)]\nfor i in range(n):\n\ta = bisect.bisect_left(X,xy[i][0])\n\tb = bisect.bisect_left(Y,xy[i][1])\n\ts[a][b] += 1\n\nfor i in range(n+2):\n\tfor j in range(n+2):\n\t\ts[i+1][j+1] += s[i+1][j] + s[i][j+1] - s[i][j]\n\nfor i in range(m):\n\tx1,y1,x2,y2 = map(int,raw_input().split())\n\tx1 = bisect.bisect_left(X,x1) - 1\n\ty1 = bisect.bisect_left(Y,y1) - 1\n\tx2 = bisect.bisect_left(X,x2+1) - 1\n\ty2 = bisect.bisect_left(Y,y2+1) - 1\n\tprint s[x2][y2] - s[x1][y2] - s[x2][y1] + s[x1][y1]"
  },
  {
    "language": "Python",
    "code": "from bisect import bisect_left as bl\ndef main():\n  n, m = map(int, input().split())\n  plst = []\n  xlst = set()\n  ylst = set()\n  for _ in range(n):\n    x, y = map(int, input().split())\n    plst.append((x, y))\n    xlst.add(x)\n    ylst.add(y)\n  \n  xlst = sorted(list(xlst))\n  ylst = sorted(list(ylst))\n  xdic = {}\n  ydic = {}\n  for i, x in enumerate(xlst):\n    xdic[x] = i\n  for i, y in enumerate(ylst):\n    ydic[y] = i\n  \n  xlen = len(xlst)\n  ylen = len(ylst)\n  mp = [[0] * (xlen + 1) for _ in range(ylen + 1)]\n  for x, y in plst:\n    mp[ydic[y] + 1][xdic[x] + 1] += 1\n  \n  for y in range(1, ylen + 1):\n    acc = 0\n    for x in range(1, xlen + 1):\n      acc += mp[y][x]\n      mp[y][x] = acc + mp[y - 1][x]\n  \n  for _ in range(m):\n    x1, y1, x2, y2 = map(int, input().split())\n    x1i = bl(xlst, x1)\n    y1i = bl(ylst, y1)\n    x2i = bl(xlst, x2)\n    y2i = bl(ylst, y2)\n    if x2i < xlen and xlst[x2i] == x2:\n      x2i += 1\n    if y2i < ylen and ylst[y2i] == y2:\n      y2i += 1\n    print(mp[y2i][x2i] - mp[y2i][x1i] - mp[y1i][x2i] + mp[y1i][x1i])\n\nmain()\n"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Ruiwa():\n    def __init__(self, a):\n        self.H = h = len(a)\n        self.W = w = len(a[0])\n        self.R = r = a\n        for i in range(h):\n            for j in range(1,w):\n                r[i][j] += r[i][j-1]\n\n        for i in range(1,h):\n            for j in range(w):\n                r[i][j] += r[i-1][j]\n\n    def search(self, x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n\n        r = self.R\n        rr = r[y2][x2]\n        if x1 > 0 and y1 > 0:\n            return rr - r[y1-1][x2] - r[y2][x1-1] + r[y1-1][x1-1]\n        if x1 > 0:\n            rr -= r[y2][x1-1]\n        if y1 > 0:\n            rr -= r[y1-1][x2]\n\n        return rr\n\ndef main():\n    n,m = LI()\n    na = [LI() for _ in range(n)]\n    ma = [LI() for _ in range(m)]\n    xd = set()\n    yd = set()\n    for x,y in na:\n        xd.add(x)\n        yd.add(y)\n    for x1,y1,x2,y2 in ma:\n        xd.add(x1)\n        yd.add(y1)\n        xd.add(x2)\n        yd.add(y2)\n    xl = sorted(list(xd))\n    yl = sorted(list(yd))\n    xx = {}\n    yy = {}\n    for i in range(len(xl)):\n        xx[xl[i]] = i\n    for i in range(len(yl)):\n        yy[yl[i]] = i\n    a = [[0]*(len(yl)+1) for _ in range(len(xl)+1)]\n    for x,y in na:\n        a[xx[x]][yy[y]] += 1\n    rui = Ruiwa(a)\n    r = []\n    for x1,y1,x2,y2 in ma:\n        r.append(rui.search(yy[y1],xx[x1],yy[y2],xx[x2]))\n\n\n    return '\\n'.join(map(str,r))\n\n\n\nprint(main())\n\n"
  },
  {
    "language": "Python",
    "code": "import bisect\nn,m = map(int,raw_input().split())\nxy = sorted([map(int,raw_input().split()) + [i] for i in range(n)])\nyx = sorted(xy, key = lambda x:x[1])\nX = [i[0] for i in xy]\nY = [i[1] for i in yx]\nxy = [str(i[0]) + \",\" + str(i[1]) + \"_\" + str(i[2]) for i in xy]\nyx = [str(i[0]) + \",\" + str(i[1]) + \"_\" + str(i[2]) for i in yx]\nans = [[[[0]*(n+1) for i in range(n+1)] for j in range(n+1)] for k in range(n+1)]\nfor xi in range(n):\n\tfor xj in range(xi,n+1):\n\t\tfor yi in range(n):\n\t\t\tfor yj in range(yi,n+1):\n\t\t\t\tans[xi][xj][yi][yj] = len(set(xy[xi:xj])&set(yx[yi:yj]))\nfor i in range(m):\n\tx1,y1,x2,y2 = map(int,raw_input().split())\n\tx1 = bisect.bisect_left(X,x1)\n\ty1 = bisect.bisect_left(Y,y1)\n\tx2 = bisect.bisect_right(X,x2)\n\ty2 = bisect.bisect_right(Y,y2)\n\tprint ans[x1][x2][y1][y2]"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nclass Ruiwa():\n    def __init__(self, a):\n        self.H = h = len(a)\n        self.W = w = len(a[0])\n        self.R = r = a\n        for i in range(h):\n            for j in range(1,w):\n                r[i][j] += r[i][j-1]\n\n        for i in range(1,h):\n            for j in range(w):\n                r[i][j] += r[i-1][j]\n\n    def search(self, x1, y1, x2, y2):\n        if x1 > x2 or y1 > y2:\n            return 0\n\n        r = self.R\n        rr = r[y2][x2]\n        if x1 > 0 and y1 > 0:\n            return rr - r[y1-1][x2] - r[y2][x1-1] + r[y1-1][x1-1]\n        if x1 > 0:\n            rr -= r[y2][x1-1]\n        if y1 > 0:\n            rr -= r[y1-1][x2]\n\n        return rr\n\ndef main():\n    n,m = LI()\n    na = [LI() for _ in range(n)]\n    xd = set()\n    yd = set()\n    for x,y in na:\n        xd.add(x)\n        yd.add(y)\n\n    xl = sorted(list(xd))\n    yl = sorted(list(yd))\n    xx = {}\n    yy = {}\n    for i in range(len(xl)):\n        xx[xl[i]] = i\n    for i in range(len(yl)):\n        yy[yl[i]] = i\n    a = [[0]*(len(yl)+1) for _ in range(len(xl)+1)]\n    for x,y in na:\n        a[xx[x]][yy[y]] += 1\n    rui = Ruiwa(a)\n    r = []\n    for _ in range(m):\n        x1,y1,x2,y2 = LI()\n        xx1 = bisect.bisect_left(xl, x1)\n        yy1 = bisect.bisect_left(yl, y1)\n        xx2 = bisect.bisect(xl, x2) - 1\n        yy2 = bisect.bisect(yl, y2) - 1\n        r.append(rui.search(yy1,xx1,yy2,xx2))\n\n\n    return '\\n'.join(map(str,r))\n\n\n\nprint(main())\n\n"
  }
]