[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Python",
    "code": "from collections import defaultdict\nimport math\n\ndef solve(N, M, passages):\n    # Build graph\n    graph = defaultdict(list)\n    for s, t in passages:\n        graph[s].append(t)\n    \n    # Memoization for dynamic programming\n    memo = {}\n    \n    def expected_passages(room):\n        # Reached the exit\n        if room == N:\n            return 0\n        \n        # Already computed\n        if room in memo:\n            return memo[room]\n        \n        # No outgoing passages\n        if not graph[room]:\n            return float('inf')\n        \n        # Expected passages is 1 + average of next rooms\n        exp = 1 + sum(expected_passages(next_room) for next_room in graph[room]) / len(graph[room])\n        memo[room] = exp\n        return exp\n    \n    # Try blocking each passage\n    min_expected = float('inf')\n    for block_s, block_t in passages:\n        # Create a copy of graph without blocked passage\n        blocked_graph = defaultdict(list, {k: v.copy() for k, v in graph.items()})\n        blocked_graph[block_s].remove(block_t)\n        \n        # Recalculate with blocked graph\n        memo.clear()\n        graph_bak = graph.copy()\n        graph.clear()\n        graph.update(blocked_graph)\n        \n        exp = expected_passages(1)\n        min_expected = min(min_expected, exp)\n        \n        # Restore original graph\n        graph.clear()\n        graph.update(graph_bak)\n    \n    # Do nothing option\n    exp = expected_passages(1)\n    min_expected = min(min_expected, exp)\n    \n    return min_expected\n\n# Read input\nN, M = map(int, input().split())\npassages = []\nfor _ in range(M):\n    s, t = map(int, input().split())\n    passages.append((s, t))\n\n# Print result\nprint(solve(N, M, passages))",
    "timestamp": "2025-08-05 17:33:03"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Python",
    "code": "import sys\nfrom collections import deque\n\ndef solve():\n    N, M = map(int, sys.stdin.readline().split())\n    adj = [[] for _ in range(N+1)]\n    rev_adj = [[] for _ in range(N+1)]\n    edges = []\n    for _ in range(M):\n        s, t = map(int, sys.stdin.readline().split())\n        adj[s].append(t)\n        rev_adj[t].append(s)\n        edges.append((s, t))\n    \n    # BFS to find critical nodes\n    reachable_from_1 = [False] * (N+1)\n    q = deque([1])\n    reachable_from_1[1] = True\n    while q:\n        u = q.popleft()\n        for v in adj[u]:\n            if not reachable_from_1[v]:\n                reachable_from_1[v] = True\n                q.append(v)\n    \n    reachable_to_N = [False] * (N+1)\n    q = deque([N])\n    reachable_to_N[N] = True\n    while q:\n        u = q.popleft()\n        for v in rev_adj[u]:\n            if not reachable_to_N[v]:\n                reachable_to_N[v] = True\n                q.append(v)\n    \n    critical_edges = []\n    for s, t in edges:\n        if reachable_from_1[s] and reachable_to_N[t]:\n            critical_edges.append((s, t))\n    \n    # Build adjacency list for critical graph\n    crit_adj = [[] for _ in range(N+1)]\n    for s, t in critical_edges:\n        crit_adj[s].append(t)\n    \n    # Compute E without blocking any edge\n    E = [0.0] * (N+1)\n    for u in range(N-1, 0, -1):\n        if not crit_adj[u]:\n            continue\n        sum_e = 0.0\n        for v in crit_adj[u]:\n            sum_e += E[v]\n        k = len(crit_adj[u])\n        E[u] = 1.0 + sum_e / k\n    \n    if not critical_edges:\n        print(0.0)\n        return\n    \n    # Check edges on the path from 1 to N\n    min_E = E[1]\n    \n    # Now, for each node u, find the edge u->v that when removed, maximizes (sum E[v'] - E[v])/k where k is the original degree\n    # So for each node u, find the v in crit_adj[u] with maximum E[v]\n    # Then, for each u, compute the new E if that edge is removed\n    \n    # We need to process nodes in reverse order\n    opt_E = [0.0] * (N+1)\n    best_u = -1\n    best_v = -1\n    max_reduction = 0.0\n    \n    # We need to find the edge (u, v) in critical edges where u's degree > 1, and E[v] is maximum\n    # Then, removing it would lead to the minimal E[1]\n    \n    for s, t in critical_edges:\n        u = s\n        if len(crit_adj[u]) <= 1:\n            continue\n        # Find the maximum E[v] in crit_adj[u]\n        max_e = -1.0\n        for v in crit_adj[u]:\n            if E[v] > max_e:\n                max_e = E[v]\n        # Compute the original E[u] = 1 + sum(E[v]) / k\n        k = len(crit_adj[u])\n        original_sum = sum(E[v] for v in crit_adj[u])\n        original_Eu = 1.0 + original_sum / k\n        # Compute new E[u] after removing the max E[v]\n        new_sum = original_sum - max_e\n        new_Eu = 1.0 + new_sum / (k - 1)\n        # The reduction is original_Eu - new_Eu , but we need to see how this propagates\n        # However, since we need the overall effect on E[1], we need to recompute E for all nodes after removing this edge\n        # It's not feasible to recompute for each edge, so we need to find the edge that has the highest impact\n        # So, we approximate by considering the immediate reduction in E[u]\n        reduction = original_Eu - new_Eu\n        if reduction > max_reduction:\n            max_reduction = reduction\n            best_u = u\n            best_v_tmp = -1\n            max_e_tmp = -1.0\n            for v in crit_adj[u]:\n                if E[v] > max_e_tmp:\n                    max_e_tmp = E[v]\n                    best_v_tmp = v\n            best_v = best_v_tmp\n    \n    if best_u == -1:\n        print(\"{0:.10f}\".format(E[1]))\n        return\n    \n    # Now, compute E with the best edge (best_u -> best_v) removed\n    # Create a new adjacency list where the edge best_u -> best_v is removed\n    new_adj = [[] for _ in range(N+1)]\n    for s, t in critical_edges:\n        if s == best_u and t == best_v:\n            continue\n        new_adj[s].append(t)\n    \n    new_E = [0.0] * (N+1)\n    for u in range(N-1, 0, -1):\n        if not new_adj[u]:\n            continue\n        sum_e = 0.0\n        for v in new_adj[u]:\n            sum_e += new_E[v]\n        k = len(new_adj[u])\n        new_E[u] = 1.0 + sum_e / k\n    \n    print(\"{0:.10f}\".format(new_E[1]))\n\nsolve()",
    "timestamp": "2025-08-05 17:34:23"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def minimize_expected_passages(N, M, passages):\n    import collections\n    import numpy as np\n\n    graph = collections.defaultdict(list)\n    for s, t in passages:\n        graph[s].append(t)\n\n    E = np.full(N + 1, float('inf'))\n    E[N] = 0\n\n    for v in range(N - 1, 0, -1):\n        E[v] = sum((1 + E[nxt]) / len(graph[v]) for nxt in graph[v])\n\n    min_expected = E[1]\n\n    for i, (s_i, t_i) in enumerate(passages):\n        if s_i == 1:\n            blocked_graph = collections.defaultdict(list)\n            for j, (s, t) in enumerate(passages):\n                if i != j:\n                    blocked_graph[s].append(t)\n\n            blocked_E = np.full(N + 1, float('inf'))\n            blocked_E[N] = 0\n\n            for v in range(N - 1, 0, -1):\n                blocked_E[v] = sum((1 + blocked_E[nxt]) / len(blocked_graph[v]) for nxt in blocked_graph[v])\n\n            min_expected = min(min_expected, blocked_E[1])\n\n    return min_expected\n\nif __name__ == \"__main__\":\n    import sys\n    input = sys.stdin.read\n\n    data = input().split()\n    N = int(data[0])\n    M = int(data[1])\n\n    passages = [(int(data[i * 2 + 2]), int(data[i * 2 + 3])) for i in range(M)]\n\n    result = minimize_expected_passages(N, M, passages)\n\n    print(f\"{result:.10f}\")",
    "timestamp": "2025-08-12 21:54:58"
  }
]