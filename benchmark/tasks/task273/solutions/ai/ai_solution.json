[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define MAX_LINE_LENGTH 1024\n\ntypedef struct {\n    int indent;\n    int is_ambiguous;\n} LineIndent;\n\nvoid process_program(FILE *file, LineIndent *indents, int *count) {\n    char line[MAX_LINE_LENGTH];\n    int current_indent = 0;\n    *count = 0;\n\n    while (fgets(line, MAX_LINE_LENGTH, file)) {\n        int i = 0;\n        while (line[i] == ' ') i++;\n        indents[*count].indent = i;\n        indents[*count].is_ambiguous = 0;\n        (*count)++;\n\n        for (int j = 0; line[j]; j++) {\n            if (line[j] == '(' || line[j] == '{' || line[j] == '[') {\n                current_indent++;\n            } else if (line[j] == ')' || line[j] == '}' || line[j] == ']') {\n                current_indent--;\n            }\n        }\n    }\n}\n\nvoid apply_indentation(FILE *ref_file, FILE *target_file, LineIndent *ref_indents, int ref_count) {\n    char line[MAX_LINE_LENGTH];\n    int current_indent = 0;\n    int line_num = 0;\n    LineIndent target_indents[MAX_LINE_LENGTH];\n    int target_count = 0;\n\n    while (fgets(line, MAX_LINE_LENGTH, target_file)) {\n        int i = 0;\n        while (line[i] == ' ') i++;\n        target_indents[target_count].indent = i;\n        target_indents[target_count].is_ambiguous = 0;\n        target_count++;\n\n        for (int j = 0; line[j]; j++) {\n            if (line[j] == '(' || line[j] == '{' || line[j] == '[') {\n                current_indent++;\n            } else if (line[j] == ')' || line[j] == '}' || line[j] == ']') {\n                current_indent--;\n            }\n        }\n    }\n\n    rewind(target_file);\n    for (int i = 0; i < target_count; i++) {\n        if (i >= ref_count) {\n            printf(\"-1\\n\");\n            continue;\n        }\n\n        if (ref_indents[i].is_ambiguous) {\n            printf(\"-1\\n\");\n        } else {\n            printf(\"%d\\n\", ref_indents[i].indent);\n        }\n    }\n}\n\nint main(int argc, char *argv[]) {\n    if (argc != 3) {\n        fprintf(stderr, \"Usage: %s <reference_file> <target_file>\\n\", argv[0]);\n        return 1;\n    }\n\n    FILE *ref_file = fopen(argv[1], \"r\");\n    if (!ref_file) {\n        perror(\"Failed to open reference file\");\n        return 1;\n    }\n\n    FILE *target_file = fopen(argv[2], \"r\");\n    if (!target_file) {\n        perror(\"Failed to open target file\");\n        fclose(ref_file);\n        return 1;\n    }\n\n    LineIndent ref_indents[MAX_LINE_LENGTH];\n    int ref_count;\n    process_program(ref_file, ref_indents, &ref_count);\n\n    apply_indentation(ref_file, target_file, ref_indents, ref_count);\n\n    fclose(ref_file);\n    fclose(target_file);\n    return 0;\n}",
    "timestamp": "2025-08-05 20:51:30"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <map>\n#include <sstream>\n#include <algorithm>\n\nusing namespace std;\n\nvector<int> computeIndents(const vector<string>& lines) {\n    vector<int> indents;\n    stack<char> groups;\n    map<char, char> match = {{'(', ')'}, {'{', '}'}, {'[', ']'}, {')', '('}, {'}', '{'}, {']', '['}};\n    \n    for (const string& line : lines) {\n        int indent = groups.size();\n        indents.push_back(indent);\n        \n        for (char c : line) {\n            if (c == '(' || c == '{' || c == '[') {\n                groups.push(c);\n            } else if (c == ')' || c == '}' || c == ']') {\n                if (groups.empty() || groups.top() != match[c]) {\n                    return {-1};\n                }\n                groups.pop();\n            }\n        }\n    }\n    \n    if (!groups.empty()) {\n        return {-1};\n    }\n    \n    return indents;\n}\n\nvector<int> applyIndents(const vector<string>& lines, const vector<int>& refIndents) {\n    vector<int> newIndents;\n    stack<char> groups;\n    map<char, char> match = {{'(', ')'}, {'{', '}'}, {'[', ']'}, {')', '('}, {'}', '{'}, {']', '['}};\n    \n    for (const string& line : lines) {\n        int indent = -1;\n        if (groups.size() < refIndents.size()) {\n            indent = refIndents[groups.size()];\n        }\n        newIndents.push_back(indent);\n        \n        for (char c : line) {\n            if (c == '(' || c == '{' || c == '[') {\n                groups.push(c);\n            } else if (c == ')' || c == '}' || c == ']') {\n                if (groups.empty() || groups.top() != match[c]) {\n                    return {-1};\n                }\n                groups.pop();\n            }\n        }\n    }\n    \n    if (!groups.empty()) {\n        return {-1};\n    }\n    \n    return newIndents;\n}\n\nint main() {\n    vector<string> refLines;\n    vector<string> newLines;\n    string line;\n    \n    while (getline(cin, line) && !line.empty()) {\n        refLines.push_back(line);\n    }\n    \n    while (getline(cin, line)) {\n        newLines.push_back(line);\n    }\n    \n    vector<int> refIndents = computeIndents(refLines);\n    if (!refIndents.empty() && refIndents[0] == -1) {\n        cout << -1 << endl;\n        return 0;\n    }\n    \n    vector<int> newIndents = applyIndents(newLines, refIndents);\n    for (int indent : newIndents) {\n        cout << indent << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 20:52:42"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\n\npublic class StylishIndentation {\n    public static void main(String[] args) throws IOException {\n        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n        List<String> styleLines = new ArrayList<>();\n        List<String> programLines = new ArrayList<>();\n        \n        String line;\n        while ((line = br.readLine()) != null && !line.isEmpty()) {\n            styleLines.add(line);\n        }\n        while ((line = br.readLine()) != null) {\n            programLines.add(line);\n        }\n        \n        List<Integer> styleIndents = getIndents(styleLines);\n        List<Integer> programIndents = getIndents(programLines);\n        \n        if (styleIndents.size() != programIndents.size()) {\n            System.out.println(-1);\n            return;\n        }\n        \n        Map<Integer, Integer> indentMap = new HashMap<>();\n        for (int i = 0; i < styleIndents.size(); i++) {\n            int styleIndent = styleIndents.get(i);\n            int programIndent = programIndents.get(i);\n            indentMap.put(programIndent, styleIndent);\n        }\n        \n        for (int i = 0; i < programLines.size(); i++) {\n            String programLine = programLines.get(i);\n            int originalIndent = countLeadingSpaces(programLine);\n            if (indentMap.containsKey(originalIndent)) {\n                int newIndent = indentMap.get(originalIndent);\n                String trimmed = programLine.trim();\n                StringBuilder sb = new StringBuilder();\n                for (int j = 0; j < newIndent; j++) {\n                    sb.append(' ');\n                }\n                sb.append(trimmed);\n                System.out.println(sb.toString());\n            } else {\n                System.out.println(-1);\n            }\n        }\n    }\n    \n    private static List<Integer> getIndents(List<String> lines) {\n        List<Integer> indents = new ArrayList<>();\n        Stack<Character> stack = new Stack<>();\n        \n        for (String line : lines) {\n            String trimmed = line.trim();\n            int leadingSpaces = countLeadingSpaces(line);\n            indents.add(leadingSpaces);\n            \n            for (char c : trimmed.toCharArray()) {\n                if (c == '(' || c == '{' || c == '[') {\n                    stack.push(c);\n                } else if (c == ')' || c == '}' || c == ']') {\n                    if (stack.isEmpty()) {\n                        indents.clear();\n                        return indents;\n                    }\n                    char top = stack.pop();\n                    if ((c == ')' && top != '(') || (c == '}' && top != '{') || (c == ']' && top != '[')) {\n                        indents.clear();\n                        return indents;\n                    }\n                }\n            }\n        }\n        \n        if (!stack.isEmpty()) {\n            indents.clear();\n        }\n        return indents;\n    }\n    \n    private static int countLeadingSpaces(String line) {\n        int count = 0;\n        for (char c : line.toCharArray()) {\n            if (c == ' ') {\n                count++;\n            } else {\n                break;\n            }\n        }\n        return count;\n    }\n}",
    "timestamp": "2025-08-05 20:53:10"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class StyleTransfer {\n    public static List<Integer> transferStyle(String p1, String p2) {\n        List<Integer> indents1 = getIndentations(p1);\n        List<Integer> indents2 = getIndentations(p2);\n        \n        if (indents1 == null || indents2 == null) \n            return null;\n        \n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < indents2.size(); i++) {\n            result.add(indents1.get(indents1.indexOf(indents2.get(i))));\n        }\n        \n        return result;\n    }\n    \n    private static List<Integer> getIndentations(String prog) {\n        String[] lines = prog.split(\"\\n\");\n        List<Integer> indents = new ArrayList<>();\n        Stack<Character> symbols = new Stack<>();\n        \n        for (String line : lines) {\n            String trimmed = line.trim();\n            if (trimmed.isEmpty()) {\n                indents.add(0);\n                continue;\n            }\n            \n            int indent = 0;\n            int ambiguity = 0;\n            \n            for (char c : trimmed.toCharArray()) {\n                if (c == '(' || c == '[' || c == '{') {\n                    symbols.push(c);\n                    indent++;\n                } else if (c == ')' || c == ']' || c == '}') {\n                    if (symbols.isEmpty() || \n                        !isMatchingSymbol(symbols.peek(), c)) {\n                        return null;\n                    }\n                    symbols.pop();\n                    indent--;\n                }\n            }\n            \n            if (!symbols.isEmpty()) {\n                ambiguity = symbols.size();\n            }\n            \n            if (ambiguity > 0) {\n                indents.add(-1);\n            } else {\n                indents.add(indent);\n            }\n        }\n        \n        return indents;\n    }\n    \n    private static boolean isMatchingSymbol(char open, char close) {\n        return (open == '(' && close == ')') ||\n               (open == '[' && close == ']') ||\n               (open == '{' && close == '}');\n    }\n}",
    "timestamp": "2025-08-05 20:53:18"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_LENGTH 1001\n\nint calculate_indent(char* line) {\n    int depth = 0;\n    for (int i = 0; line[i]; i++) {\n        if (line[i] == '(' || line[i] == '{' || line[i] == '[') depth++;\n        if (line[i] == ')' || line[i] == '}' || line[i] == ']') depth--;\n    }\n    return depth;\n}\n\nbool is_valid_line(char* line) {\n    int open_count[3] = {0};\n    for (int i = 0; line[i]; i++) {\n        if (line[i] == '(') open_count[0]++;\n        if (line[i] == '{') open_count[1]++;\n        if (line[i] == '[') open_count[2]++;\n        if (line[i] == ')') open_count[0]--;\n        if (line[i] == '}') open_count[1]--;\n        if (line[i] == ']') open_count[2]--;\n        \n        if (open_count[0] < 0 || open_count[1] < 0 || open_count[2] < 0) return false;\n    }\n    \n    return open_count[0] == 0 && open_count[1] == 0 && open_count[2] == 0;\n}\n\nint main() {\n    char reference[MAX_LENGTH][MAX_LENGTH];\n    char program[MAX_LENGTH][MAX_LENGTH];\n    int ref_lines, prog_lines;\n    int indentation[MAX_LENGTH];\n\n    scanf(\"%d\", &ref_lines);\n    for (int i = 0; i < ref_lines; i++) {\n        scanf(\"%s\", reference[i]);\n    }\n\n    scanf(\"%d\", &prog_lines);\n    for (int i = 0; i < prog_lines; i++) {\n        scanf(\"%s\", program[i]);\n    }\n\n    for (int i = 0; i < prog_lines; i++) {\n        if (!is_valid_line(program[i])) {\n            indentation[i] = -1;\n            continue;\n        }\n\n        bool found_match = false;\n        for (int j = 0; j < ref_lines; j++) {\n            if (strlen(program[i]) == strlen(reference[j]) && \n                strcmp(program[i], reference[j]) == 0) {\n                indentation[i] = calculate_indent(reference[j]);\n                found_match = true;\n                break;\n            }\n        }\n\n        if (!found_match) {\n            int possible_indent = -1;\n            int match_count = 0;\n            for (int j = 0; j < ref_lines; j++) {\n                if (is_valid_line(reference[j])) {\n                    int curr_indent = calculate_indent(reference[j]);\n                    if (possible_indent == -1 || possible_indent == curr_indent) {\n                        possible_indent = curr_indent;\n                        match_count++;\n                    } else {\n                        match_count = -1;\n                        break;\n                    }\n                }\n            }\n\n            indentation[i] = (match_count == 1) ? possible_indent : -1;\n        }\n    }\n\n    for (int i = 0; i < prog_lines; i++) {\n        printf(\"%d\\n\", indentation[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:30"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <sstream>\n#include <map>\n#include <set>\n\nusing namespace std;\n\nvector<int> determineIndentation(const vector<string>& referenceProgram) {\n    vector<int> indentLevels(referenceProgram.size(), 0);\n    int currentIndent = 0;\n    map<char, int> openSymbolCount;\n    set<char> openSymbols = {'(', '[', '{'};\n    set<char> closeSymbols = {')', ']', '}'};\n    map<char, char> matchingSymbol = {\n        {')', '('}, {']', '['}, {'}', '{'}\n    };\n\n    for (int i = 0; i < referenceProgram.size(); i++) {\n        string line = referenceProgram[i];\n        indentLevels[i] = currentIndent;\n\n        for (char c : line) {\n            if (openSymbols.count(c)) {\n                openSymbolCount[c]++;\n                currentIndent++;\n            }\n            if (closeSymbols.count(c)) {\n                char matching = matchingSymbol[c];\n                if (openSymbolCount[matching] > 0) {\n                    openSymbolCount[matching]--;\n                    currentIndent--;\n                }\n            }\n        }\n    }\n\n    return indentLevels;\n}\n\nvector<int> applyIndentation(const vector<string>& programToIndent, const vector<int>& referenceIndents) {\n    vector<int> indentLevels(programToIndent.size(), -1);\n    int currentIndent = 0;\n    map<char, int> openSymbolCount;\n    set<char> openSymbols = {'(', '[', '{'};\n    set<char> closeSymbols = {')', ']', '}'};\n    map<char, char> matchingSymbol = {\n        {')', '('}, {']', '['}, {'}', '{'}\n    };\n\n    map<int, int> indentCounts;\n    for (int indent : referenceIndents) {\n        indentCounts[indent]++;\n    }\n\n    for (int i = 0; i < programToIndent.size(); i++) {\n        string line = programToIndent[i];\n        int potentialIndent = -1;\n\n        for (const auto& count : indentCounts) {\n            if (potentialIndent == -1) {\n                potentialIndent = count.first;\n            } else if (potentialIndent != count.first) {\n                potentialIndent = -1;\n                break;\n            }\n        }\n\n        if (potentialIndent != -1) {\n            indentLevels[i] = potentialIndent;\n        }\n\n        for (char c : line) {\n            if (openSymbols.count(c)) {\n                openSymbolCount[c]++;\n                currentIndent++;\n            }\n            if (closeSymbols.count(c)) {\n                char matching = matchingSymbol[c];\n                if (openSymbolCount[matching] > 0) {\n                    openSymbolCount[matching]--;\n                    currentIndent--;\n                }\n            }\n        }\n    }\n\n    return indentLevels;\n}\n\nint main() {\n    int N, M;\n    cin >> N >> M;\n    cin.ignore();\n\n    vector<string> referenceProgram(N);\n    for (int i = 0; i < N; i++) {\n        getline(cin, referenceProgram[i]);\n    }\n\n    vector<string> programToIndent(M);\n    for (int i = 0; i < M; i++) {\n        getline(cin, programToIndent[i]);\n    }\n\n    vector<int> referenceIndents = determineIndentation(referenceProgram);\n    vector<int> result = applyIndentation(programToIndent, referenceIndents);\n\n    for (int indent : result) {\n        cout << indent << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 20:53:43"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def parse_program(program):\n    indentation_rules = {}\n    current_indent = []\n    indent_level = 0\n\n    for line in program:\n        clean_line = line.strip()\n        open_braces = clean_line.count('{')\n        close_braces = clean_line.count('}')\n\n        # Calculate net change in braces\n        net_braces = open_braces - close_braces\n\n        # Store the current indentation level based on brace count\n        if net_braces not in indentation_rules:\n            indentation_rules[net_braces] = indent_level\n\n        # Update indent level for next line\n        indent_level += net_braces\n\n        # Save current line's indentation depth\n        current_indent.append(indent_level)\n\n    return indentation_rules\n\ndef apply_indentation_rules(rules, program):\n    result_indents = []\n\n    for line in program:\n        clean_line = line.strip()\n        open_braces = clean_line.count('{')\n        close_braces = clean_line.count('}')\n        net_braces = open_braces - close_braces\n        \n        # Determine the base indentation\n        if net_braces in rules:\n            base_indent = rules[net_braces]\n            result_indents.append(base_indent)\n        else:\n            # If the rule is not uniquely determined\n            result_indents.append(-1)\n\n    return result_indents\n\ndef stylish_indentation(program1, program2):\n    rules = parse_program(program1)\n    return apply_indentation_rules(rules, program2)\n\n# Example Usage:\nprogram1 = [\n    \"{\",\n    \"    int x = 0;\",\n    \"    {\",\n    \"        x++;\",\n    \"    }\",\n    \"}\"\n]\n\nprogram2 = [\n    \"{\",\n    \"0;\",\n    \"{{0;}}\",\n    \"{0;}\",\n    \"}\"\n]\n\nindents = stylish_indentation(program1, program2)\nfor indent in indents:\n    print(indent)",
    "timestamp": "2025-08-13 03:55:37"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class StylishIndentation {\n    static int[] analyzeIndentation(String[] program) {\n        int braceCount = 0, parenCount = 0, bracketCount = 0;\n        int L = 0, R = 0, C = 0;\n        TreeMap<Integer, Integer> indentationMap = new TreeMap<>();\n        \n        for (String line : program) {\n            int expectedIndent = countLeadingPeriods(line);\n            int[] symbols = countSymbols(line);\n            \n            if (!indentationMap.containsKey(L * braceCount + R * parenCount + C * bracketCount)) {\n                indentationMap.put(L * braceCount + R * parenCount + C * bracketCount, expectedIndent);\n            }\n            \n            braceCount = symbols[0];\n            parenCount = symbols[1];\n            bracketCount = symbols[2];\n        }\n        \n        Set<Integer> keys = indentationMap.keySet();\n        if (keys.size() > 1) {\n            Iterator<Integer> iter = keys.iterator();\n            int firstKey = iter.next();\n            int secondKey = iter.next();\n            \n            if (secondKey - firstKey != 0) {\n                int indentDiff = indentationMap.get(secondKey) - indentationMap.get(firstKey);\n                if ((secondKey - firstKey) != 0) {\n                    L = indentDiff / (secondKey - firstKey);\n                    R = indentDiff / (secondKey - firstKey);\n                    C = indentDiff / (secondKey - firstKey);\n                }\n            }\n        }\n        \n        return new int[]{L, R, C};\n    }\n    \n    static int countLeadingPeriods(String line) {\n        int count = 0;\n        for (char ch : line.toCharArray()) {\n            if (ch != '.') break;\n            count++;\n        }\n        return count;\n    }\n    \n    static int[] countSymbols(String line) {\n        int braceCount = 0, parenCount = 0, bracketCount = 0;\n        for (char ch : line.toCharArray()) {\n            if (ch == '{') braceCount++;\n            if (ch == '}') braceCount--;\n            if (ch == '(') parenCount++;\n            if (ch == ')') parenCount--;\n            if (ch == '[') bracketCount++;\n            if (ch == ']') bracketCount--;\n        }\n        return new int[]{braceCount, parenCount, bracketCount};\n    }\n\n    static void applyIndentation(String[] program, int[] rules) {\n        int braceCount = 0, parenCount = 0, bracketCount = 0;\n        \n        for (String line : program) {\n            int indent = rules[0] * braceCount + rules[1] * parenCount + rules[2] * bracketCount;\n            if (indent < 0) indent = -1;\n            System.out.println(indent);\n            \n            int[] symbols = countSymbols(line);\n            braceCount += symbols[0];\n            parenCount += symbols[1];\n            bracketCount += symbols[2];\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        int P = sc.nextInt();\n        int Q = sc.nextInt();\n        sc.nextLine();\n        \n        String[] firstProgram = new String[P];\n        String[] secondProgram = new String[Q];\n        \n        for (int i = 0; i < P; i++) {\n            firstProgram[i] = sc.nextLine();\n        }\n        for (int i = 0; i < Q; i++) {\n            secondProgram[i] = sc.nextLine();\n        }\n        \n        int[] rules = analyzeIndentation(firstProgram);\n        applyIndentation(secondProgram, rules);\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-13 03:55:44"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <string.h>\n\n#define MAX_LINES 100\n#define MAX_LENGTH 1000\n\ntypedef struct {\n    int r, c, s; // Count of (, {, [\n} IndentationStyle;\n\nIndentationStyle currentStyle = {0, 0, 0};\nint indentationLevels[MAX_LINES];\n\n// Function to count grouping symbols in a line\nvoid countSymbols(const char* line, int *r, int *c, int *s) {\n    int len = strlen(line);\n    *r = *c = *s = 0;\n    for (int i = 0; i < len; ++i) {\n        if (line[i] == '(') (*r)++;\n        if (line[i] == ')') (*r)--;\n        if (line[i] == '{') (*c)++;\n        if (line[i] == '}') (*c)--;\n        if (line[i] == '[') (*s)++;\n        if (line[i] == ']') (*s)--;\n    }\n}\n\n// Function to compute indentation levels for second program\nvoid applyIndentation(int lineCount2, char program2[MAX_LINES][MAX_LENGTH], IndentationStyle knownStyle) {\n    int r, c, s, prevR = 0, prevC = 0, prevS = 0, indent = 0;\n    for (int i = 0; i < lineCount2; ++i) {\n        countSymbols(program2[i], &r, &c, &s);\n\n        indent += knownStyle.r * prevR + knownStyle.c * prevC + knownStyle.s * prevS;\n\n        // If indentation can't be uniquely determined, output -1\n        if (knownStyle.r * r + knownStyle.c * c + knownStyle.s * s != indent) {\n            indentationLevels[i] = -1;\n        } else {\n            indentationLevels[i] = indent;\n        }\n        \n        prevR = r;\n        prevC = c;\n        prevS = s;\n    }\n}\n\n// Sample main function\nint main() {\n    char program1[MAX_LINES][MAX_LENGTH];\n    char program2[MAX_LINES][MAX_LENGTH];\n    int lineCount1, lineCount2;\n    \n    // Read first program (assuming input is given correctly)\n    lineCount1 = 0;\n    while (fgets(program1[lineCount1], MAX_LENGTH, stdin) && program1[lineCount1][0] != '\\n') {\n        lineCount1++;\n    }\n\n    // Read second program (assuming input is given correctly)\n    lineCount2 = 0;\n    while (fgets(program2[lineCount2], MAX_LENGTH, stdin) && program2[lineCount2][0] != '\\n') {\n        lineCount2++;\n    }\n\n    // Analyze the first program to determine the indentation style\n    // You should replace this with actual logic to determine knownStyle\n    IndentationStyle knownStyle = {2, 4, 2}; // Placeholder values\n\n    // Apply indentation to the second program\n    applyIndentation(lineCount2, program2, knownStyle);\n\n    // Output indentation levels for the second program\n    for(int i = 0; i < lineCount2; ++i) {\n        printf(\"%d\\n\", indentationLevels[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 03:55:57"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def stylish_indentation(prog1, prog2):\n    def parse_indentation(prog):\n        lines = prog.split('\\n')\n        indents = [0] * len(lines)\n        stack = []\n        curr_indent = 0\n        \n        for i, line in enumerate(lines):\n            line = line.strip()\n            if not line:\n                continue\n            \n            open_count = line.count('(') + line.count('[') + line.count('{')\n            close_count = line.count(')') + line.count(']') + line.count('}')\n            \n            for char in line:\n                if char in '([{':\n                    stack.append(char)\n                    curr_indent += 1\n                elif char in ')]}':\n                    if not stack or not matches(stack[-1], char):\n                        return None\n                    stack.pop()\n                    curr_indent -= 1\n            \n            indents[i] = max(0, curr_indent - close_count)\n        \n        return indents\n    \n    def matches(open_sym, close_sym):\n        return (open_sym == '(' and close_sym == ')') or \\\n               (open_sym == '[' and close_sym == ']') or \\\n               (open_sym == '{' and close_sym == '}')\n    \n    prog1_indents = parse_indentation(prog1)\n    if prog1_indents is None:\n        return [-1] * len(prog2.split('\\n'))\n    \n    lines2 = prog2.split('\\n')\n    result = []\n    \n    for line in lines2:\n        line = line.strip()\n        if not line:\n            result.append(0)\n            continue\n        \n        open_count = line.count('(') + line.count('[') + line.count('{')\n        close_count = line.count(')') + line.count(']') + line.count('}')\n        \n        possible_indents = []\n        for i, base_indent in enumerate(prog1_indents):\n            stack = []\n            curr_indent = base_indent\n            \n            for char in prog1.split('\\n')[i].strip():\n                if char in '([{':\n                    stack.append(char)\n                    curr_indent += 1\n                elif char in ')]}':\n                    if not stack or not matches(stack[-1], char):\n                        break\n                    stack.pop()\n                    curr_indent -= 1\n            \n            if not stack and curr_indent - close_count >= 0:\n                possible_indents.append(curr_indent - close_count)\n        \n        if len(set(possible_indents)) == 1:\n            result.append(possible_indents[0])\n        else:\n            result.append(-1)\n    \n    return result",
    "timestamp": "2025-08-13 03:56:10"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef parse_indent_rules(well_indented):\n    indent_rules = []\n    stack = []\n    for line in well_indented:\n        stripped = line.lstrip()\n        leading_spaces = len(line) - len(stripped)\n        # Count the number of opening and closing symbols in the line\n        open_symbols = stripped.count('(') + stripped.count('{') + stripped.count('[')\n        close_symbols = stripped.count(')') + stripped.count('}') + stripped.count(']')\n        # Determine the net change in the stack\n        net = open_symbols - close_symbols\n        # The current line's indentation is determined by the stack size before processing the line\n        if stack:\n            expected_indent = len(stack) * 2  # Assuming 2 spaces per level\n            if leading_spaces != expected_indent:\n                return None  # Inconsistent indentation in the well-indented program\n        # Update the stack\n        if net > 0:\n            stack.extend(['('] * net)\n        elif net < 0:\n            for _ in range(-net):\n                if not stack:\n                    return None  # Mismatched symbols\n                stack.pop()\n        # Record the rule: (net, stack size after processing)\n        indent_rules.append((net, len(stack)))\n    return indent_rules\n\ndef apply_indent_rules(target, indent_rules):\n    if len(target) != len(indent_rules):\n        return [-1] * len(target)\n    result = []\n    stack = []\n    for i in range(len(target)):\n        line = target[i]\n        stripped = line.lstrip()\n        net, expected_stack_size = indent_rules[i]\n        # Update the stack based on net\n        if net > 0:\n            stack.extend(['('] * net)\n        elif net < 0:\n            for _ in range(-net):\n                if not stack:\n                    return [-1] * len(target)\n                stack.pop()\n        # Check if the stack size matches the expected size\n        if len(stack) != expected_stack_size:\n            return [-1] * len(target)\n        # Apply indentation\n        indentation = ' ' * (len(stack) * 2)\n        result.append(indentation + stripped)\n    return result\n\ndef main():\n    input_lines = sys.stdin.read().splitlines()\n    well_indented = []\n    target = []\n    separator_found = False\n    for line in input_lines:\n        if line == '======':\n            separator_found = True\n            continue\n        if not separator_found:\n            well_indented.append(line)\n        else:\n            target.append(line)\n    \n    indent_rules = parse_indent_rules(well_indented)\n    if indent_rules is None:\n        print('\\n'.join(['-1'] * len(target)))\n        return\n    \n    result = apply_indent_rules(target, indent_rules)\n    print('\\n'.join(result))\n\nif __name__ == '__main__':\n    main()",
    "timestamp": "2025-08-13 03:56:32"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n\nusing namespace std;\n\nstruct IndentationRule {\n    int r, c, s;  // Rules for (, {, [\n    IndentationRule(int r = 0, int c = 0, int s = 0) : r(r), c(c), s(s) {}\n};\n\nvector<int> parseProgram(const vector<string> &program) {\n    vector<int> ids;\n\n    int depthR = 0, depthC = 0, depthS = 0;\n    for (const string &line : program) {\n        int indent = 0;\n        while (indent < line.size() && line[indent] == '.') {\n            indent++;\n        }\n        \n        ids.push_back(indent);\n        \n        for (char ch : line) {\n            if (ch == '(') depthR++;\n            else if (ch == ')') depthR--;\n            else if (ch == '{') depthC++;\n            else if (ch == '}') depthC--;\n            else if (ch == '[') depthS++;\n            else if (ch == ']') depthS--;\n        }\n    }\n\n    return ids;\n}\n\nIndentationRule findIndentationRule(const vector<string> &program, const vector<int> &indents) {\n    int r = 0, c = 0, s = 0;\n    map<vector<int>, int> indentMap;\n\n    int depthR = 0, depthC = 0, depthS = 0;\n    for (int i = 0; i < program.size(); ++i) {\n        if (indentMap.find({depthR, depthC, depthS}) != indentMap.end()) {\n            int observedIndent = indents[i] - indents[i - 1];\n            indentMap[{depthR, depthC, depthS}] = observedIndent;\n        } else {\n            int observedIndent = indents[i] - (i > 0 ? indents[i - 1] : 0);\n            indentMap[{depthR, depthC, depthS}] = observedIndent;\n        }\n        \n        for (char ch : program[i]) {\n            if (ch == '(') depthR++;\n            else if (ch == ')') depthR--;\n            else if (ch == '{') depthC++;\n            else if (ch == '}') depthC--;\n            else if (ch == '[') depthS++;\n            else if (ch == ']') depthS--;\n        }\n    }\n\n    return IndentationRule(r, c, s);\n}\n\nvector<int> applyIndentationRule(const vector<string> &program, const IndentationRule &rule) {\n    vector<int> result;\n    int depthR = 0, depthC = 0, depthS = 0;\n\n    for (int i = 0; i < program.size(); ++i) {\n        result.push_back(depthR * rule.r + depthC * rule.c + depthS * rule.s);\n\n        for (char ch : program[i]) {\n            if (ch == '(') depthR++;\n            else if (ch == ')') depthR--;\n            else if (ch == '{') depthC++;\n            else if (ch == '}') depthC--;\n            else if (ch == '[') depthS++;\n            else if (ch == ']') depthS--;\n        }\n    }\n\n    return result;\n}\n\nint main() {\n    int P, Q;\n    cin >> P >> Q;\n\n    vector<string> program1(P), program2(Q);\n    cin.ignore();\n    \n    for (int i = 0; i < P; ++i) {\n        getline(cin, program1[i]);\n    }\n    \n    for (int i = 0; i < Q; ++i) {\n        getline(cin, program2[i]);\n    }\n\n    vector<int> indents1 = parseProgram(program1);\n    IndentationRule rule = findIndentationRule(program1, indents1);\n\n    vector<int> result = applyIndentationRule(program2, rule);\n\n    for (int indent : result) {\n        cout << indent << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:15:44"
  }
]