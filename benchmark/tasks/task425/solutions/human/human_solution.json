[
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\nint ans;\nvoid dfs(int pos, int b) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tfor (; pos < names.size(); pos++) {\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\tif (c.empty())break;\n\t}\n}\nint main() {\n\tint n;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tans = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tlist.push_back(a);\n\t\t\t}\n\t\t\tbuf.insert(make_pair(name, move(list)));\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nint ans = 0;\nvector<int>powers;\nint restp[41];\n\nint getans(const vector<vector<int>>&tonari,vector<bool>oks,const int next,const int pow) {\n\tif (pow +restp[next] <= ans)return pow;\n\telse {\n\t\tif (next == powers.size())return pow;\n\t\tint nans = 0;\n\t\tif(oks[next]){\n\t\t\tvector<bool>noks(oks);\n\t\t\tfor (int c = next + 1; c < powers.size(); ++c) {\n\t\t\t\tif (tonari[next][c])noks[c] = false;\n\t\t\t}\n\t\t\tnans = max(nans, getans(tonari,noks, next + 1, pow + powers[next]));\n\t\t}\n\t\tnans = max(nans,getans(tonari, oks, next + 1, pow));\n\t\tans = max(ans, nans);\n\t\treturn nans;\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tans = 0;\n\t\tmemset(restp, 0, sizeof(restp));\n\t\tpowers.clear();\n\t\tif (!N)break;\n\t\tvector<string>names;\n\t\tvector<vector<string>>rins(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring a; int  b, c; cin >> a >> b >> c;\n\t\t\tnames.push_back(a);\n\t\t\tpowers.push_back(b);\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\trins[i].push_back(st);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>tonari(N, vector<int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto n : rins[i]) {\n\t\t\t\tint r = find(names.begin(), names.end(), n) - names.begin();\n\t\t\t\ttonari[i][r] = true;\n\t\t\t}\n\t\t}\n\t\tvector<bool>oks(N,true);\n\t\tfor (int c = 1; c < powers.size(); ++c) {\n\t\t\tif (tonari[0][c])oks[c] = false;\n\t\t}\n\t\tfor (int c = 0; c < N; ++c) {\n\t\t\trestp[c] = accumulate(powers.begin() + c, powers.end(), 0);\n\t\t}\n\t\tint ans = getans(tonari, oks, 1, powers[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n\ninline int64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\t\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp){\n\t\t\t\tmax = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\tbool nei;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\tnei=false;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t\tif(d==0)nei=true;\n\t\t\t}\n\t\t\tif(nei){\n\t\t\t\tn--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 40\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> P;\nconst long long int MOD = 1000000007;\nconst long long int INF = 100000000000000;\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n;\nmap<string,int> id;\nmap<ll,int> dp;\nint b[40];\nint c[40];\nvector<string> d[40];\nvector<int> e[40];\nvector<int> fa;\nint ans = 0;\n\nint func(ll bo, int now){\n    if(now == fa.size()) return 0;\n    //if(dp.count(bo)) return dp[bo];\n    int ret = 0;\n    int f = fa[now];\n    if(f == 0){\n        ret = b[0];\n        bo++;\n        rep(i,e[f].size()){\n            bo += (1LL<<e[f][i]);\n        }\n        //cout << ret << endl;\n        ret += func(bo,now+1);\n        dp[bo] = ret;\n        //cout << func(bo,now+1) << endl;\n        return ret;\n    }\n    if(bo&(1LL<<f)){\n        dp[bo] = func(bo,now+1);\n        return dp[bo];\n    }\n    bo += (1LL<<f);\n    ret = func(bo,now+1);\n    int ret2 = b[f];\n    rep(i,e[f].size()){\n        if(bo&(1LL<<e[f][i])) continue;\n        bo += (1LL<<e[f][i]);\n    }\n    ret2 += func(bo,now+1);\n    //cout << f << \" \" << bo << \" \" << now << \" \" << ret << \" \" << ret2 << endl;\n    dp[bo] = max(ret,ret2);\n    return max(ret,ret2);\n}\n\nvoid solve(){\n    uf.init(n);\n    rep(i,40) d[i].clear();\n    rep(i,40) e[i].clear();\n    fa.clear();\n    id.clear();\n    dp.clear();\n    ans = 0;\n    rep(i,n){\n        string a;\n        cin >> a >> b[i] >> c[i];\n        id[a] = i;\n        rep(j,c[i]){\n            string tmp;\n            cin >> tmp;\n            d[i].push_back(tmp);\n        }\n    }\n    rep(i,n){\n        rep(j,c[i]){\n            e[i].push_back(id[d[i][j]]);\n            uf.unite(i,id[d[i][j]]);\n        }\n    }\n    rep(i,n){\n        if(uf.par[i] != i) continue;\n        vector<int> now;\n        dp.clear();\n        rep(j,n){\n            if(uf.find(j) != i) continue;\n            now.push_back(j);\n        }\n        fa = now;\n        ans += func(0,0);\n        //cout << \" \" << ans << endl;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> n){\n        if(n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n\nint n;\nstring vertex[45];\nint m[45];\nint power[45];\nstring adj[45][45];\nll graph[50];\n\nrandom_device seed_gen;\nmt19937 engine(seed_gen());\n\nvector<int> ary;\n\nint run(int n) {\n\tll cur = (1LL << n) - 1;\n\tshuffle(begin(ary) + 1, end(ary), engine);\n\trep(i, n) if (cur & (1LL << ary[i])) cur &= graph[ary[i]];\n\tint ret = 0;\n\trep(i, n) if(cur & (1LL << i)) ret += power[i];\n\treturn ret;\n}\n\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n){\n\t\t\tcin >> vertex[i] >> power[i];\n\t\t\tcin >> m[i];\n\t\t\trep(j,m[i]) cin >> adj[i][j];\n\t\t}\n\n\t\tmap<string,int> ref;\n\t\trep(i,n) ref[vertex[i]] = i;\t\n\n\t\tary.resize(n);\n\t\tiota(begin(ary),end(ary),0);\n\n\t\trep(i,n) graph[i] = (1LL << n) -1LL;\n\n\t\trep(i,n){\n\t\t\trep(j,m[i]){\n\t\t\t\tconst int idx = ref[adj[i][j]];\n\t\t\t\tgraph[i] &= ~(1LL << idx);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(loop,n * 1000) ans = max(ans,run(n));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        int mid = n/2;\n        vi p(n),c(n);\n        vector<vs> s(n);\n        int id = 0;\n        map<string,int> mp;\n        rep(i,n){\n            string t;\n            cin >> t >> p[i] >> c[i];\n            mp[t] = id++;\n            s[i].resize(c[i]);\n            rep(j,c[i]){\n                cin >> s[i][j];\n            }\n        }\n        vi st(mid),ed(n-mid),se(mid);\n        vi sout((1 << mid),0);\n        rep(i,mid){\n            st[i] = (1 << i);\n            rep(j,c[i]){\n                int num = mp[s[i][j]];\n                if(num >= mid){\n                    se[i] |= (1 << (num-mid));\n                }else{\n                    st[i] |= (1 << num);\n                }\n            }\n        }\n        rep(i,n-mid){\n            ed[i] = (1 << i);\n            rep(j,c[i+mid]){\n                int num = mp[s[i+mid][j]];\n                if(num >= mid){\n                    ed[i] |= (1 << (num-mid));\n                }\n            }\n        }\n        vector<bool> dst((1 << mid),false),ded((1 << (n-mid)),false);\n        dst[0] = true;\n        rep(i,(1 << mid)){\n            if(dst[i]){\n                rep(j,mid){\n                    if(!((i >> j) & 1)){\n                        dst[i^(1 << j)] = true;\n                    }\n                }\n            }\n        }\n        ded[0] = true;\n        rep(i,(1 << (n-mid))){\n            if(ded[i]){\n                rep(j,n-mid){\n                    if(!((i >> j) & 1)){\n                        ded[i^(1 << j)] = true;\n                    }\n                }\n            }\n        }\n        rep(i,(1 << mid)){\n            if(dst[i]){\n                rep(j,mid){\n                    if(!((i >> j) & 1)){\n                        sout[i^(1 << j)] = sout[i] | se[j];\n                    }\n                }\n            }\n        }\n        vi p1((1 << mid),0),p2((1 << (n-mid)),0);\n        rep(i,(1 << mid)){\n            if(dst[i]){\n                rep(j,mid){\n                    if((i >> j) & 1){\n                        p1[i] += p[j];\n                    }\n                }\n            }\n        }\n        rep(i,(1 << (n-mid))){\n            if(ded[i]){\n                rep(j,n-mid){\n                    if((i >> j) & 1){\n                        p2[i] += p[j+mid];\n                    }\n                }\n            }\n        }\n        vector<int> mx((1 << (n-mid)),0);\n        rep(i,(1 << (n-mid))){\n            if(ded[i]){\n                mx[i] = p2[i];\n                continue;\n            }\n            rep(j,n-mid){\n                if((i >> j) & 1){\n                    cmx(mx[i],mx[i^(1 << j)]);\n                }\n            }\n        }\n        int ans = 0;\n        rep(i,(1 << mid)){\n            if((i & 1) && dst[i]){\n                cmx(ans,p1[i] + mx[((1 << (n-mid))-1) ^ sout[i]]);\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdint>\n#include <cassert>\n#include <functional>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\nnamespace lc {\nstruct Edge {\n\tint to;\n\texplicit Edge(int to) : to(to) { }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nint enumerate_maximal_independent_sets(\n\tconst AdjacencyList<EdgeType> &graph, const std::vector<int> &p)\n{\n\tconst int n = graph.size();\n\tstd::vector<uint64_t> bit_graph(n), incr_bit_graph(n + 1);\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tuint64_t mask = (1ull << i);\n\t\tfor(const auto &e : graph[i]){ mask |= (1ull << e.to); }\n\t\tbit_graph[i] = mask;\n\t\tincr_bit_graph[i] = mask | incr_bit_graph[i + 1];\n\t}\n\tstd::function<int(int, int, uint64_t, uint64_t)> recur =\n\t\t[&, n](int i, int s, uint64_t picked, uint64_t eliminated) -> int {\n\t\t\tif(i == n){ return s; }\n\t\t\tconst bool force_ignore = ((eliminated & (1ull << i)) != 0);\n\t\t\tint flags = 1; // 1: select v_i, 2: ignore v_i\n\t\t\tif(bit_graph[i] & ~(incr_bit_graph[i + 1] | eliminated)){\n\t\t\t\tflags = (force_ignore ? 2 : 1);\n\t\t\t}else if((incr_bit_graph[i + 1] | eliminated) & (1ull << i)){\n\t\t\t\tflags = (force_ignore ? 2 : 3);\n\t\t\t}\n\t\t\tif(i == 0){ flags = 1; }\n\t\t\tint answer = 0;\n\t\t\tif(flags & 1){\n\t\t\t\tanswer = recur(\n\t\t\t\t\ti + 1, s + p[i], picked | (1ull << i),\n\t\t\t\t\teliminated | bit_graph[i]);\n\t\t\t}\n\t\t\tif(flags & 2){\n\t\t\t\tanswer = std::max(answer, recur(i + 1, s, picked, eliminated));\n\t\t\t}\n\t\t\treturn answer;\n\t\t};\n\treturn recur(0, 0, 0, 0);\n}\n}\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n};\n}\nusing namespace std;\ntypedef lc::Edge Edge;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tlc::NameTable name_table;\n\t\tvector<int> powers(n);\n\t\tlc::AdjacencyList<Edge> graph(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring u_name;\n\t\t\tint p, m;\n\t\t\tcin >> u_name >> p >> m;\n\t\t\tconst int u = name_table[u_name];\n\t\t\tpowers[u] = p;\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tstring v_name;\n\t\t\t\tcin >> v_name;\n\t\t\t\tconst int v = name_table[v_name];\n\t\t\t\tgraph.add_edge(u, v);\n\t\t\t}\n\t\t}\n\t\tconst int answer = lc::enumerate_maximal_independent_sets(graph, powers);\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nmap<string,int> M;\nvector<string> NG[41];\nstring A[41];\nint n,B[41],ans;\null g[41];\n\nunordered_set <ull> S[41];\nunordered_map <ull,int> mem[41];\null used;\nvoid dfs(int pos,int sum,ull U){\n  if(pos>=2) mem[pos-2].clear();\n  ans=max(ans,sum);\n  while(pos<n&&(g[pos]&1LL))pos++;\n  if(pos==n)return;\n  if(mem[pos][U]>=sum)return;\n  mem[pos][U]=sum;\n  //if(S[pos].count(used))return;\n  //S[pos].insert(used);\n  ull tmp=used,nU=U;\n  int nsum=sum;\n\n  if(U&(1LL<<pos)){\n    used=nU=nsum=0;\n    for(int i=0;i<pos;i++){\n      if((tmp&(1LL<<i))==0) continue; \n      if((g[pos]&(1LL<<i))==0) nU|=g[i],used|=(1LL<<i),nsum+=B[i];\n    }\n  }\n  \n  used|=(1LL<<pos);\n  dfs(pos+1,nsum+B[pos],nU|g[pos]);\n  used&=~(1LL<<pos);\n  if(used!=tmp)used=tmp,dfs(pos+1,sum,U);\n} \n\n\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    for(int i=0;i<40;i++) S[i].clear(),mem[i].clear();\n\n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      M[A[i]]=i;\n      NG[i].resize(C);\n      for(int j=0;j<C;j++)cin>>NG[i][j];\n    }\n\n    \n    for(int i=0;i<n;i++){\n      g[i]=1LL<<i;\n      for(int j=0;j<(int)NG[i].size();j++)g[i]|=1LL<<M[NG[i][j]];\n    }\n    \n    ans=0;\n    used=1;\n    dfs(1,B[0],g[0]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<30\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> strength; //国の強さ\nmultimap<string,string> adjacentCountry; //隣接した国の関係\nll ans=0;\n\n\n/*再帰で全通り試す*/\nint rec(map<string,bool> m,ll sum){\n  bool fin=true;\n  map<string,bool>::iterator it = m.begin();\n  while(it != m.end()){\n    fin*=it->second; \n    it++;\n  }\n  if(fin){//mはusedのことで、もしすべて使用している(bool値がすべてtrue)なら終了\n    if(ans < sum)ans=sum;\n    return 0;\n  }\n\n  map<string,bool> preUsed;//再帰にもっていく方のused\n  ll preSum=0; //再帰に持っていく方のsum\n  it = m.begin();\n  while(it != m.end()){\n    if(!it->second){\n      preSum=sum;\n      preSum+=strength[it->first];\n      map<string,bool>::iterator preIt = m.begin();\n      while(preIt != m.end()){//preUsedにm(=used)をコピーする\n\tpreUsed[preIt->first]=preIt->second;\n\t++preIt;\n      }\n      multimap<string,string>::iterator cpyIt = adjacentCountry.find(it->first); \n     int counter = adjacentCountry.count(it->first);\n     while(counter-- > 0){//隣国とは同盟が結べないのでtrueにする\n\tpreUsed[cpyIt->second]=true;\n\t++cpyIt;\n      }\n     preUsed[it->first]=true;//選択した国をtrueにする\n     rec(preUsed,preSum);//新たに再帰へ、いざゆかん\n    }\n    ++it;\n  }\n  \n\n\n\n\n}\n\n\nint main(){\n  int n,val,os;\n  string s,oc;\n  map<string,bool> used;\n  ll sum=0;\n\n  while(true){\n    scanf(\"%d\",&n);\n    if(n == 0)break;\n    ans=0;\n    used.clear();\n    adjacentCountry.clear();\n    strength.clear();\n    rep(i,n){\n      cin >> s;\n      scanf(\"%d %d\",&val,&os);\n      strength[s]=val;\n      if(!used[s])used[s]=false;\n      rep(j,os){\n\tcin >> oc;\n\tadjacentCountry.insert(multimap<string,string>::value_type(s,oc));      \n      }\n      \n      if(i == 0){//自国の隣国とは同盟を結べないのであらかじめusedをtrueにしておく\n\tsum = val;\n\tused[s]=true;\n\tmultimap<string,string>::iterator sit = adjacentCountry.begin();\n\twhile(sit != adjacentCountry.end()){\n\t  used[sit->second]=true;\n\t  ++sit;\n\t}\n      }      \n    }\n\n    rec(used,sum);\n    printf(\"%lld\\n\",ans);\n    \n\n\n\n  }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <array>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nclass Main{\n\tpublic:\n\tvector<int> g[40];\n\tint B[40];\n\tmap<string,int> dic;\n\tint get(string x){\n\t\tif( dic.count(x) ) return dic[x];\n\t\tint t = dic.size();\n\t\treturn dic[x] = t;\n\t}\n\n\tint N;\n\tlong long kill[40] = {};\n\tint answer = 0;\n\tint maximum = 0;\n\tint dfs(long long cond){\n\t\tint killnum = -1;\n\t\tint id = -1;\n\t\tint allsum = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tif( !(cond >> i & 1) ){\n\t\t\t\tint killtmp = __builtin_popcountll(kill[i]&~cond);\n\t\t\t\tif( killtmp > killnum ){\n\t\t\t\t\tkillnum = killtmp;\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t\tallsum += B[i];\n\t\t\t}\n\t\t}\n\t\tif( answer + allsum <= maximum ) return 0;\n\t\tif( killnum == -1 ){\n\t\t\tmaximum = answer;\n\t\t}else{\n\t\t\tanswer += B[id];\n\t\t\tdfs(cond|kill[id]|(1ll<<id));\n\t\t\tanswer -= B[id];\n\t\t\tdfs(cond|(1ll<<id));\n\t\t}\n\t}\n\tint main(){\n\t\tif( cin >> N, N == 0 ) exit(0);\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tstring A; int id,C;\n\t\t\tcin >> A;\n\t\t\tid = get(A);\n\t\t\tcin >> B[id] >> C;\n\t\t\tfor(int j = 0 ; j < C ; j++){\n\t\t\t\tstring h; cin >> h;\n\t\t\t\tint id2 = get(h);\n\t\t\t\tg[id].push_back(id2);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < g[i].size() ; j++)\n\t\t\t\tkill[i] |= 1ll<<g[i][j];\n\t\t}\n\t\tanswer = B[0];\n\t\tdfs(kill[0]|1);\n\t\tcout << maximum << endl;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tMain().main();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nmap<string,int> id;\nmap<string,long long> bit;\nmap<long long, long long> memo;\nvector<int> sum(50);\nint n;\nint maximum;\nstring a[50], d[50][50];\nint b[50], c[50];\n\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nvoid dfs(int p, long long used , int score){\n\tmaximum = max(maximum, score);\n\tif(p == n - 1) return;\n\tif(score + sum[p] <= maximum) return;\n\n\tlong long next = used bitor bit[a[p + 1]];\n\tif(not getBit(used,p + 1)) dfs(p + 1, next, score + b[p + 1]);\n\n\tdfs(p + 1, used, score);\n\n}\n\nsigned main(){\n\twhile(cin >> n,n){\n\t\tid.clear();\n\t\tbit.clear();\n\t\tmemo.clear();\n\t\tsum.clear();\n\t\tmaximum = 0;\n\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tsum[i] = b[i];\n\t\t\tid[a[i]] = i;\n\t\t\trep(j,c[i]){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,n - 1){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\t\trep(i,n){\n\t\t\tlong long near = setBit(0,i);\n\t\t\trep(j,c[i]){\n\t\t\t\tnear = setBit(near, id[d[i][j]]);\n\t\t\t}\n\t\t\tbit[a[i]] = near;\n\t\t}\n\n\n\n\t\tdfs(0, bit[a[0]], b[0]);\n\t\tcout << maximum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tvi pow(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> pow[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tvector<ll> g(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tg[i] = 1ll << i;\n\t\t\tREP(j, nei[i].size())\n\t\t\t{\n\t\t\t\tg[i] |= 1ll << mp[nei[i][j]];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tstack<ll> st;\n\t\tst.push(1);\n\t\twhile (st.size())\n\t\t{\n\t\t\tll tmp = st.top();\n\t\t\tst.pop();\n\t\t\tint left;\n\t\t\tfor (int i = n - 1; i >= 0;i--)\n\t\t\t{\n\t\t\t\tif ((tmp >> i) & 1)\n\t\t\t\t{\n\t\t\t\t\tleft = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll can = 0;\n\t\t\tint sum = 0, cansum = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((tmp >> j) & 1)\n\t\t\t\t{\n\t\t\t\t\tsum += pow[j];\n\t\t\t\t\tcan |= g[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchmax(ans, sum);\n\t\t\tFOR(j, left+1, n)\n\t\t\t{\n\t\t\t\tif ((can >> j) & 1) continue;\n\t\t\t\tll nx = tmp | (1ll << j);\n\t\t\t\tst.push(nx);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int> f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tid[t] = id.size();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\n\nint dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t\treturn sum;\n\n\tint res = 0;\n\tif (!(enemy >> d & 1))\n\t\tres = dfs(d + 1, enemy | on[d], sum + force[d]);\n\tmax_swap(res, dfs(d + 1, enemy, sum));\n\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t\tid[a] = id.size();\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t\tid[d] = id.size();\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\n\t\tint res;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tres = dfs(1, on[0], force[0]);\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tres += dfs(0, 0, 0);\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nint n;\n\nint a[64];\n\nmap<string,int> ma;\n\nvector<string> sG[64];\nvector<int> G[64];\n\nll ms[64];\n\nint ans;\n\nvi v;\n\nint hstar( ll mask ){\n  int res = 0;\n  REP( i , n ){\n    if( !( mask & PW(i) ) ){\n      res += a[i];\n    }\n  }\n  return res;\n}\n\nvoid dfs( int cur, ll mask ){\n  // cout << cur << \" \" << mask << endl;\n  chmax( ans , cur );\n  /*\n  if( cur + hstar( mask ) <= ans ){\n    return;\n  }\n  */\n  if( cur <= ans ){\n    return;\n  }\n  YYS( i , v ){\n    if( !( mask & PW(i) ) ){\n      dfs( cur + a[i], mask | ms[i] );\n    }\n  }\n}\n\nint cmp( int i , int j ){\n  return a[i] < a[j];\n}\n\nint main(){\n\n  while( 1 ){\n    n = in();\n    if( n == 0 ){\n      break;\n    }\n    ma.clear();\n    ans = 0;\n    v.clear();\n    REP( i , n ){\n      sG[i].clear();\n      G[i].clear();\n      ms[i] = 0;\n    }\n    REP( i , n ){\n      string s = stin();\n      ma[s] = i;\n      a[i] = in();\n      int m = in();\n      REP( j , m ){\n        string t = stin();\n        sG[i].pb( t );\n      }\n    }\n    REP( i , n ){\n      YYS( w , sG[i] ){\n        G[i].pb( ma[w] );\n        ms[i] = ms[i] | PW( ma[w] );\n      }\n      ms[i] = ms[i] | PW(i);\n    }\n    REP( i , n ){\n      v.pb( i );\n    }\n    sort( ALL(v), cmp );\n    dfs( a[0] , ms[0] );\n    printf( \"%d\\n\" , ans );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n#include<iostream>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n,val[40];\nvector<int> G[40];\n\nbool vis[40],used[40];\n\nvoid dfs1(int u,vector<int> &order){\n\tvis[u]=true;\n\torder.push_back(u);\n\trep(i,G[u].size()){\n\t\tint v=G[u][i];\n\t\tif(!vis[v]) dfs1(v,order);\n\t}\n}\n\nint dfs2(int i,const vector<int> &order){\n\tif(i==order.size()) return 0;\n\tint u=order[i];\n\n\t// 頂点 u を選べるかどうかを判定\n\tbool ok=true;\n\trep(j,G[u].size()){\n\t\tint v=G[u][j];\n\t\tif(used[v]) ok=false;\n\t}\n\n\tint res=0;\n\tif(u!=0){\n\t\tres=max(res,dfs2(i+1,order));\n\t}\n\tif(ok){\n\t\tused[u]=true;\n\t\tres=max(res,val[u]+dfs2(i+1,order));\n\t\tused[u]=false;\n\t}\n\treturn res;\n}\n\nint main(){\n\tfor(;cin>>n,n;){\n\t\trep(u,n) G[u].clear();\n\n\t\tint nf=0;\n\t\tmap<string,int> f;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tint tmp,m; cin>>s>>tmp>>m;\n\t\t\tif(f.count(s)==0) f[s]=nf++;\n\t\t\tint u=f[s];\n\t\t\tval[u]=tmp;\n\t\t\trep(i,m){\n\t\t\t\tstring t; cin>>t;\n\t\t\t\tif(f.count(t)==0) f[t]=nf++;\n\t\t\t\tint v=f[t];\n\t\t\t\tG[u].push_back(v);\n\t\t\t}\n\t\t}\n\n\t\trep(u,n){\n\t\t\tvis[u]=false;\n\t\t\tused[u]=false;\n\t\t}\n\n\t\tint ans=0;\n\t\trep(u,n) if(!vis[u]) {\n\t\t\tvector<int> order;\n\t\t\tdfs1(u,order);\n\t\t\tans+=dfs2(0,order);\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(long long num, int i){\n\treturn ((num & (1LL << i)) != 0);\n}\n\n//i番目を1にする\nlong long setBit(long long num, int i){\n\treturn num | (1LL << i);\n}\n\nvector<int> atk;\nvector<long long> bit;\n\nvoid input(int n){\n\tvector<string> name(n);\n\tvector<vector<string>> near(n);\n\n\tmap<string, int> id;\n\trep(i,n){\n\t\tint d;\n\t\tcin >> name[i] >> atk[i] >> d;\n\t\tid[name[i]] = i;\n\t\twhile(d--){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tnear[i].emplace_back(s);\n\t\t}\n\t}\n\n\trep(i,n){\n\t\t//bit[i] |= 1 << i;\n\t\tfor(auto s : near[i]){\n\t\t\tbit[i] |= 1LL << id[s];\n\t\t}\n\t\t//cout << bitset<10>(bit[i]) << endl;\n\t}\n}\n\nvoid dfs(int& low, int& high, map<pair<long long, long long>, int>& memo, long long enemy, long long frined, int sum){\n\tif(memo.count(make_pair(enemy, frined))){\n\t\tif(memo[make_pair(enemy, frined)] >= sum) return;\n\t}\n\tmemo[make_pair(enemy, frined)] = sum;\n\trange(i,low,high){\n\t\tif(getBit(enemy,i)) continue;\n\t\tif(getBit(frined,i)) continue;\n\t\tdfs(low, high, memo, enemy bitor bit[i], frined bitor (1LL << i), sum + atk[i]);\n\t}\n}\n\nmap<pair<long long, long long>, int> memo1, memo2;\nvector<int> dp; // dp[s] := 集合sから任意の数, 仲間を選べるときの最大値\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tatk = vector<int>(n);\n\t\tbit = vector<long long>(n,0);\n\t\tinput(n);\n\n\t\tint half = n / 2;\n\n\t\tmemo1.clear();\n\t\tmemo2.clear();\n\t\tint s = 0;\n\t\tdfs(s, half, memo1, 1, bit[0], atk[0]);\n\t\tdfs(half, n, memo2, 0, 0, 0);\n\n\t\tdp = vector<int>(1 << (n - half), 0);\n\t\tfor(auto i : memo2){\n\t\t\tint p = i.first.second >> half;\n\t\t\tdp[p] = i.second;\n\t\t}\n\t\trep(i, 1 << (n - half)){\n\t\t\trep(j,(n - half)){\n\t\t\t\tdp[setBit(i,j)] = max(dp[setBit(i,j)], dp[i]);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(auto i : memo1){\n\t\t\tint rev = ~(i.first.second >> half) bitand ((1 << (n - half)) - 1);\n\t\t\tans = max(ans, i.second + dp[rev]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long int ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n;\nstring vertex[45];\nint m[45];\nint power[45];\nstring adj[45][45];\n\null graph[45];\n\nint dfs(int cur,ull used){\n\tif(cur==n) return 0;\n\tif(used>>cur&1) return dfs(cur+1,used);\n\n\tint res=0;\n\tull nused=used|(1LL<<cur);\n\n\tif(__builtin_popcountll((~used)&(graph[cur]))<=1){\n\t\tres=power[cur]+dfs(cur+1,nused|graph[cur]);\n\t}else{\n\t\tres=dfs(cur+1,nused);\n\t\tres=max(res,power[cur]+dfs(cur+1,nused|graph[cur]));\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n){\n\t\t\tcin >> vertex[i] >> power[i];\n\t\t\tcin >> m[i];\n\t\t\trep(j,m[i]) cin >> adj[i][j];\n\t\t}\n\t\tfor(int i=1;i<n;++i){\n\t\t\tfor(int j=i+1;j<n;++j){\n\t\t\t\tif(power[i]<power[j]){\n\t\t\t\t\tswap(vertex[i],vertex[j]);\n\t\t\t\t\tswap(power[i],power[j]);\n\t\t\t\t\tswap(m[i],m[j]);\n\t\t\t\t\trep(k,45) swap(adj[i][k],adj[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tgraph[i]=0LL;\n\t\t\trep(j,m[i])rep(k,n)\n\t\t\t\tif(adj[i][j]==vertex[k])\n\t\t\t\t\tgraph[i]|=(1LL<<k);\n\t\t}\n\t\tcout << power[0]+dfs(1,graph[0]|1LL) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\ntemplate<class T>\nclass IdMaker{\npublic:\n  std::map<T,int> _m;\n  int getId(const T &v){\n    if(_m.find(v) == _m.end()){\n      int next = _m.size();\n      return _m[v] = next;\n    }\n    return _m[v];\n  }\n};\n\nll adj[40];\nint str[40];\nint memo[40];\nint ans;\n\nvoid solve(ll flag, int now){\n  ll ff = flag;\n\n  while(ff){\n    const ll f = ff & (-ff);\n    const int pos = __builtin_ctzl(f);\n    if((adj[pos] & flag) == 0){\n      now += str[pos];\n      flag ^= f;\n    }\n    ff ^= f;\n  }\n\n  if(flag == 0){\n    ans = max(ans, now);\n    return;\n  }\n\n  if(now + memo[__builtin_ctzl(flag)] <= ans)\n    return;\n\n  while(flag){\n    const ll f = flag & (-flag);\n    const int pos = __builtin_ctzl(f);\n    solve((flag ^ (1ll << pos)) & (~adj[pos]), now + str[pos]);\n    flag ^= f;\n  }\n}\n\nint main(){\n  while(const int n = getInt()){\n    IdMaker<string> idm;\n\n    REP(i,n){\n      string s; cin >> s;\n      str[idm.getId(s)] = getInt();\n      const int m = getInt();\n      adj[idm.getId(s)] = 0;\n      REP(j,m){\n        string a; cin >> a;\n        adj[idm.getId(s)] |= (1ll << idm.getId(a));\n      }\n    }\n\n    REP(i,n)\n      for(int j = i; j < n; j++)\n        memo[i] += str[j];\n\n    ll start = (1ll << n) - 1;\n    start ^= 1;\n    start ^= adj[0];\n\n    ans = 0;\n    solve(start, str[0]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\n\ntypedef unsigned long long ULL;\n\ninline int trail0(ULL s) { return (s ? __builtin_ctzll(s) : 64); }\n\nint BronKerbosch(const vector<ULL>& g, ULL cur, ULL allowed, ULL forbidden, const vector<int>& weights) {\n    if (allowed == 0 && forbidden == 0) {\n        int res = 0;\n        for (int u = trail0(cur); u < g.size(); u += trail0(cur >> (u + 1)) + 1)\n            res += weights[u];\n        return res;\n    }\n    if (allowed == 0) return -1;\n    int res = -1;\n    int pivot = trail0(allowed | forbidden);\n    ULL z = allowed & ~g[pivot];\n    for (int u = trail0(z); u < g.size(); u += trail0(z >> (u + 1)) + 1) {\n        res = max(res, BronKerbosch(g, cur | (1ULL << u), allowed & g[u], forbidden & g[u], weights));\n        allowed ^= 1ULL << u;\n        forbidden |= 1ULL << u;\n    }\n    return res;\n}\n\nint maximum_clique(const Graph& G, const vector<int>& weights) {\n    int n = G.size();\n    assert(n < 64);\n    vector<ULL> g(n, 0);\n    REP(i, n) for(int j : G[i]) g[i] |= (1ULL << j);\n    return BronKerbosch(g, 0, (1ULL << n) - 1, 0, weights);\n}\n\nint maximum_independet_set(const Graph& G, const vector<int>& weights) {\n    int n = G.size();\n    assert(n < 64);\n    vector<ULL> g(n);\n    REP(i, n) REP(j, n) if(i != j) g[i] |= (1ULL << j);\n    REP(i, G.size()) for(int j : G[i]) g[i] ^= (1ULL << j);\n    return BronKerbosch(g, 0, (1ULL << n) - 1, 0, weights);\n}\nint main(){\n    int N;\n    while(cin >> N && N > 0) {\n        vector<string> name(N);\n        vector<int> weight(N);\n        vector<string> next[50];\n        REP(i, N) {\n            cin >> name[i] >> weight[i];\n            int M;\n            cin >> M;\n            while(M--) {\n                string s;\n                cin >> s;\n                next[i].push_back(s);\n            }\n        }\n        map<string, int> idx;\n        REP(i, N) idx[name[i]] = i;\n\n        Graph G(N - 1);\n        vector<int> nweight(N - 1);\n        for(int i = 1; i < N; i++) {\n            for(string s : next[i]) {\n                G[i - 1].push_back(idx[s] - 1);\n            }\n            nweight[i - 1] = weight[i];\n        }\n\n        for(string s : next[0]) {\n            nweight[idx[s] - 1] = 0;\n        }\n\n        cout << maximum_independet_set(G, nweight) + weight[0] << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<vector<ll>> g;\nvector<ll> power;\nvector<ll> used;\nvector<P> ord;\n\nvoid build_graph() {\n\tmap<string,ll> dict;\n\tll cnt = 0;\n\tREP(i,n) {\n\t\tstring a; ll b, c;\n\t\tcin >> a >> b >> c;\n\t\tif(dict.count(a) == 0) {\n\t\t\tdict[a] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p = dict[a];\n\t\tpower[dict[a]] = b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tif(dict.count(t) == 0) {\n\t\t\t\tdict[t] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tg[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx, ll sum) {\n\tif(idx == n) return sum;\n\tif(used[ord[idx].second] != -1) return dfs(idx + 1, sum);\n\tll ret = 0;\n\tvector<ll> tmp(n);\n\tREP(i,n) tmp[i] = used[i];\n\tif((ll)g[ord[idx].second].size() > 1) {\n\t\tused[ord[idx].second] = 0;\n\t\tret = max(ret, dfs(idx + 1, sum));\n\t}\n\tused[ord[idx].second] = 1;\n\tREP(i,g[ord[idx].second].size()) used[g[ord[idx].second][i]] = 0;\n\tret = max(ret, dfs(idx + 1, sum + power[ord[idx].second]));\n\tREP(i,n) used[i] = tmp[i];\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tused.assign(n, -1);\n\tord.resize(n);\n\tg.resize(n); build_graph();\n\tll sum = 0;\n\tREP(i,n) if(used[i] == -1) {\n\t\tif(i == 0) {\n\t\t\tused[i] = 1;\n\t\t\tREP(j,g[i].size()) used[g[i][j]] = 0;\n\t\t\tsum += power[i];\n\t\t\tcontinue;\t\n\t\t}\n\t\tif(g[i].size() == 0) {\n\t\t\tused[i] = 1;\n\t\t\tsum += power[i];\n\t\t}\n\t\tif(g[i].size() == 1 && g[g[i][0]].size() == 1) {\n\t\t\tif(power[i] >= power[g[i][0]]) {\n\t\t\t\tused[i] = 1; used[g[i][0]] = 0;\n\t\t\t\tsum += power[i];\n\t\t\t} else {\n\t\t\t\tused[i] = 0; used[g[i][0]] = 1;\n\t\t\t\tsum += power[g[i][0]];\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n) {\n\t\tord[i].first = (ll)g[i].size();\n\t\tord[i].second = i;\n\t}\n\tsort(ALL(ord)); reverse(ALL(ord));\n\treturn dfs(0, sum);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<30\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> strength; //国の強さ\nmultimap<string,string> adjacentCountry; //隣接した国の関係\nll ans=0;\n\n\nint rec(map<string,bool> m,ll sum){\n  ll finsum=0;\n  bool fin=true;\n  map<string,bool>::iterator it = m.begin();\n  while(it != m.end()){\n    //cout << it->first << \" \" << it->second << endl;\n    fin*=it->second;\n    if(!it->second)finsum+=strength[it->first];  \n    it++;\n  }\n  if(fin || finsum == 0){\n    if(ans < sum)ans=sum;\n    return 0;\n  }\n\n  map<string,bool> preUsed;\n  ll preSum=0;\n  it = m.begin();\n  while(it != m.end()){\n    if(!it->second){\n      preSum=sum;\n      preSum+=strength[it->first];\n      //cout << \"sum = \" << sum  << \", it->first = \" << it->first << endl;\n   \n      map<string,bool>::iterator preIt = m.begin();\n      while(preIt != m.end()){\n\tpreUsed[preIt->first]=preIt->second;\n\t//cout << preIt->first << \" \" << preIt->second << endl;\n\t++preIt;\n      }\n      multimap<string,string>::iterator cpyIt = adjacentCountry.find(it->first); \n     int counter = adjacentCountry.count(it->first);\n      //cout << \"coutner = \" << counter << endl;\n      while(counter-- > 0){\n\t//cout << \"cpyIt->first = \" << cpyIt->first << endl;\n\tpreUsed[cpyIt->second]=true;\n\t//cout << \"cpyIt->second =\" << cpyIt->second << endl;\n\t++cpyIt;\n      }\n      preUsed[it->first]=true;\n      /*\n  map<string,bool>::iterator wr = preUsed.begin();\n      while(wr != preUsed.end()){\n\tcout << wr->first << \" \" << wr->second << endl;\n\t++wr;\n      }\n      cout << \"----------------------------------------^w^----\" << endl;\n      */\n      rec(preUsed,preSum);\n    }\n\n    ++it;\n  }\n  \n\n\n\n\n}\n\n\nint main(){\n  int n,val,os;\n  string s,oc;\n  map<string,bool> used;\n  ll sum=0;\n\n  while(true){\n    scanf(\"%d\",&n);\n    if(n == 0)break;\n    ans=0;\n    used.clear();\n    adjacentCountry.clear();\n    strength.clear();\n    rep(i,n){\n      cin >> s;\n      scanf(\"%d %d\",&val,&os);\n      strength[s]=val;\n      if(!used[s])used[s]=false;\n      rep(j,os){\n\tcin >> oc;\n\tadjacentCountry.insert(multimap<string,string>::value_type(s,oc));      \n      }\n      \n      if(i == 0){\n\tsum = val;\n\tused[s]=true;\n\tmultimap<string,string>::iterator sit = adjacentCountry.begin();\n\t//cout << \"IN  ----------------------------\" << endl;\n\twhile(sit != adjacentCountry.end()){\n\t  used[sit->second]=true;\n\t  //cout << sit->second << \" \" <<used[sit->second] << endl;\n\t  ++sit;\n\t}\n\t//cout << \"OTU ========================\" << endl;\n\n      }\n      \n    }\n\n\n\n\n    /*\n    cout << \"-----------------\" << endl;\n    map<string,bool>::iterator it = used.begin();\n    while(it != used.end()){\n      cout << \"it->first = \" << it->first << endl;\n      cout << it->second << endl;\n      ++it;\n    }\n    cout << \"-------------------\" << endl;\n    */\n\n    rec(used,sum);\n    cout << ans << endl;\n    \n\n\n\n  }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nvector<i64> edges(n + 10, 0);\nvector<int> x(n + 10, 0);\nvector<int> sum(n + 10, 0);\nint result = 0;\nvoid dfs(i64 i, i64 bit, int now_sum) {\n  result = max(result, now_sum);\n  if (i == n)\n    return;\n  //枝刈り\n  if (now_sum + sum[i] <= result)\n    return;\n  // throw\n  dfs(i + 1, bit, now_sum);\n\n  if (0 == (bit & edges[i]))\n    dfs(i + 1, bit | (1LL << i), now_sum + x[i]);\n};\nint get_i(map<string,int> &mp,string &s) {\n  if (mp.count(s)) {\n    return mp[s];\n  } else {\n    mp[s] = mp.size();\n    return (int)mp.size() - 1;\n  }\n};\n\nint main(){\n    cin >> n;\n    while(n){\n        edges.assign(n + 10, 0);\n        x.assign(n + 10, 0);\n        map<string,int> mp;\n        for (int c = 0; c < n; c++) {\n          string s;\n          cin >> s;\n          int i = get_i(mp,s);\n          int C;\n          cin >> x[i] >> C;\n          for (int d = 0; d < C; d++) {\n            cin >> s;\n            edges[i] |= (1LL << get_i(mp,s));\n          }\n        }\n\n        sum.assign(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        result = 0;\n        dfs(1,1,x[0]);\n        cout << result;\n        cin >> n;\n        if(n) cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<30\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> strength; //国の強さ\nmultimap<string,string> adjacentCountry; //隣接した国の関係\nll ans=0;\n\nint rec(map<string,bool> m,ll sum){\n  bool fin=true;\n  map<string,bool>::iterator it = m.begin();\n  while(it != m.end()){\n    //cout << it->first << \" \" << it->second << endl;\n    fin*=it->second;  \n    it++;\n  }\n  if(fin){\n    if(ans < sum)ans=sum;\n    return 0;\n  }\n\n  map<string,bool> preUsed;\n  ll preSum=0;\n  it = m.begin();\n  while(it != m.end()){\n    if(!it->second){\n      preSum=sum;\n      preSum+=strength[it->first];\n      //cout << \"sum = \" << sum  << \", it->first = \" << it->first << endl;\n   \n      map<string,bool>::iterator preIt = m.begin();\n      while(preIt != m.end()){\n\tpreUsed[preIt->first]=preIt->second;\n\t//cout << preIt->first << \" \" << preIt->second << endl;\n\t++preIt;\n      }\n      multimap<string,string>::iterator cpyIt = adjacentCountry.find(it->first); \n     int counter = adjacentCountry.count(it->first);\n      //cout << \"coutner = \" << counter << endl;\n      while(counter-- > 0){\n\t//cout << \"cpyIt->first = \" << cpyIt->first << endl;\n\tpreUsed[cpyIt->second]=true;\n\t//cout << \"cpyIt->second =\" << cpyIt->second << endl;\n\t++cpyIt;\n      }\n      preUsed[it->first]=true;\n      /*\n  map<string,bool>::iterator wr = preUsed.begin();\n      while(wr != preUsed.end()){\n\tcout << wr->first << \" \" << wr->second << endl;\n\t++wr;\n      }\n      cout << \"----------------------------------------^w^----\" << endl;\n      */\n\n\n      rec(preUsed,preSum);\n    }\n\n    ++it;\n  }\n  \n\n\n\n\n}\n\n\nint main(){\n  int n,val,os;\n  string s,oc;\n  map<string,bool> used;\n  ll sum=0;\n\n  while(true){\n    cin >> n;\n    if(n == 0)break;\n    ans=0;\n    used.clear();\n    adjacentCountry.clear();\n    strength.clear();\n    rep(i,n){\n      cin >> s >> val >> os;\n      strength[s]=val;\n      if(!used[s])used[s]=false;\n      rep(j,os){\n\tcin >> oc;\n\tadjacentCountry.insert(multimap<string,string>::value_type(s,oc));      \n      }\n      \n      if(i == 0){\n\tsum = val;\n\tused[s]=true;\n\tmultimap<string,string>::iterator sit = adjacentCountry.begin();\n\t//cout << \"IN  ----------------------------\" << endl;\n\twhile(sit != adjacentCountry.end()){\n\t  used[sit->second]=true;\n\t  //cout << sit->second << \" \" <<used[sit->second] << endl;\n\t  ++sit;\n\t}\n\t//cout << \"OTU ========================\" << endl;\n\n      }\n      \n    }\n\n\n\n\n    /*\n    cout << \"-----------------\" << endl;\n    map<string,bool>::iterator it = used.begin();\n    while(it != used.end()){\n      cout << \"it->first = \" << it->first << endl;\n      cout << it->second << endl;\n      ++it;\n    }\n    cout << \"-------------------\" << endl;\n    */\n\n    rec(used,sum);\n    cout << ans << endl;\n    \n\n\n\n  }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n#include<cassert>\n#include<sstream>\n#include<complex>\n#include<cstdio>\n#include<climits>\n#include<cstdlib>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<ctime>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps) \n#define MAX 40\nusing namespace std;\ntypedef long long ll;\n\nvector<int> G[MAX];\nint N,power[MAX],maxcost;\n\nvoid dfs(bool *color,int cost,int colored,int remain_cost)\n{\n  if(colored == N)\n    {\n      maxcost = max(maxcost,cost);\n      return;\n    }\n\n  if(remain_cost+cost <= maxcost)return;\n\n  rep(i,N)\n    {\n      if(color[i])continue;\n      bool next_color[N];\n      int next_colored = colored;\n      int next_remain_cost = remain_cost;\n      next_remain_cost -= power[i];\n      rep(j,N)next_color[j] = color[j];\n      next_color[i] = true;\n      next_colored++;\n      rep(j,G[i].size())\n\t{\n\t  if(!next_color[G[i][j]])\n\t    {\n\t      next_remain_cost -= power[G[i][j]];\n\t      next_color[G[i][j]] = true;\n\t      next_colored++;\n\t    }\n\t}\n      dfs(next_color,cost+power[i],next_colored,next_remain_cost);\n      if(remain_cost+cost <= maxcost)return;\n    }\n\n}\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      maxcost = -inf;\n      rep(i,N)G[i].clear();\n      map<string,int> getIndex;\n      int cnt = 0,C,total_cost = 0;\n      string A,D;\n      vector<int> B(N);\n      vector<string> name_list;\n      rep(i,N)\n\t{\n\t  cin >> A >> B[i] >> C;\n\t  total_cost += B[i];\n\t  if(getIndex.find(A) == getIndex.end())getIndex[A] = cnt++;\n\t  int from = getIndex[A];\n\t  name_list.push_back(A);\n\t  rep(j,C)\n\t    {\n\t      cin >> D;\n\t      if(getIndex.find(D) == getIndex.end())getIndex[D] = cnt++;\n\t      int to = getIndex[D];\n\t      G[from].push_back(to);\n\t    }\n\t} \n\n      rep(i,N)power[getIndex[name_list[i]]] = B[i];\n\n\n      assert(cnt == N);\n      bool color[N];\n      int colored = 0;\n      rep(i,N)color[i] = false;\n      color[0] = true;\n      colored++;\n      total_cost -= power[0];\n      rep(i,G[0].size())\n\t{\n\t  colored++;\n\t  color[G[0][i]] = true;\n\t  total_cost -= power[G[0][i]];\n\t}\n\n      dfs(color,power[0],colored,total_cost);\n      cout << maxcost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    vector<vector<string>> graph_(n);\n    map<string,int> encode;\n    vector<int> strength(n),sum(n);\n    rep(i,0,n){\n        string a;\n        int b,c;\n        cin >> a >> b >> c;\n        encode[a]=i;\n        strength[i]=b;\n        sum[i]=b;\n        if(i>0) sum[i]+=sum[i-1];\n        rep(j,0,c){\n            string d;\n            cin >> d;\n            graph_[i].push_back(d);\n        }\n    }\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        rep(j,0,graph_[i].size()){\n            graph[i].push_back(encode[graph_[i][j]]);\n        }\n    }\n\n    int maxi=0;\n    function<int(int64_t,int,int)> rec=[&](int64_t s,int i,int k){\n        if(i==n) return maxi=max(maxi,k);\n        if(k+sum[n-1]-sum[i-1]<=maxi) return maxi;\n        int res=rec(s,i+1,k);\n        bool f=true;\n        for(int j:graph[i]) if((s>>j)&1){\n            f=false;\n            break;\n        }\n        if(f) res=max(res,rec(s|(int64_t(1)<<i),i+1,k+strength[i]));\n        return maxi=max(maxi,res);;\n    };\n\n    cout << rec(1,1,strength[0]) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize (\"-O3\")\n#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        int mid = n/2;\n        vi p(n),c(n);\n        vector<vs> s(n);\n        int id = 0;\n        map<string,int> mp;\n        rep(i,n){\n            string t;\n            cin >> t >> p[i] >> c[i];\n            mp[t] = id++;\n            s[i].resize(c[i]);\n            rep(j,c[i]){\n                cin >> s[i][j];\n            }\n        }\n        vi st(mid),ed(n-mid),se(mid);\n        vi sout((1 << mid),0);\n        rep(i,mid){\n            st[i] = (1 << i);\n            rep(j,c[i]){\n                int num = mp[s[i][j]];\n                if(num >= mid){\n                    se[i] |= (1 << (num-mid));\n                }else{\n                    st[i] |= (1 << num);\n                }\n            }\n        }\n        rep(i,n-mid){\n            ed[i] = (1 << i);\n            rep(j,c[i+mid]){\n                int num = mp[s[i+mid][j]];\n                if(num >= mid){\n                    ed[i] |= (1 << (num-mid));\n                }\n            }\n        }\n        vector<bool> dst((1 << mid),false),ded((1 << (n-mid)),false);\n        vi p1((1 << mid),0),p2((1 << (n-mid)),0);\n        vector<int> mx((1 << (n-mid)),0);\n        dst[0] = true;\n        rep(i,(1 << mid)){\n            if(dst[i]){\n                rep(j,mid){\n                    if(!((i >> j) & 1)){\n                        if(!(i & st[j])){\n                            dst[i^(1 << j)] = true;\n                            sout[i^(1 << j)] = sout[i] | se[j];\n                        }\n                    }else{\n                        p1[i] += p[j];\n                    }\n                }\n            }\n        }\n        ded[0] = true;\n        rep(i,(1 << (n-mid))){\n            if(ded[i]){\n                rep(j,n-mid){\n                    if(!((i >> j) & 1)){\n                        if(!(i & ed[j])){\n                            ded[i^(1 << j)] = true;\n                        }\n                    }else{\n                        p2[i] += p[j+mid];\n                    }\n                }\n                mx[i] = p2[i];\n            }else{\n                rep(j,n-mid){\n                    if((i >> j) & 1){\n                        cmx(mx[i],mx[i^(1 << j)]);\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        rep(i,(1 << mid)){\n            if((i & 1) && dst[i]){\n                cmx(ans,p1[i] + mx[((1 << (n-mid))-1) ^ sout[i]]);\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <climits>\n#include <cmath>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\ntypedef vector<int> VI;\ntypedef vector<ll> VL;\ntypedef pair<int, int> ipair;\ntypedef tuple<int, int, int> ituple;\n\n// const int INF = INT_MAX;\n// const ll INF = LLONG_MAX;\n// const int MOD = ((int)1e9 + 7);\n// const ld EPS = (1e-10);\n#define PI acosl(-1)\n#define MAX_N (40 + 2)\n#define SIZE_PER_ONCE 20\n\nconst ull ONE = 1;\n\n// 国の集合の中の総和の最大\null dp[2][1 << SIZE_PER_ONCE];\n\nmap<string, int> name2index;\nvector<string> tmp_neighbor[MAX_N];\nint power[MAX_N];\null neighbor[MAX_N];\n\nvoid set_dp(int dp_index, int start_index, int size) {\n  for (int i = 1; i < (1 << size); i++){\n    ull b = 0;\n    ull score = 0;\n    for (int j = 0; j < size; j++){\n      if ((i & (1 << j)) == 0) {\n        continue;\n      }\n      if ((b & neighbor[start_index + j]) != 0) {\n        score = 0;\n        break;\n      }\n      score += power[start_index + j];\n      b |= ONE << (start_index + j);\n    }\n    dp[dp_index][i] = score;\n  }\n\n  if (start_index == 0) {\n    return;\n  }\n\n  // 高速メビウス変換で最大値を出す\n  for(int i=0; i<size; i++) {\n    for(int s=0; s<(1<<size); s++) {\n      if ((s>>i&1)==1) {\n        dp[dp_index][s]= max(dp[dp_index][s^(1<<i)], dp[dp_index][s]);\n      }\n    }\n  }\n\n}\n\nvoid init() {\n  for (int i = 0; i < MAX_N; i++){\n      tmp_neighbor[i].clear();\n  }\n\n  name2index.clear();\n}\n\nvoid exec(int n){\n  string a;\n  int b, c;\n  string s;\n\n  init();\n\n  for (int i = 0; i < n; i++){\n    cin >> a;\n    scanf(\"%d%d\", &b, &c);\n    name2index[a] = i;\n    power[i] = b;\n\n    for (int j = 0; j < c; j++){\n      cin >> s;\n      // printf(\"|tmp_neighbor[%d]| = %d\\n\", i, tmp_neighbor[i].size());\n      tmp_neighbor[i].push_back(s);\n    }\n  }\n\n  for (int i = 0; i < n; i++){\n    ull tmp = 0;\n    tmp |= ONE << i;\n\n    for (int j = 0; j < tmp_neighbor[i].size(); j++){\n      tmp |= ONE << name2index[tmp_neighbor[i][j]];\n    }\n    // printf(\"neighbor[%d] = %lld\\n\", i, tmp);\n    // cout << static_cast<std::bitset<8> >(tmp) << endl;\n\n    neighbor[i] = tmp;\n  }\n\n  ull ans = 0;\n  if (n <= SIZE_PER_ONCE) {\n    set_dp(0, 0, n);\n\n    for (int i = 0; i < (ONE << n); i++){\n      if ((i & 1) == 1) {\n    // cout << static_cast<std::bitset<16> >(i) << endl;\n        ans = max(ans, dp[0][i]);\n      }\n    }\n  }\n  else {\n    // 前半分を計算\n    set_dp(0, 0, SIZE_PER_ONCE);\n    // 前半分を計算\n    set_dp(1, SIZE_PER_ONCE, n - SIZE_PER_ONCE);\n\n    for (int i = 0; i < (ONE << SIZE_PER_ONCE); i++){\n      if ((i & 1) == 1) {\n        ull tmp = dp[0][i];\n\n        ull tmp_mask = 0, mask = 0;\n        for (int j = 0; j < SIZE_PER_ONCE; j++){\n          if (((i >> j) & 1) == 1) {\n            tmp_mask |= neighbor[j];\n          }\n        }\n        tmp_mask >>= SIZE_PER_ONCE;\n\n        for (int j = 0; j < n - SIZE_PER_ONCE; j++){\n          if (((tmp_mask >> j) & 1) == 0) {\n            mask |= ONE << j;\n          }\n        }\n        tmp += dp[1][mask];\n\n        ans = max(tmp, ans);\n      }\n    }\n  }\n\n  cout << ans << endl;\n}\n\nvoid solve(){\n  int t = 1;\n  while (scanf(\"%d\", &t) != EOF) {\n    if (t == 0) {\n      break;\n    }\n    exec(t);\n  }\n}\n\nint main(){\n  solve();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        int mid = n/2;\n        vi p(n),c(n);\n        vector<vs> s(n);\n        int id = 0;\n        map<string,int> mp;\n        rep(i,n){\n            string t;\n            cin >> t >> p[i] >> c[i];\n            mp[t] = id++;\n            s[i].resize(c[i]);\n            rep(j,c[i]){\n                cin >> s[i][j];\n            }\n        }\n        vi st(mid),ed(n-mid),se(mid);\n        vi sout((1 << mid),0);\n        rep(i,mid){\n            st[i] = (1 << i);\n            rep(j,c[i]){\n                int num = mp[s[i][j]];\n                if(num >= mid){\n                    se[i] |= (1 << (num-mid));\n                }else{\n                    st[i] |= (1 << num);\n                }\n            }\n        }\n        rep(i,n-mid){\n            ed[i] = (1 << i);\n            rep(j,c[i+mid]){\n                int num = mp[s[i+mid][j]];\n                if(num >= mid){\n                    ed[i] |= (1 << (num-mid));\n                }\n            }\n        }\n        rep(i,(1 << mid)){\n            rep(j,mid){\n                if(!((i >> j) & 1)){\n                    sout[i^(1 << j)] = sout[i] | se[j];\n                }\n            }\n        }\n        vector<int> dst((1 << mid),-1),ded((1 << (n-mid)),-1);\n        dst[0] = 0;\n        srep(i,1,(1 << mid)){\n            rep(j,mid){\n                int prv = (i^(1 << j));\n                if(((i >> j) & 1) && dst[prv] >= 0){\n                    if(!(prv & st[j]) && !(dst[prv] & (1 << j))){\n                        dst[i] = dst[prv] | st[j];\n                        break;\n                    }\n                }\n            }\n        }\n        ded[0] = 0;\n        srep(i,1,(1 << (n-mid))){\n            rep(j,n-mid){\n                int prv = (i^(1 << j));\n                if(((i >> j) & 1) && ded[prv] >= 0){\n                    if(!(prv & ed[j]) && !(ded[prv] & (1 << j))){\n                        ded[i] = ded[prv] | ed[j];\n                        break;\n                    }\n                }\n            }\n        }\n        vi p1((1 << mid),0),p2((1 << (n-mid)),0);\n        rep(i,(1 << mid)){\n            rep(j,mid){\n                if((i >> j) & 1){\n                    p1[i] += p[j];\n                }\n            }\n        }\n        rep(i,(1 << (n-mid))){\n            rep(j,n-mid){\n                if((i >> j) & 1){\n                    p2[i] += p[j+mid];\n                }\n            }\n        }\n        vector<int> mx((1 << (n-mid)),0);\n        rep(i,(1 << (n-mid))){\n            if(ded[i] >= 0){\n                mx[i] = p2[i];\n                continue;\n            }\n            rep(j,n-mid){\n                if((i >> j) & 1){\n                    cmx(mx[i],mx[i^(1 << j)]);\n                }\n            }\n        }\n        int ans = 0;\n        rep(i,(1 << mid)){\n            if((i & 1) && dst[i] >= 0){\n                cmx(ans,p1[i] + mx[((1 << (n-mid))-1) ^ sout[i]]);\n            }\n        }\n        cout << ans << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nvector<long long int> G;\nvector<int> B;\nint N;\n\nint solve(int v, long long int t){\n  if(v >= B.size() || t == (1LL<<N) - 1) return 0;\n  int ret = 0;\n  if(!(t>>v & 1)){\n    long long t_ = t | (1LL<<v);\n    t_ |= G[v];\n    ret = B[v] + solve(v+1,t_);\n    /*\n    if(G[v] == 0LL || \n       (G[v].size() == 1 && B[G[v][0]] <= B[v])) return ret;\n    */\n    if(G[v] == 0LL) return ret;\n  }\n  ret = max(ret, solve(v+1,t));\n  return ret;\n}\n\nint main(){\n  while(cin >> N, N){\n    map<string,int> M;\n    vector< vector<string> > D(N);\n    string a;\n    B = vector<int>(N);\n    int c;\n    for(int i = 0; i < N; ++i){\n      cin >> a >> B[i] >> c;\n      M[a] = i;\n      string d;\n      for(int j = 0; j < c; ++j){\n        cin >> d;\n        D[i].push_back(d);\n      }\n    }\n    G = vector<long long int>(N,0LL);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < D[i].size(); ++j){\n        G[i] |= 1LL<<M[D[i][j]];\n      }\n    }\n    long long int t = 1LL;\n    t |= G[0];\n    cout << B[0] + solve(1,t) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    vector<vector<string>> graph_(n);\n    map<string,int> encode;\n    vector<int> strength(n);\n    rep(i,0,n){\n        string a;\n        int b,c;\n        cin >> a >> b >> c;\n        encode[a]=i;\n        strength[i]=b;\n        rep(j,0,c){\n            string d;\n            cin >> d;\n            graph_[i].push_back(d);\n        }\n    }\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        rep(j,0,graph_[i].size()){\n            graph[i].push_back(encode[graph_[i][j]]);\n        }\n    }\n\n    function<int(int,int,int)> rec=[&](int s,int i,int k){\n        if(i==n) return k;\n        int res=0;\n        bool f=true;\n        for(int j:graph[i]) if((s>>j)&1){\n            f=false;\n            break;\n        }\n        res=rec(s,i+1,k);\n        if(f) res=max(res,rec(s|(1<<i),i+1,k+strength[i]));\n        return res;\n    };\n\n    cout << rec(1,1,strength[0]) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint id[40];\nint G[40][40];\nstring name[40];\nint B[40];\nvector<string> D[40];\nint N;\nmap<string, int> m;\n\nint dp[2][1 << 20];\n\nint f(int t, int mask, vector<int>& v) {\n\tint&  d = dp[t][mask];\n\tif(d != -1) return d;\n\td = 0;\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tif(mask >> i & 1) {\n\t\t\td = max(d, f(t, mask ^ (1 << i), v));\n\t\t\tint nmask = mask ^ (1 << i);\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif((mask >> j & 1) && G[v[i]][v[j]]) nmask ^= 1 << j;\n\t\t\t}\n\t\t\td = max(d, f(t, nmask, v) + B[v[i]]);\n\t\t}\n\t}\n\t//cerr << \"mask : \" << mask << \", d : \" << d << endl;\n\treturn d;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> N, N) {\n\t\tm.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> name[i] >> B[i];\n\t\t\tm[name[i]] = i;\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tD[i].assign(C, \"\");\n\t\t\tfor(int j = 0; j < C; j++) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\n\t\t}\n\n\t\tmemset(G, 0, sizeof G);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(auto s : D[i]) {\n\t\t\t\tG[m[name[i]]][m[s]] = G[m[s]][m[name[i]]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> v1, v2;\n\t\tfor(int i = 1; i < N; i++) {\n\t\t\tif(G[0][i]) continue;\n\t\t\tif(i <= N / 2) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\n\t\tmemset(dp, -1, sizeof dp);\n\t\tfor(int i = 0; i < 1 << v1.size(); i++) {\n\t\t\tf(0, i, v1);\n\t\t}\n\t\tfor(int i = 0; i < 1 << v2.size(); i++) {\n\t\t\tf(1, i, v2);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 1 << v2.size(); i++) {\n\t\t\tint sum = dp[1][i];\n\t\t\tint mask = 0;\n\t\t\tfor(int j = 0; j < v1.size(); j++) {\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = 0; k < v2.size(); k++) {\n\t\t\t\t\tif((i >> k & 1) && G[v1[j]][v2[k]]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag) mask ^= 1 << j;\n\t\t\t}\n\t\t\tsum += dp[0][mask];\n\t\t\tans = max(ans, sum);\n\t\t}\n\t\tcout << ans + B[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nvector<int> power;\nvector<vector<int> > adj;\nmap<pair<char, long long>, int> memo;\n\nint dfs(char country, long long ng) {\n\tif(country == power.size())\n\t\treturn 0;\n\n\tif(memo.count(make_pair(country, ng)))\n\t\treturn memo[make_pair(country, ng)];\n\n\tint res = dfs(country + 1, ng);\n\n\tif((ng & (1ll << country)) == 0) {\n\t\tlong long next_ng = ng;\n\t\tfor(int i = 0; i < adj[country].size(); ++i)\n\t\t\tnext_ng |= (1ll << adj[country][i]);\n\n\t\tchmax(res, dfs(country + 1, next_ng) + power[country]);\n\t}\n\n\treturn memo[make_pair(country, ng)] = res;\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tfor(int n = 0; cin >> n, n;) {\n\t\tmap<string, int> convert;\n\t\tvector<vector<string> > d(n);\n\t\tpower.clear();\n\t\tpower.resize(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring a;\n\t\t\tint c;\n\t\t\tcin >> a >> power[i] >> c;\n\n\t\t\tconvert[a] = i;\n\n\t\t\td[i].resize(c);\n\t\t\tfor(int j = 0; j < c; ++j)\n\t\t\t\tcin >> d[i][j];\n\n\t\t}\n\n\t\tadj.clear();\n\t\tadj.resize(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < d[i].size(); ++j)\n\t\t\t\tadj[i].push_back(convert[d[i][j]]);\n\n\t\tlong long ng = 0;\n\t\tfor(int i = 0; i < adj[0].size(); ++i)\n\t\t\tng |= (1ll << adj[0][i]);\n\n\t\tint ans = power[0] + dfs(1, ng);\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int> f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tif (on[no])\n\t\t{\n\t\t\tputs(\"hoge\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tid[t] = id.size();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\nint max_f = 0;\nvoid dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t{\n\t\tmax_swap(max_f, sum);\n\t\treturn;\n\t}\n\n\tif (!(enemy >> d & 1))\n\t\tdfs(d + 1, enemy | on[d], sum + force[d]);\n\tdfs(d + 1, enemy, sum);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t\tid[a] = id.size();\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t\tid[d] = id.size();\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tmax_f = 0;\n\t\tdfs(1, on[0], 0);\n\t\tres += max_f + force[0];\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tmax_f = 0;\n\t\t\t\tdfs(0, 0, 0);\n\t\t\t\tres += max_f;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<ll> power;\nvector<bool> de;\nvector<ll> flag;\n\nvoid preorder(ll p,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tused[p]=true;\n\tpreo.pb(p);\n\tflag[p]=(ll)preo.size();\n\tbool upd=false;\n\tREP(i,(ll)adj[p].size()) if(!used[adj[p][i]]) {\n\t\tupd=true;\n\t\tpreorder(adj[p][i],used,preo,adj);\n\t}\n\tde[p]=!upd;\n}\n\nvoid input(vector<vector<ll>>& adj) {\n\tmap<string,ll> dict;\n\tll cnt=0;\n\tREP(i,n) {\n\t\tstring a;\n\t\tll b,c;\n\t\tcin>>a>>b>>c;\n\t\tif(dict.count(a)==0) {\n\t\t\tdict[a]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p=dict[a];\n\t\tpower[dict[a]]=b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(dict.count(t)==0) {\n\t\t\t\tdict[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tadj[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx,vector<int>& used,vector<ll>& preo,vector<vector<ll>>& adj,ll sum,vector<vector<ll>>& ban) {\n\tif(idx==(ll)preo.size()) {\n\t\treturn sum;\n\t}\n\tif(used[preo[idx]]==0) return dfs(idx+1,used,preo,adj,sum,ban);\n\tll ret=0;\n\tif(preo[idx]!=0&&!de[preo[idx]]) {\n\t\tused[preo[idx]]=0;\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum,ban));\n\t}\n\tused[preo[idx]]=1;\n\tvector<bool> buf((ll)ban[preo[idx]].size());\n\tREP(i,buf.size()) {\n\t\tbuf[i]=used[ban[preo[idx]][i]];\n\t\tused[ban[preo[idx]][i]]=0;\n\t}\n\tret=max(ret,dfs(idx+1,used,preo,adj,sum+power[preo[idx]],ban));\n\tREP(i,buf.size()) {\n\t\tused[ban[preo[idx]][i]]=buf[i];\n\t}\n\tused[preo[idx]]=-1;\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tde.resize(n);\n\tflag.resize(n);\n\tvector<vector<ll>> adj(n);\n\tinput(adj);\n\tvector<bool> used(n,false);\n\tvector<vector<ll>> preo;\n\tREP(i,n) if(!used[i]) {\n\t\tvector<ll> v;\n\t\tpreorder(i,used,v,adj);\n\t\tpreo.pb(v);\n\t}\n\tvector<int> used2(n,-1);\n\tll ans=0;\n\tvector<vector<ll>> ban(n);\n\tREP(i,n) REP(j,(ll)adj[i].size()) {\n\t\tif(flag[adj[i][j]]>flag[i]) ban[i].pb(adj[i][j]);\n\t};\n\tREP(i,preo.size()) ans+=dfs(0,used2,preo[i],adj,0,ban);\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#ifdef __BORLANDC__\n\ttypedef __int64 ll;\n#else\n\ttypedef long long ll;\n#endif\n\nconst ll L1 = 1;\nconst int N = 40;\nint M = 20;\n\nint n;\nll edge[N];\nint power[N];\n\nvoid printbit(ll state){\n\trep(i,n)printf(\"%d\",((L1<<i)&state)>0);puts(\"\");\n}\n\nvoid printedge(){\n\tprintf(\"edge\\n\");\n\trep(i,n)printbit(edge[i]);\n}\n\nbool init(){\n\tcin>>n;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i]=power[i]=0;\n\t\n\tmap<string,int> mp;\n\tvector<string> estr[N];\n\trep(i,n){\n\t\tstring a;\n\t\tint b,c;\n\t\tcin>>a>>b>>c;\n\t\tmp[a]=i;\n\t\tpower[i]=b;\n\t\trep(j,c){\n\t\t\tstring d;\n\t\t\tcin>>d;\n\t\t\testr[i].push_back(d);\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,estr[i].size()){\n\t\t\tedge[i] |= (L1<<mp[estr[i][j]]);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool hasbit(ll state, int bit){return state&(L1<<bit);}\n\nint T = (1<<M);\nconst int TM = (1<<20);\nint half[TM];\n\nint left_search(){\n\trep(i,TM)half[i]=0;\n\t\n\tint maxi = 0;\n\tfor(int i=1;i<T;i+=2){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\trep(j,M){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\t if(edge[j]&i)ok=false;\n\t\t\t\t sum += power[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ok)half[i]=sum;\n\t\tmaxi = max(maxi,half[i]);\n\t}\n\treturn maxi;\n}\n\nint memo[TM];\nint left_memo(int state){\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tint ret = half[state];\n\trep(i,M){\n\t\tif(state&(1<<i)){\n\t\t\tret = max(ret, left_memo(state ^ (1<<i)));\n\t\t}\n\t}\n\treturn memo[state]=ret;\n}\n\nint right_search(){\n\tint ans = 0;\n\tfor(ll i=0; i<(L1<<n); i+=T){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\tll mask = 0;\n\t\treps(j,M,n){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\tif(edge[j]&i)ok=false;\n\t\t\t\tsum+=power[j];\n\t\t\t\tmask |= edge[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ok){\n\t\t\tmask &= (T-1);\n\t\t\tmask ^= (T-1);\n\t\t\t//printf(\"i=%d sum=%d memo[bit]=%d \",i,sum,memo[mask]);\n\t\t\t//printbit(mask);\n\t\t\tans = max(ans, memo[mask]+sum);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid left_dp(){\n\trep(i,TM)memo[i]=-1;\n\t\n\tleft_memo(T-1);\n}\n\nvoid printdp(){\n\trep(i,T){\n\t\tprintf(\"%3d \",memo[i]);printbit(i);\n\t}\n}\nvoid printsearch(){\n\trep(i,T){\n\t\tprintf(\"%3d \",half[i]);printbit(i);\n\t}\n}\nint solve(){\n\tM = (n+1)/2;\n\tT = (1<<M);\n\t\n\tint a = left_search();\n\tleft_dp();\n\t\n\t/*\n\tputs(\"s\");\n\tprintsearch();\n\tputs(\"d\");\n\tprintdp();\n\t*/\n\treturn max(a,right_search());\n}\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n6\nINTERCAL 10 3 Chef Piet COW\nChef 7 3 INTERCAL Piet COW\nPiet 6 2 INTERCAL Chef\nCOW 7 2 INTERCAL Chef\nJ 6 1 A\nA 12 1 J\n0\n\n6\nINTERCAL 20 1 J\nChef 50 3 J A Piet\nPiet 30 2 A Chef\nCOW 15 1 J\nJ 40 3 COW INTERCAL Chef\nA 25 2 Chef Piet\n0\n\n*/"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring a[40];\nint b[40];\nvector<string> d[40];\nmap<string,int> sn;\nvector<int> dn[40];\nint mr[40];\n\nbool cmp(int pa,int pb){\n  return b[pa]>b[pb];\n}\n\nint dfs(long long u,int c,int cm){\n  if(c==n){\n    return cm;\n  }else{\n    int m=0;\n    if(!(u>>mr[c]&1)){\n      int pr=0;\n      for(int i=c;i<n;i++){\n\tif(!(u>>mr[i]&1)){\n\t  pr+=b[mr[i]];\n\t}\n      }\n      if(pr+cm>m){\n\tlong long nu=u|1LL<<mr[c];\n\tfor(int i=0;i<dn[mr[c]].size();i++){\n\t  nu|=1LL<<dn[mr[c]][i];\n\t}\n\tm=dfs(nu,c+1,cm+b[mr[c]]);\n      }\n    }\n    return max(m,dfs(u,c+1,cm));\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    sn.clear();\n    for(int i=0;i<n;i++){\n      int c;\n      cin>>a[i]>>b[i]>>c;\n      sn[a[i]]=i;\n      d[i].resize(c);\n      while(c--){\n\tcin>>d[i][c];\n      }\n    }\n    for(int i=0;i<n;i++){\n      dn[i].resize(n);\n      for(int j=0;j<d[i].size();j++){\n\tdn[i][j]=sn[d[i][j]];\n      }\n    }\n    for(int i=0;i<n;i++){\n      mr[i]=i;\n    }\n    sort(mr,mr+n,cmp);\n    long long n=1;\n    for(int i=0;i<dn[0].size();i++){\n      n|=1LL<<dn[0][i];\n    }\n    cout<<dfs(n,0,b[0])<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cassert>\n#include <cstdio>\nusing namespace std;\n#define MAX 41\n#define TEST 0\n\ntypedef long long int ll;\n\nint n;\nmap<string,int> names;\nint b[MAX],c[MAX];\nstring ds[MAX][MAX];\nint graph[MAX][MAX];\n\n\nint rmax;\nll rmaxs;\n/**\n O(n^2)\n */\nbool isClique(ll bits){\n    for(int i=0;i<n;i++){\n        if(bits&(1LL<<i)){\n            for(int j=0;j<n;++j){\n                if(bits&(1LL<<j)){\n                    if(graph[i][j]==0&&i!=j){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\nvoid rec(ll bits,int sum){//gradually elim-ing vertices\n    if(TEST)\n        printf(\"bits=%llx,sum=%d\\n\",bits,sum);\n    if(sum<=rmax||sum<=0){\n        return;\n    }\n    if((bits&1)==0){//vertex 0 is not in the set\n        return;\n    }\n    int mini=90000;\n    int minv=-1;\n    for(int i=0;i<n;i++){\n        if((bits&(1LL<<i))==0){\n            continue;\n        }\n        int ind=b[i];\n        for(int j=0;j<n;j++){\n            if((bits&(1LL<<j))==0||i==j){\n                continue;\n            }\n            if(graph[i][j]){\n                ind+=b[j];\n            }\n        }\n        if(ind<mini){\n            mini=ind;\n            minv=i;\n        }\n    }\n    if(mini==sum){//clique\n        rmax=sum;\n        rmaxs=bits;\n        return;\n    }\n    //minv:minimum\n    ll set=1LL<<minv;\n    int w=b[minv];\n    for(int i=0;i<n;i++){\n        if((bits&(1LL<<i))&&graph[minv][i]){\n            set|=1LL<<i;\n            w+=b[i];\n        }\n    }\n    if(TEST)\n    printf(\"minv=%d,set=%llx,w=%d\\n\",minv,set,w);\n    rec(set,w);\n    rec(bits&~(1LL<<minv),sum-b[minv]);\n    return;\n}\n\n\nint main(void){\n    while(cin>>n&&n){\n        int sum=0;\n        for(int i=0;i<n;i++){\n            fill_n(graph[i],n,1);\n        }\n        for(int i=0;i<n;i++){\n            string a;\n            cin>>a>>b[i]>>c[i];\n            names.insert(pair<string,int>(a,i));\n            for(int j=0;j<c[i];j++){\n                string t;\n                cin>>t;\n                ds[i][j]=t;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int d=names[ds[i][j]];\n                graph[i][d]=0;\n            }\n            graph[i][i]=0;\n        }\n        ll bits=1;\n        sum=b[0];\n        for(int i=1;i<n;i++){\n            if(graph[0][i]){\n                bits|=1LL<<i;\n                sum+=b[i];\n            }\n        }\n        rmax=0;\n        rmaxs=0;\n        rec(bits,sum);\n        cout<<rmax<<endl;\n        if(TEST){\n            cout<<\"rmaxs\"<<hex<<rmaxs<<dec<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\nconst ld eps = 1e-9;\n\n\nmap<string, int>mp;\nint num = 0;\n\nint getnum(string st) {\n\tif (mp.find(st) == mp.end()) {\n\t\tmp[st] = num++;\n\t}\n\treturn mp[st];\n}\n\n\n\nstruct country {\n\tint num;\n\tint power;\n\tvector<int>connects;\n};\nint N;\nvector<int>rests;\nvoid getans(int now, const vector<country>&cs,vector<int>&oks,int n_power ,int&ans) {\n\tif (now == N-1) {\n\t\tans = max(ans, n_power);\n\t\treturn;\n\t}\n\telse if (rests[now] + n_power < ans) {\n\t\treturn;\n\t}\n\tif (oks[cs[now].num]) {\n\t\tvector<int>nextoks(oks);\n\t\tfor (auto con : cs[now].connects) {\n\t\t\tnextoks[con] = false;\n\t\t}\n\t\tgetans(now + 1, cs, nextoks, n_power + cs[now].power, ans);\n\t}\n\tgetans(now + 1, cs, oks, n_power, ans);\n}\n\nint main() {\n\twhile (1) {cin >> N;\n\tif (!N)break;\n\tmp.clear();\n\tnum = 0;\n\trests.clear();\n\t\tvector<vector<int>>connects(N);\n\t\tvector<int>powers(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name;\n\t\t\tint B, C; cin >> name>> B >> C;\n\t\t\tint from = getnum(name);\n\t\t\tpowers[from] = B;\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tstring d; cin >> d;\n\t\t\t\tint to = getnum(d);\n\t\t\t\tconnects[from].push_back(to);\n\t\t\t}\n\t\t}\n\t\tvector<country>cs;\n\t\tfor (int i = 1; i < N; ++i) {\n\t\t\tcs.push_back(country{ i,powers[i],connects[i] });\n\t\t}\n\t\tsort(cs.begin(), cs.end(), [](const country&l, const country&r) {\n\t\t\treturn l.power > r.power;\n\t\t});\n\n\t\tvector<int>oks(N,1);\n\t\tfor (auto con : connects[0]) {\n\t\t\toks[con] = false;\n\t\t}\n\t\trests=vector<int>(N);\n\n\t\tfor (int i = N -2; i >= 0; --i) {\n\t\t\trests[i] = rests[i + 1] + cs[i].power;\n\t\t}\n\t\tint ans = 0;\n\t\t\n\t\tgetans(0, cs, oks, 0, ans);\n\t\tcout <<powers[0]+ ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nmap<string,int> M;\nvector<string> NG[41];\nstring A[41];\nint n,B[41],ans;\nbool G[41][41];\null g[41];\n\nunordered_set <ull> S[41];\null used;\nvoid dfs(int pos,int sum,ull U){\n\n  ans=max(ans,sum);\n  while(pos<n&&(g[pos]&1LL))pos++;\n  if(pos==n)return;\n  if(S[pos].count(used))return;\n  S[pos].insert(used);\n  ull tmp=used,nU=U;\n  int nsum=sum;\n\n  if(U&(1LL<<pos)){\n    used=0,nU=0,nsum=0;\n    for(int i=0;i<pos;i++){\n      if((tmp&(1LL<<i))==0) continue; \n      if((g[pos]&(1LL<<i))==0) nU|=g[i],used|=(1LL<<i),nsum+=B[i];\n    }\n  }\n  \n  used|=(1LL<<pos);\n  dfs(pos+1,nsum+B[pos],nU|g[pos]);\n  used&=~(1LL<<pos);\n  if(used!=tmp)used=tmp,dfs(pos+1,sum,U);\n} \n\n\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    for(int i=0;i<n;i++) S[i].clear();\n\n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      M[A[i]]=i;\n      NG[i].resize(C);\n      for(int j=0;j<C;j++)cin>>NG[i][j];\n    }\n\n    \n    for(int i=0;i<n;i++){\n      g[i]=1LL<<i;\n      for(int j=0;j<(int)NG[i].size();j++)g[i]|=1LL<<M[NG[i][j]];\n    }\n    \n    ans=0;\n    used=1;\n    dfs(1,B[0],g[0]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vll = vector<ll>;\nusing vvi = vector<vector<int>>;\nusing vvl = vector<vector<ll>>;\nll dp[1LL << 20] = {0};\n\nbool solve() {\n  int n;\n  cin >> n;\n  if (n == 0) return false;\n  map<string, int> mp;\n  vector<string> name(n);\n  vector<vector<string>> ene(n);\n  vector<ll> v(n);\n  for (int i = 0; i < n; i++) {\n    cin >> name[i];\n    mp[name[i]] = i;\n    cin >> v[i];\n    int c;\n    cin >> c;\n    ene[i].resize(c);\n    for (int j = 0; j < c; j++) cin >> ene[i][j];\n  }\n  vector<ll> p(n);\n  for (int i = 0; i < n; i++) {\n    for (auto &s : ene[i]) {\n      p[i] |= 1LL << mp[s];\n      p[mp[s]] |= 1LL << i;\n    }\n  }\n  for (int i = 0; i < (1LL << 20); i++) dp[i] = 0;\n  for (int i = 0; i < (1LL << max(0, n - 20)); i++) {\n    ll ng = 0;\n    for (int j = 0; j < max(0, n - 20); j++) {\n      if (i & (1LL << j)) {\n        ng |= p[j + 20] >> 20;\n      }\n    }\n    for (int j = 0; j < max(0, n - 20); j++) {\n      if (i & (1LL << j)) continue;\n      int next = i | (1LL << j);\n      int nextng = ng | (p[j + 20] >> 20);\n      dp[next] = max(dp[next], dp[i]);\n      if (nextng & next) continue;\n      dp[next] = max(dp[next], dp[i] + v[j + 20]);\n    }\n  }\n\n  ll ans = 0;\n  for (ll i = 0; i < (1 << min(n, 20)); i++) {\n    ll temp = 0;\n    ll ng = 0;\n    if (i % 2 == 0) continue;\n    for (int j = 0; j < min(n, 20); j++) {\n      if (i & (1LL << j)) {\n        temp += v[j];\n        ng |= p[j];\n      }\n    }\n    if (ng & i) continue;\n    int bit = ((1LL << 20) - 1) & (~(ng >> 20));\n    ans = max(ans, temp + dp[bit]);\n  }\n  cout << ans << endl;\n  return true;\n}\n\nint main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  while (solve());\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nstruct MaximumIndependentSet {\n    using T = ll;\n    MaximumIndependentSet(const int n) : n{n}, former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost(n, 1), elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    MaximumIndependentSet(const vector<T>& cost) : n(cost.size()), former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost{cost}, elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    void addEdge(const int from, const int to)\n    {\n        assert(0 <= from);\n        assert(from < n);\n        assert(0 <= to);\n        assert(to < n);\n        elist[from].push_back(to);\n        elist[to].push_back(from);\n    }\n\n    T calculate()\n    {\n        for (ll i = 0; i < latter_maximum; i++) {\n            for (int j = 0; j < latter; j++) {\n                if (i & (1LL << j)) {\n                    bool ok = true;\n                    for (const int to : elist[j + former]) {\n                        if (to >= former) {\n                            if (i & (1LL << (to - former))) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (ok) {\n                        latter_dp[i] = latter_dp[i - (1LL << j)] + cost[j + former];\n                    } else {\n                        latter_dp[i] = latter_dp[i - (1LL << j)];\n                    }\n                    break;\n                }\n            }\n        }\n\n        T maximum = latter_dp[latter_maximum - 1];\n        for (ll i = 1; i < former_maximum; i++) {\n            for (int j = 0; j < former; j++) {\n                if (i & (1LL << j)) {\n                    if (former_dp[i - (1LL << j)] != -INF<T>) {\n                        bool ok = true;\n                        ll mask = former_next[i - (1LL << j)];\n                        for (const int to : elist[j]) {\n                            if (to >= former) {\n                                mask &= ~(1LL << (to - former));\n                            } else {\n                                if (i & (1LL << to)) {\n                                    ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (ok) {\n                            former_dp[i] = former_dp[i - (1LL << j)] + cost[j];\n                            former_next[i] = mask;\n                            maximum = max(maximum, former_dp[i] + latter_dp[mask]);\n                        } else {\n                            former_dp[i] = -INF<T>;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        return maximum;\n    }\n\n    const int n;\n    const int former;\n    const int latter;\n    const ll former_maximum;\n    const ll latter_maximum;\n    const vector<T> cost;\n    vector<vector<int>> elist;\n    vector<T> former_dp;\n    vector<T> latter_dp;\n    vector<ll> former_next;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        ll N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        map<string, ll> id;\n        vector<vector<string>> neighbor(N);\n        vector<ll> power(N);\n        for (ll i = 0; i < N; i++) {\n            string s;\n            cin >> s;\n            id[s] = i;\n            ll B;\n            cin >> B;\n            power[i] = B;\n            ll C;\n            cin >> C;\n            for (ll j = 0; j < C; j++) {\n                string d;\n                cin >> d;\n                neighbor[i].push_back(d);\n            }\n        }\n        set<ll> far;\n        for (ll i = 1; i < N; i++) {\n            far.insert(i);\n        }\n        for (const string& s : neighbor[0]) {\n            far.erase(id[s]);\n        }\n        const ll size = far.size();\n        map<ll, ll> mp;\n        ll cnt = 0;\n        for (const ll f : far) {\n            mp[f] = cnt;\n            cnt++;\n        }\n\n        vector<ll> B;\n        for (const ll f : far) {\n            B.push_back(power[f]);\n        }\n        MaximumIndependentSet st{B};\n        for (const ll f : far) {\n            for (const string& name : neighbor[f]) {\n                const ll ind = id[name];\n                if (far.find(ind) != far.end()) {\n                    st.addEdge(mp[f], mp[ind]);\n                }\n            }\n        }\n        cout << power[0] + st.calculate() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX 45\ntypedef long long ll;\n  \nint N, B[MAX], sum[MAX], mx;\nll ng[MAX];\n\nvoid dfs(ll v, int strength, ll S)\n{\n    mx = max(mx, strength);\n    \n    if (v == N || sum[v] + strength <= mx) {\n        return;\n    }    \n    dfs(v+1, strength, S);\n    if (!(S >> v & 1) && (ng[v] & S) == 0) {\n        dfs(v+1, strength + B[v], S|(1LL<<v));\n    }\n}\n  \nint main()\n{\n    while (cin >> N, N) {\n        string A, D;\n        int C;\n        vector<string> DG[MAX];          \n        map<string, int> s2i;\n        \n        for (int i = 0; i < N; i++) {\n            cin >> A >> B[i] >> C;\n            s2i[A] = i;\n            for (int j = 0; j < C; j++) {\n                cin >> D;\n                DG[i].push_back(D);\n            }\n        }\n        \n        sum[N-1] = B[N-1];\n        for (int i = N-2; i >= 0; i--) {\n            sum[i] = sum[i+1] + B[i];\n        }\n        \n        for (int i = 0; i < N; i++) {\n            int len = DG[i].size();\n            ng[i] = 0;\n            for (int j = 0; j < len; j++) {\n                ll t = s2i[DG[i][j]];\n                ng[i] |= 1LL<<t;\n            }\n        }\n        mx = 0;\n        dfs(1, B[0], 1<<0);\n        cout << mx << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nvector<int> G[44];\nint B[44];\nbool ok[44];\nint idx[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\n\nbool used[55];\nbool sele[55];\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[idx[i]] && !used[idx[i]] && !sele[idx[i]] ) cnt++;\n  }\n  //cout << id << \" \"<< cnt << \" \"<< M << endl;\n  return cnt > M;\n  //return false;\n}\nint solve(int num){\n  int id = idx[num];\n  if( num == N ) return 0;\n  if( sele[id] || ok[id] || used[id] ) return solve(num+1);\n  if( check(num) ) return 0;\n  \n  bool tmp[41]={};\n  sele[id] = true;\n  for(int i=0;i<N;i++) tmp[i] = used[i];\n  for(int i=0;i<(int)G[id].size();i++) used[G[id][i]] = true;\n  int res = solve(num+1)+B[id];\n\n  //cout << \"view\" << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << endl; }\n  //cout << id << \" \" << res << endl;\n  \n  int sum = 0;\n  //for(int i=id;i<N;i++) if( !sele[i] && !ok[i] && !used[i] ) sum += B[i];\n  for(int i=num+1;i<N;i++) if( !sele[idx[i]] && !ok[idx[i]] && !used[idx[i]] ) sum += B[idx[i]];\n\n  for(int i=0;i<N;i++) used[i] = tmp[i];\n  sele[id] = false;\n\n  if( sum > res )\n    res = max( res,solve(num+1) );\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    vector<pair<int,int>> point;\n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id].clear();\n      point.push_back( make_pair( B[id], id ) );\n      assert( id < N );\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id].push_back( nd );\n      }\n    }\n\n    sort( point.rbegin(), point.rend() );\n    for(int i=0;i<(int)point.size();i++)\n      idx[i] = point[i].second;\n\n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i].empty() ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    memset(used,0,sizeof(used));\n    memset(sele,0,sizeof(sele));\n    M = (N+1)/2;\n    if( !G[0].empty() ) res += B[0];\n    sele[0] = true;\n    for(int i=0;i<(int)G[0].size();i++) used[G[0][i]] = true;\n    res += solve(0);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 50;\n\nint N;\nmap<string,int> id;\nGraph g;\nint B[MAXN];\n\nlli adj[MAXN];\nint sum[MAXN];\nint ans;\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nvoid rec(int k, lli bit, int now) {\n  if(now + sum[k] <= ans) return;\n  if(k == N) {\n    ans = now;\n    return;\n  }\n  if(!(bit & (1<<k))) rec(k+1, bit|adj[k], now+B[k]);\n  rec(k+1, bit, now);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    for(int v = 0; v < N; ++v) {\n      adj[v] = 0;//1LL<<v;\n      for(int i = 0; i < g[v].size(); ++i) {\n        int nv = g[v][i];\n        adj[v] |= 1LL<<nv;\n      }\n    }\n\n    sum[N] = 0;\n    for(int v = N-1; v >= 0; --v) sum[v] = sum[v+1] + B[v];\n\n    ans = 0;\n    rec(1, adj[0], B[0]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[40];\nbool G[40][40];\nint NG[40];\nint sum[40];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[idx] <= beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\nvector<int> G2[N];\n\nset<ll> memo;\n\nvoid dfs(int x,int sum,ll S){\n  \n  for(int i=0;i<G2[x].size();i++){\n    \n    int f=0, nx=G2[x][i];\n    \n    for(int j=0;j<n;j++)\n      if((S&(1<<j))&&G[j][nx]) f=1;\n    \n    if(!f){\n      \n      ll nS=S;\n      \n      nS|=(1<<nx);\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[nx]);\n      \n      dfs(x+1,sum+cost[nx],nS);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(!G[i][j]){\n\t  G2[i].push_back(j);\n\t  G2[j].push_back(i);\n\t}\n\t  \n    ans=cost[0];\n    \n    ll S=(1<<0);\n\n    dfs(1,cost[0],S);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<int> DD[41];\nHmap<string, int> hm;\n\nvector<ll> dp0(1<<20);\nvector<ll> dp1(1<<20);\n\nint masks[1<<20];\n\nvoid calc (vl& dp, int s, int e) {\n  int l = e - s;\n  vector<int> ngs(l);\n  rep(i, l) {\n    for(const auto& t: DD[i+s]) {\n      if(s <= t && t < e) {\n\tngs[i] |= (1<<(t-s));\n      }\n    }\n  }\n  rep(mask, 1 << l) {\n    rep(i, l) {\n      if(mask & (1<<i)) continue;\n      if(mask&ngs[i]) continue;\n      int nxt = mask | (1<<i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n    }\n  }\n  rep(mask, 1<<l) {\n    rep(i, l) {\n      if(mask&(1<<i)) {\n\tint pre = mask - (1<<i);\n\tdp[mask] = max(dp[mask], dp[pre]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    hm.clear();\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    rep(i, n) {\n      DD[i].resize(D[i].size());\n      rep(j, D[i].size()) {\n\tDD[i][j] = hm[D[i][j]];\n      }\n    }\n    \n    rep(i, 1<<20) dp0[i] = 0;\n    rep(i, 1<<20) dp1[i] = 0;\n    \n    calc(dp0, 0, n/2);\n    calc(dp1, n/2, n);\n\n    continue;\n    \n    int len = n - (n/2);\n    rep(i, 1<<(n+1)/2) masks[i] = (1<<len)-1;\n    vector<int> ngs(n/2);\n    rep(i, n) {\n      for(const auto& tt : DD[i]) {\n\tint t = tt - n / 2;\n\tif(t < 0) continue;\n\tngs[i] |= (1<<t);\n      }\n    }\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tint tmp = masks[mask]&ngs[i];\n\tmasks[mask] -= tmp;\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp0[mask] + dp1[masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<vector<ll>> g;\nvector<ll> power;\nvector<ll> used;\nvector<P> ord;\n\nvoid build_graph() {\n\tmap<string,ll> dict;\n\tll cnt = 0;\n\tREP(i,n) {\n\t\tstring a; ll b, c;\n\t\tcin >> a >> b >> c;\n\t\tif(dict.count(a) == 0) {\n\t\t\tdict[a] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p = dict[a];\n\t\tpower[dict[a]] = b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tif(dict.count(t) == 0) {\n\t\t\t\tdict[t] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tg[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx, ll sum) {\n\tif(idx == n) return sum;\n\tif(used[ord[idx].second] != -1) return dfs(idx + 1, sum);\n\tll ret = 0;\n\tvector<ll> tmp(n);\n\tREP(i,n) tmp[i] = used[i];\n\tif((ll)g[ord[idx].second].size() > 1) {\n\t\tused[ord[idx].second] = 0;\n\t\tret = max(ret, dfs(idx + 1, sum));\n\t}\n\tused[ord[idx].second] = 1;\n\tREP(i,g[ord[idx].second].size()) used[g[ord[idx].second][i]] = 0;\n\tret = max(ret, dfs(idx + 1, sum + power[ord[idx].second]));\n\tREP(i,n) used[i] = tmp[i];\n\treturn ret;\n}\n\nll solve() {\n\tpower.assign(n,0);\n\tused.assign(n, -1);\n\tord.assign(n,-1);\n\tg.assign(n,vector<ll>(0)); build_graph();\n\tll sum = 0;\n\tREP(i,n) if(used[i] == -1) {\n\t\tif(i == 0) {\n\t\t\tused[i] = 1;\n\t\t\tREP(j,g[i].size()) used[g[i][j]] = 0;\n\t\t\tsum += power[i];\n\t\t\tcontinue;\t\n\t\t}\n\t\tif(g[i].size() == 0) {\n\t\t\tused[i] = 1;\n\t\t\tsum += power[i];\n\t\t}\n\t\tif(g[i].size() == 1 && g[g[i][0]].size() == 1) {\n\t\t\tif(power[i] >= power[g[i][0]]) {\n\t\t\t\tused[i] = 1; used[g[i][0]] = 0;\n\t\t\t\tsum += power[i];\n\t\t\t} else {\n\t\t\t\tused[i] = 0; used[g[i][0]] = 1;\n\t\t\t\tsum += power[g[i][0]];\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n) {\n\t\tord[i].first = (ll)g[i].size();\n\t\tord[i].second = i;\n\t}\n\tsort(ALL(ord)); reverse(ALL(ord));\n\treturn dfs(0, sum);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n\n// Debug\n#define DUMP(x) cerr<<#x<<\" = \"<<(x)<<endl\n\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\n\nusing LL = int64_t;\n\n#define fs first\n#define sc second\n\nconst int64_t MOD = 1e9+7;\n\nint n;\nvector<int> B;\nvector<LL> G;\nvector<int> sum;\n\nvoid solve(LL s, int i, int score, int& bestScore) {\n    if (i == n) {\n        chmax(bestScore, score);\n        return;\n    }\n\n    if (bestScore >= score + (sum[n] - sum[i])) {\n        chmax(bestScore, score);\n        return;\n    }\n\n    if (~s >> i & 1) {\n        solve(s | G[i], i+1, score+B[i], bestScore);\n    }\n    solve(s | 1LL<<i, i+1, score, bestScore);\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    cout << fixed << setprecision(10);\n\n    while (true) {\n        cin >> n;\n        if (n == 0) {\n            break;\n        }\n\n        map<string,int> country;\n        vector<vector<string>> graph(n);\n        B.assign(n, 0);\n        G.assign(n, 0);\n        for (int i = 0; i < n; i++) G[i] = 1LL<<i;\n\n        for (int i = 0; i < n; ++i) {\n            string a; cin >> a; country[a] = i;\n            cin >> B[i];\n            int c; cin >> c;\n            for (int k = 0; k < c; ++k) {\n                string t; cin >> t;\n                graph[i].push_back(t);\n            }\n        }\n\n        for (int i = 0; i < n; ++i) {\n            for (string s : graph[i]) {\n                G[i] |= 1LL<<country[s];\n                G[country[s]] |= 1LL<<i;\n            }\n        }\n\n        sum.assign(n+1, 0);\n        for (int i = 0; i < n; ++i) {\n            sum[i+1] = sum[i] + B[i];\n        }\n\n        int ans = 0;\n        solve(G[0], 1, B[0], ans);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = 1 << 21;\nint X[MAX], Y[MAX], cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tvector<vector<bool>> E(N, vector<bool>(N));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << B[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(X, 0, sizeof(X));\n\t\t\tmemset(Y, 0, sizeof(Y));\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nmask = mask | (1 << i);\n\t\t\t\t\tdp[nmask] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tint tmp = dp[mask];\n\n\t\t\t\tx -= tmp;\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\n\nint N;\nvector<vector<int> > L;\nvector<int> power;\nvector<bool> ok;\nint ans;\nvector<int> total;\n\nvoid calc(int now,int sum){\n\tans=max(ans,sum);\n\n\tint t=0;\n\tfor(int i=now;i<N;i++)\n\t\tt+=power[i];\n\tif(t+sum<=ans) return;\n\n\n//\tif(sum+total[now]<=ans)return;\n\tif(now>=N) return;\n\tif(!ok[now]){calc(now+1,sum);return;}\n\n\tbool can_cut=true;\n\n\tfor(int i=0;i<L[now].size();i++){//枝狩れるかチェック!\n\t\tif(ok[L[now][i]]){can_cut=false;break;}\n\t}\n\n\tvector<int> memo;\n\tfor(int i=0;i<L[now].size();i++){\n\t\tif(ok[L[now][i]]=true){memo.push_back(L[now][i]);ok[L[now][i]]=false;}\n\t}\n\n//\tcout<<\"put \"<<now<<\" \"<<sum+power[now]<<endl;\n\tcalc(now+1,sum+power[now]);\n\n\tfor(int i=0;i<memo.size();i++)\n\t\tok[memo[i]]=true;\n\n\tif(!can_cut) calc(now+1,sum);//枝刈り\n}\n\nint main()\n{\n\twhile(cin>>N && N!=0){\n\t\tans=0;\n\t\tint c=0;\n\t\tmap<string,int> Idx;\n\t\tL.clear();L.resize(N,vector<int>());\n\t\tok.clear();ok.resize(N,true);\n\t\tpower.clear(); power.resize(N,0);\n//\t\tvector<vector<string> > memo(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring nation;\n\t\t\tcin>>nation;\n\t\t\tif(!Idx.count(nation))Idx[nation]=c++;\n\t\t\tcin>>power[Idx[nation]];\n\t\t\tint m=0;cin>>m;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tstring s; cin>>s;\n//\t\t\t\tmemo[i].push_back(s);\n\t\t\t\tif(!Idx.count(s))Idx[s]=c++;\n\t\t\t\tL[Idx[nation]].push_back(Idx[s]);\n\t\t\t}\n\t\t}\n\n\t\ttotal.clear();total.resize(N+1,0);\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\ttotal[i]=total[i+1]+power[i];\n\t\t}\n\n\n\t\tok[0]=false;\n\t\tans+=power[0];\n\t\tfor(int i=0;i<L[0].size();i++)\n\t\t\tok[L[0][i]]=false;\n\n\t\tcalc(1,ans);\n\t\t\n\t\tcout<<ans<<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 45\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], m, ans;\n\nset<ll> memo;\n\nvoid dfs(int x,ll S,int sum){\n\n  ans=max(ans,sum);\n  \n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  if(x==m) return ;\n  \n  for(int i=0;i<n;i++){\n    \n    if(S&(1LL<<i)) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<n;j++)\n\n      if((S&(1LL<<j))&&G[j][i]) f=1;\n    \n    if(!f) dfs(x+1,S|(1LL<<i),sum+cost[i]);\n    \n  }\n  \n}\n\nvoid dfs2(int x,ll S,int sum){\n\n  int f=0;\n  \n  for(int i=0;i<n;i++){\n    if(!(S&(1LL<<i))) continue;\n    for(int j=i+1;j<n;j++){\n      if(!(S&(1LL<<j))) continue;\n      if(G[i][j]) f=1;\n    }\n  }\n  \n  if(!f){\n    ans=max(ans,sum);\n    return ;\n  }\n\n  if(memo.count(S)) return;\n\n  memo.insert(S);\n  \n  if(x==n) return ;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1LL<<i))) continue;\n    \n    for(int j=i+1;j<n;j++){\n      \n      if(!(S&(1LL<<j))) continue;\n      \n      if(G[i][j]){\n\t\n\tif(i) dfs2(x+1,S|(1LL<<i),sum-cost[i]);\n\t\n\tdfs2(x+1,S|(1LL<<j),sum-cost[j]);\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\n\nint main(){\n\n  while(1){\n  \n    cin>>n;\n\n    if(!n) break;\n    \n    map<string,int> num;\n    int cnt=0, sum=0;\n    \n    memset(G,0,sizeof(G));\n\n    for(int i=0;i<n;i++){\n      \n      string s;\n      \n      cin>>s;\n      \n      if(!num.count(s)) num[s]=cnt++;\n      \n      cin>>cost[num[s]];\n\n      if(i) sum+=cost[num[s]];\n      \n      int x;\n      cin>>x;\n      \n      for(int j=0;j<x;j++){\n\t\n\tstring t;\n\t\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\t\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n    \n    ans=0;\n    \n    m=(n-1)/2;\n    \n    memo.clear();\n    \n    dfs(0,1,0);\n\n    dfs2(m+1,(1LL<<n)-1,sum);\n\n    cout<<ans+cost[0]<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_N 41\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Country{\n  int index,power;\n  Country(int index=IINF,int power=IINF):index(index),power(power){}\n  bool operator < (const Country& c)const{ return power > c.power; }\n};\n\nint N,answer,V,sum[MAX_N];\null adj_bitmask[MAX_N];\nCountry c_list[MAX_N];\n\ninline void input(){\n  V = 0;\n  int dex = 0,i_tmp;\n  map<string,int> getIndex;\n  set<string> ban;\n  string s_tmp;\n  rep(i,N){\n    cin >> s_tmp >> i_tmp;\n    if( ban.find(s_tmp) != ban.end() ){\n      cin >> i_tmp;\n      rep(i,i_tmp)cin>>s_tmp;\n      continue;\n    }\n    if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n    int from = getIndex[s_tmp];\n    if( from == 0 ) answer = i_tmp;\n    c_list[from] = Country(from,i_tmp);\n    adj_bitmask[from] = 0ULL;\n    cin >> i_tmp;\n    rep(j,i_tmp){\n      cin >> s_tmp;\n      if( from == 0 ){\n\tban.insert(s_tmp);\n\tcontinue;\n      }\n      if( ban.find(s_tmp) != ban.end() ) continue;\n      if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n      int to = getIndex[s_tmp];\n      adj_bitmask[from] |= (1<<to);\n    }\n  }\n  V = dex;\n}\n\nvoid dfs(int sp,int power,ull friend_bitmask,ull enemy_bitmask){\n  if( power + sum[sp] <= answer )return;\n  answer = max(answer,power);\n  if( sp >= V ) return;\n   \n  REP(i,sp,V){\n    if( ((friend_bitmask|enemy_bitmask)>>(ull)(c_list[i].index)) & 1ULL ) continue;\n    if( friend_bitmask & adj_bitmask[c_list[i].index] ) continue;\n    dfs(i+1,power+c_list[i].power,friend_bitmask|(1ULL<<c_list[i].index),enemy_bitmask|adj_bitmask[c_list[i].index]);\n    dfs(i+1,power,friend_bitmask,enemy_bitmask);\n    break;\n  }\n\n}\n\nint main(){\n  while(cin>>N,N){\n    input();\n    sort(c_list,c_list+V);\n    rep(i,V)sum[i] = 0;\n    sum[V-1] = c_list[V-1].power;\n    for(int i=V-2;i>=0;i--) sum[i] = sum[i+1] + ((c_list[i].index==0)?0:c_list[i].power);\n    dfs(0,answer,1,0);\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nmap<string,int> id;\nmap<string,long long> bit;\nmap<long long, long long> memo;\nvector<int> sum(50);\nint n;\nint maximum;\nstring a[50], d[50][50];\nint b[50], c[50];\n\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint dfs(int p, long long used , int score){\n\t//if(memo.count(used)) return memo[used];\n\tif(score + sum[p] < maximum) return 0;\n\n\tint res = 0;\n\trep(i,n){\n\t\tif(getBit(used,i)) continue;\n\t\t\n\t\tlong long next = used bitor bit[a[i]];\n\t\tres = max(res, dfs(p + 1, next, score + b[i]));\n\t}\n\n\tmaximum = max(maximum, score);\n\treturn memo[used] = res;\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tid.clear();\n\t\tbit.clear();\n\t\tmemo.clear();\n\t\tsum.clear();\n\t\tmaximum = 0;\n\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tsum[i] = b[i];\n\t\t\tid[a[i]] = i;\n\t\t\trep(j,c[i]){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,n - 1){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\t\trep(i,n){\n\t\t\tlong long near = setBit(0,i);\n\t\t\trep(j,c[i]){\n\t\t\t\tnear = setBit(near, id[d[i][j]]);\n\t\t\t}\n\t\t\tbit[a[i]] = near;\n\t\t}\n\n\n\n\t\tdfs(0, bit[a[0]], b[0]);\n\t\tcout << maximum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(v) (v).begin(), (v).end()\n#define resz(v, ...) (v).clear(), (v).resize(__VA_ARGS__)\n#define reps(i, m, n) for(int i = (int)(m); i < (int)(n); i++)\n#define rep(i, n) reps(i, 0, n)\n\ntemplate<class T1, class T2> void chmin(T1 &a, T2 b){if(a>b)a=b;}\ntemplate<class T1, class T2> void chmax(T1 &a, T2 b){if(a<b)a=b;}\n\ntypedef pair<int, int> Pi;\ntypedef tuple<int, int, int> Ti;\ntypedef vector<int> vint;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nint N;\nvint B, C, G, sumB;\nvector<string> A;\nvector< vector<string> > D;\nmap<string, int> mp;\nint ans;\n\nvoid dfs(int idx, int sum, int bit) {\n  chmax(ans, sum);\n  if(idx == N) return;\n  if(sum+sumB[idx] <= ans) return;\n  dfs(idx+1, sum, bit);\n  if(!((bit>>idx)&1)) dfs(idx+1, sum+B[idx], bit|G[idx]);\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  while(cin >> N, N) {\n    resz(A, N);\n    resz(B, N);\n    resz(C, N);\n    resz(D, N);\n    resz(sumB, N);\n    mp.clear();\n    rep(i, N) {\n      cin >> A[i] >> B[i] >> C[i];\n      mp[A[i]] = i;\n      rep(j, i+1) sumB[j] += B[i];\n      resz(D[i], C[i]);\n      rep(j, C[i]) cin >> D[i][j];\n    }\n\n    resz(G, N);\n    rep(i, N) {\n      G[i] |= 1LL<<i;\n      rep(j, C[i]) G[i] |= 1LL<<mp[D[i][j]];\n    }\n\n    ans = 0;\n    dfs(1, B[0], G[0]);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdint>\n#include <cassert>\n#include <functional>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\nnamespace lc {\nstruct Edge {\n\tint to;\n\texplicit Edge(int to) : to(to) { }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType, typename Func>\nvoid enumerate_maximal_independent_sets(\n\tconst AdjacencyList<EdgeType> &graph, Func func)\n{\n\tconst int n = graph.size();\n\tstd::vector<uint64_t> bit_graph(n), incr_bit_graph(n + 1);\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tuint64_t mask = (1ull << i);\n\t\tfor(const auto &e : graph[i]){ mask |= (1ull << e.to); }\n\t\tbit_graph[i] = mask;\n\t\tincr_bit_graph[i] = mask | incr_bit_graph[i + 1];\n\t}\n\tstd::function<void(int, uint64_t, uint64_t)> recur =\n\t\t[&, n](int i, uint64_t picked, uint64_t eliminated) -> void {\n\t\t\tif(i == n){\n\t\t\t\tfunc(picked);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tconst bool force_ignore = ((eliminated & (1ull << i)) != 0);\n\t\t\tint flags = 1; // 1: select v_i, 2: ignore v_i\n\t\t\tif(bit_graph[i] & ~(incr_bit_graph[i + 1] | eliminated)){\n\t\t\t\tflags = (force_ignore ? 2 : 1);\n\t\t\t}else if((incr_bit_graph[i + 1] | eliminated) & (1ull << i)){\n\t\t\t\tflags = (force_ignore ? 2 : 3);\n\t\t\t}\n\t\t\tif(flags & 1){\n\t\t\t\trecur(i + 1, picked | (1ull << i), eliminated | bit_graph[i]);\n\t\t\t}\n\t\t\tif(flags & 2){ recur(i + 1, picked, eliminated); }\n\t\t};\n\trecur(0, 0, 0);\n}\n}\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n};\n}\nusing namespace std;\ntypedef lc::Edge Edge;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tlc::NameTable name_table;\n\t\tvector<int> powers(n);\n\t\tlc::AdjacencyList<Edge> graph(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring u_name;\n\t\t\tint p, m;\n\t\t\tcin >> u_name >> p >> m;\n\t\t\tconst int u = name_table[u_name];\n\t\t\tpowers[u] = p;\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tstring v_name;\n\t\t\t\tcin >> v_name;\n\t\t\t\tconst int v = name_table[v_name];\n\t\t\t\tgraph.add_edge(u, v);\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tlc::enumerate_maximal_independent_sets(graph, [&](uint64_t s){\n\t\t\tif((s & 1) == 0){ return; }\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tif(s & (1ull << i)){ sum += powers[i]; }\n\t\t\t}\n\t\t\tanswer = max(answer, sum);\n\t\t});\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint G[40][40];\nstring name[40];\nint B[40];\nvector<string> D[40];\nint N;\nmap<string, int> m;\n\nint dp[2][1 << 20];\n\nint f(int t, int mask, vector<int>& v) {\n\tint&  d = dp[t][mask];\n\tif(d != -1) return d;\n\td = 0;\n\tfor(int i = 0; i < v.size(); i++) {\n\t\tif(mask >> i & 1) {\n\t\t\td = max(d, f(t, mask ^ (1 << i), v));\n\t\t\tint nmask = mask ^ (1 << i);\n\t\t\tfor(int j = 0; j < v.size(); j++) {\n\t\t\t\tif((mask >> j & 1) && G[v[i]][v[j]]) nmask ^= 1 << j;\n\t\t\t}\n\t\t\td = max(d, f(t, nmask, v) + B[v[i]]);\n\t\t}\n\t}\n\t//cerr << \"mask : \" << mask << \", d : \" << d << endl;\n\treturn d;\n}\n\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> N, N) {\n\t\tm.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> name[i] >> B[i];\n\t\t\tm[name[i]] = i;\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tD[i].assign(C, \"\");\n\t\t\tfor(int j = 0; j < C; j++) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmemset(G, 0, sizeof G);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(auto s : D[i]) {\n\t\t\t\tG[m[name[i]]][m[s]] = G[m[s]][m[name[i]]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tvector<int> v1, v2;\n\t\tfor(int i = 1; i < N; i++) {\n\t\t\tif(G[0][i]) continue;\n\t\t\tif(i <= N / 2) v1.push_back(i);\n\t\t\telse v2.push_back(i);\n\t\t}\n\n\t\tmemset(dp, -1, sizeof dp);\n\t\t/*for(int i = 0; i < 1 << v1.size(); i++) {\n\t\t\tf(0, i, v1);\n\t\t}*/\n\t\tfor(int i = 0; i < 1 << v2.size(); i++) {\n\t\t\tf(1, i, v2);\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < 1 << v2.size(); i++) {\n\t\t\tint sum = dp[1][i];\n\t\t\tint mask = 0;\n\t\t\tfor(int j = 0; j < v1.size(); j++) {\n\t\t\t\tbool flag = true;\n\t\t\t\tfor(int k = 0; k < v2.size(); k++) {\n\t\t\t\t\tif((i >> k & 1) && G[v1[j]][v2[k]]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(flag) mask ^= 1 << j;\n\t\t\t}\n\t\t\tsum += f(0, mask, v1);\n\t\t\tans = max(ans, sum);\n\t\t}\n\t\tcout << ans + B[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\n\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    vector<int> dp0(1<<half);\n    for(int i=0;i<(1<<half);i++){\n        bool isok=true;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                dp0[i]+=b[j];\n                for(int k=0;k<g[j].size();k++){\n                    isok&=!(g[j][k]<half && (1<<g[j][k])&i);\n                }\n            }\n            if(!isok) dp0[i]=-INF;\n        }\n    }\n\n    vector<int> dp1(1<<rest);\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                dp1[i]+=b[j+half];\n                for(int k=0;k<g[j+half].size();k++){\n                    isok&=!(g[j+half][k]>=half && (1<<(g[j+half][k]-half))&i);\n                }\n            }\n            if(!isok) dp1[i]=-INF;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        if(__builtin_popcount(i)==1){\n            int j=__builtin_ctz(i);\n            for(int k=0;k<g[j].size();k++){\n                if(g[j][k]>=half){\n                    opn[i]=opn[i]&(~(1<<(g[j][k]-half)));\n                }\n            }\n        }\n        for(int j=0;j<half;j++){\n            opn[i|(1<<j)]&=opn[i];\n        }\n        res=max(res,dp0[i]+dp1[opn[i]]);\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint ans;\nint n;\nint power[40];\nvector<vector<int> > g;\nvoid solve(int S, int now, int sum) {\n  int t = 0;\n  if (now == n) {\n    ans = max(ans, sum);\n    return;\n  }\n  for (int i=now; i<n; ++i) if (!(S>>i&1)) t += power[i];\n  if (sum + t < ans) return;\n  bool f = 0;\n  FOR(it, g[now]) {\n    if (S>>*it&1) {\n      f = 1;\n      break;\n    }\n  }\n  if (!f) {\n    // use\n    solve(S|1<<now, now+1, sum+power[now]);\n  }\n  solve(S, now+1, sum);\n}\n\nint main() {\n  while(cin>>n,n) {\n    map<string,int> mp;\n    int num = 0;\n    g = vector<vector<int> >(n);\n    REP(i,n) {\n      string A;\n      int B,C;\n      cin >> A >> B >> C;\n      if (mp.count(A) == 0) mp[A] = num++;\n      power[mp[A]] = B;\n      REP(j,C) {\n        string D; cin >> D;\n        if (mp.count(D) == 0) mp[D] = num++;\n        g[mp[A]].push_back(mp[D]);\n        g[mp[D]].push_back(mp[A]);\n      }\n    }\n    ans = 0;\n    solve(1,1,power[0]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint b[50], c[50];\nstring d[50][50];\nstring a[50];\n\nlong long can[50]; //いけないところは1\n\nmap< string , int > java;\nmap< long long, int> dp; \n\nint rec(long long ikeru, long long used){ //いけるとこ0\n  if(dp.find(used)!=dp.end()) return dp[used];\n  int ret = 0;\n  for(int i = 0; i < N; i++){\n    if((ikeru >> i) & 1LL) continue;\n    if((used >> i) & 1LL) continue;\n    if(used & can[i]) continue;\n    ret = max( ret, rec((ikeru|can[i]),used|(1LL << i)) + b[i]);\n  }\n  return dp[used] = ret;\n}\n\nint main(){\n\n  while(cin >> N, N){\n    java.clear();\n    dp.clear();\n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> b[i] >> c[i];\n      java[a[i]] = i;\n\n      for(int j = 0; j < c[i]; j++){\n        cin >> d[i][j];\n      }\n    }\n\n    for(int i = 0; i < N; i++){\n      can[i] = 0;\n      for(int j = 0; j < c[i]; j++){\n        can[i] |= 1 << java[d[i][j]];\n      }\n    }\n\n    \n    cout << rec( can[0], 1) + b[0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int msb(int v) { return 1 << 31 - __builtin_clz(v); }\ninline int lsb(int v) { return v & -v; }\ninline long msb(long v) { return 1ll << 63 - __builtin_clzll(v); }\ninline long lsb(long v) { return v & -v; }\n\n//// idconv ////\ntemplate<class T>\nstruct idconv\n{\n\tvector<T> v;\n\tint get(T t)\n\t{\n\t\tint id = (int)(find(allof(v), t) - v.begin());\n\t\tif (id == v.size()) v.push_back(t);\n\t\treturn id;\n\t}\n};\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tfreopen(\"E:/My Documents/Downloads/judge/E/E1\", \"r\", stdin);\n\tfreopen(\"E:/My Documents/Downloads/judge/E/E1.r\", \"w\", stdout);\n\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline long bit(int idx) { return 1ll << idx; }\n\nint dfs(const vector<pair<int, long>> &nations, long cand, map<long, int> &memo)\n{\n\tif (!cand) return 0;\n\tif (memo.count(cand)) return memo[cand];\n\tpair<int, long> dt = nations[__builtin_ctzll(cand)];\n\treturn memo[cand] = max(dt.first + dfs(nations, cand & ~dt.second, memo), dfs(nations, cand & ~lsb(cand), memo));\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tcerr << testcase << endl;\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tvector<bitset<64>> adj(N);\n\t\tvector<pair<int, long>> nations(N);\n\t\tidconv<string> idc;\n\t\tREP(i, N)\n\t\t{\n\t\t\tint id = idc.get(read<string>());\n\t\t\tint pw = read<int>();\n\t\t\tlong a = bit(id);\n\t\t\tfor (auto &s : readjag<string>()) a |= 1ll << idc.get(s);\n\t\t\tadj[id] = a;\n\t\t\tnations[id] = make_pair(pw, a);\n\t\t}\n\n\t\tint sum = nations[0].first;\n\t\tlong candidate = bit(N) - 1 & ~nations[0].second;\n\n\t\t// グラフ分割\n\t\tREP(k, N) REP(i, N) REP(j, N) adj[i][j] = adj[i][j] | (adj[i][k] & adj[k][j]);\n\n\t\tREP(i, N)\n\t\t{\n\t\t\tlong cand = candidate & adj[i].to_ullong();\n\t\t\tif (cand)\n\t\t\t{\n\t\t\t\tmap<long, int> memo;\n\t\t\t\tsum += dfs(nations, cand, memo);\n\t\t\t\tcandidate &= ~cand;\n\t\t\t}\n\t\t}\n\t\tWRITE(sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> adj[50];\nint power[50];\nbool used[50];\nint ans, rest, sum;\nint N;\nvector<int> per;\nvoid dfs(int k_){\n  if(k_ == N){\n    ans = max(ans,  sum);\n    return ;\n  }\n  int k = per[k_];\n  //printf(\"%d:%d %d %d\\n\", k,sum , rest, ans);\n  if(sum + rest <= ans){\n    return;\n  }\n  bool usedtmp[50];\n  memcpy(usedtmp, used, sizeof(used));\n  int sumtmp = sum;\n  int resttmp = rest;\n  if(!used[k]){\n    used[k] = true;\n    sum += power[k];\n    rest -= power[k];\n    FORIT(it, adj[k])if(!used[*it]){\n      rest -= power[*it];\n      used[*it] = true;\n    }\n    dfs(k_ + 1);\n    memcpy(used, usedtmp, sizeof(used));\n    sum = sumtmp;\n    rest = resttmp;\n  }\n  if(k != 0){\n    if(!used[k])rest -= power[k];\n    used[k] = true;\n    dfs(k_ + 1);\n  }\n}\n \ntypedef pair<int, int> P;\nint main(){\n  while(cin>>N && N){\n    ans = 0, rest = 0, sum = 0;\n    REP(i, 50) adj[i].clear();\n    memset(used, 0, sizeof(used));\n    map<string, int> id;\n    vector<string> adjstr[50];\n    REP(i, N){\n      string s; cin>>s; id[s] = i;\n      cin>>power[i];\n      rest += power[i];\n      int k; cin>>k;\n      while(k--){\n        string str; cin>>str;\n        adjstr[i].push_back(str);\n      }\n    }\n    REP(i, N){\n      REP(j, adjstr[i].size()){\n        adj[i].push_back(id[adjstr[i][j]]);\n      }\n    }\n    vector<P> ps(N-1);\n    REP(i, N-1)ps[i] = P(-power[i+1], i+1);\n    sort(ps.begin(), ps.end());\n    per = vector<int>(N, 0);\n    REP(i, N-1) per[i+1] = ps[i].second;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nchar str[50];\nstring name[50];\nint b[50];\nint c[50];\nstring d[50][50];\nint g[50][50];\nint n;\nint deg[50];\nint dfs(vector<int>use){\n\tbool ok=true;\n\tint ret=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(use[i]==1)ret+=b[i];\n\t\tif(use[i]==-1)ok=false;\n\t}\n\tif(ok){\n\t\t/*if(ret>40){\n\t\t\tfor(int i=0;i<use.size();i++)printf(\"%d \",use[i]);\n\t\t\tprintf(\": %d\\n\",ret);\n\t\t}*/\n\t\treturn ret;\n\t}\n\tint m=-1;\n\tint at=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]){\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<n;j++)if(g[i][j]&&!~use[j])cnt++;\n\t\t\tif(m<cnt){\n\t\t\t\tm=deg[i];at=i;\n\t\t\t}\n\t\t}\n\t}\n\t// use\n\tret=0;\n\tvector<int> to=use;\n\tto[at]=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]&&g[at][i]){\n\t\t\tto[i]=0;\n\t\t//\tfor(int j=0;j<n;j++)if(g[i][j])deg[i]--;\n\t\t}\n\t}\n\tret=max(ret,dfs(to));\n\t//for(int i=0;i<n;i++)if(to[i]==0&&use[i]==-1)for(int j=0;j<n;j++)if(g[i][j])deg[j]++;\n\t// non use\n\tto=use;\n\tto[at]=0;\n//\tfor(int i=0;i<n;i++)if(g[at][i])deg[i]--;\n\tret=max(ret,dfs(to));\n//\tfor(int i=0;i<n;i++)if(g[at][i])deg[i]++;\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tmap<string,int>m;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint p,q;scanf(\"%s%d%d\",str,&p,&q);\n\t\t\tname[i]=str;\n\t\t\tb[i]=p;\n\t\t\tc[i]=q;\n\t\t\tm[name[i]]=i;\n\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\tscanf(\"%s\",str);\n\t\t\t\td[i][j]=str;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<c[i];j++)\n\t\t\tg[i][m[d[i][j]]]=1;\n\t\tfor(int i=0;i<a;i++)deg[i]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)deg[i]+=g[i][j];\n//\t\tfor(int i=0;i<a;i++){\n\t//\t\tfor(int j=0;j<a;j++)printf(\"%d \",g[i][j]);printf(\"\\n\");\n\t\t//}\n\n\t\tvector<int> s(a,-1);\n\t\ts[0]=1;\n\t\tfor(int i=0;i<a;i++)if(g[0][i])s[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]==0)s[i]=1;\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]==1){\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(g[i][j]&&deg[j]==1){\n\t\t\t\t\t\tif(i&&j){\n\t\t\t\t\t\t\tif(b[i]>=b[j]){\n\t\t\t\t\t\t\t\ts[i]=1;s[j]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(s));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\ntemplate<class T>\nclass IdMaker{\npublic:\n  std::map<T,int> _m;\n  int getId(const T &v){\n    if(_m.find(v) == _m.end()){\n      int next = _m.size();\n      return _m[v] = next;\n    }\n    return _m[v];\n  }\n};\n\nll adj[40];\nint str[40];\nint memo[40];\nint ans;\n\nvoid solve(ll flag, int now){\n  ll ff = flag;\n\n  while(ff){\n    const ll f = ff & (-ff);\n    const int pos = __builtin_ctzl(f);\n    if((adj[pos] & flag) == 0){\n      now += str[pos];\n      flag ^= f;\n    }\n    ff ^= f;\n  }\n\n  ans = max(ans, now);\n  if(now + memo[__builtin_ctzl(flag)] <= ans)\n    return;\n\n  while(flag){\n    const ll f = flag & (-flag);\n    const int pos = __builtin_ctzl(f);\n    solve((flag ^ (1ll << pos)) & (~adj[pos]), now + str[pos]);\n    flag ^= f;\n  }\n}\n\nint main(){\n  while(const int n = getInt()){\n    IdMaker<string> idm;\n\n    REP(i,n){\n      string s; cin >> s;\n      str[idm.getId(s)] = getInt();\n      const int m = getInt();\n      adj[idm.getId(s)] = 0;\n      REP(j,m){\n        string a; cin >> a;\n        adj[idm.getId(s)] |= (1ll << idm.getId(a));\n      }\n    }\n\n    REP(i,n) memo[i] = 0;\n    REP(i,n)\n      for(int j = i; j < n; j++)\n        memo[i] += str[j];\n\n    ll start = (1ll << n) - 1;\n    start ^= 1;\n    start ^= adj[0];\n\n    ans = 0;\n    solve(start, str[0]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstring a[45], d[45][45];\nint b[45], c[45];\nvector<int> g[45];\nmap<string, int> mp;\nint n;\nbool del[45];\n\nint func(int v, vector<int>& used) {\n\tif(v == n) return 0;\n\tif(del[v]) return func(v+1, used);\n\t//cout << \"v:\" << v << endl;\n\t//for(auto i: used) cout << i << \" \";\n\t//cout << endl;\n\t\n\tint ret = 0;\n\tif(!used[v]) {\n\t\tvector<int> n = {v};\n\t\tfor(int i: g[v]) if(!used[i]) n.push_back(i);\n\t\tfor(int i: n) used[i] = 1;\n\t\tret = max(ret, func(v+1, used) + b[v]);\n\t\tfor(int i: n) used[i] = 0;\n\t}\n\t\t\n\tint d = 0;\n\tfor(int i: g[v]) if(!used[i]) ++d;\n\t//cout << \"d:\" << d << endl;\n\tif(!used[v]) {\n\t\tused[v] = 1;\n\t\tret = max(ret, func(v+1, used));\n\t\tused[v] = 0;\n\t} else {\n\t\tret = max(ret, func(v+1, used));\n\t}\n\t\n\t//cout << \"v:\" << v << \" \" << ret << endl;\n\treturn ret;\n}\n\nint main() {\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tmp.clear();\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tfor(int j=0; j<c[i]; ++j) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t\tmp[a[i]] = i;\n\t\t}\n\t\tmemset(del, false, sizeof(del));\n\t\tdel[0] = true;\n\t\tfor(int i=0; i<c[0]; ++i) {\n\t\t\tdel[mp[d[0][i]]] = true;\n\t\t}\n\t\tint cnt = 0;\n\t\tfor(int i=0; i<n; ++i) {\n\t\t\tg[i].clear();\n\t\t\tif(del[i]) continue;\n\t\t\tfor(int j=0; j<c[i]; ++j) {\n\t\t\t\tif(!del[mp[d[i][j]]]) {\n\t\t\t\t\tg[i].push_back(mp[d[i][j]]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t}\n\t\t//for(int i=0; i<n; ++i) {\n\t\t//\tcout << \"i:\" << i << endl;\n\t\t//\tfor(auto j: g[i]) cout << j << \" \";\n\t\t//\tcout << endl;\n\t\t//}\n\t\tvector<int> used(n, 0);\n\t\tcout << func(0, used) + b[0] << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nusing ll = int;\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<ll> d0[41];\nvector<ll> d1[41];\n\nll dp0[1<<21];\nll dp1[1<<21];\nll maskNg0[1<<21];\nll maskNg1[1<<21];\nll maskNg2[1<<21];\n\nvoid calc(ll* dp, ll l, ll r, ll* maskNg) {\n  rep(mask, 1 << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1<<i)) continue;\n      ll nxt = mask | (1 << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    ll l = 0, m = n/2, r = n;\n\n    unordered_map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    rep(i, n) {\n      d0[i].clear();\n      d1[i].clear();\n      rep(j, D[i].size()) {\n\tint k = mp[D[i][j]];\n\tif(k < m) d0[i].push_back(k);\n\telse d1[i].push_back(k);\n      }\n    }\n  \n    rep(i, 1<<(m - l)) maskNg0[i] = maskNg2[i] = 0;\n    rep(i, 1<<(r - m)) maskNg1[i] = 0;\n    \n    rep(i, m - l) {\n      auto& mask = maskNg0[i];\n      rep(j, d0[i].size()) {\n\tll k = d0[i][j];\n\tif(k >= m) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg1[i];\n      rep(j, d1[i + m].size()) {\n\tll k = d1[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg2[i];\n      rep(j, d1[i].size()) {\n\tll k = d1[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n\n    rep(i, 1 << (m - l)) dp0[i] = 0;\n    rep(i, 1 << (r - m)) dp1[i] = 0;\n    calc(dp0, l, m, maskNg0);\n    calc(dp1, m, r, maskNg1);\n\n    rep(mask, (1 << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1<<i)]);\n      }\n    }\n    \n    ll ans = 0;\n    rep(x, 1<<(m - l)) {\n      if(x&1) {\n\tll y = (1<<(r - m)) - 1;\n\trep(i, m - l) {\n\t  if(x & (1 << i)) {\n\t    y -= (y & maskNg2[i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<bitset<40> > neighbor;\nvector<int> strong;\n\nvector<vector<int> > memo;\n\nint solve(int i, bitset<40> ng)\n{\n    if(i == -1)\n        return 0;\n\n    bitset<40> ng2((1<<18) - 1);\n    ng2 &= ng;\n    if(i < 18 && memo[i][ng2.to_ulong()] != -1)\n        return memo[i][ng2.to_ulong()];\n\n    int ret = solve(i-1, ng);\n    if(!ng[i])\n        ret = max(ret, solve(i-1, ng |= neighbor[i]) + strong[i]);\n\n    if(i < 18)\n        memo[i][ng2.to_ulong()] = ret;\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<string> > d(n);\n        strong.resize(n);\n        for(int i=n-1; i>=0; --i){\n            string s;\n            int m;\n            cin >> s >> strong[i] >> m;\n            index[s] = i;\n            d[i].resize(m);\n            for(int j=0; j<m; ++j)\n                cin >> d[i][j];\n        }\n\n        neighbor.assign(n, 0);\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<d[i].size(); ++j){\n                int k = index[d[i][j]];\n                neighbor[i][k] = true;\n            }\n        }\n\n        memo.assign(18, vector<int>(1<<18, -1));\n        cout << (solve(n-2, neighbor[n-1]) + strong[n-1]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nmap<string,int> id;\nvector<int> G[51];\nint p[51];\nint ng[51];\nint ng2[51];\nint dp[1<<21];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tid.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tmemset(ng,0,sizeof(ng));\n\t\tmemset(ng2,0,sizeof(ng2));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a;\n\t\t\tint b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif(id.find(a)==id.end())id[a]=(int)id.size()-1;\n\t\t\tp[id[a]]=b;\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif(id.find(d)==id.end())id[d]=(int)id.size()-1;\n\t\t\t\tG[id[a]].push_back(id[d]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tif(G[i][j]<(n/2)){\n\t\t\t\t\tng[i]+=(1<<G[i][j]);\n\t\t\t\t}else{\n\t\t\t\t\tng2[i]+=1<<(G[i][j]-n/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint rest=n-n/2;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<(1<<(n/2));i++){\n\t\t\tint flag2=0,sum=0;\n\t\t\tbool ok=true;\n\t\t\tif(!(i&1))continue;\n\t\t\tfor(int j=0;j<n/2;j++){\n\t\t\t\tif(i>>j & 1){\n\t\t\t\t\tif(i & ng[j])ok=false;\n\t\t\t\t\tflag2|=ng2[j];\n\t\t\t\t\tsum+=p[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tdp[flag2]=max(dp[flag2],sum);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<rest);i++){\n\t\t\tfor(int j=0;j<rest;j++){\n\t\t\t\tif(i>>j & 1)dp[i]=max(dp[i-(1<<j)],dp[i]);\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<(1<<rest);i++){\n\t\t\tint flag=0,sum=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<rest;j++){\n\t\t\t\tif(i>>j & 1){\n\t\t\t\t\tif(i & ng2[n/2+j])ok=false;\n\t\t\t\t\tflag|=ng2[n/2+j];\n\t\t\t\t\tsum+=p[n/2+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok && dp[(1<<rest)-1-i]>=0)res=max(res,sum+dp[(1<<rest)-1-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], cf[64], ct[64];\nint dp[1<<20];\n\nint solve() {\n    const int n = N / 2, m = N - n;\n    const int nn = 1<<n, mm = 1<<m;\n    memset(cf, 0, sizeof(cf));\n    rep (i, n) rep (j, n) if (g[i][j]) cf[i] |= 1<<j;\n    rep (i, m) rep (j, m) if (g[i+n][j+n]) cf[i+n] |= 1<<j;\n    rep (i, m) rep (j, n) if (g[i+n][j]) ct[i] |= 1<<j;\n    rep (i, nn) dp[i] = 0;\n    rep (b, nn) {\n        if (b&1) {\n            bool ok = true;\n            rep (i, n) if (b&(1<<i) && b&cf[i]) { ok = false; break; }\n            if (ok) {\n                int s = 0;\n                rep (i, n) if (b&(1<<i)) s += B[i];\n                dp[b] = max(dp[b], s);\n            }\n        }\n        rep (i, n) dp[b|(1<<i)] = max(dp[b|(1<<i)], dp[b]);\n    }\n    int ans = 0;\n    rep (b, mm) {\n        bool ok = true;\n        rep (i, m) if (b&(1<<i) && b&cf[i+n]) { ok = false; break; }\n        if (!ok) continue;\n        int s = 0;\n        rep (i, m) if (b&(1<<i)) s += B[i+n];\n        int z = 0;\n        rep (i, m) if (b&(1<<i)) z |= ct[i];\n        ans = max(ans, dp[nn-1-z] + s);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<30\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> strength; //国の強さ\nmultimap<string,string> adjacentCountry; //隣接した国の関係\nll ans=0;\n\nint rec(map<string,bool> m,ll sum){\n  bool fin=true;\n  map<string,bool>::iterator it = m.begin();\n  while(it != m.end()){\n    //cout << it->first << \" \" << it->second << endl;\n    fin*=it->second;  \n    it++;\n  }\n  if(fin){\n    if(ans < sum)ans=sum;\n    return 0;\n  }\n\n  map<string,bool> preUsed;\n  ll preSum=0;\n  it = m.begin();\n  while(it != m.end()){\n    if(!it->second){\n      preSum=sum;\n      preSum+=strength[it->first];\n      //cout << \"sum = \" << sum  << \", it->first = \" << it->first << endl;\n   \n      map<string,bool>::iterator preIt = m.begin();\n      while(preIt != m.end()){\n\tpreUsed[preIt->first]=preIt->second;\n\t//cout << preIt->first << \" \" << preIt->second << endl;\n\t++preIt;\n      }\n      multimap<string,string>::iterator cpyIt = adjacentCountry.find(it->first); \n     int counter = adjacentCountry.count(it->first);\n      //cout << \"coutner = \" << counter << endl;\n      while(counter-- > 0){\n\t//cout << \"cpyIt->first = \" << cpyIt->first << endl;\n\tpreUsed[cpyIt->second]=true;\n\t//cout << \"cpyIt->second =\" << cpyIt->second << endl;\n\t++cpyIt;\n      }\n      preUsed[it->first]=true;\n      /*\n  map<string,bool>::iterator wr = preUsed.begin();\n      while(wr != preUsed.end()){\n\tcout << wr->first << \" \" << wr->second << endl;\n\t++wr;\n      }\n      cout << \"----------------------------------------^w^----\" << endl;\n      */\n\n\n      rec(preUsed,preSum);\n    }\n\n    ++it;\n  }\n  \n\n\n\n\n}\n\n\nint main(){\n  int n,val,os;\n  string s,oc;\n  map<string,bool> used;\n  ll sum=0;\n\n  while(true){\n    cin >> n;\n    if(n == 0)break;\n    ans=0;\n    used.clear();\n    adjacentCountry.clear();\n    strength.clear();\n    rep(i,n){\n      cin >> s >> val >> os;\n      strength[s]=val;\n      if(!used[s])used[s]=false;\n      rep(j,os){\n\tcin >> oc;\n\tadjacentCountry.insert(multimap<string,string>::value_type(s,oc));      \n      }\n      \n      if(i == 0){\n\tsum = val;\n\tused[s]=true;\n\tmultimap<string,string>::iterator sit = adjacentCountry.begin();\n\t//cout << \"IN  ----------------------------\" << endl;\n\twhile(sit != adjacentCountry.end()){\n\t  used[sit->second]=true;\n\t  //cout << sit->second << \" \" <<used[sit->second] << endl;\n\t  ++sit;\n\t}\n\t//cout << \"OTU ========================\" << endl;\n\n      }\n      \n    }\n\n\n\n\n    /*\n    cout << \"-----------------\" << endl;\n    map<string,bool>::iterator it = used.begin();\n    while(it != used.end()){\n      cout << \"it->first = \" << it->first << endl;\n      cout << it->second << endl;\n      ++it;\n    }\n    cout << \"-------------------\" << endl;\n    */\n\n    rec(used,sum);\n    cout << ans << endl;\n    \n\n\n\n  }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], dig[64];\nint vis[64], use[64], conf[64];\nvector<pair<int, int> > que;\n\nvoid coll(int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    que.push_back(mp(dig[at], at));\n    rep (i, N) if (g[at][i]) coll(i);\n}\n\nint rec(int ix) {\n    if (ix == -1) return 0;\n    for (int i = ix+1; i < (int)que.size(); i++) {\n        const int x = que[i].second;\n        if (use[x] == 0 && conf[x] == 0) {\n            bool some = false;\n            rep (j, ix) {\n                const int y = que[j].second;\n                if (g[x][y]) some = true;\n            }\n            if (some == false) return -INF;\n        }\n    }\n    const int at = que[ix].second;\n    int ans = -INF;\n    if (conf[at] == 0) {\n        rep (i, N) if (g[at][i]) conf[i]++;\n        use[at] = 1;\n        ans = max(ans, rec(ix-1) + B[at]);\n        rep (i, N) if (g[at][i]) conf[i]--;\n        use[at] = 0;\n    }\n    if (at != 0) ans = max(ans, rec(ix-1));\n    return ans;\n}\n\nint solve() {\n    rep (i, N) dig[i] = C[i];\n    memset(use, 0, sizeof(use));\n    memset(conf, 0, sizeof(conf));\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (vis[i] == 0) {\n        que.clear();\n        coll(i);\n        sort(que.begin(), que.end());\n        ans += rec(que.size()-1);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\ntypedef long long ll;\n\ntemplate <typename _Func>\nvoid enumerate_maximal_independent_sets_recur(\n\tconst vector<ll> &conn, const vector<ll> &iconn, _Func &func,\n\tint i = 0, ll picked = 0, ll eliminated = 0)\n{\n\tint n = conn.size();\n\tif(i == n){\n\t\tfunc(picked);\n\t}else if(!((iconn[i + 1] | eliminated) & (1ll << i))){\n\t\tenumerate_maximal_independent_sets_recur(\n\t\t\tconn, iconn, func, i + 1,\n\t\t\tpicked | (1ll << i), eliminated | conn[i]);\n\t}else{\n\t\tenumerate_maximal_independent_sets_recur(\n\t\t\tconn, iconn, func, i + 1, picked, eliminated);\n\t\tif(!(eliminated & (1ll << i))){\n\t\t\tenumerate_maximal_independent_sets_recur(\n\t\t\t\tconn, iconn, func, i + 1,\n\t\t\t\tpicked | (1ll << i), eliminated | conn[i]);\n\t\t}\n\t}\n}\n\ntemplate <typename _Func>\nvoid enumerate_maximal_independent_sets(\n\tconst vector< vector<int> > &conn, _Func &func)\n{\n\tint n = conn.size();\n\tvector<ll> bitconn(n), ibitconn(n + 1);\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tll mask = 0;\n\t\tfor(int j = 0; j < conn[i].size(); ++j){\n\t\t\tmask |= (1ll << conn[i][j]);\n\t\t}\n\t\tbitconn[i] = mask;\n\t\tibitconn[i] = mask | ibitconn[i + 1];\n\t}\n\tenumerate_maximal_independent_sets_recur(bitconn, ibitconn, func);\n}\n\nstruct Solver {\n\tSolver() : power(), answer(0) { }\n\tvector<int> power;\n\tint answer;\n\tvoid operator()(ll picked){\n\t\tint n = power.size();\n\t\tif(picked & 1ll){\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < n; ++j){\n\t\t\t\tif(picked & (1ll << j)){ sum += power[j]; }\n\t\t\t}\n\t\t\tanswer = max(answer, sum);\n\t\t}\n\t}\n};\n\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint N;\n\t\tcin >> N;\n\t\tif(N == 0){ break; }\n\t\tvector< vector<int> > conn(N);\n\t\tvector<int> power(N);\n\t\tmap<string, int> nametable;\n\t\tfor(int i = 0; i < N; ++i){\n\t\t\tstring A;\n\t\t\tint B, C;\n\t\t\tcin >> A >> B >> C;\n\t\t\tint aid = nametable.size();\n\t\t\tif(nametable.find(A) == nametable.end()){\n\t\t\t\tnametable[A] = aid;\n\t\t\t}else{\n\t\t\t\taid = nametable[A];\n\t\t\t}\n\t\t\tpower[aid] = B;\n\t\t\tfor(int j = 0; j < C; ++j){\n\t\t\t\tstring D;\n\t\t\t\tcin >> D;\n\t\t\t\tint did = nametable.size();\n\t\t\t\tif(nametable.find(D) == nametable.end()){\n\t\t\t\t\tnametable[D] = did;\n\t\t\t\t}else{\n\t\t\t\t\tdid = nametable[D];\n\t\t\t\t}\n\t\t\t\tconn[aid].push_back(did);\n\t\t\t}\n\t\t}\n\t\tSolver solver;\n\t\tsolver.power = power;\n\t\tenumerate_maximal_independent_sets(conn, solver);\n\t\tcout << solver.answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i=j; i<k;++i)\n#define rep(i,j) reps(i,0,j)\n#define pb emplace_back\n#define mk make_pair\n\nint n;\nvector<string> a;\nvector<int> b;\nvector<vector<string>> d;\nvector<vector<int>> g;\nvector<long long> e;\n\ntypedef long long ll;\n\nint dfs(int i, ll s) {\n\tif(i == n) {\n\t\treturn 0;\n\t}\n\n\tif((s >> i) & 1) {\n\t\treturn dfs(i + 1, s);\n\t}\n\n\tint ret = 0;\n\n\tif(i != 0 && !(g[i].size() == 1 && ((s >> g[i][0]) & 1))) {\n\t\tret = dfs(i + 1, s);\n\t}\n\n\t{\n\t\tll ns = s | e[i];\n\n\t\tret = max(ret, dfs(i + 1, ns) + b[i]);\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\ta = vector<string>(n);\n\t\tb = vector<int>(n);\n\t\td = vector<vector<string>>(n);\n\t\te = vector<long long>(n);\n\t\trep(i, n) {\n\t\t\tint c;\n\t\t\tcin >> a[i] >> b[i] >> c;\n\t\t\td[i].resize(c);\n\n\t\t\trep(j, c) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> m;\n\t\trep(i, n) {\n\t\t\tm.insert(make_pair(a[i], m.size()));\n\t\t}\n\n\t\tg = vector<vector<int>>(n);\n\n\t\trep(i, n) {\n\t\t\te[i] = 1LL << i;\n\t\t\tfor(auto to : d[i]) {\n\t\t\t\tg[i].push_back(m[to]);\n\t\t\t\te[i] = e[i] | (1LL << g[i].back());\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(0, 0) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\tif (used[names[pos].first])continue;\n\t\trest -= names[pos].second;\n\t\tused[names[pos].first] = 1;\n\t\tvector<string> c;\n\t\tint rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\trest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\trest = rest1;\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tbmap.clear();\n\t\tans = 0;\n\t\tmb = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\t//vector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\t//list.push_back(a);\n\t\t\t\tbuf[name].push_back(a);\n\t\t\t\t//buf[a].push_back(name);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tused[names[0].first] = 1;\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tused[a] = 1;\n\t\t\tmb -= bmap[a];\n\t\t}\n\t\tdfs(1, names[0].second,mb-names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, t, ans;\nmap<string, int> mp;\nvi power;\nvector<vi> es;\nvi sum;\n\nvoid solve(int i, ll team, int sumpow)\n{\n\tif (i == t)\n\t{\n\t\tchmax(ans, sumpow);\n\t\treturn;\n\t}\n\tif (sumpow + sum[i + 1] - sum[i] <= ans) return;\n\tbool f = true;\n\tfor (auto k:es[i])\n\t{\n\t\tif ((team >> k) & 1)\n\t\t{\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (f) solve(i + 1, team | (1ll << i), sumpow + power[i]);\n\tsolve(i + 1, team, sumpow);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> n, n)\n\t{\n\t\tans = 0;\n\t\tmp.clear(); power.resize(n); es.resize(n); sum.resize(n+1);\n\t\tt = 0;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (!mp.count(s)) mp[s] = t++;\n\t\t\tint tmp = mp[s];\n\t\t\tint p; cin >> p;\n\t\t\tpower[tmp] = p;\n\t\t\tint m; cin >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring a; cin >> a;\t\t\t\n\t\t\t\tif (!mp.count(a)) mp[a] = t++;\n\t\t\t\tint op = mp[a];\n\t\t\t\tes[tmp].push_back(op);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) sum[i + 1] = sum[i] + power[i];\n\t\tsolve(1, 1, power[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 45\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], m, ans;\n\nset<ll> memo;\n\nvoid dfs(int x,ll S,int sum){\n\n  ans=max(ans,sum);\n  \n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  if(x==m) return ;\n  \n  for(int i=0;i<n;i++){\n    \n    if(S&(1LL<<i)) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<n;j++)\n\n      if((S&(1LL<<j))&&G[j][i]) f=1;\n    \n    if(!f) dfs(x+1,S|(1LL<<i),sum+cost[i]);\n    \n  }\n  \n}\n\nvoid dfs2(int x,ll S,int sum){\n\n  int f=0;\n  \n  for(int i=0;i<n;i++){\n    if(!(S&(1LL<<i))) continue;\n    for(int j=i+1;j<n;j++){\n      if(!(S&(1LL<<j))) continue;\n      if(G[i][j]) f=1;\n    }\n  }\n  \n  if(!f) ans=max(ans,sum);\n\n  if(memo.count(S)) return;\n\n  memo.insert(S);\n  \n  if(x==n) return ;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1LL<<i))) continue;\n    \n    for(int j=i+1;j<n;j++){\n      \n      if(!(S&(1LL<<j))) continue;\n      \n      if(G[i][j]){\n\t\n\tif(i) dfs2(x+1,S|(1LL<<i),sum-cost[i]);\n\t\n\tdfs2(x+1,S|(1LL<<j),sum-cost[j]);\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\n\nint main(){\n\n  while(1){\n  \n    cin>>n;\n\n    if(!n) break;\n    \n    map<string,int> num;\n    int cnt=0, sum=0;\n    \n    memset(G,0,sizeof(G));\n\n    for(int i=0;i<n;i++){\n      \n      string s;\n      \n      cin>>s;\n      \n      if(!num.count(s)) num[s]=cnt++;\n      \n      cin>>cost[num[s]];\n\n      if(i) sum+=cost[num[s]];\n      \n      int x;\n      cin>>x;\n      \n      for(int j=0;j<x;j++){\n\t\n\tstring t;\n\t\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\t\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n    \n    ans=0;\n    \n    m=(n-1)/2;\n    \n    memo.clear();\n    \n    dfs(0,1,0);\n\n    dfs2(m+1,(1LL<<n)-1,sum);\n\n    cout<<ans+cost[0]<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <memory>\n#include <cstring>\n#include <cassert>\n#include <numeric>\n#include <sstream>\n#include <complex>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <cctype>\n#include <unordered_map>\n#include <unordered_set>\nusing namespace std;\n\n#define REP2(i, m, n) for (int i = (int)(m); i < (int)(n); i++)\n#define REP(i, n) REP2(i, 0, n)\n#define ALL(S) (S).begin(), (S).end()\n\ntemplate <typename T, typename E>\nostream &operator<<(std::ostream &os, const std::pair<T, E> &p){\n  return os << \"(\" << p.first << \", \" << p.second << \")\";\n}\n\ntypedef long long ll;\n\nclass IndependentSet{\n  typedef unsigned long long ll;\n  std::vector<ll>  graph;\n  std::vector<int> weight;\n  \n  ll              used;\n  inline int  degree(int v) { return __builtin_popcountll(graph[v] & ~used); }\npublic:\n  \n  IndependentSet(int V, std::vector<int> weight)\n    : graph(V), weight(weight), used(0)\n  {\n    assert(V < 64);\n    for (int i = 0; i < V; i++){\n      graph[i] |= 1LL << i;\n    }\n  }\n  \n  void add_edge(int u, int v){\n    assert(u < (int)graph.size() && v < (int)graph.size());\n    graph[u] |= 1LL << v;\n    graph[v] |= 1LL << u;\n  }\n  \n  int solve(){\n    int res      = 0;\n    int next     = -1;\n    ll  old_used = used;\n    \n    for (size_t v = 0; v < graph.size(); v++){\n      if (used & (1LL << v)){\n        continue;\n      } else if (degree(v) <=  1){\n        next = v;\n        break;\n      } else if (next == -1 || degree(v) > degree(next)){\n        next = v;\n      }\n    }\n\n    if (next == -1){\n      return 0;\n    } else if (degree(next) > 1){\n      used |= 1LL << next;\n      res = solve();\n      used = old_used;\n    }\n    \n    used |= graph[next];\n    res = std::max(res, solve() + weight[next]);\n    used = old_used;\n    return res;\n  }\n};\n\n\nint main(){\n  ios::sync_with_stdio(false);\n\n  int N;\n  \n  while (cin >> N && N){\n    map<string, int> city_to_id;\n    \n    int adj[N][N];\n    vector<int> weight(N);\n    \n    memset(adj, 0, sizeof(adj));\n    REP(i, N){\n      string city;\n      cin >> city;\n      if (city_to_id.count(city) == 0) {\n        size_t id = city_to_id.size();\n        city_to_id[city] = id;\n      }\n      cin >> weight[city_to_id[city]];\n\n      int num_adj;\n      cin >> num_adj;\n      REP(j, num_adj){\n        string adj_city;\n        cin >> adj_city;\n        if (city_to_id.count(adj_city) == 0) {\n          size_t id = city_to_id.size();\n          city_to_id[adj_city] = id;\n        }\n        adj[city_to_id[city]][city_to_id[adj_city]] = 1;\n        adj[city_to_id[adj_city]][city_to_id[city]] = 1;\n      }\n    }\n\n    const int INF = 1e9;\n    weight[0] += INF;\n    IndependentSet is(N, weight);\n    REP(i, N) REP(j, N) if (adj[i][j]) is.add_edge(i, j);\n    cout << is.solve() - INF << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint Cc;\n\nchar Name[40][20];\nchar NearS[40][40][20];\nbool Near[40][40];\nbool ally[40];\nint Power[40];\nint n, t;\nint Max_Power;\nint Remain_Power;\n\t\n\nvoid make_ally(bool ally1[40], int name, int power, int remain_power){\n\tint i,j;\n\tbool ally2[40];\n\tmemcpy(ally2,ally1,sizeof(ally));\n\n\tally2[name] = 1;\n\tpower += Power[name];\n\tremain_power -= Power[name];\n\n//\tcout<<name<<\" : \"<<power<<endl;\n\tfor(i=0;i<n;i++)\n\t\tif(Near[name][i]){\n\t\t\tif(!ally2[i]){\n\t\t\t\tally2[i]=1;\n\t\t\t\tremain_power -= Power[i];\n\t\t\t}\n\t\t}\n\n for(i=name;i<n;i++){\n\t\tif(!ally2[i]){\n\t\t\tfor(j=name;j<n;j++){\n\t\t\t\tif(!ally2[j] && Near[j][i]) break;\n\t\t\t}\n\t\t\tif(j==n){\n\t\t\t\tally2[i] = 1;\n\t\t\t\tpower += Power[i];\n\t\t\t\tremain_power -= Power[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif(power > Max_Power) Max_Power = power;\n\tif(Max_Power >= power + remain_power) return;\n\n\tfor(i=name;i<n;i++)\n\t\tif(!ally2[i]) make_ally(ally2, i, power, remain_power);\n\n\treturn;\n}\nint search(char *name){\n\tint i;\n\tfor(i=0;i<Cc;i++) if(!strcmp(name, Name[i])) return i;\n\tprintf(\"%s\\n\", name);\n\treturn 0;\n}\n\nint main(){\n\tint j, i;\n\twhile(cin >> n, n){\n\t\tmemset(Name, 0, sizeof(Name));\n\t\tmemset(Near, 0, sizeof(Near));\n\t\tmemset(NearS, 0, sizeof(NearS));\n\t\tmemset(Power, 0, sizeof(Power));\n\t\tmemset(ally, 0, sizeof(ally));\n\t\tMax_Power=0; Remain_Power=0;\n\n\t\tfor(Cc=0;Cc<n;Cc++){\n\t\t\tcin >> Name[Cc] >> Power[Cc] >> t;\n\t\t\tRemain_Power += Power[Cc];\n\n\t\t\tfor(i=0;i<t;i++) cin >> NearS[Cc][i];\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;NearS[i][j][0];j++){\n\t\t\t\tNear[i][search(NearS[i][j])] = 1;\n//\t\t\t\tprintf(\"%d-%d\\n\", i, search(NearS[i][j]));\n\t\t\t}\n\t\t}\n\t\tmake_ally(ally, 0, 0, Remain_Power);\n\t\tcout<<Max_Power<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,ans,sum;\nstring a[50];\nint b[50],c[50];\nvector<string> d[50];\nmap<string,int> m;\nvoid dfs(int x,int p,int q,set<int> s,set<int> t){\n  //cout<<x<<\" \"<<p<<\" \"<<q<<\":\"<<sum<<\" \"<<ans<<endl;\n  if(sum-q<=ans) return;\n  ans=max(ans,p);\n  if(x==n) return;\n  dfs(x+1,p,q,s,t);\n  if(!t.count(x)){\n    s.insert(x);\n    p+=b[x];\n    for(int i=0;i<c[x];i++){\n      if(s.count(m[d[x][i]])) return;\n      if(t.count(m[d[x][i]])) continue;\n      t.insert(m[d[x][i]]);\n      q+=b[m[d[x][i]]];\n    }\n    dfs(x+1,p,q,s,t);\n  }\n}\nsigned main(){\n  while(cin>>n,n){\n    m.clear();\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      m[a[i]]=i;\n      d[i].clear();\n      d[i].resize(c[i]);\n      for(int j=0;j<c[i];j++) cin>>d[i][j];\n    }\n    ans=sum=0;\n    for(int i=0;i<n;i++) sum+=b[i];\n    set<int> s,t;\n    s.insert(0);\n    int p=b[0],q=0;\n    for(int i=0;i<c[0];i++){\n      if(t.count(m[d[0][i]])) continue;\n      t.insert(m[d[0][i]]);\n      q+=b[m[d[0][i]]];\n    }\n    dfs(1,p,q,s,t);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//OBOG2012E 敵の敵は味方 \n#include<iostream>\n#include<cstring>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n//\nint64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct{\n\tint id;\n\tint power;\n\tint64 neighbor;\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp)max = tmp;\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define LINE cout << \"LINE : \" << __LINE__ << endl\n#define dump(v) cout << #v << \" : \" << v << \" \"\n#define dumpl(v) dump(v) << endl\n\nusing ll = int_fast64_t;\n\nvoid calc(vector<ll>& dp, ll l, ll r, const vector<ll>& maskNg, const vector<ll>& B) {\n  rep(mask, 1LL << (r - l)) {\n    /*\n    rep(i, r - l) {\n      if(mask&(1LL<<i)) {\n\tdp[mask] = max(dp[mask], dp[mask - (1LL<<i)]);\n      }\n    }\n    */\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1LL<<i)) continue;\n      ll nxt = mask | (1LL << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    vector<string> A(n);\n    vector<ll> B(n);\n    vector<vector<string>> D(n);\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    vector<vector<ll>> d(n);\n    rep(i, n) {\n      d[i].resize(D[i].size());\n      rep(j, D[i].size()) d[i][j] = mp[D[i][j]];\n    }\n\n    ll l = 0, m = n/2, r = n;\n    vector<vector<ll>> maskNg;\n    maskNg.push_back(vector<ll>(m - l, 0));\n    maskNg.push_back(vector<ll>(r - m, 0));\n    maskNg.push_back(vector<ll>(m - l, 0));\n    \n    rep(i, m - l) {\n      auto& mask = maskNg[0][i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j];\n\tif(k >= m) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg[1][i];\n      rep(j, d[i + m].size()) {\n\tll k = d[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg[2][i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n\n    vector<ll> dp0(1<<(m - l), 0LL);\n    vector<ll> dp1(1<<(r - m), 0LL);\n    calc(dp0, l, m, maskNg[0], B);\n    calc(dp1, m, r, maskNg[1], B);\n\n    rep(mask, (1LL << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1LL<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1LL<<i)]);\n      }\n    }\n    \n    ll ans = 0LL;\n    rep(x, 1LL<<(m - l)) {\n      if(x&1LL) {\n\tll y = (1LL<<(r - m)) - 1LL;\n\trep(i, m - l) {\n\t  if(x & (1LL << i)) {\n\t    y -= (y & maskNg[2][i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//#include\"bits/stdc++.h\"\n\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = 1 << 21;\nint cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nbool E[41][41];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tmemset(E, 0, sizeof(E));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << B[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[mask | (1 << i)] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tx -= dp[mask];\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint mx_tmp =0;\nvector<int> a,b;\nvector<vector<string> > c;\nvector<long long> g;\n\nint n;\nint dfs(int x,int s,long long y){\n    int xxx = 0;\n    for(int i=x;i<n;i++){\n        if((y>>i)&1)continue;\n        xxx += a[i];\n    }\n    if(s+xxx<mx_tmp)return -1;\n    int tmp = a[x];\n    int mx = 0;\n    y |= g[x];\n    for(int i=x+1;i<n;i++){\n        if((y&(g[i]-(1LL<<i)))==(g[i]-(1LL<<i))){\n            if(((y>>i)&1)==0){\n                tmp += a[i];\n                y|=g[i];\n            }\n        }\n    }\n    for(int i=x+1;i<n;i++){\n        if((y>>i)&1)continue;\n        int tmp2 = dfs(i,s+tmp,y);\n        if(mx < tmp2){\n            mx = tmp2;\n        }\n        mx_tmp = max(mx_tmp,tmp+mx);\n    }\n    return tmp + mx;\n}\n\nint main(){\n    while(cin>>n &&n!=0){\n        map<string,int>mp;\n        int cnt = 0;\n        a.clear();\n        b.clear();\n        c.clear();\n        g.clear();\n        a.resize(n);\n        b.resize(n);\n        c.resize(n);\n        g.resize(n);\n        for(int i=0;i<n;i++){\n            string s;\n            cin >> s;\n            mp[s] = cnt;\n            cnt++;\n            cin >> a[i] >> b[i];\n            for(int j=0;j<b[i];j++){\n                cin >> s;\n                c[i].push_back(s);\n            }\n        }\n        for(int i=0;i<n;i++){\n            g[i] = 1LL<<i;\n            for(int j=0;j<b[i];j++){\n                g[i]+=(1LL<<mp[c[i][j]]);\n            }\n        }\n        mx_tmp=0;\n        int ans = dfs(0,0,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nusing ll = int;\n\nstring A[41];\nll B[41];\nll C[41];\nstring D[41][41];\nvector<ll> d0[41];\nvector<ll> d1[41];\n\nll dp0[1<<20];\nll dp1[1<<20];\nll maskNg0[1<<20];\nll maskNg1[1<<20];\nll maskNg2[1<<20];\n\nvoid calc(ll* dp, ll l, ll r, ll* maskNg) {\n  rep(mask, 1 << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1<<i)) continue;\n      ll nxt = mask | (1 << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      cin >> A[i] >> B[i] >> C[i];\n      rep(j, C[i]) cin >> D[i][j];\n    }\n    ll l = 0, m = n/2, r = n;\n\n    unordered_map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    rep(i, n) {\n      d0[i].clear();\n      d1[i].clear();\n      rep(j, C[i]) {\n\tint k = mp[D[i][j]];\n\tif(k < m) d0[i].push_back(k);\n\telse d1[i].push_back(k);\n      }\n    }\n  \n    rep(i, 1<<(m - l)) maskNg0[i] = maskNg2[i] = 0;\n    rep(i, 1<<(r - m)) maskNg1[i] = 0;\n    \n    rep(i, m - l) {\n      auto& mask = maskNg0[i];\n      rep(j, d0[i].size()) {\n\tll k = d0[i][j];\n\tif(k >= m) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg1[i];\n      rep(j, d1[i + m].size()) {\n\tll k = d1[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg2[i];\n      rep(j, d1[i].size()) {\n\tll k = d1[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n\n    rep(i, 1 << (m - l)) dp0[i] = 0;\n    rep(i, 1 << (r - m)) dp1[i] = 0;\n    calc(dp0, l, m, maskNg0);\n    calc(dp1, m, r, maskNg1);\n\n    rep(mask, (1 << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1<<i)]);\n      }\n    }\n    \n    ll ans = 0;\n    rep(x, 1<<(m - l)) {\n      if(x&1) {\n\tll y = (1<<(r - m)) - 1;\n\trep(i, m - l) {\n\t  if(x & (1 << i)) {\n\t    y -= (y & maskNg2[i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#ifdef __BORLANDC__\n\ttypedef __int64 ll;\n#else\n\ttypedef long long ll;\n#endif\n\nconst ll L1 = 1;\nconst int N = 40;\nint M = 20;\n\nint n;\nll edge[N];\nint power[N];\n\nvoid printbit(ll state){\n\trep(i,n)printf(\"%d\",((L1<<i)&state)>0);puts(\"\");\n}\n\nvoid printedge(){\n\tprintf(\"edge\\n\");\n\trep(i,n)printbit(edge[i]);\n}\n\nbool init(){\n\tcin>>n;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i]=power[i]=0;\n\t\n\tmap<string,int> mp;\n\tvector<string> estr[N];\n\trep(i,n){\n\t\tstring a;\n\t\tint b,c;\n\t\tcin>>a>>b>>c;\n\t\tmp[a]=i;\n\t\tpower[i]=b;\n\t\trep(j,c){\n\t\t\tstring d;\n\t\t\tcin>>d;\n\t\t\testr[i].push_back(d);\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,estr[i].size()){\n\t\t\tedge[i] |= (L1<<mp[estr[i][j]]);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool hasbit(ll state, int bit){return state&(L1<<bit);}\n\nint T = (1<<M);\nconst int TM = (1<<20);\nint half[TM];\n\nint left_search(){\n\trep(i,T)half[i]=0;\n\t\n\tint maxi = 0;\n\tfor(int i=1;i<T;i+=2){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\trep(j,M){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\t if(edge[j]&i)ok=false;\n\t\t\t\t sum += power[j];\n\t\t\t}\n\t\t\tif(!ok)break;\n\t\t}\n\t\t\n\t\tif(ok)half[i]=sum;\n\t\tmaxi = max(maxi,half[i]);\n\t}\n\treturn maxi;\n}\n\nint memo[TM];\nint left_memo(int state){\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tint ret = half[state];\n\trep(i,M){\n\t\tif(state&(1<<i)){\n\t\t\tret = max(ret, left_memo(state ^ (1<<i)));\n\t\t}\n\t}\n\treturn memo[state]=ret;\n}\n\nint right_search(){\n\tint ans = 0;\n\tfor(ll i=0; i<(L1<<n); i+=T){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\tll mask = 0;\n\t\treps(j,M,n){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\tif(edge[j]&i)ok=false;\n\t\t\t\tsum+=power[j];\n\t\t\t\tmask |= edge[j];\n\t\t\t}\n\t\t\tif(!ok)break;\n\t\t}\n\t\t\n\t\tif(ok){\n\t\t\tmask &= (T-1);\n\t\t\tmask ^= (T-1);\n\t\t\t//printf(\"i=%d sum=%d memo[bit]=%d \",i,sum,memo[mask]);\n\t\t\t//printbit(mask);\n\t\t\tans = max(ans, left_memo(mask)+sum);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid left_dp(){\n\trep(i,T)memo[i]=-1;\n\t\n\t//left_memo(T-1);\n}\n\nvoid printdp(){\n\trep(i,T){\n\t\tprintf(\"%3d \",memo[i]);printbit(i);\n\t}\n}\nvoid printsearch(){\n\trep(i,T){\n\t\tprintf(\"%3d \",half[i]);printbit(i);\n\t}\n}\nint solve(){\n\tM = (n+1)/2;\n\tT = (1<<M);\n\t\n\tint a = left_search();\n\tleft_dp();\n\t\n\t/*\n\tputs(\"s\");\n\tprintsearch();\n\tputs(\"d\");\n\tprintdp();\n\t*/\n\treturn max(a,right_search());\n}\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n6\nINTERCAL 10 3 Chef Piet COW\nChef 7 3 INTERCAL Piet COW\nPiet 6 2 INTERCAL Chef\nCOW 7 2 INTERCAL Chef\nJ 6 1 A\nA 12 1 J\n0\n\n6\nINTERCAL 20 1 J\nChef 50 3 J A Piet\nPiet 30 2 A Chef\nCOW 15 1 J\nJ 40 3 COW INTERCAL Chef\nA 25 2 Chef Piet\n0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint reg(map<string, int>& tbl, string& name) {\n\tif (tbl.count(name) == 0) {\n\t\tint id = tbl.size();\n\t\ttbl[name] = id;\n\t}\n\treturn tbl[name];\n}\n\nint N;\nvector< vector<int> > G;\nvector<int> power;\nvector<int> ps;\nvector<int> conv;\nvector<int> adjacent;\n\nint ans = 0, p = 0;\nbool merge(int n) {\n\tif (adjacent[n] > 0) return false;\n\tfor (int i = 0; i < G[n].size(); ++i) {\n\t\tadjacent[G[n][i]]++;\n\t}\n\treturn true;\n}\nbool remove(int n) {\n\tfor (int i = 0; i < G[n].size(); ++i) {\n\t\tadjacent[G[n][i]]--;\n\t}\n}\nvoid dfs(int n) {\n\tif (n == N) {\n\t\tans = max(ans, p);\n\t}\n\telse if (p + ps[n] > ans) {\n\t\tif ( merge(conv[n]) ) {\n\t\t\tp += power[n];\n\t\t\tdfs(n+1);\n\t\t\tremove(conv[n]);\n\t\t\tp -= power[n];\n\t\t}\n\t\tdfs(n+1);\n\t}\n}\n\nint main() {\n\twhile ( cin >> N, N ) {\n\t\tmap<string, int> tbl;\n\t\tpower.clear(); power.resize(N);\n\t\tG.clear(); G.resize(N);\n\t\tconv.clear(); conv.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring A; cin >> A; int a = reg(tbl, A);\n\t\t\tint B, C; cin >> B >> C;\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tstring D; cin >> D;\n\t\t\t\tint d = reg(tbl, D);\n\t\t\t\tG[a].push_back(d);\n\t\t\t}\n\t\t\tpower[i] = B;\n\t\t\tconv[i] = a;\n\t\t}\n\t\tps.resize(N+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tps[i] = power[i];\n\t\t}\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tps[i] += ps[i+1];\n\t\t}\n\t\tadjacent = vector<int>(N, 0);\n\t\tans = 0; p = power[0]; merge(conv[0]);\n\t\tdfs(1);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring a[40];\nint b[40];\nvector<string> d[40];\nmap<string,int> sn;\nvector<int> dn[40];\nint mr[40];\n\nbool cmp(int pa,int pb){\n  return b[pa]*1./dn[pa].size()>b[pb]*1./dn[pb].size();\n}\n\nint dfs(long long u,int c,int cm){\n  if(c==n){\n    return cm;\n  }else{\n    int m=0;\n    if(!(u>>mr[c]&1)){\n      int pr=0;\n      for(int i=c;i<n;i++){\n\tif(!(u>>mr[i]&1)){\n\t  pr+=b[mr[i]];\n\t}\n      }\n      if(pr+cm>m){\n\tlong long nu=u|1LL<<mr[c];\n\tfor(int i=0;i<dn[mr[c]].size();i++){\n\t  nu|=1LL<<dn[mr[c]][i];\n\t}\n\tm=dfs(nu,c+1,cm+b[mr[c]]);\n      }\n    }\n    return max(m,dfs(u,c+1,cm));\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    sn.clear();\n    for(int i=0;i<n;i++){\n      int c;\n      cin>>a[i]>>b[i]>>c;\n      sn[a[i]]=i;\n      d[i].resize(c);\n      while(c--){\n\tcin>>d[i][c];\n      }\n    }\n    for(int i=0;i<n;i++){\n      dn[i].resize(n);\n      for(int j=0;j<d[i].size();j++){\n\tdn[i][j]=sn[d[i][j]];\n      }\n    }\n    for(int i=0;i<n;i++){\n      mr[i]=i;\n    }\n    sort(mr,mr+n,cmp);\n    long long n=1;\n    for(int i=0;i<dn[0].size();i++){\n      n|=1LL<<dn[0][i];\n    }\n    cout<<dfs(n,0,b[0])<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint ans = 0;\nint N;\nvector<int>rests;\n\nvoid getans(const int sum,const int now, const vector < pair<int, vector<int>>>&connects, vector<int>&oks) {\n\tif (now == N)ans =max(ans, sum);\n\telse {\n\t\t//if (sum + rests[now] < ans)return;\n\t\tif (oks[now]) {\n\t\t\tvector<int>preoks(oks);\n\t\t\tpreoks[now] = false;\n\t\t\tfor (auto e : connects[now].second) {\n\t\t\t\tpreoks[e] = false;\n\t\t\t}\n\t\t\tgetans(sum + connects[now].first, now+1, connects, preoks);\n\t\t\t\n\t\t}\n\t\tif (now) {\n\n\t\t\tgetans(sum, now + 1, connects, oks);\n\t\t}\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tans = 0;\n\t\trests.clear();\n\t\trests.resize(N);\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tvector<pair<int,vector<int>>>connects(N);\n\t\tint num = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name; int b, c; cin >> name >> b >> c;\n\t\t\tif (mp.find(name) == mp.end()) {\n\t\t\t\tmp[name] = num;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tint myid = mp[name];\n\t\t\tconnects[myid].first = b;\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tif (mp.find(st) == mp.end()) {\n\t\t\t\t\tmp[st] = num;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tint opid = mp[st];\n\n\t\t\t\tconnects[mp[name]].second.emplace_back(opid);\n\t\t\t}\n\t\t}\n\t\t//sort(connects.begin(), connects.end());\n\t\t//reverse(connects.begin(), connects.end());\n\t\trests[N - 1] = connects[N - 1].first;\n\t\tfor (int i = N - 2; i >= 0; --i) {\n\t\t\trests[i] = rests[i + 1] + connects[i].first;\n\t\t}\n\n\t\tvector<int>oks(N, true);\n\t\tgetans(0, 0, connects, oks);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> adj[50];\nint power[50];\nll used;\nint ans, rest, sum;\nint N;\nvector<int> per;\nvoid dfs(int k_){\n  if(k_ == N){\n    ans = max(ans,  sum);\n    return ;\n  }\n  int k = per[k_];\n  //printf(\"%d:%d %d %d\\n\", k,sum , rest, ans);\n  if(sum + rest <= ans){\n    return;\n  }\n  ll usedtmp = used;\n  int sumtmp = sum;\n  int resttmp = rest;\n  if(!(used >> k & 1)){\n    used |= 1 << k;\n    sum += power[k];\n    rest -= power[k];\n    FORIT(it, adj[k])if(!(used >> (*it) & 1)){\n      rest -= power[*it];\n      used |= 1<<(*it);\n    }\n    dfs(k_ + 1);\n    used = usedtmp;\n    sum = sumtmp;\n    rest = resttmp;\n  }\n  if(k != 0){\n    if(!(used << k & 1))rest -= power[k];\n    used |= 1 << k;\n    dfs(k_ + 1);\n  }\n}\n \ntypedef pair<int, int> P;\nint main(){\n  while(cin>>N && N){\n    ans = 0, rest = 0, sum = 0;\n    REP(i, 50) adj[i].clear();\n    used = 0;\n    map<string, int> id;\n    vector<string> adjstr[50];\n    REP(i, N){\n      string s; cin>>s; id[s] = i;\n      cin>>power[i];\n      rest += power[i];\n      int k; cin>>k;\n      while(k--){\n        string str; cin>>str;\n        adjstr[i].push_back(str);\n      }\n    }\n    REP(i, N){\n      REP(j, adjstr[i].size()){\n        adj[i].push_back(id[adjstr[i][j]]);\n      }\n    }\n    vector<P> ps(N-1);\n    REP(i, N-1)ps[i] = P(-power[i+1], i+1);\n    sort(ps.begin(), ps.end());\n    per = vector<int>(N, 0);\n    REP(i, N-1) per[i+1] = ps[i].second;\n    used = 0;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nvector<string> list[40];\nstring name[40];\nint n, w[40], sum;\nvector<vi> e;\nbool v[40], ok[40];\n\nvoid dfs(int c, vector<pi> &o){\n\to.pb(mp(w[c], c));\n\tv[c] = 1;\n\tok[c] = 1;\n\teach(i, e[c]) if(!v[*i]) dfs(*i, o);\n}\nvoid rec(int c, int cur, const vector<pi> &o){\n\tint next = -1, tmp = 0;\n\tfor(int i = o.size() - 1; i >= c; i--) if(ok[o[i].second]){\n\t\tnext = o[i].second;\n\t\ttmp += o[i].first;\n\t}\n\tif(cur + tmp <= sum) return;\n\tif(next < 0){\n\t\tsum = cur + tmp;\n\t\treturn;\n\t}\n\tif(ok[o[c].second]){\n\t\tbool ok2[40];\n\t\trep(i, n) ok2[i] = ok[i];\n\t\teach(i, e[o[c].second]) ok[*i] = 0;\n\t\trec(c + 1, cur + o[c].first, o);\n\t\trep(i, n) ok[i] = ok2[i];\n\t}\n\tif(o[c].second != 0) rec(c + 1, cur, o);\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(v, 0, sizeof(v));\n\t\te.clear(); e.resize(n);\n\t\tmap<string, int> id;\n\t\trep(i, n){\n\t\t\tint k;\n\t\t\tcin >> name[i] >> w[i] >> k;\n\t\t\tlist[i].clear(); list[i].resize(k);\n\t\t\trep(j, k) cin >> list[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, list[i].size()) e[i].pb(id[list[i][j]]);\n\t\t\n\t\tint ans = 0;\n\t\trep(i, n) if(!v[i]){\n\t\t\tvector<pi> ord;\n\t\t\tdfs(i, ord);\n\t\t\tsort(all(ord), greater<pi>());\n\t\t\tsum = 0;\n\t\t\trec(0, 0, ord);\n\t\t\tans += sum;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline unsigned msb(unsigned v) { return 1ul << 31 - __builtin_clz(v); }\ninline unsigned lsb(unsigned v) { return v & -v; }\ninline unsigned long msb(unsigned long v) { return 1ull << 63 - __builtin_clzll(v); }\ninline unsigned long lsb(unsigned long v) { return v & -v; }\n\n//// idconv ////\ntemplate<class T>\nstruct idconv\n{\n\tvector<T> v;\n\tint get(T t)\n\t{\n\t\tint id = (int)(find(allof(v), t) - v.begin());\n\t\tif (id == v.size()) v.push_back(t);\n\t\treturn id;\n\t}\n};\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ntypedef pair<int, long> NATION;\nint dfs(const vector<NATION> &nations, long cand)\n{\n\tif (!cand) return 0;\n\tint id = __builtin_ctzll(cand);\n\tpair<int, long> dt = nations[id];\n\treturn max(dt.first + dfs(nations, cand & ~dt.second), dfs(nations, cand & ~(1 << id)));\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tvector<NATION> nations(N);\n\t\tidconv<string> idc;\n\t\tREP(_, N)\n\t\t{\n\t\t\tint id = idc.get(read<string>());\n\t\t\tint pw = read<int>();\n\t\t\tlong adj = 1 << id;\n\t\t\tfor (auto &s : readjag<string>()) adj |= 1ll << idc.get(s);\n\t\t\tnations[id] = make_pair(pw, adj);\n\t\t}\n\n\t\tNATION self = nations[0];\n\t\tlong cand = (1 << N) - 1;\n\n\t\tWRITE(self.first + dfs(nations, cand & ~self.second));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    vector<vector<string>> graph_(n);\n    map<string,int> encode;\n    vector<int> strength(n),sum(n);\n    rep(i,0,n){\n        string a;\n        int b,c;\n        cin >> a >> b >> c;\n        encode[a]=i;\n        strength[i]=b;\n        sum[i]=b;\n        if(i>0) sum[i]+=sum[i-1];\n        rep(j,0,c){\n            string d;\n            cin >> d;\n            graph_[i].push_back(d);\n        }\n    }\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        rep(j,0,graph_[i].size()){\n            graph[i].push_back(encode[graph_[i][j]]);\n        }\n    }\n\n    int maxi=0;\n    function<int(int,int,int)> rec=[&](int s,int i,int k){\n        if(i==n) return k;\n        if(k+sum[n-1]-sum[i-1]<=maxi) return maxi;\n        int res=rec(s,i+1,k);\n        bool f=true;\n        for(int j:graph[i]) if((s>>j)&1){\n            f=false;\n            break;\n        }\n        if(f) res=max(res,rec(s|(1<<i),i+1,k+strength[i]));\n        maxi=max(maxi,res);\n        return res;\n    };\n\n    cout << rec(1,1,strength[0]) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<vector<int> > memo;\n\nvoid dfs(int x,int sum,vector<int> S,int idx){\n  \n  for(int i=idx;i<n;i++){\n\n    if(!x&&i) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<S.size();j++)\n      if(G[S[j]][i]) f=1;\n    \n    if(!f){\n      \n      vector<int> nS=S;\n      \n      sort(nS.begin(),nS.end());\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n\n      nS.push_back(i);\n      \n      ans=max(ans,sum+cost[i]);\n\t\n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=0;\n\n    vector<int> S;\n    \n    dfs(0,0,S,0);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nmap<string,int> M;\nvector<string> NG[41];\nstring A[41];\nint n,B[41],ans;\null g[41];\n\nunordered_set <ull> S[41];\nunordered_map <ull,int> mem[41];\null used;\nvoid dfs(int pos,int sum,ull U){\n\n  ans=max(ans,sum);\n  while(pos<n&&(g[pos]&1LL))pos++;\n  if(pos==n)return;\n  if(mem[pos][U]>=sum)return;\n  mem[pos][U]=sum;\n  //if(S[pos].count(used))return;\n  //S[pos].insert(used);\n  ull tmp=used,nU=U;\n  int nsum=sum;\n\n  if(U&(1LL<<pos)){\n    used=nU=nsum=0;\n    for(int i=0;i<pos;i++){\n      if((tmp&(1LL<<i))==0) continue; \n      if((g[pos]&(1LL<<i))==0) nU|=g[i],used|=(1LL<<i),nsum+=B[i];\n    }\n  }\n  \n  used|=(1LL<<pos);\n  dfs(pos+1,nsum+B[pos],nU|g[pos]);\n  used&=~(1LL<<pos);\n  if(used!=tmp)used=tmp,dfs(pos+1,sum,U);\n} \n\n\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    for(int i=0;i<40;i++) S[i].clear(),mem[i].clear();\n\n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      M[A[i]]=i;\n      NG[i].resize(C);\n      for(int j=0;j<C;j++)cin>>NG[i][j];\n    }\n\n    \n    for(int i=0;i<n;i++){\n      g[i]=1LL<<i;\n      for(int j=0;j<(int)NG[i].size();j++)g[i]|=1LL<<M[NG[i][j]];\n    }\n    \n    ans=0;\n    used=1;\n    dfs(1,B[0],g[0]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> adj[50];\nint power[50];\nbool used[50];\nint ans, rest, sum;\nint N;\nvector<int> per;\nvoid dfs(int k_){\n  if(k_ == N){\n    ans = max(ans,  sum);\n    return ;\n  }\n  int k = per[k_];\n  //printf(\"%d:%d %d %d\\n\", k,sum , rest, ans);\n  if(sum + rest <= ans){\n    return;\n  }\n  bool usedtmp[50];\n  memcpy(usedtmp, used, sizeof(used));\n  int sumtmp = sum;\n  int resttmp = rest;\n  if(!used[k]){\n    used[k] = true;\n    sum += power[k];\n    rest -= power[k];\n    FORIT(it, adj[k])if(!used[*it]){\n      rest -= power[*it];\n      used[*it] = true;\n    }\n    dfs(k_ + 1);\n    memcpy(used, usedtmp, sizeof(used));\n    sum = sumtmp;\n    rest = resttmp;\n  }\n  if(k != 0){\n    if(!used[k])rest -= power[k];\n    used[k] = true;\n    dfs(k_ + 1);\n  }\n}\n\ntypedef pair<int, int> P;\nint main(){\n  while(cin>>N && N){\n    ans = 0, rest = 0, sum = 0;\n    REP(i, 50) adj[i].clear();\n    memset(used, 0, sizeof(used));\n    map<string, int> id;\n    vector<string> adjstr[50];\n    REP(i, N){\n      string s; cin>>s; id[s] = i;\n      cin>>power[i];\n      rest += power[i];\n      int k; cin>>k;\n      while(k--){\n        string str; cin>>str;\n        adjstr[i].push_back(str);\n      }\n    }\n    REP(i, N){\n      REP(j, adjstr[i].size()){\n        adj[i].push_back(id[adjstr[i][j]]);\n      }\n    }\n    vector<P> ps(N-1);\n    REP(i, N-1)ps[i] = P(-power[i+1], i+1);\n    sort(ps.begin(), ps.end());\n    per = vector<int>(N, 0);\n    REP(i, N-1) per[i+1] = ps[i].second;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint id[40];\nint G[40][40];\nstring name[40];\nint B[40];\nvector<string> D[40];\nint N;\nint ans;\nmap<string, int> m;\n\nvoid f(int n, ll mask, int sum) {\n\tif(n == N) {\n\t\t/*for(int i = 0; i < N; i++) {\n\t\t\tif(mask >> i & 1) cout << name[i] << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t\tans = max(ans, sum);\n\t\treturn;\n\t}\n\n\tint tsum = 0;\n\tfor(int i = n; i < N; i++) {\n\t\ttsum += B[id[i]];\n\t}\n\tif(sum + tsum <= ans) return;\n\n\tbool canUse = true;\n\tfor(int i = 0; i < N; i++) {\n\t\tif((mask >> id[i] & 1) && G[m[name[id[n]]]][m[name[id[i]]]]) {\n\t\t\tcanUse = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(canUse) {\n\t\tf(n + 1, mask | (1LL << id[n]), sum + B[id[n]]);\n\t}\n\n\tf(n + 1, mask, sum);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> N, N) {\n\t\tm.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> name[i] >> B[i];\n\t\t\tm[name[i]] = i;\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tD[i].assign(C, \"\");\n\t\t\tfor(int j = 0; j < C; j++) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint myPow = B[0];\n\t\tB[0] = 1e9;\n\n\t\ttypedef pair<int, int> P;\n\t\tvector<P> p;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tp.push_back({ B[i], i });\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\treverse(p.begin(), p.end());\n\n\t\tB[0] = myPow;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tid[i] = p[i].second;\n\t\t}\n\n\t\tmemset(G, 0, sizeof G);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(auto s : D[i]) {\n\t\t\t\tG[m[name[i]]][m[s]] = G[m[s]][m[name[i]]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tf(1, 1, B[0]);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define LOG(...) fprintf(stderr,__VA_ARGS__)\n//#define LOG(...)\n#define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define RFOR(i,a,b) for(int i=(int)(b-1);i>=(int)(a);--i)\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define RREP(i,n) for(int i=(int)(n-1);i>=0;--i)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort(ALL(c))\n#define RSORT(c) sort(RALL(c))\n#define SZ(a) ((int)(a).size())\n#define BIT(x, i) (((x) >> (i)) & 1)\n#define SQ(x) ((x)*(x))\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<bool> vb;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef vector<vb> vvb;\ntypedef vector<vi> vvi;\ntypedef vector<vll> vvll;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n\nint main() {\n    int N;\n    while (cin >> N, N) {\n        vs name(N);\n        vi strength(N);\n        vll neighbor(N);\n        map<string, int> name2id;\n        vector<vs> neighbor_name(N);\n        REP(i, N) {\n            int m;\n            cin >> name[i] >> strength[i] >> m;\n            name2id[name[i]] = i;\n            REP(j, m) {\n                string c;\n                cin >> c;\n                neighbor_name[i].push_back(c);\n            }\n        }\n        REP(i, N) {\n            ll bit = 1LL << i;\n            for (string c : neighbor_name[i]) {\n                bit |= 1LL << name2id[c];\n            }\n            neighbor[i] = bit;\n        }\n\n        vi select;\n        REP(i, N) {\n            if (!BIT(neighbor[0], i)) {\n                select.push_back(i);\n            }\n        }\n\n        map<ll, int> res;\n        int ma = res[0] = strength[0];\n        bool redo;\n        do {\n            redo = false;\n            map<ll, int> res2;\n            for (pair<ll, int> kv : res) {\n                ll state = kv.first;\n                for (int i : select) {\n                    if (!BIT(neighbor[0], i) && !(state & neighbor[i])) {\n                        int v = kv.second + strength[i];\n                        res2[state|neighbor[i]] = v;\n                        ma = max(ma, v);\n                        redo = true;\n                    }\n                }\n            }\n            res = res2;\n        } while (redo);\n        cout << ma << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> adj[50];\nint power[50];\nbool used[50];\nint ans, rest, sum;\nint N;\nvector<int> per;\nvoid dfs(int k_){\n  if(k_ == N){\n    ans = max(ans,  sum);\n    return ;\n  }\n  int k = per[k_];\n  //printf(\"%d:%d %d %d\\n\", k,sum , rest, ans);\n  if(sum + rest <= ans){\n    return;\n  }\n  bool usedtmp[50];\n  REP(i, 50) usedtmp[i] = used[i];\n  int sumtmp = sum;\n  int resttmp = rest;\n  bool notuse = true;\n  if(!used[k]){\n    notuse = false;\n    used[k] = true;\n    sum += power[k];\n    rest -= power[k];\n    FORIT(it, adj[k])if(!used[*it]){\n      notuse = true;\n      rest -= power[*it];\n      used[*it] = true;\n    }\n    dfs(k_ + 1);\n    REP(i, 50) used[i] = usedtmp[i];\n    sum = sumtmp;\n    rest = resttmp;\n  }\n  if(k != 0 && notuse){\n    if(!used[k])rest -= power[k];\n    used[k] = true;\n    dfs(k_ + 1);\n    rest += power[k];\n    used[k] = false;\n  }\n}\n\ntypedef pair<int, int> P;\nint main(){\n  while(cin>>N && N){\n    ans = 0, rest = 0, sum = 0;\n    REP(i, 50) adj[i].clear();\n    memset(used, 0, sizeof(used));\n    map<string, int> id;\n    vector<string> adjstr[50];\n    REP(i, N){\n      string s; cin>>s; id[s] = i;\n      cin>>power[i];\n      rest += power[i];\n      int k; cin>>k;\n      while(k--){\n        string str; cin>>str;\n        adjstr[i].push_back(str);\n      }\n    }\n    REP(i, N){\n      REP(j, adjstr[i].size()){\n        adj[i].push_back(id[adjstr[i][j]]);\n      }\n    }\n    vector<P> ps(N-1);\n    REP(i, N-1)ps[i] = P(-power[i+1], i+1);\n    sort(ps.begin(), ps.end());\n    per = vector<int>(N, 0);\n    REP(i, N-1) per[i+1] = ps[i].second;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<vector<ll>> g;\nvector<ll> power;\nvector<ll> used;\nvector<P> ord;\n\nvoid build_graph() {\n\tmap<string,ll> dict;\n\tll cnt = 0;\n\tREP(i,n) {\n\t\tstring a; ll b, c;\n\t\tcin >> a >> b >> c;\n\t\tif(dict.count(a) == 0) {\n\t\t\tdict[a] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p = dict[a];\n\t\tpower[dict[a]] = b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tif(dict.count(t) == 0) {\n\t\t\t\tdict[t] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tg[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx, ll sum) {\n\tif(idx == n) return sum;\n\tif(used[ord[idx].second] != -1) return dfs(idx + 1, sum);\n\tll ret = 0;\n\tvector<ll> tmp(n);\n\tREP(i,n) tmp[i] = used[i];\n\tif((ll)g[ord[idx].second].size() > 1) {\n\t\tused[ord[idx].second] = 0;\n\t\tret = max(ret, dfs(idx + 1, sum));\n\t}\n\tused[ord[idx].second] = 1;\n\tREP(i,g[ord[idx].second].size()) used[g[ord[idx].second][i]] = 0;\n\tret = max(ret, dfs(idx + 1, sum + power[ord[idx].second]));\n\tREP(i,n) used[i] = tmp[i];\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tused.assign(n, -1);\n\tord.resize(n);\n\tg.resize(0); g.resize(n); build_graph();\n\tll sum = 0;\n\tREP(i,n) if(used[i] == -1) {\n\t\tif(i == 0) {\n\t\t\tused[i] = 1;\n\t\t\tREP(j,g[i].size()) used[g[i][j]] = 0;\n\t\t\tsum += power[i];\n\t\t\tcontinue;\t\n\t\t}\n\t\tif(g[i].size() == 0) {\n\t\t\tused[i] = 1;\n\t\t\tsum += power[i];\n\t\t}\n\t\tif(g[i].size() == 1 && g[g[i][0]].size() == 1) {\n\t\t\tif(power[i] >= power[g[i][0]]) {\n\t\t\t\tused[i] = 1; used[g[i][0]] = 0;\n\t\t\t\tsum += power[i];\n\t\t\t} else {\n\t\t\t\tused[i] = 0; used[g[i][0]] = 1;\n\t\t\t\tsum += power[g[i][0]];\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n) {\n\t\tord[i].first = (ll)g[i].size();\n\t\tord[i].second = i;\n\t}\n\tsort(ALL(ord)); reverse(ALL(ord));\n\treturn dfs(0, sum);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\ntypedef long long ll;\nint n;\nmap<int,int> strength;\nint ans;\nmap<string,int> Iindex;\nvector<int> findex[50];\n\nint rec(bool used[],int sum){\n  //cout << \"counter \" <<  counter << endl;\n  //if(counter > n){\n  //if(ans < sum)ans = sum;\n  //return -1;\n  //}\n  bool fin=true;\n  for(int i=0;i<n;i++)fin*=used[i];\n  if(fin){\n    //cout << \"sum = \" << sum << endl;\n    if(ans < sum)ans = sum;\n    return -1;\n  }\n\n\n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      //cout << \"---\" << endl;\n      //cout << i << endl;\n      int presum = sum;\n      presum+=strength[i];\n      bool preused[50];\n      copy(used,used+n,preused);\n      preused[i]=true;\n      //counter++;\n      for(int j=0;j<findex[i].size();j++){\n\tpreused[findex[i][j]]=true;\n\t//counter++;\n      }     \n      //for(int i=0;i<n;i++)cout << preused[i] << \" \";\n      //cout << endl;\n      // cout << \"presum = \" << presum << endl;\n      rec(preused,presum);\n    }\n  }\n\n}\n\n\nint main(){\n  string s1,s2;\n  int val,num;\n  vector<string> relation[50];\n  bool used[50];\n  int Fnum,Fcounter;\n  string Me;\n  while(true){\n    scanf(\"%d\",&n);\n    if(n == 0)break;\n    ans=0;\n    for(int i=0;i<50;i++){\n      relation[i].clear();\n      findex[i].clear();\n    }\n    Iindex.clear();\n    strength.clear();\n    Fcounter=0;\n    for(int i=0;i<50;i++)used[i]=false;\n    for(int i=0;i<n;i++){\n      cin >> s1 >> val >> num;\n      if(i == 0){Me = s1;Fnum = num; }\n      Iindex[s1]=i;\n      strength[i]=val;\n      for(int j=0;j<num;j++){\n\tcin >> s2;\n\trelation[i].push_back(s2);\n      }     \n\n    }\n  \n    used[0]=true;\n    Fcounter++;\n \n    vector<string>::iterator it = relation[0].begin();\n    for(int j=0;j<Fnum;j++,it++){\n      used[Iindex[*it]]=true;\n      Fcounter++;\n    }\n    \n    /*\n    cout << \"--------------\" << endl;\n    for(int i=0;i<n;i++)cout << used[i];\n    cout << endl;\n    cout << \"--------------\" << endl;   \n    */\n\n\n    for(int k=0;k<n;k++){\n      for(int j=0;j<relation[k].size();j++){\n\tfindex[k].push_back(Iindex[relation[k][j]]);\n      }\n    }\n\n\n    rec(used,strength[0]);\n    cout << ans << endl;\n\n\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\ntypedef long long LL;\n#define SORT(c) sort((c).begin(),(c).end())\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\nusing namespace std;\nmap<string,int> cn;\nvector<set<int> > adj;\nvector<int> arm;\nmap<tuple<int,set<int> >,int> memo;\nint n;\nint solve(int tmp,set<int> used){\n  auto t=make_tuple(tmp,used);\n  if(memo.count(t)) return memo[t];\n  if(tmp>=n) return 0;\n  memo[t]=0;\n  if(!used.empty()&&(*used.begin())==tmp){\n    used.erase(used.begin());\n    memo[t]=max(memo[t],solve(tmp+1,used));\n  }else{\n    memo[t]=max(memo[t],solve(tmp+1,used));\n    cout << memo[t] <<endl;\n    for(auto ac:adj[tmp]) used.insert(ac);\n    memo[t]=max(memo[t],solve(tmp+1,used)+arm[tmp]);\n  }\n  return memo[t];\n}\nint main(void)\n{\n  for(;;){\n    cin >> n;\n    if(!n) return 0;\n    cn.clear();\n    adj.assign(n,set<int>());\n    arm.resize(n);\n    memo.clear();\n    vector<vector<string> > adjs(n);\n    REP(i,n){\n      string s;\n      cin >> s;\n      cn[s]=i;\n      cin >> arm[i];\n      int adjc;\n      cin >> adjc;\n      adjs[i].resize(adjc);\n      REP(j,adjc) cin >> adjs[i][j];\n    }\n    REP(i,n){\n      for(auto s:adjs[i])\n\tif(cn[s]>i) adj[i].insert(cn[s]);\n    }\n    cout << solve(0,set<int>()) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<ll> power;\n\nvoid preorder(ll p,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tused[p]=true;\n\tpreo.pb(p);\n\tREP(i,(ll)adj[p].size()) if(!used[adj[p][i]]) {\n\t\tpreorder(adj[p][i],used,preo,adj);\n\t}\n}\n\nvoid input(vector<vector<ll>>& adj) {\n\tmap<string,ll> dict;\n\tll cnt=0;\n\tREP(i,n) {\n\t\tstring a;\n\t\tll b,c;\n\t\tcin>>a>>b>>c;\n\t\tif(dict.count(a)==0) {\n\t\t\tdict[a]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p=dict[a];\n\t\tpower[dict[a]]=b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(dict.count(t)==0) {\n\t\t\t\tdict[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tadj[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj,ll& sum) {\n\tif(idx==(ll)preo.size()) {\n\t\treturn sum;\n\t}\n\tll ret=0;\n\tif(preo[idx]!=0&&(idx==0||(ll)adj[preo[idx]].size()>1)) {\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum));\n\t}\n\tbool ok=true;\n\tREP(i,(ll)adj[preo[idx]].size()) ok=ok&(!used[adj[preo[idx]][i]]);\n\tif(ok) {\n\t\tused[preo[idx]]=true;\n\t\tsum+=power[preo[idx]];\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum));\n\t\tsum-=power[preo[idx]];\n\t} else if((ll)adj[preo[idx]].size()>1) ret=max(ret,dfs(idx+1,used,preo,adj,sum));\n\tused[preo[idx]]=false;\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tvector<vector<ll>> adj(n);\n\tinput(adj);\n\tvector<bool> used(n,false);\n\tvector<vector<ll>> preo;\n\tREP(i,n) if(!used[i]) {\n\t\tvector<ll> v;\n\t\tpreorder(i,used,v,adj);\n\t\tpreo.pb(v);\n\t}\n\tused.assign(n,false);\n\tll ans=0;\n\tll x=0;\n\tREP(i,preo.size()) ans+=dfs(0,used,preo[i],adj,x);\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\nvector<ll> g;\nvi power;\nvi ss;\n\nint solve(int i, ll tmp, ll ok)\n{\n\tif (i == n) return 0;\n\tint res = 0;\n\tif (((ok >> i) & 1) == 0) chmax(res, solve(i + 1, tmp | (1ll << i), ok | g[i]) + power[i]);\n\tchmax(res, solve(i + 1, tmp, ok));\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tg.resize(n);\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tpower.resize(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> power[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tREP(i, n)\n\t\t{\n\t\t\tg[i] = 1ll << i;\n\t\t\tREP(j, nei[i].size())\n\t\t\t{\n\t\t\t\tg[i] |= 1ll << mp[nei[i][j]];\n\t\t\t}\n\t\t}\n\n\t\tss.resize(n + 1);\n\t\tREP(i, n) ss[i + 1] = ss[i] + power[i];\n\n\t\tll ok = g[0];\n\t\tcout << solve(1, 1, ok) + power[0] << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9;\nint n, b[100], c[100], dp1[1 << 20], dp2[1 << 20], ng[100];\nstring name[100], d[100][100];\nbool e[100][100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(e, 0, sizeof(e));\n\t\tmap<string, int> id;\n\t\t\n\t\trep(i, n){\n\t\t\tcin >> name[i] >> b[i] >> c[i];\n\t\t\trep(j, c[i]) cin >> d[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, c[i]) e[i][id[d[i][j]]] = e[id[d[i][j]]][i] = 1;\n\t\t\n\t\tint N = n / 2, M = n - N;\n\t\trep(i, 1 << N) dp1[i] = -inf;\n\t\trep(i, 1 << M) dp2[i] = -inf;\n\t\tdp1[1] = b[0]; dp2[0] = 0;\n\t\t\n\t\trep(i, 1 << N) if(dp1[i] != -inf) rep(j, N) if(!(i & 1 << j)){\n\t\t\tif(dp1[i | 1 << j] != -inf) continue;\n\t\t\trep(k, N) if((i & 1 << k) && e[j][k]) goto FAIL;\n\t\t\tdp1[i | 1 << j] = dp1[i] + b[j];\n\t\t\tFAIL:;\n\t\t}\n\t\t\n\t\trep(i, 1 << M) if(dp2[i] != -inf) rep(j, M) if(!(i & 1 << j)){\n\t\t\tif(dp2[i | 1 << j] != -inf) continue;\n\t\t\trep(k, M) if((i & 1 << k) && e[j + N][k + N]) goto FAIL2;\n\t\t\tdp2[i | 1 << j] = dp2[i] + b[j + N];\n\t\t\tFAIL2:;\n\t\t}\n\t\t\n\t\trep(i, 1 << M) rep(j, M) if(i & 1 << j)\n\t\t\tdp2[i] = max(dp2[i], dp2[i ^ 1 << j]);\n\t\t\n\t\trep(i, N) ng[i] = 0;\n\t\trep(i, N) rep(j, M) if(e[i][j + N]) ng[i] |= 1 << j;\n\t\t\n\t\tint ans = 0;\n\t\trep(i, 1 << N){\n\t\t\tint can = (1 << M) - 1;\n\t\t\trep(j, N) if(i & 1 << j) can &= ~ng[j];\n\t\t\t\n\t\t\tans = max(ans, dp1[i] + dp2[can]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nvector< vector<int> > G;\nvector<int> B;\nint N;\n\nint solve(int v, long long int t){\n  if(v >= B.size() || t == (1LL<<N) - 1) return 0;\n  int ret = solve(v+1,t);\n  if(!(t>>v & 1)){\n    t |= 1LL<<v;\n    for(int i = 0; i < G[v].size(); ++i) t |= 1LL<<G[v][i];\n    ret = max(ret, B[v] + solve(v+1,t));\n  }\n  return ret;\n}\n\nint main(){\n  while(cin >> N, N){\n    map<string,int> M;\n    vector< vector<string> > D(N);\n    string a;\n    B = vector<int>(N);\n    int c;\n    for(int i = 0; i < N; ++i){\n      cin >> a >> B[i] >> c;\n      M[a] = i;\n      string d;\n      for(int j = 0; j < c; ++j){\n        cin >> d;\n        D[i].push_back(d);\n      }\n    }\n    G = vector< vector<int> >(N);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < D[i].size(); ++j){\n        G[i].push_back(M[D[i][j]]);\n      }\n    }\n    long long int t = 1LL;\n    for(int i = 0; i < G[0].size(); ++i) t |= 1LL<<G[0][i];\n    cout << B[0] + solve(0,t) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define LINE cout << \"LINE : \" << __LINE__ << endl\n#define dump(v) cout << #v << \" : \" << v << \" \"\n#define dumpl(v) dump(v) << endl\n\nusing ll = int_fast64_t;\n\nstring A[41];\nll B[41];\nvector<string> D[41];\n\nvoid calc(vector<ll>& dp, ll l, ll r, const vector<ll>& maskNg) {\n  rep(mask, 1LL << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1LL<<i)) continue;\n      ll nxt = mask | (1LL << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    unordered_map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    vector<vector<ll>> d(n);\n    rep(i, n) {\n      d[i].resize(D[i].size());\n      rep(j, D[i].size()) d[i][j] = mp[D[i][j]];\n    }\n\n    ll l = 0, m = n/2, r = n;\n    vector<vector<ll>> maskNg;\n    maskNg.push_back(vector<ll>(m - l, 0));\n    maskNg.push_back(vector<ll>(r - m, 0));\n    maskNg.push_back(vector<ll>(m - l, 0));\n    \n    rep(i, m - l) {\n      auto& mask = maskNg[0][i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j];\n\tif(k >= m) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg[1][i];\n      rep(j, d[i + m].size()) {\n\tll k = d[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg[2][i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n\n    vector<ll> dp0(1<<(m - l), 0LL);\n    vector<ll> dp1(1<<(r - m), 0LL);\n    calc(dp0, l, m, maskNg[0]);\n    calc(dp1, m, r, maskNg[1]);\n\n    rep(mask, (1LL << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1LL<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1LL<<i)]);\n      }\n    }\n    \n    ll ans = 0LL;\n    rep(x, 1LL<<(m - l)) {\n      if(x&1LL) {\n\tll y = (1LL<<(r - m)) - 1LL;\n\trep(i, m - l) {\n\t  if(x & (1LL << i)) {\n\t    y -= (y & maskNg[2][i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        map<string,int> A;\n        int B[40];\n        fill(B,B+40,0);\n        vector<string> D[40];\n        \n        for(int i=0;i<N;i++){\n            string name;\n            cin>>name;\n            A[name]=i;\n            cin>>B[i];\n            int C;\n            cin>>C;\n            for(int j=0;j<C;j++){\n                string S;\n                cin>>S;\n                D[i].push_back(S);\n            }\n        }\n        bool G[N][N];\n        fill(G[0],G[N],false);\n        for(int i=0;i<N;i++){\n            for(auto s:D[i]){\n                int j = A[s];\n                G[i][j]=G[j][i]=true;\n            }\n        }\n        int64_t mask[40];\n        fill(mask,mask+40,0);\n        for(int i=0;i<N;i++){\n            for(int j=0;j<N;j++){\n                mask[i]|=(G[i][j]<<j);\n            }\n        }\n\n        int DP[1<<20];\n        fill(DP,DP+(1<<min(20,N)),0);\n        for(int64_t s=1;s<(1<<min(20,N));s+=2){\n            int64_t adj = 0;\n            for(int i=0;i<min(20,N);i++){\n                adj|=((s>>i)&1)*(mask[i]&s);\n            }\n            if(!adj){\n                int sum = 0;\n                for(int i=0;i<min(20,N);i++){\n                    if((s>>i)&1) sum+=B[i];\n                }\n                DP[s]=max(DP[s],sum);\n            }\n            for(int i=0;i<min(20,N);i++){\n                DP[s|(1<<i)]=max(DP[s|(1<<i)],DP[s]);\n            }\n        }\n        if(N>20){\n            int ans = 0;\n            for(int64_t s=0;s<(1LL<<N);s+=(1<<20)){\n                int64_t adj=0;\n                for(int i=20;i<N;i++){\n                    adj|=((s>>i)&1)*(mask[i]&s);\n                }\n                if(adj) continue;\n                int sum = 0;\n                for(int i=20;i<N;i++){\n                    if((s>>i)&1) sum+=B[i];\n                }\n                int64_t b = (1<<20)-1;\n                for(int i=20;i<N;i++){\n                    if((s>>i)&1) b&=~mask[i];\n                }\n                ans = max(ans,sum+DP[b]);\n            }\n            cout<<ans<<endl;\n        }else{\n            int ans = 0;\n            for(int s=1;s<(1<<N);s+=2){\n                ans=max(ans,DP[s]);\n            }\n            cout<<ans<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nmap<string,int> id;\nmap<string,long long> bit;\nmap<long long, long long> memo;\nvector<int> sum(50);\nint n;\nint maximum;\nstring a[50], d[50][50];\nint b[50], c[50];\n\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nvoid dfs(int p, long long used , int score){\n\tmaximum = max(maximum, score);\n\tif(p == n - 1) return;\n\tif(score + sum[p] <= maximum) return;\n\n\tlong long next = used bitor bit[a[p + 1]];\n\tif(not getBit(used,p + 1)) dfs(p + 1, next, score + b[p + 1]);\n\n\tdfs(p + 1, used, score);\n\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tid.clear();\n\t\tbit.clear();\n\t\tmemo.clear();\n\t\tsum.clear();\n\t\tmaximum = 0;\n\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tsum[i] = b[i];\n\t\t\tid[a[i]] = i;\n\t\t\trep(j,c[i]){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,n - 1){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\t\trep(i,n){\n\t\t\tlong long near = setBit(0,i);\n\t\t\trep(j,c[i]){\n\t\t\t\tnear = setBit(near, id[d[i][j]]);\n\t\t\t}\n\t\t\tbit[a[i]] = near;\n\t\t}\n\n\n\n\t\tdfs(0, bit[a[0]], b[0]);\n\t\tcout << maximum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define f first\n#define s second\nusing namespace std;\ntypedef pair<int,int> P;\nmap<string,int> M;\nstring A[41];\nint B[41];\nvector<string> G[41];\n\nint used[41];\nint prim(int start){\n  int res=0;\n  \n  priority_queue<P> Q;\n  Q.push(P(B[start],start));\n  \n  while(!Q.empty()){\n    P t=Q.top();Q.pop();  \n    int pos=t.second, cost=t.first;\n    if(used[pos]++)continue;\n    res+=cost;\n    \n    for(int i=0;i<G[pos].size();i++){\n      int npos = M[G[pos][i]];\n      used[npos]=1;\n      for(int j=0;j<G[npos].size();j++){\n\tint nx=M[G[npos][j]];\n\tQ.push(P(B[nx],nx));\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n;\n  while(cin>>n,n){\n    M.clear();\n    vector<P> Pow;\n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      M[A[i]]=i;\n      G[i].resize(C);\n      Pow.push_back(P(B[i],i));\n      for(int j=0;j<C;j++) cin>>G[i][j];\n    }\n\n    sort(Pow.begin(),Pow.end(),greater<P>());\n  \n    memset(used,0,sizeof(used));\n    int ans=0;\n    ans=max(ans,prim(0));\n    for(int i=0;i<n;i++) {\n      if(used[Pow[i].s]==0) ans+=prim(Pow[i].s);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nmap<string,int> M;\nvector<string> NG[41];\nstring A[41];\nint n,B[41],ans;\null g[41];\nint Sum[41];\n\nvoid dfs(int pos,int sum,ull U){\n  ans=max(ans,sum);\n  if(pos==n)return;\n  if(ans>=sum+Sum[pos]) return;\n  \n  dfs(pos+1,sum,U);\n  if((U&(1LL<<pos))==0)dfs(pos+1,sum+B[pos],U|g[pos]);\n  \n}\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    \n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      Sum[i]=B[i];\n      M[A[i]]=i;\n      NG[i].resize(C);\n      for(int j=0;j<C;j++)cin>>NG[i][j];\n    }\n    \n    for(int i=n-2;i>=0;i--) Sum[i]+=Sum[i+1];\n    \n    for(int i=0;i<n;i++){\n      g[i]=1LL<<i;\n      for(int j=0;j<(int)NG[i].size();j++)g[i]|=1LL<<M[NG[i][j]];\n    }\n    ans=0;\n    dfs(1,B[0],g[0]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\n\nint main(){\n    while(cin >> n , n){\n        map<string,int> mp;\n        vector<i64> edges(n,0);\n        vector<int> x(n);\n\n        auto get_i = [&](string& s){\n            if(mp.count(s)){\n                return  mp[s];\n            }\n            else{\n                mp[s] = mp.size();\n                return (int)mp.size() - 1;\n            }\n        };\n\n        for(int c = 0;c < n;c++){\n            string s;cin >> s;\n            int i = get_i(s);\n            int C;\n            cin >> x[i] >> C;\n            for(int d = 0;d < C;d++){\n                cin >> s;\n                edges[i] |= (1LL << get_i(s));\n            }\n        }\n\n        vector<int> sum(n + 1,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        int result = 0;\n        function<void(i64,i64,int)> dfs = [&](int i,i64 bit,int now_sum){\n            result = max(result , now_sum);\n            if(i == n) return;\n            //枝刈り\n            if(now_sum + sum[i] <= result) return;\n            //throw\n            dfs(i + 1,bit,now_sum);\n\n            if(!(bit & edges[i])) dfs(i + 1,bit | (1LL << i),now_sum + x[i]);\n        };\n        dfs(1,1,x[0]);\n        cout << result << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring a[40];\nint b[40];\nvector<string> d[40];\nmap<string,int> sn;\nvector<int> dn[40];\nint mr[40];\n\nbool cmp(int pa,int pb){\n  return b[pa]>b[pb];\n}\n\nint dfs(long long u,int c,int cm){\n  if(c==n){\n    return cm;\n  }else{\n    int m=dfs(u,c+1,cm);\n    int pr=0;\n    for(int i=c;i<n;i++){\n      if(!(u>>mr[i]&1)){\n\tpr+=b[mr[i]];\n      }\n    }\n    if(pr+cm>m&&!(u>>mr[c]&1)){\n      long long nu=u|1LL<<mr[c];\n      for(int i=0;i<dn[mr[c]].size();i++){\n\tnu|=1LL<<dn[mr[c]][i];\n      }\n      m=max(m,dfs(nu,c+1,cm+b[mr[c]]));\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    sn.clear();\n    for(int i=0;i<n;i++){\n      int c;\n      cin>>a[i]>>b[i]>>c;\n      sn[a[i]]=i;\n      d[i].resize(c);\n      while(c--){\n\tcin>>d[i][c];\n      }\n    }\n    for(int i=0;i<n;i++){\n      dn[i].resize(n);\n      for(int j=0;j<d[i].size();j++){\n\tdn[i][j]=sn[d[i][j]];\n      }\n    }\n    for(int i=0;i<n;i++){\n      mr[i]=i;\n    }\n    sort(mr,mr+n,cmp);\n    long long n=1;\n    for(int i=0;i<dn[0].size();i++){\n      n|=1LL<<dn[0][i];\n    }\n    cout<<dfs(n,0,b[0])<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdint>\n#include <cassert>\n#include <functional>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\nnamespace lc {\nstruct Edge {\n\tint to;\n\texplicit Edge(int to) : to(to) { }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType, typename Func>\nvoid enumerate_maximal_independent_sets(\n\tconst AdjacencyList<EdgeType> &graph, Func func)\n{\n\tconst int n = graph.size();\n\tstd::vector<uint64_t> bit_graph(n), incr_bit_graph(n + 1);\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tuint64_t mask = (1ull << i);\n\t\tfor(const auto &e : graph[i]){ mask |= (1ull << e.to); }\n\t\tbit_graph[i] = mask;\n\t\tincr_bit_graph[i] = mask | incr_bit_graph[i + 1];\n\t}\n\tstd::function<void(int, uint64_t, uint64_t)> recur =\n\t\t[&, n](int i, uint64_t picked, uint64_t eliminated) -> void {\n\t\t\tif(i == n){\n\t\t\t\tif((picked | eliminated) == (1ull << n) - 1){ func(picked); }\n\t\t\t}else if(bit_graph[i] & ~(incr_bit_graph[i + 1] | eliminated)){\n\t\t\t\trecur(i + 1, picked | (1ull << i), eliminated | bit_graph[i]);\n\t\t\t}else if((incr_bit_graph[i + 1] | eliminated) & (1ull << i)){\n\t\t\t\trecur(i + 1, picked, eliminated);\n\t\t\t\tif(!(eliminated & (1ull << i))){\n\t\t\t\t\trecur(\n\t\t\t\t\t\ti + 1, picked | (1ull << i),\n\t\t\t\t\t\teliminated | bit_graph[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trecur(i + 1, picked | (1ull << i), eliminated | bit_graph[i]);\n\t\t\t}\n\t\t};\n\trecur(0, 0, 0);\n}\n}\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n};\n}\nusing namespace std;\ntypedef lc::Edge Edge;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tlc::NameTable name_table;\n\t\tvector<int> powers(n);\n\t\tlc::AdjacencyList<Edge> graph(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring u_name;\n\t\t\tint p, m;\n\t\t\tcin >> u_name >> p >> m;\n\t\t\tconst int u = name_table[u_name];\n\t\t\tpowers[u] = p;\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tstring v_name;\n\t\t\t\tcin >> v_name;\n\t\t\t\tconst int v = name_table[v_name];\n\t\t\t\tgraph.add_edge(u, v);\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tlc::enumerate_maximal_independent_sets(graph, [&](uint64_t s){\n\t\t\tif((s & 1) == 0){ return; }\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tif(s & (1ull << i)){ sum += powers[i]; }\n\t\t\t}\n\t\t\tanswer = max(answer, sum);\n\t\t});\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, a, n) for (ll i = ((ll) a); i < ((ll) n); i++)\nusing namespace std;\ntypedef long long ll;\n\nstruct node {\n  string A;\n  ll B, C;\n  vector<string> D;\n};\n\nll N;\nnode P[40];\n\nll adjust[40];\nll used, ans, sum;\n\nvoid dfs(ll v) {\n  if (v == N) {\n    ans = max(ans, sum);\n    return;\n  }\n\n  ll former = used & adjust[v] & ((1LL << v) - 1);\n  ll latter = adjust[v] & (((1LL << N) - 1) - ((1LL << v) - 1) - (1LL << v));\n\n  if (former) {\n    dfs(v + 1);\n  } else if (!former && !latter) {\n    used += 1LL << v;\n    sum += P[v].B;\n    dfs(v + 1);\n    used -= 1LL << v;\n    sum -= P[v].B;\n  } else {\n    dfs(v + 1);\n    used += 1LL << v;\n    sum += P[v].B;\n    dfs(v + 1);\n    used -= 1LL << v;\n    sum -= P[v].B;\n  }\n}\n\nint main(void) {\n  while (cin >> N, N != 0) {\n    REP(i, 0, N) {\n      cin >> P[i].A >> P[i].B >> P[i].C;\n      P[i].D.clear();\n      REP(j, 0, P[i].C) {\n        string S;\n        cin >> S;\n        P[i].D.push_back(S);\n      }\n    }\n    sort(P + 1, P + N, [](const node x, const node y) { return x.C > y.C; });\n\n    map<string, ll> mp;\n    REP(i, 0, N) mp[P[i].A] = i;\n\n    REP(i, 0, N) adjust[i] = 0;\n    REP(i, 0, N) {\n      REP(j, 0, P[i].C) {\n        ll v = mp[P[i].D[j]];\n        adjust[i] += 1LL << v;\n      }\n    }\n\n    used = 1;\n    ans = P[0].B;\n    sum = P[0].B;\n    dfs(1);\n\n    cout << ans << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,int>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\nmap<string ,int> ma;\nint po[50];\nbool ok[1<<20]={0};\nint an[1<<20]={0};\nint dp[1<<20]={0};\nbool miok[1<<20]={0};\nint dp2[1<<20]={0};\nint hi,mi;\nvector<int> G[50];\nvector<pa> e1,e2,e3;\nint ichi[50]={0};\n\n\nvoid shoki(int r){\n\te1.clear();\n\te2.clear();\n\te3.clear();\n\tma.clear();\n\tfor(int i=0;i<50;i++){\n\t\tpo[i]=0;\n\t\tG[i].clear();\n\t\tichi[i]=0;\n\t}\n\t\n\tfor(int i=0;i<(1<<r);i++){\n\t\t\n\t\t\n\t\tdp[i]=0;\n\t\t\n\t\tdp2[i]=0;\n\t}\n\t\n}\n\nvoid makeok(){\n\tfor(int i=0;i<(1<<hi);i++)ok[i]=true;\n\t\n\tfor(auto t:e1){\n\t\tok[(1<<t.second)+(1<<t.first)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<hi);i++){\n\t\tbool b=ok[i];\n\t\tif(b==false) continue;\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(ok[i-(1<<j)]==false){\n\t\t\t\tb=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tok[i]=b;\n\t}\n\treturn;\n\t\n}\nvoid makean(){\n\tfor(int i=0;i<(1<<hi);i++)an[i]=(1<<(mi))-1;\n\t\n\tfor(auto t:e3){\n\t\tan[(1<<t.first)]^= (1<<(t.second-hi));\n\t}\n\t\n\tfor(int i=0;i<(1<<hi);i++){\n\t\t\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tan[i]=an[1<<j]&an[i-(1<<j)];\n\t\t}\n\t}\n\t\n}\n\nvoid makedp(){\n\tfor(int i=0;i<(1<<mi);i++)miok[i]=true;\n\t\n\tfor(auto t:e2){\n\t\n\t\tmiok[(1<<t.first)+(1<<t.second)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<mi);i++){\n\t\tbool b=miok[i];\n\t\tif(!b) continue;\n\t\tmiok[i]=true;\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(miok[i-(1<<j)]==false){\n\t\t\t\tmiok[i]=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<mi);i++)if(miok[i]){\n\t\tint cnt=0;\n\t\tdp[i]=0;\n\t\tfor(int  j=0;j<mi;j++)if(i&(1<<j)){\n\t\t\tdp[i]=dp[i-(1<<j)]+po[hi+j];\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tfor(int i=0;i<(1<<mi);i++)if(!miok[i]){\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tdp[i]=max(dp[i],dp[i-(1<<j)]);\n\t\t}\n\t\t\n\t}\n}\n\n\n\n         signed main(){\nint n;\n         \twhile(1){\n         \tcin>>n;\n         \t\tif(n==0) return 0;\n         \t\t\n         \t\tshoki((n+1)/2);\n         \tint count1=0;\n         \tfor(int i=0;i<n;i++){\n         \t\tstring s1,s2;\n         \t\tcin>>s1;\n         \t\tif(ma.find(s1)==ma.end()){\n         \t\t\tma[s1]=count1;\n         \t\t\tcount1++;\n         \t\t}\n         \t\tint r3,r4;\n         \t\tcin>>r3>>r4;\n         \t\tpo[ma[s1]]=r3;\n         \t\tfor(int j=0;j<r4;j++){\n         \t\t\tcin>>s2;\n         \t\t\tif(ma.find(s2)==ma.end()){\n         \t\t\t\tma[s2]=count1;\n         \t\t\t\tcount1++;\n         \t\t\t}\n         \t\t\tG[ma[s1]].pb(ma[s2]);\n         \t\t}\n         \t}\n         \t\n         \tint n1=n/2;\n         \thi=n1,mi=n-n1;\n         \tfor(int i=0;i<G[0].size();i++)ichi[G[0][i]]=1;\n         \t//for(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j])cout<<i<<\" \"<<G[i][j]<<endl;\n         \tfor(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j]){\n         \n         \t\n         \t\tif(G[i][j]<hi) e1.pb(mp(i,G[i][j]));\n         \t\telse if(i<hi) e3.pb(mp(i,G[i][j]));\n         \t\telse {\n         \t\t\te2.pb(mp(i-hi,G[i][j]-hi));\n         \t\t}\n         \t}\n         \t\n         \t\n         //\tfor(int i=0;i<n;i++)cout<<po[i]<<endl;\n    \tmakeok();\n         \t\t\n    \tmakean();\n         \t\n    \tmakedp();\n    \t int ans=-1;\n \t\t for(int i=0;i<(1<<hi);i++)if(ok[i]){\n    \t\n \t\t \tfor(int j=0;j<hi;j++)if(i&(1<<j)){\n \t\t \t\t\n \t\t \t\tdp2[i]=dp2[i-(1<<j)]+po[j];\n \t\t \t\tbreak;\n \t\t \t}\n \t\t \tif(i&1)ans=max(ans,dp2[i]+dp[an[i]]);\n    \t}\n         \t\t/*\n         \tint ans=-1;\n          for(int i=0;i<(1<<hi);i++)if(ok[i])if(i&1){\n          \n    \t\tfor(int j=0;j<hi;j++)if(i&(1<<j))dp2[i]=max(dp2[i],dp2[i-(1<<j)]);\n    \t\t\n    \t\tans=max(ans,dp2[i]+dp[an[i]]);\n    \t\t}\n         \t\t*/\n       \n    \tcout<<ans<<endl;\n         }\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\nint ans;\nvoid dfs(int pos, int b) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tfor (; pos < names.size(); pos++) {\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tans = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tlist.push_back(a);\n\t\t\t}\n\t\t\tbuf.insert(make_pair(name, move(list)));\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\n\n// ノード数\nint n;\n// H[国名] := ノード番号 (文字列 と ノード番号の対応付け)\nmap<string,int> H;\n// 国名の保持, v.size() == n \nvector<string> v;\n// i 番目の国の強さ\nint power[40];\n// 答え\nint ans;\n\n// G := グラフ\n// pos := これから使おうとしている頂点の開始番号\n// used[i] := 頂点 i を使えないときは true, 使えるときは false\n// p := 強さの総和\nvoid solve(vector< vector<int> >& G, int pos, vector<bool> used, int p){\n\tans = max( ans , p );\n\tfor(int i=pos ; i < n ; i++ ){\n\t\tif( !used[i] ){\n\t\t\tvector<bool> used_ = used;\n\t\t\tused_[i] = true;\n\t\t\tfor(int j=0 ; j < G[i].size() ; j++ ){\n\t\t\t\tint v = G[i][j];\n\t\t\t\tused_[v] = true;\n\t\t\t}\n\t\t\tbool flag = false;\n\t\t\tfor(int j=pos+1 ; j < n ; j++ ){\n\t\t\t\tif( !used_[j] ){\n\t\t\t\t\tflag = true;\n\t\t\t\t\tvector<bool> used__ = used_;\n\t\t\t\t\tused__[j] = true;\n\t\t\t\t\tfor(int k=0 ; k < G[j].size() ; k++ ){\n\t\t\t\t\t\tint v = G[j][k];\n\t\t\t\t\t\tused__[v] = true;\n\t\t\t\t\t}\n\t\t\t\t\tsolve( G , pos+1 , used__ , p+power[i]+power[j] );\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( !flag ){\n\t\t\t\tsolve( G , pos+1 , used_ , p+power[i] );\n\t\t\t}\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\t// 初期化\n\t\tH.clear();\n\t\tv.clear();\n\t\t// グラフ\n\t\tvector< vector<int> > G(n);\n\t\t\n\t\tvector< vector<string> > D(n);\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tstring A;\n\t\t\tint B, C;\n\t\t\tcin >> A >> B >> C;\n\t\t\tH[A] = i;\n\t\t\tv.push_back(A);\n\t\t\tpower[i] = B;\n\t\t\t\n\t\t\tD[i] = vector<string>(C);\n\t\t\tfor(int j=0 ; j < C ; j++ ){\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < D[i].size() ; j++ ){\n\t\t\t\tint v = H[ D[i][j] ];\n\t\t\t\tG[i].push_back( v );\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tvector<bool> used(n,false);\n\t\tused[0] = true;\n\t\tfor(int i=0 ; i < G[0].size() ; i++ ){\n\t\t\tused[ G[0][i] ] = true;\n\t\t}\n\t\tsolve( G , 1 , used , power[0] );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<int> DD[41];\nHmap<string, int> hm;\n\nvector<ll> dp0(1<<20);\nvector<ll> dp1(1<<20);\n\nint masks[1<<20];\n\nvoid calc (vl& dp, int s, int e) {\n  int l = e - s;\n  vector<int> ngs(l);\n  rep(i, l) {\n    for(const auto& t: DD[i+s]) {\n      if(s <= t && t < e) {\n\tngs[i] |= (1<<(t-s));\n      }\n    }\n  }\n  rep(mask, 1 << l) {\n    rep(i, l) {\n      if(mask & (1<<i)) continue;\n      if(mask&ngs[i]) continue;\n      int nxt = mask | (1<<i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n    }\n  }\n  rep(mask, 1<<l) {\n    rep(i, l) {\n      if(mask&(1<<i)) {\n\tint pre = mask - (1<<i);\n\tdp[mask] = max(dp[mask], dp[pre]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    hm.clear();\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    rep(i, n) {\n      DD[i].resize(D[i].size());\n      rep(j, D[i].size()) {\n\tDD[i][j] = hm[D[i][j]];\n      }\n    }\n    \n    rep(i, 1<<20) dp0[i] = 0;\n    rep(i, 1<<20) dp1[i] = 0;\n    \n    calc(dp0, 0, n/2);\n    calc(dp1, n/2, n);\n\n    //continue;\n    \n    int len = n - (n/2);\n    rep(i, 1<<((n+1)/2))  masks[i] = (1<<len)-1;\n    vector<int> ngs(n/2);\n    rep(i, n/2) {\n      for(const auto& tt : DD[i]) {\n\tint t = tt - n / 2;\n\tif(t < 0) continue;\n\tngs[i] |= (1<<t);\n      }\n    }\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tint tmp = masks[mask]&ngs[i];\n\tmasks[mask] -= tmp;\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp0[mask] + dp1[masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cassert>\n#include <cstdio>\nusing namespace std;\n#define MAX 41\n#define TEST 0\n\ntypedef long long int ll;\n\nint n;\nmap<string,int> names;\nint b[MAX],c[MAX];\nstring ds[MAX][MAX];\nint graph[MAX][MAX];\n\n\nint rmax;\nll rmaxs;\nvoid rec(ll bits,int sum){//gradually elim-ing vertices\n    if(TEST)\n        printf(\"bits=%llx,sum=%d\\n\",bits,sum);\n    if(sum<=rmax){\n        return;\n    }\n    if((bits&1)==0){//vertex 0 is not in the set\n        return;\n    }\n    int mini=90000;\n    int minv=-1;\n    for(int i=0;i<n;i++){\n        if((bits&(1LL<<i))==0){\n            continue;\n        }\n        int ind=b[i];\n        for(int j=0;j<n;j++){\n            if((bits&(1LL<<j))==0||i==j){\n                continue;\n            }\n            if(graph[i][j]){\n                ind+=b[j];\n            }\n        }\n        if(ind<mini){\n            mini=ind;\n            minv=i;\n        }\n    }\n    if(mini==sum){//clique\n        rmax=sum;\n        rmaxs=bits;\n        return;\n    }\n    //minv:minimum\n    ll set=1LL<<minv;\n    int w=b[minv];\n    for(int i=0;i<n;i++){\n        if((bits&(1LL<<i))&&graph[minv][i]){\n            set|=1LL<<i;\n            w+=b[i];\n        }\n    }\n    if(TEST)\n    printf(\"minv=%d,set=%llx,w=%d\\n\",minv,set,w);\n    rec(set,w);\n    rec(bits&~(1LL<<minv),sum-b[minv]);\n    return;\n}\n\n\nint main(void){\n    while(cin>>n&&n){\n        names.clear();\n        int sum=0;\n        for(int i=0;i<n;i++){\n            fill_n(graph[i],n,1);\n        }\n        for(int i=0;i<n;i++){\n            string a;\n            cin>>a>>b[i]>>c[i];\n            names.insert(pair<string,int>(a,i));\n            for(int j=0;j<c[i];j++){\n                string t;\n                cin>>t;\n                ds[i][j]=t;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int d=names[ds[i][j]];\n                graph[i][d]=0;\n            }\n            graph[i][i]=0;\n        }\n        ll bits=1;\n        sum=b[0];\n        for(int i=1;i<n;i++){\n            if(graph[0][i]){\n                bits|=1LL<<i;\n                sum+=b[i];\n            }\n        }\n        rmax=0;\n        rmaxs=0;\n        rec(bits,sum);\n        cout<<rmax<<endl;\n        if(TEST){\n            cout<<\"rmaxs\"<<hex<<rmaxs<<dec<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdint>\n#include <cassert>\n#include <functional>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\nnamespace lc {\nstruct Edge {\n\tint to;\n\texplicit Edge(int to) : to(to) { }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType, typename Func>\nvoid enumerate_maximal_independent_sets(\n\tconst AdjacencyList<EdgeType> &graph, Func func)\n{\n\tconst int n = graph.size();\n\tstd::vector<uint64_t> bit_graph(n), incr_bit_graph(n + 1);\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tuint64_t mask = 0;\n\t\tfor(const auto &e : graph[i]){ mask |= (1ull << e.to); }\n\t\tbit_graph[i] = mask;\n\t\tincr_bit_graph[i] = mask | incr_bit_graph[i + 1];\n\t}\n\tstd::function<void(int, uint64_t, uint64_t)> recur =\n\t\t[&, n](int i, uint64_t picked, uint64_t eliminated) -> void {\n\t\t\tif(i == n){\n\t\t\t\tif((picked | eliminated) == (1ull << n) - 1){ func(picked); }\n\t\t\t}else if((incr_bit_graph[i + 1] | eliminated) & (1ull << i)){\n\t\t\t\trecur(i + 1, picked, eliminated);\n\t\t\t\tif(!(eliminated & (1ull << i))){\n\t\t\t\t\trecur(\n\t\t\t\t\t\ti + 1, picked | (1ull << i),\n\t\t\t\t\t\teliminated | bit_graph[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trecur(i + 1, picked | (1ull << i), eliminated | bit_graph[i]);\n\t\t\t}\n\t\t};\n\trecur(0, 0, 0);\n}\n}\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n};\n}\nusing namespace std;\ntypedef lc::Edge Edge;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tlc::NameTable name_table;\n\t\tvector<int> powers(n);\n\t\tlc::AdjacencyList<Edge> graph(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring u_name;\n\t\t\tint p, m;\n\t\t\tcin >> u_name >> p >> m;\n\t\t\tconst int u = name_table[u_name];\n\t\t\tpowers[u] = p;\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tstring v_name;\n\t\t\t\tcin >> v_name;\n\t\t\t\tconst int v = name_table[v_name];\n\t\t\t\tgraph.add_edge(u, v);\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tlc::enumerate_maximal_independent_sets(graph, [&](uint64_t s){\n\t\t\tif((s & 1) == 0){ return; }\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tif(s & (1ull << i)){ sum += powers[i]; }\n\t\t\t}\n\t\t\tanswer = max(answer, sum);\n\t\t});\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint b[50], c[50];\nstring d[50][50];\nstring a[50];\n\nlong long can[50]; //いけないところは1\n\nmap< string , int > java;\nmap< long long, int> dp; \n\nint rec(long long ikeru, long long used){ //いけるとこ0\n  if(dp.find(ikeru)!=dp.end()) return dp[ikeru];\n  int ret = 0;\n  for(int i = 0; i < N; i++){\n    if((ikeru >> i) & 1LL) continue;\n    if((used >> i) & 1LL) continue;\n    if(used & can[i]) continue;\n    ret = max( ret, rec((ikeru|can[i]),used|(1LL << i)) + b[i]);\n  }\n  return dp[ikeru] = ret;\n}\n\nint main(){\n\n  while(cin >> N, N){\n    java.clear();\n    dp.clear();\n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> b[i] >> c[i];\n      java[a[i]] = i;\n\n      for(int j = 0; j < c[i]; j++){\n        cin >> d[i][j];\n      }\n    }\n\n    for(int i = 0; i < N; i++){\n      can[i] = 0;\n      for(int j = 0; j < c[i]; j++){\n        can[i] |= 1 << java[d[i][j]];\n      }\n    }\n\n    \n    cout << rec( can[0], 1) + b[0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define UNION 1\n#define NEIGHBOR 2\n\nstruct Union{\n\tstring A;\n\tint B,C;\n\tint D[42];\n\tqueue<string> S;\n} \tU[42];\n\nstruct UnionSearch{\n\tint State[42], B;\n};\n\nvoid AddUnion(UnionSearch *us, int u){\n\tus->State[u] = UNION;\n\tfor(int i=0;i<U[u].C;i++) us->State[ U[u].D[i] ] = NEIGHBOR;\n\tus->B += U[u].B;\n}\n\nint N;\nqueue <UnionSearch> US;\n\n\nint Find(string s){\n\tfor(int i=1;i<=N;i++) if(s==U[i].A) return i;\n\tprintf(\"error\");\n\treturn 0;\n}\n\nmain(){\n\tint i,c,Max;\n\tstring s;\n\twhile(cin>>N,N){\n\t//\tUS.clear();\n\t\twhile(!US.empty()) US.pop();\n\t\tfor(i=0;i<42;i++){\n\t\t\tU[i].A = \"\";\n\t\t\tU[i].B=0;\n\t\t\tU[i].C=0;\n\t\t\tmemset(U[i].D, 0, 42*sizeof(int));\n\t\t\twhile(!U[i].S.empty()) U[i].S.pop();\n\t\t}\n\t\tMax = 0;\n\t\tfor(i=1;i<=N;i++){\n\t\t\tcin>>U[i].A>>U[i].B>>c;\n\t\t\twhile(c--){\n\t\t\t\tcin>>s;\n\t\t\t\tU[i].S.push(s);\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=N;i++){\n\t\t\twhile(!U[i].S.empty()){\n\t\t\t\tU[i].D[U[i].C++] = Find(U[i].S.front());\n\t\t\t\tU[i].S.pop();\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tUnionSearch q={0};\n\t\tAddUnion(&q, 1);\n\t\tUS.push(q);\n\t\twhile(!US.empty()){\n\t\t\tq = US.front();\n\t\t\tUS.pop();\n\t\t\tint t;\n\t\t\tfor(t=1;t<=N;t++){\n\t\t\t\tif(!q.State[t])break;\n\t\t\t\n\t\t\t}\n\t\t\tif(t>N){\n\t\t\t\tMax = max(Max, q.B);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(i=0;i<U[t].C;i++){\n\t\t\t\tUnionSearch p = q;\n\t\t\t\tif(p.State[U[t].D[i]]) continue;\n\t\t\t\tAddUnion(&p, U[t].D[i]);\n\t\t\t\tUS.push(p);\n\t\t\t}\n\t\t\tAddUnion(&q, t);\n\t\t\tUS.push(q);\n\t\t}\n\t\tcout << Max << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<30\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> strength; //国の強さ\nmultimap<string,string> adjacentCountry; //隣接した国の関係\nll ans=0;\n\n\nint rec(map<string,bool> m,ll sum){\n  ll finsum=0;\n  bool fin=true;\n  map<string,bool>::iterator it = m.begin();\n  while(it != m.end()){\n    //cout << it->first << \" \" << it->second << endl;\n    fin*=it->second;\n    if(!it->second)finsum+=strength[it->first];  \n    it++;\n  }\n  if(fin || finsum == 0){\n    if(ans < sum)ans=sum;\n    return 0;\n  }\n\n  map<string,bool> preUsed;\n  ll preSum=0;\n  it = m.begin();\n  while(it != m.end()){\n    if(!it->second){\n      preSum=sum;\n      preSum+=strength[it->first];\n      //cout << \"sum = \" << sum  << \", it->first = \" << it->first << endl;\n   \n      map<string,bool>::iterator preIt = m.begin();\n      while(preIt != m.end()){\n\tpreUsed[preIt->first]=preIt->second;\n\t//cout << preIt->first << \" \" << preIt->second << endl;\n\t++preIt;\n      }\n      multimap<string,string>::iterator cpyIt = adjacentCountry.find(it->first); \n     int counter = adjacentCountry.count(it->first);\n      //cout << \"coutner = \" << counter << endl;\n      while(counter-- > 0){\n\t//cout << \"cpyIt->first = \" << cpyIt->first << endl;\n\tpreUsed[cpyIt->second]=true;\n\t//cout << \"cpyIt->second =\" << cpyIt->second << endl;\n\t++cpyIt;\n      }\n      preUsed[it->first]=true;\n      /*\n  map<string,bool>::iterator wr = preUsed.begin();\n      while(wr != preUsed.end()){\n\tcout << wr->first << \" \" << wr->second << endl;\n\t++wr;\n      }\n      cout << \"----------------------------------------^w^----\" << endl;\n      */\n      rec(preUsed,preSum);\n    }\n\n    ++it;\n  }\n  \n\n\n\n\n}\n\n\nint main(){\n  int n,val,os;\n  string s,oc;\n  map<string,bool> used;\n  ll sum=0;\n\n  while(true){\n    scanf(\"%d\",&n);\n    if(n == 0)break;\n    ans=0;\n    used.clear();\n    adjacentCountry.clear();\n    strength.clear();\n    rep(i,n){\n      cin >> s;\n      scanf(\"%d %d\",&val,&os);\n      strength[s]=val;\n      if(!used[s])used[s]=false;\n      rep(j,os){\n\tcin >> oc;\n\tadjacentCountry.insert(multimap<string,string>::value_type(s,oc));      \n      }\n      \n      if(i == 0){\n\tsum = val;\n\tused[s]=true;\n\tmultimap<string,string>::iterator sit = adjacentCountry.begin();\n\t//cout << \"IN  ----------------------------\" << endl;\n\twhile(sit != adjacentCountry.end()){\n\t  used[sit->second]=true;\n\t  //cout << sit->second << \" \" <<used[sit->second] << endl;\n\t  ++sit;\n\t}\n\t//cout << \"OTU ========================\" << endl;\n\n      }\n      \n    }\n\n\n\n\n    /*\n    cout << \"-----------------\" << endl;\n    map<string,bool>::iterator it = used.begin();\n    while(it != used.end()){\n      cout << \"it->first = \" << it->first << endl;\n      cout << it->second << endl;\n      ++it;\n    }\n    cout << \"-------------------\" << endl;\n    */\n\n    rec(used,sum);\n    cout << ans << endl;\n    \n\n\n\n  }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint V;\nconst int MAX_V=40;\nvector<int> G[MAX_V];\nbool used[MAX_V];\nint ord[MAX_V];\nint cnt[MAX_V];\t\t//cnt[v] = the num of selected verticies connected with v;\ntypedef long long ll;\nset<ll> done;\n\nint ans,power[40],m[40];\nstring name[40];\nvector<string> names[40];\n\nvoid dfs(int it){\n\tif(it==V){\n\t\tll x=0;\n\t\trep(i,V) if(used[i]) x|=(1LL<<i);\n\t\tif(done.find(x)!=done.end()) return;\n\t\tdone.insert(x);\n\t\tif(!used[0]) return;\n\t\tint sum=0;\n\t\trep(i,V) if(used[i]) sum+=power[i];\n\t\tchmax(ans,sum);\n\t\treturn;\n\t}\n\tint v=ord[it];\n\tif(used[v]||cnt[v]){\n\t\tdfs(it+1);\n\t\treturn;\n\t}\n\t//use v\n\tused[v]=1;\n\tfor(int u:G[v]) cnt[u]++;\n\tdfs(it+1);\n\tused[v]=0;\n\tfor(int u:G[v]) cnt[u]--;\n\n\tfor(int u:G[v]) if(cnt[u]==0&&!used[u]){\n\t\tused[u]=1;\n\t\tfor(int w:G[u]) cnt[w]++;\n\t\tdfs(it+1);\n\t\tused[u]=0;\n\t\tfor(int w:G[u]) cnt[w]--;\n\t}\n}\nvoid enum_ind(int N){\n\tV=N;\n\ttypedef pair<int,int> P;\n\tvector<P> tmp;\n\trep(i,N) tmp.pb(P(G[i].size(),i));\n\tsort(all(tmp));\n\trep(i,N) ord[i]=tmp[i].sc;\n\trep(i,N) used[i]=0,cnt[i]=0;\n\tdone.clear();\n\tdfs(0);\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N) names[i].clear();\n\t\trep(i,N) G[i].clear();\n\t\tans=0;\n\t\trep(i,N){\n\t\t\tcin>>name[i]>>power[i]>>m[i];\n\t\t\trep(j,m[i]){\n\t\t\t\tstring st;\n\t\t\t\tcin>>st;\n\t\t\t\tnames[i].pb(st);\n\t\t\t}\n\t\t}\n\t\trep(i,N){\n\t\t\trep(j,m[i]){\n\t\t\t\trep(k,N){\n\t\t\t\t\tif(name[k]==names[i][j]) G[i].pb(k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenum_ind(N);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if(ne & (1LL<<i) != 0) continue;\n        if(((ne | cs[i].ne) ^ (ne | (1<<i))) < 1LL){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n\n    priority_queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.top().second.second;\n        power = pq.top().second.first;\n        int v = pq.top().first + 1;\n        pq.pop();\n        res = max(res, power);\n        if(v > n - 1) continue;\n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        \n        int sum = power;\n        for(int i = v + 1; i < n; i++){\n            if(((1LL<<i) & ne) != 0) sum += cs[i].power;\n        }\n        if(sum < res) continue;\n\n        ll nne = ne;\n        int npower = power;\n        for(int i = v + 1; i < n; i++){\n            if((nne & (1LL<<i)) != 0) continue;\n            if(((nne | cs[i].ne) ^ (nne | (1<<i))) < (1LL<<(v))){\n                nne |= cs[i].ne;\n                npower += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(npower, nne)));\n        \n        \n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if(((ne | cs[i].ne) ^ (ne | (1LL<<i))) < (1LL<<v)){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\n\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    vector<int> dp0(1<<half);\n    vector<int> vs0(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=0;i<(1<<half);i++){\n        int vs=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                dp0[i]+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) dp0[i]=-INF;\n        }\n    }\n\n    vector<int> dp1(1<<rest);\n    vector<int> vs1(rest,0);\n    for(int i=0;i<rest;i++){\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                dp1[i]+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) dp1[i]=-INF;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n\n    vector<int> vs01(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]>=half) vs01[i]|=(1<<(g[i][j]-half));\n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if(i&(1<<j)) opn&=~vs01[j];\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    //ios_base::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int msb(int v) { return 1 << 31 - __builtin_clz(v); }\ninline int lsb(int v) { return v & -v; }\ninline long msb(long v) { return 1ll << 63 - __builtin_clzll(v); }\ninline long lsb(long v) { return v & -v; }\n\n//// idconv ////\ntemplate<class T>\nstruct idconv\n{\n\tvector<T> v;\n\tint get(T t)\n\t{\n\t\tint id = (int)(find(allof(v), t) - v.begin());\n\t\tif (id == v.size()) v.push_back(t);\n\t\treturn id;\n\t}\n};\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\nint dfs(const vector<pair<int, long>> &nations, long cand, map<long, int> &memo)\n{\n\tif (!cand) return 0;\n\tif (memo.count(cand)) return memo[cand];\n\tpair<int, long> dt = nations[__builtin_ctzll(cand)];\n\treturn memo[cand] = max(dt.first + dfs(nations, cand & ~dt.second, memo), dfs(nations, cand & ~lsb(cand), memo));\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tvector<bitset<64>> adj(N);\n\t\tvector<pair<int, long>> nations(N);\n\t\tidconv<string> idc;\n\t\tREP(_, N)\n\t\t{\n\t\t\tint id = idc.get(read<string>());\n\t\t\tint pw = read<int>();\n\t\t\tlong a = 1ll << id;\n\t\t\tfor (auto &s : readjag<string>()) a |= 1ll << idc.get(s);\n\t\t\tadj[id] = a;\n\t\t\tnations[id] = make_pair(pw, a);\n\t\t}\n\n\t\tint sum = nations[0].first;\n\t\tlong candidate = (1ll << N) - 1 & ~nations[0].second;\n\n\t\t// グラフ分割\n\t\tREP(k, N) REP(i, N) REP(j, N) adj[i][j] = adj[i][j] | (adj[i][k] & adj[k][j]);\n\n\t\tREP(i, N)\n\t\t{\n\t\t\tlong cand = candidate & adj[i].to_ullong();\n\t\t\tif (cand)\n\t\t\t{\n\t\t\t\tmap<long, int> memo;\n\t\t\t\tsum += dfs(nations, cand, memo);\n\t\t\t\tcandidate &= ~cand;\n\t\t\t}\n\t\t}\n\t\tWRITE(sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nmap<string,int> id;\nmap<string,long long> bit;\nmap<long long, long long> memo;\nvector<int> sum(50);\nint n;\nint maximum;\nstring a[50], d[50][50];\nint b[50], c[50];\n\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nvoid dfs(int p, long long used , int score){\n\tmaximum = max(maximum, score);\n\tif(p == n) return;\n\tif(score + sum[p - 1] <= maximum) return;\n\n\tlong long next = used bitor bit[a[p]];\n\tif(not getBit(used,p)) dfs(p, next, score + b[p]);\n\n\tdfs(p + 1, used, score);\n\n}\n\nsigned main(){\n\twhile(cin >> n,n){\n\t\tid.clear();\n\t\tbit.clear();\n\t\tmemo.clear();\n\t\tsum.clear();\n\t\tmaximum = 0;\n\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tsum[i] = b[i];\n\t\t\tid[a[i]] = i;\n\t\t\trep(j,c[i]){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,n - 1){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\t\trep(i,n){\n\t\t\tlong long near = setBit(0,i);\n\t\t\trep(j,c[i]){\n\t\t\t\tnear = setBit(near, id[d[i][j]]);\n\t\t\t}\n\t\t\tbit[a[i]] = near;\n\t\t}\n\n\n\n\t\tdfs(1, bit[a[0]], b[0]);\n\t\tcout << maximum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nmap< long long , int > dp;\n\nint N;\nint b[40], c[40];\nstring d[40][40];\nstring a[40];\n\nlong long can[40]; //いけないところは1\n\nmap< string , int > java;\n\nint rec(long long used, long long sintyoku){ \n  if(dp.find(used) != dp.end()) return dp[used];\n  int ret = 0;\n  for(int i = 0; i < N; i++){\n    if((used >> i) & 1) continue; //既に行っている\n    if(used & can[i]) continue; //いけないところがあったらそこにはいけない\n    ret = max( ret, rec( used | (1 << i), sintyoku | can[i]) + b[i]);\n  }\n  return dp[used] = ret;\n}\n\nint main(){\n\n  while(cin >> N, N){\n    java.clear();\n    dp.clear();\n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> b[i] >> c[i];\n      java[a[i]] = i;\n\n      for(int j = 0; j < c[i]; j++){\n        cin >> d[i][j];\n      }\n    }\n\n    for(int i = 0; i < N; i++){\n      can[i] = 0;\n      for(int j = 0; j < c[i]; j++){\n        can[i] |= 1 << java[d[i][j]];\n      }\n    }\n\n    \n    cout << rec( 0, 0) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint m, q[64];\n\nvoid collect(int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q[m++] = at;\n    rep (i, N) if (g[at][i]) collect(i);\n}\n\nint n, a, r[64], p[64], w[4][1024];\nInt f[64];\n\nvoid prepare() {\n    n = m;\n    a = 0;\n    rep (i, n) r[i] = q[i];\n    rep (i, n) {\n        p[i] = B[r[i]];\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n    rep (k, 4) rep (b, 1024) {\n        int s = 0;\n        for (int i = 0; i < 10 && k*10+i < n; i++) if (b&(1<<i)) s += p[i];\n        w[k][b] = s;\n    }\n}\n\nvoid rec(int k, Int u) {\n    int s = w[0][u&1023] + w[1][(u>>10)&1023]\n        + w[2][(u>>20)&1023] + w[3][(u>>30)&1023];\n    if (s < a) return ;\n    if (k == n) a = s;\n    else {\n        rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return ;\n        const int mask = (1LL<<n) - 1;\n        if (u&(1LL<<k)) rec(k+1, u&(mask-f[k]));\n        if (r[k]) rec(k+1, u&(mask-(1LL<<k)));\n    }\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        m = 0;\n        collect(i);\n        prepare();\n        rec(0, (1LL<<n)-1);\n        ans += a;\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N, B[40];\nvector<int> D[40];\n\nint dfs(int n, int *flag_)\n{\n    int preproc = 0, res = 0;\n    int flag[40];\n    for(int i = 0; i < N; ++i)\n        flag[i] = flag_[i];\n    \n    flag[n] = 1;\n    for(int i = 0; i < D[n].size(); ++i)\n        flag[D[n][i]] = -1;\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n    \tif(flag[i] != 0) continue;\n        bool f = true;\n        for(int j = 0; j < D[i].size(); ++j)\n            if(flag[D[i][j]] != -1) {\n                f = false; break;\n            }\n        if(f)\n            flag[i] = 1, preproc += B[i];\n    }\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n        if(flag[i] != 0) continue;\n        int tmp = B[i] + dfs(i, flag);\n        res = max(res, tmp);\n        flag[i] = -1;\n    }\n    \n    return preproc + res;\n}\n\nint main()\n{\n    int C;\n    string A, Dt;\n    \n    while(cin >> N && N)\n    {\n        map<string, int> table;\n        vector<string> Ds[40];\n        for(int i = 0; i < 40; ++i) D[i].clear();\n        \n        for(int i = 0; i < N; ++i)\n        {\n            cin >> A >> B[i] >> C;\n            for(int j = 0; j < C; ++j)\n                cin >> Dt, Ds[i].push_back(Dt);\n            table[A] = i;\n        }\n        for(int i = 0; i < N; ++i)\n            for(int j = 0; j < Ds[i].size(); ++j)\n                D[i].push_back(table[Ds[i][j]]);\n        \n        int flag[40] = {};\n        int res = B[0] + dfs(0, flag);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// compile in C++11. use -std=c++11.\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define repeat(i,n) for(int i=0;i<static_cast<int>(n);i++)\n#define debug(x) #x << \"=\" << (x)\n#define dump(x) cerr << debug(x) << \" (L:\" << __LINE__ << \")\"<< endl\n\ntypedef long long ll;\ntypedef complex<double> point;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    os << \"[\";\n    for(const auto& v : vec){\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long ll;\n\nll solve(ll k,ll cur,ll mask,const vector<ll>& power,\n         const vector<ll>& masks,const vector<ll>& sum,ll& current_max){\n    int n = power.size();\n    if(k == n) return cur;\n    if(cur + sum[n] - sum[k-1] < current_max) return cur;\n    if(mask & (1 << k)){\n        // already masked\n        return solve(k+1,cur,mask,power,masks,sum,current_max);\n    }else{\n        current_max = cur+power[k];\n        return max(solve(k+1,cur+power[k],mask | masks[k],power,masks,sum,current_max),\n                   solve(k+1,cur,mask,power,masks,sum,current_max));\n    }\n}\n\nint main(){\n    while(true){\n        int n;cin >> n;\n        if(n == 0) break;\n        unordered_map<string,int> index_of;\n        int k = 0;\n        vector<ll> mask(n);\n        vector<ll> power(n);\n        for(int i=0;i<n;i++){\n            string A;int B,C;\n            cin >> A >> B >> C;\n            if(index_of.find(A) == index_of.end()){\n                index_of[A] = k;k++;\n            }\n            power[index_of[A]] = B;\n            for(int j=0;j<C;j++){\n                string d;cin >> d;\n                if(index_of.find(d) == index_of.end()){\n                    index_of[d] = k;k++;\n                }\n                mask[index_of[A]] = mask[index_of[A]] | (1 << index_of[d]);\n            }\n        }\n        // sum of [0..i)\n        vector<ll> sum(n+1);\n        for(int i=1;i<=n;i++){\n            sum[i] = sum[i-1] + power[i-1];\n        }\n        ll p = power[0];\n        cout << solve(1,power[0],mask[0],power,mask,sum,p) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\nusing namespace std;\nvector<long long int> G;\nvector< vector<int> > G_;\nvector<int> B;\nint N;\n\nint solve(int v, long long int t){\n  if(v >= B.size() || t == (1LL<<N) - 1) return 0;\n  int ret = 0;\n  if(!(t>>v & 1)){\n    long long t_ = t | (1LL<<v);\n    t_ |= G[v];\n    int v_ = v + 1;\n    while(t_>>v_ & 1) ++v_;\n    ret = B[v] + solve(v_,t_);\n\n    if(G_[v].empty() || \n       (G_[v].size() == 1 && B[G_[v][0]] <= B[v])) return ret;\n\n    //if(G[v] == 0LL) return ret;\n  }\n  int v_ = v + 1;\n  while(t>>v_ & 1) ++v_;\n  t |= 1LL<<v;\n  ret = max(ret, solve(v_,t));\n  return ret;\n}\n\nint main(){\n  while(cin >> N, N){\n    map<string,int> M;\n    vector< vector<string> > D(N);\n    string a;\n    B = vector<int>(N);\n    int c;\n    for(int i = 0; i < N; ++i){\n      cin >> a >> B[i] >> c;\n      M[a] = i;\n      string d;\n      for(int j = 0; j < c; ++j){\n        cin >> d;\n        D[i].push_back(d);\n      }\n    }\n    G = vector<long long int>(N,0LL);\n    G_ = vector< vector<int> >(N);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < D[i].size(); ++j){\n        G[i] |= 1LL<<M[D[i][j]];\n        G_[i].push_back(M[D[i][j]]);\n      }\n    }\n    long long int t = 1LL;\n    t |= G[0];\n    cout << B[0] + solve(1,t) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nchar str[50];\nstring name[50];\nint b[50];\nint c[50];\nstring d[50][50];\nint g[50][50];\nint n;\nint deg[50];\nint dfs(vector<int>use){\n\tbool ok=true;\n\tint ret=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(use[i]==1)ret+=b[i];\n\t\tif(use[i]==-1)ok=false;\n\t}\n\tif(ok){\n\t\t/*if(ret>40){\n\t\t\tfor(int i=0;i<use.size();i++)printf(\"%d \",use[i]);\n\t\t\tprintf(\": %d\\n\",ret);\n\t\t}*/\n\t\treturn ret;\n\t}\n\tint m=-1;\n\tint at=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]&&m<deg[i]){\n\t\t\tm=deg[i];at=i;\n\t\t}\n\t}\n\t// use\n\tret=0;\n\tvector<int> to=use;\n\tto[at]=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]&&g[at][i]){\n\t\t\tto[i]=0;\n\t\t}\n\t}\n\tret=max(ret,dfs(to));\n\t// non use\n\tto=use;\n\tto[at]=0;\n\tret=max(ret,dfs(to));\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tmap<string,int>m;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint p,q;scanf(\"%s%d%d\",str,&p,&q);\n\t\t\tname[i]=str;\n\t\t\tb[i]=p;\n\t\t\tc[i]=q;\n\t\t\tm[name[i]]=i;\n\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\tscanf(\"%s\",str);\n\t\t\t\td[i][j]=str;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<c[i];j++)\n\t\t\tg[i][m[d[i][j]]]=1;\n\t\tfor(int i=0;i<a;i++)deg[i]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)deg[i]+=g[i][j];\n//\t\tfor(int i=0;i<a;i++){\n\t//\t\tfor(int j=0;j<a;j++)printf(\"%d \",g[i][j]);printf(\"\\n\");\n\t\t//}\n\n\t\tvector<int> s(a,-1);\n\t\ts[0]=1;\n\t\tfor(int i=0;i<a;i++)if(g[0][i])s[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]==0)s[i]=1;\n\t\t}\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]==1){\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(g[i][j]&&deg[j]==1){\n\t\t\t\t\t\tif(i&&j){\n\t\t\t\t\t\t\tif(b[i]>=b[j]){\n\t\t\t\t\t\t\t\ts[i]=1;s[j]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(s));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tvector<vector<bool>> E(N, vector<bool>(N));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << A[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1LL << n;\n\t\t\tint NY = 1LL << (N - n);\n\t\t\tvector<int> X(NX), Y(NY);\n\n\t\t\tauto indx = [&](int mask) {\n\n\t\t\t\t// 頂点\n\t\t\t\tvector<int> v;\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\tif ((mask >> j) & 1)\n\t\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\n\t\t\t\tfor (auto p1 : v)for (auto p2 : v) {\n\t\t\t\t\tif (E[p1][p2] == true)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\t\t\tauto indy = [&](int mask) {\n\n\t\t\t\t// 頂点\n\t\t\t\tvector<int> v;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif ((mask >> j) & 1)\n\t\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\n\t\t\t\tfor (auto p1 : v)for (auto p2 : v) {\n\t\t\t\t\tif (E[p1 + n][p2 + n] == true)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\n\t\t\tvector<int> cost(NY);\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy(nmask))\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx(mask))continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tint tmp = 0;\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t\trep(j, n, N) {\n\t\t\t\t\t\t\tif (E[i][j])\n\t\t\t\t\t\t\t\ttmp |= 1 << (j - n);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx -= tmp;\n\n\t\t\t\t//cerr << \"m \" << bitset<4>(mask) << \" \" << cost_a << endl;\n\t\t\t\t//cerr << \"x \" << bitset<4>(x) << \" \" << cost[x] << endl;\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\nusing namespace std;\n\nint main(){\n    int N;\n    while(cin>>N,N){\n        map<string,int> A;\n        int B[40];\n        fill(B,B+40,0);\n        vector<string> D[40];\n        set<string> D0;\n        string A0;\n        cin>>A0;\n        A[A0]=0;\n        cin>>B[0];\n        int C0;\n        cin>>C0;\n        for(int i=0;i<C0;i++){\n            string Di;\n            cin>>Di;\n            D0.insert(Di);\n        }\n        int cnt=1;\n        for(int i=1;i<N;i++){\n            string name;\n            cin>>name;\n            if(D0.count(name)){\n                int b,c;\n                cin>>b>>c;\n                while(c--) cin>>name;\n            }else{\n                A[name]=cnt;\n                cin>>B[cnt];\n                int C;\n                cin>>C;\n                for(int j=0;j<C;j++){\n                    string S;\n                    cin>>S;\n                    if(!D0.count(S)) D[cnt].push_back(S);\n                }\n                cnt++;\n            }\n        }\n        N-=C0;\n\n        int64_t mask[N];\n        fill(mask,mask+N,0);\n        for(int i=0;i<N;i++){\n            for(auto s:D[i]){\n                int j = A[s];\n                mask[i]|=(1LL<<j);\n            }\n        }\n\n        int DP[1<<N/2];\n        fill(DP,DP+(1<<N/2),0);\n        for(int64_t s=1;s<(1LL<<N/2);s+=2){\n            int64_t adj = 0;\n            for(int i=0;i<N/2;i++){\n                adj|=((s>>i)&1LL)*(mask[i]&s);\n            }\n            if(!adj){\n                for(int i=0;i<N/2;i++){\n                    if((s>>i)&1LL) DP[s]+=B[i];\n                }\n            }\n        }\n        for(int64_t s=1;s<(1LL<<N/2);s+=2){\n            for(int i=1;i<N/2;i++){\n                DP[s|(1LL<<i)]=max(DP[s|(1LL<<i)],DP[s]);\n            }\n        }\n        int ans = 0;\n        for(int64_t s=0;s<(1LL<<N);s+=(1LL<<N/2)){\n            int64_t adj=0;\n            for(int i=N/2;i<N;i++){\n                adj|=((s>>i)&1LL)*(mask[i]&s);\n            }\n            if(adj) continue;\n            int sum = 0;\n            for(int i=N/2;i<N;i++){\n                if((s>>i)&1LL) sum+=B[i];\n            }\n            int64_t b = (1<<N/2)-1;\n            for(int i=N/2;i<N;i++){\n                if((s>>i)&1LL) b&=~mask[i];\n            }\n            ans = max(ans,sum+DP[b]);\n        }\n        cout<<ans<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<vector<ll>> g;\nvector<ll> power;\nvector<ll> used;\nvector<P> ord;\n\nvoid build_graph() {\n\tmap<string,ll> dict;\n\tll cnt = 0;\n\tREP(i,n) {\n\t\tstring a; ll b, c;\n\t\tcin >> a >> b >> c;\n\t\tif(dict.count(a) == 0) {\n\t\t\tdict[a] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p = dict[a];\n\t\tpower[dict[a]] = b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tif(dict.count(t) == 0) {\n\t\t\t\tdict[t] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tg[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx, ll sum) {\n\tif(idx == n) return sum;\n\tif(used[ord[idx].second] != -1) return dfs(idx + 1, sum);\n\tll ret = 0;\n\tvector<ll> tmp(n);\n\tREP(i,n) tmp[i] = used[i];\n\tif((ll)g[ord[idx].second].size() > 1) {\n\t\tused[ord[idx].second] = 0;\n\t\tret = max(ret, dfs(idx + 1, sum));\n\t}\n\tused[ord[idx].second] = 1;\n\tREP(i,g[ord[idx].second].size()) used[g[ord[idx].second][i]] = 0;\n\tret = max(ret, dfs(idx + 1, sum + power[ord[idx].second]));\n\tREP(i,n) used[i] = tmp[i];\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tused.assign(n, -1);\n\tord.resize(n);\n\tg.resize(n); build_graph();\n\tll sum = 0;\n\tREP(i,n) if(used[i] == -1) {\n\t\tif(i == 0) {\n\t\t\tused[i] = 1;\n\t\t\tREP(j,g[i].size()) used[g[i][j]] = 0;\n\t\t\tsum += power[i];\n\t\t\tcontinue;\t\n\t\t}\n\t\tif(g[i].size() == 0) {\n\t\t\tused[i] = 1;\n\t\t\tsum += power[i];\n\t\t}\n\t\tif(g[i].size() == 1 && g[g[i][0]].size() == 1) {\n\t\t\tif(power[i] >= power[g[i][0]]) {\n\t\t\t\tused[i] = 1; used[g[i][0]] = 0;\n\t\t\t\tsum += power[i];\n\t\t\t} else {\n\t\t\t\tused[i] = 0; used[g[i][0]] = 1;\n\t\t\t\tsum += power[g[i][0]];\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n) {\n\t\tord[i].first = (ll)g[i].size();\n\t\tord[i].second = i;\n\t\tif(i == 0) ord[i].first = INF;\n\t}\n\tsort(ALL(ord)); reverse(ALL(ord));\n\treturn dfs(0, sum);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nvector<int> atk, bit;\n\nvoid input(int n){\n\tvector<string> name(n);\n\tvector<vector<string>> near(n);\n\n\tmap<string, int> id;\n\trep(i,n){\n\t\tint d;\n\t\tcin >> name[i] >> atk[i] >> d;\n\t\tid[name[i]] = i;\n\t\twhile(d--){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tnear[i].emplace_back(s);\n\t\t}\n\t}\n\n\trep(i,n){\n\t\t//bit[i] |= 1 << i;\n\t\tfor(auto s : near[i]){\n\t\t\tbit[i] |= 1 << id[s];\n\t\t}\n\t\t//cout << bitset<10>(bit[i]) << endl;\n\t}\n}\n\nvoid dfs(int& n, int& low, int& high, map<pair<int, int>, int>& memo, int enemy, int frined, int sum){\n\tif(memo.count(make_pair(enemy, frined))){\n\t\tif(memo[make_pair(enemy, frined)] >= sum) return;\n\t}\n\tmemo[make_pair(enemy, frined)] = sum;\n\trange(i,low,high){\n\t\tif(getBit(enemy,i)) continue;\n\t\tif(getBit(frined,i)) continue;\n\t\tdfs(n, low, high, memo, enemy bitor bit[i], frined bitor (1 << i), sum + atk[i]);\n\t}\n}\n\nconst int MAX = 16;\nmap<pair<int,int>, int> memo1, memo2;\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tatk = vector<int>(n);\n\t\tbit = vector<int>(n,0);\n\t\tinput(n);\n\n\t\tint half = n / 2;\n\n\t\tmemo1.clear();\n\t\tmemo2.clear();\n\t\tint s = 0;\n\t\tdfs(n, s, half, memo1, 1, bit[0], atk[0]);\n\t\tdfs(n, half, n, memo2, 0, 0, 0);\n\n\t\tvector<int> dp(1 << MAX, 0); // dp[s] := 集合sから任意の数, 仲間を選べるときの最大値\n\t\tfor(auto i : memo2){\n\t\t\tdp[i.first.second] = i.second;\n\t\t}\n\t\trep(i, 1 << MAX){\n\t\t\trep(j,MAX){\n\t\t\t\tdp[setBit(i,j)] = max(dp[setBit(i,j)], dp[i]);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(auto i : memo1){\n\t\t\tbitset<MAX> b(i.first.second);\n\t\t\tans = max(ans, i.second + dp[(~b).to_ulong()]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\nconst int HALF=20;\nvector<int> dp0(1<<HALF);\nvector<int> vs0(HALF,0);\nvector<int> dp1(1<<HALF);\nvector<int> vs1(HALF,0);\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    for(int i=0;i<half;i++){\n        vs0[i]=0;\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=1;i<(1<<half);i+=2){\n        int vs=0;\n        int val=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                val+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) val=-INF;\n            dp0[i]=val;\n        }\n    }\n\n    \n    for(int i=0;i<rest;i++){\n        vs1[i]=0;\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        int val=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                val+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) val=-INF;\n            dp1[i]=val;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n\n    vector<int> vs01(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]>=half) vs01[i]|=(1<<(g[i][j]-half));\n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if(i&(1<<j)) opn&=~vs01[j];\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    //ios_base::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i, n) for(int i = 0; i < (int)(n); ++i)\n\nusing namespace std;\n\ntypedef vector<int> Node;\ntypedef vector<Node> Graph;\n\nusing ull = unsigned long long;\ninline int trail(ull s) {\n  return (s ? __builtin_ctzll(s) : 64);\n}\n// O(3^(n/3)) ?\n// reference:https://sites.google.com/site/indy256/algo/bron_kerbosh\ntemplate <typename T>\nT BronKerbosch(const vector<ull>& g, ull cur, ull allowed,\n               ull forbidden, const vector<T>& w) {\n  if(allowed == 0 && forbidden == 0) {\n    T res = 0;\n    for(int u = trail(cur); u < g.size();\n        u += trail(cur >> (u + 1)) + 1)\n      res += w[u];\n    return res;\n  }\n  if(allowed == 0) return -1;\n  T res = -1;\n  int piv = trail(allowed | forbidden);\n  ull z = allowed & ~g[piv];\n  for(int u = trail(z); u < g.size();\n      u += trail(z >> (u + 1)) + 1) {\n    res = max(res, BronKerbosch(g, cur | (1ULL << u),\n                                allowed & g[u],\n                                forbidden & g[u], w));\n    allowed ^= 1ULL << u;\n    forbidden |= 1ULL << u;\n  }\n  return res;\n}\n\ntemplate <typename T>\nT maxmum_clique(const vector<vector<int>> G,\n                const vector<T>& w) {\n  int n = G.size();\n  assert(n < 64);\n  vector<ull> g(n, 0);\n  for(int i = 0; i < n; ++i)\n    for(int j : G[i]) g[i] ^= 1ULL << j;\n  return BronKerbosch(g, 0, (1ULL << n) - 1, 0, w);\n}\n\ntemplate <typename T>\nT maximal_independent_set(const vector<vector<int>>& G,\n                          const vector<T>& w) {\n  int n = G.size();\n  assert(n < 64);\n  vector<ull> g(n, (1ULL << n) - 1);\n  for(int i = 0; i < n; ++i) {\n    g[i] ^= 1ULL << i;\n    for(int j : G[i]) g[i] ^= 1ULL << j;\n  }\n  return BronKerbosch(g, 0, (1ULL << n) - 1, 0, w);\n}\n\nstruct country {\n  string name;\n  int n;\n  long long s;\n  vector<string> v;\n};\n\nint n, mid;\nmap<string, int> mp;\nvector<country> v;\nvector<int> w;\nvector<vector<int>> edge;\n\nint main() {\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    mp.clear();\n    v.clear();\n    v.resize(n);\n    w.resize(n);\n    edge.clear();\n    edge.resize(n - 1);\n    for(int i = 0; i < n; ++i) {\n      cin >> v[i].name >> w[i] >> v[i].n;\n      for(int j = 0; j < v[i].n; ++j) {\n        string x;\n        cin >> x;\n        v[i].v.push_back(x);\n      }\n      mp[v[i].name] = i;\n    }\n    for(int i = 1; i < n; ++i)\n      for(auto s : v[i].v)\n        if(mp[s] > 0) edge[i - 1].push_back(mp[s] - 1);\n    vector<int> nw(n - 1, 0);\n    for(int i = 1; i < n; ++i) nw[i - 1] = w[i];\n    for(auto s : v[0].v) nw[mp[s] - 1] = 0;\n    cout << maximal_independent_set<int>(edge, nw) + w[0]\n         << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint r[64], p[64];\nInt f[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nvoid prepare(vector<int>& q) {\n    const int n = q.size();\n    vector<pair<int, int> > ps;\n    rep (i, n) ps.push_back(mp(-B[q[i]], q[i]));\n    sort(ps.begin(), ps.end());\n    rep (i, n) r[i] = ps[n-1-i].second;\n    //rep (i, n) r[i] = q[i];\n    rep (i, n) p[i] = B[r[i]];\n    rep (i, n) {\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nint n, a;\n\nvoid rec(int k, Int u) {\n    int s = 0;\n    rep (i, n) if (u&(1LL<<i)) s += p[i];\n    if (s < a) return ;\n    if (k == n) a = s;\n    else {\n        rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return ;\n        const int mask = (1LL<<n) - 1;\n        if (u&(1LL<<k)) rec(k+1, u&(mask-f[k]));\n        if (r[k]) rec(k+1, u&(mask-(1LL<<k)));\n    }\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        n = q.size();\n        a = 0;\n        rec(0, (1LL<<q.size())-1);\n        ans += a;\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n;\nstring name[40];\nvector<string> neighbor[40];\nmap<string,int> name2id;\nint a[40],b[40],c[40];\nint G[40][40];\n\nconst int N=1<<20;\nint dp[N];\nint NG[40],OK[40];\n\nint main()\n{\n    cin.tie(0);ios::sync_with_stdio(false);\n\n    while(cin >>n,n)\n    {\n        // initialize\n        name2id.clear();\n        rep(i,40) neighbor[i].clear();\n        memset(G,0,sizeof(G));\n        memset(dp,0,sizeof(dp));\n        memset(NG,0,sizeof(NG));\n        memset(OK,0,sizeof(OK));\n\n        // input\n        rep(i,n)\n        {\n            cin >>name[i] >>b[i] >>c[i];\n            neighbor[i].resize(c[i]);\n            rep(j,c[i]) cin >>neighbor[i][j];\n\n            a[i] = i;\n            name2id[name[i]] = i;\n        }\n\n        rep(i,n)rep(j,c[i]) G[i][name2id[neighbor[i][j]]] = 1;\n\n        int X=n/2, Y=n-X;\n\n        // make NG mask\n        rep(i,X)rep(j,X)if(G[i][j]) NG[i] |= 1<<j;\n        rep(i,Y)rep(j,Y)if(G[X+i][X+j]) NG[X+i] |= 1<<j;\n\n        // make OK mask\n        rep(i,X)rep(j,Y)if(G[i][X+j]==0) OK[i] |= 1<<j;\n\n        // ?????????????????????????????¶\n        rep(mask,1<<Y)\n        {\n            bool ok=true;\n            int sum=0;\n            rep(i,Y)if(mask>>i&1)\n            {\n                ok &= ((NG[X+i]&mask) == 0);\n                sum += b[X+i];\n            }\n\n            if(ok) dp[mask] = sum;\n        }\n\n        rep(mask,1<<Y)rep(i,Y)if(!(mask>>i&1))\n        {\n            int nmask = mask|(1<<i);\n            dp[nmask] = max(dp[nmask],dp[mask]);\n        }\n\n        int ans=0;\n        // ?????????????????????????????¶\n        for(int mask=1; mask<(1<<X); mask+=2)\n        {\n            bool ok=true;\n            int val = 0, t = (1<<Y)-1;\n            rep(i,X)if(mask>>i&1)\n            {\n                ok &= ((NG[i]&mask) == 0);\n                val += b[i];\n                t &= OK[i];\n            }\n            if(!ok) continue;\n\n            ans = max(ans, val+dp[t]);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nstring s[50],t;\nint n,a[50],x,ans,rui[50];\nvector<string>v[50];\nvector<int>vp[50];\nset<string>st[50];\nbool used[50];\nmap<string,int>m;\nvoid dfs(int d,int p){\n    if(used[d]){\n        dfs(d+1,p);\n        return ;\n    }\n    if(d==n)ans=max(ans,p);\n    else{\n        if(rui[d]+p<=ans)return ;\n        vector<int>vv;\n        r(i,vp[d].size()){\n            if(!used[vp[d][i]])\n              used[vp[d][i]]=1,\n              vv.push_back(vp[d][i]);\n        }\n        dfs(d+1,p+a[d]);\n        r(i,vv.size())used[vv[i]]=0;\n        if(rui[d]+p<=ans)return ;\n        dfs(d+1,p);\n    }\n}\nint main(){\n    while(cin>>n,n){\n        m.clear();\n        ans=0;\n        memset(used,0,sizeof(used));\n        r(i,50)v[i].clear();\n\tr(i,50)vp[i].clear();\n        r(i,n){\n            cin>>s[i];\n            cin>>a[i]>>x;\n            r(j,x){\n                cin>>t;\n                v[i].push_back(t);\n            }\n            m[s[i]]=i;\n        }\n\tr(i,n){\n\t  r(j,v[i].size()){\n\t    vp[i].push_back(m[v[i][j]]);\n\t  }\n\t}\n        rui[n-1]=a[n-1];\n        for(int i=n-2;i>=0;i--)\n            rui[i]=rui[i+1]+a[i];\n        used[0]=1;\n        r(i,v[0].size()){\n            used[m[v[0][i]]]=1;\n        }\n        dfs(1,a[0]);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\ntypedef pair<long long,int> P;\nint str[40];\nvector<string> se[40];\nvector<int> e[40];\nmap<string,int> ct;\nmap<long long,int> dp[2];//00010:0がunused 1がused\nint main(){\n\tint n;\n\tint i,j;\n\twhile(1){\n\tscanf(\"%d\",&n);\n\tif(n==0)return 0;\n\tdp[0].clear();\n\tdp[1].clear();\t\n\tct.clear();\n\tfor(i=0;i<n;i++){\n\t\tse[i].clear();\n\t\te[i].clear();\n\t}\n\tfor(i=0;i<n;i++){\n\t\tchar s[20];\n\t\tstring name;\n\t\tscanf(\" %s\",s);\n\t\tname.append(s);\n\t\tct[name]=i;\n\t\tint a,b;\n\t\tscanf(\"%d %d\",&a,&b);\n\t\tstr[i]=a;\n\t\tfor(j=0;j<b;j++){\n\t\t\tname.clear();\n\t\t\tscanf(\" %s\",s);\n\t\t\tname.append(s);\n\t\t\tse[i].push_back(name);\n\t\t}\n\t}\n\tfor(i=0;i<n;i++){\n\t\tfor(j=0;j<se[i].size();j++){\n\t\t\te[i].push_back(ct[se[i][j]]);\n\t\t}\n\t}\n\tlong long use=0;\n\tfor(j=0;j<e[0].size();j++)use|=(long long)1<<(e[0][j]-1);\n\tdp[1][use]=str[0];\n\tfor(i=1;i<n;i++){\n\t\tlong long use=0;\n\t\tfor(j=0;j<e[i].size();j++)if(e[i][j]>=i+1)use|=(long long)1<<(e[i][j]-i-1);\n\t\tdp[(i+1)%2].clear();\n\t\tmap<long long,int>::iterator it;\n\t\tfor(it=dp[i%2].begin();it!=dp[i%2].end();it++){\n\t\t\tP p=*it;\n\t\t\tlong long used=p.first;\n\t\t\tint mx=p.second;\n\t\t\tdp[(i+1)%2][used>>1]=max(dp[(i+1)%2][used>>1],mx);\n\t\t\tif(!(used&1))dp[(i+1)%2][(used>>1)|use]=max(dp[(i+1)%2][(used>>1)|use],mx+str[i]);\n\t\t}\n\t}\n\tprintf(\"%d\\n\",dp[n%2][0]);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 50;\n\nint N;\nmap<string,int> id;\nGraph g;\nint B[MAXN];\n\nlli adj[MAXN];\nint sum[MAXN];\nint ans;\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nvoid rec(int k, lli bit, int now) {\n  ans = max(ans, now);\n  if(now + sum[k] <= ans) return;\n  if(k == N) return;\n  if(!(bit & (1LL<<k))) rec(k+1, bit|adj[k], now+B[k]);\n  rec(k+1, bit, now);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    for(int v = 0; v < N; ++v) {\n      adj[v] = 0;//1LL<<v;\n      for(int i = 0; i < g[v].size(); ++i) {\n        int nv = g[v][i];\n        adj[v] |= 1LL<<nv;\n      }\n    }\n\n    sum[N] = 0;\n    for(int v = N-1; v >= 0; --v) sum[v] = sum[v+1] + B[v];\n\n    ans = 0;\n    rec(1, adj[0], B[0]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int>& f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tint tt = id.size();\n\t\t\t\tid[t] = tt;\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\nint max_f;\nvoid dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t{\n\t\tmax_swap(max_f, sum);\n\t\treturn;\n\t}\n\n\t{\n\t\tint rem = 0;\n\t\tfor (int i = d; i < m; ++i)\n\t\t\tif (!(enemy >> i & 1))\n\t\t\t\trem += force[i];\n\t\tif (sum + rem <= max_f)\n\t\t\treturn;\n\t}\n\n\tif (!(enemy >> d & 1))\n\t\tdfs(d + 1, enemy | on[d], sum + force[d]);\n\tdfs(d + 1, enemy, sum);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t{\n\t\t\t\tint t = id.size();\n\t\t\t\tid[a] = t;\n\t\t\t}\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t{\n\t\t\t\t\tint t = id.size();\n\t\t\t\t\tid[d] = t;\n\t\t\t\t}\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\n\t\tint res;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tmax_f = 0;\n\t\tdfs(1, on[0], force[0]);\n\t\tres = max_f;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tmax_f = 0;\n\t\t\t\tdfs(0, 0, 0);\n\t\t\t\tres += max_f;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <iostream>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define VI vector<int>\n#define LL long long\n#define VLL vector<LL>\n#define PB push_back\nusing namespace std;\nmap<string, int> m;\n//map<LL, int> ans;\nVI g;\nVI s;\nint n;\n\nint DFS(LL p){\n\t//if(EXIST(ans,p))return ans[p];\n\tint ret = 0;\n\tREP(i,n){\n\t\tif(!(p&(1LL<<i))){\n\t\t\tLL q = p|(1LL<<i);\n\t\t\tq|=g[i];\n\t\t\tret = max(ret,DFS(q)+s[i]); \n\t\t}\n\t}\n\t//return ans[p]=ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint ret=0;\n\t\tLL start=1LL;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)return 0;\n\t\ts=VI(n);\n\t\tg=VI(n);\n\t\tm.clear();\n\t\tint k=0,idx;\n\t\tREP(i,n){\n\t\t\tstring name;\n\t\t\tcin>>name;\n\t\t\tif(!EXIST(m,name)){\n\t\t\t\tidx=m[name]=k;\n\t\t\t\tk++;\n\t\t\t}else idx=m[name];\n\t\t\tg[idx]=(1LL<<idx);\n\t\t\tint q;\n\t\t\tcin>>s[idx]>>q;\n\t\t\tif(q==0){\n\t\t\t\tif(idx!=0)ret+=s[idx];\n\t\t\t\tg[0]|=(1LL<<idx);\n\t\t\t}\n\t\t\tREP(j,q){\n\t\t\t\tcin>>name;\n\t\t\t\tif(!EXIST(m,name)){\n\t\t\t\t\tm[name]=k;\n\t\t\t\t\tg[idx]|=(1LL<<k);\n\t\t\t\t\tk++;\n\t\t\t\t}else g[idx]|=(1LL<<m[name]);\n\t\t\t}\n\t\t}\n\t\tcout << DFS(g[0])+s[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint country2idx(map<string,int>& dict,string country){\n  int idx = dict.size();\n  if(dict.find(country) == dict.end()){\n    dict[country] = idx;\n    return idx;\n  }\n  return dict[country];\n}\n\nvector<int> edges[41];\nbool used[41];\nint power[41];\n\nbool can_unite(int node){\n  if(used[node]) return false;\n  for(int i=0;i<edges[node].size();i++){\n    if(used[edges[node][i]]) return false;\n  }\n  return true;\n}\n\nint dfs(int current,int sum,const vector<int>& subset){\n  if(current == subset.size()) return sum;\n\n  int res = sum;\n  int next = subset[current];\n  if(can_unite(next)){\n    used[next] = true;\n    res = max(res,dfs(current+1,sum + power[next],subset));\n    used[next] = false;\n  }\n  res = max(res,dfs(current+1,sum,subset));\n  return res;\n}\n\nclass UnionFindTree {\nprivate:\n  int parent[41];\n  int rank[41];\npublic:\n  UnionFindTree(){\n    for(int i = 0; i <= 40; i++){\n      parent[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  void unite(int lhs,int rhs) {\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(lhs == rhs) return;\n    \n    if(rank[lhs] < rank[rhs]){\n      parent[rhs] = lhs;\n      rank[rhs]++;\n    }\n    else{\n      parent[lhs] = rhs;\n      rank[lhs]++;\n    }\n  }\n\n  int find(int current){\n    if(current == parent[current]) return current;\n    else find(parent[current]);\n  }\n};\n\nint N;\nvoid make_subset(UnionFindTree* uft,int root,vector<int>& subset){\n  for(int i = 0; i < N; i++){\n    if(uft->find(i) == root){\n      subset.push_back(i);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    for(int i = 0; i <= 40; i++){\n      edges[i].clear();\n    }\n    UnionFindTree uft;\n    map<string,int> dict;\n    for(int country_i = 0; country_i < N; country_i++){\n      string country;\n      int tmp_power;\n      cin >> country >> tmp_power;\n      int adjacent_countries;\n      cin >> adjacent_countries;\n\n      int root = country2idx(dict,country);\n      power[root] = tmp_power;\n      for(int adj_i = 0; adj_i < adjacent_countries; adj_i++){\n        string adj_country;\n        cin >> adj_country;\n        int child = country2idx(dict,adj_country);\n        edges[root].push_back(child);\n        uft.unite(root,child);\n      }\n    }\n\n    bool tree[41];\n    memset(tree,false,sizeof(tree));\n\n    int res = 0;\n    for(int i = 0; i < N; i++){\n      if(tree[uft.find(i)]) continue;\n      tree[uft.find(i)] = true;\n      int tmp = 0;\n      vector<int> subset;\n      make_subset(&uft,uft.find(i),subset);\n      memset(used,false,sizeof(used));\n      if(i == 0){\n        used[0] = true;\n        tmp = max(tmp,dfs(0,power[0],subset));\n      }\n      else{\n        tmp = max(tmp,dfs(0,0,subset));\n      }\n      res += tmp;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define UNION true\n#define NEIGHBOR true\n\nstruct Union{\n\tstring A;\n\tint B,C;\n\tint D[42];\n\tqueue<string> S;\n} \tU[42];\n\nstruct UnionSearch{\n\tchar State[41];\n\tunsigned short B;\n};\n\nvoid AddUnion(UnionSearch *us, int u){\n\tus->State[u] = UNION;\n\tfor(int i=0;i<U[u].C;i++) us->State[ U[u].D[i] ] = NEIGHBOR;\n\tus->B += U[u].B;\n}\n\nint N;\nqueue <UnionSearch> US;\n\n\nint Find(string s){\n\tfor(int i=1;i<=N;i++) if(s==U[i].A) return i;\n\tprintf(\"error\");\n\treturn 0;\n}\n\nmain(){\n\tint i,c;\n\tunsigned short Max;\n\tstring s;\n\tUnionSearch q, p;\n\twhile(cin>>N,N){\n\t//\tUS.clear();\n\t\twhile(!US.empty()) US.pop();\n\t\tfor(i=0;i<42;i++){\n\t\t\tU[i].A = \"\";\n\t\t\tU[i].B=0;\n\t\t\tU[i].C=0;\n\t\t\tmemset(U[i].D, 0, 42*sizeof(int));\n\t\t\twhile(!U[i].S.empty()) U[i].S.pop();\n\t\t}\n\t\tMax = 0;\n\t\tmemset(&q, 0, sizeof(q));\n\t\t\n\t\tfor(i=1;i<=N;i++){\n\t\t\tcin>>U[i].A>>U[i].B>>c;\n\t\t\twhile(c--){\n\t\t\t\tcin>>s;\n\t\t\t\tU[i].S.push(s);\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=N;i++){\n\t\t\twhile(!U[i].S.empty()){\n\t\t\t\tU[i].D[U[i].C++] = Find(U[i].S.front());\n\t\t\t\tU[i].S.pop();\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tAddUnion(&q, 1);\n\t\tUS.push(q);\n\t\twhile(!US.empty()){\n\t\t\tq = US.front();\n\t\t\tUS.pop();\n\t\t\tint t;\n\t\t\tfor(t=1;t<=N;t++){\n\t\t\t\tif(!q.State[t])break;\n\t\t\t\n\t\t\t}\n\t\t\tif(t>N){\n\t\t\t\tMax = max(Max, q.B);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(i=0;i<U[t].C;i++){\n\t\t\t\tp = q;\n\t\t\t\tif(p.State[U[t].D[i]]) continue;\n\t\t\t\tAddUnion(&p, U[t].D[i]);\n\t\t\t\tUS.push(p);\n\t\t\t}\n\t\t\tAddUnion(&q, t);\n\t\t\tUS.push(q);\n\t\t}\n\t\tcout << Max << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//#include\"bits/stdc++.h\"\n\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = (1 << 20) + 1;\nint cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nbool E[41][41];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tmemset(E, 0, sizeof(E));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << B[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[mask | (1 << i)] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tx -= dp[mask];\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef long long ll;\n\nint pw[50],N;\n\nclass UnionFind {\npublic:\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nclass Edge\n{\npublic:\n\tint src, dst;\n\tEdge(int src, int dst)\n\t:src(src),dst(dst)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nll paint[40], rest[40];\nll relt;\n\nll dfs(int p, ll used, ll score, Graph& g, vector<int>& group)\n{\t\n\tif(p==group.size()) return score;\n\tif(used >> group[p] & 1) return dfs(p+1, used, score, g, group);\n\tif(score + rest[group[p]] <= relt) return 0;\n\n\tll res = score;\n\tll tmp = used | paint[group[p]];\n\tres = max(res, dfs(p+1, tmp, score+pw[group[p]], g, group));\n\tres = max(res, dfs(p+1, used, score, g, group));\n\t\n\trelt = max(res, relt);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> N, N) {\n\t\tmemset(rest, 0, sizeof(rest));\n\n\t\tcerr << N << endl;\n\t\tint gcnt = 0;\n\t\tmap<string, int> dic;\n\t\tGraph graph(N);\n\t\tUnionFind uf(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tstring src;\n\t\t\tcin >> src;\n\n\t\t\tif(!dic.count(src)) dic[src] = gcnt++;\n\t\t\tint s = dic[src];\n\n\t\t\tcin >> pw[s];\n\t\n\t\t\tint M;\n\t\t\tcin >> M;\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++) {\n\t\t\t\tstring dst;\n\t\t\t\tcin >> dst;\n\t\t\t\t\n\t\t\t\tif(!dic.count(dst)) dic[dst] = gcnt++;\n\t\t\t\tint t = dic[dst];\n\n\t\t\t\tgraph[s].push_back(Edge(s,t));\n\t\t\t\tuf.unionSet(s,t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tpaint[i] = (1LL << i);\n\t\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\t\tpaint[i] |= (1LL << graph[i][j].dst);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > groups(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tgroups[uf.root(i)].push_back(i);\n\t\t\trest[uf.root(i)] += pw[i];\n\t\t}\n\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tfor(int j=1; j<groups[i].size(); j++) {\n\t\t\t\trest[groups[i][j]] = rest[groups[i][j-1]] - pw[groups[i][j-1]];\n\t\t\t}\n\t\t} \n\n\t\tll res = pw[0];\n\t\tll init = paint[0];\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tif(groups[i].size() == 0) continue;\n\t\t\trelt = 0;\n\t\t\tres += dfs(0, init, 0, graph, groups[i]);\n\t\t} \n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, G[N][N], A[N], ans;\nvector<P> idx;\n\nvoid dfs(int x,int sum,vector<int> S){\n  \n  ans=max(ans,sum);\n  \n  if(x==n||ans>=sum+A[x]) return;\n  \n  dfs(x+1,sum,S);\n  \n  for(int i=0;i<S.size();i++)\n    if(G[S[i]][idx[x].second]) return;\n\n  S.push_back(idx[x].second);\n  \n  dfs(x+1,sum+idx[x].first,S);\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cost, cnt=0;\n    \n    memset(G,0,sizeof(G));\n    idx.clear();\n    \n    for(int i=0;i<n;i++){\n      \n      string s;\n      cin>>s;\n      \n      if(!num.count(s)) num[s]=cnt++;\n\n      int a, b;\n      cin>>a>>b;\n\n      if(i) idx.push_back(P(a,num[s]));\n      else cost=a;\n      \n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n      }\n      \n    }\n    \n    sort(idx.begin(),idx.end(),greater<P>());\n\n    memset(A,0,sizeof(A));\n    \n    A[n-1]=idx[n-1].first;\n    \n    for(int i=n-2;i>=0;i--)\n      A[i]=A[i+1]+idx[i].first;\n    \n    ans=0;\n    \n    vector<int> s;\n    \n    s.push_back(0);\n    \n    dfs(0,cost,s);\n    \n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tint N;\n\tvector<int> ps;\n\tvector<vector<int>> es;\n\tvector<bool> canselect;\n\tvector<int> fillc;\n\n\tint Mv;\t\n\tint must;\n\n\tvector<bool> change;\n\tvoid dfs(int v,int val){\n\t\t//DUMP(v);\n\t\tMv=max(Mv,val);\n\t\tif(v>=N)return;\n\t\tif(val+fillc[v]<=Mv)return;\n\t\tif(canselect[v]){\n\t\t\tvector<int> change;\n\t\t\tselect(v,change);\n\t\t\tdfs(v+1,val+ps[v]);\n\t\t\tunselect(v,change);\n\t\t\t//周りが全て固定されていれば未選択の必要はない\n\t\t\t//if(!allfixed(v))\n\t\t\tdfs(v+1,val);\n\t\t}else{\n\t\t\tdfs(v+1,val);\n\t\t}\n\t}\n\n\tbool allfixed(int v){\n\t\tREP(i,es[v].size())if(es[v][i]>v)return false;\n\t\treturn true;\n\t}\n\n\tvoid select(int v,vector<int>& change){\n\t\tcanselect[v]=false;\n\t\tREP(i,es[v].size()){\n\t\t\tif(canselect[es[v][i]]){\n\t\t\t\tcanselect[es[v][i]]=false;\n\t\t\t\tchange.push_back(es[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid unselect(int v,vector<int>& change){\n\t\tcanselect[v]=true;\n\t\tREP(i,change.size())canselect[change[i]]=true;\n\t}\n\n\tvoid run(){\n\t\t//ifstream fin(\"in\" );\n\t\t//ofstream fout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >>N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> cs(N);\n\t\t\tmap<string,int> stoid;\n\t\t\tps=vector<int>(N);\n\t\t\tvector<vector<string>> ess(N);\n\t\t\tREP(i,N){\n\t\t\t\tcin >> cs[i] >> ps[i];stoid.insert(make_pair(cs[i],i));\n\t\t\t\t\n\t\t\t\tint k;cin >>k;\n\t\t\t\tREP(j,k) {\n\t\t\t\t\tstring s;cin >> s;ess[i].push_back(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tes=vector<vector<int>>(N);\n\t\t\tREP(i,N)REP(j,ess[i].size())es[i].push_back(stoid[ess[i][j]]);\n\t\t\n\t\t\tcanselect=vector<bool>(N,true);\n\t\t\tfillc=vector<int>(N+1);\n\t\t\tfor(int i=N-1;i>=0;i--)fillc[i]+=fillc[i+1]+ps[i];\n\n\t\t\t//自分\n\t\t\tvector<int> dummy;\n\t\t\tmust=ps[0];select(0,dummy);\n\t\t\t//孤立点\n\t\t\tREP(i,N)if(canselect[i] && es[i].size()==0){must+=ps[i];select(i,dummy);}\n\t\t\t\n\t\t\tMv=must;\n\t\t\tdfs(0,must);\n\n\t\t\tcout<< Mv<<endl;\n\t\t}\n\t}\n};\n int main(){\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if(ne & (1LL<<i) != 0) continue;\n        if((ne | cs[i].ne) <= ne){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n\n    priority_queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.top().second.second;\n        power = pq.top().second.first;\n        int v = pq.top().first + 1;\n        pq.pop();\n        res = max(res, power);\n        if(v > n - 1) continue;\n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        \n        \n        ll nne = ne;\n        int npower = power;\n        for(int i = v + 1; i < n; i++){\n            if((nne & (1LL<<i)) != 0) continue;\n            if((nne | cs[i].ne) <= ne){\n                nne |= cs[i].ne;\n                npower += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(npower, nne)));\n        \n        \n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if((ne | cs[i].ne) <= ne){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tvector<vector<bool>> E(N, vector<bool>(N));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << A[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1LL << n;\n\t\t\tint NY = 1LL << (N - n);\n\t\t\tvector<int> X(NX), Y(NY);\n\n\t\t\tvector<bool> indx(NX, true);\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\t\tif (!((mask >> i) & 1))continue;\n\t\t\t\t\tif (!((mask >> j) & 1))continue;\n\t\t\t\t\tif (E[i][j])\n\t\t\t\t\t\tindx[mask] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<bool> indy(NY, true);\n\t\t\trep(mask, 0, NY) {\n\t\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\t\tif (!((mask >> i) & 1))continue;\n\t\t\t\t\tif (!((mask >> j) & 1))continue;\n\t\t\t\t\tif (E[i + n][j + n])\n\t\t\t\t\t\tindy[mask] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<int> cost(NY);\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<int> dp(NX);\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nmask = mask | (1 << i);\n\t\t\t\t\tdp[nmask] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tint tmp = dp[mask];\n\n\t\t\t\tx -= tmp;\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define LINE cout << \"LINE : \" << __LINE__ << endl\n#define dump(v) cout << #v << \" : \" << v << \" \"\n#define dumpl(v) dump(v) << endl\n\n//using ll = int_fast64_t;\n\nusing ll = int;\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<ll> d[41];\n\nll dp0[1<<21];\nll dp1[1<<21];\nll maskNg0[1<<21];\nll maskNg1[1<<21];\nll maskNg2[1<<21];\n\nvoid calc(ll* dp, ll l, ll r, ll* maskNg) {\n  rep(mask, 1 << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1<<i)) continue;\n      ll nxt = mask | (1 << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    unordered_map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    rep(i, n) {\n      d[i].resize(D[i].size());\n      rep(j, D[i].size()) d[i][j] = mp[D[i][j]];\n    }\n\n    ll l = 0, m = n/2, r = n;\n  \n    rep(i, 1<<(m - l)) maskNg0[i] = maskNg2[i] = 0;\n    rep(i, 1<<(r - m)) maskNg1[i] = 0;\n    \n    rep(i, m - l) {\n      auto& mask = maskNg0[i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j];\n\tif(k >= m) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg1[i];\n      rep(j, d[i + m].size()) {\n\tll k = d[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg2[i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n\n    rep(i, 1 << (m - l)) dp0[i] = 0;\n    rep(i, 1 << (r - m)) dp1[i] = 0;\n    calc(dp0, l, m, maskNg0);\n    calc(dp1, m, r, maskNg1);\n\n    rep(mask, (1 << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1<<i)]);\n      }\n    }\n    \n    ll ans = 0;\n    rep(x, 1<<(m - l)) {\n      if(x&1) {\n\tll y = (1<<(r - m)) - 1;\n\trep(i, m - l) {\n\t  if(x & (1 << i)) {\n\t    y -= (y & maskNg2[i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,ans,sum;\nstring a[50];\nint b[50],c[50];\nvector<string> d[50];\nvector<int> e[50];\nmap<string,int> m;\nmap<int,int> memo[40];\nvoid dfs(int x,int p,int q,int t){\n  if(sum-q<=ans) return;\n  ans=max(ans,p);\n  if(x==n) return;\n  //cout<<x<<\" \"<<p<<\" \"<<q<<\":\"<<sum<<\" \"<<ans<<endl;\n  if(memo[x].count(t>>x)&&p<=memo[x][t>>x]) return;\n  memo[x][t>>x]=p;\n  if(!((t>>x)&1)){\n    int np=p,nq=1,nt=t;\n    np+=b[x];\n    for(int i=0;i<c[x];i++){\n      if((nt>>e[x][i])&1) continue;\n      nt+=1LL<<e[x][i];\n      nq+=b[e[x][i]];\n    }\n    dfs(x+1,np,nq,nt);\n  }\n  dfs(x+1,p,q,t);\n}\nsigned main(){\n  while(cin>>n,n){\n    m.clear();\n    for(int i=0;i<40;i++) memo[i].clear();\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      m[a[i]]=i;\n      d[i].clear();\n      d[i].resize(c[i]);\n      for(int j=0;j<c[i];j++) cin>>d[i][j];\n    }\n    for(int i=0;i<n;i++){\n      e[i].clear();\n      e[i].resize(c[i]);\n      for(int j=0;j<c[i];j++) e[i][j]=m[d[i][j]];\n    }\n    ans=sum=0;\n    for(int i=0;i<n;i++) sum+=b[i];\n    int t=0;\n    int p=b[0],q=0;\n    for(int i=0;i<c[0];i++){\n      if((t>>e[0][i])&1) continue;\n      t+=1LL<<e[0][i];\n      q+=b[e[0][i]];\n    }\n    dfs(1,p,q,t);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// compile in C++11. use -std=c++11.\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define repeat(i,n) for(int i=0;i<static_cast<int>(n);i++)\n#define debug(x) #x << \"=\" << (x)\n#define dump(x) cerr << debug(x) << \" (L:\" << __LINE__ << \")\"<< endl\n\ntypedef long long ll;\ntypedef complex<double> point;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    os << \"[\";\n    for(const auto& v : vec){\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long ll;\n\nll solve(ll k,ll cur,ll mask,const vector<ll>& power,\n         const vector<ll>& masks,const vector<ll>& sum,ll& current_max){\n    int n = power.size();\n    if(k == n) return cur;\n    if(cur + sum[n] - sum[k-1] <= current_max) return cur;\n    if(mask & (1 << k)){\n        // already masked\n        return solve(k+1,cur,mask,power,masks,sum,current_max);\n    }else{\n        current_max = cur+power[k];\n        return max(solve(k+1,cur+power[k],mask | masks[k],power,masks,sum,current_max),\n                   solve(k+1,cur,mask,power,masks,sum,current_max));\n    }\n}\n\nint main(){\n    while(true){\n        int n;cin >> n;\n        if(n == 0) break;\n        unordered_map<string,int> index_of;\n        int k = 0;\n        vector<ll> mask(n);\n        vector<ll> power(n);\n        for(int i=0;i<n;i++){\n            string A;int B,C;\n            cin >> A >> B >> C;\n            if(index_of.find(A) == index_of.end()){\n                index_of[A] = k;k++;\n            }\n            power[index_of[A]] = B;\n            for(int j=0;j<C;j++){\n                string d;cin >> d;\n                if(index_of.find(d) == index_of.end()){\n                    index_of[d] = k;k++;\n                }\n                mask[index_of[A]] = mask[index_of[A]] | (1 << index_of[d]);\n            }\n        }\n        // sum of [0..i)\n        vector<ll> sum(n+1);\n        for(int i=1;i<=n;i++){\n            sum[i] = sum[i-1] + power[i-1];\n        }\n        ll p = power[0];\n        cout << solve(1,power[0],mask[0],power,mask,sum,p) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nmap<string, int> kuni;\nint power[40];\nvector<vector<string>> vvs;\nint mat[40][40] = {};\nint ans = 0;\nvector<int> used(40);\nint n;\n\nbool check()\n{\n\tbool f = true;\n\tfor (int i = 0; i<n; i++)\n\t{\n\t\tif (used[i] == 0) f = false;\n\t}\n\treturn f;\n}\n\nbool over()\n{\n\tint sum = 0;\n\tREP(i, n)\n\t{\n\t\tif (used[i] != 2) sum += power[i];\n\t}\n\treturn ans < sum;\n}\n\nvoid solve()\n{\n\tif (check())\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<n; i++)\n\t\t{\n\t\t\tif (used[i] == 1) sum += power[i];\n\t\t}\n\t\tans = max(ans, sum);\n\t\treturn;\n\t}\n\tfor (int i = 0; i<n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\tauto copy = used;\n\t\t\tused[i] = 1;\n\t\t\tfor (int j = 0; j<n; j++)\n\t\t\t{\n\t\t\t\tif (mat[i][j] == 1) used[j] = 2;\n\t\t\t}\n\t\t\tsolve();\n\t\t\tused = copy;\n\t\t\tused[i] = 2;\n\t\t\tif(!over()) solve();\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> n && n)\n\t{\n\t\tkuni.clear();\n\t\tvvs.clear();\n\t\tfor (int i = 0; i<40; i++)for (int j = 0; j<40; j++) mat[i][j] = 0;\n\t\tfor (int i = 0; i<40; i++) used[i] = 0;\n\t\tans = 0;\n\n\t\tvvs.resize(n);\n\t\tfor (int i = 0; i<n; i++)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tkuni[s] = i;\n\t\t\tint c;\n\t\t\tcin >> power[i] >> c;\n\t\t\tvvs[i].resize(c);\n\t\t\tfor (int j = 0; j<c; j++)\n\t\t\t{\n\t\t\t\tcin >> vvs[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i<vvs.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j<vvs[i].size(); j++)\n\t\t\t{\n\t\t\t\tmat[i][kuni[vvs[i][j]]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (mat[0][i] == 1)\n\t\t\t{\n\t\t\t\tused[i] = 2;\n\t\t\t}\n\t\t}\n\t\tused[0] = 1;\n\t\tsolve();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\n\nmap<string, int> kuni;\nint power[40];\nvector<vector<string>> vvs;\nint mat[40][40] = {};\nint ans = 0;\nvector<int> used(40);\nint n;\n\nbool check()\n{\n\tbool f = true;\n\tfor (int i = 0; i<n; i++)\n\t{\n\t\tif (used[i] == 0) f = false;\n\t}\n\treturn f;\n}\n\nbool over()\n{\n\tint sum = 0;\n\tREP(i, n)\n\t{\n\t\tif (used[i] != 2) sum += power[i];\n\t}\n\treturn ans < sum;\n}\n\nvoid solve()\n{\n\tif (check())\n\t{\n\t\tint sum = 0;\n\t\tfor (int i = 0; i<n; i++)\n\t\t{\n\t\t\tif (used[i] == 1) sum += power[i];\n\t\t}\n\t\tans = max(ans, sum);\n\t\treturn;\n\t}\n\tfor (int i = 0; i<n; i++)\n\t{\n\t\tif (used[i] == 0)\n\t\t{\n\t\t\tauto copy = used;\n\t\t\tused[i] = 1;\n\t\t\tfor (int j = 0; j<n; j++)\n\t\t\t{\n\t\t\t\tif (mat[i][j] == 1) used[j] = 2;\n\t\t\t}\n\t\t\tsolve();\n\t\t\tused = copy;\n\t\t\tused[i] = 2;\n\t\t\tif(over()) solve();\n\t\t}\n\t}\n}\n\nint main()\n{\n\twhile (cin >> n && n)\n\t{\n\t\tkuni.clear();\n\t\tvvs.clear();\n\t\tfor (int i = 0; i<40; i++)for (int j = 0; j<40; j++) mat[i][j] = 0;\n\t\tfor (int i = 0; i<40; i++) used[i] = 0;\n\t\tans = 0;\n\n\t\tvvs.resize(n);\n\t\tfor (int i = 0; i<n; i++)\n\t\t{\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tkuni[s] = i;\n\t\t\tint c;\n\t\t\tcin >> power[i] >> c;\n\t\t\tvvs[i].resize(c);\n\t\t\tfor (int j = 0; j<c; j++)\n\t\t\t{\n\t\t\t\tcin >> vvs[i][j];\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i<vvs.size(); i++)\n\t\t{\n\t\t\tfor (int j = 0; j<vvs[i].size(); j++)\n\t\t\t{\n\t\t\t\tmat[i][kuni[vvs[i][j]]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < n; i++)\n\t\t{\n\t\t\tif (mat[0][i] == 1)\n\t\t\t{\n\t\t\t\tused[i] = 2;\n\t\t\t}\n\t\t}\n\t\tused[0] = 1;\n\t\tsolve();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nint N;\nmap<string,int> id;\nint B[MAXN];\nbool vis[MAXN];\nGraph g;\nint Maxi;\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\nvoid addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nvoid dfs(int v, vector<int> &vs) {\n  vs.push_back(v);\n  vis[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    int nv = g[v][i];\n    if(vis[nv]) continue;\n    dfs(nv, vs);\n  }\n}\n\nvoid bt(int k, int now, const vector<int> &vs, const vector<int> &sum, vector<int> &used) {\n  if(k == vs.size()) {\n    Maxi = max(Maxi, now);\n    return;\n  }\n  if(now + sum[k] <= Maxi) return;\n  if(vs[k] != 0) {\n    used[vs[k]] = false;\n    bt(k+1, now, vs, sum, used);\n  }\n  try {\n    for(int i = 0; i < g[vs[k]].size(); ++i) {\n      int nv = g[vs[k]][i];\n      if(used[nv]) throw 0;\n    }\n    used[vs[k]] = true;\n    bt(k+1, now+B[vs[k]], vs, sum, used);\n  } catch(...){}\n  used[vs[k]] = false;\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n    int res = 0;\n    fill(vis, vis+MAXN, false);\n    for(int i = 0; i < N; ++i) {\n      if(!vis[i]) {\n        vector<int> vs;\n        dfs(i, vs);\n        vector<int> used(N);\n        vector<int> sum(vs.size()+1);\n        for(int j = (int)vs.size()-1; j >= 0; --j) {\n          sum[j] = sum[j+1] + B[vs[j]];\n        }\n        Maxi = 0;\n        bt(0, 0, vs, sum, used);\n        res += Maxi;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> name;\nvector<string> x[40];\nvector<int> v[40];\nvector<int> pow(40), res(41);\nint n;\nll ans;\n\nvoid dfs(int pos, ll bit, ll score){\n    ans = max(ans, score);\n    if(pos == n)    return;\n    if(score + res[pos] <= ans)    return;\n    ll tmp = 1ll<<pos;\n    for(int x : v[pos])  tmp += 1ll<<x;\n    if(((bit>>pos)&1) == 0)    dfs(pos+1, bit|tmp, score+pow[pos]);\n    dfs(pos+1, bit, score);\n}\n\nint main(){\n    while(cin >> n, n){\n        name.clear();\n        for(int i = 0; i < n; i++)  v[i].clear(), x[i].clear();\n        for(int i = 0; i < n; i++){\n            string s;\n            int c;\n            cin >> s >> pow[i] >> c;\n            name[s] = i;\n            while(c-- > 0){\n                string t;   cin >> t;\n                x[i].push_back(t);\n            }\n        }\n        for(int i = 0; i < n; i++){\n            for(string s : x[i])    v[i].push_back(name[s]);\n        }\n        ans = 0;\n        res[n] = 0;\n        for(int i = n-1; i >= 0; i--)   res[i] = res[i+1]+pow[i];\n        ll start = 1;\n        for(int x : v[0])    start += 1ll<<x;\n        dfs(1, start, pow[0]);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nchar str[50];\nstring name[50];\nint b[50];\nint c[50];\nstring d[50][50];\nint g[50][50];\nint n;\nint deg[50];\nint best=0;\nint dfs(vector<int>use){\n\tbool ok=true;\n\tint ret=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(use[i]==1)ret+=b[i];\n\t\tif(use[i]==-1)ok=false;\n\t}\n\tif(ok){\n\t\tbest=max(best,ret);\n\t\treturn ret;\n\t}\n\tint tmp=0;\n\tfor(int i=0;i<use.size();i++)if(use[i]!=0)tmp+=b[i];\n\tif(tmp<=best)return tmp;\n\tint m=-1;\n\tint at=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]){\n\t\t\tint cnt=0;\n\t\t\tfor(int j=0;j<n;j++)if(g[i][j]&&!~use[j])cnt++;\n\t\t\tif(m<cnt){\n\t\t\t\tm=deg[i];at=i;\n\t\t\t}\n\t\t}\n\t}\n\t// use\n\tret=0;\n\tvector<int> to=use;\n\tto[at]=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]&&g[at][i]){\n\t\t\tto[i]=0;\n\t\t}\n\t}\n\tret=max(ret,dfs(to));\n\t// non use\n\tto=use;\n\tto[at]=0;\n\tret=max(ret,dfs(to));\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tmap<string,int>m;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint p,q;scanf(\"%s%d%d\",str,&p,&q);\n\t\t\tname[i]=str;\n\t\t\tb[i]=p;\n\t\t\tc[i]=q;\n\t\t\tm[name[i]]=i;\n\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\tscanf(\"%s\",str);\n\t\t\t\td[i][j]=str;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<c[i];j++)\n\t\t\tg[i][m[d[i][j]]]=1;\n\t\tfor(int i=0;i<a;i++)deg[i]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)deg[i]+=g[i][j];\n\t\tvector<int> s(a,-1);\n\t\ts[0]=1;\n\t\tfor(int i=0;i<a;i++)if(g[0][i])s[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]==0)s[i]=1;\n\t\t}\n\t\tbest=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]==1){\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(g[i][j]&&deg[j]==1){\n\t\t\t\t\t\tif(i&&j){\n\t\t\t\t\t\t\tif(b[i]>=b[j]){\n\t\t\t\t\t\t\t\ts[i]=1;s[j]=0;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",dfs(s));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <ext/hash_map>\n\nusing namespace std;\nusing namespace __gnu_cxx;\n\ntypedef long long LL;\n\nstruct Dict {\n    map<string,int> dict;\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        int id = dict.size();\n        return dict[str] = id;\n    }\n};\n\nstruct DisjointSet/*{{{*/\n{\n  vector<int> parent;\n\n  int root(int x)\n  {\n    if (parent[x] < 0) {\n      return x;\n    } else {\n      parent[x] = root(parent[x]);\n      return parent[x];\n    }\n  }\n\n  explicit DisjointSet(int n) : parent(n, -1) {}\n\n  bool unite(int x, int y)\n  {\n    const int a = root(x);\n    const int b = root(y);\n    if (a != b) {\n      if (parent[a] < parent[b]) {\n        parent[a] += parent[b];\n        parent[b] = a;\n      } else {\n        parent[b] += parent[a];\n        parent[a] = b;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  bool find(int x, int y) { return root(x) == root(y); }\n  int size(int x) { return -parent[root(x)]; }\n};/*}}}*/\n\nstruct Hash {\n    size_t operator() (const pair<LL,int> &obj) const {\n        return size_t(obj.first + obj.second);\n    }\n};\n\nhash_map<pair<LL,int>,int,Hash> memo;\nint dfs(int pos, LL used, const vector<LL> &neighbors, const vector<int> &scores) {\n    const int N = neighbors.size();\n    if(pos == N) return 0;\n    int score = 0;\n    const pair<LL,int> key(used, pos);\n    //if(memo.count(key)) return memo[key];\n\n    LL rem = 0;\n    for(int i = pos+1; i < N; ++i) {\n        rem |= neighbors[i];\n    }\n\n    if(!(used & (1LL<<pos))) {\n        score = max(score, dfs(pos+1, used | neighbors[pos] | (1LL<<pos), neighbors, scores) + scores[pos]);\n    }\n    if((used & (1LL<<pos)) || (rem & (1LL<<pos))) {\n        score = max(score, dfs(pos+1, used, neighbors, scores));\n    }\n\n    //return memo[key] = score;\n    return score;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<LL> neighbors(N, 0);\n        vector<int> scores(N, 0);\n        DisjointSet group(N);\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string name;\n            int score, ncnt;\n            cin >> name >> score >> ncnt;\n            const int cid = dict.get(name);\n            scores[cid] = score;\n            while(ncnt--) {\n                string nname;\n                cin >> nname;\n                const int nid = dict.get(nname);\n                group.unite(cid, nid);\n                neighbors[cid] |= 1LL<<nid;\n            }\n        }\n\n        memo.clear();\n        cout << dfs(1, neighbors[0] | 1, neighbors, scores) + scores[0] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint country2idx(map<string,int>& dict,string country){\n  int idx = dict.size();\n  if(dict.find(country) == dict.end()){\n    dict[country] = idx;\n    return idx;\n  }\n  return dict[country];\n}\n\nvector<int> edges[41];\nbool used[41];\nint power[41];\nint limit_gain[101];\n\nbool can_unite(int node){\n  if(used[node]) return false;\n  for(int i=0;i<edges[node].size();i++){\n    if(used[edges[node][i]]) return false;\n  }\n  return true;\n}\n\nint gRes;\nvoid dfs(int current,int sum,const vector<int>& subset){\n  if(sum + limit_gain[current] <= gRes) return;\n\n  if(current == subset.size()){\n    gRes = max(gRes,sum);\n    return;\n  }\n\n  int next = subset[current];\n  if(can_unite(next)){\n    used[next] = true;\n    dfs(current+1,sum + power[next],subset);\n    used[next] = false;\n  }\n  dfs(current+1,sum,subset);\n}\n\nclass UnionFindTree {\nprivate:\n  int parent[41];\n  int rank[41];\npublic:\n  UnionFindTree(){\n    for(int i = 0; i <= 40; i++){\n      parent[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  void unite(int lhs,int rhs) {\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(lhs == rhs) return;\n    \n    if(rank[lhs] < rank[rhs]){\n      parent[rhs] = lhs;\n      rank[rhs]++;\n    }\n    else{\n      parent[lhs] = rhs;\n      rank[lhs]++;\n    }\n  }\n\n  int find(int current){\n    if(current == parent[current]) return current;\n    else find(parent[current]);\n  }\n};\n\nint N;\nvoid make_subset(UnionFindTree* uft,int root,vector<int>& subset){\n  for(int i = 0; i < N; i++){\n    if(uft->find(i) == root){\n      subset.push_back(i);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    for(int i = 0; i <= 40; i++){\n      edges[i].clear();\n    }\n    UnionFindTree uft;\n    map<string,int> dict;\n    for(int country_i = 0; country_i < N; country_i++){\n      string country;\n      int tmp_power;\n      cin >> country >> tmp_power;\n      int adjacent_countries;\n      cin >> adjacent_countries;\n\n      int root = country2idx(dict,country);\n      power[root] = tmp_power;\n      for(int adj_i = 0; adj_i < adjacent_countries; adj_i++){\n        string adj_country;\n        cin >> adj_country;\n        int child = country2idx(dict,adj_country);\n        edges[root].push_back(child);\n        uft.unite(root,child);\n      }\n    }\n\n    bool tree[41];\n    memset(tree,false,sizeof(tree));\n\n    int res = 0;\n    for(int i = 0; i < N; i++){\n      if(tree[uft.find(i)]) continue;\n      tree[uft.find(i)] = true;\n      vector<int> subset;\n      make_subset(&uft,uft.find(i),subset);\n\n      gRes = 0;\n      int sum = 0;\n      memset(limit_gain,0,sizeof(limit_gain));\n      for(int j = 0; j < subset.size(); j++){\n        sum += power[subset[j]];\n      }\n      for(int j = 0; j < subset.size(); j++){\n        limit_gain[j] = sum;\n        sum -= power[subset[j]];\n      }\n      memset(used,false,sizeof(used));\n      int tmp = 0;\n      if(i == 0){\n        used[0] = true;\n        dfs(0,power[0],subset);\n        tmp = gRes;\n      }\n      else{\n        dfs(0,0,subset);\n        tmp = gRes;\n      }\n      res += tmp;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 45\ntypedef long long ll;\ntypedef pair<int, ll> P;\n\nint get_node(string s, map<string, int> s2i)\n{\n    if (s2i.count(s) > 0) {\n        return s2i[s];\n    }\n    s2i[s] = s2i.size();\n    return s2i[s];\n}\n\nint N, B[MAX];\nbool ng_node[MAX], is_adj[MAX][MAX];\nmap<ll, int> memo;\n\nint dfs(int v, ll S)\n{\n    if (memo.count(S) > 0) {\n        return memo[S];\n    }\n    int res = 0;\n    for (ll i = 0; i < (ll)N; i++) {\n        if ((S >> i & 1LL) || is_adj[v][i]) {\n            continue;\n        }\n        bool ok = 1;\n        for (ll j = 0; j < (ll)N; j++) {\n            if ((S >> j & 1LL) && !ng_node[j]) {\n                if (is_adj[v][j] || is_adj[i][j]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        if (ok) {\n            res = max(res, dfs(i, S|(1LL<<i)) + B[i]);   \n        }\n    }\n    memo[S] = res;\n    return res;\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        string A, D;\n        int C, sum = 0;\n        ll S = 0;      \n        vector<string> DG[MAX];\n        \n        map<string, int> s2i;\n        \n        memo.clear();\n        memset(is_adj, 0, sizeof(is_adj));\n        memset(ng_node, 0, sizeof(ng_node));\n        \n        for (int i = 0; i < N; i++) {\n            cin >> A >> B[i] >> C;\n            s2i[A] = i;\n            for (int j = 0; j < C; j++) {\n                cin >> D;\n                DG[i].push_back(D);\n            }\n        }\n\n        for (ll i = 0; i < (ll)N; i++) {\n            int len = DG[i].size();\n            if (len == 0) {\n                for (int j = 0; j < N; j++) {\n                    is_adj[i][j] = is_adj[j][i] = 1;\n                }\n                ng_node[i] = 1;\n                sum += B[i];\n                S |= 1LL<<i;\n            }\n            for (int j = 0; j < len; j++) {\n                ll t = s2i[DG[i][j]];\n                is_adj[i][t] = is_adj[t][i] = 1;\n            }\n        }\n        \n        cout << dfs(0, S|(1LL<<0)) + B[0] + sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct renamer\n{\n  map<string,int> m;\n  int operator()(const string& s)\n  {\n    if (m.count(s)) {\n      return m[s];\n    } else {\n      const int id = m.size();\n      m.insert(make_pair(s, id));\n      return id;\n    }\n  }\n};\n\ntypedef unsigned long long ull;\n\null invalidate(const vector<vector<int> >& g, ull invalid, int u)\n{\n  const int N = g.size();\n  for (int i = 0; i < N; i++) {\n    if (g[u][i]) {\n      invalid |= 1ULL<<i;\n    }\n  }\n  invalid |= 1ULL<<u;\n  return invalid;\n}\n\nint solve(const vector<vector<int> >& g, const vector<int>& scores, int u, ull used, ull invalid, int acc)\n{\n  const int N = g.size();\n  if (u == N) {\n    return acc;\n  }\n  for (int i = u; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      if (g[j][i]) {\n        if (j >= u) {\n          goto NEXT;\n        }\n        if (used << (1ULL<<j)) {\n          goto NEXT;\n        }\n      }\n    }\n    used |= 1ULL<<i;\n    invalid = invalidate(g, invalid, i);\n    acc += scores[i];\nNEXT:\n    ;\n  }\n  if (invalid & (1ULL<<u)) {\n    return solve(g, scores, u+1, used, invalid, acc);\n  }\n  // if u is excluded\n  int m = solve(g, scores, u+1, used, invalid, acc);\n\n  // if u is included\n  for (int i = 0; i < N; i++) {\n    if (g[i][u]) {\n      if (used & (1ULL<<i)) {\n        goto FAIL;\n      }\n    }\n  }\n  used |= 1ULL<<u;\n  invalid = invalidate(g, invalid, u);\n  m = max(m, solve(g, scores, u+1, used, invalid, acc + scores[u]));\nFAIL:\n  return m;\n}\n\nint main()\n{\n  int N;\n  while (cin >> N && N != 0) {\n    vector<vector<int> > g(N, vector<int>(N, false));\n    vector<int> scores(N);\n    renamer rename;\n    for (int i = 0; i < N; i++) {\n      string s;\n      int b, c;\n      cin >> s >> b >> c;\n      const int u = rename(s);\n      scores[u] = b;\n      for (int j = 0; j < c; j++) {\n        cin >> s;\n        const int v = rename(s);\n        g[u][v] = true;\n      }\n    }\n\n    ull invalid = invalidate(g, 0, 0);\n    cout << solve(g, scores, 1, 1ULL<<0, invalid, scores[0]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nusing ll = int;\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<ll> d0[41];\nvector<ll> d1[41];\n\nll dp0[1<<20];\nll dp1[1<<20];\nll maskNg0[1<<20];\nll maskNg1[1<<20];\nll maskNg2[1<<20];\n\nvoid calc(ll* dp, ll l, ll r, ll* maskNg) {\n  rep(mask, 1 << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1<<i)) continue;\n      ll nxt = mask | (1 << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    ll l = 0, m = n/2, r = n;\n\n    unordered_map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    rep(i, n) {\n      d0[i].clear();\n      d1[i].clear();\n      rep(j, D[i].size()) {\n\tint k = mp[D[i][j]];\n\tif(k < m) d0[i].push_back(k);\n\telse d1[i].push_back(k);\n      }\n    }\n  \n    rep(i, 1<<(m - l)) maskNg0[i] = maskNg2[i] = 0;\n    rep(i, 1<<(r - m)) maskNg1[i] = 0;\n    \n    rep(i, m - l) {\n      auto& mask = maskNg0[i];\n      rep(j, d0[i].size()) {\n\tll k = d0[i][j];\n\tif(k >= m) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg1[i];\n      rep(j, d1[i + m].size()) {\n\tll k = d1[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg2[i];\n      rep(j, d1[i].size()) {\n\tll k = d1[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n\n    rep(i, 1 << (m - l)) dp0[i] = 0;\n    rep(i, 1 << (r - m)) dp1[i] = 0;\n    calc(dp0, l, m, maskNg0);\n    calc(dp1, m, r, maskNg1);\n\n    rep(mask, (1 << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1<<i)]);\n      }\n    }\n    \n    ll ans = 0;\n    rep(x, 1<<(m - l)) {\n      if(x&1) {\n\tll y = (1<<(r - m)) - 1;\n\trep(i, m - l) {\n\t  if(x & (1 << i)) {\n\t    y -= (y & maskNg2[i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint ans;\nint bs[114514];\nint cs[114514];\nchar buf[114514];\nbool used[114514];\nstring as[114514];\nvector<int> es[114514];\nvector<string> ds[114514];\nmap<string, int> rev;\n\nvoid calc(int v, int sum) {\n  if (v >= n) {\n    ans = max(ans, sum);\n    return;\n  }\n\n  calc(v+1, sum);\n  if (!used[v]) {\n    vector<int> restores;\n    for (int i=0; i<cs[v]; i++) {\n      int u = es[v][i];\n      if (!used[u]) {\n        used[u] = true;\n        restores.emplace_back(u);\n      }\n    }\n    calc(v+1, sum+bs[v]);\n    for (int u : restores) used[u] = false;\n  }\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n    rev.clear();\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      as[i] = buf;\n      rev[as[i]] = i;\n      scanf(\"%d\", &bs[i]);\n      scanf(\"%d\", &cs[i]);\n      ds[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        scanf(\" %s\", buf);\n        ds[i][j] = buf;\n      }\n    }\n  \n    for (int i=0; i<n; i++) {\n      es[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        es[i][j] = rev[ds[i][j]];\n      }\n      used[i] = false;\n    }\n\n    for (int u : es[0]) used[u] = true;\n  \n    ans = 0;\n    calc(1, bs[0]);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint country2idx(map<string,int>& dict,string country){\n  int idx = dict.size();\n  if(dict.find(country) == dict.end()){\n    dict[country] = idx;\n    return idx;\n  }\n  return dict[country];\n}\n\nvector<int> edges[41];\nbool used[41];\nbool visited[41];\nint power[41];\n\nbool can_unite(int node){\n  for(int i=0;i<edges[node].size();i++){\n    if(used[edges[node][i]]) return false;\n  }\n  return true;\n}\n\nint dfs(int current,int sum){\n  int res = sum;\n  for(int i = 0; i < edges[current].size();i++){\n    int next = edges[current][i];\n    if(visited[next]) continue;\n    if(can_unite(next)){\n      used[next] = true;\n      visited[next] = true;\n      res = max(res,dfs(next,sum + power[next]));\n      used[next] = false;\n    }\n    else{\n      visited[next] = true;\n      res = max(res,dfs(next,sum));\n    }\n  }\n  return res;\n}\n\nclass UnionFindTree {\nprivate:\n  int parent[41];\n  int rank[41];\npublic:\n  UnionFindTree(){\n    for(int i = 0; i <= 40; i++){\n      parent[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  void unite(int lhs,int rhs) {\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(lhs == rhs) return;\n    \n    if(rank[lhs] < rank[rhs]){\n      parent[rhs] = lhs;\n      rank[rhs]++;\n    }\n    else{\n      parent[lhs] = rhs;\n      rank[lhs]++;\n    }\n  }\n\n  int find(int current){\n    if(current == parent[current]) return current;\n    else find(parent[current]);\n  }\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    for(int i = 0; i <= 40; i++){\n      edges[i].clear();\n    }\n    UnionFindTree uft;\n    map<string,int> dict;\n    for(int country_i = 0; country_i < N; country_i++){\n      string country;\n      int tmp_power;\n      cin >> country >> tmp_power;\n      int adjacent_countries;\n      cin >> adjacent_countries;\n\n      int root = country2idx(dict,country);\n      power[root] = tmp_power;\n      for(int adj_i = 0; adj_i < adjacent_countries; adj_i++){\n        string adj_country;\n        cin >> adj_country;\n        int child = country2idx(dict,adj_country);\n        edges[root].push_back(child);\n        uft.unite(root,child);\n      }\n    }\n\n    bool tree[41];\n    memset(tree,false,sizeof(tree));\n\n    int res = 0;\n    for(int i = 0; i < N; i++){\n      if(tree[uft.find(i)]) continue;\n      tree[uft.find(i)] = true;\n      int tmp = 0;\n      for(int j = 0; j < N; j++){\n        if(uft.find(j) != uft.find(i)) continue;\n        memset(used,false,sizeof(used));\n        memset(visited,false,sizeof(visited));\n        if(i == 0){\n          used[0] = true;\n          visited[0] = true;\n          tmp = max(tmp,dfs(0,power[0]));\n          break;\n        }\n        else{\n          used[j] = true;\n          visited[j] = true;\n          tmp = max(tmp,dfs(j,power[j]));\n        }\n      }\n      res += tmp;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\ntemplate<class T>\nclass IdMaker{\npublic:\n  std::map<T,int> _m;\n  int getId(const T &v){\n    if(_m.find(v) == _m.end()){\n      int next = _m.size();\n      return _m[v] = next;\n    }\n    return _m[v];\n  }\n};\n\nll adj[40];\nint str[40];\nint memo[40];\nint ans;\n\nvoid solve(ll flag, int now){\n  ll ff = flag;\n\n  while(ff){\n    const ll f = ff & (-ff);\n    const int pos = __builtin_ctzl(f);\n    if((adj[pos] & flag) == 0){\n      now += str[pos];\n      flag ^= f;\n    }\n    ff ^= f;\n  }\n\n  ans = max(ans, now);\n\n  if(flag == 0)\n    return;\n\n  while(flag){\n    const ll f = flag & (-flag);\n    const int pos = __builtin_ctzl(f);\n    solve((flag ^ (1ll << pos)) & (~adj[pos]), now + str[pos]);\n    flag ^= f;\n  }\n}\n\nint main(){\n  while(const int n = getInt()){\n    IdMaker<string> idm;\n\n    REP(i,n){\n      string s; cin >> s;\n      str[idm.getId(s)] = getInt();\n      const int m = getInt();\n      adj[idm.getId(s)] = 0;\n      REP(j,m){\n        string a; cin >> a;\n        adj[idm.getId(s)] |= (1ll << idm.getId(a));\n      }\n    }\n\n    REP(i,n)\n      for(int j = i; j < n; j++)\n        memo[i] += str[j];\n\n    ll start = (1ll << n) - 1;\n    start ^= 1;\n    start ^= adj[0];\n\n    ans = 0;\n    solve(start, str[0]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nint n;\nvector<ll> adj;\nvi power, sum_rest;\n\nint res;\n\nvoid dfs(int v, int sum, ll used, ll disabled){\n    if(v == n){\n        res = max(res, sum);\n        return;\n    }\n    if(sum + sum_rest[v] < res) return;\n\n    int nv = v + 1;\n\n    dfs(nv, sum, used, disabled);\n\n    if(not(disabled & (1LL << v))){\n        dfs(nv, sum + power[v], used & (1LL << v), disabled | adj[v]);\n    }\n}\n\nint main(void){\n    for(; cin >> n, n;){\n        res = 0;\n\n        power = sum_rest = vi(n);\n        adj = vector<ll>(n);\n\n        vector<vector<string>> d_str(n);\n        map<string, int> s2i;\n\n        int sum = 0;\n        rep(i, n){\n            string name;\n            int p, m; cin >> name >> p >> m;\n            d_str[i] = vector<string>(m);\n            for(auto & ee : d_str[i]) cin >> ee;\n\n            s2i[name] = i;\n            power[i] = p;\n\n            sum += p;\n        }\n\n        sum_rest[0] = sum;\n        rep(i, n - 1){\n            sum_rest[i + 1] = sum_rest[i] - power[i];\n        }\n\n        rep(i, n){\n            ll vec = 0;\n            for(auto & e : d_str[i]){\n                int idx = s2i[e];\n                vec |= (1LL << idx);\n            }\n            adj[i] = vec;\n        }\n\n        dfs(1, power[0], 1LL, adj[0]);\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41], wes[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n  ans = max(ans, wsum);\n  if(wsum + wes[N-1] - (curr ? wes[curr-1] : 0) <= ans) return;\n  if(curr == N-1) return;\n  const int next = curr + 1;\n  dfs(S, wsum, next);\n  rep(k, next) if(adjacent[next][k] && (S >> k & 1)) return;\n  dfs(S|(1LL<<next), wsum + weight[next], next);\n}\n\nint main() {\n\n  while(cin >> N && N) {\n    rep(i, 41) weight[i] = 0;\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(i, N) {\n      string s; cin >> s;\n      if(id.find(s) == id.end()) id[s] = v++;\n      cin >> weight[id[s]];\n      int n; cin >> n;\n      rep(_, n) {\n        string t; cin >> t;\n        if(id.find(t) == id.end()) id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) wes[i] = weight[i] + (i ? wes[i-1] : 0);\n\n    ans = 0;\n    dfs(1LL<<0, weight[0], 0);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin >> N,N){\n\tmap<string,int> country;\n\tvector<vector<string>> adj(N);\n\tVI bs(N);\n\tREP(i,N){\n\t  string s;\n\t  cin >> s;\n\t  country[s] = i;\n\t  cin >> bs[i];\n\t  int C; cin >> C;\n\t  REP(j,C){\n\t\tcin >> s;\n\t\tadj[i].EB(s);\n\t  }\n\t}\n\tif(N == 1){\n\t  cout << bs[0] << endl;\n\t  continue;\n\t}\n\n\tVVI G(N);\n\tREP(i,N){\n\t  for(auto& s: adj[i])\n\t\tG[i].PB(country[s]);\n\t}\n\tVL ban(N);\n\tREP(i,N){\n\t  for(int to: G[i])\n\t\tban[i] = ban[i] | (1ll<<to);\n\t}\n\n\tint N2 = N / 2;\n\tint NR = N - N2;\n\tVI dp(1<<NR);\n\tREP(i,1<<NR){\n\t  int sum = 0;\n\t  LL x = (LL)(i) << N2;\n\t  REP(j,NR)\n\t\tif(i>>j&1){\n\t\t  sum += bs[j+N2];\n\t\t  if((ban[j+N2] & x) != 0){\n\t\t\tsum = -1e9;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t  if(sum >= 0)\n\t\tdp[i] = sum;\n\t}\n\n\tfor(int i=0;i<NR;++i){\n\t  for(int b=0;b<(1<<NR);++b){\n\t\tif((b>>i&1) == 1)\n\t\t  maxi(dp[b], dp[b^(1<<i)]);\n\t  }\n\t}\n\n\tint ans = 0;\n\tfor(int b=1;b<1<<N2;b+=2){\n\t  int sum = 0;\n\t  LL x = b;\n\t  LL b2 = 0;\n\t  REP(j,N2)\n\t\tif(b>>j&1){\n\t\t  b2 = b2 | ban[j];\n\t\t  sum += bs[j];\n\t\t  if((ban[j] & x) != 0){\n\t\t\tsum = -1e9;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t  if(sum < 0) continue;\n\t  b2 = (b2 >> N2) ^ ((1<<NR) - 1);\n\t  ans = max(ans, sum + dp[b2]);\n\t}\n\tcout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint ans = 0;\nint N;\nvector<int>rests;\n\nvoid getans(const int sum,const int now, const vector < pair<int, vector<int>>>&connects, vector<int>&oks) {\n\tif (now == N)ans =max(ans, sum);\n\telse {\n\t\tif (sum + rests[now] < ans)return;\n\t\tif (oks[now]) {\n\t\t\tvector<int>preoks(oks);\n\t\t\tpreoks[now] = false;\n\t\t\tfor (auto e : connects[now].second) {\n\t\t\t\tpreoks[e] = false;\n\t\t\t}\n\t\t\tgetans(sum + connects[now].first, now+1, connects, preoks);\n\t\t\t\n\t\t}\n\t\tif (now) {\n\n\t\t\tgetans(sum, now + 1, connects, oks);\n\t\t}\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tans = 0;\n\t\trests.clear();\n\t\trests.resize(N);\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tvector<tuple<int,int,vector<int>>>connects(N);\n\t\tint num = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name; int b, c; cin >> name >> b >> c;\n\t\t\tif (mp.find(name) == mp.end()) {\n\t\t\t\tmp[name] = num;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tint myid = mp[name];\n\t\t\tget<0>(connects[myid]) = b;\n\t\t\tget<1>(connects[myid]) = myid;\n\t\t\tvector<int>vs;\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tif (mp.find(st) == mp.end()) {\n\t\t\t\t\tmp[st] = num;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tint opid = mp[st];\n\t\t\t\tvs.emplace_back(opid);\n\t\t\t\tget<2>(connects[myid]).emplace_back(opid);\n\t\t\t}\n\t\t}\n\t\tsort(connects.begin()+1, connects.end());\n\t\treverse(connects.begin()+1, connects.end());\n\t\tmap<int,int>convert;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tconvert[get<1>(connects[i])] = i;\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto& j : get<2>(connects[i])) {\n\t\t\t\tj = convert[j];\n\t\t\t}\n\t\t}\n\t\tint a = get<0>(connects[N - 1]);\n\t\trests[N - 1] =a;\n\t\tfor (int i = N - 2; i >= 0; --i) {\n\t\t\trests[i] = rests[i + 1] + get<0>(connects[i]);\n\t\t}\n\t\tvector<pair<int, vector<int>>>newconnects;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tnewconnects.emplace_back(get<0>(connects[i]), get<2>(connects[i]));\n\t\t}\n\n\t\tvector<int>oks(N, true);\n\t\tgetans(0, 0, newconnects, oks);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\nint dp[1 << 21];\n\nint main(){\n    while (true) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n        \n        string country[45];\n        int power[45], nearc[45];\n        int near[45][45];\n        string nears[45][45];\n        for (int i = 0; i < n; ++i) {\n            cin >> country[i] >> power[i] >> nearc[i];\n            for (int j = 0; j < nearc[i]; ++j) {\n                cin >> nears[i][j];\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int k = 0; k < nearc[j]; ++k) {\n                    if (country[i] == nears[j][k]) {\n                        near[j][k] = i;\n                    }\n                }\n            }\n        }\n        int n1 = n / 2;\n        int n2 = n - n1;\n        for (int i = 0; i < (1 << n1); ++i) {\n            dp[i] = 0;\n            for (int j = 0; j < n1; ++j) {\n                if ((i >> j) & 1) {\n                    dp[i] += power[j + n2];\n                    for (int k = 0; k < nearc[j + n2]; ++k) {\n                        if (near[j + n2][k] >= n2 && ((i >> (near[j + n2][k] - n2)) & 1))\n                            goto A;\n                    }\n                }\n            }\n            continue;\n            \n        A:\n            dp[i] = 0;\n            for (int j = 0; j < n1; ++j) {\n                if ((i >> j) & 1) {\n                    dp[i] = max(dp[i], dp[i - (1 << j)]);\n                }\n            }\n        }\n        int ma = 0;\n        for (int i = 1; i < (1 << n2); i += 2) {\n            int sum = 0, bitmsk = 0;\n            for (int j = 0; j < n2; ++j) {\n                if ((i >> j) & 1) {\n                    sum += power[j];\n                    for (int k = 0; k < nearc[j]; ++k) {\n                        if (near[j][k] >= n2){\n                            bitmsk |= 1 << (near[j][k] - n2);\n                        }\n                        else if ((i >> near[j][k]) & 1)\n                            goto B;\n                    }\n                }\n            }\n            ma = max(ma, sum + dp[bitmsk ^ ((1 << n1) - 1)]);\n            \n        B:\n            continue;\n        }\n        cout << ma << \"\\n\";\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// compile in C++11. use -std=c++11.\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define repeat(i,n) for(int i=0;i<static_cast<int>(n);i++)\n#define debug(x) #x << \"=\" << (x)\n#define dump(x) cerr << debug(x) << \" (L:\" << __LINE__ << \")\"<< endl\n\ntypedef long long ll;\ntypedef complex<double> point;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    os << \"[\";\n    for(const auto& v : vec){\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long ll;\n\nvoid solve(ll k,ll cur,ll mask,const vector<ll>& power,\n         const vector<ll>& masks,const vector<ll>& sum,ll& current_max){\n    int n = power.size();\n    if(k == n) return;\n    if(cur + sum[n] - sum[k] <= current_max) return;\n    if(mask & (1 << k)){\n        solve(k+1,cur,mask,power,masks,sum,current_max);\n    }else{\n        current_max = max(current_max,cur+power[k]);\n        solve(k+1,cur+power[k],mask | masks[k],power,masks,sum,current_max);\n        solve(k+1,cur,mask,power,masks,sum,current_max);\n    }\n}\n\nint main(){\n    while(true){\n        int n;cin >> n;\n        if(n == 0) break;\n        unordered_map<string,int> index_of;\n        int k = 0;\n        vector<ll> mask(n);\n        vector<ll> power(n);\n        for(int i=0;i<n;i++){\n            string A;int B,C;\n            cin >> A >> B >> C;\n            if(index_of.find(A) == index_of.end()){\n                index_of[A] = k;k++;\n            }\n            power[index_of[A]] = B;\n            for(int j=0;j<C;j++){\n                string d;cin >> d;\n                if(index_of.find(d) == index_of.end()){\n                    index_of[d] = k;k++;\n                }\n                mask[index_of[A]] = mask[index_of[A]] | (1 << index_of[d]);\n            }\n        }\n        // sum of [0..i)\n        vector<ll> sum(n+1);\n        for(int i=1;i<=n;i++){\n            sum[i] = sum[i-1] + power[i-1];\n        }\n        ll p = power[0];\n        solve(1,power[0],mask[0],power,mask,sum,p);\n        cout << p << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_N 41\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Country{\n  int index,power;\n  Country(int index=IINF,int power=IINF):index(index),power(power){}\n  bool operator < (const Country& c)const{ return power > c.power; }\n};\n\nint N,answer,V,sum[MAX_N];\null adj_bitmask[MAX_N];\nCountry c_list[MAX_N];\n\ninline void input(){\n  V = 0;\n  int dex = 0,i_tmp;\n  map<string,int> getIndex;\n  set<string> ban;\n  string s_tmp;\n  rep(i,N){\n    cin >> s_tmp >> i_tmp;\n    if( ban.find(s_tmp) != ban.end() ){\n      cin >> i_tmp;\n      rep(i,i_tmp)cin>>s_tmp;\n      continue;\n    }\n    if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n    int from = getIndex[s_tmp];\n    if( from == 0 ) answer = i_tmp;\n    c_list[from] = Country(from,i_tmp);\n    adj_bitmask[from] = 0ULL;\n    cin >> i_tmp;\n    rep(j,i_tmp){\n      cin >> s_tmp;\n      if( from == 0 ){\n\tban.insert(s_tmp);\n\tcontinue;\n      }\n      if( ban.find(s_tmp) != ban.end() ) continue;\n      if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n      int to = getIndex[s_tmp];\n      adj_bitmask[from] |= (1ULL<<to);\n    }\n  }\n  V = dex;\n}\n\nvoid dfs(int sp,int power,ull friend_bitmask,ull enemy_bitmask){\n  if( power + sum[sp] <= answer )return;\n  answer = max(answer,power);\n  if( sp >= V ) return;\n   \n  REP(i,sp,V){\n    if( ((friend_bitmask|enemy_bitmask)>>(ull)(c_list[i].index)) & 1ULL ) continue;\n    if( friend_bitmask & adj_bitmask[c_list[i].index] ) continue;\n    dfs(i+1,power+c_list[i].power,friend_bitmask|(1ULL<<c_list[i].index),enemy_bitmask|adj_bitmask[c_list[i].index]);\n    dfs(i+1,power,friend_bitmask,enemy_bitmask);\n    break;\n  }\n\n}\n\nint main(){\n  while(cin>>N,N){\n    input();\n    sort(c_list,c_list+V);\n    rep(i,V)sum[i] = 0;\n    sum[V-1] = c_list[V-1].power;\n    for(int i=V-2;i>=0;i--) sum[i] = sum[i+1] + ((c_list[i].index==0)?0:c_list[i].power);\n    dfs(0,answer,1,0);\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> adj[50];\nint power[50];\nbool used[50];\nint ans, rest, sum;\nint N;\nvector<int> per;\nvoid dfs(int k_){\n  if(k_ == N){\n    ans = max(ans,  sum);\n    return ;\n  }\n  int k = per[k_];\n  //printf(\"%d:%d %d %d\\n\", k,sum , rest, ans);\n  if(sum + rest <= ans){\n    ans = max(ans,  sum);\n    return;\n  }\n  bool usedtmp[50];\n  REP(i, 50) usedtmp[i] = used[i];\n  int sumtmp = sum;\n  int resttmp = rest;\n  if(!used[k]){\n    used[k] = true;\n    sum += power[k];\n    rest -= power[k];\n    FORIT(it, adj[k])if(!used[*it]){\n      rest -= power[*it];\n      used[*it] = true;\n    }\n    dfs(k_ + 1);\n    REP(i, 50) used[i] = usedtmp[i];\n    sum = sumtmp;\n    rest = resttmp;\n  }\n  if(k != 0){\n    if(!used[k])rest -= power[k];\n    used[k] = true;\n    dfs(k_ + 1);\n    rest += power[k];\n    used[k] = false;\n  }\n}\n\ntypedef pair<int, int> P;\nint main(){\n  while(cin>>N && N){\n    ans = 0, rest = 0, sum = 0;\n    REP(i, 50) adj[i].clear();\n    memset(used, 0, sizeof(used));\n    map<string, int> id;\n    vector<string> adjstr[50];\n    REP(i, N){\n      string s; cin>>s; id[s] = i;\n      cin>>power[i];\n      rest += power[i];\n      int k; cin>>k;\n      while(k--){\n        string str; cin>>str;\n        adjstr[i].push_back(str);\n      }\n    }\n    REP(i, N){\n      REP(j, adjstr[i].size()){\n        adj[i].push_back(id[adjstr[i][j]]);\n      }\n    }\n    vector<P> ps(N-1);\n    REP(i, N-1)ps[i] = P(-power[i+1], i+1);\n    sort(ps.begin(), ps.end());\n    per = vector<int>(N, 0);\n    REP(i, N-1) per[i+1] = ps[i].second;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9;\nint n, b[100], c[100], dp1[1 << 20], dp2[1 << 20];\nint ng1[100], ng2[100], ng[100];\nstring name[100], d[100][100];\nbool e[100][100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(e, 0, sizeof(e));\n\t\tmap<string, int> id;\n\t\t\n\t\trep(i, n){\n\t\t\tcin >> name[i] >> b[i] >> c[i];\n\t\t\trep(j, c[i]) cin >> d[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, c[i]) e[i][id[d[i][j]]] = e[id[d[i][j]]][i] = 1;\n\t\t\n\t\tint N = n / 2, M = n - N;\n\t\trep(i, 1 << N) dp1[i] = -inf;\n\t\trep(i, 1 << M) dp2[i] = -inf;\n\t\tdp1[1] = b[0]; dp2[0] = 0;\n\t\t\n\t\trep(i, N) ng1[i] = ng[i] = 0;\n\t\trep(i, M) ng2[i] = 0;\n\t\t\n\t\trep(i, N) rep(j, N) if(e[i][j]) ng1[i] |= 1 << j;\n\t\trep(i, M) rep(j, M) if(e[i + N][j + N]) ng2[i] |= 1 << j;\n\t\trep(i, N) rep(j, M) if(e[i][j + N]) ng[i] |= 1 << j;\n\t\t\n\t\tfor(int i = 1; i < 1 << N; i++){\n\t\t\tint l = 0;\n\t\t\tfor(; !(i & 1 << l); l++);\n\t\t\tif(dp1[i ^ 1 << l] == -inf || ((i ^ 1 << l) & ng1[l])) continue;\n\t\t\tdp1[i] = dp1[i ^ 1 << l] + b[l];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < 1 << M; i++){\n\t\t\tint l = 0;\n\t\t\tfor(; !(i & 1 << l); l++);\n\t\t\tif(dp2[i ^ 1 << l] == -inf || ((i ^ 1 << l) & ng2[l])) continue;\n\t\t\tdp2[i] = dp2[i ^ 1 << l] + b[l + N];\n\t\t}\n\t\t\n\t\trep(i, 1 << M) rep(j, M) if(i & 1 << j)\n\t\t\tdp2[i] = max(dp2[i], dp2[i ^ 1 << j]);\n\t\t\n\t\tint ans = 0;\n\t\trep(i, 1 << N){\n\t\t\tint can = (1 << M) - 1;\n\t\t\trep(j, N) if(i & 1 << j) can &= ~ng[j];\n\t\t\t\n\t\t\tans = max(ans, dp1[i] + dp2[can]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint n;\nvector<int> b(41, 0), sum(41, 0);\nint ret = 0;\n\nvoid dfs(int cur, ll ban, const vector<vector<int>> &g, const vector<ll> &con, int ss, ll visit)\n{\n    if (cur == n)\n        return;\n    if (ss + sum[cur + 1] <= ret)\n        return;\n    // cout << bitset<64>(visit) << \" \" << ss << endl;\n    ret = max(ret, ss);\n    dfs(cur + 1, ban, g, con, ss, visit);\n    if ((ban >> (cur + 1)) & 1)\n        return;\n    dfs(cur + 1, ban | con[cur + 1], g, con, ss + b[cur + 1], visit | (1LL << (cur + 1)));\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n)\n    {\n        ret = 0;\n        vector<string> a(n);\n        vector<vector<string>> d(n);\n        map<string, int> mp;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> a[i];\n            mp[a[i]] = i;\n            cin >> b[i];\n            int c;\n            cin >> c;\n            for (int j = 0; j < c; j++)\n            {\n                string s;\n                cin >> s;\n                d[i].push_back(s);\n            }\n        }\n        sum[n - 1] = b[n - 1];\n        for (int i = n - 2; i >= 0; i--)\n            sum[i] = sum[i + 1] + b[i];\n        // printv(sum);\n        vector<vector<int>> g(n);\n        vector<ll> con(n, 0); // con[i] := i に隣接する頂点\n        for (int i = 0; i < n; i++)\n        {\n            for (const auto &s : d[i])\n            {\n                int idx = mp[s];\n                g[i].push_back(idx);\n                con[i] |= (1LL << idx);\n            }\n        }\n        dfs(0, con[0], g, con, b[0], 1);\n        cout << ret << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nbitset<40> G[44];\nint B[44];\nint idx[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\nbitset<40> ok;\nbitset<40> used;\nbitset<40> sele;\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[idx[i]] && !used[idx[i]] && !sele[idx[i]] ) cnt++;\n  }\n  //cout << id << \" \"<< cnt << \" \"<< M << endl;\n  //return cnt > M;\n  return false;\n}\nint solve(int num){\n  int id = idx[num];\n  if( num == N ) return 0;\n  if( sele[id] || ok[id] || used[id] ) return solve(num+1);\n  //if( check(num) ) return 0;\n  \n  bitset<40> tmp = used;\n  sele[id] = true;\n  used |= G[id];\n  int res = solve(num+1)+B[id];\n\n  //cout << \"view\" << endl;\n  //cout << ok << endl;\n  //cout << used << endl;\n  //cout << sele << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << \n  //cout << id << \" \" << res << endl;\n\n  used = tmp;\n  sele[id] = false;\n  \n  int sum = 0;\n  //for(int i=id;i<N;i++) if( !sele[i] && !ok[i] && !used[i] ) sum += B[i];\n  for(int i=num+1;i<N;i++) if( !sele[idx[i]] && !ok[idx[i]] && !used[idx[i]] ) sum += B[idx[i]];\n\n\n  if( sum > res )\n    res = max( res,solve(num+1) );\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    vector<pair<int,int>> point;\n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id]=0;\n      point.push_back( make_pair( B[id], id ) );\n      assert( id < N );\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id][nd] = true;\n      }\n    }\n\n    sort( point.rbegin(), point.rend() );\n    for(int i=0;i<(int)point.size();i++)\n      idx[i] = point[i].second;\n\n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i]==bitset<40>(0) ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    used = bitset<40>(0);\n    sele = bitset<40>(0);\n    if( G[0]!=bitset<40>(0) ) res += B[0];\n    sele[0] = true;\n    used |= G[0];\n    res += solve(0);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> P;\nint const MAX_N = 41;\n\nint N, ans, cost[MAX_N], f[MAX_N];\nmap<string,int> h;\nvector<int> G[MAX_N];\nbool used[MAX_N], edge[MAX_N][MAX_N];\n\nvoid add_edge(const string& a, const string& b, int& id, int cost_){\n\tif( !h.count(a) ) h[a] = id++;\n\tint u = h[a];\n\tif( !h.count(b) ) h[b] = id++;\n\tint v = h[b];\n\tG[u].push_back( v );\n\tG[v].push_back( u );\n\tedge[u][v] = edge[v][u] = true;\n\tcost[u] = cost_;\n}\n\n// k := テ、ツサツ甘ィツヲツ凝」ツ?ヲテ」ツ??」ツつ凝ゥツ?づァツつケ, sum := テァツキツ湘・ツ陳?\nvoid solve(int k, int sum){\n\tif( N == k ){\n\t\tans = max(ans, sum);\n\t}else{\n\t\t// ans テ」ツつ暗」ツつ甘」ツ??」ツ??ィツァツ」テ」ツ?古ィツヲツ凝」ツ?、テ」ツ?凝」ツつ嘉」ツ?ェテ」ツ??」ツ?ィテ」ツ??\n\t\tif( sum + f[k] <= ans ) return;\n\t\t\n\t\tif( G[k].size() == 0 ){ // テヲツャツ。テヲツ閉ー 0 テ」ツ?ョテ」ツ?ィテ」ツ??\n\t\t\tsolve(k+1, sum + cost[k]);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\t// is_used := テゥツ?づァツつケ k テ」ツつ津、ツスツソテ」ツ?暗」ツつ凝」ツ?凝」ツ?ゥテ」ツ??」ツ??\n\t\tbool is_used = true;\n\t\tfor(int i=0 ; i < k ; i++ ){\n\t\t\tif( used[i] && edge[i][k] ) is_used = false;\n\t\t}\n\t\tif( is_used ){\n\t\t\tused[k] = true;\n\t\t\tsolve(k+1, sum + cost[k]);\n\t\t\tused[k] = false;\n\t\t\t\n\t\t\tbool flag = true;\n\t\t\tfor(int i=k+1 ; i < N ; i++ ){\n\t\t\t\tif( edge[k][i] ) flag = false;\n\t\t\t}\n\t\t\tif( !flag )\n\t\t\t\tsolve(k+1, sum);\n\t\t}else{\n\t\t\tsolve(k+1, sum);\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> N , N ){\n\t\th.clear();\n\t\tfor(int i=0 ; i < MAX_N ; i++ ){\n\t\t\tG[i].clear();\n\t\t\tused[i] = false;\n\t\t\tf[i] = 0;\n\t\t\tfor(int j=0 ; j < MAX_N ; j++ ){\n\t\t\t\tedge[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tint id = 0;\n\t\t\n\t\tfor(int i=0 ; i < N ; i++ ){\n\t\t\tstring A, D;\n\t\t\tint B, C;\n\t\t\tcin >> A >> B >> C;\n\t\t\t\n\t\t\tif( !h.count(A) ) h[A] = id++;\n\t\t\tint u = h[A];\n\t\t\tcost[u] = B;\n\t\t\tfor(int j=0 ; j < C ; j++ ){\n\t\t\t\tcin >> D;\n\t\t\t\t\n\t\t\t\tif( !h.count(D) ) h[D] = id++;\n\t\t\t\tint v = h[D];\n\t\t\t\tG[u].push_back( v );\n\t\t\t\tG[v].push_back( u );\n\t\t\t\tedge[u][v] = edge[v][u] = true;\n\t\t\t}\n\t\t}\n\t\tfor(int i = N-1 ; i >= 0 ; i-- ){\n\t\t\tf[i] += f[i+1] + cost[i];\n\t\t}\n\t\t\n\t\tans = cost[0];\n\t\tused[0] = true;\n\t\tsolve(1, cost[0]);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\nusing namespace std;\nmap<int,int> country;\nint solve(map<set<int>,int> &visited,map<int,set<int> > &bannedlist,set<int> banned,int power){\n\tif(banned.size()==country.size())return power;\n\tif(visited.find(banned)!=visited.end())return visited[banned];\n\tint max=power;\n\tfor(int i=0,t;i<country.size();++i){\n\t\tif(banned.find(i)==banned.end()){\n\t\t\tset<int> b = banned;\n\t\t\tb.insert(i);\n\t\t\tfor(set<int>::iterator it=bannedlist[i].begin();it!=bannedlist[i].end();++it) b.insert(*it);\n\t\t\tt=solve(visited,bannedlist,b,power+country[i]);\n\t\t\tif(t>max)max=t;\n\t\t}\n\t}\n\tvisited[banned]=max;\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n)break;\n\t\tcountry.clear();\n\t\tmap<string,int> c_name;\n\t\tmap<int,set<string> > banned_c;\n\t\tint power,ncount;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tstring s;\n\t\t\tcin>>s>>power>>ncount;\n\t\t\tc_name[s]=i;\n\t\t\tcountry[i]=power;\n\t\t\tfor(int j=0;j<ncount;++j){\n\t\t\t\tstring ban;\n\t\t\t\tcin>>ban;\n\t\t\t\tbanned_c[i].insert(ban);\n\t\t\t}\n\t\t}\n\t\tmap<int,set<int> > banned;\n\t\tfor(int i=0;i<n;++i) for(set<string>::iterator it=banned_c[i].begin();it!=banned_c[i].end();++it) banned[i].insert(c_name[*it]);\n\t\tmap<set<int>,int> visited;\n\t\tset<int> b=banned[0];\n\t\tb.insert(0);\n\t\tint ans = solve(visited,banned,b,country[0]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nvector<int> power;\nvector<vector<int> > adj;\n\nint dfs(char country, long long ng) {\n\tif(country == power.size())\n\t\treturn 0;\n\n\tif(ng & (1ll << country))\n\t\treturn dfs(country + 1, ng);\n\n\tif(adj[country].size() == 0)\n\t\treturn dfs(country + 1, ng) + power[country];\n\n\tint tmp = dfs(country + 1, ng);\n\n\tfor(int i = 0; i < adj[country].size(); ++i)\n\t\tng |= (1ll << adj[country][i]);\n\n\treturn max(tmp, dfs(country + 1, ng) + power[country]);\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tfor(int n = 0; cin >> n, n;) {\n\t\tmap<string, int> convert;\n\t\tvector<vector<string> > d(n);\n\t\tpower.clear();\n\t\tpower.resize(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring a;\n\t\t\tint c;\n\t\t\tcin >> a >> power[i] >> c;\n\n\t\t\tconvert[a] = i;\n\n\t\t\td[i].resize(c);\n\t\t\tfor(int j = 0; j < c; ++j)\n\t\t\t\tcin >> d[i][j];\n\t\t}\n\n\t\tadj.clear();\n\t\tadj.resize(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < d[i].size(); ++j)\n\t\t\t\tif(i < convert[d[i][j]])\n\t\t\t\t\tadj[i].push_back(convert[d[i][j]]);\n\n\t\tlong long ng = 0;\n\t\tfor(int i = 0; i < adj[0].size(); ++i)\n\t\t\tng |= (1ll << adj[0][i]);\n\n\t\tint ans = power[0] + dfs(1, ng);\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50;\n// input ????????????\nstring A[MAXN], D[MAXN][MAXN];\nint B[MAXN], C[MAXN];\nint N;\n\n// ?????¨?????????????????±\nint strength[MAXN];\nbool G[MAXN][MAXN];\n\nint dp1[1<<21], dp2[1<<21];\n\n// s ???????????????????????¨???????????£????????????????????????????????§???\nint dfs1(int s) {\n\tint& ret = dp1[s];\n\tif (ret >= 0) return ret;\n\tret = 0;\n\tint n = N/2;\n\tfor (int i = 0; i < n; i++) {\n\t\tif ((s>>i)&1) {\n\t\t\t// i ????????£?????????\n\t\t\tint tmp = strength[i];\n\t\t\tint ns = s;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (((s>>j)&1) == 0) continue;\n\t\t\t\tif (G[i][j]) ns ^= 1<<j;\n\t\t\t}\n\t\t\ttmp += dfs1(ns);\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dfs2(int s) {\n\tint& ret = dp2[s];\n\tif (ret >= 0) return ret;\n\tret = 0;\n\tint n = N/2, n1 = N-n;\n\tfor (int i = 0; i < n1; i++) {\n\t\tif ((s>>i)&1) {\n\t\t\t// i ????????£?????????\n\t\t\tint tmp = strength[i+n];\n\t\t\tint ns = s;\n\t\t\tfor (int j = 0; j < n1; j++) {\n\t\t\t\tif (((s>>j)&1) == 0) continue;\n\t\t\t\tif (G[i+n][j+n]) ns ^= 1<<j;\n\t\t\t}\n\t\t\ttmp += dfs2(ns);\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N) {\n    \tif (N==0) break;\n    \tmap<string, int> mp;\n    \tfor (int i = 0; i < N; i++) {\n    \t\tcin >> A[i] >> B[i] >> C[i];\n    \t\tmp[A[i]] = 0;\n    \t\tfor (int j = 0; j < C[i]; j++) {\n    \t\t\tcin >> D[i][j];\n    \t\t}\n    \t}\n    \t{\n    \t\tint k = 0;\n    \t\tfor (auto& p : mp) \n    \t\t\tp.second = k++;\n    \t}\n    \t// ?????±????????¨??????????????????\n    \tfor (int i = 0; i < N; i++) \n    \t\tstrength[mp[A[i]]] = B[i];\n    \t// ??°??????????????????\n    \tmemset(G, false, sizeof(G));\n    \tfor (int i = 0; i < N; i++) {\n    \t\tint v = mp[A[i]];\n    \t\tG[v][v] = true;\n    \t\tfor (int j = 0; j < C[i]; j++) {\n    \t\t\tint u = mp[D[i][j]];\n    \t\t\tG[v][u] = true;\n    \t\t}\n    \t}\n    \tif (N==1) {\n    \t\tcout << strength[0] << endl;\n    \t\tcontinue;\n    \t}\n    \t// ????????¨??????\n    \tmemset(dp1, -1, sizeof(dp1));\n    \tmemset(dp2, -1, sizeof(dp2));\n    \tint n = N/2, n1 = N-n;;\n    \tint v = mp[A[0]];\n    \tint ans = 0;\n    \tfor (int s = 0; s < 1<<n; s++) {\n    \t\tbool ng = false;\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tif (G[v][i] && ((s>>i)&1)) ng = true;\n    \t\t}\n    \t\tif (v < n && ((s>>v)&1)) ng = true;\n    \t\tif (ng) continue;\n    \t\tint ns = 0;\n    \t\tfor (int i = 0; i < n1; i++) {\n    \t\t\tint tmp = (i+n != v);\n    \t\t\tfor (int j = 0; j < n; j++) {\n    \t\t\t\tif (((s>>j)&1)==0) continue;\n    \t\t\t\tif (G[j][i+n]) tmp = 0;\n    \t\t\t}\n    \t\t\tif (G[i+n][v]) tmp = 0;\n    \t\t\tns |= tmp<<i;\n    \t\t}\n    \t\tans = max(ans, strength[v]+dfs1(s)+dfs2(ns));\n    \t}\n    \tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nint N;\nmap<string,int> id;\nint B[MAXN];\nbool vis[MAXN];\nGraph g;\nint Maxi;\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\nvoid addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nvoid dfs(int v, vector<int> &vs) {\n  vs.push_back(v);\n  vis[v] = true;\n  for(int i = 0; i < g[v].size(); ++i) {\n    int nv = g[v][i];\n    if(vis[nv]) continue;\n    dfs(nv, vs);\n  }\n}\n\nvoid bt(int k, int now, const vector<int> &vs, const vector<int> &sum, vector<int> &used) {\n  if(k == vs.size()) {\n    Maxi = max(Maxi, now);\n    return;\n  }\n  if(now + sum[k] <= Maxi) return;\n  if(vs[k] != 0) {\n    used[vs[k]] = false;\n    bt(k+1, now, vs, sum, used);\n  }\n  try {\n    for(int i = 0; i < g[vs[k]].size(); ++i) {\n      int nv = g[vs[k]][i];\n      if(used[nv]) throw 0;\n    }\n    used[vs[k]] = true;\n    bt(k+1, now+B[vs[k]], vs, sum, used);\n  } catch(...){}\n  used[vs[k]] = false;\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n    int res = 0;\n    fill(vis, vis+MAXN, false);\n    for(int i = 0; i < N; ++i) {\n      if(!vis[i]) {\n        vector<int> vs;\n        dfs(i, vs);\n        vector<pair<int,int> > pv;\n        for(int j = 0; j < vs.size(); ++j) {\n          int out;\n          if(vs[j] == 0) out = (1<<28);\n          else out = g[vs[j]].size();\n          pv.push_back(make_pair(-out, vs[j]));\n        }\n        sort(pv.begin(), pv.end());\n        for(int j = 0; j < vs.size(); ++j) vs[j] = pv[j].second;\n        vector<int> used(N);\n        vector<int> sum(vs.size()+1);\n        for(int j = (int)vs.size()-1; j >= 0; --j) {\n          sum[j] = sum[j+1] + B[vs[j]];\n        }\n        Maxi = 0;\n        bt(0, 0, vs, sum, used);\n        res += Maxi;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<'='<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\nconst int INF=1e9;\nconst int MOD=1e9+7;\nconst double EPS=1e-9;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& a){\n\tos<<'[';\n\trep(i,a.size()) os<<(i?\" \":\"\")<<a[i];\n\treturn os<<']';\n}\n\nstruct Edge{\n\tint src,dst;\n\tEdge(){}\n\tEdge(int s,int d):src(s),dst(d){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid DFS(const Graph& g,const vi& ps,int u,vi& vis,int cur,int rem,int& res)\n{\n\tint n=g.size();\n\tif(cur+rem<=res) return;\n\tres=max(res,cur);\n\tif(u==n) return;\n\t\n\tif(vis[u]){\n\t\tDFS(g,ps,u+1,vis,cur,rem,res);\n\t\treturn;\n\t}\n\t\n\t// use u\n\tvi tmp=vis;\n\tvis[u]=1;\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(!vis[v]) vis[v]=2,rem-=ps[v];\n\t}\n\tDFS(g,ps,u+1,vis,cur+ps[u],rem-ps[u],res);\n\tswap(vis,tmp);\n\trep(i,g[u].size()){\n\t\tint v=g[u][i].dst;\n\t\tif(!vis[v]) rem+=ps[v];\n\t}\n\t\n\tif(u==0) return;\n\t\n\t// don't use u\n\tif(g[u].size()>=1){\n\t\tvis[u]=2;\n\t\tDFS(g,ps,u+1,vis,cur,rem-ps[u],res);\n\t\tvis[u]=0;\n\t}\n}\n\nint MaxIndependentSet(const Graph& g,const vi& ps)\n{\n\tvi vis(g.size());\n\tint res=0;\n\tDFS(g,ps,0,vis,0,accumulate(all(ps),0),res);\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n;cin>>n && n;){\n\t\tGraph g(n);\n\t\tvi ps(n); // 軍事力\n\t\tmap<string,int> f;\n\t\trep(i,n){\n\t\t\tstring s; cin>>s;\n\t\t\tf.insert(mp(s,f.size()));\n\t\t\tint u=f[s];\n\t\t\tcin>>ps[u];\n\t\t\tint m; cin>>m;\n\t\t\trep(j,m){\n\t\t\t\tstring t; cin>>t;\n\t\t\t\tf.insert(mp(t,f.size()));\n\t\t\t\tint v=f[t];\n\t\t\t\tg[u].emplace_back(u,v);\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout<<MaxIndependentSet(g,ps)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nvector<i64> edges(n + 10, 0);\nvector<int> x(n + 10, 0);\nvector<int> sum(n + 10, 0);\nint result = 0;\nvoid dfs(i64 i, i64 bit, int now_sum) {\n  result = max(result, now_sum);\n  if (i == n)\n    return;\n  //枝刈り\n  if (now_sum + sum[i] <= result)\n    return;\n  // throw\n  dfs(i + 1, bit, now_sum);\n\n  if (!(bit & edges[i]))\n    dfs(i + 1, bit | (1LL << i), now_sum + x[i]);\n};\nint get_i(map<string,int> &mp,string &s) {\n  if (mp.count(s)) {\n    return mp[s];\n  } else {\n    mp[s] = mp.size();\n    return (int)mp.size() - 1;\n  }\n};\n\nint main(){\n    cin >> n;\n    while(n){\n        edges.assign(n + 10, 0);\n        x.assign(n + 10, 0);\n        map<string,int> mp;\n        for (int c = 0; c < n; c++) {\n          string s;\n          cin >> s;\n          int i = get_i(mp,s);\n          int C;\n          cin >> x[i] >> C;\n          for (int d = 0; d < C; d++) {\n            cin >> s;\n            edges[i] |= (1LL << get_i(mp,s));\n          }\n        }\n\n        sum.assign(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        result = 0;\n        dfs(1,1,x[0]);\n        cout << result;\n        cin >> n;\n        if(n) cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nint N, G[42][42];\nstring C[42];\n\n#define UNION 1\n#define NEIGHBOR 2\n\nstruct Union{\n\tstring A;\n\tint B,C;\n\tint D[42];\n\tqueue<string> S;\n} \tU[42];\n\nclass UnionSearch{\npublic:\n\tint State[42], B;\n\tUnionSearch();\n\tvoid AddUnion(int u);\n};\n\nUnionSearch::UnionSearch(){\n\tB=0;\n\tfor(int i=1;i<=N;i++) State[i]=0;\n}\n\nvoid UnionSearch::AddUnion(int u){\n\tState[u] = UNION;\n\tfor(int i=0;i<U[u].C;i++) State[ U[u].D[i] ] = NEIGHBOR;\n\tB += U[u].B;\n}\n\n\nqueue <UnionSearch> US;\n\n\nint Find(string s){\n\tfor(int i=1;i<=N;i++) if(s==U[i].A) return i;\n\tprintf(\"error\");\n\treturn 0;\n}\n\nmain(){\n\tint i,j,k,c,Max;\n\tstring s;\n\twhile(cin>>N,N){\n\t//\tUS.clear();\n\t\tMax = 0;\n\t\tfor(i=1;i<=N;i++){\n\t\t\tcin>>U[i].A>>U[i].B>>c;\n\t\t\twhile(c--){\n\t\t\t\tcin>>s;\n\t\t\t\tU[i].S.push(s);\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=N;i++){\n\t\t\twhile(!U[i].S.empty()){\n\t\t\t\tU[i].D[U[i].C++] = Find(U[i].S.front());\n\t\t\t\tU[i].S.pop();\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tUnionSearch q;\n\t\tq.AddUnion(1);\n\t\tUS.push(q);\n\t\twhile(!US.empty()){\n\t\t\tq = US.front();\n\t\t\tUS.pop();\n\t\t\tint t;\n\t\t\tfor(t=1;t<=N;t++){\n\t\t\t\tif(!q.State[t])break;\n\t\t\t\n\t\t\t}\n\t\t\tif(t>N){\n\t\t\t\tMax = max(Max, q.B);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(i=0;i<U[t].C;i++){\n\t\t\t\tUnionSearch p = q;\n\t\t\t\tif(p.State[U[t].D[i]]) continue;\n\t\t\t\tp.AddUnion(U[t].D[i]);\n\t\t\t\tUS.push(p);\n\t\t\t}\n\t\t\tq.AddUnion(t);\n\t\t\tUS.push(q);\n\t\t}\n\t\tcout << Max << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\nint N, G[42][42];\nstring C[42];\n\n#define UNION 1\n#define NEIGHBOR 2\n\nstruct Union{\n\tstring A;\n\tint B,C;\n\tint D[42];\n\tqueue<string> S;\n} \tU[42];\n\nclass UnionSearch{\npublic:\n\tint State[42], B;\n\tUnionSearch::UnionSearch();\n\tvoid UnionSearch::AddUnion(int u);\n};\n\nUnionSearch::UnionSearch(){\n\tB=0;\n\tfor(int i=1;i<=N;i++) State[i]=0;\n}\n\nvoid UnionSearch::AddUnion(int u){\n\tState[u] = UNION;\n\tfor(int i=0;i<U[u].C;i++) State[ U[u].D[i] ] = NEIGHBOR;\n\tB += U[u].B;\n}\n\n\nqueue <UnionSearch> US;\n\n\nint Find(string s){\n\tfor(int i=1;i<=N;i++) if(s==U[i].A) return i;\n\tprintf(\"error\");\n\treturn 0;\n}\n\nmain(){\n\tint i,j,k,c,Max;\n\tstring s;\n\twhile(cin>>N,N){\n\t//\tUS.clear();\n\t\tMax = 0;\n\t\tfor(i=1;i<=N;i++){\n\t\t\tcin>>U[i].A>>U[i].B>>c;\n\t\t\twhile(c--){\n\t\t\t\tcin>>s;\n\t\t\t\tU[i].S.push(s);\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=N;i++){\n\t\t\twhile(!U[i].S.empty()){\n\t\t\t\tU[i].D[U[i].C++] = Find(U[i].S.front());\n\t\t\t\tU[i].S.pop();\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tUnionSearch q;\n\t\tq.AddUnion(1);\n\t\tUS.push(q);\n\t\twhile(!US.empty()){\n\t\t\tq = US.front();\n\t\t\tUS.pop();\n\t\t\tint t;\n\t\t\tfor(t=1;t<=N;t++){\n\t\t\t\tif(!q.State[t])break;\n\t\t\t\n\t\t\t}\n\t\t\tif(t>N){\n\t\t\t\tMax = max(Max, q.B);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(i=0;i<U[t].C;i++){\n\t\t\t\tUnionSearch p = q;\n\t\t\t\tif(p.State[U[t].D[i]]) continue;\n\t\t\t\tp.AddUnion(U[t].D[i]);\n\t\t\t\tUS.push(p);\n\t\t\t}\n\t\t\tq.AddUnion(t);\n\t\t\tUS.push(q);\n\t\t}\n\t\tcout << Max << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nmap<string,int> m;\nint idx=0;\nvector<int> G[101];\nvector<string> CS[101];\nstring names[101];\nint strong[101];\nbool used[101];\nint optNum;\n\n// 現在選べるものから選ぶ\nvoid dfs(int idx,int sum){\n  if(idx==N){\n    optNum=max(optNum,sum);\n    return;\n  }\n  if(used[idx]){\n    dfs(idx+1,sum);\n    return;\n  }\n  int allSum=0;\n  bool cur[50];\n  for(int i=0;i<N;i++){\n    cur[i]=used[i];\n    if(!used[i])allSum+=strong[i];\n  }\n  if(allSum+sum<=optNum)return;\n  bool ok=true;\n  // これから選ぶ頂点のどれかと隣接しているかチェック\n  for(int i=idx+1;i<N;i++){\n    if(used[i])continue;\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j]==idx){\n\tok=false;\n\tbreak;\n      }\n    }\n    if(!ok)break;\n  }\n  // 隣接している頂点が存在する場合\n  if(idx!=0&&!ok){\n    // 取らない\n    dfs(idx+1,sum);\n  }\n  if(!used[idx]){\n    used[idx]=true;\n    for(int j=0;j<(int)G[idx].size();j++){\n      int to=G[idx][j];\n      used[to]=true;\n    }\n    dfs(idx+1,sum+strong[idx]);\n    for(int j=0;j<N;j++)used[j]=cur[j];\n  }\n}\n\nint main(){\n  while(cin>>N&&N){\n    idx=0;\n    optNum=-1;\n    for(int i=0;i<101;i++){\n      G[i].clear();\n      CS[i].clear();\n    }\n    m.clear();\n    for(int i=0;i<N;i++){\n      cin>>names[i]>>strong[i];\n      int C;\n      cin>>C;\n      for(int j=0;j<C;j++){\n\tstring s;\n\tcin>>s;\n\tif(m.count(s)==0)m[s]=idx++;\n\tCS[i].push_back(s);\n      }\n    }\n    for(int i=0;i<N;i++)\n      m[names[i]]=i;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<(int)CS[i].size();j++){\n\tG[m[names[i]]].push_back(m[CS[i][j]]);\n\tG[m[CS[i][j]]].push_back(m[names[i]]);\n      }\n    }\n    memset(used,0,sizeof(used));\n    dfs(0,0);\n    cout<<optNum<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,ans,sum;\nstring a[50];\nint b[50],c[50];\nvector<string> d[50];\nvector<int> e[50];\nmap<string,int> m;\nvoid dfs(int x,int p,int q,int s,int t){\n  //cout<<x<<\" \"<<p<<\" \"<<q<<\":\"<<sum<<\" \"<<ans<<endl;\n  if(sum-q<=ans) return;\n  ans=max(ans,p);\n  if(x==n) return;\n  dfs(x+1,p,q,s,t);\n  if(!((t>>x)&1)){\n    s+=1LL<<x;\n    p+=b[x];\n    for(int i=0;i<c[x];i++){\n      if((s>>e[x][i])&1) return;\n      if((t>>e[x][i])&1) continue;\n      t+=1LL<<e[x][i];\n      q+=b[e[x][i]];\n    }\n    dfs(x+1,p,q,s,t);\n  }\n}\nsigned main(){\n  while(cin>>n,n){\n    m.clear();\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      m[a[i]]=i;\n      d[i].clear();\n      d[i].resize(c[i]);\n      for(int j=0;j<c[i];j++) cin>>d[i][j];\n    }\n    for(int i=0;i<n;i++){\n      e[i].clear();\n      e[i].resize(c[i]);\n      for(int j=0;j<c[i];j++) e[i][j]=m[d[i][j]];\n    }\n    ans=sum=0;\n    for(int i=0;i<n;i++) sum+=b[i];\n    int s=1,t=0;\n    int p=b[0],q=0;\n    for(int i=0;i<c[0];i++){\n      if((t>>e[0][i])&1) continue;\n      t+=1LL<<e[0][i];\n      q+=b[e[0][i]];\n    }\n    dfs(1,p,q,s,t);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if(ne & (1LL<<i) != 0) continue;\n        if(((ne | cs[i].ne) ^ (ne | (1<<i))) < 1LL){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n\n    priority_queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.top().second.second;\n        power = pq.top().second.first;\n        int v = pq.top().first + 1;\n        pq.pop();\n        res = max(res, power);\n        if(v > n - 1) continue;\n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        \n        \n        ll nne = ne;\n        int npower = power;\n        for(int i = v + 1; i < n; i++){\n            if((nne & (1LL<<i)) != 0) continue;\n            if(((nne | cs[i].ne) ^ (nne | (1<<i))) < (1LL<<v)){\n                nne |= cs[i].ne;\n                npower += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(npower, nne)));\n        \n        \n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if(((ne | cs[i].ne) ^ (ne | (1LL<<i))) < (1LL<<v)){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nint N;\n\nstring Name[40];\nvector<string>to[40];\nvint G[40];\nint val[40];\n\npint bef[1<<20],aft[1<<20];\nbool used[40];\nvoid solve(){\n\n    fill_n(bef,1<<20,pint(-1,-1));\n    fill_n(aft,1<<20,pint(-1,-1));\n\n    rep(i,N){\n        cin>>Name[i];\n        cin>>val[i];\n        int m;cin>>m;\n        to[i].resize(m);\n        rep(j,m)cin>>to[i][j];\n    }\n\n    rep(i,N){\n        G[i].resize(to[i].size());\n        rep(j,to[i].size()){\n            int hoge=find(Name,Name+N,to[i][j])-Name;\n            G[i][j]=hoge;\n        }\n    }\n\n    int a=N/2;\n    int b=N-a;\n\n    bef[0]=mp(0,0);\n    rep(i,1<<a){\n        if(bef[i].first==-1)continue;\n        rep(j,a){\n            if(bef[i].second>>j&1)continue;\n            int b=bef[i].second|(1<<j);\n            rep(k,G[j].size())if(G[j][k]<a)b|=(1<<G[j][k]);\n            bef[i|(1<<j)].first=bef[i].first+val[j];\n            bef[i|(1<<j)].second=b;\n        }\n    }\n    aft[0]=mp(0,0);\n    rep(i,1<<b){\n        if(aft[i].first==-1)continue;\n        rep(j,b){\n            if(aft[i].second>>j&1)continue;\n            int b=aft[i].second|(1<<j);\n            rep(k,G[j+a].size())if(G[j+a][k]>=a)b|=(1<<(G[j+a][k]-a));\n            aft[i|(1<<j)].first=aft[i].first+val[j+a];\n            aft[i|(1<<j)].second=b;\n        }\n    }\n\n\n\n    rep(i,1<<b){\n        rep(j,b){\n            if((i>>j&1)==0)continue;\n            chmax(aft[i].first,aft[i^(1<<j)].first);\n        }\n    }\n\n\n    int ans=0;\n    rep(i,1<<a){\n        if(bef[i].first==-1)continue;\n        if((i&1)==0)continue;\n        memset(used,0,sizeof(used));\n        rep(j,a){\n            if(i>>j&1)rep(k,G[j].size())used[G[j][k]]=true;\n        }\n\n        int bit=(1<<b)-1;\n        for(int j=a;j<N;j++){\n            if(used[j])bit^=1<<(j-a);\n        }\n        chmax(ans,bef[i].first+aft[bit].first);\n    }\n    cout<<ans<<endl;\n}\n\nint main(){\n    while(scanf(\"%d\",&N),N)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[40];\nbool G[40][40];\nint NG[40];\nint sum[41];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[fake] < beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint N;\nvector<vector<int>> G;\nstring A[42];\nint B[42], C[42];\nmap<ll, int> memo;\n\nint dfs(ll bit){\n    if(bit == (1 << N) - 1) return 0;\n    if(memo.find(bit) != memo.end()) return memo[bit];\n    int ret = 0;\n    for(int i=1;i<N;i++){\n        if((bit >> i) & 1) continue;\n        ll nbit = bit | (1 << i);\n        for(int to : G[i]){\n            nbit |= (1 << to);\n        }\n        ret = max(ret, dfs(nbit) + B[i]);\n    }\n    memo[bit] = ret;\n    return ret;\n}\n\nint main(){\n    while(true){\n        cin >> N;\n        if(N == 0) break;\n\n        map<string, int> mp;\n        vector<vector<string>> names(N);\n        for(int i=0;i<N;i++){\n            cin >> A[i] >> B[i] >> C[i];\n            mp[A[i]] = i;\n            names[i].resize(C[i]);\n            for(int j=0;j<C[i];j++){\n                cin >> names[i][j];\n            }\n        }\n\n        G.assign(N, {});\n        for(int i=0;i<N;i++){\n            for(string& to : names[i]){\n                G[i].push_back(mp[to]);\n            }\n        }\n\n        ll bit = 1;\n        int ans = B[0];\n        for(int i=1;i<N;i++){\n            if(C[i] == 0){\n                bit |= (1 << i);\n                ans += B[i];\n            }\n        }\n        for(int to : G[0]){\n            bit |= (1 << to);\n        }\n\n        memo.clear();\n\n        cout << ans + dfs(bit) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<vector<int> > memo;\n\nvoid dfs(int x,int sum,vector<int> S,int idx){\n  \n  for(int i=idx;i<n;i++){\n\n    if(!x&&i) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<S.size();j++)\n      if(G[S[j]][i]) f=1;\n    \n    if(!f){\n      \n      vector<int> nS=S;\n      \n      nS.push_back(i);\n      \n      sort(nS.begin(),nS.end());\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[i]);\n\t\n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=0;\n\n    vector<int> S;\n    \n    dfs(0,0,S,0);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<int> DD[41];\nHmap<string, int> hm;\n\nvector<ll> dp0(1<<20);\nvector<ll> dp1(1<<20);\n\nint masks[1<<20];\n\nvoid calc (vl& dp, int s, int e) {\n  int l = e - s;\n  vector<int> ngs(l);\n  rep(i, l) {\n    for(const auto& t: DD[i+s]) {\n      if(s <= t && t < e) {\n\tngs[i] |= (1<<(t-s));\n      }\n    }\n  }\n  rep(mask, 1 << l) {\n    rep(i, l) {\n      if(mask & (1<<i)) continue;\n      if(mask&ngs[i]) continue;\n      int nxt = mask | (1<<i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n    }\n  }\n  rep(mask, 1<<l) {\n    rep(i, l) {\n      if(mask&(1<<i)) {\n\tint pre = mask - (1<<i);\n\tdp[mask] = max(dp[mask], dp[pre]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    hm.clear();\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    rep(i, n) {\n      DD[i].resize(D[i].size());\n      rep(j, D[i].size()) {\n\tDD[i][j] = hm[D[i][j]];\n      }\n    }\n\n    continue;\n    \n    rep(i, 1<<20) dp0[i] = 0;\n    rep(i, 1<<20) dp1[i] = 0;\n    \n    calc(dp0, 0, n/2);\n    calc(dp1, n/2, n);\n\n    int len = n - (n/2);\n    rep(i, 1<<(n+1)/2) masks[i] = (1<<len)-1;\n    vector<int> ngs(n/2);\n    rep(i, n) {\n      for(const auto& tt : DD[i]) {\n\tint t = tt - n / 2;\n\tif(t < 0) continue;\n\tngs[i] |= (1<<t);\n      }\n    }\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tint tmp = masks[mask]&ngs[i];\n\tmasks[mask] -= tmp;\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp0[mask] + dp1[masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring a[40];\nint b[40];\nvector<string> d[40];\nmap<string,int> sn;\n\nint dfs(long long u,int c){\n  if(c==n){\n    return 0;\n  }else{\n    int m=dfs(u,c+1);\n    int i;\n    if(!(u>>c&1)){\n      long long nu=u|1LL<<c;\n      for(int i=0;i<d[c].size();i++){\n\tnu|=1LL<<sn[d[c][i]];\n      }\n      m=max(m,dfs(nu,c+1)+b[c]);\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    sn.clear();\n    for(int i=0;i<n;i++){\n      int c;\n      cin>>a[i]>>b[i]>>c;\n      sn[a[i]]=i;\n      d[i].resize(c);\n      while(c--){\n\tcin>>d[i][c];\n      }\n    }\n    long long n=1;\n    for(int i=0;i<d[0].size();i++){\n      n|=1LL<<sn[d[0][i]];\n    }\n    cout<<dfs(n,1)+b[0]<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\n\nint N;\nvector<vector<int> > L;\nvector<int> power;\nvector<bool> ok;\nint ans;\nvector<int> total;\n\nvoid calc(int now,int sum){\n\n\tans=max(ans,sum);\n\tint t=0;\n\n\tfor(int i=now;i<N;i++)\n\t\tt+=power[i];\n\tif(t+sum<=ans) return;\n\n\tif(now>=N) return;\n\n\tif(!ok[now]){calc(now+1,sum);return;}\n\tbool can_cut=true;\n\n\tfor(int i=0;i<L[now].size();i++){//枝狩れるかチェック!\n\t\tif(ok[L[now][i]]){can_cut=false;break;}\n\t}\n\n\tvector<int> memo;\n\tfor(int i=0;i<L[now].size();i++){\n\t\tif(ok[L[now][i]]){memo.push_back(L[now][i]);ok[L[now][i]]=false;}\n\t}\n\n\n\tcalc(now+1,sum+power[now]);\n\n\tfor(int i=0;i<memo.size();i++)\n\t\tok[memo[i]]=true;\n\n\tif(!can_cut) calc(now+1,sum);//枝刈り\n}\n\nint main()\n{\n\twhile(cin>>N && N!=0){\n\t\tans=0;\n\t\tint c=0;\n\t\tmap<string,int> Idx;\n\t\tL.clear();L.resize(N,vector<int>());\n\t\tok.clear();ok.resize(N,true);\n\t\tpower.clear(); power.resize(N,0);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring nation;\n\t\t\tcin>>nation;\n\t\t\tif(!Idx.count(nation))Idx[nation]=c++;\n\t\t\tcin>>power[Idx[nation]];\n\t\t\tint m=0;cin>>m;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tstring s; cin>>s;\n\t\t\t\tif(!Idx.count(s))Idx[s]=c++;\n\t\t\t\tL[Idx[nation]].push_back(Idx[s]);\n\t\t\t}\n\t\t}\n\n\t\ttotal.clear();total.resize(N+1,0);\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\ttotal[i]=total[i+1]+power[i];\n\t\t}\n\n\n\t\tok[0]=false;\n\t\tans+=power[0];\n\t\tfor(int i=0;i<L[0].size();i++)\n\t\t\tok[L[0][i]]=false;\n\n\t\tcalc(1,ans);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing Graph = vector< vector<int> >;\n\n// generate binary string (not less than k-digit)\nstring to_binString(int n, int k) {\n    string ret = \"\";\n    while(n) ret += ('0' + (n&1)), n >>= 1;\n    while(ret.length() < k) ret += '0';\n    // reverse(ret.begin(), ret.end());\n    return ret;\n}\n\nint N;\n\nmap<long long int, int> checked;\n\nint solve(const Graph &G, const vector<int> &cost, vector<int> &deg, long long int bit) {\n    if(checked.count(bit)) {\n        return checked[bit];\n    }\n\n    long long int nbit;\n\n    int ret = 0, tmp;\n\n    // 次数最大の頂点\n    int ma = -1, i = -1;\n    for(int k=0; k<N; k++) {\n        if(!(bit >> k & 1)) continue;\n        if(deg[k] > ma) {\n            ma = deg[k];\n            i = k;\n        }\n    }\n\n    if(i >= 0) {\n        // その頂点を使う\n        nbit = bit ^ (1LL << i); tmp = cost[i];\n        vector<int> diff;\n        for(auto v : G[i]) {\n            if(nbit >> v & 1) {\n                nbit ^= (1LL << v);\n                for(auto to : G[v]) {\n                    deg[to]--;\n                    diff.push_back(to);\n                }\n            }\n        }\n\n        // 孤立している頂点\n        for(int k=0; k<N; k++) {\n            if(deg[k] == 0 && nbit >> k & 1) {\n                tmp += cost[k];\n                nbit ^= (1LL << k);\n            }\n        }\n\n        tmp += solve(G, cost, deg, nbit);\n        ret = max(ret, tmp);\n\n        // 次数を元にもどす\n        for(auto v : diff) deg[v]++;\n\n        // 使わない\n        nbit = bit ^ (1LL << i), tmp = 0;\n\n        for(auto v : G[i]) deg[v]--;\n        for(int k=0; k<N; k++) {\n            if(deg[k] == 0 && nbit >> k & 1) {\n                tmp += cost[k];\n                nbit ^= (1LL << k);\n            }\n        }\n\n        tmp += solve(G, cost, deg, nbit);\n        ret = max(ret, tmp);\n\n        for(auto v : G[i]) deg[v]++;\n    }\n\n    // printf(\"bit = %s, ret = %d\\n\", to_binString(bit, N).c_str(), ret);\n    return checked[bit] = ret;\n}\n\nint main() {\n    while(cin >> N, N) {\n        checked.clear();\n        map<string, int> mp;\n\n        string root = \"\";\n        vector<string> adj[50], name(N);\n        vector<int> tmp(N), cost(N);\n        for(int i=0; i<N; i++) {\n            cin >> name[i];\n            if(i == 0) {\n                root = name[i];\n            }\n\n            mp[ name[i] ]++;\n            cin >> tmp[i];\n\n            int x; cin >> x;\n            for(int k=0; k<x; k++) {\n                string s; cin >> s;\n                mp[s]++;\n                adj[i].push_back(s);\n            }\n        }\n\n        int id = 0;\n        for(auto &x : mp) {\n            x.second = id++;\n        }\n\n        Graph G(N);\n        vector<int> deg(N);\n        for(int i=0; i<N; i++) {\n            int u = mp[ name[i] ];\n            cost[u] = tmp[i];\n            for(auto s : adj[i]) {\n                int v = mp[s];\n                G[u].push_back(v);\n                G[v].push_back(u);\n                deg[u]++; deg[v]++;\n            }\n        }\n\n        long long int bit = (1LL << N) - 1;\n        int root_v = mp[root], isolate = cost[root_v];\n\n        // root_v に隣接する頂点\n        bit ^= (1LL << root_v);\n        for(auto v : G[root_v]) {\n            if(bit >> v & 1) {\n                bit ^= (1LL << v);\n                for(auto to : G[v]) {\n                    deg[to]--;\n                }\n            }\n        }\n\n        // 孤立している頂点\n        for(int i=0; i<N; i++) {\n            if(deg[i] == 0 && bit >> i & 1) {\n                isolate += cost[i];\n                bit ^= (1LL << i);\n            }\n        }\n\n        cout << isolate + solve(G, cost, deg, bit) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,int>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\nmap<string ,int> ma;\nint po[50];\nbool ok[1<<20]={0};\nint an[1<<20]={0};\nint dp[1<<20]={0};\nbool miok[1<<20]={0};\nint dp2[1<<20]={0};\nint hi,mi;\nvector<int> G[50];\nvector<pa> e1,e2,e3;\nint ichi[50]={0};\n\n\nvoid shoki(int r){\n\te1.clear();\n\te2.clear();\n\te3.clear();\n\tma.clear();\n\tfor(int i=0;i<50;i++){\n\t\tpo[i]=0;\n\t\tG[i].clear();\n\t\tichi[i]=0;\n\t}\n\t\n\tfor(int i=0;i<(1<<r);i++){\n\t\t\n\t\t\n\t\tdp[i]=0;\n\t\t\n\t\tdp2[i]=0;\n\t}\n\t\n}\n\nvoid makeok(){\n\tfor(int i=0;i<(1<<hi);i++)ok[i]=true;\n\t\n\tfor(auto t:e1){\n\t\tok[(1<<t.second)+(1<<t.first)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<hi);i++){\n\t\tbool b=ok[i];\n\t\tif(b==false) continue;\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(ok[i-(1<<j)]==false){\n\t\t\t\tb=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tok[i]=b;\n\t}\n\treturn;\n\t\n}\nvoid makean(){\n\tfor(int i=0;i<(1<<hi);i++)an[i]=(1<<(mi))-1;\n\t\n\tfor(auto t:e3){\n\t\tan[(1<<t.first)]^= (1<<(t.second-hi));\n\t}\n\t\n\tfor(int i=0;i<(1<<hi);i++){\n\t\t\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tan[i]=an[1<<j]&an[i-(1<<j)];\n\t\t}\n\t}\n\t\n}\n\nvoid makedp(){\n\tfor(int i=0;i<(1<<mi);i++)miok[i]=true;\n\t\n\tfor(auto t:e2){\n\t\n\t\tmiok[(1<<t.first)+(1<<t.second)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<mi);i++){\n\t\tbool b=miok[i];\n\t\tif(!b) continue;\n\t\tmiok[i]=true;\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(miok[i-(1<<j)]==false){\n\t\t\t\tmiok[i]=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<mi);i++)if(miok[i]){\n\t\tint cnt=0;\n\t\tdp[i]=0;\n\t\tfor(int  j=0;j<mi;j++)if(i&(1<<j)){\n\t\t\tdp[i]=dp[i-(1<<j)]+po[hi+j];\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tfor(int i=0;i<(1<<mi);i++)if(!miok[i]){\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tdp[i]=max(dp[i],dp[i-(1<<j)]);\n\t\t}\n\t\t\n\t}\n}\n\n\n\n         signed main(){\nint n;\n         \twhile(1){\n         \tcin>>n;\n         \t\tif(n==0) return 0;\n         \t\t\n         \t\tshoki((n+1)/2);\n         \tint count1=0;\n         \tfor(int i=0;i<n;i++){\n         \t\tstring s1,s2;\n         \t\tcin>>s1;\n         \t\tif(ma.find(s1)==ma.end()){\n         \t\t\tma[s1]=count1;\n         \t\t\tcount1++;\n         \t\t}\n         \t\tint r3,r4;\n         \t\tcin>>r3>>r4;\n         \t\tpo[ma[s1]]=r3;\n         \t\tfor(int j=0;j<r4;j++){\n         \t\t\tcin>>s2;\n         \t\t\tif(ma.find(s2)==ma.end()){\n         \t\t\t\tma[s2]=count1;\n         \t\t\t\tcount1++;\n         \t\t\t}\n         \t\t\tG[ma[s1]].pb(ma[s2]);\n         \t\t}\n         \t}\n         \t\n         \tint n1=n/2;\n         \thi=n1,mi=n-n1;\n         \tfor(int i=0;i<G[0].size();i++)ichi[G[0][i]]=1;\n         \t//for(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j])cout<<i<<\" \"<<G[i][j]<<endl;\n         \tfor(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j]){\n         \n         \t\n         \t\tif(G[i][j]<hi) e1.pb(mp(i,G[i][j]));\n         \t\telse if(i<hi) e3.pb(mp(i,G[i][j]));\n         \t\telse {\n         \t\t\te2.pb(mp(i-hi,G[i][j]-hi));\n         \t\t}\n         \t}\n         \t\n         \t\n         //\tfor(int i=0;i<n;i++)cout<<po[i]<<endl;\n    \tmakeok();\n         \t\t\n    \tmakean();\n         \t\n    \tmakedp();\n    \t int ans=0;\n \t\t for(int i=0;i<(1<<hi);i++)if(ok[i]){\n    \t\n \t\t \tfor(int j=0;j<hi;j++)if(i&(1<<j)){\n \t\t \t\t\n \t\t \t\tdp2[i]=dp2[i-(1<<j)]+po[j];\n \t\t \t\tbreak;\n \t\t \t}\n \t\t \tif(i&1)ans=max(ans,dp2[i]+dp[an[i]]);\n    \t}\n         \t\t/*\n         \tint ans=-1;\n          for(int i=0;i<(1<<hi);i++)if(ok[i])if(i&1){\n          \n    \t\tfor(int j=0;j<hi;j++)if(i&(1<<j))dp2[i]=max(dp2[i],dp2[i-(1<<j)]);\n    \t\t\n    \t\tans=max(ans,dp2[i]+dp[an[i]]);\n    \t\t}\n         \t\t*/\n       \n    \tcout<<ans<<endl;\n         }\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <string>\n#define inf 1e9\n\nusing namespace std;\ntypedef pair<int, int> P;\n\nint n;\nmap<string, int> mp;\nint w[45];\nvector<string> adj[45];\nvector<int> G[45];\nvector<P> vec, vec2;\nint mask[45];\nint dp[1<<20], dp2[1<<20];\n\nvoid make(int p, int sel, int sum, int b, int n, vector<P> &vec)\n{\n\tif(p >= b+n){\n\t\tvec.push_back(make_pair(sel, sum));\n\t\treturn;\n\t}\n\tmake(p+1, sel, sum, b, n, vec);\n\tif(mask[p] & sel) return;\n\tmake(p+1, sel | (1<<(p-b)), sum + w[p], b, n, vec);\n}\n\nint main(void)\n{\n\twhile(1){\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\tfor(int i = 0; i < n; i++) adj[i].clear();\n\t\tmp.clear();\n\t\t\n\t\tstring s; int c;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcin >> s >> w[i] >> c;\n\t\t\tmp[s] = i;\n\t\t\tfor(int j = 0; j < c; j++){\n\t\t\t\tcin >> s;\n\t\t\t\tadj[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tG[i].clear();\n\t\t\tfor(int j = 0; j < adj[i].size(); j++){\n\t\t\t\tG[i].push_back(mp[adj[i][j]]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(n == 1){\n\t\t\tcout << w[0] << endl;\n\t\t\tcontinue;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < n/2; i++){\n\t\t\tmask[i] = 0;\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tint v = G[i][j];\n\t\t\t\tif(v >= 0 && v < n/2) mask[i] |= 1<<v;\n\t\t\t}\n\t\t}\n\t\tfor(int i = n/2; i < n; i++){\n\t\t\tmask[i] = 0;\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tint v = G[i][j];\n\t\t\t\tif(v >= n/2 && v < n) mask[i] |= 1<<(v-n/2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tvec.clear(), make(0, 0, 0, 0, n/2, vec);\n\t\tvec2.clear(), make(n/2, 0, 0, n/2, n-n/2, vec2);\n\t\t\n\t\t//for(int i = 0; i < vec.size(); i++) cout << vec[i].first << \" \" << vec[i].second << endl;\n\t\t\n\t\tint S = 1<<(n/2);\n\t\tfor(int i = 0; i < S; i++) dp[i] = -inf;\n\t\tfor(int i = 0; i < vec.size(); i++){\n\t\t\tif((vec[i].first & 1) == 0) continue;\n\t\t\tdp[vec[i].first] = vec[i].second;\n\t\t}\n\t\tint S2 = 1<<(n-n/2);\n\t\tfor(int i = 0; i < S2; i++) dp2[i] = -inf;\n\t\tfor(int i = 0; i < vec2.size(); i++) dp2[vec2[i].first] = vec2[i].second;\n\t\tfor(int i = 0; i < S2; i++){\n\t\t\tfor(int j = 0; j < n-n/2; j++){\n\t\t\t\tif(i & (1<<j)) dp2[i] = max(dp2[i], dp2[i & ~(1<<j)]);\n\t\t\t}\n\t\t}\n\t\t\n\t\t//for(int i = 0; i < S2; i++) cout << dp2[i] << \" \"; cout << endl;\n\t\t\n\t\tint adj2[25];\n\t\tfor(int i = 0; i < n/2; i++){\n\t\t\tadj2[i] = 0;\n\t\t\tfor(int j = 0; j < G[i].size(); j++){\n\t\t\t\tint v = G[i][j];\n\t\t\t\tif(v >= n/2 && v < n) adj2[i] |= 1<<(v-n/2);\n\t\t\t}\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < S; i++){\n\t\t\tif(dp[i] < 0) continue;\n\t\t\tint mask = 0;\n\t\t\tfor(int j = 0; j < n/2; j++) if((i & (1<<j))) mask |= adj2[j];\n\t\t\tans = max(ans, dp[i] + dp2[(S2-1)-mask]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n;\nint main(){\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs name(n);\n\t\tvi b(n),co(n);\n\t\tvector<vs>in(n);\n\t\trep(i,n){\n\t\t\tcin>>name[i]>>b[i]>>co[i];\n\t\t\tma[name[i]]=1;\n\t\t\tin[i]=vs(co[i]);\n\t\t\trep(j,co[i]){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tma[in[i][j]]=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\trep(i,n)ma[name[i]]=i;\n\t\n\t\tvector<ll>A(n);\n\t\trep(i,n)rep(j,in[i].size()){\n\t\t\tint from=ma[name[i]],to=ma[in[i][j]];\n\t\t\tA[from]|=1ll<<to;\n\t\t}\n\t\tint N=n/2,nN=n-N;\n\t\t\n//\t\trep(i,n){\n//\t\t\tcout<<name[i]<<\" \";\n//\t\t\trep(j,n)cout<<((A[i]&1<<j)>>j)<<\" \";cout<<endl;\n//\t\t}\n\t\tvi dp(1<<nN);\n\t\trep(i,1<<nN){\n\t\t\tbool h=true;\n\t\t\trep(j,nN)if((i&1<<j)&&((i&A[j+N]>>N)))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,nN)if(i&1<<j)sum+=b[N+j];\n\t\t\t\tdp[i]=max(dp[i],sum);\n\t\t\t}\n\t\t\trep(j,nN)if((i&1<<j)==0)\n\t\t\t\tdp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n\t\t}\n\t\t\n\t\tint out=0;\n\t\trep(i,1<<N)if(i&1){\n\t\t\tbool h=true;\n\t\t\tint sum=0;\n\t\t\trep(j,N)if((i&1<<j)){\n\t\t\t\tsum+=b[j];\n\t\t\t\tif(i&A[j])h=false;\n\t\t\t}\n\t\t\tif(h){\n\t\t\t\tt=(1<<nN)-1;\n\t\t\t\trep(j,N)if((i&1<<j))t&=~(A[j]>>N);\n\t\t\t\tout=max(out,sum+dp[t]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n/*\nint n,m;\nvi A,B;\nint dp[52][52][110][2][3];\nint mem[52][52][110][2][3];\nint f(int a,int b,int co,int tu,int pas){\n    if(mem[a][b][co][tu][pas]+inf)return mem[a][b][co][tu][pas];\n\tif(pas==3)\n\t\n    int A,B,TU=(tu+co)%2;\n    if(!tu)A=a+(1+co)/2,B=b+co/2;\n    else A=a+co/2,B=b+(1+co)/2;\n    if(TU==0){\n        int ma=-inf;\n        if(A<n)ma=max(ma,f(a,b,co+1,tu,0));\n        if(co)ma=max(ma,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else if(a+b+co)ma=max(ma,0);\n        cout<<\" \"<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<ma<<\" \"<<dp[a][b][co][tu]<<endl;\n        return mem[a][b][co][tu]=ma;\n    }else{\n        int mi=inf;\n        if(B<m)mi=min(mi,f(a,b,co+1,tu,0));\n        if(co)mi=min(mi,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else mi=min(mi,0);\n        cout<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<mi<<endl;\n        return mem[a][b][co][tu]=mi;\n    }\n}\nint main(){\n    cin>>n>>m;\n    A=vi(n);rep(i,n)cin>>A[i];\n    B=vi(m);rep(i,m)cin>>B[i];\n     \n    rep(l,2)rep(i,n+1)rep(j,m+1){\n        int sum=0;\n        int L=l,I=i,J=j;\n        int co=0;\n        while(1){\n            dp[i][j][co][l]=sum;\n            if(L&&J>=m||!L&&I>=n)break;\n            if(L){\n                if(B[J]+1)sum-=B[J];\n                else sum=0;\n                J++;\n            }else{\n                if(A[I]+1)sum+=A[I];\n                else sum=0;\n                I++;\n            }\n            L^=1;\n            co++;\n        }\n    }   \n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][0];cout<<endl;}\n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][1];cout<<endl;}\n    rep(i,52)rep(j,52)rep(k,110)rep(l,2)rep(q,3)\n        mem[i][j][k][l][q]=-inf;\n    cout<<f(0,0,0,0,1)<<endl;\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\tif (used[names[pos].first])continue;\n\t\trest -= names[pos].second;\n\t\tvector<string> c;\n\t\tint rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\trest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\trest = rest1;\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tbmap.clear();\n\t\tans = 0;\n\t\tmb = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\t//vector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\t//list.push_back(a);\n\t\t\t\tbuf[name].push_back(a);\n\t\t\t\tbuf[a].push_back(name);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second,mb-names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<ll> power;\nvector<bool> de;\n\nvoid preorder(ll p,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tused[p]=true;\n\tpreo.pb(p);\n\tbool upd=false;\n\tREP(i,(ll)adj[p].size()) if(!used[adj[p][i]]) {\n\t\tupd=true;\n\t\tpreorder(adj[p][i],used,preo,adj);\n\t}\n\tde[p]=!upd;\n}\n\nvoid input(vector<vector<ll>>& adj) {\n\tmap<string,ll> dict;\n\tll cnt=0;\n\tREP(i,n) {\n\t\tstring a;\n\t\tll b,c;\n\t\tcin>>a>>b>>c;\n\t\tif(dict.count(a)==0) {\n\t\t\tdict[a]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p=dict[a];\n\t\tpower[dict[a]]=b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(dict.count(t)==0) {\n\t\t\t\tdict[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tadj[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx,vector<int>& used,vector<ll>& preo,vector<vector<ll>>& adj,ll sum) {\n\tif(idx==(ll)preo.size()) {\n\t\treturn sum;\n\t}\n\tif(used[preo[idx]]==0) return dfs(idx+1,used,preo,adj,sum);\n\tll ret=0;\n\tif(preo[idx]!=0&&!de[preo[idx]]) {\n\t\tused[preo[idx]]=0;\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum));\n\t}\n\tused[preo[idx]]=1;\n\tvector<bool> buf(n);\n\tREP(i,(ll)adj[preo[idx]].size()) {\n\t\tbuf[adj[preo[idx]][i]]=used[adj[preo[idx]][i]];\n\t\tused[adj[preo[idx]][i]]=0;\n\t}\n\tret=max(ret,dfs(idx+1,used,preo,adj,sum+power[preo[idx]]));\n\tREP(i,(ll)adj[preo[idx]].size()) {\n\t\tused[adj[preo[idx]][i]]=buf[adj[preo[idx]][i]];\n\t}\n\tused[preo[idx]]=-1;\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tde.resize(n);\n\tvector<vector<ll>> adj(n);\n\tinput(adj);\n\tvector<bool> used(n,false);\n\tvector<vector<ll>> preo;\n\tREP(i,n) if(!used[i]) {\n\t\tvector<ll> v;\n\t\tpreorder(i,used,v,adj);\n\t\tpreo.pb(v);\n\t}\n\tvector<int> used2(n,-1);\n\tll ans=0;\n\tll x=0;\n\tREP(i,preo.size()) ans+=dfs(0,used2,preo[i],adj,x);\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nint ans = 0;\nvector<int>powers;\nint restp[41];\nbool check(const vector<vector<int>>&tonari,const vector<bool>&oks, const int next, int pow) {\n\tfor (int c = next; c < powers.size(); ++c) {\n\t\tif (oks[c]) {\n\t\t\tpow += powers[c];\n\t\t}\n\t}\n\treturn pow > ans;\n}\nint getans(const vector<vector<int>>&tonari,vector<bool>oks,const int next,const int pow) {\n\tif (!check(tonari,oks,next,pow))return pow;\n\telse {\n\t\tif (next == powers.size())return pow;\n\t\tint nans = 0;\n\t\tif(oks[next]){\n\t\t\tvector<bool>noks(oks);\n\t\t\tfor (int c = next + 1; c < powers.size(); ++c) {\n\t\t\t\tif (tonari[next][c])noks[c] = false;\n\t\t\t}\n\t\t\tnans = max(nans, getans(tonari,noks, next + 1, pow + powers[next]));\n\t\t}\n\t\tnans = max(nans,getans(tonari, oks, next + 1, pow));\n\t\tans = max(ans, nans);\n\t\treturn nans;\n\t}\n\n}\n\nstruct country {\n\n};\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tans = 0;\n\t\tmemset(restp, 0, sizeof(restp));\n\t\tpowers.clear();\n\t\tif (!N)break;\n\t\tvector<string>names;\n\t\tvector<vector<string>>rins(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring a; int  b, c; cin >> a >> b >> c;\n\t\t\tnames.push_back(a);\n\t\t\tpowers.push_back(b);\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\trins[i].push_back(st);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>tonari(N, vector<int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto n : rins[i]) {\n\t\t\t\tint r = find(names.begin(), names.end(), n) - names.begin();\n\t\t\t\ttonari[i][r] = true;\n\t\t\t}\n\t\t}\n\t\tvector<bool>oks(N,true);\n\t\tfor (int c = 1; c < powers.size(); ++c) {\n\t\t\tif (tonari[0][c])oks[c] = false;\n\t\t}\n\t\tfor (int c = 0; c < N; ++c) {\n\t\t\trestp[c] = accumulate(powers.begin() + c, powers.end(), 0);\n\t\t}\n\t\tint ans = getans(tonari, oks, 1, powers[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if(ne & (1LL<<i) != 0) continue;\n        if(((ne | cs[i].ne) ^ (ne | (1<<i))) < 1LL){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n\n    queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.front().second.second;\n        power = pq.front().second.first;\n        int v = pq.front().first + 1;\n        pq.pop();\n        res = max(res, power);\n        if(v > n - 1) continue;\n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        \n        \n        ll nne = ne;\n        int npower = power;\n        for(int i = v + 1; i < n; i++){\n            if((nne & (1LL<<i)) != 0) continue;\n            if(((nne | cs[i].ne) ^ (nne | (1<<i))) < (1LL<<v)){\n                nne |= cs[i].ne;\n                npower += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(npower, nne)));\n        \n        \n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if(((ne | cs[i].ne) ^ (ne | (1LL<<i))) < (1LL<<v)){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<vector<ll>> g;\nvector<ll> power;\nvector<ll> used;\nvector<P> ord;\n\nvoid build_graph() {\n\tmap<string,ll> dict;\n\tll cnt = 0;\n\tREP(i,n) {\n\t\tstring a; ll b, c;\n\t\tcin >> a >> b >> c;\n\t\tif(dict.count(a) == 0) {\n\t\t\tdict[a] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p = dict[a];\n\t\tpower[dict[a]] = b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tif(dict.count(t) == 0) {\n\t\t\t\tdict[t] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tg[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx, ll sum) {\n\tif(idx == n) return sum;\n\tif(used[ord[idx].second] != -1) return dfs(idx + 1, sum);\n\tll ret = 0;\n\tvector<ll> tmp(n);\n\tREP(i,n) tmp[i] = used[i];\n\tif((ll)g[ord[idx].second].size() > 1) {\n\t\tused[ord[idx].second] = 0;\n\t\tret = max(ret, dfs(idx + 1, sum));\n\t}\n\tused[ord[idx].second] = 1;\n\tREP(i,g[ord[idx].second].size()) used[g[ord[idx].second][i]] = 0;\n\tret = max(ret, dfs(idx + 1, sum + power[ord[idx].second]));\n\tREP(i,n) used[i] = tmp[i];\n\treturn ret;\n}\n\nll solve() {\n\tpower.assign(n,0);\n\tused.assign(n, -1);\n\tord.assign(n,P(-1,-1));\n\tg.assign(n,vector<ll>(0)); build_graph();\n\tll sum = 0;\n\tREP(i,n) if(used[i] == -1) {\n\t\tif(i == 0) {\n\t\t\tused[i] = 1;\n\t\t\tREP(j,g[i].size()) used[g[i][j]] = 0;\n\t\t\tsum += power[i];\n\t\t\tcontinue;\t\n\t\t}\n\t\tif(g[i].size() == 0) {\n\t\t\tused[i] = 1;\n\t\t\tsum += power[i];\n\t\t}\n\t\tif(g[i].size() == 1 && g[g[i][0]].size() == 1) {\n\t\t\tif(power[i] >= power[g[i][0]]) {\n\t\t\t\tused[i] = 1; used[g[i][0]] = 0;\n\t\t\t\tsum += power[i];\n\t\t\t} else {\n\t\t\t\tused[i] = 0; used[g[i][0]] = 1;\n\t\t\t\tsum += power[g[i][0]];\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n) {\n\t\tord[i].first = (ll)g[i].size();\n\t\tord[i].second = i;\n\t}\n\tsort(ALL(ord)); reverse(ALL(ord));\n\treturn dfs(0, sum);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tint N;\n\tvector<int> ps;\n\tvector<vector<int>> es;\n\tvector<bool> selected;\n\tvector<bool> canselect;\n\tvector<int> fillc;\n\n\tint Mv;\t\n\tint must;\n\n\tvector<bool> change;\n\tvoid dfs(int v,int val){\n\t\t//DUMP(v);\n\t\tMv=max(Mv,val);\n\t\tif(v>=N)return;\n\t\tif(val+fillc[v]<=Mv)return;\n\t\tif(canselect[v]){\n\t\t\tvector<int> change;\n\t\t\tselect(v,change);\n\t\t\tdfs(v+1,val+ps[v]);\n\t\t\tunselect(v,change);\n\t\t\tif(!checkuse(v))//必ず使う方がいい\n\t\t\t\tdfs(v+1,val);\n\t\t}else{\n\t\t\tdfs(v+1,val);\n\t\t}\n\t}\n\n\tbool checkuse(int v){\n\t\t//if(selected[v])return false;//0\n\t\tREP(i,es[v].size())if(es[v][i]>v)return false;\n\t\treturn true;\n\t}\n\n\tvoid select(int v,vector<int>& change){\n\t\tselected[v]=true;canselect[v]=false;\n\t\tREP(i,es[v].size()){\n\t\t\tif(canselect[es[v][i]]){\n\t\t\t\tcanselect[es[v][i]]=false;\n\t\t\t\tchange.push_back(es[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid unselect(int v,vector<int>& change){\n\t\tselected[v]=false;canselect[v]=true;\n\t\tREP(i,change.size())canselect[change[i]]=true;\n\t}\n\n\tvoid run(){\n\t\t//ifstream fin(\"in\" );\n\t\t//ofstream fout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >>N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> cs(N);\n\t\t\tmap<string,int> stoid;\n\t\t\tps=vector<int>(N);\n\t\t\tvector<vector<string>> ess(N);\n\t\t\tREP(i,N){\n\t\t\t\tcin >> cs[i] >> ps[i];stoid.insert(make_pair(cs[i],i));\n\t\t\t\t\n\t\t\t\tint k;cin >>k;\n\t\t\t\tREP(j,k) {\n\t\t\t\t\tstring s;cin >> s;ess[i].push_back(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tes=vector<vector<int>>(N);\n\t\t\tREP(i,N)REP(j,ess[i].size())es[i].push_back(stoid[ess[i][j]]);\n\t\t\n\t\t\tcanselect=vector<bool>(N,true);\n\t\t\tselected=vector<bool>(N);\n\t\t\tfillc=vector<int>(N+1);\n\t\t\tfor(int i=N-1;i>=0;i--)fillc[i]+=fillc[i+1]+ps[i];\n\n\t\t\t//自分\n\t\t\tvector<int> dummy;\n\t\t\tmust=ps[0];select(0,dummy);\n\t\t\t//孤立点\n\t\t\tREP(i,N)if(canselect[i] && es[i].size()==0){must+=ps[i];select(i,dummy);}\n\t\t\t\n\t\t\tMv=must;\n\t\t\tdfs(0,must);\n\n\t\t\tcout<< Mv<<endl;\n\t\t}\n\t}\n};\n int main(){\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<vector<int>,int> P2;\ntypedef pair<P,P2> P3;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<vector<int> > memo;\n\nqueue<P3> q;\n\nvoid bfs(){\n\n  vector<int> s;\n  \n  q.push(P3(P(0,0),P2(s,0)));\n\n  while(!q.empty()){\n\n    P3 t=q.front(); q.pop();\n\n    int idx=t.second.second;\n    vector<int> S=t.second.first;\n    int x=t.first.first;\n    int sum=t.first.second;\n    \n    for(int i=idx;i<n;i++){\n    \n      if(!x&&i) continue;\n    \n      int f=0;\n    \n      for(int j=0;j<S.size();j++)\n\tif(G[S[j]][i]) f=1;\n    \n      if(!f){\n      \n\tvector<int> nS=S;\n      \n\tnS.push_back(i);\n      \n\tsort(nS.begin(),nS.end());\n      \n\tif(memo.count(nS)) continue;\n  \n\tmemo.insert(nS);\n      \n\tans=max(ans,sum+cost[i]);\n\t\n\tq.push(P3(P(x+1,sum+cost[i]),P2(nS,i+1)));\n      }\n    \n    }\n  }\n}\n\nvoid dfs(int x,int sum,vector<int> S,int idx){\n  \n  for(int i=idx;i<n;i++){\n    \n    if(!x&&i) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<S.size();j++)\n      if(G[S[j]][i]) f=1;\n    \n    if(!f){\n      \n      vector<int> nS=S;\n      \n      nS.push_back(i);\n      \n      sort(nS.begin(),nS.end());\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[i]);\n\t\n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=0;\n\n    //    vector<int> S;\n    \n    //dfs(0,0,S,0);\n    bfs();\n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint r[64], p[64];\nInt f[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nvoid prepare(vector<int>& q) {\n    const int n = q.size();\n    vector<pair<int, int> > ps;\n    rep (i, q.size()) ps.push_back(mp(C[q[i]], q[i]));\n    sort(ps.begin(), ps.end());\n    rep (i, n) r[i] = ps[n-1-i].second;\n    rep (i, n) p[i] = B[r[i]];\n    rep (i, n) {\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nint rec(int n, int k, Int u) {\n    if (k == n) return 0;\n    rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return -INF;\n    int ans = -INF;\n    if (u&(1LL<<k)) ans = max(ans, rec(n, k+1, u&((1LL<<n)-1-f[k])) + p[k]);\n    if (r[k]) ans = max(ans, rec(n, k+1, u));\n    return ans;\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        ans += rec(q.size(), 0, (1LL<<q.size())-1);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ALL(v) std::begin(v), std::end(v)\n#define ALLR(v) std::rbegin(v), std::rend(v)\nusing ll = std::int64_t;\nusing ull = std::uint64_t;\nusing pii = std::pair<int, int>;\nusing tii = std::tuple<int, int, int>;\nusing pll = std::pair<ll, ll>;\nusing tll = std::tuple<ll, ll, ll>;\ntemplate <typename T> using vec = std::vector<T>;\ntemplate <typename T> using vvec = vec<vec<T>>;\ntemplate <typename T> const T& var_min(const T &t) { return t; }\ntemplate <typename T> const T& var_max(const T &t) { return t; }\ntemplate <typename T, typename... Tail> const T& var_min(const T &t, const Tail&... tail) { return std::min(t, var_min(tail...)); }\ntemplate <typename T, typename... Tail> const T& var_max(const T &t, const Tail&... tail) { return std::max(t, var_max(tail...)); }\ntemplate <typename T, typename... Tail> void chmin(T &t, const Tail&... tail) { t = var_min(t, tail...); }\ntemplate <typename T, typename... Tail> void chmax(T &t, const Tail&... tail) { t = var_max(t, tail...); }\ntemplate <typename T> const T& clamp(const T &t, const T &low, const T &high) { return std::max(low, std::min(high, t)); }\ntemplate <typename T> void chclamp(T &t, const T &low, const T &high) { return t = clamp(t, low, high); }\ntemplate <typename T> T make_v(T init) { return init; }\ntemplate <typename T, typename... Tail> auto make_v(T init, std::size_t s, Tail... tail) { auto v = std::move(make_v(init, tail...)); return vec<decltype(v)>(s, v); }\ntemplate <typename T, std::size_t Head, std::size_t ...Tail> struct multi_dem_array { using type = std::array<typename multi_dem_array<T, Tail...>::type, Head>; };\ntemplate <typename T, std::size_t Head> struct multi_dem_array<T, Head> { using type = std::array<T, Head>; };\ntemplate <typename T, std::size_t ...Args> using mdarray = typename multi_dem_array<T, Args...>::type;\nnamespace init__ { struct InitIO { InitIO() { std::cin.tie(nullptr); std::ios_base::sync_with_stdio(false); std::cout << std::fixed << std::setprecision(30); } } init_io; }\n\nnamespace graph {\n\nusing Node = ll;\nusing Weight = ll;\nusing Edge = std::pair<Node, Weight>;\n\ntemplate <bool Directed>\nstruct Graph : public vvec<Edge> {\n    using vvec<Edge>::vvec;\n\n    void add_edge(Node f, Node t, Weight w = 1) {\n        (*this)[f].emplace_back(t, w);\n        if (!Directed) (*this)[t].emplace_back(f, w);\n    }\n\n    Graph<Directed> build_inv() const {\n        Graph<Directed> ret(this->size());\n        for (Node i = 0; i < this->size(); i++) {\n            for (const Edge &e : (*this)[i]) {\n                Node j;\n                Weight w;\n                std::tie(j, w) = e;\n                if (!Directed && j < i) continue;\n                ret.add_edge(j, i, w);\n            }\n        }\n\n        return ret;\n    }\n};\n\n}\n\nconstexpr static std::size_t half = (40 + 1) / 2;\nconstexpr static std::size_t hsz = (1ll << half);\nstd::array<ll, hsz> halfg;\nvec<ll> pows;\n\nnamespace graph {\n\ntemplate <std::size_t Size>\nclass IndependentSet {\n    vvec<ll> dp;\n    const std::size_t gsz;\n    std::array<ll, Size> bs_graph;\n\n    void build_neigh(std::array<ll, hsz> &gr, std::size_t sz) {\n        for (ll i = 0; i < sz; i++) {\n            ll mask = 1ll << i;\n            for (ll s = 0; s < (1ll << sz); s++) if (s & mask) gr[s] |= gr[s ^ mask];\n        }\n    }\n\n    void calc_sz(vec<ll> &sz_v, std::array<ll, hsz> &gr, std::size_t sz, int offset) {\n        std::fill(ALL(sz_v), 0);\n        build_neigh(gr, sz);\n        for (ll s = 0; s < sz_v.size(); s++) {\n            ll e = gr[s];\n            if (s & e) continue;\n            for (int i = 0; i < sz; i++) if (s & (1ll << i)) sz_v[s] += pows[offset + i];\n        }\n        for (ll i = 0; i < sz; i++) {\n            ll mask = 1ll << i;\n            for (ll s = 0; s < (1ll << sz); s++) if (s & mask) chmax(sz_v[s], sz_v[s ^ mask]);\n        }\n    }\n\n    void extract_graph(std::array<ll, hsz> &arr, ll l, ll r, ll tl, ll tr) {\n        std::fill(ALL(arr), 0);\n        std::size_t s = tr - tl;\n        ll mask = (1ll << s) - 1;\n        for (ll i = 0; i < r - l; i++) arr[1ll << i] = (bs_graph[i + l] >> tl) & mask;\n    }\n\npublic:\n    template <bool Dir>\n    IndependentSet(const graph::Graph<Dir> &g) : gsz(g.size()), dp(2) {\n        std::fill(ALL(bs_graph), 0);\n        for (ll i = 0; i < gsz; i++) for (auto &&e : g[i]) {\n            ll nxt = e.first;\n            bs_graph[i] |= (1ll << nxt);\n        }\n    }\n\n    ll solve() {\n        ll left = 0, mid = gsz / 2, right = gsz;\n        pii ranges[] = { { left, mid, }, { mid, right, } };\n\n        for (ll i = 0; i < 2; i++) {\n            ll l, r;\n            std::tie(l, r) = ranges[i];\n\n            std::size_t sz = r - l;\n            dp[i].resize(1ll << sz);\n            extract_graph(halfg, l, r, l, r);\n            calc_sz(dp[i], halfg, sz, l);\n        }\n\n        extract_graph(halfg, left, mid, mid, right);\n        build_neigh(halfg, mid - left);\n        ll mask = 1ll << (right - mid);\n        for (ll i = 0; i < (1ll << (mid - left)); i++) {\n            ll &e = halfg[i];\n            e = (~e) & (mask - 1);\n        }\n\n        ll ret = 0;\n        for (ll i = 0; i < (1ll << (mid - left)); i++) {\n            ll j = halfg[i];\n            chmax(ret, dp[0][i] + dp[1][j]);\n        }\n\n        return ret;\n    }\n};\n\ntemplate <bool Dir>\nll indep_set(const Graph<Dir> &gr) {\n    IndependentSet<40> iset(gr);\n    return iset.solve();\n}\n\n}\n\nbool solve() {\n    ll n;\n    std::cin >> n;\n    if (!n) return false;\n\n    std::map<std::string, ll> id_mp;\n    auto get_id = [&](const std::string &s) {\n        auto ite = id_mp.find(s);\n        if (ite != id_mp.end()) return ite->second;\n        ll tmp = id_mp.size();\n        id_mp[s] = tmp;\n        return tmp;\n    };\n\n    pows = vec<ll>(n);\n    graph::Graph<true> g(n);\n    for (ll i = 0; i < n; i++) {\n        std::string a;\n        ll b, c;\n        std::cin >> a >> b >> c;\n        ll id = get_id(a);\n        pows[id] = b;\n        while (c--) {\n            std::string t;\n            std::cin >> t;\n            ll tid = get_id(t);\n            g.add_edge(id, tid);\n        }\n    }\n\n    for (auto &&e : g[0]) pows[e.first] = 0;\n    std::cout << graph::indep_set(g) << '\\n';\n    return true;\n}\n\nint main() {\n    while (solve());\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], ans;\n\nset<ll> memo;\n\nvoid dfs(ll S){\n\n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  int cnt=0, sum=0;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1LL<<i))) continue;\n\n    sum+=cost[i];\n    \n    for(int j=i+1;j<n;j++){\n      if(!(S&(1LL<<j))) continue;\n      if(!G[i][j]) cnt++;\n    }\n    \n  }\n  \n  if(sum<ans) return ;\n  \n  int node=__builtin_popcountll(S);\n\n  if(cnt==node*(node-1)/2){\n    \n    ans=max(ans,sum);\n    return ;\n  }\n\n  for(int i=0;i<n;i++){\n\n    if(!(S&(1LL<<i))) continue;\n\n    for(int j=i+1;j<n;j++){\n      \n      if(!(S&(1LL<<j))) continue;\n\n      if(G[i][j]) continue;\n      \n      dfs(S&~(1<<j));\n      \n      if(i) dfs(S&~(1<<i));\n      \n    }\n  }\n  \n}\n\nint main(){\n  \n  while(1)  {\n\n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cnt=0;\n\n    memset(G,0,sizeof(G));\n    \n    for(int i=0;i<n;i++){\n\n      string s;\n      cin>>s;\n\n      if(!num.count(s)) num[s]=cnt++;\n      \n      int a,b;\n      cin>>a>>b;\n      \n      cost[num[s]]=a;\n\n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n\n    ans=0;\n\n    memo.clear();\n    \n    dfs((1LL<<n)-1);\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], dig[64];\nint vis[64], use[64], conf[64];\nvector<pair<int, int> > que;\n\nvoid coll(int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    que.push_back(mp(dig[at], at));\n    rep (i, N) if (g[at][i]) coll(i);\n}\n\nint rec(int ix) {\n    if (ix == -1) return 0;\n    for (int i = ix+1; i < (int)que.size(); i++) {\n        const int x = que[i].second;\n        if (use[x] == 0 && conf[x] == 0) {\n            bool some = false;\n            rep (j, ix+1) {\n                const int y = que[j].second;\n                if (g[x][y]) some = true;\n            }\n            if (some == false) return -INF;\n        }\n    }\n    const int at = que[ix].second;\n    int ans = -INF;\n    if (conf[at] == 0) {\n        rep (i, N) if (g[at][i]) conf[i]++;\n        use[at] = 1;\n        ans = max(ans, rec(ix-1) + B[at]);\n        rep (i, N) if (g[at][i]) conf[i]--;\n        use[at] = 0;\n    }\n    if (at != 0) ans = max(ans, rec(ix-1));\n    return ans;\n}\n\nint solve() {\n    rep (i, N) dig[i] = C[i];\n    memset(use, 0, sizeof(use));\n    memset(conf, 0, sizeof(conf));\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (vis[i] == 0) {\n        que.clear();\n        coll(i);\n        sort(que.begin(), que.end());\n        ans += rec(que.size()-1);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <math.h>\nusing namespace std;\n\nint Cc;\n\nchar Name[40][20];\nchar NearS[40][40][20];\nbool Near[40][40];\nunsigned long long int ally;\nint Power[40];\nint n, t;\nint Max_Power;\n\nvoid make_ally(unsigned long long int ally1, int name, int power){\n\tint i,j;\n\tunsigned long long int ally2;\n\tally2 = ally1;\n\tally2 += pow(2,name);\n\n\tpower += Power[name];\n\n\tfor(i=0;i<n;i++){\n\t\tif(Near[name][i]){\n\t\t\tif(!((ally2>>i)&1)) ally2 += pow(2,i);\n\t\t}\n\t}\n\n for(i=name;i<n;i++){\n\t\tif(!(ally2>>i)&1){\n\t\t\tfor(j=name;j<n;j++){\n\t\t\t\tif(!((ally2>>j)&1) && Near[j][i]) break;\n\t\t\t}\n\t\t\tif(j==n){\n\t\t\t\tif(!((ally2>>i)&1)) ally2 += pow(2,i);\n\t\t\t\tpower += Power[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif(power > Max_Power) Max_Power = power;\n\n//\tfor(i=0;i<n;i++) cout<<((ally2>>i)&1)<<\" : \";\n//cout << endl;\n\n\tfor(i=name;i<n;i++)\n\t\tif(!((ally2>>i)&1)) make_ally(ally2, i, power);\n\n\treturn;\n}\nint search(char *name){\n\tint i;\n\tfor(i=0;i<Cc;i++) if(!strcmp(name, Name[i])) return i;\n\tprintf(\"%s\\n\", name);\n\treturn 0;\n}\n\nint main(){\n\tint j, i;\n\twhile(cin >> n, n){\n\t\tmemset(Name, 0, sizeof(Name));\n\t\tmemset(Near, 0, sizeof(Near));\n\t\tmemset(NearS, 0, sizeof(NearS));\n\t\tmemset(Power, 0, sizeof(Power));\n\t\tally = 0;\n\t\tMax_Power=0;\n\n\t\tfor(Cc=0;Cc<n;Cc++){\n\t\t\tcin >> Name[Cc] >> Power[Cc] >> t;\n\n\t\t\tfor(i=0;i<t;i++) cin >> NearS[Cc][i];\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;NearS[i][j][0];j++){\n\t\t\t\tNear[i][search(NearS[i][j])] = 1;\n//\t\t\t\tprintf(\"%d-%d\\n\", i, search(NearS[i][j]));\n\t\t\t}\n\t\t}\n\t\tmake_ally(ally, 0, 0);\n\t\tcout<<Max_Power<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    Hmap<string, int> hm;\n    vector<string> A(n);\n    vector<ll> B(n);\n    vector<vector<string>> D(n);\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    auto calc = [&](vl& dp, int s, int e) {\n      int l = e - s;\n      rep(mask, 1 << l) {\n\trep(i, l) {\n\t  if(mask & (1<<i)) continue;\n\t  bool f = true;\n\t  for(const auto& str: D[i+s]) {\n\t    int t = hm[str];\n\t    if(s <= t && t < e) {\n\t      if(mask&(1<<(t - s))) f = false;\n\t    }\n\t  }\n\t  if(f) {\n\t    int nxt = mask | (1<<i);\n\t    dp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n\t  }\n\t}\n      }\n      rep(mask, 1<<l) {\n\trep(i, l) {\n\t  if(mask&(1<<i)) {\n\t    int pre = mask - (1<<i);\n\t    dp[mask] = max(dp[mask], dp[pre]);\n\t  }\n\t}\n      }\n    };\n\n    vector<vl> dp(2, vl(1<<20, 0));\n    calc(dp[0], 0, n/2);\n    calc(dp[1], n/2, n);\n\n    int len = n - (n/2);\n    vector<int> masks(1<<(n/2), (1<<len)-1);\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tfor(const auto& str : D[i]) {\n\t  int t = hm[str] - n / 2;\n\t  if(t < 0) continue;\n\t  if(masks[mask] & (1<<t)) masks[mask] -= (1<<t);\n\t}\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp[0][mask] + dp[1][masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n//\nint64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\tif(i+1==n)tmp = power+kuni[i].power;\n\t\t\telse\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp)max = tmp;\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);//次数でソート\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#pragma GCC optimize(\"unroll-loops\")\n#pragma GCC push_options\n#pragma GCC target(\"sse,sse2,sse3,ssse3,sse4,popcnt,abm,mmx,avx\")\n#include<bits/stdc++.h>\n#include <xmmintrin.h>\n#include <immintrin.h>\nusing namespace::std;\n__attribute__((constructor))void init(){cin.tie(0);ios::sync_with_stdio(false);cout<<fixed<<setprecision(15);}\n#include<ext/pb_ds/assoc_container.hpp>\n#include<ext/pb_ds/tree_policy.hpp>\n#include <ext/pb_ds/priority_queue.hpp>\n#include<ext/pb_ds/tag_and_trait.hpp>\n// #include <boost/multiprecision/cpp_dec_float.hpp>\n// #include <boost/multiprecision/cpp_int.hpp>\n// namespace mp = boost::multiprecision;\n// typedef mp::number<mp::cpp_dec_float<0>> cdouble;\n// typedef mp::cpp_int cint;\ntemplate<typename T>using pbds=__gnu_pbds::tree<T,__gnu_pbds::null_type,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T>using pbds_map=__gnu_pbds::tree<T,T,less<T>,__gnu_pbds::rb_tree_tag,__gnu_pbds::tree_order_statistics_node_update>;\ntemplate<typename T,typename E>using hash_map=__gnu_pbds::gp_hash_table<T,E>;\ntemplate<typename T>using pqueue =__gnu_pbds::priority_queue<T, greater<T>,__gnu_pbds::rc_binomial_heap_tag>;\ntypedef long long lint;\n#define INF (1LL<<60)\n#define IINF (1<<30)\n#define EPS (1e-10)\n#define endl ('\\n')\n#define MOD 1000000007LL\n//#define MOD 998244353LL\ntypedef vector<lint> vec;\ntypedef vector<vector<lint>> mat;\ntypedef vector<vector<vector<lint>>> mat3;\ntypedef vector<string> svec;\ntypedef vector<vector<string>> smat;\ntemplate<typename T>inline void numout(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i<INF/2?i:\"INF\";f=1;}cout<<endl;}\ntemplate<typename T>inline void numout2(T t){for(auto i:t)numout(i);}\ntemplate<typename T>inline void output(T t){bool f=0;for(auto i:t){cout<<(f?\" \":\"\")<<i;f=1;}cout<<endl;}\ntemplate<typename T>inline void output2(T t){for(auto i:t)output(i);}\ntemplate<typename T>inline void _output(T t){bool f=0;for(lint i=0;i<t.size();i++){cout<<f?\"\":\" \"<<t[i];f=1;}cout<<endl;}\ntemplate<typename T>inline void _output2(T t){for(lint i=0;i<t.size();i++)output(t[i]);}\n#define rep(i,n) for(lint i=0;i<lint(n);++i)\n#define repi(i,a,b) for(lint i=lint(a);i<(lint)(b);++i)\n#define rrep(i,n) for(lint i=lint(n)-1;i>=0;--i)\n#define rrepi(i,a,b) for(lint i=lint(b)-1;i>=lint(a);--i)\n#define irep(i) for(lint i=0;;++i)\n#define all(n) begin(n),end(n)\n#define dist(a,b,c,d) sqrt(pow(a-c,2)+pow(b-d,2))\ninline lint gcd(lint A,lint B){return B?gcd(B,A%B):A;}\ninline lint lcm(lint A,lint B){return A/gcd(A,B)*B;}\n// inline cint cgcd(cint A,cint B){return B?cgcd(B,A%B):A;}\n// inline cint clcm(cint A,cint B){return A/cgcd(A,B)*B;}\nbool chmin(auto& s,const auto& t){bool res=s>t;s=min(s,t);return res;}\nbool chmax(auto& s,const auto& t){bool res=s<t;s=max(s,t);return res;}\nconst vector<lint> dx={1,0,-1,0,1,1,-1,-1};\nconst vector<lint> dy={0,1,0,-1,1,-1,1,-1};\n#define SUM(v) accumulate(all(v),0LL)\nauto call=[](auto f,auto... args){return f(f,args...);};\n\n\n \nint main(){\n    while(1){\n        lint n;\n        cin>>n;\n        if(n==0)break;\n        map<string,lint>m;\n        vector<vector<string>>s(n);\n        vector<lint>v(n);\n        rep(i,n){\n            string t;\n            cin>>t;\n            m[t]=i;\n            cin>>v[i];\n            lint x;\n            cin>>x;\n            rep(j,x){\n                string u;\n                cin>>u;\n                s[i].push_back(u);\n            }\n        }\n        mat g(n);\n        rep(i,n){\n            rep(j,s[i].size()){\n                g[i].push_back(m[s[i][j]]);\n            }\n        }\n        lint k=n/2;\n        lint* tmp=new lint[1LL<<k]();\n        lint* tmp2=new lint[1LL<<(n-k)]();\n        rep(i,1LL<<k){\n            bool b=i&1LL;\n            if(!b)continue;\n            lint cnt=0;\n            rep(j,k){\n                if(i&(1LL<<j)){\n                    for(auto e:g[j]){\n                        if(e>=k)continue;\n                        if(i&(1LL<<e)){\n                            b=0;\n                            if(b==0)break;\n                        }\n                    }\n                    cnt+=v[j];\n                }\n                if(b==0)break;\n            }\n            if(b)tmp[i]=cnt;\n        }\n        rep(t,1LL<<(n-k)){\n            lint i=t<<k;\n            bool b=1;\n            lint cnt=0;\n            rep(j,(n-k)){\n                if(i&(1LL<<(j+k))){\n                    for(auto e:g[j+k]){\n                        if(i&(1LL<<e))b=0;\n                        if(b==0)break;\n                    }\n                    cnt+=v[j+k];\n                }\n                if(b==0)break;\n            }\n            if(b)tmp2[t]=cnt;\n        }\n        rep(i,1LL<<(n-k)){\n            rep(j,(n-k)){\n                if(i&(1LL<<j)){\n                    tmp2[i]=max(tmp2[i],tmp2[i-(1LL<<j)]);\n                }\n            }\n        }\n        lint ans=0;\n        vector<lint>hoge(k,0);\n        rep(i,k){\n            for(auto e:g[i]){\n                if(e<k)continue;\n                hoge[i]|=1LL<<(e-k);\n            }\n        }\n        rep(i,1LL<<k){\n            if(tmp[i]==0)continue;\n            lint mask=(1LL<<(n-k))-1;\n            rep(j,k){\n                if(i&(1LL<<j)){\n                    mask&=~hoge[j];\n                }\n            }\n            ans=max(ans,tmp[i]+tmp2[mask]);\n        }\n        cout<<ans<<endl;\n        delete[] tmp;\n        delete[] tmp2;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41], wes[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n\n  ans = max(ans, wsum);\n\n  if(wsum + wes[N-1] - (curr ? wes[curr-1] : 0) <= ans) return;\n\n  if(curr == N-1) return;\n\n  const int next = curr + 1;\n\n  bool ok = 1;\n  rep(k, next) if(adjacent[next][k] && (S >> k & 1)) { ok = 0; break; }\n\n  if(!ok) {\n    dfs(S, wsum, next);\n  }\n  else {\n    dfs(S, wsum, next);\n    dfs(S|(1LL<<next), wsum + weight[next], next);\n  }\n}\n\nint main() {\n\n  while(cin >> N && N) {\n    rep(i, 41) weight[i] = 0;\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(i, N) {\n      string s; cin >> s;\n      if(id.find(s) == id.end()) id[s] = v++;\n      cin >> weight[id[s]];\n      int n; cin >> n;\n      rep(_, n) {\n        string t; cin >> t;\n        if(id.find(t) == id.end()) id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) wes[i] = weight[i] + (i ? wes[i-1] : 0);\n\n    ans = 0;\n    dfs(1LL<<0, weight[0], 0);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing P = pair<int, int>;\nconst ll MOD = 1000000007;\n\nint N;\nvector<vector<int>> G;\nstring A[42];\nint B[42], C[42];\nmap<ll, int> memo;\nstring names[42][42];\n\nint dfs(ll bit){\n    if(bit == (1LL << N) - 1) return 0;\n    if(memo.find(bit) != memo.end()) return memo[bit];\n    int ret = 0;\n    for(int i=1;i<N;i++){\n        if((bit >> i) & 1) continue;\n        ll nbit = bit | (1LL << i);\n        for(int to : G[i]){\n            nbit |= (1LL << to);\n        }\n        ret = max(ret, dfs(nbit) + B[i]);\n    }\n    memo[bit] = ret;\n    return ret;\n}\n\nint main(){\n    while(true){\n        cin >> N;\n        if(N == 0) break;\n\n        map<string, int> mp;\n        for(int i=0;i<N;i++){\n            cin >> A[i] >> B[i] >> C[i];\n            mp[A[i]] = i;\n            for(int j=0;j<C[i];j++){\n                cin >> names[i][j];\n            }\n        }\n\n        G.assign(N, {});\n        for(int i=0;i<N;i++){\n            for(string& to : names[i]){\n                G[i].push_back(mp[to]);\n            }\n        }\n\n        ll bit = 1;\n        int ans = B[0];\n        for(int i=1;i<N;i++){\n            if(C[i] == 0){\n                bit |= (1 << i);\n                ans += B[i];\n            }\n        }\n        for(int to : G[0]){\n            bit |= (1 << to);\n        }\n\n        memo.clear();\n\n        cout << ans + dfs(bit) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//29\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint N;\nint B[40];\nvector<pair<int,int> > v;\nlong long bm[40];\n\nint rec(long long b,long long bb,int c){\n  if(c==v.size()){\n    return 0;\n  }else{\n    int s=v[c].first;\n    int t=v[c].second;\n    int m=rec(b,bb|1LL<<s|1LL<<t,c+1);\n    if(!(((b|bb)>>s|b>>t)&1)){\n      m=max(m,B[s]+rec(b|1LL<<s,bb|1LL<<t|bm[s],c+1));\n    }\n    if(!(((b|bb)>>t|b>>s)&1)){\n      m=max(m,B[t]+rec(b|1LL<<t,bb|1LL<<s|bm[t],c+1));\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>N,N){\n    string A[40];\n    vector<string> D[40];\n    for(int i=0;i<N;i++){\n      int C;\n      cin>>A[i]>>B[i]>>C;\n      D[i].resize(C);\n      while(C--){\n\tcin>>D[i][C];\n      }\n    }\n    v.clear();\n    int m=0;\n    long long b=0;\n    long long bb=0;\n    for(int i=0;i<N;i++){\n      bm[i]=1LL<<i;\n      for(int j=0;j<D[i].size();j++){\n\tint k=find(A,A+N,D[i][j])-A;\n\tbm[i]|=1LL<<k;\n\tif(i<k){\n\t  v.push_back(make_pair(i,k));\n\t}\n      }\n      if(i==0||D[i].size()==0){\n\tm+=B[i];\n\tb|=1LL<<i;\n\tbb|=bm[i];\n      }\n    }\n    cout<<m+rec(b,bb,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    vector<vector<string>> graph_(n);\n    map<string,int> encode;\n    vector<int> strength(n),sum(n);\n    rep(i,0,n){\n        string a;\n        int b,c;\n        cin >> a >> b >> c;\n        encode[a]=i;\n        strength[i]=b;\n        sum[i]=b;\n        if(i>0) sum[i]+=sum[i-1];\n        rep(j,0,c){\n            string d;\n            cin >> d;\n            graph_[i].push_back(d);\n        }\n    }\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        rep(j,0,graph_[i].size()){\n            graph[i].push_back(encode[graph_[i][j]]);\n        }\n    }\n\n    int maxi=0;\n    function<int(int,int,int)> rec=[&](int s,int i,int k){\n        if(i==n) return maxi=max(maxi,k);\n        if(k+sum[n-1]-sum[i-1]<=maxi) return maxi;\n        int res=rec(s,i+1,k);\n        bool f=true;\n        for(int j:graph[i]) if((s>>j)&1){\n            f=false;\n            break;\n        }\n        if(f) res=max(res,rec(s|(1<<i),i+1,k+strength[i]));\n        return maxi=max(maxi,res);;\n    };\n\n    cout << rec(1,1,strength[0]) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nstruct before_main {\n  before_main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n  }\n} before_main;\n\n#define REP(i, a, b) for (int i = a; i < (int)b; i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef long long ll;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41];\nint weight_sum[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n\n  ans = max(ans, wsum);\n\n  if (curr == N) {\n    return;\n  }\n\n  if (wsum + weight_sum[N-1] - (curr ? weight_sum[curr - 1] : 0) <= ans)\n    return;\n\n  dfs(S, wsum, curr + 1);\n\n  rep(k, curr) {\n    if (adjacent[curr][k] && (S >> k & 1)) {\n      return;\n    }\n  }\n\n  dfs(S | (1 << curr), wsum + weight[curr], curr + 1);\n}\n\nint main() {\n\n  while (cin >> N && N) {\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(_, N) {\n      string s;\n      cin >> s;\n      if (id.find(s) == id.end())\n        id[s] = v++;\n      cin >> weight[id[s]];\n      int n;\n      cin >> n;\n      rep(_, n) {\n        string t;\n        cin >> t;\n        if (id.find(t) == id.end())\n          id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) weight_sum[i] = weight[i] + (i ? weight_sum[i-1] : 0);\n\n    ans = 0;\n    dfs(1<<0, weight[0], 1);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nbool edge[50][50] = {};\nint force[50] = {};\nll memo[50];\nint dp1[1<<21], dp2[1<<21];\n\nint dfs1(int state) {\n    int &ret = dp1[state];\n    if (ret >= 0) return ret;\n    ret = 0;\n\n    int n = N/2;\n    for (int i = 0; i < n; i++) {\n        if (!((state >> i) & 1)) continue;\n        int next_state = (int)(((ll)state) & memo[i]);\n        ret = max(ret, force[i] + dfs1(next_state));\n    }\n    return ret;\n}\n\nint dfs2(int state) {\n    int &ret = dp2[state];\n    if (ret >= 0) return ret;\n    ret = 0;\n\n    int n = N/2, ns = N - n;\n    for (int i = 0; i < ns; i++) {\n        if (!((state >> i) & 1)) continue;\n        int next_state = (int)(((ll)state) & (memo[i + n] >> n));\n        ret = max(ret, force[i + n] + dfs2(next_state));\n    }\n    return ret;\n}\n\nint main() {\n    while (cin >> N, N) {\n        map<string, int> name2id;\n        memset(edge, false, sizeof(edge));\n        for (int i = 0; i < N; i++) {\n            string from; int f, n_v;\n            cin >> from >> f >> n_v;\n            if (!name2id.count(from)) name2id[from] = name2id.size();\n\n            int fid = name2id[from];\n            force[fid] = f;\n            edge[fid][fid] = true;\n\n            for (int j = 0; j < n_v; j++) {\n                string to; cin >> to;\n                if (!name2id.count(to)) name2id[to] = name2id.size();\n                edge[fid][name2id[to]] = true;\n            }\n        }\n\n        if (N == 1) {\n            cout << force[0] << endl;\n            continue;\n        }\n\n        for (int i = 0; i < N; i++) {\n            ll tmp = 0;\n            for (int j = 0; j < N; j++)\n                if (edge[i][j]) tmp |= (1ll << j);\n            memo[i] = ((1ll << 50) - 1) ^ tmp;\n        }\n\n        memset(dp1, -1, sizeof(dp1));\n        memset(dp2, -1, sizeof(dp2));\n        int n = N / 2, ans = 0;\n        for (int state = 0; state < (1 << n); state++) {\n            if (state & 1) continue;\n\n            bool is_ok = true;\n            for (int i = 0; is_ok && i < n; i++) {\n                if (edge[0][i] && ((state >> i) & 1)) is_ok = false;\n            }\n            if (!is_ok) continue;\n\n            ll flag = (1ll << N) - 1;\n            flag &= memo[0];\n            for (int i = 0; i < n; i++) {\n                if ((state >> i) & 1) flag &= memo[i];\n            }\n            int ns = (int)(flag >> n);\n\n            ans = max(ans, force[0] + dfs1(state) + dfs2(ns));\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[40];\nbool G[40][40];\nint NG[40];\n\nint64 dfs(int64 idx, int64 bit)\n{\n  if(idx == N) return (0);\n  int64 ret = dfs(idx + 1, bit);\n  if((NG[idx] & bit) == 0 && !(bit >> idx) & 1)\n    ret = max(ret, dfs(idx + 1, bit | (1LL << idx)) + V[idx]);\n  return (ret);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    cout << dfs(1, 1) + V[0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\nbool getBit(long long num, int i){\n\treturn ((num & (1LL << i)) != 0);\n}\n\nvector<int> atk, sum;\nvector<long long> bit;\nint maxi;\n\nvoid input(int n){\n\tvector<string> name(n);\n\tvector<vector<string>> near(n);\n\n\tmap<string, int> id;\n\trep(i,n){\n\t\tint d;\n\t\tcin >> name[i] >> atk[i] >> d;\n\t\tid[name[i]] = i;\n\t\twhile(d--){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tnear[i].emplace_back(s);\n\t\t}\n\t}\n\n\trep(i,n){\n\t\tsum[i + 1] = sum[i] + atk[i];\n\t}\n\n\trep(i,n){\n\t\tbit[i] |= 1LL << i;\n\t\tfor(auto s : near[i]){\n\t\t\tbit[i] |= 1LL << id[s];\n\t\t}\n\t\t//cout << bitset<10>(bit[i]) << endl;\n\t}\n}\n\nvoid dfs(int& n, int i, long long enemy, int total){\n\tmaxi = max(maxi, total);\n\tif(i == n) return;\n\tif(total + sum[n] - sum[i] < maxi) return;\n\t\n\tif(not getBit(enemy,i)){\n\t\tdfs(n, i + 1, enemy bitor bit[i], total + atk[i]);\n\t}\n\tdfs(n, i + 1, enemy, total);\n}\n\n//map<pair<long long, long long>, int> memo1, memo2;\nvector<int> dp; // dp[s] := 集合sから任意の数, 仲間を選べるときの最大値\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tatk = vector<int>(n);\n\t\tsum = vector<int>(n + 1, 0);\n\t\tbit = vector<long long>(n,0);\n\t\tinput(n);\n\n\t\tmaxi = 0;\n\t\tdfs(n, 0, bit[0], atk[0]);\n\t\tcout << maxi << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdint>\n#include <cassert>\n#include <functional>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\nnamespace lc {\nstruct Edge {\n\tint to;\n\texplicit Edge(int to) : to(to) { }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType, typename Func>\nvoid enumerate_maximal_independent_sets(\n\tconst AdjacencyList<EdgeType> &graph, Func func)\n{\n\tconst int n = graph.size();\n\tstd::vector<uint64_t> bit_graph(n), incr_bit_graph(n + 1);\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tuint64_t mask = (1ull << i);\n\t\tfor(const auto &e : graph[i]){ mask |= (1ull << e.to); }\n\t\tbit_graph[i] = mask;\n\t\tincr_bit_graph[i] = mask | incr_bit_graph[i + 1];\n\t}\n\tstd::function<void(int, uint64_t, uint64_t)> recur =\n\t\t[&, n](int i, uint64_t picked, uint64_t eliminated) -> void {\n\t\t\tif(i == n){\n\t\t\t\tif((picked | eliminated) == (1ull << n) - 1){ func(picked); }\n\t\t\t}else if(bit_graph[i] & ~(incr_bit_graph[i + 1] | eliminated)){\n\t\t\t\tif(!(eliminated & (1ull << i))){\n\t\t\t\t\trecur(i + 1, picked | (1ull << i), eliminated | bit_graph[i]);\n\t\t\t\t}else{\n\t\t\t\t\trecur(i + 1, picked, eliminated);\n\t\t\t\t}\n\t\t\t}else if((incr_bit_graph[i + 1] | eliminated) & (1ull << i)){\n\t\t\t\trecur(i + 1, picked, eliminated);\n\t\t\t\tif(!(eliminated & (1ull << i))){\n\t\t\t\t\trecur(i + 1, picked | (1ull << i), eliminated | bit_graph[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trecur(i + 1, picked | (1ull << i), eliminated | bit_graph[i]);\n\t\t\t}\n\t\t};\n\trecur(0, 0, 0);\n}\n}\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n};\n}\nusing namespace std;\ntypedef lc::Edge Edge;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tlc::NameTable name_table;\n\t\tvector<int> powers(n);\n\t\tlc::AdjacencyList<Edge> graph(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring u_name;\n\t\t\tint p, m;\n\t\t\tcin >> u_name >> p >> m;\n\t\t\tconst int u = name_table[u_name];\n\t\t\tpowers[u] = p;\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tstring v_name;\n\t\t\t\tcin >> v_name;\n\t\t\t\tconst int v = name_table[v_name];\n\t\t\t\tgraph.add_edge(u, v);\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tlc::enumerate_maximal_independent_sets(graph, [&](uint64_t s){\n\t\t\tif((s & 1) == 0){ return; }\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tif(s & (1ull << i)){ sum += powers[i]; }\n\t\t\t}\n\t\t\tanswer = max(answer, sum);\n\t\t});\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\n\n// ノード数\nint n;\n// H[国名] := ノード番号 (文字列 と ノード番号の対応付け)\nmap<string,int> H;\n// 国名の保持, v.size() == n \nvector<string> v;\n// i 番目の国の強さ\nint power[40];\n// 答え\nint ans;\n\n// G := グラフ\n// pos := これから使おうとしている頂点の開始番号\n// used[i] := 頂点 i を使えないときは true, 使えるときは false\n// p := 強さの総和\nvoid solve(vector< vector<int> >& G, int pos, vector<bool> used, int p){\n\tans = max( ans , p );\n\tfor(int i=pos ; i < n ; i++ ){\n\t\tif( !used[i] ){\n\t\t\tvector<bool> used_ = used;\n\t\t\tused_[i] = true;\n\t\t\tfor(int j=0 ; j < G[i].size() ; j++ ){\n\t\t\t\tint v = G[i][j];\n\t\t\t\tused_[v] = true;\n\t\t\t}\n\t\t\tsolve( G , pos+1 , used_ , p+power[i] );\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\t// 初期化\n\t\tH.clear();\n\t\tv.clear();\n\t\t// グラフ\n\t\tvector< vector<int> > G(n);\n\t\t\n\t\tvector< vector<string> > D(n);\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tstring A;\n\t\t\tint B, C;\n\t\t\tcin >> A >> B >> C;\n\t\t\tH[A] = i;\n\t\t\tv.push_back(A);\n\t\t\tpower[i] = B;\n\t\t\t\n\t\t\tD[i] = vector<string>(C);\n\t\t\tfor(int j=0 ; j < C ; j++ ){\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < D[i].size() ; j++ ){\n\t\t\t\tint v = H[ D[i][j] ];\n\t\t\t\tG[i].push_back( v );\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tvector<bool> used(n,false);\n\t\tused[0] = true;\n\t\tfor(int i=0 ; i < G[0].size() ; i++ ){\n\t\t\tused[ G[0][i] ] = true;\n\t\t}\n\t\tint sum = power[0];\n\t\tfor(int i=1 ; i < n ; i++ ){\n\t\t\tif( used[i] ) continue;\n\t\t\tif( G[i].size() == 0 ){\n\t\t\t\tsum += power[i];\n\t\t\t\tused[i] = true;\n\t\t\t}else if( G[i].size() == 1 ){\n\t\t\t\tint v = G[i][0];\n\t\t\t\tif( G[v].size() == 1 ){\n\t\t\t\t\tsum += max( power[i] , power[v] );\n\t\t\t\t\tused[i] = used[v] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint pos=0;\n\t\tfor(int i=1 ; i < n ; i++ ){\n\t\t\tif( used[i] == false ){\n\t\t\t\tbreak;\n\t\t\t}else{\n\t\t\t\tpos = i;\n\t\t\t}\n\t\t}\n\t\tsolve( G , pos , used , sum );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nusing ll = int;\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<ll> d[41];\n\nll dp0[1<<21];\nll dp1[1<<21];\nll maskNg0[1<<21];\nll maskNg1[1<<21];\nll maskNg2[1<<21];\n\ninline void calc(ll* dp, ll l, ll r, ll* maskNg) {\n  rep(mask, 1 << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1<<i)) continue;\n      ll nxt = mask | (1 << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    unordered_map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    rep(i, n) {\n      d[i].resize(D[i].size());\n      rep(j, D[i].size()) d[i][j] = mp[D[i][j]];\n    }\n\n    ll l = 0, m = n/2, r = n;\n  \n    rep(i, 1<<(m - l)) maskNg0[i] = maskNg2[i] = 0;\n    rep(i, 1<<(r - m)) maskNg1[i] = 0;\n    \n    rep(i, m - l) {\n      auto& mask = maskNg0[i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j];\n\tif(k >= m) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg1[i];\n      rep(j, d[i + m].size()) {\n\tll k = d[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg2[i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n\n    rep(i, 1 << (m - l)) dp0[i] = 0;\n    rep(i, 1 << (r - m)) dp1[i] = 0;\n    calc(dp0, l, m, maskNg0);\n    calc(dp1, m, r, maskNg1);\n\n    rep(mask, (1 << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1<<i)]);\n      }\n    }\n    \n    ll ans = 0;\n    rep(x, 1<<(m - l)) {\n      if(x&1) {\n\tll y = (1<<(r - m)) - 1;\n\trep(i, m - l) {\n\t  if(x & (1 << i)) {\n\t    y -= (y & maskNg2[i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <map>\nusing namespace std;\ntypedef long long int ll;\n\nconst int N=45;\n\nint a[N];\n\nll bit[N];\nint dp1[1<<20];\nint dp2[1<<20];\n\nint n;\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    map<string,int> mp;\n    while(cin >> n,n){\n        mp.clear();\n        vector<string> rinsetu[n];\n        for(int i=0;i<n;i++){\n            string s; cin >> s;\n            mp[s]=i;\n            cin >> a[i];\n            int m; cin >> m;\n            while(m--){\n                cin >> s;\n                rinsetu[i].push_back(s);\n            }\n        }\n        for(int i=0;i<n;i++){\n            bit[i]=0;\n            for(string s:rinsetu[i]){\n                bit[i]|=(1LL<<mp[s]);\n            }\n        }\n        int r=n/2;\n        int l=n-r;\n        for(ll i=0;i<(1<<r);i++){\n            int sum=0;\n            dp1[i]=-1;\n            bool ok=1;\n            for(int j=0;j<r;j++){\n                if(i&(1LL<<j)){\n                    sum+=a[j];\n                    if(i&bit[j]){\n                        ok=0;\n                    }\n                }\n                if(!ok)break;\n            }\n            if(ok){\n                dp1[i]=sum;\n            }\n        }\n        for(ll i=0;i<(1<<l);i++){\n            dp2[i]=0;\n            int sum=0;\n            bool ok=1;\n            for(int j=0;j<l;j++){\n                if(i&(1<<j)){\n                    sum+=a[j+r];\n                    ll ii=(ll)(i<<r);\n                    if(ii&bit[j+r]){\n                        ok=0;\n                    }\n                }\n                if(!ok)break;\n            }\n            if(ok){\n                dp2[i]=sum;\n            }\n        }\n        for(int j=0;j<(1<<l);j++){\n            for(int i=0;i<l;i++){\n                if(j&(1<<i)){\n                    dp2[j]=max(dp2[j],dp2[j^(1<<i)]);\n                }\n            }\n        }\n        int res=0;\n        ll q=(1<<l)-1;\n        for(int i=0;i<(1<<r);i++){\n            if(i%2==0)continue;\n            if(dp1[i]==-1)continue;\n            ll p=0;\n            for(int j=0;j<r;j++){\n                if(i&(1<<j)){\n                    p|=bit[j];\n                }\n            }\n            p>>=r;\n            p^=q;\n            res=max(res,dp1[i]+dp2[p]);\n        }\n        printf(\"%lld\\n\",res);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint ans;\nint bs[114514];\nint cs[114514];\nchar buf[114514];\nbool used[114514];\nstring as[114514];\nvector<int> es[114514];\nvector<string> ds[114514];\nmap<string, int> rev;\n\nvoid calc(set<int> &vs, int sum) {\n  if (vs.empty()) {\n    ans = max(ans, sum);\n    return;\n  }\n\n  int v = *vs.begin();\n  vs.erase(v);\n  calc(vs, sum);\n  vector<int> restores;\n  for (int i=0; i<cs[v]; i++) {\n    int u = es[v][i];\n    if (vs.count(u)) {\n      restores.emplace_back(u);\n      vs.erase(u);\n    }\n  }\n  calc(vs, sum+bs[v]);\n  vs.insert(v);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n    rev.clear();\n    set<int> vs;\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      as[i] = buf;\n      rev[as[i]] = i;\n      scanf(\"%d\", &bs[i]);\n      scanf(\"%d\", &cs[i]);\n      ds[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        scanf(\" %s\", buf);\n        ds[i][j] = buf;\n      }\n      vs.insert(i);\n    }\n  \n    for (int i=0; i<n; i++) {\n      es[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        es[i][j] = rev[ds[i][j]];\n      }\n    }\n\n    int pre = 0;\n    vs.erase(0);\n    for (int u : es[0]) {\n      vs.erase(u);\n    }\n    pre += bs[0];\n\n    for (int i=1; i<n; i++) {\n      if (!vs.count(i)) continue;\n      if (cs[i] == 0 || (cs[i] == 1 && bs[i] >= bs[es[i][0]])) {\n        vs.erase(i);\n        for (int u : es[i]) {\n          vs.erase(u);\n        }\n        pre += bs[i];\n      }\n    }\n  \n    ans = 0;\n    calc(vs, pre);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nvector<int> G[44];\nint B[44];\nbool ok[44];\nint idx[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\n\nbool used[55];\nbool sele[55];\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[i] && !used[i] && !sele[i] ) cnt++;\n  }\n  //cout << id << \" \"<< cnt << \" \"<< M << endl;\n  return cnt > M;\n}\nint solve(int num){\n  int id = idx[num];\n  if( num == N ) return 0;\n  if( sele[id] || ok[id] || used[id] ) return solve(num+1);\n  if( check(num) ) return 0;\n  \n  bool tmp[41]={};\n  sele[id] = true;\n  for(int i=0;i<N;i++) tmp[i] = used[i];\n  for(int i=0;i<(int)G[id].size();i++) used[G[id][i]] = true;\n  int res = solve(num+1)+B[id];\n\n  //cout << \"view\" << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << endl; }\n  //cout << id << \" \" << res << endl;\n\n  for(int i=0;i<N;i++) used[i] = tmp[i];\n  sele[id] = false;\n  \n  int sum = 0;\n  for(int i=id+1;i<N;i++) if( !ok[i] && !used[i] ) sum += B[i];\n  if( sum > res )\n    res = max( res,solve(num+1) );\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    vector<pair<int,int>> point;\n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id].clear();\n      point.push_back( make_pair( B[id], id ) );\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id].push_back( nd );\n      }\n    }\n\n    sort( point.rbegin(), point.rend() );\n    for(int i=0;i<(int)point.size();i++)\n      idx[i] = point[i].second;\n\n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i].empty() ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    memset(used,0,sizeof(used));\n    memset(sele,0,sizeof(sele));\n    M = (N+1)/2;\n    if( !G[0].empty() ) res += B[0];\n    sele[0] = true;\n    for(int i=0;i<(int)G[0].size();i++) used[G[0][i]] = true;\n    res += solve(0);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nconst int BIT = 1<<21;\nint N;\nmap<string,int> id;\nint B[MAXN];\nGraph g;\nint S[BIT], T[BIT], D[BIT];\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    int b = N/2;\n    int a = N - b;\n    vector<pair<int,int> > esS, esT, esU;\n    for(int v = 0; v < N; ++v) {\n      for(int j = 0; j < g[v].size(); ++j) {\n        int nv = g[v][j];\n        if(v < a && nv < a && v < nv) esS.push_back(make_pair(v, nv));\n        if(v >= a && nv >= a && v < nv) esT.push_back(make_pair(v, nv));\n        if(v < a && nv >= a) esU.push_back(make_pair(v, nv));\n      }\n    }\n\n    fill(S, S+BIT, 0);\n    for(int j = 0; j < (1<<a); ++j) {\n      vector<int> used(N);\n      if(S[j] == -1) continue;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n        if(used[v]) S[j] += B[v];\n      }\n      for(int i = 0; i < esS.size(); ++i) {\n        int p = esS[i].first;\n        int q = esS[i].second;\n        if(used[p] && used[q]) {\n          for(int k = j; k < (1<<a); k = ((k + 1)|j)) S[k] = -1;\n          break;\n        }\n      }\n    }\n\n    fill(T, T+BIT, 0);\n    for(int j = 0; j < (1<<b); ++j) {\n      vector<int> used(N);\n      if(T[j] == -1) continue;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v >= a && (j & (1<<(v-a)));\n        if(used[v]) T[j] += B[v];\n      }\n      for(int i = 0; i < esT.size(); ++i) {\n        int p = esT[i].first;\n        int q = esT[i].second;\n        if(used[p] && used[q]) {\n          for(int k = j; k < (1<<b); k = ((k + 1)|j)) T[k] = -1;\n          break;\n        }\n      }\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      for(int k = 0; k < b; ++k) {\n        if(j & (1<<k)) continue;\n        T[j|(1<<k)] = max(T[j|(1<<k)], T[j]);\n      }\n    }\n\n    fill(D, D+BIT, (1<<b)-1);\n    vector<int> bits(N, 0);\n    for(int i = 0; i < esU.size(); ++i) {\n      int p = esU[i].first;\n      int q = esU[i].second;\n      bits[p] |= (1<<(q-a));\n    }\n    for(int i = 0; i < a; ++i) {\n      int j = 1<<i;\n      for(int k = j; k < (1<<a); k = ((k+1)|j)) D[k] &= ~bits[i];\n    }\n\n    int res = 0;\n\n    for(int j = 0; j < (1<<a); ++j) {\n      if(S[j] == -1) continue;\n      if(!(j & 1)) continue;\n      /*\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n      }\n      int bit = (1<<b)-1;\n      for(int i = 0; i < esU.size(); ++i) {\n        int p = esU[i].first;\n        int q = esU[i].second;\n        if(used[p]) {\n          bit &= ~(1<<(q-a));\n        }\n      }\n      */\n      int bit = D[j];\n      if(T[bit] == -1) continue;\n      res = max(res, S[j] + T[bit]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[45];\nbool G[45][45];\nint64 NG[45];\nint sum[45];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[idx] <= beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 50;\n\nint N;\nmap<string,int> id;\nGraph g;\nint B[MAXN];\n\nlli adj[MAXN];\nint sum[MAXN];\nint ans;\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nvoid rec(int k, lli bit, int now) {\n  if(now + sum[k] <= ans) return;\n  if(k == N) {\n    ans = max(ans, now);\n    return;\n  }\n  if(!(bit & (1LL<<k))) rec(k+1, bit|adj[k], now+B[k]);\n  rec(k+1, bit, now);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    for(int v = 0; v < N; ++v) {\n      adj[v] = 0;//1LL<<v;\n      for(int i = 0; i < g[v].size(); ++i) {\n        int nv = g[v][i];\n        adj[v] |= 1LL<<nv;\n      }\n    }\n\n    sum[N] = 0;\n    for(int v = N-1; v >= 0; --v) sum[v] = sum[v+1] + B[v];\n\n    ans = 0;\n    rec(1, adj[0], B[0]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if((ne & (1LL<<i)) != 0) continue;\n        if(((ne | cs[i].ne) ^ (ne | (1LL<<i))) < 1LL){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n    \n    priority_queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.top().second.second;\n        power = pq.top().second.first;\n        int v = pq.top().first + 1;\n        pq.pop();\n        //cout << v << \"*\" << power << \":\" << ne << endl;\n        res = max(res, power);\n        \n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        \n        int sum = power;\n        for(int i = v; i < n; i++){\n            if(((1LL<<i) & ne) == 0) sum += cs[i].power;\n        }\n        //cout << sum << \"sum: res \" << res << endl;\n        if(sum < res) continue;\n        \n        ll nne = ne;\n        int npower = power;\n        for(int i = v + 1; i < n; i++){\n            if((nne & (1LL<<i)) != 0) continue;\n            if(((nne | cs[i].ne) ^ (nne | (1LL<<i))) < (1LL <<(v+1))){\n                nne |= cs[i].ne;\n                npower += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(npower, nne)));\n        \n        \n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if(((ne | cs[i].ne) ^ (ne | (1LL<<i))) < (1LL <<(v+1))){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nint ans = 0;\nvector<int>powers;\n\nint getans(const vector<vector<int>>&tonari,vector<int>ally,vector<bool>oks,const int next,const int pow) {\n\tif (pow + accumulate(powers.begin() + next, powers.end(), pow) <= ans)return 0;\n\telse {\n\t\tif (next == powers.size())return pow;\n\t\tint nans = 0;\n\t\tif(oks[next]){\n\t\t\tvector<int>nally(ally);\n\t\t\tnally.push_back(next);\n\t\t\tvector<bool>noks(oks);\n\t\t\tfor (int c = next + 1; c < powers.size(); ++c) {\n\t\t\t\tif (tonari[next][c])noks[c] = false;\n\t\t\t}\n\t\t\tnans = max(nans, getans(tonari,nally,noks, next + 1, pow + powers[next]));\n\t\t}\n\t\tnans = max(nans,getans(tonari, ally, oks, next + 1, pow));\n\t\tans = max(ans, nans);\n\t\treturn nans;\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tpowers.clear();\n\t\tif (!N)break;\n\t\tvector<string>names;\n\t\tvector<vector<string>>rins(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring a; int  b, c; cin >> a >> b >> c;\n\t\t\tnames.push_back(a);\n\t\t\tpowers.push_back(b);\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\trins[i].push_back(st);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>tonari(N, vector<int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto n : rins[i]) {\n\t\t\t\tint r = find(names.begin(), names.end(), n) - names.begin();\n\t\t\t\ttonari[i][r] = true;\n\t\t\t}\n\t\t}\n\t\tvector<bool>oks(N,true);\n\t\tfor (int c = 1; c < powers.size(); ++c) {\n\t\t\tif (tonari[0][c])oks[c] = false;\n\t\t}\n\t\tint ans = getans(tonari, vector<int>(), oks, 1, powers[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\nvector<int> G2[N];\n\nset<ll> memo;\n\nvoid dfs(int x,int sum,ll S){\n  \n  for(int i=0;i<G2[x].size();i++){\n    \n    int f=0, nx=G2[x][i];\n    \n    for(int j=0;j<n;j++)\n      if((S&(1<<j))&&G[j][nx]) f=1;\n    \n    if(!f){\n      \n      ll nS=S;\n      \n      nS|=(1<<nx);\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[nx]);\n      \n      dfs(x+1,sum+cost[nx],nS);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(!G[i][j]){\n\t  G2[i].push_back(j);\n\t  G2[j].push_back(i);\n\t}\n\t  \n    ans=cost[0];\n    \n    ll S=(1<<0);\n\n    dfs(1,cost[0],S);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int>& f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tint tt = id.size();\n\t\t\t\tid[t] = tt;\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\nint max_f;\nvoid dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t{\n\t\tmax_swap(max_f, sum);\n\t\treturn;\n\t}\n\n\tif (!(enemy >> d & 1))\n\t{\n\t\tint rem = 0;\n\t\tfor (int i = d; i < m; ++i)\n\t\t\tif (!(enemy >> i & 1))\n\t\t\t\trem += force[i];\n\t\tif (sum + rem <= max_f)\n\t\t\treturn;\n\n\t\tdfs(d + 1, enemy | on[d], sum + force[d]);\n\t}\n\tdfs(d + 1, enemy, sum);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t{\n\t\t\t\tint t = id.size();\n\t\t\t\tid[a] = t;\n\t\t\t}\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t{\n\t\t\t\t\tint t = id.size();\n\t\t\t\t\tid[d] = t;\n\t\t\t\t}\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\n\t\tint res;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tmax_f = 0;\n\t\tdfs(1, on[0], force[0]);\n\t\tres = max_f;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tmax_f = 0;\n\t\t\t\tdfs(0, 0, 0);\n\t\t\t\tres += max_f;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\n\nint main(){\n    while(cin >> n , n){\n        map<string,int> mp;\n        vector<i64> edges(n,0);\n        vector<int> x(n);\n\n        auto get_i = [&](string& s){\n            if(mp.count(s)){\n                return  mp[s];\n            }\n            else{\n                mp[s] = mp.size();\n                return (int)mp.size() - 1;\n            }\n        };\n\n        for(int c = 0;c < n;c++){\n            string s;cin >> s;\n            int i = get_i(s);\n            int C;\n            cin >> x[i] >> C;\n            for(int d = 0;d < C;d++){\n                cin >> s;\n                edges[i] |= (1LL << get_i(s));\n            }\n        }\n\n        vector<int> sum(n + 1,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        int result = 0;\n        function<void(i64,i64,int)> dfs = [&](int i,i64 bit,int now_sum){\n            result = max(result , now_sum);\n            if(i == n) return;\n            //枝刈り\n            if(now_sum + sum[i] <= result) return;\n            //throw\n            dfs(i + 1,bit,now_sum);\n\n            if(!(bit & edges[i])) dfs(i + 1,bit | (1LL << i),now_sum + x[i]);\n        };\n        dfs(1,1,x[0]);\n        cout << result << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\nconst int HALF=20;\nint dp0[1<<HALF];\nint vs0[HALF];\nint dp1[1<<HALF];\nint vs1[HALF];\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    for(int i=0;i<half;i++){\n        vs0[i]=0;\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=1;i<(1<<half);i+=2){\n        int vs=0;\n        int val=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                val+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) val=-INF;\n            dp0[i]=val;\n        }\n    }\n\n    \n    for(int i=0;i<rest;i++){\n        vs1[i]=0;\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        int val=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                val+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) val=-INF;\n            dp1[i]=val;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n\n    vector<int> vs01(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]>=half) vs01[i]|=(1<<(g[i][j]-half));\n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if(i&(1<<j)) opn&=~vs01[j];\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    //ios_base::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef unsigned long long int ULLI;\n\nint n;\nint ans;\nULLI used;\nint bs[114514];\nint cs[114514];\nULLI es[114514];\nchar buf[11451419];\nstring as[114514];\nvector<string> ds[114514];\nmap<string, int> rev;\n\nULLI popcount(ULLI x) { \n  x = ((x & 0xaaaaaaaaaaaaaaaaUL) >> 1) \n    +  (x & 0x5555555555555555UL); \n  x = ((x & 0xccccccccccccccccUL) >> 2) \n    +  (x & 0x3333333333333333UL); \n  x = ((x & 0xf0f0f0f0f0f0f0f0UL) >> 4) \n    +  (x & 0x0f0f0f0f0f0f0f0fUL); \n  x = ((x & 0xff00ff00ff00ff00UL) >> 8) \n    +  (x & 0x00ff00ff00ff00ffUL); \n  x = ((x & 0xffff0000ffff0000UL) >> 16) \n    +  (x & 0x0000ffff0000ffffUL); \n  x = ((x & 0xffffffff00000000UL) >> 32) \n    +  (x & 0x00000000ffffffffUL); \n  return x; \n} \n\nvoid calc(int v, int sum) {\n  if (v >= n || used == (1ULL << n)-1) {\n    ans = max(ans, sum);\n    return;\n  }\n\n  if (!(used >> v & 1)) {\n    ULLI used_reserve = used;\n    used |= 1ULL << v;\n    used |= es[v];\n    calc(v+1, sum+bs[v]);\n    used = used_reserve;\n\n    ULLI bits = es[v]&~used;\n    int cnt = popcount(bits);\n    if (cnt == 0) return;\n    int idx = ffsll(bits)-1;\n    if (cnt == 1 && bs[v] >= bs[idx]) return;\n  }\n  calc(v+1, sum);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    rev.clear();\n    for (int i=0; i<n; i++) {\n      scanf(\" %s %d %d\", buf, &bs[i], &cs[i]);\n      as[i] = string(buf);\n      rev[as[i]] = i;\n      ds[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        scanf(\" %s\", buf);\n        ds[i][j] = buf;\n      }\n    }\n  \n    for (int i=0; i<n; i++) {\n      es[i] = 0;\n      for (int j=0; j<cs[i]; j++) {\n        es[i] |= 1ULL << rev[ds[i][j]];\n      }\n    }\n\n    int pre = bs[0];\n    used = 1;\n    used |= es[0]; \n    for (int i=1; i<n; i++) {\n      if (used >> i & 1) continue;\n      if (cs[i] == 0 || (cs[i] == 1 && bs[i] >= bs[rev[ds[i][0]]])) {\n        pre += bs[i];\n        used |= 1ULL << i;\n        used |= es[i];\n      }\n    }\n  \n    //printf(\"%llx\\n\", used);\n    ans = 0;\n    calc(1, pre);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint ans = 0;\nint N;\nvector<int>rests;\n\nvoid getans(const int sum,const int now, const vector < pair<int, vector<int>>>&connects, vector<int>&oks) {\n\tif (now == N)ans =max(ans, sum);\n\telse {\n\t\t//if (sum + rests[now] < ans)return;\n\t\tif (oks[now]) {\n\t\t\tvector<int>preoks(oks);\n\t\t\tpreoks[now] = false;\n\t\t\tfor (auto e : connects[now].second) {\n\t\t\t\tpreoks[e] = false;\n\t\t\t}\n\t\t\tgetans(sum + connects[now].first, now+1, connects, preoks);\n\t\t\t\n\t\t}\n\t\tif (now) {\n\n\t\t\tgetans(sum, now + 1, connects, oks);\n\t\t}\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tans = 0;\n\t\trests.clear();\n\t\trests.resize(N);\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tvector<tuple<int,int,vector<int>>>connects(N);\n\t\tint num = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name; int b, c; cin >> name >> b >> c;\n\t\t\tif (mp.find(name) == mp.end()) {\n\t\t\t\tmp[name] = num;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tint myid = mp[name];\n\t\t\tget<0>(connects[myid]) = b;\n\t\t\tget<1>(connects[myid]) = myid;\n\t\t\tvector<int>vs;\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tif (mp.find(st) == mp.end()) {\n\t\t\t\t\tmp[st] = num;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tint opid = mp[st];\n\t\t\t\tvs.emplace_back(opid);\n\t\t\t\tget<2>(connects[myid]).emplace_back(opid);\n\t\t\t}\n\t\t}\n\t\tsort(connects.begin()+1, connects.end());\n\t\treverse(connects.begin()+1, connects.end());\n\t\tmap<int,int>convert;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tconvert[get<1>(connects[i])] = i;\n\t\t}\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto& j : get<2>(connects[i])) {\n\t\t\t\tj = convert[j];\n\t\t\t}\n\t\t}\n\t\tint a = get<0>(connects[N - 1]);\n\t\trests[N - 1] =a;\n\t\tfor (int i = N - 2; i >= 0; --i) {\n\t\t\trests[i] = rests[i + 1] + get<0>(connects[i]);\n\t\t}\n\t\tvector<pair<int, vector<int>>>newconnects;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tnewconnects.emplace_back(get<0>(connects[i]), get<2>(connects[i]));\n\t\t}\n\n\t\tvector<int>oks(N, true);\n\t\tgetans(0, 0, newconnects, oks);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define  _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#pragma comment (linker, \"/STACK:526000000\")\n\n#include \"bits/stdc++.h\"\n\nusing namespace std;\ntypedef string::const_iterator State;\n#define eps 1e-5L\n#define MAX_MOD 1000000007LL\n#define GYAKU 500000004LL\n#define seg_size 262144LL\n#define MOD 998244353LL\n#define pb push_back\n#define mp make_pair\ntypedef long long ll;\n#define REP(a,b) for(long long (a) = 0;(a) < (b);++(a))\n#define ALL(x) (x).begin(),(x).end()\n\n// geometry library\n\ntypedef complex<long double> Point;\ntypedef pair<complex<long double>, complex<long double>> Line;\n\ntypedef struct Circle {\n    complex<long double> center;\n    long double r;\n}Circle;\n\n//内積、 dot(a,b) = |a||b|cos()\nlong double dot(Point a, Point b) {\n    return (a.real() * b.real() + a.imag() * b.imag());\n}\n//外積、cross(a,b) = |a||b|sin()\nlong double cross(Point a, Point b) {\n    return (a.real() * b.imag() - a.imag() * b.real());\n}\n\n//線分と点の距離\nlong double Dist_Line_Point(Line a, Point b) {\n    if (dot(a.second - a.first, b - a.first) < eps) return abs(b - a.first);\n    if (dot(a.first - a.second, b - a.second) < eps) return abs(b - a.second);\n    return abs(cross(a.second - a.first, b - a.first)) / abs(a.second - a.first);\n}\n\n//線分の交差判定\nint is_intersected_ls(Line a, Line b) {\n    return (cross(a.second - a.first, b.first - a.first) * cross(a.second - a.first, b.second - a.first) < 0) &&\n        (cross(b.second - b.first, a.first - b.first) * cross(b.second - b.first, a.second - b.first) < 0);\n}\n\n//線分の交点\nPoint intersection_l(Line a, Line b) {\n    Point da = a.second - a.first;\n    Point db = b.second - b.first;\n    return a.first + da * cross(db, b.first - a.first) / cross(db, da);\n}\n\n//線分と線分の距離\nlong double Dist_Line_Line(Line a, Line b) {\n    if (is_intersected_ls(a, b) == 1) {\n        return 0;\n    }\n    return min({ Dist_Line_Point(a,b.first), Dist_Line_Point(a,b.second),Dist_Line_Point(b,a.first),Dist_Line_Point(b,a.second) });\n}\n\n//円と円の交点\npair<Point, Point> intersection_Circle_Circle(Circle a, Circle b) {\n    long double dist = abs(a.center - b.center);\n    assert(dist <= eps + a.r + b.r);\n    assert(dist+eps >= abs(a.r - b.r));\n    Point target = b.center - a.center;\n    long double pointer = target.real() * target.real() + target.imag() * target.imag();\n    long double aa = pointer + a.r * a.r - b.r * b.r;\n    aa /= 2.0L;\n    Point l{ (aa * target.real() + target.imag() * sqrt(pointer * a.r * a.r - aa * aa))/pointer,\n            (aa* target.imag() - target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer};\n    Point r{ (aa * target.real() - target.imag() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer,\n        (aa * target.imag() + target.real() * sqrt(pointer * a.r * a.r - aa * aa)) / pointer };\n    r = r + a.center;\n    l = l + a.center;\n    return mp(l, r);\n}\n\n//end of geometry\n\ntemplate<typename A>\nA pows(A val, ll b) {\n    assert(b >= 1);\n    A ans = val;\n    b--;\n    while (b) {\n        if (b % 2) {\n            ans *= val;\n        }\n        val *= val;\n        b /= 2LL;\n    }\n    return ans;\n}\n\ntemplate<typename A>\nclass Compressor {\npublic:\n    bool is_zipped = false;\n    map<A, ll> zipper;\n    map<ll, A> unzipper;\n    queue<A> fetcher;\n    Compressor(){\n        is_zipped = false;\n        zipper.clear();\n        unzipper.clear();\n    }\n    void add(A now) {\n        assert(is_zipped == false);\n        zipper[now] = 1;\n        fetcher.push(now);\n    }\n    void exec() {\n        assert(is_zipped == false);\n        int cnt = 0;\n        for (auto i = zipper.begin(); i != zipper.end(); ++i) {\n            i->second = cnt;\n            unzipper[cnt] = i->first;\n            cnt++;\n        }\n        is_zipped = true;\n    }\n    ll fetch() {\n        assert(is_zipped == true);\n        A hoge = fetcher.front();\n        fetcher.pop();\n        return zipper[hoge];\n    }\n    ll zip(A now) {\n        assert(is_zipped == true);\n        assert(zipper.find(now) != zipper.end());\n        return zipper[now];\n    }\n    A unzip(ll a) {\n        assert(is_zipped == true);\n        assert(a < unzipper.size());\n        return unzipper[a];\n    }\n};\n\ntemplate<typename A>\nclass Matrix {\npublic:\n    vector<vector<A>> data;\n    Matrix(vector<vector<A>> a) :data(a){\n\n    }\n    Matrix operator + (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = obj.data[i][q] + (this -> data[i][q]);\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator - (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data.size());\n        assert(obj.data[0].size() == this->data[0].size());\n        REP(i, obj.data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[i].size()) {\n                A hoge = this->data[i][q] - obj.data[i][q];\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix operator * (const Matrix obj) {\n        vector<vector<A>> ans;\n        assert(obj.data.size() == this->data[0].size());\n        REP(i, this -> data.size()) {\n            ans.push_back(vector<A>());\n            REP(q, obj.data[0].size()) {\n                A hoge = (this -> data[i][0]) * (obj.data[0][q]);\n                for(int t = 1;t < obj.data[i].size();++t){\n                    hoge += this -> data[i][t] * obj.data[t][q];\n                }\n                ans.back().push_back(hoge);\n            }\n        }\n        return Matrix(ans);\n    }\n    Matrix &operator *= (const Matrix obj) {\n        *this = (*this * obj);\n        return *this;\n    }\n    Matrix& operator += (const Matrix obj) {\n        *this = (*this + obj);\n        return *this;\n    }\n    Matrix& operator -= (const Matrix obj) {\n        *this = (*this - obj);\n        return *this;\n    }\n};\n\nclass modint {\npublic:\n    using u64 = std::uint_fast64_t;\n    u64 value = 0;\n    u64 mod;\n    modint(ll a, ll b): value(((a%b) + 2 * b) % b),mod(b) {\n\n    }\n    modint operator+(const modint rhs) const{\n        return modint(*this) += rhs;\n    }\n    modint operator-(const modint rhs) const{\n        return modint(*this) -= rhs;\n    }\n    modint operator*(const modint rhs) const {\n        return modint(*this) *= rhs;\n    }\n    modint operator/(const modint rhs) const{\n        return modint(*this) /= rhs;\n    }\n    modint& operator+=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value += rhs.value;\n        if (value >= mod) {\n            value -= mod;\n        }\n        return *this;\n    }\n    modint& operator-=(const modint rhs) {\n        assert(rhs.mod == mod);\n        if (value < rhs.value) {\n            value += mod;\n        }\n        value -= rhs.value;\n        return *this;\n    }\n    modint& operator*=(const modint rhs) {\n        assert(rhs.mod == mod);\n        value = (value *  rhs.value) % mod;\n        return *this;\n    }\n    modint& operator/=(modint rhs) {\n        assert(rhs.mod == mod);\n        ll rem = mod - 2;\n        while (rem) {\n            if (rem % 2) {\n                *this *= rhs;\n            }\n            rhs *= rhs;\n            rem /= 2LL;\n        }\n        return *this;\n    }\n};\n\nvoid init() {\n    iostream::sync_with_stdio(false);\n    cout << fixed << setprecision(20);\n}\n\nunsigned long xor128() {\n    static unsigned long x = 123456789, y = 362436069, z = 521288629, w = 88675123;\n    unsigned long t = (x ^ (x << 11));\n    x = y; y = z; z = w;\n    return (w = (w ^ (w >> 19)) ^ (t ^ (t >> 8)));\n}\n\n#define int ll\nvector<tuple<int, int, int>> inputs;\nint cnt[50];\nint dfs(int itr,int bad) {\n    if (itr == inputs.size()) return 0;\n    if (bad & (1LL << get<0>(inputs[itr]))) return dfs(itr + 1, bad);\n    if ((1LL << get<0>(inputs[itr]))&cnt[itr]) {\n        return max(dfs(itr + 1, bad | get<2>(inputs[itr])) + get<1>(inputs[itr]), dfs(itr + 1, bad));\n    }\n    return dfs(itr + 1, bad | get<2>(inputs[itr])) + get<1>(inputs[itr]);\n}\nvoid solve(){\n    while (true) {\n        inputs.clear();\n        int n;\n        cin >> n;\n        if (n == 0) return;\n        Compressor<string> zipper;\n        REP(i, n) {\n            string a;\n            cin >> a;\n            zipper.add(a);\n            int b;\n            cin >> b;\n            int c;\n            cin >> c;\n            inputs.push_back(make_tuple(-1, b, c));\n            REP(q, c) {\n                string a;\n                cin >> a;\n                zipper.add(a);\n            }\n        }\n        zipper.exec();\n        REP(i, n) {\n            get<0>(inputs[i]) = zipper.fetch();\n            int cnt = get<2>(inputs[i]);\n            get<2>(inputs[i]) = 0;\n            REP(q, cnt) {\n                get<2>(inputs[i]) |= (1LL << zipper.fetch());\n            }\n        }\n        sort(inputs.begin() + 1, inputs.end(), [](const auto& l, const auto& r) {\n            int cnt[2] = {};\n            REP(q, 50) {\n                if (get<2>(l) & (1LL << q)) cnt[0]++;\n                if (get<2>(r) & (1LL << q)) cnt[1]++;\n            }\n            return cnt[0] > cnt[1];\n            });\n        REP(i, 50) {\n            cnt[i] = 0;\n        }\n        for (int i = (int)inputs.size() - 2; i >= 0; --i) {\n            cnt[i] = cnt[i + 1] | (get<2>(inputs[i+1]));\n        }\n        cout << dfs(1, get<2>(inputs[0])) + get<1>(inputs[0]) << endl;\n    }\n}\n\n#undef int\nint main() {\n    init();\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "//#include\"bits/stdc++.h\"\n\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = (1 << 20) + 1;\nint cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nbool E[41][41];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tmemset(E, 0, sizeof(E));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << B[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\t\t\tmemset(cost, 0, sizeof(cost));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (!indx[mask]) {\n\t\t\t\t\trep(i, 0, n) {\n\t\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!indy[mask]) {\n\t\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[mask | (1 << i)] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tx -= dp[mask];\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> adj[50];\nint power[50];\nbool used[50];\nint ans, rest, sum;\nint N;\nvector<int> per;\nvoid dfs(int k_){\n  if(k_ == N){\n    ans = max(ans,  sum);\n    return ;\n  }\n  int k = per[k_];\n  //printf(\"%d:%d %d %d\\n\", k,sum , rest, ans);\n  if(sum + rest - 10 <= ans){\n    return;\n  }\n  bool usedtmp[50];\n  REP(i, 50) usedtmp[i] = used[i];\n  int sumtmp = sum;\n  int resttmp = rest;\n  if(!used[k]){\n    used[k] = true;\n    sum += power[k];\n    rest -= power[k];\n    FORIT(it, adj[k])if(!used[*it]){\n      rest -= power[*it];\n      used[*it] = true;\n    }\n    dfs(k_ + 1);\n    REP(i, 50) used[i] = usedtmp[i];\n    sum = sumtmp;\n    rest = resttmp;\n  }\n  if(k != 0){\n    if(!used[k])rest -= power[k];\n    used[k] = true;\n    dfs(k_ + 1);\n    rest += power[k];\n    used[k] = false;\n  }\n}\n\ntypedef pair<int, int> P;\nint main(){\n  while(cin>>N && N){\n    ans = 0, rest = 0, sum = 0;\n    REP(i, 50) adj[i].clear();\n    memset(used, 0, sizeof(used));\n    map<string, int> id;\n    vector<string> adjstr[50];\n    REP(i, N){\n      string s; cin>>s; id[s] = i;\n      cin>>power[i];\n      rest += power[i];\n      int k; cin>>k;\n      while(k--){\n        string str; cin>>str;\n        adjstr[i].push_back(str);\n      }\n    }\n    REP(i, N){\n      REP(j, adjstr[i].size()){\n        adj[i].push_back(id[adjstr[i][j]]);\n      }\n    }\n    vector<P> ps(N-1);\n    REP(i, N-1)ps[i] = P(-power[i+1], i+1);\n    sort(ps.begin(), ps.end());\n    per = vector<int>(N, 0);\n    REP(i, N-1) per[i+1] = ps[i].second;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nmap<string, int> idx;\nint B[40];\nbool NG[40][40];\nint dp1[1 << 20];\nint dp2[1 << 20];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tmemset(NG, 0, sizeof(NG));\n\t\tmemset(dp1, 0, sizeof(dp1));\n\t\tmemset(dp2, 0, sizeof(dp2));\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring A;\n\t\t\tcin >> A;\n\t\t\tif (idx.find(A) == idx.end()) idx[A] = cnt++;\n\t\t\tcin >> B[idx[A]];\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tstring D;\n\t\t\t\tcin >> D;\n\t\t\t\tif (idx.find(D) == idx.end()) idx[D] = cnt++;\n\t\t\t\tNG[idx[A]][idx[D]] = 1;\n\t\t\t}\n\t\t}\n\t\tint x = N / 2;\n\t\tint y = N - x;\n\t\tfor (int i = 1; i < (1 << x); i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint bit = 0;\n\t\t\t\tfor (int k = 0; k < x; k++) {\n\t\t\t\t\tif (j != k && !NG[j][k]) bit |= (1 << k);\n\t\t\t\t}\n\t\t\t\tdp1[i] = max(dp1[i], dp1[i ^ (1 << j)]);\n\t\t\t\tdp1[i] = max(dp1[i], dp1[i&bit] + B[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < (1 << y); i++) {\n\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint bit = 0;\n\t\t\t\tfor (int k = 0; k < y; k++) {\n\t\t\t\t\tif (j != k && !NG[j + x][k + x]) bit |= (1 << k);\n\t\t\t\t}\n\t\t\t\tdp2[i] = max(dp2[i], dp2[i ^ (1 << j)]);\n\t\t\t\tdp2[i] = max(dp2[i], dp2[i&bit] + B[j + x]);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint mask = 1;\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\tif (!NG[0][i]) mask |= (1 << i);\n\t\t}\n\t\tfor (int i = 1; i < (1 << x); i++) {\n\t\t\tint bit = (1 << y) - 1;\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\tfor (int k = 0; k < y; k++) {\n\t\t\t\t\tif (!NG[j][k + x]) tmp |= (1 << k);\n\t\t\t\t}\n\t\t\t\tbit &= tmp;\n\t\t\t}\n\t\t\tans = max(ans, dp1[i&mask] + dp2[bit]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tint N;\n\tvector<int> ps;\n\tvector<vector<int>> es;\n\tvector<bool> selected;\n\tvector<bool> canselect;\n\n\tint Mv;\t\n\tint must;\n\n\tvector<bool> change;\n\tvoid dfs(int v,int val){\n\t\tMv=max(Mv,val);\n\t\tif(v>=N)return;\n\t\tif(canselect[v]){\n\t\t\tvector<int> change;\n\t\t\tselect(v,change);\n\t\t\tdfs(v+1,val+ps[v]);\n\t\t\tunselect(v,change);\n\t\t}\n\t\tdfs(v+1,val);\n\t}\n\n\tvoid select(int v,vector<int>& change){\n\t\tselected[v]=true;canselect[v]=false;\n\t\tREP(i,es[v].size()){\n\t\t\tif(canselect[es[v][i]]){\n\t\t\t\tcanselect[es[v][i]]=false;\n\t\t\t\tchange.push_back(es[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid unselect(int v,vector<int>& change){\n\t\tselected[v]=false;canselect[v]=true;\n\t\tREP(i,change.size())canselect[change[i]]=true;\n\t}\n\n\tvoid run(){\n\t\twhile(true){\n\t\t\tcin >>N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> cs(N);\n\t\t\tmap<string,int> stoid;\n\t\t\tps=vector<int>(N);\n\t\t\tvector<vector<string>> ess(N);\n\t\t\tREP(i,N){\n\t\t\t\tcin >> cs[i] >> ps[i];stoid.insert(make_pair(cs[i],i));\n\t\t\t\t\n\t\t\t\tint k;cin >>k;\n\t\t\t\tREP(j,k) {\n\t\t\t\t\tstring s;cin >> s;ess[i].push_back(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tes=vector<vector<int>>(N);\n\t\t\tREP(i,N)REP(j,ess[i].size())es[i].push_back(stoid[ess[i][j]]);\n\t\t\n\t\t\tcanselect=vector<bool>(N,true);\n\t\t\tselected=vector<bool>(N);\n\t\t\t//自分\n\t\t\tvector<int> dummy;\n\t\t\tmust=ps[0];select(0,dummy);\n\t\t\t//孤立点\n\t\t\tREP(i,N)if(canselect[i] && es[i].size()==0){must+=ps[i];select(i,dummy);}\n\t\t\t\n\t\t\tMv=must;\n\t\t\tdfs(0,must);\n\n\t\t\tcout<< Mv<<endl;\n\t\t}\n\t}\n};\n int main(){\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tvi pow(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> pow[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tvector<ll> g(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tg[i] = 1ll << i;\n\t\t\tREP(j, nei[i].size())\n\t\t\t{\n\t\t\t\tg[i] |= 1ll << mp[nei[i][j]];\n\t\t\t}\n\t\t}\n\n\t\tvi ss(n + 1);\n\t\tREP(i, n) ss[i + 1] = ss[i] + pow[i];\n\n\t\tint ans = 0;\n\t\tstack<ll> st;\n\t\tst.push(1);\n\t\twhile (st.size())\n\t\t{\n\t\t\tll tmp = st.top();\n\t\t\tst.pop();\n\t\t\tint left = -1;\n\t\t\tll can = 0;\n\t\t\tint sum = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((tmp >> j) & 1)\n\t\t\t\t{\n\t\t\t\t\tchmax(left, j);\n\t\t\t\t\tsum += pow[j];\n\t\t\t\t\tcan |= g[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum + ss[n] - ss[left] <= ans) continue;\n\t\t\tchmax(ans, sum);\n\t\t\tFOR(j, left+1, n)\n\t\t\t{\n\t\t\t\tif ((can >> j) & 1) continue;\n\t\t\t\tll nx = tmp | (1ll << j);\n\t\t\t\tst.push(nx);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <map>\nusing namespace std;\n\nmap<string,int> dictionary;\n\nint dic(string name){\n\tif( dictionary.count(name) ) return dictionary[name];\n\telse{\n\t\tint t = dictionary.size();\n\t\treturn dictionary[name] = t;\n\t}\n}\n\nvector<int> g[40];\nint P[40];\n\nint dmg[40]={};\nint deg[40]={};\nint cover[40] = {};\n\nvoid cCover(int x,int v){\n\tcover[x]+= v;\n\tfor(int i = 0; i < g[x].size() ; i++){\n\t\tif( cover[g[x][i]] == 0 ){\n\t\t\tdeg[g[x][i]]--;\n\t\t\tdeg[x]--;\n\t\t\tdmg[g[x][i]] -= P[x];\n\t\t\tdmg[x] -= P[g[x][i]];\n\t\t}\n\t\tcover[g[x][i]] += v;\n\t\tif( cover[g[x][i]] == 0 ){\n\t\t\tdeg[g[x][i]]++;\n\t\t\tdeg[x]++;\n\t\t\tdmg[g[x][i]] += P[x];\n\t\t\tdmg[x] += P[g[x][i]];\t\t\t\n\t\t}\n\t}\n}\n\nint n;\nint maximum = 0;\nint current = 0;\n\nint dfs(){\n\tint allsum = 0;\n\tvector< pair<int,int> > good;\n\tfor(int i = 0 ; i < n ; i++){\t\t\n\t\tif( cover[i] == 0 ){\n\t\t\tallsum += P[i];\n\t\t\tgood.push_back(make_pair(dmg[i],i));\n\t\t}\n\t}\n\t\n\tif( current+allsum <= maximum ){\n\t\treturn 0;\n\t}else{\n\t\tmaximum = max(current,maximum);\n\t}\n\tsort(good.begin(),good.end());\n\tfor(int i = 0 ; i < good.size() ; i++){\n\t\tcCover(good[i].second,1);\n\t\tcurrent += P[good[i].second];\n\t\tdfs();\n\t\tcurrent -= P[good[i].second];\n\t\tcCover(good[i].second,-1);\n\t}\n\t\n}\n\nint main(){\n\twhile(cin >> n && n){\n\t\tdictionary.clear();\n\t\tfor(int i = 0 ; i < 40 ; i++){\n\t\t\tg[i].clear();\n\t\t\tdmg[i] = 0;\n\t\t\tdeg[i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring name;\n\t\t\tint power,num;\n\t\t\tcin >> name >> power >> num;\n\t\t\tP[dic(name)] = power;\n\t\t\tdeg[dic(name)] = num;\n\t\t\tfor(int j = 0 ; j < num ; j++){\n\t\t\t\tstring connect;\n\t\t\t\tcin >> connect;\n\t\t\t\tg[dic(name)].push_back(dic(connect));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\t\tdmg[i] += P[g[i][j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmaximum = 0;\n\t\tcurrent = P[0];\n\t\t\n\t\tcCover(0,1);\n\t\tdfs();\n\t\tcCover(0,-1);\n\t\t\n\n\t\t\n\t\tcout << maximum << endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n\nint n;\nstring vertex[45];\nint m[45];\nint power[45];\nstring adj[45][45];\nll graph[50];\n\nrandom_device seed_gen;\nmt19937 engine(seed_gen());\n\nvector<int> ary;\n\nint run(int n) {\n\tll cur = (1LL << n) - 1;\n\tshuffle(begin(ary) + 1, end(ary), engine);\n\trep(i, n) if (cur & (1LL << ary[i])) cur &= graph[ary[i]];\n\tint ret = 0;\n\trep(i, n) if(cur & (1LL << i)) ret += power[i];\n\treturn ret;\n}\n\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n){\n\t\t\tcin >> vertex[i] >> power[i];\n\t\t\tcin >> m[i];\n\t\t\trep(j,m[i]) cin >> adj[i][j];\n\t\t}\n\n\t\tmap<string,int> ref;\n\t\trep(i,n) ref[vertex[i]] = i;\t\n\n\t\tary.resize(n);\n\t\tiota(begin(ary),end(ary),0);\n\n\t\trep(i,n) graph[i] = (1LL << n) -1LL;\n\n\t\trep(i,n){\n\t\t\trep(j,m[i]){\n\t\t\t\tconst int idx = ref[adj[i][j]];\n\t\t\t\tgraph[i] &= ~(1LL << idx);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(loop,1000000) ans = max(ans,run(n));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#ifndef _WIN32\n#include<iostream>\n#endif \n#include<cmath>\n#include<iomanip>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<bitset>\nusing namespace std;\n\ntypedef long long LL;\n#define FOR(i,bg,ed) for(int i=(bg);i<(ed);i++)\n#define REP(i,n) FOR(i,0,n)\ntemplate<typename T> bool chmax(T &l, T r) {\n\tbool res = l < r;\n\tif (res) l = r;\n\treturn res;\n}\ntemplate<typename T> istream& operator>>(istream &is, vector<T> &v) {\n\tfor (auto &it : v)is >> it;\n\treturn is;\n}\n\nstruct cww {\n\tcww() {\n\t\tcout << fixed;\n\t\tcout << setprecision(10);\n\t}\n}star;\nint N;\ntypedef vector<int> V;\ntypedef vector<V> VV;\ntypedef vector<string> Vs;\ntypedef vector<Vs> VVs;\nVV G;\nV B;\nint bitdp[1 << 20];\nbool input() {\n\tcin >> N;\n\tif (N == 0)return false;\n\tG.assign(N, V(N, 0));\n\tB.assign(N, 0);\n\tmap<string, int> memo;\n\tVs A(N);\n\tVVs D(N);\n\tREP(i, N) {\n\t\tcin >> A[i]>>B[i];\n\t\tint C;\n\t\tcin >> C;\n\t\tREP(j, C) {\n\t\t\tstring s; cin >> s;\n\t\t\tD[i].push_back(s);\n\t\t}\n\t\tmemo[A[i]] = i;\n\t}\n\tREP(i, N) for(auto &it:D[i]){\n\t\tint j = memo[it];\n\t\tG[i][j] = 1;\n\t}\n\treturn true;\n}\nvoid sync(int n) {\n\tint sz = 1 << n;\n\n\tREP(bit, sz) {\n\t\tREP(i, n)\n\t\t\tif (bit&(1 << i));\n\t\t\telse chmax(bitdp[bit | (1 << i)],bitdp[bit]);\n\t}\n}\n\nint main() {\n\twhile (input()) {\n\t\tint m = N/2;\n\t\tint n = N -m;\n\t\tint res = 0;\n\t\tREP(bit, (1<<n))bitdp[bit] = 0;\n\t\tconst int mask = (1 << n) - 1;\n\t\tV x(n,0);\n\t\tV y(m,0);\n\t\tV z(m, mask);\n\t\tREP(i, n) {\n\t\t\tREP(j, n)if (i != j&&G[i][j] == 1)x[i] |= (1 << j);\n\t\t}\n\t\tREP(i, m) {\n\t\t\tREP(j, m)if (i != j&&G[i+n][j+n] == 1)y[i] |= (1 << j);\n\t\t}\n\t\tREP(i, m) {\n\t\t\tREP(j, n)if (G[i + n][j])z[i] -= (1 << j);\n\t\t}\n\t\tREP(bit, (1 << n))if(bit&1) {\n\t\t\tbool flag = true;\n\t\t\tint cost = 0;\n\t\t\tREP(i,n)\n\t\t\t\tif (bit&(1 << i)) {\n\t\t\t\t\tcost += B[i];\n\t\t\t\t\tif (bit&x[i]) {\n\t\t\t\t\t\tflag = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\tif (flag) {\n\t\t\t\tbitdp[bit] = cost;\n\t\t\t\tchmax(res, cost);\n\t\t\t}\n\t\t}\n\t\tsync(n);\n\n\t\tREP(bit, (1 << m)) {\n\t\t\tbool flag = true;\n\t\t\tint cost = 0;\n\t\t\tint ans = mask;\n\t\t\tREP(i, m) {\n\t\t\t\tif (bit&(1 << i)) {\n\t\t\t\t\tcost += B[i + n];\n\t\t\t\t\tif (bit&y[i]) {\n\t\t\t\t\t\tflag = false; break;\n\t\t\t\t\t}\n\t\t\t\t\tans &= z[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (flag)if(ans&1) {\n\t\t\t\tchmax(res, cost + bitdp[ans]);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\trest -= names[pos].second;\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tint rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\trest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\trest = rest1;\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tans = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tlist.push_back(a);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tbuf.insert(make_pair(name, move(list)));\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second,mb-names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <functional>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct Dict {\n    map<string,int> dict;\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        int id = dict.size();\n        return dict[str] = id;\n    }\n};\n\nstruct DisjointSet/*{{{*/\n{\n  vector<int> parent;\n\n  int root(int x)\n  {\n    if (parent[x] < 0) {\n      return x;\n    } else {\n      parent[x] = root(parent[x]);\n      return parent[x];\n    }\n  }\n\n  explicit DisjointSet(int n) : parent(n, -1) {}\n\n  bool unite(int x, int y)\n  {\n    const int a = root(x);\n    const int b = root(y);\n    if (a != b) {\n      if (parent[a] < parent[b]) {\n        parent[a] += parent[b];\n        parent[b] = a;\n      } else {\n        parent[b] += parent[a];\n        parent[a] = b;\n      }\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  bool find(int x, int y) { return root(x) == root(y); }\n  int size(int x) { return -parent[root(x)]; }\n};/*}}}*/\n\nint dfs(int pos, LL used, const vector<LL> &neighbors, const vector<int> &scores) {\n    if(pos == (int)scores.size()) return 0;\n    int score = 0;\n    if(!(used & (1LL<<pos))) {\n        score = max(score, dfs(pos+1, used | neighbors[pos] | (1LL<<pos), neighbors, scores) + scores[pos]);\n    }\n    if((used & (1LL<<pos)) || (used & neighbors[pos]) != neighbors[pos]) {\n        score = max(score, dfs(pos+1, used, neighbors, scores));\n    }\n\n    return score;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<LL> neighbors(N, 0);\n        vector<int> scores(N, 0);\n        DisjointSet group(N);\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string name;\n            int score, ncnt;\n            cin >> name >> score >> ncnt;\n            const int cid = dict.get(name);\n            scores[cid] = score;\n            while(ncnt--) {\n                string nname;\n                cin >> nname;\n                const int nid = dict.get(nname);\n                group.unite(cid, nid);\n                neighbors[cid] |= 1LL<<nid;\n            }\n        }\n\n        cout << dfs(1, neighbors[0] | 1, neighbors, scores) + scores[0] << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nmap<string,int> m;\nint idx=0;\nvector<int> G[101];\nvector<string> CS[101];\nstring names[101];\nint strong[101];\nbool used[101];\nint optNum;\n\n// 現在選べるものから選ぶ\nvoid dfs(int idx,int sum){\n  if(idx==N){\n    optNum=max(optNum,sum);\n    return;\n  }\n  int allSum=0;\n  bool cur[50];\n  for(int i=0;i<N;i++){\n    cur[i]=used[i];\n    if(!used[i])allSum+=strong[i];\n  }\n  if(allSum+sum<=optNum)return;\n  if(idx!=0)dfs(idx+1,sum);\n  if(!used[idx]){\n    used[idx]=true;\n    for(int j=0;j<(int)G[idx].size();j++){\n      int to=G[idx][j];\n      used[to]=true;\n    }\n    dfs(idx+1,sum+strong[idx]);\n    for(int j=0;j<N;j++)used[j]=cur[j];\n  }\n  // for(int i=0;i<N;i++){\n  //   if(used[i])continue;\n  //   used[i]=true;\n  //   for(int j=0;j<(int)G[i].size();j++){\n  //     int to=G[i][j];\n  //     used[to]=true;\n  //   }\n  //   dfs(idx+1,sum+strong[i]);\n  //   for(int j=0;j<N;j++)used[j]=cur[j];\n  // }\n}\n\nint main(){\n  while(cin>>N&&N){\n    idx=0;\n    optNum=-1;\n    for(int i=0;i<101;i++){\n      G[i].clear();\n      CS[i].clear();\n    }\n    m.clear();\n    for(int i=0;i<N;i++){\n      cin>>names[i]>>strong[i];\n      int C;\n      cin>>C;\n      for(int j=0;j<C;j++){\n\tstring s;\n\tcin>>s;\n\tif(m.count(s)==0)m[s]=idx++;\n\tCS[i].push_back(s);\n      }\n    }\n    for(int i=0;i<N;i++)\n      m[names[i]]=i;\n    for(int i=0;i<N;i++)\n      for(int j=0;j<(int)CS[i].size();j++)\n\tG[m[names[i]]].push_back(m[CS[i][j]]);\n    memset(used,0,sizeof(used));\n    // for(int i=0;i<(int)G[0].size();i++)\n    //   used[G[0][i]]=true;\n    // used[0]=true;\n    dfs(0,0);\n    cout<<optNum<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nvector< vector<int> > G;\nvector<int> B;\nint N;\n\nint solve(int v, long long int t){\n  if(v >= B.size() || t == (1LL<<N) - 1) return 0;\n  int ret = 0;\n  if(!(t>>v & 1)){\n    long long t_ = t | (1LL<<v);\n    if(G[v].empty()) return B[v] + solve(v+1,t_);\n    if(G[v].size() == 1 && B[G[v][0]] <= B[v]) return B[v] + solve(v+1,t_);\n    for(int i = 0; i < G[v].size(); ++i) t_ |= 1LL<<G[v][i];\n    ret = max(ret, B[v] + solve(v+1,t_));\n  }\n  ret = max(ret, solve(v+1,t));\n  return ret;\n}\n\nint main(){\n  while(cin >> N, N){\n    map<string,int> M;\n    vector< vector<string> > D(N);\n    string a;\n    B = vector<int>(N);\n    int c;\n    for(int i = 0; i < N; ++i){\n      cin >> a >> B[i] >> c;\n      M[a] = i;\n      string d;\n      for(int j = 0; j < c; ++j){\n        cin >> d;\n        D[i].push_back(d);\n      }\n    }\n    G = vector< vector<int> >(N);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < D[i].size(); ++j){\n        G[i].push_back(M[D[i][j]]);\n      }\n    }\n    long long int t = 1LL;\n    for(int i = 0; i < G[0].size(); ++i) t |= 1LL<<G[0][i];\n    cout << B[0] + solve(0,t) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cassert>\nusing namespace std;\n#define MAX 41\n#define TEST 0\n\ntypedef long long int ll;\n\nint n;\nmap<string,int> names;\nint b[MAX],c[MAX];\nstring ds[MAX][MAX];\nint graph[MAX][MAX];\n\n\nint rmax;\nll rmaxs;\n/**\n O(n^2)\n */\nbool isClique(ll bits){\n    for(int i=0;i<n;i++){\n        if(bits&(1LL<<i)){\n            for(int j=0;j<n;++j){\n                if(bits&(1LL<<j)){\n                    if(graph[i][j]==0&&i!=j){\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n    return true;\n}\nvoid rec(ll bits,int sum){//gradually elim-ing vertices\n    if(sum<=rmax||sum<=0){\n        return;\n    }\n    if((bits&1)==0){//vertex 0 is not in the set\n        return;\n    }\n    if(isClique(bits)){\n        rmax=max(rmax,sum);\n        rmaxs=bits;\n        return;\n    }\n    //not clique\n    for(int i=0;i<n;i++){\n        if((bits&(1LL<<i))==0){\n            continue;\n        }\n        for(int j=i+1;j<n;j++){\n            if((bits&(1LL<<j))==0){\n                continue;\n            }\n            if(!graph[i][j]){\n                rec(bits&~(1LL<<i),sum-b[i]);\n                rec(bits&~(1LL<<j),sum-b[j]);\n                return;\n            }\n        }\n    }\n    assert((\"Error unreachable code\",0));\n}\n\n\nint main(void){\n    while(cin>>n&&n){\n        int sum=0;\n        for(int i=0;i<n;i++){\n            fill_n(graph[i],n,1);\n        }\n        for(int i=0;i<n;i++){\n            string a;\n            cin>>a>>b[i]>>c[i];\n            sum+=b[i];\n            names.insert(pair<string,int>(a,i));\n            for(int j=0;j<c[i];j++){\n                string t;\n                cin>>t;\n                ds[i][j]=t;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int d=names[ds[i][j]];\n                graph[i][d]=0;\n            }\n            graph[i][i]=0;\n        }\n        if(TEST){\n            for(int i=0;i<n;i++){\n                for(int j=0;j<n;j++){\n                    cout<<graph[i][j]<<\" \";\n                }\n                cout<<\":\"<<b[i]<<endl;\n            }\n        }\n        rmax=0;\n        rmaxs=0;\n        rec((1LL<<n)-1,sum);\n        cout<<rmax<<endl;\n        if(TEST){\n            cout<<\"rmaxs\"<<hex<<rmaxs<<dec<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i=j; i<k;++i)\n#define rep(i,j) reps(i,0,j)\n#define pb emplace_back\n#define mk make_pair\n\nint n;\nvector<string> a;\nvector<int> b;\nvector<vector<string>> d;\nvector<vector<int>> g;\n\ntypedef long long ll;\n\nint dfs(int i, ll s) {\n\tif(i == n) {\n\t\treturn 0;\n\t}\n\n\tif((s >> i) & 1) {\n\t\treturn dfs(i + 1, s);\n\t}\n\n\tint ret = 0;\n\n\tif(i != 0 && !(g[i].size() == 1 && ((s >> g[i][0]) & 1))) {\n\t\tret = dfs(i + 1, s);\n\t}\n\n\t{\n\t\tll ns = s | 1LL << i;\n\t\tfor(int v : g[i]) {\n\t\t\tns = ns | (1LL << v);\n\t\t}\n\n\t\tret = max(ret, dfs(i + 1, ns) + b[i]);\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\ta = vector<string>(n);\n\t\tb = vector<int>(n);\n\t\td = vector<vector<string>>(n);\n\n\t\trep(i, n) {\n\t\t\tint c;\n\t\t\tcin >> a[i] >> b[i] >> c;\n\t\t\td[i].resize(c);\n\n\t\t\trep(j, c) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> m;\n\t\trep(i, n) {\n\t\t\tm.insert(make_pair(a[i], m.size()));\n\t\t}\n\n\t\tg = vector<vector<int>>(n);\n\n\t\trep(i, n) {\n\t\t\tfor(auto to : d[i]) {\n\t\t\t\tg[i].push_back(m[to]);\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(0, 0) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n;\nint main(){\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs name(n);\n\t\tvi b(n),co(n);\n\t\tvector<vs>in(n);\n\t\trep(i,n){\n\t\t\tcin>>name[i]>>b[i]>>co[i];\n\t\t\tma[name[i]]=1;\n\t\t\tin[i]=vs(co[i]);\n\t\t\trep(j,co[i]){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tma[in[i][j]]=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\trep(i,n)ma[name[i]]=i;\n\t\n\t\tvi A(n);\n\t\trep(i,n)rep(j,in[i].size()){\n\t\t\tint from=ma[name[i]],to=ma[in[i][j]];\n\t\t\tA[from]|=1<<to;\n\t\t}\n\t\tint N=n/2,nN=n-N;\n\t\t\n//\t\trep(i,n){\n//\t\t\tcout<<name[i]<<\" \";\n//\t\t\trep(j,n)cout<<((A[i]&1<<j)>>j)<<\" \";cout<<endl;\n//\t\t}\n\t\tvi dp(1<<nN);\n\t\trep(i,1<<nN){\n\t\t\tbool h=true;\n\t\t\trep(j,nN)if((i&1<<j)&&((i&A[j+N]>>N)))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,nN)if(i&1<<j)sum+=b[N+j];\n\t\t\t\tdp[i]=sum;\n\t\t\t}\n\t\t}\n\t\trep(i,1<<nN)rep(j,nN)if((i&1<<j)==0)\n\t\t\tdp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n\t\t\n\t\tint out=0;\n\t\trep(i,1<<N)if(i&1){\n\t\t\tbool h=true;\n\t\t\trep(j,N)if((i&1<<j)&&(i&A[j]))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,N)if(i&1<<j)sum+=b[j];\n\t\t\t\tt=(1<<nN)-1;\n\t\t\t\trep(j,N)if((i&1<<j))t&=~(A[j]>>N);\n\t\t\t\tout=max(out,sum+dp[t]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], ans;\n\nset<ll> memo;\n\nvoid dfs(ll S){\n\n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  int cnt=0, sum=0;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1<<i))) continue;\n\n    sum+=cost[i];\n    \n    for(int j=i+1;j<n;j++){\n      if(!(S&(1<<j))) continue;\n      if(!G[i][j]) cnt++;\n    }\n    \n  }\n\n  int node=__builtin_popcount(S);\n  \n  if(cnt==node*(node-1)/2){\n    ans=max(ans,sum);\n    return ;\n  }\n\n  for(int i=1;i<n;i++)\n    for(int j=i;j<n;j++){\n      \n      int nS=S;\n\n      for(int k=i;k<=j;k++) nS=nS&(~(1<<k));\n\n      dfs(nS);\n      \n    }\n  \n}\n\nint main(){\n  \n  while(1)  {\n    \n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cnt=0;\n\n    memset(G,0,sizeof(G));\n    \n    for(int i=0;i<n;i++){\n\n      string s;\n      cin>>s;\n\n      if(!num.count(s)) num[s]=cnt++;\n      \n      int a,b;\n      cin>>a>>b;\n      \n      cost[num[s]]=a;\n\n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n\n    ans=0;\n\n    memo.clear();\n    \n    dfs((1<<n)-1);\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<ll> power;\nvector<bool> de;\nvector<ll> flag;\n\nvoid preorder(ll p,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tused[p]=true;\n\tpreo.pb(p);\n\tflag[p]=(ll)preo.size();\n\tbool upd=false;\n\tREP(i,(ll)adj[p].size()) if(!used[adj[p][i]]) {\n\t\tupd=true;\n\t\tpreorder(adj[p][i],used,preo,adj);\n\t}\n\tde[p]=!upd;\n}\n\nvoid input(vector<vector<ll>>& adj) {\n\tmap<string,ll> dict;\n\tll cnt=0;\n\tREP(i,n) {\n\t\tstring a;\n\t\tll b,c;\n\t\tcin>>a>>b>>c;\n\t\tif(dict.count(a)==0) {\n\t\t\tdict[a]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p=dict[a];\n\t\tpower[dict[a]]=b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(dict.count(t)==0) {\n\t\t\t\tdict[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tadj[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx,vector<int>& used,vector<ll>& preo,vector<vector<ll>>& adj,ll sum,vector<vector<ll>>& ban) {\n\tif(idx==(ll)preo.size()) {\n\t\treturn sum;\n\t}\n\tif(used[preo[idx]]==0) return dfs(idx+1,used,preo,adj,sum,ban);\n\tll ret=0;\n\tif(preo[idx]!=0&&!de[preo[idx]]&&(ll)ban[preo[idx]].size()!=0) {\n\t\tused[preo[idx]]=0;\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum,ban));\n\t}\n\tused[preo[idx]]=1;\n\tvector<bool> buf((ll)ban[preo[idx]].size());\n\tREP(i,buf.size()) {\n\t\tbuf[i]=used[ban[preo[idx]][i]];\n\t\tused[ban[preo[idx]][i]]=0;\n\t}\n\tret=max(ret,dfs(idx+1,used,preo,adj,sum+power[preo[idx]],ban));\n\tREP(i,buf.size()) {\n\t\tused[ban[preo[idx]][i]]=buf[i];\n\t}\n\tused[preo[idx]]=-1;\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tde.resize(n);\n\tflag.resize(n);\n\tvector<vector<ll>> adj(n);\n\tinput(adj);\n\tvector<bool> used(n,false);\n\tvector<vector<ll>> preo;\n\tREP(i,n) if(!used[i]) {\n\t\tvector<ll> v;\n\t\tpreorder(i,used,v,adj);\n\t\tpreo.pb(v);\n\t}\n\tvector<int> used2(n,-1);\n\tll ans=0;\n\tvector<vector<ll>> ban(n);\n\tREP(i,n) REP(j,(ll)adj[i].size()) {\n\t\tif(flag[adj[i][j]]>flag[i]) ban[i].pb(adj[i][j]);\n\t};\n\tREP(i,preo.size()) ans+=dfs(0,used2,preo[i],adj,0,ban);\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\nint n;\nint b[44],c[44];\nstring d[44][44];\nvector<int> g[44];\nint dame[44];\nll ans=0,sum=0;\n\nvoid dfs(int v,ll ns){\n  if(v==n){\n    maxch(ans,ns);\n    return ;\n  }\n  \n  ll asum=0;\n  repl(i,v,n){\n    if(!dame[i])asum+=b[i];\n  }\n  if(asum+ns<ans)return ;\n  if(dame[v]==0){ // use\n    dame[v]++;\n    for(int nv:g[v]){\n      dame[nv]++;\n    }\n    dfs(v+1,ns+b[v]);\n    for(int nv:g[v]){\n      dame[nv]--;\n    }\n    dame[v]--;\n  }\n  // unuse\n  dfs(v+1,ns);\n  return ;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    rep(i,44)g[i].clear();\n    map<string,int> idx;\n    cin>>n;\n    if(n==0)break;\n    ans=sum=0;\n    rep(i,n){\n      string name;\n      cin>>name>>b[i]>>c[i];\n      idx[name]=i;\n      sum+=b[i];\n      rep(j,c[i]){\n        cin>>d[i][j];\n      }\n    }\n    rep(i,n){\n      rep(j,c[i]){\n        int nv=idx[d[i][j]];\n        g[i].pb(nv);\n        //printf(\"(%d %d)\\n\", i,nv);\n      }\n    }\n    memset(dame,0,sizeof(dame));\n    dame[0]++;\n    for(int v:g[0]){\n      dame[v]++;\n    }\n    dfs(1,0);\n    cout<<ans+b[0]<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\ntypedef pair<long long,int> P;\nint str[40];\nvector<string> se[40];\nvector<int> e[40];\nmap<string,int> ct;\nmap<long long,int> dp[2];\nint main(){\n    int n;\n    int i,j;\n    while(1){\n    scanf(\"%d\",&n);\n    if(n==0)return 0;\n    dp[0].clear();\n    dp[1].clear(); \n    ct.clear();\n    for(i=0;i<n;i++){\n        se[i].clear();\n        e[i].clear();\n    }\n    for(i=0;i<n;i++){\n        char s[20];\n        string name;\n        scanf(\" %s\",s);\n        name.append(s);\n        ct[name]=i;\n        int a,b;\n        scanf(\"%d %d\",&a,&b);\n        str[i]=a;\n        for(j=0;j<b;j++){\n            name.clear();\n            scanf(\" %s\",s);\n            name.append(s);\n            se[i].push_back(name);\n        }\n    }\n    for(i=0;i<n;i++){\n        for(j=0;j<se[i].size();j++){\n            e[i].push_back(ct[se[i][j]]);\n        }\n    }\n    long long use=0;\n    for(j=0;j<e[0].size();j++)use|=(long long)1<<(e[0][j]-1);\n    dp[1][use]=str[0];\n    for(i=1;i<n;i++){\n        long long use=0;\n        for(j=0;j<e[i].size();j++)if(e[i][j]>=i+1)use|=(long long)1<<(e[i][j]-i-1);\n        dp[(i+1)%2].clear();\n        map<long long,int>::iterator it;\n        for(it=dp[i%2].begin();it!=dp[i%2].end();it++){\n            P p=*it;\n            long long used=p.first;\n            int mx=p.second;\n            dp[(i+1)%2][used>>1]=max(dp[(i+1)%2][used>>1],mx);\n            if(!(used&1))dp[(i+1)%2][(used>>1)|use]=max(dp[(i+1)%2][(used>>1)|use],mx+str[i]);\n        }\n    }\n    printf(\"%d\\n\",dp[n%2][0]);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <iostream>\n#include <algorithm>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <utility>\n#include <cctype>\n#include <numeric>\nusing namespace std;\n\n#define rep(i,n) for(int (i)=0; (i)<(int)(n); ++(i))\n#define foreach(c,i) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n\nconst int kN = 42;\nint N;\nint B[kN];\nlong long C[kN];\ntypedef pair<int,int> P;\n\nvoid print(long long l, int n) {\n  string s;\n  rep(i,n) s += (l >> i & 1) ? '1' : '0';\n  cout << s << endl;\n}\n\nint solve() {\n  const int half = N / 2;\n  int ret = 0;\n  \n  // 開いているビット, 最大値 のペアを作成\n  map<int,int> hash;\n  \n  // 前半分を列挙\n  for (int S = 1; S < (1 << half); ++S) {\n    if (!(S & 1)) continue;\n    // 整合性チェック と コストを求める\n    bool ok = true;\n    int cost = 0;\n    long long t = 0;\n    for (int i = 0; i < half && ok; ++i) {\n      if (S >> i & 1) {\n        if (!(t >> i & 1)) {\n          t |= C[i];\n          cost += B[i];\n        }\n        else {\n          ok = false;\n        }\n      }\n    }\n    if (!ok) continue;\n    // 残りの空いているビットを列挙\n    int zeros = 0;\n    for (int i = 0; i < N - half; ++i) {\n      if (!(t >> (i + half) & 1))\n        zeros |= (1<<i);\n    }\n    hash[zeros] = max(hash[zeros], cost);\n    // コスト更新\n    ret = max(ret, cost);\n  }\n  \n  vector<P> vp;\n  foreach(hash,it) {\n    vp.push_back(P(it->second, it->first));\n  }\n  sort(vp.begin(), vp.end(), greater<P>());\n\n  // 後ろ半分を列挙\n  for (int S = 0; S < (1 << (N - half)); ++S) {\n    // 整合性確認\n    bool ok = true;\n    long long t = 0;\n    int cost = 0;\n    for (int i = 0; i < (N - half) && ok; ++i) {\n      if (S >> i & 1) {\n        if (!(t >> (i + half) & 1)) {\n          t |= C[i+half];\n          cost += B[i+half];\n        }\n        else {\n          ok = false;\n        }\n      }\n    }\n    if (!ok) continue;\n    // コスト更新\n    rep(i,vp.size()) {\n      if ((vp[i].second | S) != vp[i].second) continue;\n      ret = max(ret, vp[i].first + cost);\n      break;\n    }\n  }\n  return ret;\n}\n\nvoid input() {\n  map<string,int> hash;\n  string a, d;\n  int b, c, cnt = 0;\n  memset(C, 0, sizeof C);\n\n  rep(i,N) {\n    cin >> a >> b >> c;\n    if (hash.count(a) == 0) {\n      hash[a] = cnt++;\n    }\n    B[hash[a]] = b;\n    rep(j,c) {\n      cin >> d;\n      if (hash.count(d) == 0) {\n        hash[d] = cnt++;\n      }\n      C[hash[a]] += 1LL << hash[d];\n    }\n  }\n}\n\nint main() {\n  ios_base::sync_with_stdio(false);\n  while (cin >> N, N) {\n    input();\n    cout << solve() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nvector<string> list[40];\nstring name[40];\nint n, w[40], sum;\nvector<vi> e;\nbool v[40], ok[40];\n\nvoid dfs(int c, vector<pi> &o){\n\to.pb(mp(w[c], c));\n\tv[c] = 1;\n\tok[c] = 1;\n\teach(i, e[c]) if(!v[*i]) dfs(*i, o);\n}\nvoid rec(int c, int cur, const vector<pi> &o){\n\tint next = -1, tmp = 0;\n\tfor(int i = o.size() - 1; i >= c; i--) if(ok[o[i].second]){\n\t\tnext = o[i].second;\n\t\ttmp += o[i].first;\n\t}\n\tif(cur + tmp <= sum) return;\n\tif(next < 0){\n\t\tsum = cur + tmp;\n\t\treturn;\n\t}\n\tif(ok[o[c].second]){\n\t\tbool ok2[40];\n\t\trep(i, n) ok2[i] = ok[i];\n\t\teach(i, e[o[c].second]) ok[*i] = 0;\n\t\tok[o[c].second] = 0;\n\t\trec(c + 1, cur + o[c].first, o);\n\t\trep(i, n) ok[i] = ok2[i];\n\t}\n\tif(o[c].second != 0) rec(c + 1, cur, o);\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(v, 0, sizeof(v));\n\t\te.clear(); e.resize(n);\n\t\tmap<string, int> id;\n\t\trep(i, n){\n\t\t\tint k;\n\t\t\tcin >> name[i] >> w[i] >> k;\n\t\t\tlist[i].clear(); list[i].resize(k);\n\t\t\trep(j, k) cin >> list[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, list[i].size()) e[i].pb(id[list[i][j]]);\n\t\t\n\t\tint ans = 0;\n\t\trep(i, n) if(!v[i]){\n\t\t\tvector<pi> ord;\n\t\t\tdfs(i, ord);\n\t\t\tsort(all(ord), greater<pi>());\n\t\t\tsum = 0;\n\t\t\trec(0, 0, ord);\n\t\t\tans += sum;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nstring s[50],t;\nint n,a[50],x,ans,rui[50];\nvector<string>v[50];\nset<string>st[50];\nbool used[50];\nmap<string,int>m;\nvoid dfs(int d,int p){\n    if(used[d]){\n        dfs(d+1,p);\n        return ;\n    }\n    if(d==n)ans=max(ans,p);\n    else{\n        if(rui[d]+p<=ans)return ;\n        vector<int>vv;\n        r(i,v[d].size()){\n            if(!used[m[v[d][i]]])\n              used[m[v[d][i]]]=1,\n              vv.push_back(m[v[d][i]]);\n        }\n        dfs(d+1,p+a[d]);\n        r(i,vv.size())used[vv[i]]=0;\n        if(rui[d]+p<=ans)return ;\n        dfs(d+1,p);\n    }\n}\nint main(){\n    while(cin>>n,n){\n        m.clear();\n        ans=0;\n        memset(used,0,sizeof(used));\n        r(i,50)v[i].clear();\n        r(i,n){\n            cin>>s[i];\n            cin>>a[i]>>x;\n            r(j,x){\n                cin>>t;\n                v[i].push_back(t);\n            }\n            m[s[i]]=i;\n        }\n        rui[n-1]=a[n-1];\n        for(int i=n-2;i>=0;i--)\n            rui[i]=rui[i+1]+a[i];\n        used[0]=1;\n        r(i,v[0].size()){\n            used[m[v[0][i]]]=1;\n        }\n        dfs(1,a[0]);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\n\ntypedef long long int64;\n\nint N, V[45];\nbool G[45][45];\nint64 NG[45];\nint sum[45];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[fake] <= beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nsigned main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nclass Main{\n\tpublic:\n\tvector<int> g[40];\n\tint B[40];\n\tmap<string,int> dic;\n\tint get(string x){\n\t\tif( dic.count(x) ) return dic[x];\n\t\tint t = dic.size();\n\t\treturn dic[x] = t;\n\t}\n\n\tint N;\n\tlong long kill[40];\n\tint answer;\n\tint maximum;\n\tint dfs(long long cond){\n\t\tint killnum = -1;\n\t\tint id = -1;\n\t\tint allsum = 0;\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tif( !(cond >> i & 1) ){\n\t\t\t\tint killtmp = __builtin_popcountll(kill[i]&~cond);\n\t\t\t\tif( killtmp > killnum ){\n\t\t\t\t\tkillnum = killtmp;\n\t\t\t\t\tid = i;\n\t\t\t\t}\n\t\t\t\tallsum += B[i];\n\t\t\t}\n\t\t}\n\t\tif( answer + allsum <= maximum ) return 0;\n\t\tif( killnum == -1 ){\n\t\t\tmaximum = answer;\n\t\t}else{\n\t\t\tanswer += B[id];\n\t\t\tdfs(cond|kill[id]|(1ll<<id));\n\t\t\tanswer -= B[id];\n\t\t\tdfs(cond|(1ll<<id));\n\t\t}\n\t}\n\tint main(){\n\t\tanswer = maximum = 0;\n\t\tfor(int i = 0 ; i < 40 ; i++) kill[i] = 0;\n\t\tif( cin >> N, N == 0 ) exit(0);\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tstring A; int id,C;\n\t\t\tcin >> A;\n\t\t\tid = get(A);\n\t\t\tcin >> B[id] >> C;\n\t\t\tfor(int j = 0 ; j < C ; j++){\n\t\t\t\tstring h; cin >> h;\n\t\t\t\tint id2 = get(h);\n\t\t\t\tg[id].push_back(id2);\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < N ; i++){\n\t\t\tfor(int j = 0 ; j < g[i].size() ; j++)\n\t\t\t\tkill[i] |= 1ll<<g[i][j];\n\t\t}\n\t\tanswer = B[0];\n\t\tdfs(kill[0]|1);\n\t\tcout << maximum << endl;\n\t}\n};\n\nint main(){\n\twhile(1){\n\t\tMain().main();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n;\nint main(){\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs name(n);\n\t\tvi b(n),co(n);\n\t\tvector<vs>in(n);\n\t\trep(i,n){\n\t\t\tcin>>name[i]>>b[i]>>co[i];\n\t\t\tma[name[i]]=1;\n\t\t\tin[i]=vs(co[i]);\n\t\t\trep(j,co[i]){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tma[in[i][j]]=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\trep(i,n)ma[name[i]]=i;\n\t\n\t\tvi A(n);\n\t\trep(i,n)rep(j,in[i].size()){\n\t\t\tint from=ma[name[i]],to=ma[in[i][j]];\n\t\t\tA[from]|=1<<to;\n\t\t}\n\t\tint N=n/2,nN=n-N;\n\t\t\n//\t\trep(i,n){\n//\t\t\tcout<<name[i]<<\" \";\n//\t\t\trep(j,n)cout<<((A[i]&1<<j)>>j)<<\" \";cout<<endl;\n//\t\t}\n\t\tvi dp(1<<nN);\n\t\trep(i,1<<nN){\n\t\t\tbool h=true;\n\t\t\trep(j,nN)if((i&1<<j)&&((i&A[j+N]>>N)))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,nN)if(i&1<<j)sum+=b[N+j];\n\t\t\t\tdp[i]=max(dp[i],sum);\n\t\t\t}\n\t\t\trep(j,nN)if((i&1<<j)==0)\n\t\t\t\tdp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n\t\t}\n\t\t\n\t\tint out=0;\n\t\trep(i,1<<N)if(i&1){\n\t\t\tbool h=true;\n\t\t\trep(j,N)if((i&1<<j)&&(i&A[j]))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,N)if(i&1<<j)sum+=b[j];\n\t\t\t\tt=(1<<nN)-1;\n\t\t\t\trep(j,N)if((i&1<<j))t&=~(A[j]>>N);\n\t\t\t\tout=max(out,sum+dp[t]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n/*\nint n,m;\nvi A,B;\nint dp[52][52][110][2][3];\nint mem[52][52][110][2][3];\nint f(int a,int b,int co,int tu,int pas){\n    if(mem[a][b][co][tu][pas]+inf)return mem[a][b][co][tu][pas];\n\tif(pas==3)\n\t\n    int A,B,TU=(tu+co)%2;\n    if(!tu)A=a+(1+co)/2,B=b+co/2;\n    else A=a+co/2,B=b+(1+co)/2;\n    if(TU==0){\n        int ma=-inf;\n        if(A<n)ma=max(ma,f(a,b,co+1,tu,0));\n        if(co)ma=max(ma,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else if(a+b+co)ma=max(ma,0);\n        cout<<\" \"<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<ma<<\" \"<<dp[a][b][co][tu]<<endl;\n        return mem[a][b][co][tu]=ma;\n    }else{\n        int mi=inf;\n        if(B<m)mi=min(mi,f(a,b,co+1,tu,0));\n        if(co)mi=min(mi,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else mi=min(mi,0);\n        cout<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<mi<<endl;\n        return mem[a][b][co][tu]=mi;\n    }\n}\nint main(){\n    cin>>n>>m;\n    A=vi(n);rep(i,n)cin>>A[i];\n    B=vi(m);rep(i,m)cin>>B[i];\n     \n    rep(l,2)rep(i,n+1)rep(j,m+1){\n        int sum=0;\n        int L=l,I=i,J=j;\n        int co=0;\n        while(1){\n            dp[i][j][co][l]=sum;\n            if(L&&J>=m||!L&&I>=n)break;\n            if(L){\n                if(B[J]+1)sum-=B[J];\n                else sum=0;\n                J++;\n            }else{\n                if(A[I]+1)sum+=A[I];\n                else sum=0;\n                I++;\n            }\n            L^=1;\n            co++;\n        }\n    }   \n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][0];cout<<endl;}\n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][1];cout<<endl;}\n    rep(i,52)rep(j,52)rep(k,110)rep(l,2)rep(q,3)\n        mem[i][j][k][l][q]=-inf;\n    cout<<f(0,0,0,0,1)<<endl;\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n, G[N][N], A[N], ans;\nvector<P> idx;\n\nvoid dfs(int x,int sum,vector<int> S){\n  \n  ans=max(ans,sum);\n  \n  if(x==n-1||ans>=sum+A[x]) return;\n  \n  dfs(x+1,sum,S);\n  \n  for(int i=0;i<S.size();i++)\n    if(G[S[i]][idx[x].second]) return;\n  \n  S.push_back(idx[x].second);\n  \n  dfs(x+1,sum+idx[x].first,S);\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cost, cnt=0;\n    \n    memset(G,0,sizeof(G));\n    idx.clear();\n    \n    for(int i=0;i<n;i++){\n      \n      string s;\n      cin>>s;\n      \n      if(!num.count(s)) num[s]=cnt++;\n\n      int a, b;\n      cin>>a>>b;\n\n      if(i) idx.push_back(P(a,num[s]));\n      else cost=a;\n      \n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n      }\n      \n    }\n    \n    sort(idx.begin(),idx.end(),greater<P>());\n\n    memset(A,0,sizeof(A));\n    \n    A[n-1]=idx[n-1].first;\n    \n    for(int i=n-2;i>=0;i--)\n      A[i]=A[i+1]+idx[i].first;\n    \n    ans=cost;\n    \n    vector<int> s;\n    \n    s.push_back(0);\n    \n    dfs(0,cost,s);\n    \n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nchar str[50];\nstring name[50];\nint b[50];\nint c[50];\nstring d[50][50];\nint g[50][50];\nint n;\nint deg[50];\nint dfs(vector<int>use){\n\tbool ok=true;\n\tint ret=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(use[i]==1)ret+=b[i];\n\t\tif(use[i]==-1)ok=false;\n\t}\n\tif(ok){\n\t\t/*if(ret>40){\n\t\t\tfor(int i=0;i<use.size();i++)printf(\"%d \",use[i]);\n\t\t\tprintf(\": %d\\n\",ret);\n\t\t}*/\n\t\treturn ret;\n\t}\n\tint m=-1;\n\tint at=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]&&m<deg[i]){\n\t\t\tm=deg[i];at=i;\n\t\t}\n\t}\n\t// use\n\tret=0;\n\tvector<int> to=use;\n\tto[at]=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]&&g[at][i]){\n\t\t\tto[i]=0;\n\t\t}\n\t}\n\tret=max(ret,dfs(to));\n\t// non use\n\tto=use;\n\tto[at]=0;\n\tret=max(ret,dfs(to));\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tmap<string,int>m;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint p,q;scanf(\"%s%d%d\",str,&p,&q);\n\t\t\tname[i]=str;\n\t\t\tb[i]=p;\n\t\t\tc[i]=q;\n\t\t\tm[name[i]]=i;\n\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\tscanf(\"%s\",str);\n\t\t\t\td[i][j]=str;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<c[i];j++)\n\t\t\tg[i][m[d[i][j]]]=1;\n\t\tfor(int i=0;i<a;i++)deg[i]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)deg[i]+=g[i][j];\n//\t\tfor(int i=0;i<a;i++){\n\t//\t\tfor(int j=0;j<a;j++)printf(\"%d \",g[i][j]);printf(\"\\n\");\n\t\t//}\n\n\t\tvector<int> s(a,-1);\n\t\ts[0]=1;\n\t\tfor(int i=0;i<a;i++)if(g[0][i])s[i]=0;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]==0)s[i]=1;\n\t\t}\n\t/*\tfor(int i=0;i<a;i++){\n\t\t\tif(deg[i]==1){\n\t\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\t\tif(g[i][j]&&deg[j]==1){\n\t\t\t\t\t\tif(i&&j){\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}*/\n\t\tprintf(\"%d\\n\",dfs(s));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define LINE cout << \"LINE : \" << __LINE__ << endl\n#define dump(v) cout << #v << \" : \" << v << \" \"\n#define dumpl(v) dump(v) << endl\n\nusing ll = int_fast64_t;\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<ll> d[41];\n\nll dp0[1<<21];\nll dp1[1<<21];\nll maskNg0[1<<21];\nll maskNg1[1<<21];\nll maskNg2[1<<21];\n\nvoid calc(ll* dp, ll l, ll r, ll* maskNg) {\n  rep(mask, 1LL << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1LL<<i)) continue;\n      ll nxt = mask | (1LL << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    unordered_map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    rep(i, n) {\n      d[i].resize(D[i].size());\n      rep(j, D[i].size()) d[i][j] = mp[D[i][j]];\n    }\n\n    ll l = 0, m = n/2, r = n;\n  \n    rep(i, 1<<(m - l)) maskNg0[i] = maskNg2[i] = 0;\n    rep(i, 1<<(r - m)) maskNg1[i] = 0;\n    \n    rep(i, m - l) {\n      auto& mask = maskNg0[i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j];\n\tif(k >= m) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg1[i];\n      rep(j, d[i + m].size()) {\n\tll k = d[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg2[i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n\n    rep(i, 1LL << (m - l)) dp0[i] = 0;\n    rep(i, 1LL << (r - m)) dp1[i] = 0;\n    calc(dp0, l, m, maskNg0);\n    calc(dp1, m, r, maskNg1);\n\n    rep(mask, (1LL << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1LL<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1LL<<i)]);\n      }\n    }\n    \n    ll ans = 0LL;\n    rep(x, 1LL<<(m - l)) {\n      if(x&1LL) {\n\tll y = (1LL<<(r - m)) - 1LL;\n\trep(i, m - l) {\n\t  if(x & (1LL << i)) {\n\t    y -= (y & maskNg2[i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_N 41\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Country{\n  int index,power;\n  Country(int index=IINF,int power=IINF):index(index),power(power){}\n  bool operator < (const Country& c)const{ return power > c.power; }\n};\n\nint N,answer,V,sum[MAX_N];\null adj_bitmask[MAX_N];\nCountry c_list[MAX_N];\n\ninline void input(){\n  V = 0;\n  int dex = 0,i_tmp;\n  map<string,int> getIndex;\n  set<string> ban;\n  string s_tmp;\n  rep(i,N){\n    cin >> s_tmp >> i_tmp;\n    if( ban.find(s_tmp) != ban.end() ){\n      cin >> i_tmp;\n      rep(i,i_tmp)cin>>s_tmp;\n      continue;\n    }\n    if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n    int from = getIndex[s_tmp];\n    if( from == 0 ) answer = i_tmp;\n    c_list[from] = Country(from,i_tmp);\n    adj_bitmask[from] = 0ULL;\n    cin >> i_tmp;\n    rep(j,i_tmp){\n      cin >> s_tmp;\n      if( from == 0 ){\n\tban.insert(s_tmp);\n\tcontinue;\n      }\n      if( ban.find(s_tmp) != ban.end() ) continue;\n      if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n      int to = getIndex[s_tmp];\n      adj_bitmask[from] |= (1ULL<<to);\n    }\n  }\n  V = dex;\n}\n\nvoid dfs(int sp,int power,ull friend_bitmask,ull enemy_bitmask){\n  if( power + sum[sp] <= answer )return;\n  answer = max(answer,power);\n  if( sp >= V ) return;\n   \n  REP(i,sp,V){\n    if( ((friend_bitmask|enemy_bitmask)>>(ull)(c_list[i].index)) & 1ULL ) continue;\n    if( friend_bitmask & adj_bitmask[c_list[i].index] ) continue;\n    dfs(i+1,power+c_list[i].power,friend_bitmask|(1ULL<<c_list[i].index),enemy_bitmask|adj_bitmask[c_list[i].index]);\n    dfs(i+1,power,friend_bitmask,enemy_bitmask);\n    break;\n  }\n\n}\n\nint main(){\n  while(cin>>N,N){\n    input();\n    sort(c_list,c_list+V);\n    rep(i,V)sum[i] = 0;\n    sum[V-1] = c_list[V-1].power;\n    for(int i=V-2;i>=0;i--) sum[i] = sum[i+1] + ((c_list[i].index==0)?0:c_list[i].power);\n    dfs(0,answer,1,0);\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\ninline unsigned int __builtin_popcount(unsigned int x){ return __popcnt(x); }\ninline unsigned long long __builtin_popcountll(unsigned long long x) { return __popcnt64(x); }\n\n#pragma pop_macro(\"long\")\n#endif\ninline int bsf(int v) { return __builtin_ctz(v); }\ninline long bsf(long v) { return __builtin_ctzll(v); }\ninline int bsr(int v) { return 31 - __builtin_clz(v); }\ninline long bsr(long v) { return 63 - __builtin_clzll(v); }\ninline int msb(int v) { return 1 << bsr(v); }\ninline long msb(long v) { return 1ll << bsr(v); }\ninline int lsb(int v) { return v & -v; }\ninline long lsb(long v) { return v & -v; }\ninline int pop_lsb(int v) { return v & v - 1; }\ninline long pop_lsb(long v) { return v & v - 1; }\n\n//// idconv ////\ntemplate<class T>\nstruct idconv\n{\n\tvector<T> v;\n\tint get(T t)\n\t{\n\t\tint id = (int)(find(allof(v), t) - v.begin());\n\t\tif (id == v.size()) v.push_back(t);\n\t\treturn id;\n\t}\n};\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline long bit(int i) { return 1ll << i; }\n\nint dfs(const vector<pair<int, long>> &nations, long cand, map<long, int> &memo)\n{\n\tif (!cand) return 0;\n\tif (memo.count(cand)) return memo[cand];\n\tpair<int, long> d = nations[bsf(cand)];\n\tint use = dfs(nations, cand & ~d.second, memo) + d.first;\n\tint notuse = dfs(nations, pop_lsb(cand), memo);\n\treturn memo[cand] = max(use, notuse);\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tvector<bitset<64>> adj(N);\n\t\tvector<pair<int, long>> nations(N);\n\t\tidconv<string> idc;\n\t\tREP(i, N)\n\t\t{\n\t\t\tint id = idc.get(read<string>());\n\t\t\tint pw = read<int>();\n\t\t\tlong a = bit(id);\n\t\t\tfor (auto &s : readjag<string>()) a |= bit(idc.get(s));\n\t\t\tadj[id] = a;\n\t\t\tnations[id] = make_pair(pw, a);\n\t\t}\n\n\t\tint sum = nations[0].first;\n\t\tlong candidate = bit(N) - 1 & ~nations[0].second;\n\n\t\t// グラフ分割\n\t\tREP(k, N) REP(i, N) REP(j, N) adj[i][j] = adj[i][j] | (adj[i][k] & adj[k][j]);\n\n\t\tREP(i, N)\n\t\t{\n\t\t\tlong cand = candidate & adj[i].to_ullong();\n\t\t\tif (cand)\n\t\t\t{\n\t\t\t\tmap<long, int> memo;\n\t\t\t\tsum += dfs(nations, cand, memo);\n\t\t\t\tcandidate &= ~cand;\n\t\t\t}\n\t\t}\n\t\tWRITE(sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint V;\nconst int MAX_V=40;\nvector<int> G[MAX_V];\nbool used[MAX_V];\nint ord[MAX_V];\nint cnt[MAX_V];\t\t//cnt[v] = the num of selected verticies connected with v;\ntypedef long long ll;\nset<ll> done;\n\nint ans,power[40],m[40];\nstring name[40];\nvector<string> names[40];\n\nvoid dfs(int it){\n\tif(it==V){\n\t\tll x=0;\n\t\trep(i,V) if(used[i]) x|=(1LL<<i);\n\t\tif(done.find(x)!=done.end()) return;\n\t\tdone.insert(x);\n\t\tif(!used[0]) return;\n\t\tint sum=0;\n\t\trep(i,V) if(used[i]) sum+=power[i];\n\t\tchmax(ans,sum);\n\t\treturn;\n\t}\n\tint v=ord[it];\n\tif(used[v]||cnt[v]){\n\t\tdfs(it+1);\n\t\treturn;\n\t}\n\t//use v\n\tused[v]=1;\n\tfor(int u:G[v]) cnt[u]++;\n\tdfs(it+1);\n\tused[v]=0;\n\tfor(int u:G[v]) cnt[u]--;\n\n\tfor(int u:G[v]) if(cnt[u]==0&&!used[u]){\n\t\tused[u]=1;\n\t\tfor(int w:G[u]) cnt[w]++;\n\t\tdfs(it+1);\n\t\tused[u]=0;\n\t\tfor(int w:G[u]) cnt[w]--;\n\t}\n}\nvoid enum_ind(int N){\n\tV=N;\n\ttypedef pair<int,int> P;\n\tvector<P> tmp;\n\trep(i,N) tmp.pb(P(G[i].size(),i));\n\tsort(all(tmp));\n\trep(i,N) ord[i]=tmp[i].sc;\n\tdfs(0);\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N) names[i].clear();\n\t\trep(i,N) G[i].clear();\n\t\tans=0;\n\t\trep(i,N){\n\t\t\tcin>>name[i]>>power[i]>>m[i];\n\t\t\trep(j,m[i]){\n\t\t\t\tstring st;\n\t\t\t\tcin>>st;\n\t\t\t\tnames[i].pb(st);\n\t\t\t}\n\t\t}\n\t\trep(i,N){\n\t\t\trep(j,m[i]){\n\t\t\t\trep(k,N){\n\t\t\t\t\tif(name[k]==names[i][j]) G[i].pb(k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenum_ind(N);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#ifdef __BORLANDC__\n\ttypedef __int64 ll;\n#else\n\ttypedef long long ll;\n#endif\n\nconst ll L1 = 1;\nconst int N = 40;\nint M = 20;\n\nint n;\nll edge[N];\nint power[N];\n\nvoid printbit(ll state){\n\trep(i,n)printf(\"%d\",((L1<<i)&state)>0);puts(\"\");\n}\n\nvoid printedge(){\n\tprintf(\"edge\\n\");\n\trep(i,n)printbit(edge[i]);\n}\n\nbool init(){\n\tcin>>n;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i]=power[i]=0;\n\t\n\tmap<string,int> mp;\n\tvector<string> estr[N];\n\trep(i,n){\n\t\tstring a;\n\t\tint b,c;\n\t\tcin>>a>>b>>c;\n\t\tmp[a]=i;\n\t\tpower[i]=b;\n\t\trep(j,c){\n\t\t\tstring d;\n\t\t\tcin>>d;\n\t\t\testr[i].push_back(d);\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,estr[i].size()){\n\t\t\tedge[i] |= (L1<<mp[estr[i][j]]);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool hasbit(ll state, int bit){return state&(L1<<bit);}\n\nint T = (1<<M);\nconst int TM = (1<<20);\nint half[TM];\n\nint left_search(){\n\trep(i,T)half[i]=0;\n\t\n\tint maxi = 0;\n\tfor(int i=1;i<T;i+=2){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\trep(j,M){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\t if(edge[j]&i)ok=false;\n\t\t\t\t sum += power[j];\n\t\t\t}\n\t\t\tif(!ok)break;\n\t\t}\n\t\t\n\t\tif(ok)half[i]=sum;\n\t\tmaxi = max(maxi,half[i]);\n\t}\n\treturn maxi;\n}\n\nint memo[TM];\nint left_memo(int state){\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tint ret = half[state];\n\trep(i,M){\n\t\tif(state&(1<<i)){\n\t\t\tret = max(ret, left_memo(state ^ (1<<i)));\n\t\t}\n\t}\n\treturn memo[state]=ret;\n}\n\nint right_search(){\n\tint ans = 0;\n\tfor(ll i=0; i<(L1<<n); i+=T){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\tll mask = 0;\n\t\treps(j,M,n){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\tif(edge[j]&i)ok=false;\n\t\t\t\tsum+=power[j];\n\t\t\t\tmask |= edge[j];\n\t\t\t}\n\t\t\tif(!ok)break;\n\t\t}\n\t\t\n\t\tif(ok){\n\t\t\tmask &= (T-1);\n\t\t\tmask ^= (T-1);\n\t\t\t//printf(\"i=%d sum=%d memo[bit]=%d \",i,sum,memo[mask]);\n\t\t\t//printbit(mask);\n\t\t\tans = max(ans, memo[mask]+sum);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid left_dp(){\n\trep(i,T)memo[i]=-1;\n\t\n\tleft_memo(T-1);\n}\n\nvoid printdp(){\n\trep(i,T){\n\t\tprintf(\"%3d \",memo[i]);printbit(i);\n\t}\n}\nvoid printsearch(){\n\trep(i,T){\n\t\tprintf(\"%3d \",half[i]);printbit(i);\n\t}\n}\nint solve(){\n\tM = (n+1)/2;\n\tT = (1<<M);\n\t\n\tint a = left_search();\n\tleft_dp();\n\t\n\t/*\n\tputs(\"s\");\n\tprintsearch();\n\tputs(\"d\");\n\tprintdp();\n\t*/\n\treturn max(a,right_search());\n}\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n6\nINTERCAL 10 3 Chef Piet COW\nChef 7 3 INTERCAL Piet COW\nPiet 6 2 INTERCAL Chef\nCOW 7 2 INTERCAL Chef\nJ 6 1 A\nA 12 1 J\n0\n\n6\nINTERCAL 20 1 J\nChef 50 3 J A Piet\nPiet 30 2 A Chef\nCOW 15 1 J\nJ 40 3 COW INTERCAL Chef\nA 25 2 Chef Piet\n0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_N 41\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Country{\n  int index,power;\n  Country(int index=IINF,int power=IINF):index(index),power(power){}\n  bool operator < (const Country& c)const{ return power > c.power; }\n};\n\nint N,answer,V,sum[MAX_N];\null adj_bitmask[MAX_N];\nCountry c_list[MAX_N];\n\ninline void input(){\n  V = 0;\n  int dex = 0,i_tmp;\n  map<string,int> getIndex;\n  set<string> ban;\n  string s_tmp;\n  rep(i,N){\n    cin >> s_tmp >> i_tmp;\n    if( ban.find(s_tmp) != ban.end() ){\n      cin >> i_tmp;\n      rep(i,i_tmp)cin>>s_tmp;\n      continue;\n    }\n    if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n    int from = getIndex[s_tmp];\n    if( from == 0 ) answer = i_tmp;\n    c_list[from] = Country(from,i_tmp);\n    adj_bitmask[from] = 0ULL;\n    cin >> i_tmp;\n    rep(j,i_tmp){\n      cin >> s_tmp;\n      if( from == 0 ){\n\tban.insert(s_tmp);\n\tcontinue;\n      }\n      if( ban.find(s_tmp) != ban.end() ) continue;\n      if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n      int to = getIndex[s_tmp];\n      adj_bitmask[from] |= (1<<to);\n    }\n  }\n  V = dex;\n}\n\nvoid dfs(int sp,int power,ull friend_bitmask,ull enemy_bitmask){\n // if( power + sum[sp] <= answer ) return;\n  answer = max(answer,power);\n  if( sp >= V ) return;\n   \n  REP(i,sp,V){\n    if( ((friend_bitmask|enemy_bitmask)>>c_list[i].index) & 1 ) continue;\n    if( friend_bitmask & adj_bitmask[c_list[i].index] ) continue;\n    dfs(i+1,power+c_list[i].power,friend_bitmask|(1<<c_list[i].index),enemy_bitmask|adj_bitmask[c_list[i].index]);\n    dfs(i+1,power,friend_bitmask,enemy_bitmask);\n    break;\n  }\n\n}\n\nint main(){\n  while(cin>>N,N){\n    input();\n    sort(c_list,c_list+V);\n    rep(i,V)sum[i] = 0;\n    sum[V-1] = c_list[V-1].power;\n    for(int i=V-2;i>=0;i--) sum[i] = sum[i+1] + c_list[i].power;\n    dfs(0,answer,1,0);\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n      \n#define FOR(i,a,b) for( ll i = (a); i < (ll)(b); i++ )\n#define REP(i,n) FOR(i,0,n)\n#define YYS(x,arr) for(auto& x:arr)\n#define ALL(x) (x).begin(),(x).end()\n#define SORT(x) sort( (x).begin(),(x).end() )\n#define REVERSE(x) reverse( (x).begin(),(x).end() )\n#define UNIQUE(x) (x).erase( unique( ALL( (x) ) ) , (x).end() )\n#define PW(x) (1LL<<(x))\n#define SZ(x) ((ll)(x).size())\n#define SHOW(x) cout << #x << \" = \" << x << endl\n#define SHOWA(x,n) for( int yui = 0; yui < n; yui++ ){ cout << x[yui] << \" \"; } cout << endl\n\n#define pb emplace_back\n#define fi first\n#define se second\n\nusing namespace std;\n\ntypedef long double ld;\ntypedef long long int ll;\ntypedef pair<int,int> pi;\ntypedef pair<ll,ll> pl;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<bool> vb;\ntypedef vector<ld> vd;\ntypedef vector<pi> vpi;\ntypedef vector<pl> vpl;\ntypedef vector<vpl> gr;\ntypedef vector<vl> ml;\ntypedef vector<vd> md;\ntypedef vector<vi> mi;\n     \nconst ll INF = (ll)1e9 + 10;\nconst ll INFLL = (ll)1e18 + 10;\nconst ld EPS = 1e-12;\nconst ll MOD = 1e9+7;\n     \ntemplate<class T> T &chmin( T &a , const T &b ){ return a = min(a,b); }\ntemplate<class T> T &chmax( T &a , const T &b ){ return a = max(a,b); }\ntemplate<class T> inline T sq( T a ){ return a * a; }\n\nll in(){ long long int x; scanf( \"%lld\" , &x ); return x; }\nchar yuyushiki[1000010]; string stin(){ scanf( \"%s\" , yuyushiki ); return yuyushiki; }\n\n// head\n\nint n;\n\nint a[64];\n\nmap<string,int> ma;\n\nvector<string> sG[64];\nvector<int> G[64];\n\nll ms[64];\n\nint ans;\n\nvi v;\n\nint hstar( ll mask ){\n  int res = 0;\n  REP( i , n ){\n    if( !( mask & PW(i) ) ){\n      res += a[i];\n    }\n  }\n  return res;\n}\n\nvoid dfs( int cur, ll mask ){\n  // cout << cur << \" \" << mask << endl;\n  chmax( ans , cur );\n  if( cur + hstar( mask ) <= ans ){\n    return;\n  }\n  REP( i , n ){\n    if( !( mask & PW(v[i]) ) ){\n      dfs( cur + a[v[i]], mask | ms[v[i]] );\n    }\n  }\n}\n\nint cmp( int i , int j ){\n  return a[i] > a[j];\n}\n\nint main(){\n\n  while( 1 ){\n    n = in();\n    if( n == 0 ){\n      break;\n    }\n    ma.clear();\n    ans = 0;\n    v.clear();\n    REP( i , n ){\n      sG[i].clear();\n      G[i].clear();\n      ms[i] = 0;\n    }\n    REP( i , n ){\n      string s = stin();\n      ma[s] = i;\n      a[i] = in();\n      int m = in();\n      REP( j , m ){\n        string t = stin();\n        sG[i].pb( t );\n      }\n    }\n    REP( i , n ){\n      YYS( w , sG[i] ){\n        G[i].pb( ma[w] );\n        ms[i] = ms[i] | PW( ma[w] );\n      }\n      ms[i] = ms[i] | PW(i);\n    }\n    REP( i , n ){\n      v.pb( i );\n    }\n    sort( ALL(v), cmp );\n    dfs( a[0] , ms[0] );\n    printf( \"%d\\n\" , ans );\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\trest -= names[pos].second;\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tint rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\trest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\trest = rest1;\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tbmap.clear();\n\t\tans = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tlist.push_back(a);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tbuf.insert(make_pair(name, move(list)));\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second,mb-names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <string>\n#include <cassert>\n#include <cstdio>\nusing namespace std;\n#define MAX 41\n#define TEST 0\n\ntypedef long long int ll;\n\nint n;\nmap<string,int> names;\nint b[MAX],c[MAX];\nstring ds[MAX][MAX];\nint graph[MAX][MAX];\n\n\nint rmax;\nll rmaxs;\nvoid rec(ll bits,int sum){//gradually elim-ing vertices\n    if(TEST)\n        printf(\"bits=%llx,sum=%d\\n\",bits,sum);\n    if(sum<=rmax){\n        return;\n    }\n    if((bits&1)==0){//vertex 0 is not in the set\n        return;\n    }\n    int mini=90000;\n    int minv=-1;\n    for(int i=0;i<n;i++){\n        if((bits&(1LL<<i))==0){\n            continue;\n        }\n        int ind=b[i];\n        for(int j=0;j<n;j++){\n            if((bits&(1LL<<j))==0||i==j){\n                continue;\n            }\n            if(graph[i][j]){\n                ind+=b[j];\n            }\n        }\n        if(ind<mini){\n            mini=ind;\n            minv=i;\n        }\n    }\n    if(mini==sum){//clique\n        rmax=sum;\n        rmaxs=bits;\n        return;\n    }\n    //minv:minimum\n    ll set=1LL<<minv;\n    int w=b[minv];\n    for(int i=0;i<n;i++){\n        if((bits&(1LL<<i))&&graph[minv][i]){\n            set|=1LL<<i;\n            w+=b[i];\n        }\n    }\n    if(TEST)\n    printf(\"minv=%d,set=%llx,w=%d\\n\",minv,set,w);\n    rec(set,w);\n    rec(bits&~(1LL<<minv),sum-b[minv]);\n    return;\n}\n\n\nint main(void){\n    while(cin>>n&&n){\n        int sum=0;\n        for(int i=0;i<n;i++){\n            fill_n(graph[i],n,1);\n        }\n        for(int i=0;i<n;i++){\n            string a;\n            cin>>a>>b[i]>>c[i];\n            names.insert(pair<string,int>(a,i));\n            for(int j=0;j<c[i];j++){\n                string t;\n                cin>>t;\n                ds[i][j]=t;\n            }\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int d=names[ds[i][j]];\n                graph[i][d]=0;\n            }\n            graph[i][i]=0;\n        }\n        ll bits=1;\n        sum=b[0];\n        for(int i=1;i<n;i++){\n            if(graph[0][i]){\n                bits|=1LL<<i;\n                sum+=b[i];\n            }\n        }\n        rmax=0;\n        rmaxs=0;\n        rec(bits,sum);\n        cout<<rmax<<endl;\n        if(TEST){\n            cout<<\"rmaxs\"<<hex<<rmaxs<<dec<<endl;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n\nint64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp)max = tmp;\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring a[40];\nint b[40];\nvector<string> d[40];\nmap<string,int> sn;\nvector<int> dn[40];\nint mr[40];\n\nbool cmp(int pa,int pb){\n  return b[pa]>b[pb];\n}\n\nint dfs(long long u,int c,int cm){\n  if(c==n){\n    return cm;\n  }else{\n    int m=dfs(u,c+1,cm);\n    if(!(u>>mr[c]&1)){\n      int pr=0;\n      for(int i=c;i<n;i++){\n\tif(!(u>>mr[i]&1)){\n\t  pr+=b[mr[i]];\n\t}\n      }\n      if(pr+cm>m){\n\tlong long nu=u|1LL<<mr[c];\n\tfor(int i=0;i<dn[mr[c]].size();i++){\n\t  nu|=1LL<<dn[mr[c]][i];\n\t}\n\tm=max(m,dfs(nu,c+1,cm+b[mr[c]]));\n      }\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    sn.clear();\n    for(int i=0;i<n;i++){\n      int c;\n      cin>>a[i]>>b[i]>>c;\n      sn[a[i]]=i;\n      d[i].resize(c);\n      while(c--){\n\tcin>>d[i][c];\n      }\n    }\n    for(int i=0;i<n;i++){\n      dn[i].resize(n);\n      for(int j=0;j<d[i].size();j++){\n\tdn[i][j]=sn[d[i][j]];\n      }\n    }\n    for(int i=0;i<n;i++){\n      mr[i]=i;\n    }\n    sort(mr,mr+n,cmp);\n    long long n=1;\n    for(int i=0;i<dn[0].size();i++){\n      n|=1LL<<dn[0][i];\n    }\n    cout<<dfs(n,0,b[0])<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nint n;\nvector<ll> adj;\nvi power, sum_rest;\n\nint res;\n\nvoid dfs(int v, int sum, ll vec){\n    if(v == n){\n        res = max(res, sum);\n        return;\n    }\n    if(sum + sum_rest[v] < res) return;\n\n    int nv = v + 1;\n\n    dfs(nv, sum, vec);\n\n    if((vec & adj[v]) == 0){\n        dfs(nv, sum + power[v], vec | adj[v] | (1LL << v));\n    }\n}\n\nint main(void){\n    for(; cin >> n, n;){\n        res = 0;\n\n        power = sum_rest = vi(n);\n        adj = vector<ll>(n);\n\n        vector<vector<string>> d_str(n);\n        map<string, int> s2i;\n\n        int sum = 0;\n        rep(i, n){\n            string name;\n            int p, m; cin >> name >> p >> m;\n            d_str[i] = vector<string>(m);\n            for(auto & ee : d_str[i]) cin >> ee;\n\n            s2i[name] = i;\n            power[i] = p;\n\n            sum += p;\n        }\n\n        sum_rest[0] = sum;\n        rep(i, n - 1){\n            sum_rest[i + 1] = sum_rest[i] - power[i];\n        }\n\n        rep(i, n){\n            ll vec = 0;\n            for(auto & e : d_str[i]){\n                int idx = s2i[e];\n                vec |= (1LL << idx);\n            }\n            adj[i] = vec;\n        }\n\n        dfs(1, power[0], 1LL);\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nconst int BIT = 1<<21;\nint N;\nmap<string,int> id;\nint B[MAXN];\nGraph g;\nint S[BIT], T[BIT], D[BIT];\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    int b = N/2;\n    int a = N - b;\n    vector<pair<int,int> > esS, esT, esU;\n    for(int v = 0; v < N; ++v) {\n      for(int j = 0; j < g[v].size(); ++j) {\n        int nv = g[v][j];\n        if(v < a && nv < a && v < nv) esS.push_back(make_pair(v, nv));\n        if(v >= a && nv >= a && v < nv) esT.push_back(make_pair(v, nv));\n        if(v < a && nv >= a) esU.push_back(make_pair(v, nv));\n      }\n    }\n\n    fill(S, S+BIT, 0);\n    for(int j = 0; j < (1<<a); ++j) {\n      vector<int> used(N);\n      if(S[j] == -1) continue;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n        if(used[v]) S[j] += B[v];\n      }\n      for(int i = 0; i < esS.size(); ++i) {\n        int p = esS[i].first;\n        int q = esS[i].second;\n        if(used[p] && used[q]) {\n          for(int k = j; k < (1<<a); k = ((k + 1)|j)) S[k] = -1;\n          break;\n        }\n      }\n    }\n\n    fill(T, T+BIT, 0);\n    for(int j = 0; j < (1<<b); ++j) {\n      vector<int> used(N);\n      if(T[j] == -1) continue;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v >= a && (j & (1<<(v-a)));\n        if(used[v]) T[j] += B[v];\n      }\n      for(int i = 0; i < esT.size(); ++i) {\n        int p = esT[i].first;\n        int q = esT[i].second;\n        if(used[p] && used[q]) {\n          for(int k = j; k < (1<<b); k = ((k + 1)|j)) T[k] = -1;\n          break;\n        }\n      }\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      for(int k = 0; k < b; ++k) {\n        if(j & (1<<k)) continue;\n        T[j|(1<<k)] = max(T[j|(1<<k)], T[j]);\n      }\n    }\n\n    fill(D, D+BIT, (1<<b)-1);\n    for(int i = 0; i < esU.size(); ++i) {\n      int p = esU[i].first;\n      int q = esU[i].second;\n      int j = 1<<p;\n      for(int k = j; k < (1<<a); k = ((k+1)|j)) D[k] &= ~(1<<(q-a));\n    }\n\n    int res = 0;\n\n    for(int j = 0; j < (1<<a); ++j) {\n      if(S[j] == -1) continue;\n      if(!(j & 1)) continue;\n      /*\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n      }\n      int bit = (1<<b)-1;\n      for(int i = 0; i < esU.size(); ++i) {\n        int p = esU[i].first;\n        int q = esU[i].second;\n        if(used[p]) {\n          bit &= ~(1<<(q-a));\n        }\n      }\n      */\n      int bit = D[j];\n      if(T[bit] == -1) continue;\n      res = max(res, S[j] + T[bit]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint Cc;\n\nchar Name[40][20];\nchar NearS[40][40][20];\nbool Near[40][40];\nbool ally[40];\nint Power[40];\nint n, t;\nint Max_Power;\n\nvoid make_ally(bool ally1[40], int name, int power){\n\tint i,j;\n\tbool ally2[40];\n\tmemcpy(ally2,ally1,sizeof(ally));\n\n\tally2[name] = 1;\n\tpower += Power[name];\n\n\tfor(i=0;i<n;i++){\n\t\tif(Near[name][i]){\n\t\t\tally2[i]=1;\n\t\t}\n\t}\n\n for(i=name;i<n;i++){\n\t\tif(!ally2[i]){\n\t\t\tfor(j=name;j<n;j++){\n\t\t\t\tif(!ally2[j] && Near[j][i]) break;\n\t\t\t}\n\t\t\tif(j==n){\n\t\t\t\tally2[i] = 1;\n\t\t\t\tpower += Power[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif(power > Max_Power) Max_Power = power;\n\n\tfor(i=name;i<n;i++)\n\t\tif(!ally2[i]) make_ally(ally2, i, power);\n\n\treturn;\n}\nint search(char *name){\n\tint i;\n\tfor(i=0;i<Cc;i++) if(!strcmp(name, Name[i])) return i;\n\tprintf(\"%s\\n\", name);\n\treturn 0;\n}\n\nint main(){\n\tint j, i;\n\twhile(cin >> n, n){\n\t\tmemset(Name, 0, sizeof(Name));\n\t\tmemset(Near, 0, sizeof(Near));\n\t\tmemset(NearS, 0, sizeof(NearS));\n\t\tmemset(Power, 0, sizeof(Power));\n\t\tmemset(ally, 0, sizeof(ally));\n\t\tMax_Power=0; Remain_Power=0;\n\n\t\tfor(Cc=0;Cc<n;Cc++){\n\t\t\tcin >> Name[Cc] >> Power[Cc] >> t;\n\t\t\tRemain_Power += Power[Cc];\n\n\t\t\tfor(i=0;i<t;i++) cin >> NearS[Cc][i];\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;NearS[i][j][0];j++){\n\t\t\t\tNear[i][search(NearS[i][j])] = 1;\n//\t\t\t\tprintf(\"%d-%d\\n\", i, search(NearS[i][j]));\n\t\t\t}\n\t\t}\n\t\tmake_ally(ally, 0, 0);\n\t\tcout<<Max_Power<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nconst int BIT = 1<<21;\nint N;\nmap<string,int> id;\nint B[MAXN];\nGraph g;\nint S[BIT], T[BIT];\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    int b = N/2;\n    int a = N - b;\n    vector<pair<int,int> > esS, esT, esU;\n    for(int v = 0; v < N; ++v) {\n      for(int j = 0; j < g[v].size(); ++j) {\n        int nv = g[v][j];\n        if(v < a && nv < a && v < nv) esS.push_back(make_pair(v, nv));\n        if(v >= a && nv >= a && v < nv) esT.push_back(make_pair(v, nv));\n        if(v < a && nv >= a) esU.push_back(make_pair(v, nv));\n      }\n    }\n\n    fill(S, S+BIT, 0);\n    for(int j = 0; j < (1<<a); ++j) {\n      vector<int> used(N);\n      if(S[j] == -1) continue;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n        if(used[v]) S[j] += B[v];\n      }\n      for(int i = 0; i < esS.size(); ++i) {\n        int p = esS[i].first;\n        int q = esS[i].second;\n        if(used[p] && used[q]) {\n          for(int k = j; k < (1<<a); k = ((k + 1)|j)) S[k] = -1;\n          break;\n        }\n      }\n    }\n\n    fill(T, T+BIT, 0);\n    for(int j = 0; j < (1<<b); ++j) {\n      vector<int> used(N);\n      if(T[j] == -1) continue;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v >= a && (j & (1<<(v-a)));\n        if(used[v]) T[j] += B[v];\n      }\n      for(int i = 0; i < esT.size(); ++i) {\n        int p = esT[i].first;\n        int q = esT[i].second;\n        if(used[p] && used[q]) {\n          for(int k = j; k < (1<<b); k = ((k + 1)|j)) T[k] = -1;\n          break;\n        }\n      }\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      for(int k = 0; k < b; ++k) {\n        if(j & (1<<k)) continue;\n        T[j|(1<<k)] = max(T[j|(1<<k)], T[j]);\n      }\n    }\n\n    int res = 0;\n    for(int j = 0; j < (1<<a); ++j) {\n      if(S[j] == -1) continue;\n      if(!(j & 1)) continue;\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n      }\n      int bit = (1<<b)-1;\n      for(int i = 0; i < esU.size(); ++i) {\n        int p = esU[i].first;\n        int q = esU[i].second;\n        if(used[p]) {\n          bit &= ~(1<<(q-a));\n        }\n      }\n      res = max(res, S[j] + T[bit]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define UNION 1\n#define NEIGHBOR 2\n\nstruct Union{\n\tstring A;\n\tint B,C;\n\tint D[42];\n\tqueue<string> S;\n} \tU[42];\n\nclass UnionSearch{\npublic:\n\tint State[42], B;\n\tUnionSearch();\n\tvoid AddUnion(int u);\n};\n\nUnionSearch::UnionSearch(){\n\tB=0;\n\tfor(int i=0;i<42;i++) State[i]=0;\n}\n\nvoid UnionSearch::AddUnion(int u){\n\tState[u] = UNION;\n\tfor(int i=0;i<U[u].C;i++) State[ U[u].D[i] ] = NEIGHBOR;\n\tB += U[u].B;\n}\n\nint N;\nqueue <UnionSearch> US;\n\n\nint Find(string s){\n\tfor(int i=1;i<=N;i++) if(s==U[i].A) return i;\n\tprintf(\"error\");\n\treturn 0;\n}\n\nmain(){\n\tint i,c,Max;\n\tstring s;\n\twhile(cin>>N,N){\n\t//\tUS.clear();\n\t\twhile(!US.empty()) US.pop();\n\t\tfor(i=0;i<42;i++){\n\t\t\tU[i].A = \"\";\n\t\t\tU[i].B=0;\n\t\t\tU[i].C=0;\n\t\t\tmemset(U[i].D, 0, 42*sizeof(int));\n\t\t\twhile(!U[i].S.empty()) U[i].S.pop();\n\t\t}\n\t\tMax = 0;\n\t\tfor(i=1;i<=N;i++){\n\t\t\tcin>>U[i].A>>U[i].B>>c;\n\t\t\twhile(c--){\n\t\t\t\tcin>>s;\n\t\t\t\tU[i].S.push(s);\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=N;i++){\n\t\t\twhile(!U[i].S.empty()){\n\t\t\t\tU[i].D[U[i].C++] = Find(U[i].S.front());\n\t\t\t\tU[i].S.pop();\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tUnionSearch q;\n\t\tq.AddUnion(1);\n\t\tUS.push(q);\n\t\twhile(!US.empty()){\n\t\t\tq = US.front();\n\t\t\tUS.pop();\n\t\t\tint t;\n\t\t\tfor(t=1;t<=N;t++){\n\t\t\t\tif(!q.State[t])break;\n\t\t\t\n\t\t\t}\n\t\t\tif(t>N){\n\t\t\t\tMax = max(Max, q.B);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(i=0;i<U[t].C;i++){\n\t\t\t\tUnionSearch p = q;\n\t\t\t\tif(p.State[U[t].D[i]]) continue;\n\t\t\t\tp.AddUnion(U[t].D[i]);\n\t\t\t\tUS.push(p);\n\t\t\t}\n\t\t\tq.AddUnion(t);\n\t\t\tUS.push(q);\n\t\t}\n\t\tcout << Max << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tvi pow(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> pow[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tvector<ll> g(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tg[i] = 1ll << i;\n\t\t\tREP(j, nei[i].size())\n\t\t\t{\n\t\t\t\tg[i] |= 1ll << mp[nei[i][j]];\n\t\t\t}\n\t\t}\n\n\t\tvi ss(n + 1);\n\t\tREP(i, n) ss[i + 1] = ss[i] + pow[i];\n\n\t\tint ans = 0;\n\t\tstack<ll> st;\n\t\tst.push(1);\n\t\twhile (st.size())\n\t\t{\n\t\t\tll tmp = st.top();\n\t\t\tst.pop();\n\t\t\tint left;\n\t\t\tfor (int i = n - 1; i >= 0;i--)\n\t\t\t{\n\t\t\t\tif ((tmp >> i) & 1)\n\t\t\t\t{\n\t\t\t\t\tleft = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll can = 0;\n\t\t\tint sum = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((tmp >> j) & 1)\n\t\t\t\t{\n\t\t\t\t\tsum += pow[j];\n\t\t\t\t\tcan |= g[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum + ss[n] - ss[left + 1] <= ans) continue;\n\t\t\tchmax(ans, sum);\n\t\t\tFOR(j, left+1, n)\n\t\t\t{\n\t\t\t\tif ((can >> j) & 1) continue;\n\t\t\t\tll nx = tmp | (1ll << j);\n\t\t\t\tst.push(nx);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint m, q[64];\n\nvoid collect(int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q[m++] = at;\n    rep (i, N) if (g[at][i]) collect(i);\n}\n\nint n, a, r[64], p[64];\nInt f[64];\n\nvoid prepare() {\n    n = m;\n    a = 0;\n    rep (i, n) r[i] = q[i];\n    rep (i, n) {\n        p[i] = B[r[i]];\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nvoid rec(int k, Int u) {\n    int s = 0;\n    rep (i, n) if (u&(1LL<<i)) s += p[i];\n    if (s < a) return ;\n    if (k == n) a = s;\n    else {\n        rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return ;\n        const int mask = (1LL<<n) - 1;\n        if (u&(1LL<<k)) rec(k+1, u&(mask-f[k]));\n        if (r[k]) rec(k+1, u&(mask-(1LL<<k)));\n    }\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        m = 0;\n        collect(i);\n        prepare();\n        rec(0, (1LL<<n)-1);\n        ans += a;\n    }\n    return ans;\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    vector<vector<string>> graph_(n);\n    map<string,int> encode;\n    vector<int> strength(n),sum(n);\n    rep(i,0,n){\n        string a;\n        int b,c;\n        cin >> a >> b >> c;\n        encode[a]=i;\n        strength[i]=b;\n        sum[i]=b;\n        if(i>0) sum[i]+=sum[i-1];\n        rep(j,0,c){\n            string d;\n            cin >> d;\n            graph_[i].push_back(d);\n        }\n    }\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        rep(j,0,graph_[i].size()){\n            graph[i].push_back(encode[graph_[i][j]]);\n        }\n    }\n\n    int maxi=0;\n    function<int(int64_t,int,int)> rec=[&](int64_t s,int i,int k){\n        if(i==n) return maxi=max(maxi,k);\n        if(k+sum[n-1]-sum[i-1]<=maxi) return maxi;\n        int res=rec(s,i+1,k);\n        bool f=true;\n        for(int j:graph[i]) if((s>>j)&1){\n            f=false;\n            break;\n        }\n        if(f) res=max(res,rec(s|(1<<i),i+1,k+strength[i]));\n        return maxi=max(maxi,res);;\n    };\n\n    cout << rec(1,1,strength[0]) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint r[64], p[64];\nInt f[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nvoid prepare(vector<int>& q) {\n    const int n = q.size();\n    //vector<pair<int, int> > ps;\n    //rep (i, n) ps.push_back(mp(C[q[i]], q[i]));\n    //sort(ps.begin(), ps.end());\n    //rep (i, n) r[i] = ps[n-1-i].second;\n    rep (i, n) r[i] = q[i];\n    rep (i, n) p[i] = B[r[i]];\n    rep (i, n) {\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nint n, a;\n\nvoid rec(int k, Int u) {\n    int s = 0;\n    rep (i, n) if (u&(1LL<<i)) s += p[i];\n    if (s < a) return ;\n    if (k == n) a = s;\n    else {\n        rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return ;\n        const int mask = (1LL<<n) - 1;\n        if (u&(1LL<<k)) rec(k+1, u&(mask-f[k]));\n        if (r[k]) rec(k+1, u&(mask-(1LL<<k)));\n    }\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        n = q.size();\n        a = 0;\n        rec(0, (1LL<<q.size())-1);\n        ans += a;\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nHmap<string, int> hm;\n\nvector<ll> dp0(1<<20);\nvector<ll> dp1(1<<20);\n\nvoid calc (vl& dp, int s, int e) {\n  int l = e - s;\n  rep(mask, 1 << l) {\n    rep(i, l) {\n      if(mask & (1<<i)) continue;\n      bool f = true;\n      for(const auto& str: D[i+s]) {\n\tint t = hm[str];\n\tif(s <= t && t < e) {\n\t  if(mask&(1<<(t - s))) f = false;\n\t}\n      }\n      if(f) {\n\tint nxt = mask | (1<<i);\n\tdp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n      }\n    }\n  }\n  rep(mask, 1<<l) {\n    rep(i, l) {\n      if(mask&(1<<i)) {\n\tint pre = mask - (1<<i);\n\tdp[mask] = max(dp[mask], dp[pre]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    hm.clear();\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    \n    rep(i, 1<<20) dp0[i] = 0;\n    rep(i, 1<<20) dp1[i] = 0;\n    \n    calc(dp0, 0, n/2);\n    calc(dp1, n/2, n);\n\n    int len = n - (n/2);\n    vector<int> masks(1<<(n/2), (1<<len)-1);\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tfor(const auto& str : D[i]) {\n\t  int t = hm[str] - n / 2;\n\t  if(t < 0) continue;\n\t  if(masks[mask] & (1<<t)) masks[mask] -= (1<<t);\n\t}\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp0[mask] + dp1[masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<int> DD[41];\nHmap<string, int> hm;\n\nvector<ll> dp0(1<<20);\nvector<ll> dp1(1<<20);\n\nint masks[1<<20];\n\nvoid calc (vl& dp, int s, int e) {\n  int l = e - s;\n  vector<int> ngs(l);\n  rep(i, l) {\n    for(const auto& t: DD[i+s]) {\n      if(s <= t && t < e) {\n\tngs[i] |= (1<<(t-s));\n      }\n    }\n  }\n  rep(mask, 1 << l) {\n    rep(i, l) {\n      if(mask & (1<<i)) continue;\n      if(mask&ngs[i]) continue;\n      int nxt = mask | (1<<i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n    }\n  }\n  rep(mask, 1<<l) {\n    rep(i, l) {\n      if(mask&(1<<i)) {\n\tint pre = mask - (1<<i);\n\tdp[mask] = max(dp[mask], dp[pre]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    hm.clear();\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    rep(i, n) {\n      DD[i].resize(D[i].size());\n      rep(j, D[i].size()) {\n\tDD[i][j] = hm[D[i][j]];\n      }\n    }\n    \n    rep(i, 1<<20) dp0[i] = 0;\n    rep(i, 1<<20) dp1[i] = 0;\n    \n    calc(dp0, 0, n/2);\n    calc(dp1, n/2, n);\n\n    //continue;\n    \n    int len = n - (n/2);\n    rep(i, 1<<((n+1)/2)) masks[i] = (1<<len)-1;\n    vector<int> ngs(n/2);\n    rep(i, n) {\n      for(const auto& tt : DD[i]) {\n\tint t = tt - n / 2;\n\tif(t < 0) continue;\n\tngs[i] |= (1<<t);\n      }\n    }\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tint tmp = masks[mask]&ngs[i];\n\tmasks[mask] -= tmp;\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp0[mask] + dp1[masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX 45\ntypedef long long ll;\n  \nint N, B[MAX], sum[MAX], mx;\nbool is_adj[MAX][MAX];\n\nvoid dfs(int v, int strength, ll S)\n{\n    mx = max(mx, strength);\n    \n    if (v == N || sum[v] + strength <= mx) {\n        return;\n    }\n    \n    dfs(v+1, strength, S);\n    if (!(S >> v & 1) && !is_adj[0][v]) {\n        bool ok = 1;\n        for (int i = 1; i < N; i++) {\n            if (S >> i & 1) {\n                if (is_adj[i][v]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        if (ok) {           \n            dfs(v+1, strength + B[v], S|(1LL<<v));\n        }\n    }\n}\n  \nint main()\n{\n    while (cin >> N, N) {\n        string A, D;\n        int C;\n        vector<string> DG[MAX];          \n        map<string, int> s2i;\n        \n        memset(is_adj, 0, sizeof(is_adj));\n        \n        for (int i = 0; i < N; i++) {\n            cin >> A >> B[i] >> C;\n            s2i[A] = i;\n            for (int j = 0; j < C; j++) {\n                cin >> D;\n                DG[i].push_back(D);\n            }\n        }\n        \n        sum[N-1] = B[N-1];\n        for (int i = N-2; i >= 0; i--) {\n            sum[i] = sum[i+1] + B[i];\n        }\n        \n        for (int i = 0; i < N; i++) {\n            int len = DG[i].size();\n            for (int j = 0; j < len; j++) {\n                ll t = s2i[DG[i][j]];\n                is_adj[i][t] = is_adj[t][i] = 1;\n            }\n        }\n        mx = 0;\n        dfs(1, B[0], 0);\n        cout << mx << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nmap<string,int> M;\nvector<string> NG[41];\nstring A[41];\nint n,B[41],ans;\null g[41];\n\nunordered_set <ull> S[41];\nunordered_map <ull,int> mem[41];\null used;\nvoid dfs(int pos,int sum,ull U){\n\n  ans=max(ans,sum);\n  while(pos<n&&(g[pos]&1LL))pos++;\n  if(pos==n)return;\n  if(mem[pos][U]>=sum)return;\n  mem[pos][U]=sum;\n  //if(S[pos].count(used))return;\n  //S[pos].insert(used);\n  ull tmp=used,nU=U;\n  int nsum=sum;\n\n  if(U&(1LL<<pos)){\n    used=nU=nsum=0;\n    for(int i=0;i<pos;i++){\n      if((tmp&(1LL<<i))==0) continue; \n      if((g[pos]&(1LL<<i))==0) nU|=g[i],used|=(1LL<<i),nsum+=B[i];\n    }\n  }\n  \n  used|=(1LL<<pos);\n  dfs(pos+1,nsum+B[pos],nU|g[pos]);\n  used&=~(1LL<<pos);\n  if(used!=tmp)used=tmp,dfs(pos+1,sum,U);\n} \n\n\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    for(int i=0;i<40;i++) S[i].clear(),mem[i].clear();\n\n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      M[A[i]]=i;\n      NG[i].resize(C);\n      for(int j=0;j<C;j++)cin>>NG[i][j];\n    }\n\n    \n    for(int i=0;i<n;i++){\n      g[i]=1LL<<i;\n      for(int j=0;j<(int)NG[i].size();j++)g[i]|=1LL<<M[NG[i][j]];\n    }\n    \n    ans=0;\n    used=1;\n    dfs(1,B[0],g[0]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\nstruct MaximumIndependentSet {\n    using T = int;\n    MaximumIndependentSet(const int n) : n{n}, former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost(n, 1), elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    MaximumIndependentSet(const vector<T>& cost) : n(cost.size()), former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost{cost}, elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    void addEdge(const int from, const int to)\n    {\n        assert(0 <= from);\n        assert(from < n);\n        assert(0 <= to);\n        assert(to < n);\n        elist[from].push_back(to);\n        elist[to].push_back(from);\n    }\n\n    T calculate()\n    {\n        if(n==0){\n            return 0;\n        }else if (n == 1) {\n            return max(cost[0], static_cast<T>(0));\n        }\n        for (ll i = 0; i < latter_maximum; i++) {\n            for (int j = 0; j < latter; j++) {\n                if (i & (1LL << j)) {\n                    ll mask = i - (1LL << j);\n                    for (const int to : elist[j + former]) {\n                        if (to >= former) {\n                            if (i & (1LL << (to - former))) {\n                                mask &= ~(1LL << (to - former));\n                            }\n                        }\n                    }\n                    latter_dp[i] = max(latter_dp[i - (1LL << j)], latter_dp[mask] + cost[j + former]);\n                    break;\n                }\n            }\n        }\n\n        T maximum = latter_dp[latter_maximum - 1];\n        for (ll i = 1; i < former_maximum; i++) {\n            for (int j = 0; j < former; j++) {\n                if (i & (1LL << j)) {\n                    if (former_dp[i - (1LL << j)] != -INF<T>) {\n                        bool ok = true;\n                        ll mask = former_next[i - (1LL << j)];\n                        for (const int to : elist[j]) {\n                            if (to >= former) {\n                                mask &= ~(1LL << (to - former));\n                            } else {\n                                if (i & (1LL << to)) {\n                                    ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (ok) {\n                            former_dp[i] = former_dp[i - (1LL << j)] + cost[j];\n                            former_next[i] = mask;\n                            maximum = max(maximum, former_dp[i] + latter_dp[mask]);\n                        } else {\n                            former_dp[i] = -INF<T>;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        return maximum;\n    }\n\n    const int n;\n    const int former;\n    const int latter;\n    const ll former_maximum;\n    const ll latter_maximum;\n    const vector<T> cost;\n    vector<vector<int>> elist;\n    vector<T> former_dp;\n    vector<T> latter_dp;\n    vector<ll> former_next;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        map<string, int> id;\n        vector<vector<string>> neighbor(N);\n        vector<int> power(N);\n        for (int i = 0; i < N; i++) {\n            string s;\n            cin >> s;\n            id[s] = i;\n            int B;\n            cin >> B;\n            power[i] = B;\n            int C;\n            cin >> C;\n            for (int j = 0; j < C; j++) {\n                string d;\n                cin >> d;\n                neighbor[i].push_back(d);\n            }\n        }\n        set<int> far;\n        for (int i = 1; i < N; i++) {\n            far.insert(i);\n        }\n        for (const string& s : neighbor[0]) {\n            far.erase(id[s]);\n        }\n        const int size = far.size();\n        map<int, int> mp;\n        int cnt = 0;\n        for (const int f : far) {\n            mp[f] = cnt;\n            cnt++;\n        }\n\n        vector<int> B;\n        for (const int f : far) {\n            B.push_back(power[f]);\n        }\n        MaximumIndependentSet st{B};\n        for (const int f : far) {\n            for (const string& name : neighbor[f]) {\n                const int ind = id[name];\n                if (far.find(ind) != far.end()) {\n                    st.addEdge(mp[f], mp[ind]);\n                }\n            }\n        }\n        cout << power[0] + st.calculate() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9;\nint n, b[100], c[100], dp1[1 << 20], dp2[1 << 20];\nstring name[100], d[100][100];\nbool e[100][100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(e, 0, sizeof(e));\n\t\tmap<string, int> id;\n\t\t\n\t\trep(i, n){\n\t\t\tcin >> name[i] >> b[i] >> c[i];\n\t\t\trep(j, c[i]) cin >> d[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, c[i]) e[i][id[d[i][j]]] = e[id[d[i][j]]][i] = 1;\n\t\t\n\t\tint N = n / 2, M = n - N;\n\t\trep(i, 1 << N) dp1[i] = -inf;\n\t\trep(i, 1 << M) dp2[i] = -inf;\n\t\tdp1[1] = b[0]; dp2[0] = 0;\n\t\t\n\t\trep(i, 1 << N) if(dp1[i] != -inf) rep(j, N) if(!(i & 1 << j)){\n\t\t\tif(dp1[i | 1 << j] != -inf) continue;\n\t\t\trep(k, N) if((i & 1 << k) && e[j][k]) goto FAIL;\n\t\t\tdp1[i | 1 << j] = dp1[i] + b[j];\n\t\t\tFAIL:;\n\t\t}\n\t\t\n\t\trep(i, 1 << M) if(dp2[i] != -inf) rep(j, M) if(!(i & 1 << j)){\n\t\t\tif(dp2[i | 1 << j] != -inf) continue;\n\t\t\trep(k, M) if((i & 1 << k) && e[j + N][k + N]) goto FAIL2;\n\t\t\tdp2[i | 1 << j] = dp2[i] + b[j + N];\n\t\t\tFAIL2:;\n\t\t}\n\t\t\n\t\tint ans = 0;\n\t\trep(i, 1 << N){\n\t\t\tint can = (1 << M) - 1;\n\t\t\trep(j, N) if(i & 1 << j) rep(k, M) if(e[j][k + N])\n\t\t\tcan &= ~(1 << k);\n\t\t\t\n\t\t\tfor(int j = can; ; j = j - 1 & can){\n\t\t\t\tans = max(ans, dp1[i] + dp2[j]);\n\t\t\t\tif(j == 0) break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<30\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> strength; //国の強さ\nmultimap<string,string> adjacentCountry; //隣接した国の関係\nll ans=0;\n\n\nint rec(map<string,bool> m,ll sum){\n  ll finsum=0;\n  bool fin=true;\n  map<string,bool>::iterator it = m.begin();\n  while(it != m.end()){\n    //cout << it->first << \" \" << it->second << endl;\n    fin*=it->second;\n    if(!it->second)finsum+=strength[it->first];  \n    it++;\n  }\n  if(fin || finsum == 0){\n    if(ans < sum)ans=sum;\n    return 0;\n  }\n\n  map<string,bool> preUsed;\n  ll preSum=0;\n  it = m.begin();\n  while(it != m.end()){\n    if(!it->second){\n      preSum=sum;\n      preSum+=strength[it->first];\n      //cout << \"sum = \" << sum  << \", it->first = \" << it->first << endl;\n   \n      map<string,bool>::iterator preIt = m.begin();\n      while(preIt != m.end()){\n\tpreUsed[preIt->first]=preIt->second;\n\t//cout << preIt->first << \" \" << preIt->second << endl;\n\t++preIt;\n      }\n      multimap<string,string>::iterator cpyIt = adjacentCountry.find(it->first); \n     int counter = adjacentCountry.count(it->first);\n      //cout << \"coutner = \" << counter << endl;\n      while(counter-- > 0){\n\t//cout << \"cpyIt->first = \" << cpyIt->first << endl;\n\tpreUsed[cpyIt->second]=true;\n\t//cout << \"cpyIt->second =\" << cpyIt->second << endl;\n\t++cpyIt;\n      }\n      preUsed[it->first]=true;\n      /*\n  map<string,bool>::iterator wr = preUsed.begin();\n      while(wr != preUsed.end()){\n\tcout << wr->first << \" \" << wr->second << endl;\n\t++wr;\n      }\n      cout << \"----------------------------------------^w^----\" << endl;\n      */\n      rec(preUsed,preSum);\n    }\n\n    ++it;\n  }\n  \n\n\n\n\n}\n\n\nint main(){\n  int n,val,os;\n  string s,oc;\n  map<string,bool> used;\n  ll sum=0;\n\n  while(true){\n    scanf(\"%d\",&n);\n    if(n == 0)break;\n    ans=0;\n    used.clear();\n    adjacentCountry.clear();\n    strength.clear();\n    rep(i,n){\n      cin >> s;\n      scanf(\"%d %d\",&val,&os);\n      strength[s]=val;\n      if(!used[s])used[s]=false;\n      rep(j,os){\n\tcin >> oc;\n\tadjacentCountry.insert(multimap<string,string>::value_type(s,oc));      \n      }\n      \n      if(i == 0){\n\tsum = val;\n\tused[s]=true;\n\tmultimap<string,string>::iterator sit = adjacentCountry.begin();\n\t//cout << \"IN  ----------------------------\" << endl;\n\twhile(sit != adjacentCountry.end()){\n\t  used[sit->second]=true;\n\t  //cout << sit->second << \" \" <<used[sit->second] << endl;\n\t  ++sit;\n\t}\n\t//cout << \"OTU ========================\" << endl;\n\n      }\n      \n    }\n\n\n\n\n    /*\n    cout << \"-----------------\" << endl;\n    map<string,bool>::iterator it = used.begin();\n    while(it != used.end()){\n      cout << \"it->first = \" << it->first << endl;\n      cout << it->second << endl;\n      ++it;\n    }\n    cout << \"-------------------\" << endl;\n    */\n\n    rec(used,sum);\n    cout << ans << \"aaa\" << endl;\n    \n\n\n\n  }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<ll> power;\n\nvoid preorder(ll p,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tused[p]=true;\n\tpreo.pb(p);\n\tREP(i,(ll)adj[p].size()) if(!used[adj[p][i]]) {\n\t\tpreorder(adj[p][i],used,preo,adj);\n\t}\n}\n\nvoid input(vector<vector<ll>>& adj) {\n\tmap<string,ll> dict;\n\tll cnt=0;\n\tREP(i,n) {\n\t\tstring a;\n\t\tll b,c;\n\t\tcin>>a>>b>>c;\n\t\tif(dict.count(a)==0) {\n\t\t\tdict[a]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p=dict[a];\n\t\tpower[dict[a]]=b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(dict.count(t)==0) {\n\t\t\t\tdict[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tadj[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tif(idx==(ll)preo.size()) {\n\t\tll sum=0;\n\t\tREP(i,(ll)preo.size()) if(used[preo[i]]) sum+=power[preo[i]];\n\t\treturn sum;\n\t}\n\tll ret=0;\n\tif(preo[idx]!=0&&(idx==0||(ll)adj[preo[idx]].size()>1)) {\n\t\tret=max(ret,dfs(idx+1,used,preo,adj));\n\t}\n\tbool ok=true;\n\tREP(i,(ll)adj[preo[idx]].size()) ok=ok&(!used[adj[preo[idx]][i]]);\n\tif(ok) {\n\t\tused[preo[idx]]=true;\n\t\tret=max(ret,dfs(idx+1,used,preo,adj));\n\t}\n\tused[preo[idx]]=false;\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tvector<vector<ll>> adj(n);\n\tinput(adj);\n\tvector<bool> used(n,false);\n\tvector<vector<ll>> preo;\n\tREP(i,n) if(!used[i]) {\n\t\tvector<ll> v;\n\t\tpreorder(i,used,v,adj);\n\t\tpreo.pb(v);\n\t}\n\tused.assign(n,false);\n\tll ans=0;\n\tREP(i,preo.size()) ans+=dfs(0,used,preo[i],adj);\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nint ans = 0;\nvector<int>powers;\n\nint getans(const vector<vector<int>>&tonari,vector<int>ally,vector<bool>oks,const int next,const int pow) {\n\tif (pow + accumulate(powers.begin() + next, powers.end(), pow) <= ans)return 0;\n\telse {\n\t\tif (next == powers.size())return pow;\n\t\tint nans = 0;\n\t\tif(oks[next]){\n\t\t\tvector<int>nally(ally);\n\t\t\tnally.push_back(next);\n\t\t\tvector<bool>noks(oks);\n\t\t\tfor (int c = next + 1; c < powers.size(); ++c) {\n\t\t\t\tif (tonari[next][c])noks[c] = false;\n\t\t\t}\n\t\t\tnans = max(nans, getans(tonari,nally,noks, next + 1, pow + powers[next]));\n\t\t}\n\t\tnans = max(nans,getans(tonari, ally, oks, next + 1, pow));\n\t\tans = max(ans, nans);\n\t\treturn nans;\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tpowers.clear();\n\t\tif (!N)break;\n\t\tvector<string>names;\n\t\tvector<vector<string>>rins(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring a; int  b, c; cin >> a >> b >> c;\n\t\t\tnames.push_back(a);\n\t\t\tpowers.push_back(b);\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\trins[i].push_back(st);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>tonari(N, vector<int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto n : rins[i]) {\n\t\t\t\tint r = find(names.begin(), names.end(), n) - names.begin();\n\t\t\t\ttonari[i][r] = true;\n\t\t\t}\n\t\t}\n\t\tvector<bool>oks(N,true);\n\t\tfor (int c = 1; c < powers.size(); ++c) {\n\t\t\tif (tonari[0][c])oks[c] = false;\n\t\t}\n\t\tint ans = getans(tonari, vector<int>(), oks, 1, powers[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct Dict {\n    map<string,int> dict;\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        int id = dict.size();\n        return dict[str] = id;\n    }\n};\n\nint best = 0;\nvoid dfs(int pos, LL used, int score, const vector<LL> &neighbors, const vector<LL> &neighbors_rem, const vector<int> &scores, const vector<int> &scores_rem) {\n    const int N = neighbors.size();\n    if(pos == N) {\n        best = max(best, score);\n        return; \n    }\n    if(score + scores_rem[pos] <= best) {\n        return;\n    }\n    LL mask = 1LL<<pos;\n\n    if(!(used & mask)) {\n        dfs(pos+1, used | neighbors[pos] | mask, score + scores[pos], neighbors, neighbors_rem, scores, scores_rem);\n    }\n    if((used & mask) || (pos+1 < N && (neighbors_rem[pos+1] & mask))) {\n        dfs(pos+1, used, score, neighbors, neighbors_rem, scores, scores_rem);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<LL> neighbors(N, 0);\n        vector<int> scores(N, 0);\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string name;\n            int score, ncnt;\n            cin >> name >> score >> ncnt;\n            const int cid = dict.get(name);\n            scores[cid] = score;\n            while(ncnt--) {\n                string nname;\n                cin >> nname;\n                const int nid = dict.get(nname);\n                neighbors[cid] |= 1LL<<nid;\n            }\n        }\n\n        vector<LL> neighbors_rem(N, 0);\n        vector<int> scores_rem(N, 0);\n        neighbors_rem[N-1] = neighbors[N-1];\n        scores_rem[N-1] = scores[N-1];\n        for(int i = N-2; i >= 0; --i) {\n            neighbors_rem[i] = neighbors_rem[i+1] | neighbors[i];\n            scores_rem[i] = scores_rem[i+1] + scores[i];\n        }\n        best = 0;\n        dfs(1, neighbors[0] | 1, scores[0], neighbors, neighbors_rem, scores, scores_rem);\n        cout << best << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nint ans = 0;\nvector<int>powers;\nint restp[41];\n\nint getans(const vector<vector<int>>&tonari,vector<bool>oks,const int next,const int pow) {\n\tif (pow +restp[next] <= ans)return 0;\n\telse {\n\t\tif (next == powers.size())return pow;\n\t\tint nans = 0;\n\t\tif(oks[next]){\n\t\t\tvector<bool>noks(oks);\n\t\t\tfor (int c = next + 1; c < powers.size(); ++c) {\n\t\t\t\tif (tonari[next][c])noks[c] = false;\n\t\t\t}\n\t\t\tnans = max(nans, getans(tonari,noks, next + 1, pow + powers[next]));\n\t\t}\n\t\tnans = max(nans,getans(tonari, oks, next + 1, pow));\n\t\tans = max(ans, nans);\n\t\treturn nans;\n\t}\n\n}\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tmemset(restp, 0, sizeof(restp));\n\t\tpowers.clear();\n\t\tif (!N)break;\n\t\tvector<string>names;\n\t\tvector<vector<string>>rins(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring a; int  b, c; cin >> a >> b >> c;\n\t\t\tnames.push_back(a);\n\t\t\tpowers.push_back(b);\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\trins[i].push_back(st);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>tonari(N, vector<int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto n : rins[i]) {\n\t\t\t\tint r = find(names.begin(), names.end(), n) - names.begin();\n\t\t\t\ttonari[i][r] = true;\n\t\t\t}\n\t\t}\n\t\tvector<bool>oks(N,true);\n\t\tfor (int c = 1; c < powers.size(); ++c) {\n\t\t\tif (tonari[0][c])oks[c] = false;\n\t\t}\n\t\tfor (int c = 0; c < N; ++c) {\n\t\t\trestp[c] = accumulate(powers.begin() + c, powers.end(), 0);\n\t\t}\n\t\tint ans = getans(tonari, oks, 1, powers[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nstring a[44],d[44][44];\nbool con[44][44];\nint b[44],c[44];\nint sum1[1<<20],sum2[1<<20];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    map<string,int> id;\n    rep(i,n){\n      cin>>a[i]>>b[i]>>c[i];\n      id[a[i]]=i;\n      rep(j,c[i]){\n        cin>>d[i][j];\n      }\n    }\n    memset(con,0,sizeof(con));\n    memset(sum1,0,sizeof(sum1));\n    memset(sum2,0,sizeof(sum2));\n    rep(i,n)rep(j,c[i]){\n      con[i][id[d[i][j]]]=true;\n    }\n    int n1=n/2,n2=n-n1;\n    rep(S,1<<n1){\n      bool ok=true;\n      rep(i,n1)rep(j,i){\n        if(((S>>i)&1)==1&&((S>>j)&1)==1){\n          if(con[i][j])ok=false;\n        }\n      }\n      if(ok){\n        rep(i,n1)if(((S>>i)&1)==1)sum1[S]+=b[i];\n      }\n    }\n    rep(S,1<<n2){\n      bool ok=true;\n      rep(i,n2)rep(j,i){\n        if(((S>>i)&1)==1&&((S>>j)&1)==1){\n          if(con[i+n1][j+n1])ok=false;\n        }\n      }\n      if(ok){\n        rep(i,n2)if(((S>>i)&1)==1)sum2[S]+=b[i+n1];\n      }\n      rep(i,n2)if(((S>>i)&1)==1)maxch(sum2[S],sum2[S^(1<<i)]);\n    }\n    int res=0;\n    rep(S,1<<n1){\n      if((S&1)==0)continue;\n      int S2=(1<<n2)-1;\n      rep(i,n1)rep(j,n2){\n        if(((S>>i)&1)==1&&((S2>>j)&1)==1&&con[i][j+n1]){\n          S2=S2^(1<<j);\n        }\n      }\n      maxch(res,sum1[S]+sum2[S2]);\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define r(i,n) for(int i=0;i<n;i++)\nstring s[50],t;\nint n,a[50],x,ans;\nvector<string>v[50];\nset<string>st[50];\nbool used[50];\nmap<string,int>m;\nvoid dfs(int d,int p){\n    if(used[d]){\n        dfs(d+1,p);\n        return ;\n    }\n    if(d==n)ans=max(ans,p);\n    else{\n        int res=0;\n        for(int i=0;i<n;i++){\n            if(!used[i])res+=a[i];\n        }\n        if(res+p<=ans)return ;\n        vector<int>vv;\n        r(i,v[d].size()){\n            if(!used[m[v[d][i]]])\n              used[m[v[d][i]]]=1,\n              vv.push_back(m[v[d][i]]);\n        }\n        dfs(d+1,p+a[d]);\n        r(i,vv.size())used[vv[i]]=0;\n        res=0;\n        for(int i=0;i<n;i++){\n            if(!used[i])res+=a[i];\n        }\n        if(res+p<=ans)return ;\n        dfs(d+1,p);\n    }\n}\nint main(){\n    while(cin>>n,n){\n        m.clear();\n        ans=0;\n        memset(used,0,sizeof(used));\n        r(i,50)v[i].clear();\n        r(i,n){\n            cin>>s[i];\n            cin>>a[i]>>x;\n            r(j,x){\n                cin>>t;\n                v[i].push_back(t);\n            }\n            m[s[i]]=i;\n        }\n        used[0]=1;\n        r(i,v[0].size()){\n            used[m[v[0][i]]]=1;\n        }\n        dfs(1,a[0]);\n        cout<<ans<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<ll> power;\n\nvoid preorder(ll p,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tused[p]=true;\n\tpreo.pb(p);\n\tREP(i,(ll)adj[p].size()) if(!used[adj[p][i]]) {\n\t\tpreorder(adj[p][i],used,preo,adj);\n\t}\n}\n\nvoid input(vector<vector<ll>>& adj) {\n\tmap<string,ll> dict;\n\tll cnt=0;\n\tREP(i,n) {\n\t\tstring a;\n\t\tll b,c;\n\t\tcin>>a>>b>>c;\n\t\tif(dict.count(a)==0) {\n\t\t\tdict[a]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p=dict[a];\n\t\tpower[dict[a]]=b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(dict.count(t)==0) {\n\t\t\t\tdict[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tadj[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj,ll sum) {\n\tif(idx==(ll)preo.size()) {\n\t\treturn sum;\n\t}\n\tll ret=0;\n\tif(preo[idx]!=0&&(idx==0||(ll)adj[preo[idx]].size()>1)) {\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum));\n\t}\n\tbool ok=true;\n\tREP(i,(ll)adj[preo[idx]].size()) {\n\t\tok=ok&(!used[adj[preo[idx]][i]]);\n\t\tif(!ok) {\n\t\t\tif((ll)adj[preo[idx]].size()>1) ret=max(ret,dfs(idx+1,used,preo,adj,sum));\n\t\t\tused[preo[idx]]=false;\n\t\t\treturn ret;\n\t\t}\n\t}\n\tif(ok) {\n\t\tused[preo[idx]]=true;\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum+power[preo[idx]]));\n\t}\n\tused[preo[idx]]=false;\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tvector<vector<ll>> adj(n);\n\tinput(adj);\n\tvector<bool> used(n,false);\n\tvector<vector<ll>> preo;\n\tREP(i,n) if(!used[i]) {\n\t\tvector<ll> v;\n\t\tpreorder(i,used,v,adj);\n\t\tpreo.pb(v);\n\t}\n\tused.assign(n,false);\n\tll ans=0;\n\tll x=0;\n\tREP(i,preo.size()) ans+=dfs(0,used,preo[i],adj,x);\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring a[40];\nint b[40];\nvector<string> d[40];\nmap<string,int> sn;\n\nint dfs(long long u,int c){\n  if(c==n){\n    return 0;\n  }else{\n    int m=dfs(u,c+1);\n    int i;\n    for(i=0;i<d[c].size();i++){\n      if(u>>sn[d[c][i]]&1)break;\n    }\n    if(i==d[c].size()){\n      m=max(m,dfs(u|1LL<<c,c+1)+b[c]);\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    sn.clear();\n    for(int i=0;i<n;i++){\n      int c;\n      cin>>a[i]>>b[i]>>c;\n      sn[a[i]]=i;\n      d[i].resize(c);\n      while(c--){\n\tcin>>d[i][c];\n      }\n    }\n    cout<<dfs(1,1)+b[0]<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50;\n// input ????????????\nstring A[MAXN], D[MAXN][MAXN];\nint B[MAXN], C[MAXN];\nint N;\n\n// ?????¨?????????????????±\nint strength[MAXN];\nbool G[MAXN][MAXN];\n\nll memo[MAXN];\nint dp1[1<<21], dp2[1<<21];\n\n// s ???????????????????????¨???????????£????????????????????????????????§???\nint dfs1(int s) {\n\tint& ret = dp1[s];\n\tif (ret >= 0) return ret;\n\tret = 0;\n\tint n = N/2;\n\tfor (int i = 0; i < n; i++) {\n\t\tif ((s>>i)&1) {\n\t\t\t// i ????????£?????????\n\t\t\tint tmp = strength[i];\n\t\t\tint ns = (int)(((ll)s)&memo[i]);\n\t\t\ttmp += dfs1(ns);\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dfs2(int s) {\n\tint& ret = dp2[s];\n\tif (ret >= 0) return ret;\n\tret = 0;\n\tint n = N/2, n1 = N-n;\n\tfor (int i = 0; i < n1; i++) {\n\t\tif ((s>>i)&1) {\n\t\t\t// i ????????£?????????\n\t\t\tint tmp = strength[i+n];\n\t\t\tint ns = (int)((ll)s & (memo[i+n]>>n));\n\t\t\ttmp += dfs2(ns);\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N) {\n    \tif (N==0) break;\n    \tmap<string, int> mp;\n    \tfor (int i = 0; i < N; i++) {\n    \t\tcin >> A[i] >> B[i] >> C[i];\n    \t\tmp[A[i]] = 0;\n    \t\tfor (int j = 0; j < C[i]; j++) {\n    \t\t\tcin >> D[i][j];\n    \t\t}\n    \t}\n    \t{\n    \t\tint k = 0;\n    \t\tfor (auto& p : mp) \n    \t\t\tp.second = k++;\n    \t}\n    \t// ?????±????????¨??????????????????\n    \tfor (int i = 0; i < N; i++) \n    \t\tstrength[mp[A[i]]] = B[i];\n    \t// ??°??????????????????\n    \tmemset(G, false, sizeof(G));\n    \tfor (int i = 0; i < N; i++) {\n    \t\tint v = mp[A[i]];\n    \t\tG[v][v] = true;\n    \t\tfor (int j = 0; j < C[i]; j++) {\n    \t\t\tint u = mp[D[i][j]];\n    \t\t\tG[v][u] = true;\n    \t\t}\n    \t}\n    \t// ?¨???????????????¨\n    \tfor (int i = 0; i < N; i++) {\n    \t\tll tmp = 0;\n    \t\tfor (int j = 0; j < N; j++) {\n    \t\t\tif (G[i][j]) tmp |= 1ll<<j;\n    \t\t}\n    \t\ttmp = ((1ll<<55)-1)^tmp;\n    \t\tmemo[i] = tmp;\n    \t}\n    \tif (N==1) {\n    \t\tcout << strength[0] << endl;\n    \t\tcontinue;\n    \t}\n    \t// ????????¨??????\n    \tmemset(dp1, -1, sizeof(dp1));\n    \tmemset(dp2, -1, sizeof(dp2));\n    \tint n = N/2, n1 = N-n;\n    \tint v = mp[A[0]];\n    \tint ans = 0;\n    \tfor (int s = 0; s < 1<<n; s++) {\n    \t\tbool ng = false;\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tif (G[v][i] && ((s>>i)&1)) ng = true;\n    \t\t}\n    \t\tif (v < n && ((s>>v)&1)) ng = true;\n    \t\tif (ng) continue;\n    \t\tll flag = (1ll<<N)-1;\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tif ((s>>i)&1) {\n    \t\t\t\tflag &= memo[i];\n    \t\t\t}\n    \t\t}\n    \t\tflag &= memo[v];\n    \t\tint ns = (int)(flag>>n);\n    \t\tans = max(ans, strength[v]+dfs1(s)+dfs2(ns));\n    \t}\n    \tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = 1 << 21;\nint cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nbool E[41][41];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tmemset(E, 0, sizeof(E));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << B[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[mask | (1 << i)] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tx -= dp[mask];\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint B[50];\nmap<ll,int> power;\nvector<int> edge[50];\nll admask[50];\n\nvoid dfs(ll &mask, int n, ll m2){\n\tif( m2 & (1<<n) ) return;\n\tmask |= (1<<n);\n\tfor(auto t: edge[n]) if(((mask|m2) & (1<<t)) == 0){\n\t\tdfs(mask, t, m2);\n\t}\n}\n\nvoid print(ll n){\n\trep(i,10) cout << (n&(1<<i) ? 1 : 0 );\n}\n\nint N;\nll solve(int n, ll m2);\nll solve1(ll mm, ll m2){\n\tif( power.count(mm) ) return power[mm];\n\tll mx = 0;\n\trep(j,N+1) if( (mm&(1<<j)) ){\n\t\tll p = solve(j, m2);\n\t\tmx = max<ll>( mx, p );\n\t\t//cout << \"j = \" << j << \" \" << p << endl;\n\t}\n\treturn power[mm] = mx;\n}\n\nll solve(int n, ll m2){\n\t//cout << \"solve: \" << n << \" \" << m2 << endl;\n\tll m = 0;\n\tdfs(m, n, m2);\n\tm ^= (m & m2);\n\tif( power.count(m) ) return power[m];\n\n\tll to = 0;\n\tll ret = 0;\n\tll mask = (1<<n) | admask[n];\n\tmask ^= mask & m2;\n\tfor(auto t: edge[n]) if( !((1<<t)&m2) ) to |= admask[t];\n\tto ^= to & m2;\n\trep(i,N+1) if( ((to&mask)^to) & (1<<i) ){\n\t\tll mm = 0, mx=0;\n\t\tdfs(mm, i, m2|mask);\n\t\tmm ^= mm&mask;\n\t\tmx = solve1(mm, m2|mask);\n\t\t//cout << \"mm = \" << i << \" \"; print(mm); cout << endl;\n\t\tret += mx;\n\t\t//cout << \"mx=\" << mx << \"  ret=\" << ret << endl;\n\n\t\tmask |= mm;\n\t}\n\t//print(m);cout << \":\\t\" << ret + B[n] << endl;\n\treturn ret + B[n];\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tmap<string, int> idx;\n\t\tvector<string> Ds[50];\n\n\t\tB[N] = 0;\n\t\tpower.clear();\n\t\tpower[0] = 0;\n\t\trep(i,50) edge[i].clear();\n\t\trep(i,50) admask[i] = 0;\n\n\t\trep(i,N){\n\t\t\tstring A, D;\n\t\t\tint C;\n\t\t\tcin >> A >> B[i] >> C;\n\t\t\tidx[A] = i;\n\t\t\trep(j,C){\n\t\t\t\tcin >> D;\n\t\t\t\tDs[i].push_back(D);\n\t\t\t}\n\t\t}\n\t\trep(i,N) for(auto s: Ds[i]){\n\t\t\tint j = idx[s];\n\t\t\tedge[i].push_back(j);\n\t\t\tedge[j].push_back(i);\n\t\t\tadmask[i] |= (1<<j);\n\t\t\tadmask[j] |= (1<<i);\n\t\t}\n\t\trep(i,N){\n\t\t\tint j = N;\n\t\t\tedge[i].push_back(j);\n\t\t\tedge[j].push_back(i);\n\t\t\tadmask[i] |= (1<<j);\n\t\t\tadmask[j] |= (1<<i);\n\t\t}\n\n\t\tcout << solve(0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2403\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap <string, int> M;\nint Bs[40];\nvector<string> Dstemp[40];\nlong long Ds[40];\nint N;\nmap <long long, int> C[40];\n\nvoid init() {\n  M.clear();\n  fill(Bs, Bs+40, 0);\n  for (auto i=0; i<40; i++) {\n    Dstemp[i].clear();\n    C[i].clear();\n  }\n  fill(Ds, Ds+40, 0);\n}\n\nint DFS(long long saiyo, int x) {\n  if (x == N) {\n    int ans = 0;\n    for (auto i=0; i<N; i++) {\n      if (saiyo & (1 << i)) {\n\tans += Bs[i];\n      }\n    }\n    return ans;\n  }\n  long long rinsetsu = 0;\n  for (auto i=0; i<N; i++) {\n    if (saiyo >> i & 1) {\n      rinsetsu = rinsetsu | Ds[i];\n    }\n  }\n  long long nowrin = rinsetsu;\n  //cerr << \"saiyo = \" << saiyo << \", x = \" << x \n  //     << \", notrin = \" << ((~nowrin) & ((1 << N) - 1)) << endl;\n  for (auto i=x; i<N; i++) {\n    rinsetsu = rinsetsu | Ds[i];\n  }\n  long long kyokudai = (~rinsetsu & ((1 << N) - 1)) | saiyo;\n  if (saiyo != kyokudai) {\n    return DFS(kyokudai, x);\n  }\n  int ans;\n  if (C[x].find(saiyo) != C[x].end()) {\n    return C[x][saiyo];\n  }\n  if ( ((~nowrin) & ((1 << N) - 1)) >> x & 1) {\n    ans = max(DFS(saiyo | (1<<x), x+1), DFS(saiyo, x+1));\n  } else {\n    ans = DFS(saiyo, x+1);\n  }\n  C[x][saiyo] = ans;\n  return ans;\n}\n\nint main() {\n  while(cin >> N && N) {\n    init();\n    for (auto i=0; i<N; i++) {\n      string A;\n      int C;\n      cin >> A >> Bs[i] >> C;\n      M[A] = i;\n      for (auto j=0; j<C; j++) {\n\tstring D;\n\tcin >> D;\n\tDstemp[i].push_back(D);\n      }\n    }\n    for (auto i=0; i<N; i++) {\n      for (auto j=0; j<Dstemp[i].size(); j++) {\n\tDs[i] += (1 << M[Dstemp[i][j]]);\n      }\n      // cerr << \"Ds[\" << i << \"] = \" << Ds[i] << endl;\n    }\n    cout << DFS(1, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// compile in C++11. use -std=c++11.\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define repeat(i,n) for(int i=0;i<static_cast<int>(n);i++)\n#define debug(x) #x << \"=\" << (x)\n#define dump(x) cerr << debug(x) << \" (L:\" << __LINE__ << \")\"<< endl\n\ntypedef long long ll;\ntypedef complex<double> point;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    os << \"[\";\n    for(const auto& v : vec){\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long ll;\n\nll solve(ll k,ll cur,ll mask,const vector<ll>& power,\n                             const vector<ll>& masks){\n    if(k == power.size()) return cur;\n    if(mask & (1 << k)){\n        // already masked\n        return solve(k+1,cur,mask,power,masks);\n    }else{\n        return max(solve(k+1,cur+power[k],mask | masks[k],power,masks),\n                   solve(k+1,cur,mask,power,masks));\n    }\n}\n\nint main(){\n    while(true){\n        int n;cin >> n;\n        if(n == 0) break;\n        unordered_map<string,int> index_of;\n        int k = 0;\n        vector<ll> mask(n);\n        vector<ll> power(n);\n        for(int i=0;i<n;i++){\n            string A;int B,C;\n            cin >> A >> B >> C;\n            if(index_of.find(A) == index_of.end()){\n                index_of[A] = k;k++;\n            }\n            power[index_of[A]] = B;\n            for(int j=0;j<C;j++){\n                string d;cin >> d;\n                if(index_of.find(d) == index_of.end()){\n                    index_of[d] = k;k++;\n                }\n                mask[index_of[A]] = mask[index_of[A]] | (1 << index_of[d]);\n            }\n        }\n        cout << solve(1,power[0],mask[0],power,mask) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[45];\nbool G[45][45];\nint64 NG[45];\nint sum[45];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[fake] <= beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint m, q[64];\n\nvoid collect(int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q[m++] = at;\n    rep (i, N) if (g[at][i]) collect(i);\n}\n\nint n, a, r[64], p[64];\nInt f[64];\n\nvoid prepare() {\n    n = m;\n    a = 0;\n    rep (i, n) r[i] = q[i];\n    rep (i, n) {\n        p[i] = B[r[i]];\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nvoid rec(int k, Int u) {\n    int s = 0;\n    rep (i, n) if (u&(1LL<<i)) s += p[i];\n    if (s < a) return ;\n    if (k == n) a = s;\n    else {\n        rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return ;\n        const int mask = (1LL<<n) - 1;\n        if (u&(1LL<<k)) rec(k+1, u&(mask-f[k]));\n        if (r[k]) rec(k+1, u&(mask-(1LL<<k)));\n    }\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        m = 0;\n        collect(i);\n        prepare();\n        rec(0, (1LL<<n)-1);\n        ans += a;\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n;\nstring name[40];\nvector<string> neighbor[40];\nmap<string,int> name2id;\nint a[40],b[40],c[40];\nint G[40][40];\n\nconst int N=1<<20;\nint dp[N];\nint NG[40],OK[40];\n\nint main()\n{\n    cin.tie(0);ios::sync_with_stdio(false);\n\n    while(cin >>n,n)\n    {\n        // initialize\n        name2id.clear();\n        rep(i,40) neighbor[i].clear();\n        memset(G,0,sizeof(G));\n        memset(dp,0,sizeof(dp));\n        memset(NG,0,sizeof(NG));\n        memset(OK,0,sizeof(OK));\n\n        // input\n        rep(i,n)\n        {\n            cin >>name[i] >>b[i] >>c[i];\n            neighbor[i].resize(c[i]);\n            rep(j,c[i]) cin >>neighbor[i][j];\n\n            a[i] = i;\n            name2id[name[i]] = i;\n        }\n\n        rep(i,n)rep(j,c[i]) G[i][name2id[neighbor[i][j]]] = 1;\n\n        int X=n/2, Y=n-X;\n\n        // make NG mask\n        rep(i,X)rep(j,X)if(G[i][j]) NG[i] |= 1<<j;\n        rep(i,Y)rep(j,Y)if(G[X+i][X+j]) NG[X+i] |= 1<<j;\n\n        // make OK mask\n        rep(i,X)rep(j,Y)if(G[i][X+j]==0) OK[i] |= 1<<j;\n\n        // ?????????????????????????????¶\n        rep(mask,1<<Y)\n        {\n            bool ok=true;\n            rep(i,Y)if(mask>>i&1) ok &= ((NG[X+i]&mask) == 0);\n\n            if(ok)\n            {\n                rep(i,Y)if(mask>>i&1) dp[mask] += b[X+i];\n            }\n        }\n\n        rep(mask,1<<Y)rep(i,Y)if(!(mask>>i&1))\n        {\n            int nmask = mask|(1<<i);\n            dp[nmask] = max(dp[nmask],dp[mask]);\n        }\n\n        int ans=0;\n        // ?????????????????????????????¶\n        for(int mask=1; mask<(1<<X); mask+=2)\n        {\n            bool ok=true;\n            int val = 0;\n            rep(i,X)if(mask>>i&1)\n            {\n                ok &= ((NG[i]&mask) == 0);\n                val += b[i];\n            }\n            if(!ok) continue;\n\n            int t=(1<<Y)-1;\n            rep(i,X)if(mask>>i&1) t&=OK[i];\n\n            ans = max(ans, val+dp[t]);\n        }\n\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<ll> power;\nvector<bool> de;\nvector<ll> flag;\n\nvoid preorder(ll p,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tused[p]=true;\n\tpreo.pb(p);\n\tflag[p]=(ll)preo.size();\n\tbool upd=false;\n\tREP(i,(ll)adj[p].size()) if(!used[adj[p][i]]) {\n\t\tupd=true;\n\t\tpreorder(adj[p][i],used,preo,adj);\n\t}\n\tde[p]=!upd;\n}\n\nvoid input(vector<vector<ll>>& adj) {\n\tmap<string,ll> dict;\n\tll cnt=0;\n\tREP(i,n) {\n\t\tstring a;\n\t\tll b,c;\n\t\tcin>>a>>b>>c;\n\t\tif(dict.count(a)==0) {\n\t\t\tdict[a]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p=dict[a];\n\t\tpower[dict[a]]=b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(dict.count(t)==0) {\n\t\t\t\tdict[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tadj[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx,vector<int>& used,vector<ll>& preo,vector<vector<ll>>& adj,ll sum,vector<vector<ll>>& ban) {\n\tif(idx==(ll)preo.size()) {\n\t\treturn sum;\n\t}\n\tif(used[preo[idx]]==0) return dfs(idx+1,used,preo,adj,sum,ban);\n\tll ret=0;\n\tif(preo[idx]!=0&&!de[preo[idx]]&&!(ll)ban[preo[idx]].size()!=0) {\n\t\tused[preo[idx]]=0;\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum,ban));\n\t}\n\tused[preo[idx]]=1;\n\tvector<bool> buf((ll)ban[preo[idx]].size());\n\tREP(i,buf.size()) {\n\t\tbuf[i]=used[ban[preo[idx]][i]];\n\t\tused[ban[preo[idx]][i]]=0;\n\t}\n\tret=max(ret,dfs(idx+1,used,preo,adj,sum+power[preo[idx]],ban));\n\tREP(i,buf.size()) {\n\t\tused[ban[preo[idx]][i]]=buf[i];\n\t}\n\tused[preo[idx]]=-1;\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tde.resize(n);\n\tflag.resize(n);\n\tvector<vector<ll>> adj(n);\n\tinput(adj);\n\tvector<bool> used(n,false);\n\tvector<vector<ll>> preo;\n\tREP(i,n) if(!used[i]) {\n\t\tvector<ll> v;\n\t\tpreorder(i,used,v,adj);\n\t\tpreo.pb(v);\n\t}\n\tvector<int> used2(n,-1);\n\tll ans=0;\n\tvector<vector<ll>> ban(n);\n\tREP(i,n) REP(j,(ll)adj[i].size()) {\n\t\tif(flag[adj[i][j]]>flag[i]) ban[i].pb(adj[i][j]);\n\t};\n\tREP(i,preo.size()) ans+=dfs(0,used2,preo[i],adj,0,ban);\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <bitset>\n\nusing namespace std;\n\n#define UNION true\n#define NEIGHBOR true\n\nstruct Union{\n\tstring A;\n\tunsigned short B,C;\n\tint D[42];\n\tqueue<string> S;\n} \tU[42];\n\nstruct UnionSearch{\n\tbitset<41> State;\n\tunsigned short B;\n};\n\nvoid AddUnion(UnionSearch *us, int u){\n\tus->State[u] = UNION;\n\tfor(int i=0;i<U[u].C;i++) us->State.set( U[u].D[i] );\n\tus->B += U[u].B;\n}\n\nint N;\nqueue <UnionSearch> US;\n\n\nint Find(string s){\n\tfor(int i=1;i<=N;i++) if(s==U[i].A) return i;\n\tprintf(\"error\");\n\treturn 0;\n}\n\nmain(){\n\tint i,c;\n\tunsigned short Max;\n\tstring s;\n\tUnionSearch q, p;\n\twhile(cin>>N,N){\n\t//\tUS.clear();\n\t\twhile(!US.empty()) US.pop();\n\t\tfor(i=0;i<42;i++){\n\t\t\tU[i].A = \"\";\n\t\t\tU[i].B=0;\n\t\t\tU[i].C=0;\n\t\t\tmemset(U[i].D, 0, 42*sizeof(int));\n\t\t\twhile(!U[i].S.empty()) U[i].S.pop();\n\t\t}\n\t\tMax = 0;\n\t\tq.B=0;\n\t\tq.State.reset();\n\t\t\n\t\tfor(i=1;i<=N;i++){\n\t\t\tcin>>U[i].A>>U[i].B>>c;\n\t\t\twhile(c--){\n\t\t\t\tcin>>s;\n\t\t\t\tU[i].S.push(s);\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=N;i++){\n\t\t\twhile(!U[i].S.empty()){\n\t\t\t\tU[i].D[U[i].C++] = Find(U[i].S.front());\n\t\t\t\tU[i].S.pop();\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tAddUnion(&q, 1);\n\t\tUS.push(q);\n\t\twhile(!US.empty()){\n\t\t\tq = US.front();\n\t\t\tUS.pop();\n\t\t\tint t;\n\t\t\tfor(t=1;t<=N;t++){\n\t\t\t\tif(!q.State[t])break;\n\t\t\t\n\t\t\t}\n\t\t\tif(t>N){\n\t\t\t\tMax = max(Max, q.B);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(i=0;i<U[t].C;i++){\n\t\t\t\tp = q;\n\t\t\t\tif(p.State[U[t].D[i]]) continue;\n\t\t\t\tAddUnion(&p, U[t].D[i]);\n\t\t\t\tUS.push(p);\n\t\t\t}\n\t\t\tAddUnion(&q, t);\n\t\t\tUS.push(q);\n\t\t}\n\t\tcout << Max << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n;\nsigned main(){\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs name(n);\n\t\tvi b(n),co(n);\n\t\tvector<vs>in(n);\n\t\trep(i,n){\n\t\t\tcin>>name[i]>>b[i]>>co[i];\n\t\t\tma[name[i]]=1;\n\t\t\tin[i]=vs(co[i]);\n\t\t\trep(j,co[i]){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tma[in[i][j]]=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\trep(i,n)ma[name[i]]=i;\n\t\n\t\tvi A(n);\n\t\trep(i,n)rep(j,in[i].size()){\n\t\t\tint from=ma[name[i]],to=ma[in[i][j]];\n\t\t\tA[from]|=1<<to;\n\t\t}\n\t\tint N=n/2,nN=n-N;\n\t\t\n//\t\trep(i,n){\n//\t\t\tcout<<name[i]<<\" \";\n//\t\t\trep(j,n)cout<<((A[i]&1<<j)>>j)<<\" \";cout<<endl;\n//\t\t}\n\t\tvi dp(1<<nN);\n\t\trep(i,1<<nN){\n\t\t\tbool h=true;\n\t\t\trep(j,nN)if((i&1<<j)&&((i&A[j+N]>>N)))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,nN)if(i&1<<j)sum+=b[N+j];\n\t\t\t\tdp[i]=max(dp[i],sum);\n\t\t\t}\n\t\t\trep(j,nN)if((i&1<<j)==0)\n\t\t\t\tdp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n\t\t}\n\t\t\n\t\tint out=0;\n\t\trep(i,1<<N)if(i&1){\n\t\t\tbool h=true;\n\t\t\trep(j,N)if((i&1<<j)&&(i&A[j]))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,N)if(i&1<<j)sum+=b[j];\n\t\t\t\tt=(1<<nN)-1;\n\t\t\t\trep(j,N)if((i&1<<j))t&=~(A[j]>>N);\n\t\t\t\tout=max(out,sum+dp[t]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n/*\nint n,m;\nvi A,B;\nint dp[52][52][110][2][3];\nint mem[52][52][110][2][3];\nint f(int a,int b,int co,int tu,int pas){\n    if(mem[a][b][co][tu][pas]+inf)return mem[a][b][co][tu][pas];\n\tif(pas==3)\n\t\n    int A,B,TU=(tu+co)%2;\n    if(!tu)A=a+(1+co)/2,B=b+co/2;\n    else A=a+co/2,B=b+(1+co)/2;\n    if(TU==0){\n        int ma=-inf;\n        if(A<n)ma=max(ma,f(a,b,co+1,tu,0));\n        if(co)ma=max(ma,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else if(a+b+co)ma=max(ma,0);\n        cout<<\" \"<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<ma<<\" \"<<dp[a][b][co][tu]<<endl;\n        return mem[a][b][co][tu]=ma;\n    }else{\n        int mi=inf;\n        if(B<m)mi=min(mi,f(a,b,co+1,tu,0));\n        if(co)mi=min(mi,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else mi=min(mi,0);\n        cout<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<mi<<endl;\n        return mem[a][b][co][tu]=mi;\n    }\n}\nint main(){\n    cin>>n>>m;\n    A=vi(n);rep(i,n)cin>>A[i];\n    B=vi(m);rep(i,m)cin>>B[i];\n     \n    rep(l,2)rep(i,n+1)rep(j,m+1){\n        int sum=0;\n        int L=l,I=i,J=j;\n        int co=0;\n        while(1){\n            dp[i][j][co][l]=sum;\n            if(L&&J>=m||!L&&I>=n)break;\n            if(L){\n                if(B[J]+1)sum-=B[J];\n                else sum=0;\n                J++;\n            }else{\n                if(A[I]+1)sum+=A[I];\n                else sum=0;\n                I++;\n            }\n            L^=1;\n            co++;\n        }\n    }   \n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][0];cout<<endl;}\n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][1];cout<<endl;}\n    rep(i,52)rep(j,52)rep(k,110)rep(l,2)rep(q,3)\n        mem[i][j][k][l][q]=-inf;\n    cout<<f(0,0,0,0,1)<<endl;\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        vector<int> power(n);\n        map<string, int> mp;\n        vector<vector<string>> nearby(n);\n        for (int i = 0; i < n; ++i) {\n            string s;\n            int c;\n            cin >> s >> power[i] >> c;\n            mp[s] = i;\n            nearby[i].resize(c);\n            for (int j = 0; j < c; ++j)\n                cin >> nearby[i][j];\n        }\n        vector<long long> isnearby(n, 0LL);\n        for (int i = 0; i < n; ++i)\n            for (auto& j : nearby[i])\n                isnearby[i] |= 1LL << mp[j];\n\n        for (int i = 0; i < n; ++i)\n            if ((isnearby[0] >> i) & 1)\n                power[i] = -1000000;\n\n        int n1 = n / 2;\n        int n2 = n - n1;\n        vector<int> dp(1 << n1, 0);\n        for (int i = 1; i < (1 << n1); i += 2) {\n            int ma = 0;\n            long long inb = 0;\n            for (int j = 0; j < n1; ++j) {\n                if ((i >> j) & 1) {\n                    inb |= isnearby[j];\n                    dp[i] += power[j];\n                    ma = max(ma, dp[i ^ (1 << j)]);\n                }\n            }\n            if (i & inb)\n                dp[i] = ma;\n        }\n        int ans = 0;\n        int msk = (1 << n1) - 1;\n        for (int i = 1; i < (1 << n2); ++i) {\n            int sum = 0;\n            long long inb = 0;\n            for (int j = 0; j < n2; ++j) {\n                if ((i >> j) & 1) {\n                    inb |= isnearby[n1 + j];\n                    sum += power[n1 + j];\n                }\n            }\n            if (!(i & (inb >> n1)))\n                ans = max(ans, sum + dp[(inb & msk) ^ msk]);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tvi pow(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> pow[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tvector<vi> g(n, vi(n));\n\t\tREP(i, n)REP(j, nei[i].size())\n\t\t{\n\t\t\tg[i][mp[nei[i][j]]] = 1;\n\t\t}\n\t\tint ans = 0;\n\t\tset<ll> ok;\n\t\tstack<ll> st;\n\t\tst.push(1);\n\t\twhile (st.size())\n\t\t{\n\t\t\tll tmp = st.top();\n\t\t\tst.pop();\n\t\t\tvi can;\n\t\t\tint sum = 0, cansum = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((tmp >> j) & 1)\n\t\t\t\t{\n\t\t\t\t\tsum += pow[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool f = true;\n\t\t\t\tREP(k, n)\n\t\t\t\t{\n\t\t\t\t\tif (((tmp >> k) & 1) == 0 || k == j) continue;\n\t\t\t\t\tif (g[j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f)\n\t\t\t\t{\n\t\t\t\t\tcan.push_back(j);\n\t\t\t\t\tcansum += pow[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum + cansum <= ans) continue;\n\t\t\tchmax(ans, sum);\n\t\t\tREP(j, can.size())\n\t\t\t{\n\t\t\t\tll nx = tmp | (1ll << can[j]);\n\t\t\t\tif (ok.count(nx)) continue;\n\t\t\t\tok.insert(nx);\n\t\t\t\tst.push(nx);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tvi pow(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> pow[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tvector<vi> g(n, vi(n));\n\t\tREP(i, n)REP(j, nei[i].size())\n\t\t{\n\t\t\tg[i][mp[nei[i][j]]] = 1;\n\t\t}\n\t\tint ans = 0;\n\t\tset<ll> ok;\n\t\tstack<ll> st;\n\t\tst.push(1);\n\t\twhile (st.size())\n\t\t{\n\t\t\tll tmp = st.top();\n\t\t\tst.pop();\n\t\t\tvi can;\n\t\t\tint sum = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((tmp >> j) & 1)\n\t\t\t\t{\n\t\t\t\t\tsum += pow[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool f = true;\n\t\t\t\tREP(k, n)\n\t\t\t\t{\n\t\t\t\t\tif (((tmp >> k) & 1) == 0 || k == j) continue;\n\t\t\t\t\tif (g[j][k])\n\t\t\t\t\t{\n\t\t\t\t\t\tf = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (f) can.push_back(j);\n\t\t\t}\n\t\t\tchmax(ans, sum);\n\t\t\tREP(j, can.size())\n\t\t\t{\n\t\t\t\tll nx = tmp | (1ll << can[j]);\n\t\t\t\tif (ok.count(nx)) continue;\n\t\t\t\tok.insert(nx);\n\t\t\t\tst.push(nx);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nmap<string,int> a;\nvi b,c;\nvector<vs> d;\n\nvvi g;\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tb=c=vi(n);\n\t\td=vector<vs>(n);\n\t\tg=vvi(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s>>b[i]>>c[i];\n\t\t\ta[s]=i;\n\t\t\td[i]=vs(c[i]);\n\t\t\tfor(int j=0;j<c[i];j++) cin>>d[i][j];\n\t\t}\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<c[i];j++) g[i].push_back(a[d[i][j]]);\n\t\tint N=n/2;\n\t\tvi dp(1<<N);\n\t\tfor(int i=1;i<1<<N;i++){\n\t\t\tint v,I=i;\n\t\t\tfor(int j=0;j<N;j++) if(i&1<<j){\n\t\t\t\tv=j+n-N;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tI-=1<<v-n+N;\n\t\t\tfor(int j=0;j<g[v].size();j++){\n\t\t\t\tint u=g[v][j];\n\t\t\t\tif(u>=n-N&&I&1<<u-n+N) I-=1<<u-n+N;\n\t\t\t}\n\t\t\tdp[i]=max(dp[i&i-1],dp[I]+b[v]);\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<1<<n-N;i++){\n\t\t\tint I=(1<<N)-1,sum=0;\n\t\t\tbool f=1;\n\t\t\tfor(int j=0;j<n-N;j++) if(i&1<<j){\n\t\t\t\tsum+=b[j];\n\t\t\t\tfor(int k=0;k<g[j].size();k++){\n\t\t\t\t\tint v=g[j][k];\n\t\t\t\t\tif(v<n-N&&i&1<<v) f=0;\n\t\t\t\t\tif(v>=n-N&&I&1<<v-n+N) I-=1<<v-n+N;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(f&&i&1) res=max(res,dp[I]+sum);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        int mid = n/2;\n        vi p(n),c(n);\n        vector<vs> s(n);\n        int id = 0;\n        map<string,int> mp;\n        rep(i,n){\n            string t;\n            cin >> t >> p[i] >> c[i];\n            mp[t] = id++;\n            s[i].resize(c[i]);\n            rep(j,c[i]){\n                cin >> s[i][j];\n            }\n        }\n        vi st(mid),ed(n-mid),se(mid);\n        vi sout((1 << mid),0);\n        rep(i,mid){\n            st[i] = (1 << i);\n            rep(j,c[i]){\n                int num = mp[s[i][j]];\n                if(num >= mid){\n                    se[i] |= (1 << (num-mid));\n                }else{\n                    st[i] |= (1 << num);\n                }\n            }\n        }\n        rep(i,n-mid){\n            ed[i] = (1 << i);\n            rep(j,c[i+mid]){\n                int num = mp[s[i+mid][j]];\n                if(num >= mid){\n                    ed[i] |= (1 << (num-mid));\n                }\n            }\n        }\n        vector<bool> dst((1 << mid),false),ded((1 << (n-mid)),false);\n        vi p1((1 << mid),0),p2((1 << (n-mid)),0);\n        vector<int> mx((1 << (n-mid)),0);\n        dst[0] = true;\n        rep(i,(1 << mid)){\n            if(dst[i]){\n                rep(j,mid){\n                    if(!((i >> j) & 1)){\n                        if(!(i & st[j])){\n                            dst[i^(1 << j)] = true;\n                            sout[i^(1 << j)] = sout[i] | se[j];\n                        }\n                    }else{\n                        p1[i] += p[j];\n                    }\n                }\n            }\n        }\n        ded[0] = true;\n        rep(i,(1 << (n-mid))){\n            if(ded[i]){\n                rep(j,n-mid){\n                    if(!((i >> j) & 1)){\n                        if(!(i & ed[j])){\n                            ded[i^(1 << j)] = true;\n                        }\n                    }else{\n                        p2[i] += p[j+mid];\n                    }\n                }\n                mx[i] = p2[i];\n            }else{\n                rep(j,n-mid){\n                    if((i >> j) & 1){\n                        cmx(mx[i],mx[i^(1 << j)]);\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        rep(i,(1 << mid)){\n            if((i & 1) && dst[i]){\n                cmx(ans,p1[i] + mx[((1 << (n-mid))-1) ^ sout[i]]);\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = 1 << 21;\nint X[MAX], Y[MAX], cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tvector<vector<bool>> E(N, vector<bool>(N));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << A[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(X, 0, sizeof(X));\n\t\t\tmemset(Y, 0, sizeof(Y));\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nmask = mask | (1 << i);\n\t\t\t\t\tdp[nmask] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tint tmp = dp[mask];\n\n\t\t\t\tx -= tmp;\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define M 40\n#define max(a,b) (a>b?a:b)\n\ntypedef unsigned int uint;\n\ntypedef vector<int> Graph;\n\nGraph g[M];\nint power[M], sum[M], n, ans;\n\nint solve(int s, int del[M], int pw) {\n\tint del2[M], res = 0, r;\n\tpw += power[s];\n\tfor(int i=0; i<n; ++i) del2[i] = del[i];\n\tfor(uint i=0; i<g[s].size(); ++i) {\n\t\tdel2[g[s][i]] = 1;\n\t}\n\tfor(int i=s+1; i<n; ++i) {\n\t\tif(pw+sum[n-1]-sum[i-1]<=ans) break;\n\t\tif(!del2[i]) {\n\t\t\tr = solve(i, del2, pw);\n\t\t\tres = max(r, res);\n\t\t}\n\t}\n\tans = max(pw+res, ans);\n\treturn res;\n}\n\nint main() {\n\tmap<string, int> kuni;\n\tstring name, near_n;\n\tint nc, del[M];\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfor(int i=0; i<n; ++i) g[i].clear();\n\t\tkuni.clear();\n\t\tfor(int i=0, c=0; i<n; ++i) {\n\t\t\tcin >> name;\n\t\t\tif(!kuni.count(name)) {\n\t\t\t\tkuni[name] = c++;\n\t\t\t}\n\t\t\tcin >> power[kuni[name]] >> nc;\n\t\t\tfor(int j=0; j<nc; ++j) {\n\t\t\t\tcin >> near_n;\n\t\t\t\tif(!kuni.count(near_n)) {\n\t\t\t\t\tkuni[near_n] = c++;\n\t\t\t\t}\n\t\t\t\tg[kuni[name]].push_back(kuni[near_n]);\n\t\t\t\tg[kuni[near_n]].push_back(kuni[name]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; ++i) sum[i] = !i ? power[0] : sum[i-1]+power[i];\n\t\tfor(int i=0; i<n; ++i) del[i] = 0;\n\t\tans = 0; cout << solve(0, del, 0) << endl;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], cf[64], ct[64];\nint dp[1<<20];\n\nint solve() {\n    const int n = N / 2, m = N - n;\n    const int nn = 1<<n, mm = 1<<m;\n    memset(cf, 0, sizeof(cf));\n    memset(ct, 0, sizeof(ct));\n    rep (i, n) rep (j, n) if (g[i][j]) cf[i] |= 1<<j;\n    rep (i, m) rep (j, m) if (g[i+n][j+n]) cf[i+n] |= 1<<j;\n    rep (i, m) rep (j, n) if (g[i+n][j]) ct[i] |= 1<<j;\n    rep (i, nn) dp[i] = 0;\n    rep (b, nn) {\n        if (b&1) {\n            bool ok = true;\n            rep (i, n) if (b&(1<<i) && b&cf[i]) { ok = false; break; }\n            if (ok) {\n                int s = 0;\n                rep (i, n) if (b&(1<<i)) s += B[i];\n                dp[b] = max(dp[b], s);\n            }\n        }\n        rep (i, n) dp[b|(1<<i)] = max(dp[b|(1<<i)], dp[b]);\n    }\n    int ans = 0;\n    rep (b, mm) {\n        bool ok = true;\n        rep (i, m) if (b&(1<<i) && b&cf[i+n]) { ok = false; break; }\n        if (!ok) continue;\n        int s = 0;\n        rep (i, m) if (b&(1<<i)) s += B[i+n];\n        int z = 0;\n        rep (i, m) if (b&(1<<i)) z |= ct[i];\n        ans = max(ans, dp[nn-1-z] + s);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint B[50];\nmap<ll,int> power;\nvector<int> edge[50];\nll admask[50];\n\nvoid dfs(ll &mask, int n, ll m2){\n\tif( m2 & (1ll<<n) ) return;\n\tmask |= (1ll<<n);\n\tfor(auto t: edge[n]) if(((mask|m2) & (1ll<<t)) == 0){\n\t\tdfs(mask, t, m2);\n\t}\n}\n\nvoid print(ll n){\n\trep(i,10) cout << (n&(1ll<<i) ? 1 : 0 );\n}\n\nint N;\nll solve(int n, ll m2);\nll solve1(ll mm, ll m2){\n\tif( power.count(mm) ) return power[mm];\n\tll mx = 0;\n\trep(j,N+1) if( (mm&(1ll<<j)) ){\n\t\tll p = solve(j, m2);\n\t\tmx = max<ll>( mx, p );\n\t\t//cout << \"j = \" << j << \" \" << p << endl;\n\t}\n\treturn power[mm] = mx;\n}\n\nll solve(int n, ll m2){\n\t//cout << \"solve: \" << n << \" \" << m2 << endl;\n\tll m = 0;\n\tdfs(m, n, m2);\n\tm ^= (m & m2);\n\tif( power.count(m) ) return power[m];\n\n\tll to = 0;\n\tll ret = 0;\n\tll mask = (1ll<<n) | admask[n];\n\tmask ^= mask & m2;\n\tfor(auto t: edge[n]) if( !((1ll<<t)&m2) ) to |= admask[t];\n\tto ^= to & m2;\n\trep(i,N+1) if( ((to&mask)^to) & (1ll<<i) ){\n\t\tll mm = 0, mx=0;\n\t\tdfs(mm, i, m2|mask);\n\t\tmm ^= mm&mask;\n\t\tmx = solve1(mm, m2|mask);\n\t\t//cout << \"mm = \" << i << \" \"; print(mm); cout << endl;\n\t\tret += mx;\n\t\t//cout << \"mx=\" << mx << \"  ret=\" << ret << endl;\n\n\t\tmask |= mm;\n\t}\n\t//print(m);cout << \":\\t\" << ret + B[n] << endl;\n\treturn ret + B[n];\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tmap<string, int> idx;\n\t\tvector<string> Ds[50];\n\n\t\tB[N] = 0;\n\t\tpower.clear();\n\t\tpower[0] = 0;\n\t\trep(i,50) edge[i].clear();\n\t\trep(i,50) admask[i] = 0;\n\n\t\trep(i,N){\n\t\t\tstring A, D;\n\t\t\tint C;\n\t\t\tcin >> A >> B[i] >> C;\n\t\t\tidx[A] = i;\n\t\t\trep(j,C){\n\t\t\t\tcin >> D;\n\t\t\t\tDs[i].push_back(D);\n\t\t\t}\n\t\t}\n\t\trep(i,N) for(auto s: Ds[i]){\n\t\t\tint j = idx[s];\n\t\t\tedge[i].push_back(j);\n\t\t\tedge[j].push_back(i);\n\t\t\tadmask[i] |= (1ll<<j);\n\t\t\tadmask[j] |= (1ll<<i);\n\t\t}\n\t\trep(i,N){\n\t\t\tint j = N;\n\t\t\tedge[i].push_back(j);\n\t\t\tedge[j].push_back(i);\n\t\t\tadmask[i] |= (1ll<<j);\n\t\t\tadmask[j] |= (1ll<<i);\n\t\t}\n\n\t\tcout << solve(0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nvector<int> power;\nvector<vector<int> > adj;\n\nint dfs(int country, long long ng) {\n\tif(country == power.size())\n\t\treturn 0;\n\n\tint res = dfs(country + 1, ng);\n\n\tif((ng & (1ll << country)) == 0) {\n\t\tfor(int i = 0; i < adj[country].size(); ++i)\n\t\t\tng |= (1ll << adj[country][i]);\n\n\t\tchmax(res, dfs(country + 1, ng) + power[country]);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tfor(int n = 0; cin >> n, n;) {\n\t\tmap<string, int> convert;\n\t\tvector<vector<string> > d(n);\n\t\tpower.clear();\n\t\tpower.resize(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring a;\n\t\t\tint c;\n\t\t\tcin >> a >> power[i] >> c;\n\n\t\t\tconvert[a] = i;\n\n\t\t\td[i].resize(c);\n\t\t\tfor(int j = 0; j < c; ++j)\n\t\t\t\tcin >> d[i][j];\n\n\t\t}\n\n\t\tadj.clear();\n\t\tadj.resize(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < d[i].size(); ++j)\n\t\t\t\tadj[i].push_back(convert[d[i][j]]);\n\n\t\tlong long ng = 0;\n\t\tfor(int i = 0; i < adj[0].size(); ++i)\n\t\t\tng |= (1ll << adj[0][i]);\n\n\t\tint ans = power[0] + dfs(1, ng);\n\t\tcout << ans << endl;\n\t}\n\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nvector<ll> mask;\n\nint dfs(int l, int N, int b, vector<vector<int>>& g, vector<int>& str, vector<int>& dp) {\n    int& res = dp[b];\n    if(res != -1) {\n        return res;\n    }\n    res = 0;\n    for(int i=0; i<N; ++i) {\n        if((b >> i) & 1) {\n            int nb = b & ~(1 << i);\n            nb &= ~(int)(mask[l+i] >> l);\n            res = max(res, dfs(l, N, nb, g, str, dp) + str[l+i]);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        map<string, int> id;\n        vector<vector<int>> g(N, vector<int>(N));\n        mask.resize(N);\n        vector<int> str(N);\n        for(int i=0; i<N; ++i) {\n            string A;\n            int B, C;\n            cin >> A >> B >> C;\n            if(id.count(A) == 0) {\n                id[A] = id.size() - 1;\n            }\n            str[id[A]] = B;\n            for(int j=0; j<C; ++j) {\n                string D;\n                cin >> D;\n                if(id.count(D) == 0) {\n                    id[D] = id.size() - 1;\n                }\n                g[id[A]][id[D]] = g[id[D]][id[A]] = 1;\n            }\n        }\n        if(N == 1) {\n            cout << str[0] << endl;\n            continue;\n        }\n        int N1 = N/2, N2 = N - N1;\n        for(int i=0; i<N; ++i) {\n            ll m = 0;\n            for(int j=0; j<N; ++j) {\n                if(g[i][j]) {\n                    m |= (1LL << j);\n                }\n            }\n            mask[i] = m;\n        }\n        vector<int> dp1(1 << N1, -1), dp2(1 << N2, -1);\n        int res = 0;\n        for(int b=0; b<1<<N1; b+=2) {\n            bool ignore = false;\n            for(int i=0; i<N1; ++i) {\n                if(g[0][i] && (b >> i) & 1) {\n                    ignore = true;\n                }\n            }\n            if(ignore) {\n                continue;\n            }\n            int b2 = (1 << N2) - 1;\n            for(int i=0; i<N1; ++i) {\n                if(b & (1 << i)) {\n                    b2 &= ~(int)(mask[i] >> N1);\n                }\n            }\n            b2 &= ~(int)(mask[0] >> N1);\n            res = max(res, dfs(0, N1, b, g, str, dp1) + dfs(N1, N2, b2, g, str, dp2) + str[0]);\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nmap<string,int> m;\nint idx=0;\nvector<int> G[101];\nvector<string> CS[101];\nstring names[101];\nint strong[101];\nbool used[101];\nint optNum;\n\n// 現在選べるものから選ぶ\nvoid dfs(int idx,int sum,int leftSum){\n  if(idx==N){\n    optNum=max(optNum,sum);\n    return;\n  }\n  if(used[idx]){\n    dfs(idx+1,sum,leftSum);\n    return;\n  }\n  if(leftSum+sum<=optNum)return;\n  bool ok=true;\n  // これから選ぶ頂点のどれかと隣接しているかチェック\n  for(int i=idx+1;i<N;i++){\n    if(used[i])continue;\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j]==idx){\n\tok=false;\n\tbreak;\n      }\n    }\n    if(!ok)break;\n  }\n  // 隣接している頂点が存在する場合\n  if(idx!=0&&!ok){\n    // 取らない\n    dfs(idx+1,sum,leftSum);\n  }\n  if(!used[idx]){\n    bool cur[50];\n    for(int i=0;i<N;i++)cur[i]=used[i];\n    int nLeftSum=leftSum;\n    nLeftSum-=strong[idx];\n    used[idx]=true;\n    for(int j=0;j<(int)G[idx].size();j++){\n      int to=G[idx][j];\n      if(!used[to])nLeftSum-=strong[to];\n      used[to]=true;\n    }\n    dfs(idx+1,sum+strong[idx],nLeftSum);\n    for(int j=0;j<N;j++)used[j]=cur[j];\n  }\n}\n\nint main(){\n  while(cin>>N&&N){\n    idx=0;\n    optNum=-1;\n    for(int i=0;i<101;i++){\n      G[i].clear();\n      CS[i].clear();\n    }\n    m.clear();\n    int sum=0;\n    for(int i=0;i<N;i++){\n      cin>>names[i]>>strong[i];\n      sum+=strong[i];\n      int C;\n      cin>>C;\n      for(int j=0;j<C;j++){\n\tstring s;\n\tcin>>s;\n\tif(m.count(s)==0)m[s]=idx++;\n\tCS[i].push_back(s);\n      }\n    }\n    for(int i=0;i<N;i++)\n      m[names[i]]=i;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<(int)CS[i].size();j++){\n\tG[m[names[i]]].push_back(m[CS[i][j]]);\n\tG[m[CS[i][j]]].push_back(m[names[i]]);\n      }\n    }\n    memset(used,0,sizeof(used));\n    dfs(0,0,sum);\n    cout<<optNum<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\nusing ll = long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\n\nint n;\nvector<ll> adj;\nvi power, sum_rest;\n\nint res;\n\nvoid dfs(int v, int sum, ll vec){\n    if(v == n){\n        res = max(res, sum);\n        return;\n    }\n    if(sum + sum_rest[v] < res) return;\n\n    int nv = v + 1;\n\n    dfs(nv, sum, vec);\n\n    if((vec & ((1LL << v) | adj[v])) == 0){\n        dfs(nv, sum + power[v], vec | adj[v] | (1LL << v));\n    }\n}\n\nint main(void){\n    for(; cin >> n, n;){\n        res = 0;\n\n        power = sum_rest = vi(n);\n        adj = vector<ll>(n);\n\n        vector<vector<string>> d_str(n);\n        map<string, int> s2i;\n\n        int sum = 0;\n        rep(i, n){\n            string name;\n            int p, m; cin >> name >> p >> m;\n            d_str[i] = vector<string>(m);\n            for(auto & ee : d_str[i]) cin >> ee;\n\n            s2i[name] = i;\n            power[i] = p;\n\n            sum += p;\n        }\n\n        sum_rest[0] = sum;\n        rep(i, n - 1){\n            sum_rest[i + 1] = sum_rest[i] - power[i];\n        }\n\n        rep(i, n){\n            ll vec = 0;\n            for(auto & e : d_str[i]){\n                int idx = s2i[e];\n                vec |= (1LL << idx);\n            }\n            adj[i] = vec;\n        }\n\n        dfs(1, power[0], 1LL);\n        cout << res << endl;\n    }\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0; i<(n); i++)\n#define X first\n#define Y second\n\nusing namespace std;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\nint B[50];\nmap<ll,int> power;\nvector<int> edge[50];\nll admask[50];\n\nvoid dfs(ll &mask, int n, ll m2){\n\tif( m2 & (1<<n) ) return;\n\tmask |= (1<<n);\n\tfor(auto t: edge[n]) if(((mask|m2) & (1<<t)) == 0){\n\t\tdfs(mask, t, m2);\n\t}\n}\n\nvoid print(ll n){\n\trep(i,10) cout << (n&(1<<i) ? 1 : 0 );\n}\n\nint N;\nll solve(int n, ll m2);\nll solve1(ll mm, ll m2){\n\tif( power.count(mm) ) return power[mm];\n\tll mx = 0;\n\trep(j,N+1) if( (mm&(1<<j)) ){\n\t\tll p = solve(j, m2);\n\t\tmx = max<ll>( mx, p );\n\t\t//cout << \"j = \" << j << \" \" << p << endl;\n\t}\n\treturn power[mm] = mx;\n}\n\nll solve(int n, ll m2){\n\t//cout << \"solve: \" << n << \" \" << m2 << endl;\n\tll m = 0;\n\tdfs(m, n, m2);\n\tm ^= (m & m2);\n\tif( power.count(m) ) return power[m];\n\n\tll to = 0;\n\tll ret = 0;\n\tll mask = (1<<n) | admask[n];\n\tmask ^= mask & m2;\n\tfor(auto t: edge[n]) if( !((1<<t)&m2) ) to |= admask[t];\n\tto ^= to & m2;\n\trep(i,N+1) if( ((to&mask)^to) & (1<<i) ){\n\t\tll mm = 0, mx=0;\n\t\tdfs(mm, i, m2|mask);\n\t\tmm ^= mm&mask;\n\t\tmx = solve1(mm, m2|mask);\n\t\t//cout << \"mm = \" << i << \" \"; print(mm); cout << endl;\n\t\tret += mx;\n\t\t//cout << \"mx=\" << mx << \"  ret=\" << ret << endl;\n\n\t\tmask |= mm;\n\t}\n\t//print(m);cout << \":\\t\" << ret + B[n] << endl;\n\treturn ret + B[n];\n}\n\nint main(){\n\twhile(cin >> N, N){\n\t\tmap<string, int> idx;\n\t\tvector<string> Ds[50];\n\n\t\tB[N] = 0;\n\t\tpower.clear();\n\t\tpower[0] = 0;\n\t\trep(i,50) edge[i].clear();\n\t\trep(i,50) admask[i] = 0;\n\n\t\trep(i,N){\n\t\t\tstring A, D;\n\t\t\tint C;\n\t\t\tcin >> A >> B[i] >> C;\n\t\t\tidx[A] = i;\n\t\t\trep(j,C){\n\t\t\t\tcin >> D;\n\t\t\t\tDs[i].push_back(D);\n\t\t\t}\n\t\t}\n\t\trep(i,N) for(auto s: Ds[i]){\n\t\t\tint j = idx[s];\n\t\t\tedge[i].push_back(j);\n\t\t\tedge[j].push_back(i);\n\t\t\tadmask[i] |= (1<<j);\n\t\t\tadmask[j] |= (1<<i);\n\t\t}\n\t\trep(i,N){\n\t\t\tint j = N;\n\t\t\tedge[i].push_back(j);\n\t\t\tedge[j].push_back(i);\n\t\t\tadmask[i] |= (1<<j);\n\t\t\tadmask[j] |= (1<<i);\n\t\t}\n\n\t\tcout << solve(0, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\nint calc(vector<country> &cs){\n   int n = cs.size();\n   int res = 0;\n   ll ne = cs[0].ne;\n   int power = cs[0].power;\n   REP(i, n){\n       if(ne & (1LL<<i) != 0) continue;\n       if((ne | cs[i].ne) == (ne | (1LL<<i))){\n           ne |= cs[i].ne;\n           power += cs[i].power;\n       }\n   }\n\n\n   set<ll> use;\n   priority_queue<pair<int, ll> > pq;\n   pq.push(pair<int, ll>(power, ne));\n   while(!pq.empty()){\n       ne = pq.top().second;\n       power = pq.top().first;\n       pq.pop();\n       res = max(res, power);\n       if(use.find(ne) != use.end()) continue;\n       use.insert(ne);\n       REP(i, n){\n           if(ne & (1LL<<i) != 0) continue;\n           if((ne | cs[i].ne) == (ne | (1LL<<i))){\n               ne |= cs[i].ne;\n               power += cs[i].power;\n           }\n       }\n       REP(i, n){\n           if(((1LL<<i) & ne) == 0){\n                pq.push(pair<int, ll>(power + cs[i].power, ne | cs[i].ne));  \n           }\n       }\n   }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint r[64], p[64];\nInt f[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nvoid prepare(vector<int>& q) {\n    const int n = q.size();\n    vector<pair<int, int> > ps;\n    rep (i, n) ps.push_back(mp(-B[q[i]], q[i]));\n    sort(ps.begin(), ps.end());\n    rep (i, n) r[i] = ps[n-1-i].second;\n    //rep (i, n) r[i] = q[i];\n    rep (i, n) p[i] = B[r[i]];\n    rep (i, n) {\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nint rec(int n, int k, Int u) {\n    if (k == n) return 0;\n    rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return -INF;\n    int ans = -INF;\n    const int mask = (1LL<<n) - 1;\n    if (u&(1LL<<k)) ans = max(ans, rec(n, k+1, u&(mask-f[k])) + p[k]);\n    if (r[k]) ans = max(ans, rec(n, k+1, u&(mask-(1LL<<k))));\n    return ans;\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        ans += rec(q.size(), 0, (1LL<<q.size())-1);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint ans;\nint bs[114514];\nint cs[114514];\nchar buf[114514];\nbool used[114514];\nstring as[114514];\nvector<int> es[114514];\nvector<string> ds[114514];\nmap<string, int> rev;\n\nvoid calc(int v, int sum) {\n  if (v >= n) {\n    ans = max(ans, sum);\n    return;\n  }\n\n  if (!used[v]) {\n    vector<int> restores;\n    used[v] = true;\n    for (int i=0; i<cs[v]; i++) {\n      int u = es[v][i];\n      if (!used[u]) {\n        used[u] = true;\n        restores.emplace_back(u);\n      }\n    }\n    calc(v+1, sum+bs[v]);\n    for (int u : restores) used[u] = false;\n  } \n  calc(v+1, sum);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n    rev.clear();\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      as[i] = buf;\n      rev[as[i]] = i;\n      scanf(\"%d\", &bs[i]);\n      scanf(\"%d\", &cs[i]);\n      ds[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        scanf(\" %s\", buf);\n        ds[i][j] = buf;\n      }\n      used[i] = false;\n    }\n  \n    for (int i=0; i<n; i++) {\n      es[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        es[i][j] = rev[ds[i][j]];\n      }\n    }\n\n    int pre = bs[0];\n    used[0] = true;\n    for (int u : es[0]) {\n      used[u] = true;\n    }\n\n    for (int i=1; i<n; i++) {\n      if (used[i]) continue;\n      if (cs[i] == 0 || (cs[i] == 1 && bs[i] >= bs[es[i][0]])) {\n        pre += bs[i];\n        used[i] = true;\n        for (int u : es[i]) {\n          used[u] = true;\n        }\n      }\n    }\n  \n    ans = 0;\n    calc(1, pre);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[45];\nbool G[45][45];\nint NG[45];\nint sum[45];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[idx] <= beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//OBOG2012E 敵の敵は味方 \n#include<iostream>\n#include<cstring>\nusing namespace std;\n\n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n/**/\n__int64 get_bit(int id){\n\treturn (__int64)1<<id;\n}\n\nstruct{\n\tint id;\n\tint power;\n\t__int64 neighbor;\n}kuni[40];\n\nint search(int i,int n,int power,__int64 neighbor){\n\tint tmp,max;\t\n\t__int64 a=neighbor;\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp)max = tmp;\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nint pw[50],N;\n\nclass UnionFind {\npublic:\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nclass Edge\n{\npublic:\n\tint src, dst;\n\tEdge(int src, int dst)\n\t:src(src),dst(dst)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nll paint[40], rest[40];\nll relt;\n\nll dfs(int p, ll used, ll score, Graph& g, vector<int>& group)\n{\t\n\tif(p==group.size()) return score;\n\tif(used >> group[p] & 1) return dfs(p+1, used, score, g, group);\n\tif(score + rest[group[p]] <= relt) return 0;\n\n\tll res = score;\n\tll tmp = used | paint[group[p]];\n\tres = max(res, dfs(p+1, tmp, score+pw[group[p]], g, group));\n\tres = max(res, dfs(p+1, used, score, g, group));\n\t\n\trelt = max(res, relt);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> N, N) {\n\t\tmemset(rest, 0, sizeof(rest));\n\n\t\tint gcnt = 0;\n\t\tmap<string, int> dic;\n\t\tGraph graph(N);\n\t\tUnionFind uf(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tstring src;\n\t\t\tcin >> src;\n\n\t\t\tif(!dic.count(src)) dic[src] = gcnt++;\n\t\t\tint s = dic[src];\n\n\t\t\tcin >> pw[s];\n\t\n\t\t\tint M;\n\t\t\tcin >> M;\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++) {\n\t\t\t\tstring dst;\n\t\t\t\tcin >> dst;\n\t\t\t\t\n\t\t\t\tif(!dic.count(dst)) dic[dst] = gcnt++;\n\t\t\t\tint t = dic[dst];\n\n\t\t\t\tgraph[s].push_back(Edge(s,t));\n\t\t\t\tuf.unionSet(s,t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tpaint[i] = (1LL << i);\n\t\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\t\tpaint[i] |= (1LL << graph[i][j].dst);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > groups(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tgroups[uf.root(i)].push_back(i);\n\t\t\trest[uf.root(i)] += pw[i];\n\t\t}\n\n\t\tfor(int i=0; i<N; i++) {\n\t\tfor(int j=0; j<groups[i].size(); j++)\n\t\t\trest[groups[i][j]] = rest[uf.root(groups[i][j])];\n\t\t}\n\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tfor(int j=1; j<groups[i].size(); j++) {\n\t\t\t\trest[groups[i][j]] = rest[groups[i][j-1]] - pw[groups[i][j-1]];\n\t\t\t}\n\t\t} \n\n\t\tll res = pw[0];\n\t\tll init = paint[0];\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tif(groups[i].size() == 0) continue;\n\t\t\trelt = 0;\n\t\t\tres += dfs(0, init, 0, graph, groups[i]);\n\t\t} \n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n;\nvector<ll> g;\nvi power;\nint ans;\nvi ss;\n\nvoid solve(ll tmp)\n{\n\tint left;\n\tfor (int i = n - 1; i >= 0; i--)\n\t{\n\t\tif ((tmp >> i) & 1)\n\t\t{\n\t\t\tleft = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tll can = 0;\n\tint sum = 0;\n\tREP(j, n)\n\t{\n\t\tif ((tmp >> j) & 1)\n\t\t{\n\t\t\tsum += power[j];\n\t\t\tcan |= g[j];\n\t\t\tcontinue;\n\t\t}\n\t}\n\tif (sum + ss[n] - ss[left + 1] <= ans) return;\n\tchmax(ans, sum);\n\tFOR(j, left + 1, n)\n\t{\n\t\tif ((can >> j) & 1) continue;\n\t\tsolve(tmp | (1ll << j));\n\t}\n\n}\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tans = 0;\n\t\tg.resize(n);\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tpower.resize(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> power[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tREP(i, n)\n\t\t{\n\t\t\tg[i] = 1ll << i;\n\t\t\tREP(j, nei[i].size())\n\t\t\t{\n\t\t\t\tg[i] |= 1ll << mp[nei[i][j]];\n\t\t\t}\n\t\t}\n\n\t\tss.resize(n + 1);\n\t\tREP(i, n) ss[i + 1] = ss[i] + power[i];\n\t\tsolve(1);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\ninline unsigned int __builtin_popcount(unsigned int x){ return __popcnt(x); }\ninline unsigned long long __builtin_popcountll(unsigned long long x) { return __popcnt64(x); }\n\n#pragma pop_macro(\"long\")\n#endif\ninline int bsf(int v) { return __builtin_ctz(v); }\ninline long bsf(long v) { return __builtin_ctzll(v); }\ninline int bsr(int v) { return 31 - __builtin_clz(v); }\ninline long bsr(long v) { return 63 - __builtin_clzll(v); }\ninline int msb(int v) { return 1 << bsr(v); }\ninline long msb(long v) { return 1ll << bsr(v); }\ninline int lsb(int v) { return v & -v; }\ninline long lsb(long v) { return v & -v; }\ninline int pop_lsb(int v) { return v & v - 1; }\ninline long pop_lsb(long v) { return v & v - 1; }\n\n//// idconv ////\ntemplate<class T>\nstruct idconv\n{\n\tvector<T> v;\n\tint get(T t)\n\t{\n\t\tint id = (int)(find(allof(v), t) - v.begin());\n\t\tif (id == v.size()) v.push_back(t);\n\t\treturn id;\n\t}\n};\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline long bit(int i) { return 1ll << i; }\n\nint dfs(const vector<pair<int, long>> &nations, long cand, map<long, int> &memo)\n{\n\tif (!cand) return 0;\n\tif (memo.count(cand)) return memo[cand];\n\tpair<int, long> d = nations[bsf(cand)];\n\tint use = dfs(nations, cand & ~d.second, memo) + d.first;\n\tint notuse = dfs(nations, pop_lsb(cand), memo);\n\treturn memo[cand] = max(use, notuse);\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tvector<bitset<64>> adj(N);\n\t\tvector<pair<int, long>> nations(N);\n\t\tidconv<string> idc;\n\t\tREP(i, N)\n\t\t{\n\t\t\tint id = idc.get(read<string>());\n\t\t\tint pw = read<int>();\n\t\t\tlong a = bit(id);\n\t\t\tfor (auto &s : readjag<string>()) a |= bit(idc.get(s));\n\t\t\tadj[id] = a;\n\t\t\tnations[id] = make_pair(pw, a);\n\t\t}\n\n\t\tint sum = nations[0].first;\n\t\tlong candidate = bit(N) - 1 & ~nations[0].second;\n\n\t\t// グラフ分割\n\t\tREP(k, N) REP(i, N) REP(j, N) adj[i][j] = adj[i][j] | (adj[i][k] & adj[k][j]);\n\n\t\t// グラフ別メモ付きDFS\n\t\tREP(i, N)\n\t\t{\n\t\t\tlong cand = candidate & adj[i].to_ullong();\n\t\t\tif (cand)\n\t\t\t{\n\t\t\t\tmap<long, int> memo;\n\t\t\t\tsum += dfs(nations, cand, memo);\n\t\t\t\tcandidate &= ~cand;\n\t\t\t}\n\t\t}\n\t\tWRITE(sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n#include<cassert>\n#include<sstream>\n#include<complex>\n#include<cstdio>\n#include<climits>\n#include<cstdlib>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<ctime>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps) \n#define MAX 40\nusing namespace std;\ntypedef long long ll;\n\nvector<int> G[MAX];\nint N,power[MAX],maxcost,half;\n\nvoid dfs(bool *color,int cost,int colored,int remain_cost)\n{\n  if(maxcost >= half)return;\n  if(colored == N)\n    {\n      maxcost = max(maxcost,cost);\n      return;\n    }\n\n  if(remain_cost+cost <= maxcost)return;\n\n  REP(i,1,N)\n    {\n      if(color[i])continue;\n      bool next_color[N];\n      int next_colored = colored;\n      int next_remain_cost = remain_cost;\n      next_remain_cost -= power[i];\n      rep(j,N)next_color[j] = color[j];\n      next_color[i] = true;\n      next_colored++;\n      rep(j,G[i].size())\n\t{\n\t  if(!next_color[G[i][j]])\n\t    {\n\t      next_remain_cost -= power[G[i][j]];\n\t      next_color[G[i][j]] = true;\n\t      next_colored++;\n\t    }\n\t}\n      dfs(next_color,cost+power[i],next_colored,next_remain_cost);\n      if(remain_cost+cost <= maxcost)return;\n    }\n\n}\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      maxcost = -inf;\n      rep(i,N)G[i].clear();\n      map<string,int> getIndex;\n      int cnt = 0,C,total_cost = 0;\n      string A,D;\n      vector<int> B(N);\n      vector<string> name_list;\n      rep(i,N)\n\t{\n\t  cin >> A >> B[i] >> C;\n\t  total_cost += B[i];\n\t  if(getIndex.find(A) == getIndex.end())getIndex[A] = cnt++;\n\t  int from = getIndex[A];\n\t  name_list.push_back(A);\n\t  rep(j,C)\n\t    {\n\t      cin >> D;\n\t      if(getIndex.find(D) == getIndex.end())getIndex[D] = cnt++;\n\t      int to = getIndex[D];\n\t      G[from].push_back(to);\n\t    }\n\t} \n\n      rep(i,N)power[getIndex[name_list[i]]] = B[i];\n\n\n      assert(cnt == N);\n      bool color[N];\n      int colored = 0;\n      rep(i,N)color[i] = false;\n      color[0] = true;\n      colored++;\n      total_cost -= power[0];\n      rep(i,G[0].size())\n\t{\n\t  colored++;\n\t  color[G[0][i]] = true;\n\t  total_cost -= power[G[0][i]];\n\t}\n\n      sort(all(B),greater<int>());\n      half = 0;\n      rep(i,N/2+1)half += B[i];\n\n      dfs(color,power[0],colored,total_cost);\n      cout << maxcost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<vector<int>,int> P2;\ntypedef pair<P,P2> P3;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<vector<int> > memo;\n\nqueue<P3> q;\n\nvoid bfs(){\n\n  vector<int> s;\n  \n  q.push(P3(P(0,0),P2(s,0)));\n\n  while(!q.empty()){\n\n    P3 t=q.front(); q.pop();\n\n    int idx=t.second.second;\n    vector<int> S=t.second.first;\n    int x=t.first.first;\n    int sum=t.first.second;\n    \n    for(int i=idx;i<n;i++){\n    \n      if(!x&&i) continue;\n    \n      int f=0;\n    \n      for(int j=0;j<S.size();j++)\n\tif(G[S[j]][i]) f=1;\n    \n      if(!f){\n      \n\tvector<int> nS=S;\n      \n\tnS.push_back(i);\n      \n\tsort(nS.begin(),nS.end());\n      \n\tif(memo.count(nS)) continue;\n  \n\tmemo.insert(nS);\n      \n\tans=max(ans,sum+cost[i]);\n\t\n\tq.push(P3(P(x+1,sum+cost[i]),P2(nS,i+1)));\n      }\n    \n    }\n  }\n}\n\nvoid dfs(int x,int sum,vector<int> S,int idx){\n  \n  for(int i=idx;i<n;i++){\n    \n    int f=0;\n    \n    for(int j=0;j<S.size();j++)\n      if(G[S[j]][i]) f=1;\n    \n    if(!f){\n      \n      vector<int> nS=S;\n      \n      nS.push_back(i);\n      \n      sort(nS.begin(),nS.end());\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[i]);\n      \n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=0;\n\n    vector<int> S;\n\n    S.push_back(0);\n    \n    dfs(1,cost[0],S,1);\n    //bfs();\n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#ifdef __BORLANDC__\n\ttypedef __int64 ll;\n#else\n\ttypedef long long ll;\n#endif\n\nconst ll L1 = 1;\nconst int N = 40;\nint M = 20;\n\nint n;\nll edge[N];\nint power[N];\n\nvoid printbit(ll state){\n\trep(i,n)printf(\"%d\",((L1<<i)&state)>0);puts(\"\");\n}\n\nvoid printedge(){\n\tprintf(\"edge\\n\");\n\trep(i,n)printbit(edge[i]);\n}\n\nbool init(){\n\tcin>>n;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i]=power[i]=0;\n\t\n\tmap<string,int> mp;\n\tvector<string> estr[N];\n\trep(i,n){\n\t\tstring a;\n\t\tint b,c;\n\t\tcin>>a>>b>>c;\n\t\tmp[a]=i;\n\t\tpower[i]=b;\n\t\trep(j,c){\n\t\t\tstring d;\n\t\t\tcin>>d;\n\t\t\testr[i].push_back(d);\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,estr[i].size()){\n\t\t\tedge[i] |= (L1<<mp[estr[i][j]]);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool hasbit(ll state, int bit){return state&(L1<<bit);}\n\nint T = (1<<M);\nconst int TM = (1<<20);\nint half[TM];\n\nint left_search(){\n\trep(i,T)half[i]=0;\n\t\n\tint maxi = 0;\n\tfor(int i=1;i<T;i+=2){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\trep(j,M){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\t if(edge[j]&i)ok=false;\n\t\t\t\t sum += power[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ok)half[i]=sum;\n\t\tmaxi = max(maxi,half[i]);\n\t}\n\treturn maxi;\n}\n\nint memo[TM];\nint left_memo(int state){\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tint ret = half[state];\n\trep(i,M){\n\t\tif(state&(1<<i)){\n\t\t\tret = max(ret, left_memo(state ^ (1<<i)));\n\t\t}\n\t}\n\treturn memo[state]=ret;\n}\n\nint right_search(){\n\tint ans = 0;\n\tfor(ll i=0; i<(L1<<n); i+=T){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\tll mask = 0;\n\t\treps(j,M,n){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\tif(edge[j]&i)ok=false;\n\t\t\t\tsum+=power[j];\n\t\t\t\tmask |= edge[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ok){\n\t\t\tmask &= (T-1);\n\t\t\tmask ^= (T-1);\n\t\t\t//printf(\"i=%d sum=%d memo[bit]=%d \",i,sum,memo[mask]);\n\t\t\t//printbit(mask);\n\t\t\tans = max(ans, left_memo(mask)+sum);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid left_dp(){\n\trep(i,T)memo[i]=-1;\n\t\n\t//left_memo(T-1);\n}\n\nvoid printdp(){\n\trep(i,T){\n\t\tprintf(\"%3d \",memo[i]);printbit(i);\n\t}\n}\nvoid printsearch(){\n\trep(i,T){\n\t\tprintf(\"%3d \",half[i]);printbit(i);\n\t}\n}\nint solve(){\n\tM = (n+1)/2;\n\tT = (1<<M);\n\t\n\tint a = left_search();\n\tleft_dp();\n\t\n\t/*\n\tputs(\"s\");\n\tprintsearch();\n\tputs(\"d\");\n\tprintdp();\n\t*/\n\treturn max(a,right_search());\n}\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n6\nINTERCAL 10 3 Chef Piet COW\nChef 7 3 INTERCAL Piet COW\nPiet 6 2 INTERCAL Chef\nCOW 7 2 INTERCAL Chef\nJ 6 1 A\nA 12 1 J\n0\n\n6\nINTERCAL 20 1 J\nChef 50 3 J A Piet\nPiet 30 2 A Chef\nCOW 15 1 J\nJ 40 3 COW INTERCAL Chef\nA 25 2 Chef Piet\n0\n\n*/"
  },
  {
    "language": "C++",
    "code": "////////////////////////////////////////\n///  tu3 pro-con template            ///\n////////////////////////////////////////\n#include <cassert>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <functional>\n#include <vector>\n#include <queue>\n#include <string>\n#include <complex>\n#include <stack>\n#include <set>\n#include <map>\n#include <list>\n#include <unordered_map>\n#include <unordered_set>\n#include <bitset>\n#include <regex>\nusing namespace std;\n\n//// MACRO ////\n#define countof(a) (sizeof(a)/sizeof(a[0]))\n\n#define REP(i,n) for (int i = 0; i < (n); i++)\n#define RREP(i,n) for (int i = (n)-1; i >= 0; i--)\n#define FOR(i,s,n) for (int i = (s); i < (n); i++)\n#define RFOR(i,s,n) for (int i = (n)-1; i >= (s); i--)\n#define pos(c,i) c.being() + (i)\n#define allof(c) c.begin(), c.end()\n#define aallof(a) a, countof(a)\n#define partof(c,i,n) c.begin() + (i), c.begin() + (i) + (n)\n#define apartof(a,i,n) a + (i), a + (i) + (n)\n#define long long long\n\n#define EPS 1e-9\n#define INF (1L << 30)\n#define LINF (1LL << 60)\n\n#define PREDICATE(t,a) (const t & a) -> bool\n#define COMPARISON_T(t) bool(*)(const t &, const t &)\n#define COMPARISON(t,a,b) (const t & a, const t & b) -> bool\n#define CONVERTER(TSrc,t,TDest) (const TSrc &t)->TDest\n\n//// i/o helper ////\n\nstruct _Reader { template <class T> _Reader operator ,(T &rhs) { cin >> rhs; return *this; } };\nstruct _Writer { bool f; _Writer() : f(false) { } template <class T> _Writer operator ,(const T &rhs) { cout << (f ? \" \" : \"\") << rhs; f = true; return *this; } };\n#define READ(t,...) t __VA_ARGS__; _Reader(), __VA_ARGS__\n#define WRITE(...) _Writer(), __VA_ARGS__; cout << endl\ninline int sign(double x) { return (abs(x) < EPS ? 0 : x > 0 ? 1 : -1); }\n\ntemplate <class T> struct vevector : public vector<vector<T>> { vevector(int n = 0, int m = 0, const T &initial = T()) : vector<vector<T>>(n, vector<T>(m, initial)) { } };\ntemplate <class T> struct vevevector : public vector<vevector<T>> { vevevector(int n = 0, int m = 0, int l = 0, const T &initial = T()) : vector<vevector<T>>(n, vevector<T>(m, l, initial)) { } };\ntemplate <class T> struct vevevevector : public vector<vevevector<T>> { vevevevector(int n = 0, int m = 0, int l = 0, int k = 0, const T &initial = T()) : vector<vevevector<T>>(n, vevevector<T>(m, l, k, initial)) { } };\ntemplate <class T> T read() { T t; cin >> t; return t; }\ntemplate <class T> vector<T> read(int n) { vector<T> v; REP(i, n) { v.push_back(read<T>()); } return v; }\ntemplate <class T> vevector<T> read(int n, int m) { vevector<T> v; REP(i, n) v.push_back(read<T>(m)); return v; }\ntemplate <class T> vector<T> readjag() { return read<T>(read<int>()); }\ntemplate <class T> vevector<T> readjag(int n) { vevector<T> v; REP(i, n) v.push_back(readjag<T>()); return v; }\n\ntemplate <class T1, class T2> inline istream & operator >> (istream & in, pair<T1, T2> &p) { in >> p.first >> p.second; return in; }\ntemplate <class T1, class T2> inline ostream & operator << (ostream &out, pair<T1, T2> &p) { out << p.first << p.second; return out; }\ntemplate <class T> inline ostream & operator << (ostream &out, vector<T> &v)\n{\n\tostringstream ss;\n\tfor (auto x : v) ss << x << ' ';\n\tauto s = ss.str();\n\tout << s.substr(0, s.length() - 1) << endl;\n\treturn out;\n}\n\n\n//// bit ////\n#ifdef _MSC_VER\n#pragma push_macro(\"long\")\n#undef long\ninline unsigned __builtin_ctz(unsigned x) { unsigned long r; _BitScanForward(&r, x); return r; }\ninline unsigned __builtin_clz(unsigned x) { unsigned long r; _BitScanReverse(&r, x); return 31 - r; }\ninline unsigned __builtin_ffs(unsigned x) { unsigned long r; return _BitScanForward(&r, x) ? r + 1 : 0; }\ninline unsigned __builtin_ctzll(unsigned long long x) { unsigned long r; _BitScanForward64(&r, x); return r; }\ninline unsigned __builtin_clzll(unsigned long long x) { unsigned long r; _BitScanReverse64(&r, x); return 63 - r; }\ninline unsigned __builtin_ffsll(unsigned long long x) { unsigned long r; return _BitScanForward64(&r, x) ? r + 1 : 0; }\n#pragma pop_macro(\"long\")\n#endif\n\ninline int msb(int v) { return 1 << 31 - __builtin_clz(v); }\ninline int lsb(int v) { return v & -v; }\ninline long msb(long v) { return 1ll << 63 - __builtin_clzll(v); }\ninline long lsb(long v) { return v & -v; }\n\n//// idconv ////\ntemplate<class T>\nstruct idconv\n{\n\tvector<T> v;\n\tint get(T t)\n\t{\n\t\tint id = (int)(find(allof(v), t) - v.begin());\n\t\tif (id == v.size()) v.push_back(t);\n\t\treturn id;\n\t}\n};\n\n//// start up ////\nvoid solve();\nint main()\n{\n\tsolve();\n\treturn 0;\n}\n\n////////////////////\n/// template end ///\n////////////////////\n\ninline long bit(int idx) { return 1ll << idx; }\n\nint dfs(const vector<pair<int, long>> &nations, long cand, map<long, int> &memo)\n{\n\tif (!cand) return 0;\n\tif (memo.count(cand)) return memo[cand];\n\tpair<int, long> dt = nations[__builtin_ctzll(cand)];\n\treturn memo[cand] = max(dt.first + dfs(nations, cand & ~dt.second, memo), dfs(nations, cand & ~lsb(cand), memo));\n}\n\nvoid solve()\n{\n\tint testcases = INF;\n\tREP(testcase, testcases)\n\t{\n\t\tcerr << testcase << endl;\n\t\tREAD(int, N);\n\t\tif (!N) { break; }\n\n\t\tvector<bitset<64>> adj(N);\n\t\tvector<pair<int, long>> nations(N);\n\t\tidconv<string> idc;\n\t\tREP(i, N)\n\t\t{\n\t\t\tint id = idc.get(read<string>());\n\t\t\tint pw = read<int>();\n\t\t\tlong a = bit(id);\n\t\t\tfor (auto &s : readjag<string>()) a |= 1ll << idc.get(s);\n\t\t\tadj[id] = a;\n\t\t\tnations[id] = make_pair(pw, a);\n\t\t}\n\n\t\tint sum = nations[0].first;\n\t\tlong candidate = bit(N) - 1 & ~nations[0].second;\n\n\t\t// グラフ分割\n\t\tREP(k, N) REP(i, N) REP(j, N) adj[i][j] = adj[i][j] | (adj[i][k] & adj[k][j]);\n\n\t\tREP(i, N)\n\t\t{\n\t\t\tlong cand = candidate & adj[i].to_ullong();\n\t\t\tif (cand)\n\t\t\t{\n\t\t\t\tmap<long, int> memo;\n\t\t\t\tsum += dfs(nations, cand, memo);\n\t\t\t\tcandidate &= ~cand;\n\t\t\t}\n\t\t}\n\t\tWRITE(sum);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nstruct before_main {\n  before_main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n  }\n} before_main;\n\n#define REP(i, a, b) for (int i = a; i < (int)b; i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef long long ll;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n\n  if (curr == N) {\n    ans = max(ans, wsum);\n    return;\n  }\n\n  dfs(S, wsum, curr + 1);\n\n  rep(k, curr) {\n    if (adjacent[curr][k] && (S >> k & 1)) {\n      return;\n    }\n  }\n\n  dfs(S | (1 << curr), wsum + weight[curr], curr + 1);\n}\n\nint main() {\n\n  while (cin >> N && N) {\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(_, N) {\n      string s;\n      cin >> s;\n      if (id.find(s) == id.end())\n        id[s] = v++;\n      cin >> weight[id[s]];\n      int n;\n      cin >> n;\n      rep(_, n) {\n        string t;\n        cin >> t;\n        if (id.find(t) == id.end())\n          id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    assert(v == N);\n\n    ans = 0;\n    dfs(1<<0, weight[0], 1);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], ans;\n\nset<ll> memo;\n\nvoid dfs(ll S){\n\n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  int cnt=0, sum=0;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1<<i))) continue;\n\n    sum+=cost[i];\n    \n    for(int j=i+1;j<n;j++){\n      if(!(S&(1LL<<j))) continue;\n      if(!G[i][j]) cnt++;\n    }\n    \n  }\n\n  int node=__builtin_popcount(S);\n  \n  if(cnt==node*(node-1)/2){\n    ans=max(ans,sum);\n    return ;\n  }\n\n  for(int i=1;i<n;i++)\n    for(int j=i;j<n;j++){\n      \n      int nS=S;\n\n      for(int k=i;k<=j;k++) nS=nS&~(1LL<<k);\n\n      dfs(nS);\n      \n    }\n  \n}\n\nint main(){\n  \n  while(1)  {\n\n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cnt=0;\n\n    memset(G,0,sizeof(G));\n    \n    for(int i=0;i<n;i++){\n\n      string s;\n      cin>>s;\n\n      if(!num.count(s)) num[s]=cnt++;\n      \n      int a,b;\n      cin>>a>>b;\n      \n      cost[num[s]]=a;\n\n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n\n    ans=0;\n\n    memo.clear();\n\n    dfs((1LL<<n)-1);\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nmap<string,int> army, id;\nmap<string,long long> bit;\nmap<pair<long long, long long>, long long> memo;\nint n;\nstring a[50], d[50][50];\nint b[50], c[50];\n\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint dfs(long long party, long long enemy){\n\tif(memo.count(make_pair(party, enemy))) return memo[make_pair(party, enemy)];\n\n\tint res = 0;\n\trep(i,n){\n\t\tif(getBit(party,i) || getBit(enemy, i)) continue;\n\t\tif((party bitand bit[a[i]]) != 0) continue;\n\t\t\n\t\tres = max(res, dfs(setBit(party, i), enemy bitor bit[a[i]]) + b[i]);\n\t}\n\n\treturn memo[make_pair(party, enemy)] = res;\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tarmy.clear();\n\t\tid.clear();\n\t\tbit.clear();\n\t\tmemo.clear();\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tid[a[i]] = i;\n\t\t\trep(j,c[i]){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tlong long near = 0;\n\t\t\trep(j,c[i]){\n\t\t\t\tnear = setBit(near, id[d[i][j]]);\n\t\t\t}\n\t\t\tbit[a[i]] = near;\n\t\t}\n\n\n\t\tcout << dfs(1LL ,bit[a[0]]) + b[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n \nint n;\nint main(){\n    while(cin>>n,n){\n        map<string,int>ma;\n        vs name(n);\n        vi b(n),co(n);\n        vector<vs>in(n);\n        rep(i,n){\n            cin>>name[i]>>b[i]>>co[i];\n            ma[name[i]]=1;\n            in[i]=vs(co[i]);\n            rep(j,co[i]){\n                cin>>in[i][j];\n                ma[in[i][j]]=1;\n            }\n        }\n        int t=0;\n        rep(i,n)ma[name[i]]=i;\n     \n        vector<ll>A(n);\n        rep(i,n)rep(j,in[i].size()){\n            int from=ma[name[i]],to=ma[in[i][j]];\n            A[from]|=1ll<<to;\n        }\n        int N=n/2,nN=n-N;\n         \n//      rep(i,n){\n//          cout<<name[i]<<\" \";\n//          rep(j,n)cout<<((A[i]&1<<j)>>j)<<\" \";cout<<endl;\n//      }\n        vi dp(1<<nN);\n        rep(i,1<<nN){\n            bool h=true;\n            rep(j,nN)if((i&1<<j)&&((i&A[j+N]>>N)))h=false;\n            if(h){\n                int sum=0;\n                rep(j,nN)if(i&1<<j)sum+=b[N+j];\n                dp[i]=max(dp[i],sum);\n            }\n            rep(j,nN)if((i&1<<j)==0)\n                dp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n        }\n         \n        int out=0;\n        rep(i,1<<N)if(i&1){\n            bool h=true;\n            int sum=0;\n            rep(j,N)if((i&1<<j)){\n                sum+=b[j];\n                if(i&A[j])h=false;\n            }\n            if(h){\n                t=(1<<nN)-1;\n                rep(j,N)if((i&1<<j))t&=~(A[j]>>N);\n                out=max(out,sum+dp[t]);\n            }           \n        }\n        cout<<out<<endl;\n    }\n}\n \n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<vector<int> > memo;\n\nvoid dfs(int x,int sum,vector<int> S,int idx){\n  \n  ans=max(ans,sum);\n\n  sort(S.begin(),S.end());\n  \n  if(memo.count(S)) return;\n  \n  memo.insert(S);\n  \n  for(int i=idx;i<n;i++){\n\n    if(!x&&i) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<S.size();j++)\n      if(G[S[j]][i]) f=1;\n    \n    if(!f){\n      \n      vector<int> nS=S;\n      \n      nS.push_back(i);\n      \n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=0;\n\n    vector<int> S;\n    \n    dfs(0,0,S,0);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nHmap<string, int> hm;\n\nvoid calc (vl& dp, int s, int e) {\n  int l = e - s;\n  rep(mask, 1 << l) {\n    rep(i, l) {\n      if(mask & (1<<i)) continue;\n      bool f = true;\n      for(const auto& str: D[i+s]) {\n\tint t = hm[str];\n\tif(s <= t && t < e) {\n\t  if(mask&(1<<(t - s))) f = false;\n\t}\n      }\n      if(f) {\n\tint nxt = mask | (1<<i);\n\tdp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n      }\n    }\n  }\n  rep(mask, 1<<l) {\n    rep(i, l) {\n      if(mask&(1<<i)) {\n\tint pre = mask - (1<<i);\n\tdp[mask] = max(dp[mask], dp[pre]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    hm.clear();\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    \n\n    vector<vector<ll>> dp(2, vl(1<<((n+1)/2), 0LL));\n    \n    calc(dp[0], 0, n/2);\n    calc(dp[1], n/2, n);\n\n    int len = n - (n/2);\n    vector<int> masks(1<<(n/2), (1<<len)-1);\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tfor(const auto& str : D[i]) {\n\t  int t = hm[str] - n / 2;\n\t  if(t < 0) continue;\n\t  if(masks[mask] & (1<<t)) masks[mask] -= (1<<t);\n\t}\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp[0][mask] + dp[1][masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<vector<ll>> g;\nvector<ll> power;\nvector<ll> used;\nvector<P> ord;\n\nvoid build_graph() {\n\tmap<string,ll> dict;\n\tll cnt = 0;\n\tREP(i,n) {\n\t\tstring a; ll b, c;\n\t\tcin >> a >> b >> c;\n\t\tif(dict.count(a) == 0) {\n\t\t\tdict[a] = cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p = dict[a];\n\t\tpower[dict[a]] = b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin >> t;\n\t\t\tif(dict.count(t) == 0) {\n\t\t\t\tdict[t] = cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tg[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx, ll sum) {\n\tif(idx == n) {\n\t\tif(used[0] == 1) return sum;\n\t\telse return -1;\n\t}\n\tif(used[ord[idx].second] != -1) return dfs(idx + 1, sum);\n\tll ret = 0;\n\tvector<ll> tmp(n);\n\tREP(i,n) tmp[i] = used[i];\n\tif((ll)g[ord[idx].second].size() > 1) {\n\t\tused[ord[idx].second] = 0;\n\t\tret = max(ret, dfs(idx + 1, sum));\n\t}\n\tused[ord[idx].second] = 1;\n\tREP(i,g[ord[idx].second].size()) used[g[ord[idx].second][i]] = 0;\n\tret = max(ret, dfs(idx + 1, sum + power[ord[idx].second]));\n\tREP(i,n) used[i] = tmp[i];\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tused.assign(n, -1);\n\tord.resize(n);\n\tg.resize(n); build_graph();\n\tll sum = 0;\n\tREP(i,n) if(used[i] == -1) {\n\t\tif(g[i].size() == 0) {\n\t\t\tused[i] = 1;\n\t\t\tsum += power[i];\n\t\t}\n\t\tif(g[i].size() == 1 && g[g[i][0]].size() == 1) {\n\t\t\tif(power[i] >= power[g[i][0]]) {\n\t\t\t\tused[i] = 1; used[g[i][0]] = 0;\n\t\t\t\tsum += power[i];\n\t\t\t} else {\n\t\t\t\tused[i] = 0; used[g[i][0]] = 1;\n\t\t\t\tsum += power[g[i][0]];\n\t\t\t}\n\t\t}\n\t}\n\tREP(i,n) {\n\t\tord[i].first = (ll)g[i].size();\n\t\tord[i].second = i;\n\t}\n\tsort(ALL(ord)); reverse(ALL(ord));\n\treturn dfs(0, sum);\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcout << solve() << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\trest -= names[pos].second;\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tans = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tlist.push_back(a);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tbuf.insert(make_pair(name, move(list)));\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second,mb);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define rep1(i,n) for(int i=1;i<=(int)(n);i++)\n#define all(c) c.begin(),c.end()\n#define pb push_back\n#define fs first\n#define sc second\n#define show(x) cout << #x << \" = \" << x << endl\n#define chmin(x,y) x=min(x,y)\n#define chmax(x,y) x=max(x,y)\nusing namespace std;\nint V;\nconst int MAX_V=40;\nvector<int> G[MAX_V];\nbool used[MAX_V];\nint ord[MAX_V];\nint cnt[MAX_V];\t\t//cnt[v] = the num of selected verticies connected with v;\n//typedef long long ll;\n//set<ll> done;\n\nint ans,power[40],m[40];\nstring name[40];\nvector<string> names[40];\n\nvoid dfs(int it){\n\tif(it==V){\n//\t\tll x=0;\n//\t\trep(i,V) if(used[i]) x|=(1LL<<i);\n//\t\tif(done.find(x)!=done.end()) return;\n//\t\tdone.insert(x);\n\t\tif(!used[0]) return;\n\t\tint sum=0;\n\t\trep(i,V) if(used[i]) sum+=power[i];\n\t\tchmax(ans,sum);\n\t\treturn;\n\t}\n\tint v=ord[it];\n\tif(used[v]||cnt[v]){\n\t\tdfs(it+1);\n\t\treturn;\n\t}\n\t//use v\n\tused[v]=1;\n\tfor(int u:G[v]) cnt[u]++;\n\tdfs(it+1);\n\tused[v]=0;\n\tfor(int u:G[v]) cnt[u]--;\n\n\tfor(int u:G[v]) if(cnt[u]==0&&!used[u]){\n\t\tused[u]=1;\n\t\tfor(int w:G[u]) cnt[w]++;\n\t\tdfs(it+1);\n\t\tused[u]=0;\n\t\tfor(int w:G[u]) cnt[w]--;\n\t}\n}\nvoid enum_ind(int N){\n\tV=N;\n\ttypedef pair<int,int> P;\n\tvector<P> tmp;\n\trep(i,N) tmp.pb(P(G[i].size(),i));\n\tsort(all(tmp));\n\trep(i,N) ord[i]=tmp[i].sc;\n\trep(i,N) used[i]=0,cnt[i]=0;\n//\tdone.clear();\n\tdfs(0);\n}\nint main(){\n\twhile(true){\n\t\tint N;\n\t\tcin>>N;\n\t\tif(N==0) break;\n\t\trep(i,N) names[i].clear();\n\t\trep(i,N) G[i].clear();\n\t\tans=0;\n\t\trep(i,N){\n\t\t\tcin>>name[i]>>power[i]>>m[i];\n\t\t\trep(j,m[i]){\n\t\t\t\tstring st;\n\t\t\t\tcin>>st;\n\t\t\t\tnames[i].pb(st);\n\t\t\t}\n\t\t}\n\t\trep(i,N){\n\t\t\trep(j,m[i]){\n\t\t\t\trep(k,N){\n\t\t\t\t\tif(name[k]==names[i][j]) G[i].pb(k);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tenum_ind(N);\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dfs(vvi &neighbors,int index,vi &b,map<pair<ll,int>,int> &dp,ll mask){\n\tif(index==neighbors.size()){\n\t\treturn 0;\n\t}\n\tif(EXIST(dp,make_pair(mask,index))){\n\t\treturn dp[make_pair(mask,index)];\n\t}\n\tint ret=0;\n\tREP(i,(mask&(1LL<<index))?1:2){\n\t\tll newmask=mask;\n\t\tnewmask|=(1LL<<index);\n\t\tif(i){\n\t\t\tREP(j,neighbors[index].size()){\n\t\t\t\tnewmask|=(1LL<<neighbors[index][j]);\n\t\t\t}\n\t\t}\n\t\tret=max(ret,dfs(neighbors,index+1,b,dp,newmask)+(i?b[index]:0));\n\t}\n\treturn dp[make_pair(mask,index)]=ret;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvs a(n);\n\t\tvi b(n),c(n);\n\t\tvector<vector<string> > d(n);\n\t\tREP(i,n){\n\t\t\tcin>>a[i]>>b[i]>>c[i];\n\t\t\tREP(j,c[i]){\n\t\t\t\tstring dd;\n\t\t\t\tcin>>dd;\n\t\t\t\td[i].push_back(dd);\n\t\t\t}\n\t\t}\n\t\tvvi neighbors(n);\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tif(find(ALL(d[i]),a[j])!=d[i].end()){\n\t\t\t\t\tneighbors[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tmap<pair<ll,int>,int> dp;\n\t\tint ans=0;\n\t\tdp[make_pair(1,0)]=b[0];\n\t\tll mask=1;\n\t\tREP(j,neighbors[0].size()){\n\t\t\tmask|=(1LL<<neighbors[0][j]);\n\t\t}\n\t\tans=dfs(neighbors,1,b,dp,mask)+b[0];\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, t, ans;\nmap<string, int> mp;\nvi power;\nvector<vi> es;\nvi sum;\n\nvoid solve(int i, ll team, int sumpow)\n{\n\tif (i == t)\n\t{\n\t\tchmax(ans, sumpow);\n\t\treturn;\n\t}\n\tif (sumpow + sum[t] - sum[i] <= ans) return;\n\tbool f = true;\n\tfor (auto k:es[i])\n\t{\n\t\tif ((team >> k) & 1)\n\t\t{\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (f) solve(i + 1, team | (1ll << i), sumpow + power[i]);\n\tsolve(i + 1, team, sumpow);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> n, n)\n\t{\n\t\tans = 0;\n\t\tmp.clear(); \n\t\tpower.clear(); power.resize(n);\n\t\tes.clear(); es.resize(n);\n\t\tsum.clear(); sum.resize(n + 1);\n\t\tt = 0;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (!mp.count(s)) mp[s] = t++;\n\t\t\tint tmp = mp[s];\n\t\t\tint p; cin >> p;\n\t\t\tpower[tmp] = p;\n\t\t\tint m; cin >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring a; cin >> a;\t\t\t\n\t\t\t\tif (!mp.count(a)) mp[a] = t++;\n\t\t\t\tint op = mp[a];\n\t\t\t\tes[tmp].push_back(op);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) sum[i + 1] = sum[i] + power[i];\n\t\tsolve(1, 1, power[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\nusing namespace std;\n\nint Cc;\n\nchar Name[40][20];\nchar NearS[40][40][20];\nbool Near[40][40];\nbool ally[40];\nint Power[40];\nint n, t;\nint Max_Power;\n\t\n\nvoid make_ally(bool ally1[40], int name, int power){\n\tint i,j;\n\tbool ally2[40];\n\tmemcpy(ally2,ally1,sizeof(ally));\n\n\tally2[name] = 1;\n\tpower += Power[name];\n\n\tfor(i=0;i<n;i++){\n\t\tif(Near[name][i]){\n\t\t\tally2[i]=1;\n\t\t}\n\t}\n\n for(i=name;i<n;i++){\n\t\tif(!ally2[i]){\n\t\t\tfor(j=name;j<n;j++){\n\t\t\t\tif(!ally2[j] && Near[j][i]) break;\n\t\t\t}\n\t\t\tif(j==n){\n\t\t\t\tally2[i] = 1;\n\t\t\t\tpower += Power[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tif(power > Max_Power) Max_Power = power;\n\n\tfor(i=name;i<n;i++)\n\t\tif(!ally2[i]) make_ally(ally2, i, power);\n\n\treturn;\n}\nint search(char *name){\n\tint i;\n\tfor(i=0;i<Cc;i++) if(!strcmp(name, Name[i])) return i;\n\tprintf(\"%s\\n\", name);\n\treturn 0;\n}\n\nint main(){\n\tint j, i;\n\twhile(cin >> n, n){\n\t\tmemset(Name, 0, sizeof(Name));\n\t\tmemset(Near, 0, sizeof(Near));\n\t\tmemset(NearS, 0, sizeof(NearS));\n\t\tmemset(Power, 0, sizeof(Power));\n\t\tmemset(ally, 0, sizeof(ally));\n\t\tMax_Power=0;\n\n\t\tfor(Cc=0;Cc<n;Cc++){\n\t\t\tcin >> Name[Cc] >> Power[Cc] >> t;\n\n\t\t\tfor(i=0;i<t;i++) cin >> NearS[Cc][i];\n\t\t}\n\t\tfor(i=0;i<n;i++){\n\t\t\tfor(j=0;NearS[i][j][0];j++){\n\t\t\t\tNear[i][search(NearS[i][j])] = 1;\n//\t\t\t\tprintf(\"%d-%d\\n\", i, search(NearS[i][j]));\n\t\t\t}\n\t\t}\n\t\tmake_ally(ally, 0, 0);\n\t\tcout<<Max_Power<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n#define int long long\n\ntypedef long long int64;\n\nint N, V[45];\nbool G[45][45];\nint64 NG[45];\nint sum[45];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[idx] <= beet) return;\n\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nsigned main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <cmath>\n#include <algorithm>\n#include <cfloat>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <string>\n#include <iostream>\n#include <set>\n#include <map>\n#include <time.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nenum Type{\n\tFriend,\n\tEnemy,\n\tUndefined,\n};\n\n\nstruct Info{\n\tint value,adj_num;\n\tchar name[17];\n};\n\nint N,ans;\nInfo info[40];\nint adj_table[40][40];\nchar adj_name_table[40][40][17];\n\n\nbool strCmp(char* base, char* comp){\n\tint length1,length2;\n\tfor(length1=0;base[length1] != '\\0';length1++);\n\tfor(length2=0;comp[length2] != '\\0';length2++);\n\tif(length1 != length2)return false;\n\n\tfor(int i=0;base[i] != '\\0'; i++){\n\t\tif(base[i] != comp[i])return false;\n\t}\n\treturn true;\n}\n\nvoid strcpy(char* to,char* str){\n\tfor(int i=0;str[i] != '\\0';i++){\n\t\tto[i] = str[i];\n\t\tto[i+1] = '\\0';\n\t}\n}\n\nvoid recursive(Type type[40],int index,int sum){\n\n\tif(index == N-1){\n\t\tans = max(ans,sum);\n\t\treturn;\n\t}\n\n\tint check = sum;\n\tfor(int i = 0; i < N; i++){\n\t\tif(type[i] == Undefined){\n\t\t\tcheck += info[i].value;\n\t\t}\n\t}\n\tif(check <= ans)return;\n\n\tType next_type[40];\n\tfor(int i = 0; i < N; i++)next_type[i] = type[i];\n\n\tnext_type[index+1] = Enemy;\n\trecursive(next_type,index+1,sum);\n\n\tif(type[index+1] == Undefined){\n\t\tType next_type2[40];\n\t\tfor(int i = 0; i < N; i++)next_type2[i] = type[i];\n\t\tnext_type2[index+1] = Friend;\n\n\t\tfor(int i = 0; i < info[index+1].adj_num; i++){\n\t\t\tnext_type2[adj_table[index+1][i]] = Enemy;\n\t\t}\n\t\trecursive(next_type2,index+1,sum+info[index+1].value);\n\t}\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tscanf(\"%s %d %d\",info[i].name,&info[i].value,&info[i].adj_num);\n\t\tfor(int k = 0; k < info[i].adj_num; k++){\n\t\t\tscanf(\"%s\",adj_name_table[i][k]);\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < info[i].adj_num; k++){\n\t\t\tfor(int p = 0; p < N; p++){\n\t\t\t\tif(strCmp(info[p].name,adj_name_table[i][k])){\n\t\t\t\t\tadj_table[i][k] = p;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tans = info[0].value;\n\tType first_type[40];\n\tfor(int i = 0; i < N; i++)first_type[i] = Undefined;\n\tfirst_type[0] = Friend;\n\n\tfor(int i = 0; i < info[0].adj_num; i++){\n\t\tfirst_type[adj_table[0][i]] = Enemy;\n\t}\n\n\trecursive(first_type,0,info[0].value);\n\n\tprintf(\"%d\\n\",ans);\n}\n\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d\",&N);\n\t\tif(N == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nint N;\nbool edge[50][50] = {};\nint force[50] = {};\nll memo[50];\nint dp1[1<<21], dp2[1<<21];\n\nint dfs1(int state) {\n    int &ret = dp1[state];\n    if (ret >= 0) return ret;\n    ret = 0;\n\n    int n = N/2;\n    for (int i = 0; i < n; i++) {\n        if (!((state >> i) & 1)) continue;\n        int next_state = (int)(((ll)state) & memo[i]);\n        ret = max(ret, force[i] + dfs1(next_state));\n    }\n    return ret;\n}\n\nint dfs2(int state) {\n    int &ret = dp2[state];\n    if (ret >= 0) return ret;\n    ret = 0;\n\n    int n = N/2, ns = N - n;\n    for (int i = 0; i < ns; i++) {\n        if (!((state >> i) & 1)) continue;\n        int next_state = (int)(((ll)state) & (memo[i + n] >> n));\n        ret = max(ret, force[i + n] + dfs2(next_state));\n    }\n    return ret;\n}\n\nint main() {\n    while (cin >> N, N) {\n        map<string, int> name2id;\n        memset(edge, false, sizeof(edge));\n        for (int i = 0; i < N; i++) {\n            string from; int f, n_v;\n            cin >> from >> f >> n_v;\n            if (!name2id.count(from)) {\n                int id = name2id.size();\n                name2id[from] = id;\n            }\n\n            int fid = name2id[from];\n            force[fid] = f;\n            edge[fid][fid] = true;\n\n            for (int j = 0; j < n_v; j++) {\n                string to; cin >> to;\n                if (!name2id.count(to)) {\n                    int id = name2id.size();\n                    name2id[to] = id;\n                }\n                edge[fid][name2id[to]] = true;\n            }\n        }\n\n        if (N == 1) {\n            cout << force[0] << endl;\n            continue;\n        }\n\n        for (int i = 0; i < N; i++) {\n            ll tmp = 0;\n            for (int j = 0; j < N; j++)\n                if (edge[i][j]) tmp |= (1ll << j);\n            memo[i] = ((1ll << 55) - 1) ^ tmp;\n        }\n\n        memset(dp1, -1, sizeof(dp1));\n        memset(dp2, -1, sizeof(dp2));\n        int n = N / 2, ans = 0;\n        for (int state = 0; state < (1 << n); state++) {\n            if (state & 1) continue;\n\n            bool is_ok = true;\n            for (int i = 0; is_ok && i < n; i++) {\n                if (edge[0][i] && ((state >> i) & 1)) is_ok = false;\n            }\n            if (!is_ok) continue;\n\n            ll flag = (1ll << N) - 1;\n            flag &= memo[0];\n            for (int i = 0; i < n; i++) {\n                if ((state >> i) & 1) flag &= memo[i];\n            }\n            int ns = (int)(flag >> n);\n\n            ans = max(ans, force[0] + dfs1(state) + dfs2(ns));\n        }\n        cout << ans << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\trest -= names[pos].second;\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tint rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\trest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\trest = rest1;\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tbmap.clear();\n\t\tans = 0;\n\t\tmb = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\t//list.push_back(a);\n\t\t\t\tbuf[name].push_back(a);\n\t\t\t\tbuf[a].push_back(name);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second,mb-names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 45\ntypedef long long ll;\ntypedef pair<int, ll> P;\n\nint get_node(string s, map<string, int> s2i)\n{\n    if (s2i.count(s) > 0) {\n        return s2i[s];\n    }\n    s2i[s] = s2i.size();\n    return s2i[s];\n}\n\nint N, B[MAX];\nbool ng_node[MAX], is_adj[MAX][MAX];\nmap<P, int> memo;\n\nint dfs(int v, ll S)\n{\n    if (memo.count(P(v, S)) > 0) {\n        return memo[P(v, S)];\n    }\n    int res = 0;\n    for (ll i = 0; i < (ll)N; i++) {\n        if ((S >> i & 1LL) || is_adj[v][i]) {\n            continue;\n        }\n        bool ok = 1;\n        for (ll j = 0; j < (ll)N; j++) {\n            if ((S >> j & 1LL) && !ng_node[j]) {\n                if (is_adj[v][j] || is_adj[i][j]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        if (ok) {\n            res = max(res, dfs(i, S|(1LL<<i)) + B[i]);   \n        }\n    }\n    memo[P(v, S)] = res;\n    return res;\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        string A, D;\n        int C, sum = 0;\n        ll S = 0;      \n        vector<string> DG[MAX];\n        \n        map<string, int> s2i;\n        \n        memo.clear();\n        memset(is_adj, 0, sizeof(is_adj));\n        memset(ng_node, 0, sizeof(ng_node));\n        \n        for (int i = 0; i < N; i++) {\n            cin >> A >> B[i] >> C;\n            s2i[A] = i;\n            for (int j = 0; j < C; j++) {\n                cin >> D;\n                DG[i].push_back(D);\n            }\n        }\n\n        for (ll i = 0; i < (ll)N; i++) {\n            int len = DG[i].size();\n            if (len == 0) {\n                for (int j = 0; j < N; j++) {\n                    is_adj[i][j] = is_adj[j][i] = 1;\n                }\n                ng_node[i] = 1;\n                sum += B[i];\n                S |= 1LL<<i;\n            }\n            for (int j = 0; j < len; j++) {\n                ll t = s2i[DG[i][j]];\n                is_adj[i][t] = is_adj[t][i] = 1;\n            }\n        }\n        \n        cout << dfs(0, S|(1LL<<0)) + B[0] + sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nmap<string,int> M;\nvector<string> NG[41];\nstring A[41];\nint n,B[41],ans;\null g[41];\n\nunordered_set <ull> S[41];\nunordered_map <ull,int> mem[41];\null used;\nvoid dfs(int pos,int sum,ull U){\n  if(pos>=2) mem[pos-2].clear();\n  ans=max(ans,sum);\n  while(pos<n&&(g[pos]&1LL))pos++;\n  if(pos==n)return;\n  if(mem[pos][U]>=sum)return;\n  mem[pos][U]=sum;\n  //if(S[pos].count(used))return;\n  //S[pos].insert(used);\n  ull tmp=used,nU=U;\n  int nsum=sum;\n\n  if(U&(1LL<<pos)){\n    used=nU=nsum=0;\n    for(int i=0;i<pos;i++){\n      if((tmp&(1LL<<i))==0) continue; \n      if((g[pos]&(1LL<<i))==0) nU|=g[i],used|=(1LL<<i),nsum+=B[i];\n    }\n  }\n  \n  used|=(1LL<<pos);\n  dfs(pos+1,nsum+B[pos],nU|g[pos]);\n  used&=~(1LL<<pos);\n  if(used!=tmp)used=tmp,dfs(pos+1,sum,U);\n} \n\n\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    for(int i=0;i<40;i++) S[i].clear(),mem[i].clear();\n\n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      M[A[i]]=i;\n      NG[i].resize(C);\n      for(int j=0;j<C;j++)cin>>NG[i][j];\n    }\n\n    \n    for(int i=0;i<n;i++){\n      g[i]=1LL<<i;\n      for(int j=0;j<(int)NG[i].size();j++)g[i]|=1LL<<M[NG[i][j]];\n    }\n    \n    ans=0;\n    used=1;\n    dfs(1,B[0],g[0]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int>& f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tid[t] = id.size();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\nint max_f;\nvoid dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t{\n\t\tmax_swap(max_f, sum);\n\t\treturn;\n\t}\n\n\t{\n\t\tint rem = 0;\n\t\tfor (int i = d; i < m; ++i)\n\t\t\tif (!(enemy >> i & 1))\n\t\t\t\trem += force[i];\n\t\tif (sum + rem < max_f)\n\t\t\treturn;\n\t}\n\n\tif (!(enemy >> d & 1))\n\t\tdfs(d + 1, enemy | on[d], sum + force[d]);\n\tdfs(d + 1, enemy, sum);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t{\n\t\t\t\tint t = id.size();\n\t\t\t\tid[a] = t;\n\t\t\t}\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t{\n\t\t\t\t\tint t = id.size();\n\t\t\t\t\tid[d] = t;\n\t\t\t\t}\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\n\t\tint res;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tmax_f = 0;\n\t\tdfs(1, on[0], force[0]);\n\t\tres = max_f;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tmax_f = 0;\n\t\t\t\tdfs(0, 0, 0);\n\t\t\t\tres += max_f;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint ans;\nint n;\nint power[40];\nvector<vector<int> > g;\nvoid solve(ll S, int now, int sum) {\n  if (now == n) {\n    ans = max(ans, sum);\n    return;\n  }\n  int t = 0;\n  for (int i=now; i<n; ++i) t += power[i];\n  if (sum + t < ans) return;\n  bool f = 0;\n  FOR(it, g[now]) {\n    if (S>>*it&1) {\n      f = 1;\n      break;\n    }\n  }\n  if (!f) {\n    // use\n    solve(S|1LL<<now, now+1, sum+power[now]);\n  }\n  solve(S, now+1, sum);\n}\n\nint main() {\n  while(cin>>n,n) {\n    map<string,int> mp;\n    int num = 0;\n    g = vector<vector<int> >(n);\n    REP(i,n) {\n      string A;\n      int B,C;\n      cin >> A >> B >> C;\n      if (mp.count(A) == 0) mp[A] = num++;\n      power[mp[A]] = B;\n      REP(j,C) {\n        string D; cin >> D;\n        if (mp.count(D) == 0) mp[D] = num++;\n        g[mp[A]].push_back(mp[D]);\n        g[mp[D]].push_back(mp[A]);\n      }\n    }\n    ans = 0;\n    solve(1,1,power[0]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\nconst int HALF=20;\nvector<int> dp0(1<<HALF);\nvector<int> vs0(HALF,0);\nvector<int> dp1(1<<HALF);\nvector<int> vs1(HALF,0);\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    for(int i=0;i<half;i++){\n        vs0[i]=0;\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=1;i<(1<<half);i+=2){\n        int vs=0;\n        int val=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                val+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) val=-INF;\n            dp0[i]=val;\n        }\n    }\n\n    \n    for(int i=0;i<rest;i++){\n        vs1[i]=0;\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        int val=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                val+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) val=-INF;\n            dp1[i]=val;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n\n    vector<int> vs01(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]>=half) vs01[i]|=(1<<(g[i][j]-half));\n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if(i&(1<<j)) opn&=~vs01[j];\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    //ios_base::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nusing vi = vector<int>;\nusing vvi = vector<vector<int>>;\nusing vll = vector<ll>;\nusing vvll = vector<vector<ll>>;\nconst double eps = 1e-10;\nconst ll MOD = 1000000007;\nconst int INF = 1000000000;\nconst ll LINF = 1ll<<50;\ntemplate<typename T>\nvoid printv(const vector<T>& s) {\n  for(int i=0;i<(int)(s.size());++i) {\n    cout << s[i];\n    if(i == (int)(s.size())-1) cout << endl;\n    else cout << \" \";\n  }\n}\ntemplate<typename T1, typename T2>\nostream& operator<<(ostream &os, const pair<T1, T2> p) {\n  os << p.first << \":\" << p.second;\n  return os;\n}\nint ans = 0;\nint start = 0;\nvoid dfs(int n, int now, int val, bitset<40> &bs, const vvi &g, const vi &b) {\n  if(n == now) {\n    ans = max(ans, val);\n    return;\n  }\n  bool ok = true;\n  bool distinct = true;\n  for(int i=0;i<(int)(g[now].size());++i) {\n    ok &= !bs[g[now][i]];\n    distinct &= !bs[g[now][i]] && g[now][i] < now;\n  }\n  if(ok) {\n    bs[now] = 1;\n    dfs(n, now+1, val + b[now], bs, g, b);\n    bs[now] = 0;\n  }\n  if(!distinct && now != start) {\n    dfs(n, now+1, val, bs, g, b);\n  }\n}\nvoid solve(int n) {\n  vector<string> A(n);\n  vector<int> B(n);\n  vector<int> c(n);\n  vector<vector<string>> D(n);\n  set<pair<int, string>> st;\n  for(int i=0;i<n;++i) {\n    cin >> A[i] >> B[i] >> c[i];\n    for(int j=0;j<c[i];++j) {\n      string s; cin >> s;\n      D[i].push_back(s);\n    }\n    st.insert({c[i], A[i]});\n  }\n  map<string, int> mp;\n  int id = n-1;\n  for(auto &e: st) {\n    mp[e.second] = id;\n    id--;\n  }\n  vvi g(n);\n  for(int i=0;i<n;++i) {\n    for(int j=0;j<c[i];++j) {\n      g[mp[A[i]]].push_back(mp[D[i][j]]);\n    }\n  }\n  vi b(n);\n  for(int i=0;i<n;++i) {\n    b[mp[A[i]]] = B[i];\n  }\n  start = mp[A[0]];\n  ans = 0;\n  bitset<40> bs(0);\n  dfs(n, 0, 0, bs, g, b);\n  cout << ans << endl;\n}\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  while(1) {\n    int n; cin >> n;\n    if(n == 0) break;\n    solve(n);\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define M 40\n#define max(a,b) (a>b?a:b)\n\ntypedef unsigned int uint;\n\ntypedef vector<int> Graph;\n\nGraph g[M];\nint power[M], sum[M], n, ans;\n\nint solve(int s, int del[M], int pw) {\n\tint del2[M], res = 0, r;\n\tpw += power[s];\n\tfor(int i=0; i<n; ++i) del2[i] = del[i];\n\tfor(uint i=0; i<g[s].size(); ++i) {\n\t\tdel2[g[s][i]] = 1;\n\t}\n\tfor(int i=s+1; i<n; ++i) {\n\t\tif(pw+sum[n-1]-sum[i-1]<=ans) break;\n\t\tif(!del2[i]) {\n\t\t\tr = solve(i, del2, pw);\n\t\t\tres = max(r, res);\n\t\t}\n\t}\n\tans = max(pw+res, ans);\n\treturn res;\n}\n\nint main() {\n\tmap<string, int> kuni;\n\tstring name, near_n;\n\tint nc, del[M];\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfor(int i=0; i<n; ++i) g[i].clear();\n\t\tkuni.clear();\n\t\tfor(int i=0, c=0; i<n; ++i) {\n\t\t\tcin >> name;\n\t\t\tif(!kuni.count(name)) {\n\t\t\t\tkuni[name] = c++;\n\t\t\t}\n\t\t\tcin >> power[kuni[name]] >> nc;\n\t\t\tfor(int j=0; j<nc; ++j) {\n\t\t\t\tcin >> near_n;\n\t\t\t\tif(!kuni.count(near_n)) {\n\t\t\t\t\tkuni[near_n] = c++;\n\t\t\t\t}\n\t\t\t\tg[kuni[name]].push_back(kuni[near_n]);\n\t\t\t\tg[kuni[near_n]].push_back(kuni[name]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; ++i) sum[i] = !i ? power[0] : sum[i-1]+power[i];\n\t\tfor(int i=0; i<n; ++i) del[i] = 0;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// compile in C++11. use -std=c++11.\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define repeat(i,n) for(int i=0;i<static_cast<int>(n);i++)\n#define debug(x) #x << \"=\" << (x)\n#define dump(x) cerr << debug(x) << \" (L:\" << __LINE__ << \")\"<< endl\n\ntypedef long long ll;\ntypedef complex<double> point;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    os << \"[\";\n    for(const auto& v : vec){\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long ll;\n\nll solve(ll k,ll cur,ll mask,const vector<ll>& power,\n         const vector<ll>& masks,const vector<ll>& sum,ll& current_max){\n    int n = power.size();\n    if(k == n) return cur;\n    if(cur + sum[n] - sum[k-1] <= current_max) return cur;\n    if(mask & (1 << k)){\n        // already masked\n        return solve(k+1,cur,mask,power,masks,sum,current_max);\n    }else{\n        current_max = max(current_max,cur+power[k]);\n        return max(solve(k+1,cur+power[k],mask | masks[k],power,masks,sum,current_max),\n                   solve(k+1,cur,mask,power,masks,sum,current_max));\n    }\n}\n\nint main(){\n    while(true){\n        int n;cin >> n;\n        if(n == 0) break;\n        unordered_map<string,int> index_of;\n        int k = 0;\n        vector<ll> mask(n);\n        vector<ll> power(n);\n        for(int i=0;i<n;i++){\n            string A;int B,C;\n            cin >> A >> B >> C;\n            if(index_of.find(A) == index_of.end()){\n                index_of[A] = k;k++;\n            }\n            power[index_of[A]] = B;\n            for(int j=0;j<C;j++){\n                string d;cin >> d;\n                if(index_of.find(d) == index_of.end()){\n                    index_of[d] = k;k++;\n                }\n                mask[index_of[A]] = mask[index_of[A]] | (1 << index_of[d]);\n            }\n        }\n        // sum of [0..i)\n        vector<ll> sum(n+1);\n        for(int i=1;i<=n;i++){\n            sum[i] = sum[i-1] + power[i-1];\n        }\n        ll p = power[0];\n        cout << solve(1,power[0],mask[0],power,mask,sum,p) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,m,n) for(int (i)=(int)(m);i<(int)(n);++i)\n#define rep2(i,m,n) for(int (i)=(int)(n)-1;i>=(int)(m);--i)\n#define REP(i,n) rep(i,0,n)\n#define REP2(i,n) rep2(i,0,n)\n#define FOR(i,c) for(decltype((c).begin())i=(c).begin();i!=(c).end();++i)\n#define all(hoge) (hoge).begin(),(hoge).end()\n#define en '\\n'\nusing ll = long long;\nusing ull = unsigned long long;\ntemplate <class T> using vec = vector<T>;\ntemplate <class T> using vvec = vector<vec<T>>;\ntypedef pair<ll, ll> P;\nconstexpr long long INF = 1LL << 60;\nconstexpr int INF_INT = 1 << 25;\n//constexpr long long MOD = (ll) 1e9 + 7;\nconstexpr long long MOD = 998244353LL;\ntypedef vector<ll> Array;\ntypedef vector<Array> Matrix;\n\n\ntemplate<class T> inline bool chmin(T& a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate<class T> inline bool chmax(T& a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nstruct Edge {\n\tll to, cap, rev;\n\tEdge(ll _to, ll _cap, ll _rev) {\n\tto = _to; cap = _cap; rev = _rev;\n\t}\n};\nusing Edges = vector<Edge>;\nusing Graph = vector<Edges>;\n\nvoid add_edge(Graph& G, ll from, ll to, ll cap, bool revFlag, ll revCap) {\n\tG[from].push_back(Edge(to, cap, (ll)G[to].size()));\n\tif (revFlag)G[to].push_back(Edge(from, revCap, (ll)G[from].size() - 1));\n}\n\n\nvoid solve(const ll n){\n\n\tll all=(1LL<<n)-1;\n\tvec<ll> ok(n,all),ng(n,0);\n\n\tmap<string,ll> mp;//name2num\n\tll id=n-1;\n\tvec<ll> st(n);//軍事的強さ\n\n\tauto name=[&](string t)->ll{\n\t\tif(mp.find(t)==mp.end()){\n\t\t\tmp[t]=id;\n\t\t\tid--;\n\t\t}\n\t\treturn mp[t];\n\t};\n\n\tauto add=[&](ll a,ll b){\n\t\tok[a]^=(1LL<<b);\n\t\tng[a]|=(1LL<<b);\n\t};\n\n\tREP(i,n){\n\t\tstring s;\n\t\tcin>>s;\n\t\tll a = name(s);\n\t\tcin>>st[a];\n\t\tll c;\n\t\tcin>>c;\n\t\tREP(j,c){\n\t\t\tstring d;\n\t\t\tcin>>d;\n\t\t\tll b=name(d);\n\t\t\tadd(a,b);\n\t\t}\n\t}\n\n\tll l=n/2;\n\tll r=n-l;\n\n\tll left=(1LL<<l);\n\tArray dp(left,0);\n\tREP(bit,left){\n\t\tbool flag = true;\n\t\tll con=0;\n\t\tREP(i,l){\n\t\t\tif((bit>>i)&1){\n\t\t\t\tchmax(dp[bit],dp[bit^(1LL<<i)]);\n\t\t\t\tcon = dp[bit^(1LL<<i)]+st[i];\n\t\t\t\tif(bit&ng[i]) flag=false;\n\t\t\t}\n\t\t}\n\t\tif(flag) chmax(dp[bit],con);\n\t}\n\n\tll right=(1LL<<r);\n\tll ans=0;\n\tArray dpr(right,0);\n\tREP(bit,right){\n\t\tbool flag = true;\n\t\tll mask=left-1;\n\t\tREP(i,r){\n\t\t\tif((bit>>i)&1){\n\t\t\t\tchmax(dpr[bit],dpr[bit^(1LL<<i)]+st[i+l]);\n\t\t\t\tmask&=ok[i+l];\n\t\t\t\tif(bit&(ng[i+l]>>l)) flag=false;\n\t\t\t}\n\t\t}\n\t\tif(flag && ((1LL<<n-1-l)&bit)) chmax(ans,dp[mask]+dpr[bit]);\n\t}\n\tcout<<ans<<en;\n}\n\nint main() {\n    ios::sync_with_stdio(false);\n    cin.tie(0);\n    cout.tie(0);\n\n\tll n;\n\twhile(cin>>n){\n\t\tif(n==0) break;\n\t\tsolve(n);\n\t}\n    //solve();\n    //ll t;cin>>t;REP(i,t) solve();\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint ans;\nint n;\nint power[40];\nvector<vector<int> > g;\nvoid solve(ll S, int now, int sum) {\n  int t = 0;\n  if (now == n) {\n    ans = max(ans, sum);\n    return;\n  }\n  for (int i=now; i<n; ++i) if (!(S>>i&1)) t += power[i];\n  if (sum + t < ans) return;\n  bool f = 0;\n  FOR(it, g[now]) {\n    if (S>>*it&1) {\n      f = 1;\n      break;\n    }\n  }\n  if (!f) {\n    // use\n    solve(S|1<<now, now+1, sum+power[now]);\n  }\n  solve(S, now+1, sum);\n}\n\nint main() {\n  while(cin>>n,n) {\n    map<string,int> mp;\n    int num = 0;\n    g = vector<vector<int> >(n);\n    REP(i,n) {\n      string A;\n      int B,C;\n      cin >> A >> B >> C;\n      if (mp.count(A) == 0) mp[A] = num++;\n      power[mp[A]] = B;\n      REP(j,C) {\n        string D; cin >> D;\n        if (mp.count(D) == 0) mp[D] = num++;\n        g[mp[A]].push_back(mp[D]);\n        g[mp[D]].push_back(mp[A]);\n      }\n    }\n    ans = 0;\n    solve(1,1,power[0]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nmap<string,int> M;\nvector<string> NG[41];\nstring A[41];\nint n,B[41],ans;\null g[41];\nint Sum[41];\n \nvoid dfs(int pos,int sum,ull U){\n  ans=max(ans,sum);\n  if(pos==n)return;\n  if(ans>=sum+Sum[pos]) return;\n   \n  dfs(pos+1,sum,U);\n  if((U&(1LL<<pos))==0)dfs(pos+1,sum+B[pos],U|g[pos]);\n   \n}\n \nint main(){\n  while(cin>>n,n){\n    M.clear();\n     \n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      Sum[i]=B[i];\n      M[A[i]]=i;\n      NG[i].resize(C);\n      for(int j=0;j<C;j++)cin>>NG[i][j];\n    }\n     \n    for(int i=n-2;i>=0;i--) Sum[i]+=Sum[i+1];\n     \n    for(int i=0;i<n;i++){\n      g[i]=1LL<<i;\n      for(int j=0;j<(int)NG[i].size();j++)g[i]|=1LL<<M[NG[i][j]];\n    }\n    ans=0;\n    dfs(1,B[0],g[0]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int>& f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tid[t] = id.size();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\n\nint dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t\treturn sum;\n\tif (d >= 40)\n\t\treturn -1919810114514LL;\n\n\tint res = 0;\n\tif (!(enemy >> d & 1))\n\t\tres = dfs(d + 1, enemy | on[d], sum + force[d]);\n\tmax_swap(res, dfs(d + 1, enemy, sum));\n\n\treturn res;\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t\tid[a] = id.size();\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t\tid[d] = id.size();\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\n\t\tint res;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tres = dfs(1, on[0], force[0]);\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tres += dfs(0, 0, 0);\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define M 40\n#define max(a,b) (a>b?a:b)\n\ntypedef unsigned int uint;\n\ntypedef vector<int> Graph;\n\nGraph g[M];\nint power[M], sum[M], n, ans;\n\nint solve(int s, int del[M], int pw) {\n\tint del2[M], res = 0, r;\n\tpw += power[s];\n\tfor(int i=0; i<n; ++i) del2[i] = del[i];\n\tfor(uint i=0; i<g[s].size(); ++i) {\n\t\tdel2[g[s][i]] = 1;\n\t}\n\tfor(int i=s+1; i<n; ++i) {\n\t\tif(pw+sum[n-1]-sum[i-1]<=ans) break;\n\t\tif(!del2[i]) {\n\t\t\tr = solve(i, del2, pw);\n\t\t\tres = max(r, res);\n\t\t}\n\t}\n\tans = max(pw+res, ans);\n\treturn res;\n}\n\nint main() {\n\tmap<string, int> kuni;\n\tstring name, near_n;\n\tint nc, del[M];\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfor(int i=0; i<n; ++i) g[i].clear();\n\t\tkuni.clear();\n\t\tfor(int i=0, c=0; i<n; ++i) {\n\t\t\tcin >> name;\n\t\t\tif(!kuni.count(name)) {\n\t\t\t\tkuni[name] = c++;\n\t\t\t}\n\t\t\tcin >> power[kuni[name]] >> nc;\n\t\t\tfor(int j=0; j<nc; ++j) {\n\t\t\t\tcin >> near_n;\n\t\t\t\tif(!kuni.count(near_n)) {\n\t\t\t\t\tkuni[near_n] = c++;\n\t\t\t\t}\n\t\t\t\tg[kuni[name]].push_back(kuni[near_n]);\n\t\t\t\tg[kuni[near_n]].push_back(kuni[name]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; ++i) sum[i] = !i ? power[0] : sum[i-1]+power[i];\n\t\tfor(int i=0; i<n; ++i) del[i] = 0;\n\t\tans = 0; solve(0, del, 0);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nint n, a, r[64], p[64];\nInt f[64];\n\nvoid prepare(vector<int>& q) {\n    n = q.size();\n    a = 0;\n    rep (i, n) r[i] = q[i];\n    rep (i, n) {\n        p[i] = B[r[i]];\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nvoid rec(int k, Int u) {\n    int s = 0;\n    rep (i, n) if (u&(1LL<<i)) s += p[i];\n    if (s < a) return ;\n    if (k == n) a = s;\n    else {\n        rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return ;\n        const int mask = (1LL<<n) - 1;\n        if (u&(1LL<<k)) rec(k+1, u&(mask-f[k]));\n        if (r[k]) rec(k+1, u&(mask-(1LL<<k)));\n    }\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        rec(0, (1LL<<q.size())-1);\n        ans += a;\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = 1 << 21;\nint X[MAX], Y[MAX], cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tvector<vector<bool>> E(N, vector<bool>(N));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << A[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1LL << n;\n\t\t\tint NY = 1LL << (N - n);\n\t\t\tvector<int> X(NX), Y(NY);\n\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nmask = mask | (1 << i);\n\t\t\t\t\tdp[nmask] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tint tmp = dp[mask];\n\n\t\t\t\tx -= tmp;\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\n\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    vector<int> dp0(1<<half);\n    for(int i=0;i<(1<<half);i++){\n        bool isok=true;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                dp0[i]+=b[j];\n                for(int k=0;k<g[j].size();k++){\n                    isok&=!(g[j][k]<half && (1<<g[j][k])&i);\n                }\n            }\n            if(!isok) dp0[i]=-INF;\n        }\n    }\n\n    vector<int> dp1(1<<rest);\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                dp1[i]+=b[j+half];\n                for(int k=0;k<g[j+half].size();k++){\n                    isok&=!(g[j+half][k]>=half && (1<<(g[j+half][k]-half))&i);\n                }\n            }\n            if(!isok) dp1[i]=-INF;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n    int res=0;\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                for(int k=0;k<g[j].size();k++){\n                    if(g[j][k]>=half){\n                        opn=opn&(~(1<<(g[j][k]-half)));\n                    }\n                }\n            }\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\nconst int HALF=20;\nvector<int> dp0(1<<HALF);\nvector<int> vs0(HALF,0);\nvector<int> dp1(1<<HALF);\nvector<int> vs1(HALF,0);\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    \n    for(int i=0;i<half;i++){\n        vs0[i]=0;\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=0;i<(1<<half);i++){\n        int vs=0;\n        int val=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                val+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) val=-INF;\n            dp0[i]=val;\n        }\n    }\n\n    \n    for(int i=0;i<rest;i++){\n        vs1[i]=0;\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        int val=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                val+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) val=-INF;\n            dp1[i]=val;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n\n    vector<int> vs01(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]>=half) vs01[i]|=(1<<(g[i][j]-half));\n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if(i&(1<<j)) opn&=~vs01[j];\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    //ios_base::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\nusing ll = long long;\nusing ld = long double;\nusing P = pair<int, int>;\nconstexpr ld EPS = 1e-12;\nconstexpr int INF = numeric_limits<int>::max() / 2;\nconstexpr int MOD = 1e9 + 7;\n\ntemplate <typename T>\nvoid printv(const vector<T> &v)\n{\n    int sz = v.size();\n    for (int i = 0; i < sz; i++)\n    {\n        cout << v[i] << \" \\n\"[i == sz - 1];\n    }\n}\n\nint n;\nvector<int> b(40);\n\nint dfs(int cur, ll mask, const vector<vector<int>> &g, const vector<ll> &con)\n{\n    ll ban = 0;\n    for(int i=0;i<n;i++) if((mask>>i)&1) ban |= con[i];\n    int ret = 0;\n    for(int i=cur+1;i<n;i++)\n    {\n        if((ban>>i)&1) continue;\n        ret = max(ret, b[i] + dfs(i, mask | (1LL<<i), g, con));\n    }\n    return ret;\n}\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (cin >> n, n)\n    {\n        vector<string> a(n);\n        vector<vector<string>> d(n);\n        map<string, int> mp;\n        for (int i = 0; i < n; i++)\n        {\n            cin >> a[i];\n            mp[a[i]] = i;\n            cin >> b[i];\n            int c;\n            cin >> c;\n            for (int j = 0; j < c; j++)\n            {\n                string s;\n                cin >> s;\n                d[i].push_back(s);\n            }\n        }\n        vector<vector<int>> g(n);\n        vector<ll> con(n, 0); // con[i] := i に隣接する頂点\n        for (int i = 0; i < n; i++)\n        {\n            for (const auto &s : d[i])\n            {\n                int idx = mp[s];\n                g[i].push_back(idx);\n                con[i] |= (1LL << idx);\n            }\n        }\n        cout << b[0] + dfs(0, 1, g, con) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nint N;\n\nstring Name[40];\nvector<string>to[40];\nvint G[40];\nint val[40];\n\nvector<pint>bef;\nint aft[1<<21];\nbool used[40];\nvoid solve(){\n    bef.clear();\n    memset(aft,0,sizeof(aft));\n    rep(i,N){\n        cin>>Name[i];\n        cin>>val[i];\n        int m;cin>>m;\n        to[i].resize(m);\n        rep(j,m)cin>>to[i][j];\n    }\n\n    rep(i,N){\n        G[i].resize(to[i].size());\n        rep(j,to[i].size()){\n            int hoge=find(Name,Name+N,to[i][j])-Name;\n            G[i][j]=hoge;\n        }\n    }\n\n    int a=N/2;\n    int b=N-a;\n\n    rep(i,1<<a){\n        if((i&1)==0)continue;\n        memset(used,0,sizeof(used));\n        bool f=true;\n        int s=0;\n        rep(j,a){\n            if((i>>j&1)==0)continue;\n            if(used[j])f=false;\n            rep(k,G[j].size())used[G[j][k]]=true;\n            s+=val[j];\n        }\n        if(f)bef.pb(mp(i,s));\n    }\n\n    rep(i,1<<b){\n        memset(used,0,sizeof(used));\n        bool f=true;\n        int s=0;\n        rep(j,b){\n            if((i>>j&1)==0)continue;\n            if(used[a+j])f=false;\n            rep(k,G[a+j].size())used[G[a+j][k]]=true;\n            s+=val[a+j];\n        }\n        if(f)aft[i]=s;\n    }\n\n    rep(i,1<<b){\n        rep(j,b){\n            if((i>>j&1)==0)continue;\n            chmax(aft[i],aft[i^(1<<j)]);\n        }\n    }\n\n\n    int ans=0;\n    rep(i,bef.size()){\n        memset(used,0,sizeof(used));\n        rep(j,a){\n            if(bef[i].first>>j&1)rep(k,G[j].size())used[G[j][k]]=true;\n        }\n\n        int bit=(1<<b)-1;\n        for(int j=a;j<N;j++){\n            if(used[j])bit^=1<<(j-a);\n        }\n        chmax(ans,bef[i].second+aft[bit]);\n    }\n    cout<<ans<<endl;\n}\n\nint main(){\n    while(scanf(\"%d\",&N),N)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], ans;\n\nset<ll> memo;\n\nvoid dfs(ll S){\n\n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  int cnt=0, sum=0;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1<<i))) continue;\n\n    sum+=cost[i];\n    \n    for(int j=i+1;j<n;j++){\n      if(!(S&(1<<j))) continue;\n      if(!G[i][j]) cnt++;\n    }\n    \n  }\n\n  int node=__builtin_popcount(S);\n  \n  if(cnt==node*(node-1)/2){\n    ans=max(ans,sum);\n    return ;\n  }\n\n  for(int i=1;i<n;i++)\n    for(int j=i;j<n;j++){\n      \n      int nS=S;\n\n      for(int k=i;k<=j;k++) nS=nS&(~(1<<k));\n\n      dfs(nS);\n      \n    }\n  \n}\n\nint main(){\n  \n  while(1)  {\n    \n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cnt=0;\n\n    memset(G,0,sizeof(G));\n    \n    for(int i=0;i<n;i++){\n\n      string s;\n      cin>>s;\n\n      if(!num.count(s)) num[s]=cnt++;\n      \n      int a,b;\n      cin>>a>>b;\n      \n      cost[num[s]]=a;\n\n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n\n    ans=0;\n\n    memo.clear();\n    \n    dfs((1<<n)-1);\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tint N;\n\tvector<int> ps;\n\tvector<vector<int>> es;\n\tvector<bool> selected;\n\tvector<bool> canselect;\n\tvector<int> fillc;\n\n\tint Mv;\t\n\tint must;\n\n\tvector<bool> change;\n\tvoid dfs(int v,int val){\n\t\t//DUMP(v);\n\t\tMv=max(Mv,val);\n\t\tif(v>=N)return;\n\t\tif(val+fillc[v]<=Mv)return;\n\t\tif(canselect[v]){\n\t\t\tvector<int> change;\n\t\t\tselect(v,change);\n\t\t\tdfs(v+1,val+ps[v]);\n\t\t\tunselect(v,change);\n\t\t\tif(!checkuse(v))//必ず使う方がいい\n\t\t\t\tdfs(v+1,val);\n\t\t}else{\n\t\t\tdfs(v+1,val);\n\t\t}\n\t}\n\n\tbool checkuse(int v){\n\t\t//if(selected[v])return false;//0\n\t\tREP(i,es[v].size())if(es[v][i]>v)return false;\n\t\treturn true;\n\t}\n\n\tvoid select(int v,vector<int>& change){\n\t\tselected[v]=true;canselect[v]=false;\n\t\tREP(i,es[v].size()){\n\t\t\tif(canselect[es[v][i]]){\n\t\t\t\tcanselect[es[v][i]]=false;\n\t\t\t\tchange.push_back(es[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid unselect(int v,vector<int>& change){\n\t\tselected[v]=false;canselect[v]=true;\n\t\tREP(i,change.size())canselect[change[i]]=true;\n\t}\n\n\tvoid run(){\n\t\tifstream fin(\"in\" );\n\t\tofstream fout( \"out\" );\n\t\twhile(true){\n\t\t\tfin >>N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> cs(N);\n\t\t\tmap<string,int> stoid;\n\t\t\tps=vector<int>(N);\n\t\t\tvector<vector<string>> ess(N);\n\t\t\tREP(i,N){\n\t\t\t\tfin >> cs[i] >> ps[i];stoid.insert(make_pair(cs[i],i));\n\t\t\t\t\n\t\t\t\tint k;fin >>k;\n\t\t\t\tREP(j,k) {\n\t\t\t\t\tstring s;fin >> s;ess[i].push_back(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tes=vector<vector<int>>(N);\n\t\t\tREP(i,N)REP(j,ess[i].size())es[i].push_back(stoid[ess[i][j]]);\n\t\t\n\t\t\tcanselect=vector<bool>(N,true);\n\t\t\tselected=vector<bool>(N);\n\t\t\tfillc=vector<int>(N+1);\n\t\t\tfor(int i=N-1;i>=0;i--)fillc[i]+=fillc[i+1]+ps[i];\n\n\t\t\t//自分\n\t\t\tvector<int> dummy;\n\t\t\tmust=ps[0];select(0,dummy);\n\t\t\t//孤立点\n\t\t\tREP(i,N)if(canselect[i] && es[i].size()==0){must+=ps[i];select(i,dummy);}\n\t\t\t\n\t\t\tMv=must;\n\t\t\tdfs(0,must);\n\n\t\t\tfout<< Mv<<endl;\n\t\t}\n\t}\n};\n int main(){\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tvi pow(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> pow[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tvector<ll> g(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tg[i] = 1ll << i;\n\t\t\tREP(j, nei[i].size())\n\t\t\t{\n\t\t\t\tg[i] |= 1ll << mp[nei[i][j]];\n\t\t\t}\n\t\t}\n\n\t\tvi ss(n + 1);\n\t\tREP(i, n) ss[i + 1] = ss[i] + pow[i];\n\n\t\tint ans = 0;\n\t\tstack<ll> st;\n\t\tst.push(1);\n\t\twhile (st.size())\n\t\t{\n\t\t\tll tmp = st.top();\n\t\t\tst.pop();\n\t\t\tint left;\n\t\t\tfor (int i = n - 1; i >= 0; i--)\n\t\t\t{\n\t\t\t\tif ((tmp >> i) & 1)\n\t\t\t\t{\n\t\t\t\t\tleft = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tll can = 0;\n\t\t\tint sum = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((tmp >> j) & 1)\n\t\t\t\t{\n\t\t\t\t\tsum += pow[j];\n\t\t\t\t\tcan |= g[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (sum + ss[n] - ss[left + 1] <= ans) continue;\n\t\t\tchmax(ans, sum);\n\t\t\tFOR(j, left + 1, n)\n\t\t\t{\n\t\t\t\tif ((can >> j) & 1) continue;\n\t\t\t\tst.push(tmp | (1ll << j));\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\nusing ll = int;\n\nstring A[41];\nll B[41];\nll C[41];\nstring D[41][41];\nvector<ll> d0[41];\nvector<ll> d1[41];\n\nll dp0[1<<20];\nll dp1[1<<20];\nll maskNg0[1<<20];\nll maskNg1[1<<20];\nll maskNg2[1<<20];\n\nvoid calc(ll* dp, ll l, ll r, ll* maskNg) {\n  rep(mask, 1 << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1<<i)) continue;\n      ll nxt = mask | (1 << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      cin >> A[i] >> B[i] >> C[i];\n      rep(j, C[i]) cin >> D[i][j];\n    }\n    ll l = 0, m = n/2, r = n;\n\n    unordered_map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    rep(i, n) {\n      d0[i].clear();\n      d1[i].clear();\n      rep(j, C[i]) {\n\tint k = mp[D[i][j]];\n\tif(k < m) d0[i].push_back(k);\n\telse d1[i].push_back(k);\n      }\n    }\n  \n    rep(i, 1<<(m - l)) maskNg0[i] = maskNg2[i] = 0;\n    rep(i, 1<<(r - m)) maskNg1[i] = 0;\n    \n    rep(i, m - l) {\n      auto& mask = maskNg0[i];\n      rep(j, d0[i].size()) {\n\tll k = d0[i][j];\n\tif(k >= m) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg1[i];\n      rep(j, d1[i + m].size()) {\n\tll k = d1[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg2[i];\n      rep(j, d1[i].size()) {\n\tll k = d1[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1 << k);\n      }\n    }\n\n    rep(i, 1 << (m - l)) dp0[i] = 0;\n    rep(i, 1 << (r - m)) dp1[i] = 0;\n    calc(dp0, l, m, maskNg0);\n    calc(dp1, m, r, maskNg1);\n\n    rep(mask, (1 << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1<<i)]);\n      }\n    }\n    \n    ll ans = 0;\n    rep(x, 1<<(m - l)) {\n      if(x&1) {\n\tll y = (1<<(r - m)) - 1;\n\trep(i, m - l) {\n\t  if(x & (1 << i)) {\n\t    y -= (y & maskNg2[i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<ll> memo;\n\nvoid dfs(int x,int sum,ll S,int idx){\n  \n  for(int i=idx;i<n;i++){\n    \n    int f=0;\n    \n    for(int j=0;j<n;j++)\n      if((S&(1<<j))&&G[j][i]) f=1;\n    \n    if(!f){\n      \n      ll nS=S;\n\n      nS|=(1<<i);\n      \n      //if(memo.count(nS)) continue;\n  \n      //      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[i]);\n      \n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=cost[0];\n    \n    ll S=(1<<0);\n\n    dfs(1,cost[0],S,1);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nint power[40];\nint psum[41];\nvector<int> g[40];\nint n;\nint ans;\n\nvoid solve(int now, ll S, int sum) {\n  if (sum + psum[now] < ans) return;\n  if (now == n) {\n    ans = max(ans, sum);\n    // cout << bitset<14>(S) << \" \" << sum << endl;\n    return;\n  }\n  bool ng = 0;\n  FOR(it, g[now]) {\n    if (S>>*it&1) {\n      ng = 1;\n      break;\n    }\n  }\n  solve(now+1, S, sum);\n  if (!ng) {\n    solve(now+1, S|1LL<<now, sum + power[now]);\n  }\n}\n\nint main() {\n  while(cin>>n,n) {\n    map<string,int> mp;\n    REP(i,n) g[i].clear();\n    vector<string> v[n];\n    REP(i,n) {\n      string s; cin >> s; mp[s] = i;\n      cin >> power[i];\n      int k;\n      cin >> k;\n      v[i].resize(k);\n      REP(j,k) cin >> v[i][j];\n    }\n    REP(i,n) {\n      FOR(it, v[i]) \n        g[i].push_back(mp[*it]);\n    }\n\n    // FOR(it, mp) cout << it->first << \" \" << it->second << endl;\n    psum[n] = 0;\n    for (int i=n-1; i>=0; --i) {\n      psum[i] = psum[i+1] + power[i];\n    }\n    \n    ans = 0;\n    solve(1,1,power[0]);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], cf[64], ct[64];\nint dp[1<<20];\n\nint solve() {\n    const int n = N / 2, m = N - n;\n    const int nn = 1<<n, mm = 1<<m;\n    memset(cf, 0, sizeof(cf));\n    memset(ct, 0, sizeof(ct));\n    rep (i, n) rep (j, n) if (g[i][j]) cf[i] |= 1<<j;\n    rep (i, m) rep (j, m) if (g[i+n][j+n]) cf[i+n] |= 1<<j;\n    rep (i, m) rep (j, n) if (g[i+n][j]) ct[i] |= 1<<j;\n    rep (i, nn) dp[i] = -INF;\n    rep (b, nn) {\n        if (b&1) {\n            bool ok = true;\n            rep (i, n) if (b&(1<<i) && b&cf[i]) { ok = false; break; }\n            if (ok) {\n                int s = 0;\n                rep (i, n) if (b&(1<<i)) s += B[i];\n                dp[b] = max(dp[b], s);\n            }\n        }\n        rep (i, n) dp[b|(1<<i)] = max(dp[b|(1<<i)], dp[b]);\n    }\n    int ans = 0;\n    rep (b, mm) {\n        bool ok = true;\n        rep (i, m) if (b&(1<<i) && b&cf[i+n]) { ok = false; break; }\n        if (!ok) continue;\n        int s = 0, z = 0;\n        rep (i, m) if (b&(1<<i)) s += B[i+n], z |= ct[i];\n        ans = max(ans, dp[nn-1-z] + s);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define LINE cout << \"LINE : \" << __LINE__ << endl\n#define dump(v) cout << #v << \" : \" << v << \" \"\n#define dumpl(v) dump(v) << endl\n\nusing ll = int_fast64_t;\n\nvoid calc(vector<ll>& dp, ll l, ll r, const vector<ll>& maskNg, const vector<ll>& B) {\n  rep(mask, 1LL << (r - l)) {\n    /*\n    rep(i, r - l) {\n      if(mask&(1LL<<i)) {\n\tdp[mask] = max(dp[mask], dp[mask - (1LL<<i)]);\n      }\n    }\n    */\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1LL<<i)) continue;\n      ll nxt = mask | (1LL << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    vector<string> A(n);\n    vector<ll> B(n);\n    vector<vector<string>> D(n);\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    vector<vector<ll>> d(n);\n    rep(i, n) {\n      d[i].resize(D[i].size());\n      rep(j, D[i].size()) d[i][j] = mp[D[i][j]];\n    }\n\n    ll l = 0, m = n/2, r = n;\n    vector<vector<ll>> maskNg;\n    maskNg.push_back(vector<ll>(m - l, 0));\n    maskNg.push_back(vector<ll>(r - m, 0));\n    maskNg.push_back(vector<ll>(m - l, 0));\n    \n    rep(i, m - l) {\n      auto& mask = maskNg[0][i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j];\n\tif(k >= m) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg[1][i];\n      rep(j, d[i + m].size()) {\n\tll k = d[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg[2][i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n\n    vector<ll> dp0(1<<(m - l), 0LL);\n    vector<ll> dp1(1<<(r - m), 0LL);\n    calc(dp0, l, m, maskNg[0], B);\n    calc(dp1, m, r, maskNg[1], B);\n\n    rep(mask, (1LL << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1LL<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1LL<<i)]);\n      }\n    }\n    \n    ll ans = 0LL;\n    rep(x, 1LL<<(m - l)) {\n      if(x&1LL) {\n\tll y = (1LL<<(r - m)) - 1LL;\n\trep(i, m - l) {\n\t  if(x & (1LL << i)) {\n\t    y -= (y & maskNg[2][i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cstdio>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<iomanip>\n#include<queue>\n#include<ciso646>\n#include<random>\n#include<map>\n#include<set>\n#include<bitset>\n#include<stack>\n#include<unordered_map>\n#include<utility>\n#include<cassert>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef unsigned long long ul;\ntypedef unsigned int ui;\nconst ll mod = 1000000007;\nconst ll INF = mod * mod;\ntypedef pair<int, int> P;\n#define stop char nyaa;cin>>nyaa;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define per(i,n) for(int i=n-1;i>=0;i--)\n#define Rep(i,sta,n) for(int i=sta;i<n;i++)\n#define rep1(i,n) for(int i=1;i<=n;i++)\n#define per1(i,n) for(int i=n;i>=1;i--)\n#define Rep1(i,sta,n) for(int i=sta;i<=n;i++)\ntypedef pair<ll, ll> LP;\ntypedef vector<int> vec;\ntypedef vector<string> svec;\ntypedef long double ld;\ntypedef pair<ld, ld> LDP;\nconst ld eps = 1e-8;\n\nint exibit[1 << 20];\nvoid init() {\n\trep1(i, (1 << 20) - 1) {\n\t\trep(j, 20)if (i&(1 << j)) {\n\t\t\texibit[i] = j; break;\n\t\t}\n\t}\n}\n\nint n;\nvoid solve() {\n\tmap<string, int> mp;\n\tmap<string, bool> used;\n\tvector<vector<bool>> b(n);\n\trep(i, n)b[i].resize(n, false);\n\tint cur = 0;\n\tvector<int> c(n);\n\tvector<bool> ban(n, false);\n\trep(i, n) {\n\t\tstring s; cin >> s;\n\t\tif (!used[s]) {\n\t\t\tused[s] = true;\n\t\t\tmp[s] = cur; cur++;\n\t\t}\n\t\tint id = mp[s];\n\t\tcin >> c[id];\n\t\tint d; cin >> d;\n\t\trep(j, d) {\n\t\t\tstring st; cin >> st;\n\t\t\tif (!used[st]) {\n\t\t\t\tused[st] = true;\n\t\t\t\tmp[st] = cur; cur++;\n\t\t\t}\n\t\t\tint to = mp[st];\n\t\t\tif (i == 0)ban[to] = true;\n\t\t\tb[id][to] = b[to][id] = true;\n\t\t}\n\t}\n\tban[0] = true;\n\tvector<int> v;\n\trep(i, n)if (!ban[i])v.push_back(i);\n\tint ans = 0;\n\tint len = v.size();\n\tint d1 = len / 2; int d2 = len - d1;\n\tvector<int> memo(1 << d2, 0);\n\tvector<bool> pass(1 << d2,false);\n\trep(i, (1 << d2)) {\n\t\tif (pass[i]) {\n\t\t\trep(j, d2) {\n\t\t\t\tpass[i | (1 << j)] = true;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> u;\n\t\trep(j, d2) {\n\t\t\tif (i&(1 << j))u.push_back(v[j + d1]);\n\t\t}\n\t\tbool f = true;\n\t\tif (i>0&&u.size()<3) {\n\t\t\tint chk = exibit[i];\n\t\t\trep(j, d2) {\n\t\t\t\tif (i & (1 << j)) {\n\t\t\t\t\tif (b[v[chk + d1]][v[j + d1]]) {\n\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\trep(j, d2) {\n\t\t\t\tif ((i&(1 << j))==0) {\n\t\t\t\t\tpass[i^(1<<j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\trep(j, u.size())memo[i] += c[u[j]];\n\t}\n\trep(i, (1 << d2)) {\n\t\trep(j, d2) {\n\t\t\tif (i&(1 << j)) {\n\t\t\t\tmemo[i] = max(memo[i], memo[i^(1<<j)]);\n\t\t\t}\n\t\t}\n\t}\n\tfill(pass.begin(), pass.begin() + (1 << d1), false);\n\tvector<int> trans(1 << d1, (1 << d2) - 1);\n\trep1(i, (1 << d1) - 1) {\n\t\tint chk = exibit[i];\n\t\tint mem = 0;\n\t\trep(j, d2) {\n\t\t\tif (b[v[chk]][v[d1 + j]])mem += (1 << j);\n\t\t}\n\t\tmem = (1 << d2) - 1 - mem;\n\t\ttrans[i] = trans[i^(1<<chk)] & mem;\n\t}\n\trep(i, (1 << d1)) {\n\t\tif (pass[i]) {\n\t\t\trep(j, d1) {\n\t\t\t\tpass[i | (1 << j)] = true;\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tvector<int> u;\n\t\trep(j, d1) {\n\t\t\tif (i&(1 << j))u.push_back(v[j]);\n\t\t}\n\t\tbool f = true;\n\t\tif (i>0&&u.size()<3) {\n\t\t\tint chk = exibit[i];\n\t\t\trep(j, d1) {\n\t\t\t\tif (i & (1 << j)){\n\t\t\t\t\tif (b[v[chk]][v[j]]) {\n\t\t\t\t\t\tf = false; break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (!f) {\n\t\t\trep(j, d1) {\n\t\t\t\tif ((i&(1 << j)) == 0) {\n\t\t\t\t\tpass[i^(1<<j)] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tcontinue;\n\t\t}\n\t\tint sum = 0;\n\t\trep(j, u.size()) {\n\t\t\tsum += c[u[j]];\n\t\t}\n\t\tans = max(ans, sum + memo[trans[i]]);\n\t}\n\tcout << ans + c[0] << endl;\n}\n\nsigned main() {\n\tios::sync_with_stdio(false);\n\tcin.tie(0);\n\t//cout << fixed << setprecision(10);\n\tinit();\n\twhile (cin >> n, n) {\n\t\tsolve();\n\t}\n\t//solve();\n\t//stop\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tvector<vector<bool>> E(N, vector<bool>(N));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << A[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1LL << n;\n\t\t\tint NY = 1LL << (N - n);\n\t\t\tvector<int> X(NX), Y(NY);\n\n\t\t\tauto indx = [&](int mask) {\n\n\t\t\t\t// 頂点\n\t\t\t\tvector<int> v;\n\t\t\t\trep(j, 0, n) {\n\t\t\t\t\tif ((mask >> j) & 1)\n\t\t\t\t\t\tv.push_back(j);\n\t\t\t\t}\n\n\t\t\t\tfor (auto p1 : v)for (auto p2 : v) {\n\t\t\t\t\tif (E[p1][p2] == true)\n\t\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\treturn true;\n\n\t\t\t};\n\t\t\t//auto indy = [&](int mask) {\n\n\t\t\t//\t// 頂点\n\t\t\t//\tvector<int> v;\n\t\t\t//\trep(j, 0, N - n) {\n\t\t\t//\t\tif ((mask >> j) & 1)\n\t\t\t//\t\t\tv.push_back(j);\n\t\t\t//\t}\n\n\t\t\t//\tfor (auto p1 : v)for (auto p2 : v) {\n\t\t\t//\t\tif (E[p1 + n][p2 + n] == true)\n\t\t\t//\t\t\treturn false;\n\t\t\t//\t}\n\n\t\t\t//\treturn true;\n\n\t\t\t//};\n\n\t\t\tvector<bool> indy(NY, true);\n\t\t\trep(mask, 0, NY) {\n\t\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\t\tif (!((mask >> i) & 1))continue;\n\t\t\t\t\tif (!((mask >> j) & 1))continue;\n\t\t\t\t\tif (E[i + n][j + n])\n\t\t\t\t\t\tindy[mask] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<int> cost(NY);\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx(mask))continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tint tmp = 0;\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t\trep(j, n, N) {\n\t\t\t\t\t\t\tif (E[i][j])\n\t\t\t\t\t\t\t\ttmp |= 1 << (j - n);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tx -= tmp;\n\n\t\t\t\t//cerr << \"m \" << bitset<4>(mask) << \" \" << cost_a << endl;\n\t\t\t\t//cerr << \"x \" << bitset<4>(x) << \" \" << cost[x] << endl;\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\n#define MAX_N 1000\n\nint n;\nstring a[44],d[44][44];\nll cov[44];\nint b[44],c[44];\nint sum1[1<<20],sum2[1<<20];\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    map<string,int> id;\n    rep(i,n){\n      cin>>a[i]>>b[i]>>c[i];\n      id[a[i]]=i;\n      rep(j,c[i]){\n        cin>>d[i][j];\n      }\n    }\n    memset(cov,0,sizeof(cov));\n    memset(sum1,0,sizeof(sum1));\n    memset(sum2,0,sizeof(sum2));\n    rep(i,n){\n      cov[i]=(1<<n)-1;\n      cov[i]^=(1<<i);\n      rep(j,c[i]){\n        cov[i]^=(1<<id[d[i][j]]);\n      }\n    }\n    int n1=n/2,n2=n-n1;\n    rep(S,1<<n1){\n      rep(i,n1){\n        if((cov[i]&S)==S){\n          maxch(sum1[S|(1<<i)],sum1[S]+b[i]);\n        }\n      }\n    }\n    rep(S,1<<n2){\n      rep(i,n2){\n        if(((cov[i+n1]>>n1)&S)==S){\n          maxch(sum2[S|(1<<i)],sum2[S]+b[i+n1]);\n        }\n        if(((S>>i)&1)==1)maxch(sum2[S],sum2[S^(1<<i)]);\n      }\n    }\n    int res=0;\n    rep(S,1<<n1){\n      if((S&1)==0)continue;\n      int S2=(1<<n2)-1;\n      rep(i,n1){\n        if(((S>>i)&1)==1){\n          S2&=(cov[i]>>n1);\n        }\n      }\n      maxch(res,sum1[S]+sum2[S2]);\n    }\n    cout<<res<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N, B[40];\nvector<int> D[40];\n\nint dfs(int n, int *flag_)\n{\n    int preproc = 0, res = 0;\n    int flag[40];\n    for(int i = 0; i < N; ++i)\n        flag[i] = flag_[i];\n    \n    flag[n] = 1;\n    for(int i = 0; i < D[n].size(); ++i)\n        flag[D[n][i]] = -1;\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n    \tif(flag[i] != 0) continue;\n        bool f = true;\n        for(int j = 0; j < D[i].size(); ++j)\n            if(flag[D[i][j]] != -1) {\n                f = false; break;\n            }\n        if(f)\n            flag[i] = 1, preproc += B[i];\n    }\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n        if(flag[i] != 0) continue;\n        int tmp = B[i] + dfs(i, flag);\n        res = max(res, tmp);\n        flag[i] = -1;\n    }\n    \n    return preproc + res;\n}\n\nint main()\n{\n    int C;\n    string A, Dt;\n    \n    while(cin >> N && N)\n    {\n        map<string, int> table;\n        vector<string> Ds[40];\n        for(int i = 0; i < 40; ++i) D[i].clear();\n        \n        for(int i = 0; i < N; ++i)\n        {\n            cin >> A >> B[i] >> C;\n            for(int j = 0; j < C; ++j)\n                cin >> Dt, Ds[i].push_back(Dt);\n            table[A] = i;\n        }\n        for(int i = 0; i < N; ++i)\n            for(int j = 0; j < Ds[i].size(); ++j)\n                D[i].push_back(table[Ds[i][j]]);\n        \n        int flag[40] = {};\n        int res = B[0] + dfs(0, flag);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nbitset<40> G[44];\nint B[44];\nint idx[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\nbitset<40> ok;\nbitset<40> used;\nbitset<40> sele;\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[idx[i]] && !used[idx[i]] && !sele[idx[i]] ) cnt++;\n  }\n  //cout << id << \" \"<< cnt << \" \"<< M << endl;\n  //return cnt > M;\n  return false;\n}\nint solve(int num){\n  int id = idx[num];\n  if( num == N ) return 0;\n  if( sele[id] || ok[id] || used[id] ) return solve(num+1);\n  //if( check(num) ) return 0;\n  \n  bitset<40> tmp = used;\n  sele[id] = true;\n  used |= G[id];\n  int res = solve(num+1)+B[id];\n\n  //cout << \"view\" << endl;\n  //cout << ok << endl;\n  //cout << used << endl;\n  //cout << sele << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << \n  //cout << id << \" \" << res << endl;\n\n  used = tmp;\n  sele[id] = false;\n  \n  int sum = 0;\n  //for(int i=id;i<N;i++) if( !sele[i] && !ok[i] && !used[i] ) sum += B[i];\n  for(int i=num+1;i<N;i++) if( !sele[idx[i]] && !ok[idx[i]] && !used[idx[i]] ) sum += B[idx[i]];\n\n\n  if( sum > res )\n    res = max( res,solve(num+1) );\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    vector<pair<int,int>> point;\n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id]=0;\n      point.push_back( make_pair( B[id], id ) );\n      assert( id < N );\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id][nd] = true;\n      }\n    }\n\n    sort( point.rbegin(), point.rend() );\n    for(int i=0;i<(int)point.size();i++)\n      idx[i] = point[i].second;\n\n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i]==bitset<40>(0) ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    used = bitset<40>(0);\n    sele = bitset<40>(0);\n    if( G[0]!=bitset<40>(0) ) res += B[0];\n    sele[0] = true;\n    used |= G[0];\n    res += solve(0);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nmap<string,int> a;\nvi b,c;\nvector<vs> d;\n\nvvi g;\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tb=c=vi(n);\n\t\td=vector<vs>(n);\n\t\tg=vvi(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s>>b[i]>>c[i];\n\t\t\ta[s]=i;\n\t\t\td[i]=vs(c[i]);\n\t\t\tfor(int j=0;j<c[i];j++) cin>>d[i][j];\n\t\t}\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<c[i];j++) g[i].push_back(a[d[i][j]]);\n\t\tint N=n/2,res=0;\n\t\tvi dp(1<<N);\n\t\tvl S(n);\n\t\tfor(int i=1;i<1<<N;i++){\n\t\t\tint v,I=i;\n\t\t\tfor(int j=0;j<N;j++) if(i&1<<j){\n\t\t\t\tv=j+n-N;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tI-=1<<v-n+N;\n\t\t\tfor(int j=0;j<g[v].size();j++){\n\t\t\t\tint u=g[v][j];\n\t\t\t\tif(u>=n-N&&I&1<<u-n+N) I-=1<<u-n+N;\n\t\t\t}\n\t\t\tdp[i]=max(dp[i&i-1],dp[I]+b[v]);\n\t\t}\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<g[i].size();j++) S[i]+=1ll<<g[i][j];\n\t\tfor(int i=0;i<1<<n-N;i++){\n\t\t\tint I=(1<<N)-1,sum=0;\n\t\t\tbool f=1;\n\t\t\tfor(int j=0;j<n-N;j++) if(i&1<<j){\n\t\t\t\tsum+=b[j];\n\t\t\t\tif(S[j]&i) f=0;\n\t\t\t\tI&=(1<<N)-1-(S[j]>>n-N);\n\t\t\t}\n\t\t\tif(f&&i&1) res=max(res,dp[I]+sum);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#ifdef __BORLANDC__\n\ttypedef __int64 ll;\n#else\n\ttypedef long long ll;\n#endif\n\n\nconst int INF = 1000000000;\nconst ll L1 = 1;\nconst int N = 40;\nint M = 20;\n\nint n;\nll edge[N];\nint power[N];\n\nvoid printbit(ll state){\n\trep(i,n)printf(\"%d\",((L1<<i)&state)>0);puts(\"\");\n}\n\nvoid printedge(){\n\tprintf(\"edge\\n\");\n\trep(i,n)printbit(edge[i]);\n}\n\nbool init(){\n\tcin>>n;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i]=power[i]=0;\n\t\n\tmap<string,int> mp;\n\tvector<string> estr[N];\n\trep(i,n){\n\t\tstring a;\n\t\tint b,c;\n\t\tcin>>a>>b>>c;\n\t\tmp[a]=i;\n\t\tpower[i]=b;\n\t\trep(j,c){\n\t\t\tstring d;\n\t\t\tcin>>d;\n\t\t\testr[i].push_back(d);\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,estr[i].size()){\n\t\t\tedge[i] |= (L1<<mp[estr[i][j]]);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool hasbit(ll state, int bit){return state&(L1<<bit);}\n\nint T = (1<<M);\nconst int TM = (1<<20);\nint half[TM];\n\nint left_search(){\n\trep(i,T)half[i]=0;\n\t\n\tint maxi = 0;\n\tfor(int i=1;i<T;i+=2){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\trep(j,M){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\t if(edge[j]&i)ok=false;\n\t\t\t\t sum += power[j];\n\t\t\t}\n\t\t\tif(!ok)break;\n\t\t}\n\t\t\n\t\tif(ok)half[i]=sum;\n\t\tmaxi = max(maxi,half[i]);\n\t}\n\treturn maxi;\n}\n\nint memo[TM];\nint left_memo(int state){\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tint ret = half[state];\n\tif(ret==0)ret = -INF;\n\trep(i,M){\n\t\tif(state&(1<<i)){\n\t\t\tret = max(ret, left_memo(state ^ (1<<i)));\n\t\t}\n\t}\n\treturn memo[state]=ret;\n}\n\nint right_search(){\n\tint ans = 0;\n\tfor(ll i=0; i<(L1<<n); i+=T){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\tll mask = 0;\n\t\treps(j,M,n){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\tif(edge[j]&i)ok=false;\n\t\t\t\tsum+=power[j];\n\t\t\t\tmask |= edge[j];\n\t\t\t}\n\t\t\tif(!ok)break;\n\t\t}\n\t\t\n\t\tif(ok){\n\t\t\tmask &= (T-1);\n\t\t\tmask ^= (T-1);\n\t\t\t//printf(\"i=%d sum=%d memo[bit]=%d \",i,sum,memo[mask]);\n\t\t\t//printbit(mask);\n\t\t\tans = max(ans, memo[mask]+sum);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid left_dp(){\n\trep(i,T)memo[i]=-1;\n\t\n\tleft_memo(T-1);\n}\n\nvoid printdp(){\n\trep(i,T){\n\t\tprintf(\"%3d \",memo[i]);printbit(i);\n\t}\n}\nvoid printsearch(){\n\trep(i,T){\n\t\tprintf(\"%3d \",half[i]);printbit(i);\n\t}\n}\nint solve(){\n\tM = (n+1)/2;\n\tT = (1<<M);\n\t\n\tint a = left_search();\n\tleft_dp();\n\t\n\t/*\n\tputs(\"s\");\n\tprintsearch();\n\tputs(\"d\");\n\tprintdp();\n\t*/\n\treturn max(a,right_search());\n}\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n6\nINTERCAL 10 3 Chef Piet COW\nChef 7 3 INTERCAL Piet COW\nPiet 6 2 INTERCAL Chef\nCOW 7 2 INTERCAL Chef\nJ 6 1 A\nA 12 1 J\n0\n\n6\nINTERCAL 20 1 J\nChef 50 3 J A Piet\nPiet 30 2 A Chef\nCOW 15 1 J\nJ 40 3 COW INTERCAL Chef\nA 25 2 Chef Piet\n0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nvector<int> G[44];\nint B[44];\nbool ok[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\n\nbool used[55];\nbool sele[55];\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[i] && !used[i] && !sele[i] ) cnt++;\n  }\n  return cnt > M;\n}\nint solve(int id){\n  if( id == N ) return 0;\n  if( ok[id] || used[id] ) return solve(id+1);\n  if( check(id) ) return 0;\n  int res = solve(id+1);\n  \n  bool tmp[41]={};\n  sele[id] = true;\n  for(int i=0;i<N;i++) tmp[i] = used[i];\n  for(int i=0;i<(int)G[id].size();i++) used[G[id][i]] = true;\n  res = max( res, solve(id+1)+B[id] );\n\n  //cout << \"view\" << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << endl; }\n  //cout << id << \" \" << res << endl;\n\n  for(int i=0;i<N;i++) used[i] = tmp[i];\n  sele[id] = false;\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id].clear();\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id].push_back( nd );\n      }\n    }\n\n    \n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i].empty() ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    memset(used,0,sizeof(used));\n    memset(sele,0,sizeof(sele));\n    M = (N+1)/2;\n    if( !G[0].empty() ) res += B[0];\n    sele[0] = true;\n    for(int i=0;i<(int)G[0].size();i++) used[G[0][i]] = true;\n    res += solve(1);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define rep2(i,a,b) for(int i=a;i<=b;i++)\n#define pb push_back\n#define eb emplace_back\n\nint in(){int x;cin>>x;return x;}\n\n\n    \n#define ll long long\n\nint n;\nvector<vector<int>> g;\nvector<int> p;\nint ma;\nvoid dfs(vector<int> &used,int x,int r){\n    while(r<n and used[r]) r++;\n    if(r == n){\n        ma = max(ma,x); return ;\n    }\n    vector<int> mem{r};\n    for(auto e:g[r])if(!used[e])mem.push_back(e);\n    for(auto e:mem){\n        vector<int> use{e};\n        for(auto f:g[e]){\n            if(!used[f])use.push_back(f);\n        }\n        for(auto f:use)used[f]=1;\n        dfs(used,x+p[e],r+1);\n        for(auto f:use)used[f]=0;\n    }\n}\n            \n\nmain(){\n    while(1){\n        n=in();\n        if(!n)return 0;\n        map<string,int> mp;\n        g=vector<vector<int>>(n);\n        p=vector<int>(n);\n        int cnt = 0;\n        rep(i,n){\n            string s;cin>>s;\n            int now ;\n            if(!mp.count(s))mp[s] = cnt++;\n            now = mp[s];\n            cin>>p[now];\n            int k=in();\n            rep(j,k){\n                cin>>s;\n                if(!mp.count(s))mp[s] = cnt++;\n                g[now].pb(mp[s]);\n            }\n        }\n        vector<int> used(n);\n        int ans = 0;\n        rep(i,n){\n            if(g[i].empty()){\n                used[i] = 1;\n                ans+=p[i];\n            }\n        }\n        if(!used[0]){\n            ans+=p[0];\n            for(auto e:g[0])used[e]=1;\n            used[0]=1;\n        }\n        ma = 0;\n        dfs(used,ans,0);\n        cout << ma  << endl;\n    }\n}\n\n        \n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nvector<i64> edges(n + 10, 0);\nvector<int> x(n + 10, 0);\nvector<int> sum(n + 10, 0);\nint result = 0;\nvoid dfs(i64 i, i64 bit, int now_sum) {\n  result = max(result, now_sum);\n  if (i == n)\n    return;\n  //枝刈り\n  if (now_sum + sum[i] <= result)\n    return;\n  // throw\n  dfs(i + 1, bit, now_sum);\n\n  if (0 == (bit & edges[i]))\n    dfs(i + 1, bit | (1LL << i), now_sum + x[i]);\n};\nint get_i(map<string,int> &mp,string s) {\n  mp.emplace(s,mp.size());\n  return mp[s];\n};\n\nint main(){\n    while(cin >> n,n){\n        edges.assign(n + 10, 0);\n        x.assign(n + 10, 0);\n        map<string,int> mp;\n        for (int c = 0; c < n; c++) {\n          string s;\n          cin >> s;\n          int i = get_i(mp,s);\n          int C;\n          cin >> x[i] >> C;\n          for (int d = 0; d < C; d++) {\n            cin >> s;\n            edges[i] |= (1LL << get_i(mp,s));\n          }\n        }\n\n        sum.assign(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        result = 0;\n        dfs(1,1,x[0]);\n        cout << result << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nint id[40];\nint G[40][40];\nstring name[40];\nint B[40];\nvector<string> D[40];\nint N;\nint ans;\nmap<string, int> m;\n\nvoid f(int n, ll mask, int sum) {\n\tif(n == N) {\n\t\t/*for(int i = 0; i < N; i++) {\n\t\t\tif(mask >> i & 1) cout << name[i] << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t\tans = max(ans, sum);\n\t\treturn;\n\t}\n\n\tint tsum = 0;\n\tfor(int i = n; i < N; i++) {\n\t\ttsum += B[id[i]];\n\t}\n\tif(sum + tsum <= ans) return;\n\n\tbool canUse = true;\n\tfor(int i = 0; i < N; i++) {\n\t\tif((mask >> id[i] & 1) && G[m[name[id[n]]]][m[name[id[i]]]]) {\n\t\t\tcanUse = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(canUse) {\n\t\tf(n + 1, mask | (1LL << id[n]), sum + B[id[n]]);\n\t}\n\n\tf(n + 1, mask, sum);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> N, N) {\n\t\tm.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> name[i] >> B[i];\n\t\t\tm[name[i]] = i;\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tD[i].assign(C, \"\");\n\t\t\tfor(int j = 0; j < C; j++) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint myPow = B[0];\n\t\tB[0] = 1e9;\n\n\t\ttypedef pair<int, int> P;\n\t\tvector<P> p;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tp.push_back({ B[i], i });\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\treverse(p.begin(), p.end());\n\n\t\tB[0] = myPow;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tid[i] = p[i].second;\n\t\t}\n\n\t\tmemset(G, 0, sizeof G);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(auto s : D[i]) {\n\t\t\t\tG[m[name[i]]][m[s]] = G[m[s]][m[name[i]]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tf(1, 1, B[0]);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n;\nint main(){\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs name(n);\n\t\tvi b(n),co(n);\n\t\tvector<vs>in(n);\n\t\trep(i,n){\n\t\t\tcin>>name[i]>>b[i]>>co[i];\n\t\t\tma[name[i]]=1;\n\t\t\tin[i]=vs(co[i]);\n\t\t\trep(j,co[i]){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tma[in[i][j]]=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\trep(i,n)ma[name[i]]=i;\n\t\n\t\tvector<ll>A(n);\n\t\trep(i,n)rep(j,in[i].size()){\n\t\t\tint from=ma[name[i]],to=ma[in[i][j]];\n\t\t\tA[from]|=1ll<<to;\n\t\t}\n\t\tint N=n/2,nN=n-N;\n\t\t\n//\t\trep(i,n){\n//\t\t\tcout<<name[i]<<\" \";\n//\t\t\trep(j,n)cout<<((A[i]&1<<j)>>j)<<\" \";cout<<endl;\n//\t\t}\n\t\tvi dp(1<<nN);\n\t\trep(i,1<<nN){\n\t\t\tbool h=true;\n\t\t\trep(j,nN)if((i&1<<j)&&((i&A[j+N]>>N)))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,nN)if(i&1<<j)sum+=b[N+j];\n\t\t\t\tdp[i]=max(dp[i],sum);\n\t\t\t}\n\t\t\trep(j,nN)if((i&1<<j)==0)\n\t\t\t\tdp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n\t\t}\n\t\t\n\t\tint out=0;\n\t\trep(i,1<<N)if(i&1){\n\t\t\tbool h=true;\n\t\t\trep(j,N)if((i&1<<j)&&(i&A[j]))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,N)if(i&1<<j)sum+=b[j];\n\t\t\t\tt=(1<<nN)-1;\n\t\t\t\trep(j,N)if((i&1<<j))t&=~(A[j]>>N);\n\t\t\t\tout=max(out,sum+dp[t]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n/*\nint n,m;\nvi A,B;\nint dp[52][52][110][2][3];\nint mem[52][52][110][2][3];\nint f(int a,int b,int co,int tu,int pas){\n    if(mem[a][b][co][tu][pas]+inf)return mem[a][b][co][tu][pas];\n\tif(pas==3)\n\t\n    int A,B,TU=(tu+co)%2;\n    if(!tu)A=a+(1+co)/2,B=b+co/2;\n    else A=a+co/2,B=b+(1+co)/2;\n    if(TU==0){\n        int ma=-inf;\n        if(A<n)ma=max(ma,f(a,b,co+1,tu,0));\n        if(co)ma=max(ma,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else if(a+b+co)ma=max(ma,0);\n        cout<<\" \"<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<ma<<\" \"<<dp[a][b][co][tu]<<endl;\n        return mem[a][b][co][tu]=ma;\n    }else{\n        int mi=inf;\n        if(B<m)mi=min(mi,f(a,b,co+1,tu,0));\n        if(co)mi=min(mi,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else mi=min(mi,0);\n        cout<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<mi<<endl;\n        return mem[a][b][co][tu]=mi;\n    }\n}\nint main(){\n    cin>>n>>m;\n    A=vi(n);rep(i,n)cin>>A[i];\n    B=vi(m);rep(i,m)cin>>B[i];\n     \n    rep(l,2)rep(i,n+1)rep(j,m+1){\n        int sum=0;\n        int L=l,I=i,J=j;\n        int co=0;\n        while(1){\n            dp[i][j][co][l]=sum;\n            if(L&&J>=m||!L&&I>=n)break;\n            if(L){\n                if(B[J]+1)sum-=B[J];\n                else sum=0;\n                J++;\n            }else{\n                if(A[I]+1)sum+=A[I];\n                else sum=0;\n                I++;\n            }\n            L^=1;\n            co++;\n        }\n    }   \n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][0];cout<<endl;}\n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][1];cout<<endl;}\n    rep(i,52)rep(j,52)rep(k,110)rep(l,2)rep(q,3)\n        mem[i][j][k][l][q]=-inf;\n    cout<<f(0,0,0,0,1)<<endl;\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<algorithm>\n#include<iomanip>\n#include<map>\n#define rep(X,Y) for(int X=0;(X)<(Y);++X)\n#define rrep(X,Y) for(int X=(Y)-1;(X)>=0;--X)\n#define X first\n#define Y second\n#define pb push_back\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\ntypedef pair<int,pii> piii;\n\ntypedef vector<vector<int>> Graph;\n\nint usd[50],v[50],n,re,rem[50];\n\nvoid dfs(int u,Graph &g,int sum){\n  re=max(re,sum);\n  if(u==n)return;\n  if(sum+rem[u]<re)return;\n  dfs(u+1,g,sum);\n  for(int w:g[u])\n    if(usd[w])return;\n  usd[u]=1;\n  dfs(u+1,g,sum+v[u]);\n  usd[u]=0;\n}\n\nint main(){\n  while(cin>>n,n){\n    vector<string> name(n);\n    vector<vector<string>> tmp(n);\n    map<string,int> toi;\n    rep(i,n){\n      int sz;\n      cin>>name[i]>>v[i]>>sz;\n      tmp[i].resize(sz);\n      rep(j,sz)\n\tcin>>tmp[i][j];\n      toi[name[i]]=i;\n    }\n    Graph g(n);\n    rep(i,n)\n      for(string &str:tmp[i])\n\tg[i].pb(toi[str]);\n    fill(usd,usd+50,0);\n    fill(rem,rem+50,0);\n    re=0;\n    rrep(i,n)\n      rem[i]=rem[i+1]+v[i];\n    usd[0]=1;\n    dfs(1,g,v[0]);\n    cout<<re<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <cassert>\nusing namespace std;\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\n\nint dfs(vvi &neighbors,int index,vi &used,vi &b){\n\tif(index==neighbors.size()){\n\t\treturn 0;\n\t}\n\tint ret=0;\n\tREP(i,used[index]?1:2){\n\t\tvi nused(used);\n\t\tREP(j,neighbors[index].size()){\n\t\t\tnused[neighbors[index][j]]=max(nused[neighbors[index][j]],i);\n\t\t}\n\t\tret=max(ret,dfs(neighbors,index+1,nused,b)+(i?b[index]:0));\n\t}\n\treturn ret;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tvs a(n);\n\t\tvi b(n),c(n);\n\t\tvector<vector<string> > d(n);\n\t\tREP(i,n){\n\t\t\tcin>>a[i]>>b[i]>>c[i];\n\t\t\tREP(j,c[i]){\n\t\t\t\tstring dd;\n\t\t\t\tcin>>dd;\n\t\t\t\td[i].push_back(dd);\n\t\t\t}\n\t\t}\n\t\tvvi neighbors(n);\n\t\tREP(i,n){\n\t\t\tREP(j,n){\n\t\t\t\tif(find(ALL(d[i]),a[j])!=d[i].end()){\n\t\t\t\t\tneighbors[i].push_back(j);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint ans=0;\n\t\tvi used(n);\n\t\tused[0]=1;\n\t\tREP(j,neighbors[0].size()){\n\t\t\tused[neighbors[0][j]]=max(used[neighbors[0][j]],1);\n\t\t}\n\t\tans=dfs(neighbors,1,used,b)+b[0];\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\trest -= names[pos].second;\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tint rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\trest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\trest = rest1;\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tbmap.clear();\n\t\tans = 0;\n\t\tmb = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tlist.push_back(a);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tbuf.insert(make_pair(name, move(list)));\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second,mb-names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        vector<int> power(n);\n        map<string, int> mp;\n        vector<vector<string>> nearby(n);\n        for (int i = 0; i < n; ++i) {\n            string s;\n            int c;\n            cin >> s >> power[i] >> c;\n            mp[s] = i;\n            nearby[i].resize(c);\n            for (int j = 0; j < c; ++j)\n                cin >> nearby[i][j];\n        }\n        vector<long long> isnearby(n, 0LL);\n        for (int i = 0; i < n; ++i)\n            for (auto& j : nearby[i])\n                isnearby[i] |= 1LL << mp[j];\n\n        for (int i = 0; i < n; ++i)\n            if ((isnearby[0] >> i) & 1)\n                power[i] = -1000000;\n\n        int n1 = n / 2;\n        int n2 = n - n1;\n        vector<int> dp1(1 << n1, 0);\n        vector<long long> inb1(1 << n1, 0);\n        for (int i = 1; i < (1 << n1); ++i) {\n            int ma = 0;\n            for (int j = 0; j < n1; ++j) {\n                if ((i >> j) & 1) {\n                    inb1[i] |= isnearby[j];\n                    dp1[i] += power[j];\n                    ma = max(ma, dp1[i ^ (1 << j)]);\n                }\n            }\n            if (i & inb1[i])\n                dp1[i] = ma;\n        }\n        vector<int> dp2(1 << n2, 0);\n        vector<long long> inb2(1 << n2, 0);\n        for (int i = 1; i < (1 << n2); ++i) {\n            int ma = 0;\n            for (int j = 0; j < n2; ++j) {\n                if ((i >> j) & 1) {\n                    inb2[i] |= isnearby[n1 + j];\n                    dp2[i] += power[n1 + j];\n                    ma = max(ma, dp2[i ^ (1 << j)]);\n                }\n            }\n            if (i & (inb2[i] >> n1))\n                dp2[i] = ma;\n        }\n        int ans = 0;\n        int msk = (1 << n2) - 1;\n        for (int i = 1; i < (1 << n1); i += 2)\n            ans = max(ans, dp1[i] + dp2[(inb1[i] >> n1) ^ msk]);\n\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n\ninline int64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\t\n\tif(i==n)return power;\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp){\n\t\t\t\tmax = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\n//#define int long long\n\ntypedef pair<int,int>pint;\ntypedef vector<int>vint;\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(n);i++)\ntemplate<class T,class U>void chmin(T &t,U f){if(t>f)t=f;}\ntemplate<class T,class U>void chmax(T &t,U f){if(t<f)t=f;}\n\nint N;\n\nstring Name[40];\nvector<string>to[40];\nvint G[40];\nint val[40];\n\nint bef[1<<21],aft[1<<21];\nbool used[40];\nvoid solve(){\n    memset(bef,0,sizeof(bef));\n    memset(aft,0,sizeof(aft));\n    rep(i,N){\n        cin>>Name[i];\n        cin>>val[i];\n        int m;cin>>m;\n        to[i].resize(m);\n        rep(j,m)cin>>to[i][j];\n    }\n\n    rep(i,N){\n        G[i].resize(to[i].size());\n        rep(j,to[i].size()){\n            int hoge=find(Name,Name+N,to[i][j])-Name;\n            G[i][j]=hoge;\n        }\n    }\n\n    int a=N/2;\n    int b=N-a;\n\n    rep(i,1<<a){\n        if((i&1)==0)continue;\n        memset(used,0,sizeof(used));\n        bool f=true;\n        int s=0;\n        rep(j,a){\n            if((i>>j&1)==0)continue;\n            if(used[j])f=false;\n            rep(k,G[j].size())used[G[j][k]]=true;\n            s+=val[j];\n        }\n        if(f)bef[i]=s;\n    }\n\n    rep(i,1<<b){\n        memset(used,0,sizeof(used));\n        bool f=true;\n        int s=0;\n        rep(j,b){\n            if((i>>j&1)==0)continue;\n            if(used[a+j])f=false;\n            rep(k,G[a+j].size())used[G[a+j][k]]=true;\n            s+=val[a+j];\n        }\n        if(f)aft[i]=s;\n    }\n\n    rep(i,1<<b){\n        rep(j,b){\n            if((i>>j&1)==0)continue;\n            chmax(aft[i],aft[i^(1<<j)]);\n        }\n    }\n\n\n    int ans=0;\n    rep(i,1<<a){\n        if(bef[i]==0)continue;\n        memset(used,0,sizeof(used));\n        rep(j,a){\n            if(i>>j&1)rep(k,G[j].size())used[G[j][k]]=true;\n        }\n\n        int bit=(1<<b)-1;\n        for(int j=a;j<N;j++){\n            if(used[j])bit^=1<<(j-a);\n        }\n        chmax(ans,bef[i]+aft[bit]);\n    }\n    cout<<ans<<endl;\n}\n\nint main(){\n    while(scanf(\"%d\",&N),N)solve();\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing ll=long long;\nusing ld=long double;\nusing P=pair<ll,ll>;\n#define MOD 1000000007ll\n#define INF 1000000000ll\n#define EPS 1e-7\n#define FOR(i,n,m) for(ll i=n;i<(ll)m;i++)\n#define REP(i,n) FOR(i,0,n)\n#define DUMP(a) REP(d,a.size()){cout<<a[d];if(d!=a.size()-1)cout<<\" \";else cout<<endl;}\n#define ALL(v) v.begin(),v.end()\n#define UNIQUE(v) sort(v.begin(),v.end());v.erase(unique(v.begin(),v.end()),v.end());\n#define pb push_back\n\nll n;\nvector<ll> power;\nvector<bool> de;\nvector<ll> flag;\n\nvoid preorder(ll p,vector<bool>& used,vector<ll>& preo,vector<vector<ll>>& adj) {\n\tused[p]=true;\n\tpreo.pb(p);\n\tflag[p]=(ll)preo.size();\n\tbool upd=false;\n\tREP(i,(ll)adj[p].size()) if(!used[adj[p][i]]) {\n\t\tupd=true;\n\t\tpreorder(adj[p][i],used,preo,adj);\n\t}\n\tde[p]=!upd;\n}\n\nvoid input(vector<vector<ll>>& adj) {\n\tmap<string,ll> dict;\n\tll cnt=0;\n\tREP(i,n) {\n\t\tstring a;\n\t\tll b,c;\n\t\tcin>>a>>b>>c;\n\t\tif(dict.count(a)==0) {\n\t\t\tdict[a]=cnt;\n\t\t\tcnt++;\n\t\t}\n\t\tll p=dict[a];\n\t\tpower[dict[a]]=b;\n\t\tREP(j,c) {\n\t\t\tstring t;\n\t\t\tcin>>t;\n\t\t\tif(dict.count(t)==0) {\n\t\t\t\tdict[t]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tadj[p].pb(dict[t]);\n\t\t}\n\t}\n}\n\nll dfs(ll idx,vector<int>& used,vector<ll>& preo,vector<vector<ll>>& adj,ll sum,vector<vector<ll>>& ban) {\n\tif(idx==(ll)preo.size()) {\n\t\treturn sum;\n\t}\n\tif(used[preo[idx]]==0) return dfs(idx+1,used,preo,adj,sum,ban);\n\tll ret=0;\n\tif(preo[idx]!=0&&!de[preo[idx]]&&!(ll)ban[idx].size()!=0) {\n\t\tused[preo[idx]]=0;\n\t\tret=max(ret,dfs(idx+1,used,preo,adj,sum,ban));\n\t}\n\tused[preo[idx]]=1;\n\tvector<bool> buf((ll)ban[preo[idx]].size());\n\tREP(i,buf.size()) {\n\t\tbuf[i]=used[ban[preo[idx]][i]];\n\t\tused[ban[preo[idx]][i]]=0;\n\t}\n\tret=max(ret,dfs(idx+1,used,preo,adj,sum+power[preo[idx]],ban));\n\tREP(i,buf.size()) {\n\t\tused[ban[preo[idx]][i]]=buf[i];\n\t}\n\tused[preo[idx]]=-1;\n\treturn ret;\n}\n\nll solve() {\n\tpower.resize(n);\n\tde.resize(n);\n\tflag.resize(n);\n\tvector<vector<ll>> adj(n);\n\tinput(adj);\n\tvector<bool> used(n,false);\n\tvector<vector<ll>> preo;\n\tREP(i,n) if(!used[i]) {\n\t\tvector<ll> v;\n\t\tpreorder(i,used,v,adj);\n\t\tpreo.pb(v);\n\t}\n\tvector<int> used2(n,-1);\n\tll ans=0;\n\tvector<vector<ll>> ban(n);\n\tREP(i,n) REP(j,(ll)adj[i].size()) {\n\t\tif(flag[adj[i][j]]>flag[i]) ban[i].pb(adj[i][j]);\n\t};\n\tREP(i,preo.size()) ans+=dfs(0,used2,preo[i],adj,0,ban);\n\treturn ans;\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile(1) {\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcout<<solve()<<endl;\n\t}\n\treturn 0;\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 45\ntypedef long long ll;\n\nint get_node(string s, map<string, int> s2i)\n{\n    if (s2i.count(s) > 0) {\n        return s2i[s];\n    }\n    s2i[s] = s2i.size();\n    return s2i[s];\n}\n\nint N, B[MAX];\nbool ng_node[MAX];\n\nint dfs(int v, ll S, bool is_adj[MAX][MAX])\n{\n    int res = 0;\n    for (ll i = 0; i < (ll)N; i++) {\n        if ((S >> i & 1LL) || is_adj[v][i]) {\n            continue;\n        }\n        bool ok = 1;\n        for (ll j = 0; j < (ll)N; j++) {\n            if ((S >> j & 1LL) && !ng_node[j]) {\n                if (is_adj[v][j] || is_adj[i][j]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        if (ok) {\n            res = max(res, dfs(i, S|(1LL<<i), is_adj) + B[i]);   \n        }\n    }\n    return res;\n}\n\nint main()\n{\n    while (cin >> N, N) {\n        string A, D;\n        int C, sum = 0;\n        ll S = 0;      \n        vector<string> DG[MAX];\n        \n        map<string, int> s2i;\n        bool is_adj[MAX][MAX] = {{}};\n\n        memset(ng_node, 0, sizeof(ng_node));\n        \n        for (int i = 0; i < N; i++) {\n            cin >> A >> B[i] >> C;\n            s2i[A] = i;\n            for (int j = 0; j < C; j++) {\n                cin >> D;\n                DG[i].push_back(D);\n            }\n        }\n\n        for (ll i = 0; i < (ll)N; i++) {\n            int len = DG[i].size();\n            if (len == 0) {\n                for (int j = 0; j < N; j++) {\n                    is_adj[i][j] = is_adj[j][i] = 1;\n                }\n                ng_node[i] = 1;\n                sum += B[i];\n                S |= 1LL<<i;\n            }\n            for (int j = 0; j < len; j++) {\n                ll t = s2i[DG[i][j]];\n                is_adj[i][t] = is_adj[t][i] = 1;\n            }\n        }\n        \n        cout << dfs(0, S|(1LL<<0), is_adj) + B[0] + sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"O3\")\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<set>\n#include<map>\nusing namespace std;\n#define MOD 1000000007\n#define f(i,n) for(int i=0;i<int(n);i++)\n#define N 200\nint nn;\nbool u[N];\nlong long uu;\nlong long um;\nlong long p2[N];\nvector<int>e[N];\nint aa[N];\nmap<long long, int>mp3;\n\nint solve(int kk) {\n\tif (mp3[uu] != 0)return (mp3[uu]-1);\n\tint re, re2;\n\tlong long uu2 = uu;\n\tlong long uu3 = uu;\n\tlong long x = um;\n\tuu2 >>= kk;\n\tfor (int i = kk; i < nn; i++) {\n\t\tif (uu2 & 1 == 1) {\n\t\t\tif (i + 1 == nn) {\n\t\t\t\tmp3[uu] = aa[nn - 1] + 1;\n\t\t\t\treturn aa[nn - 1];\n\t\t\t}\n\t\t\tuu ^= p2[i];\n\t\t\tre = solve(i + 1);\n\t\t\tf(j, e[i].size()) {\n\t\t\t\tx ^= p2[e[i][j]];\n\t\t\t}\n\t\t\tuu &= x;\n\t\t\tre2 = solve(i + 1);\n\t\t\tuu = uu3;\n\t\t\tmp3[uu] = max(re2 + aa[i], re) + 1;\n\t\t\treturn max(re2 + aa[i], re);\n\t\t}\n\t\tuu2 >>= 1;\n\t}\n\tmp3[uu] = 1;\n\treturn 0;\n}\n\n\nint main() {\n\tvector<char>c[100];\n\tchar cc[20];\n\tmap<vector<char>, int>mp;\n\tmap<int, int>mp2;\n\tvector<vector<char> >ab[N];\n\tvector<char>abb;\n\tvector<int>ed[N];\n\tint uuuse[N];\n\tbool used[N];\n\tvector<int>use;\n\tqueue<int>q;\n\tint a[N];\n\tf(i, N)a[i] = 0;\n\tint n, k;\n\tint x, y, z;\n\tint s, ans;\n\tbool v = true;\n\tans = 0;\n\tp2[0] = 1;\n\tf(i, 40)p2[i + 1] = p2[i] * 2;\n\twhile (true) {\n\t\tmp.clear();\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)return 0;\n\t\tf(i, n) {\n\t\t\tf(j, 20)cc[j] = 0;\n\t\t\tscanf(\"%s\", cc);\n\t\t\tx = strlen(cc);\n\t\t\tc[i].clear();\n\t\t\tf(j, x)c[i].push_back(cc[j]);\n\t\t\tmp[c[i]] = i;\n\t\t\tscanf(\"%d\", &a[i]);\n\t\t\tif (i == 0)ans = a[i];\n\t\t\tscanf(\"%d\", &k);\n\t\t\tab[i].clear();\n\t\t\tf(ii, k) {\n\t\t\t\tf(j, 20)cc[j] = 0;\n\t\t\t\tscanf(\"%s\", cc);\n\t\t\t\tx = strlen(cc);\n\t\t\t\tabb.clear();\n\t\t\t\tf(j, x)abb.push_back(cc[j]);\n\t\t\t\tab[i].push_back(abb);\n\t\t\t}\n\t\t}\n\t\tf(i, n)uuuse[i] = 1000000;\n\t\tuuuse[0] = -1;\n\t\tfor (int i = 1; i < n; i++) {\n\t\t\tf(j, ab[i].size()) {\n\t\t\t\tx = mp[ab[i][j]];\n\t\t\t\tif (x == 0)uuuse[i] = -1;\n\t\t\t}\n\t\t}\n\t\tx = 0;\n\t\tf(i, n) {\n\t\t\tif (uuuse[i] >= 0) {\n\t\t\t\tuuuse[i] = x;\n\t\t\t\ta[x] = a[i];\n\t\t\t\tx++;\n\t\t\t}\n\t\t}\n\t\tk = x;\n\t\tf(i, n) {\n\t\t\tif (uuuse[i] >= 0) {\n\t\t\t\ted[uuuse[i]].clear();\n\t\t\t\tf(j, ab[i].size()) {\n\t\t\t\t\tx = mp[ab[i][j]];\n\t\t\t\t\tif (uuuse[x] >= 0) {\n\t\t\t\t\t\ted[uuuse[i]].push_back(uuuse[x]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tn = k;\n\t\tf(i, n)used[i] = false;\n\t\tf(i, n) {\n\t\t\tif (!used[i]) {\n\t\t\t\tuse.clear();\n\t\t\t\tmp2.clear();\n\t\t\t\tx = 0;\n\t\t\t\tuse.push_back(i);\n\t\t\t\tused[i] = true;\n\t\t\t\twhile (x < use.size()) {\n\t\t\t\t\tmp2[use[x]] = x;\n\t\t\t\t\taa[x] = a[use[x]];\n\t\t\t\t\tf(j, ed[use[x]].size()) {\n\t\t\t\t\t\tif (!used[ed[use[x]][j]]) {\n\t\t\t\t\t\t\tuse.push_back(ed[use[x]][j]);\n\t\t\t\t\t\t\tused[ed[use[x]][j]] = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tx++;\n\t\t\t\t}\n\t\t\t\tf(ii, use.size()) {\n\t\t\t\t\te[ii].clear();\n\t\t\t\t\tf(j, ed[use[ii]].size()) {\n\t\t\t\t\t\tif (ii < mp2[ed[use[ii]][j]])e[ii].push_back(mp2[ed[use[ii]][j]]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tuu = 0;\n\t\t\t\tum = 0;\n\t\t\t\tnn = use.size();\n\t\t\t\tf(ii, N)u[ii] = false;\n\t\t\t\tf(ii, nn) {\n\t\t\t\t\tuu += p2[ii];\n\t\t\t\t\tum += p2[ii];\n\t\t\t\t\tu[ii] = true;\n\t\t\t\t}\n\t\t\t\tmp3.clear();\n\t\t\t\tx = solve(0);\n\t\t\t\tans += x;\n\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int>& f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tid[t] = id.size();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\nint max_f;\nvoid dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t{\n\t\tmax_swap(max_f, sum);\n\t\treturn;\n\t}\n\n\t{\n\t\tint rem = 0;\n\t\tfor (int i = d; i < m; ++i)\n\t\t\tif (!(enemy >> i & 1))\n\t\t\t\trem += force[i];\n\t\tif (sum + rem < max_f)\n\t\t\treturn;\n\t}\n\n\tif (!(enemy >> d & 1))\n\t\tdfs(d + 1, enemy | on[d], sum + force[d]);\n\tdfs(d + 1, enemy, sum);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t\tid[a] = id.size();\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t\tid[d] = id.size();\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\t\tcout << -1 << endl;\n\t\tcontinue;\n\t\t//n = 40;\n\t\t//g = vector<vector<int> >(n);\n\t\t//f = vector<int>(n);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//{\n\t\t//\tf[i] = 3333;\n\t\t//\tif (i + 1 != n)\n\t\t//\t\tg[i].push_back(i + 1);\n\t\t//}\n\n\n\t\tint res;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tmax_f = 0;\n\t\tdfs(1, on[0], force[0]);\n\t\tres = max_f;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tmax_f = 0;\n\t\t\t\tdfs(0, 0, 0);\n\t\t\t\tres += max_f;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nmap<string, int> idx;\nint B[40];\nbool NG[40][40];\nint dp1[1 << 20];\nint dp2[1 << 20];\nint main() {\n\tint N;\n\twhile (cin >> N, N) {\n\t\tmemset(NG, 0, sizeof(NG));\n\t\tmemset(dp1, 0, sizeof(dp1));\n\t\tmemset(dp2, 0, sizeof(dp2));\n\t\tidx.clear();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring A;\n\t\t\tcin >> A;\n\t\t\tif (idx.find(A) == idx.end()) idx[A] = cnt++;\n\t\t\tcin >> B[idx[A]];\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tstring D;\n\t\t\t\tcin >> D;\n\t\t\t\tif (idx.find(D) == idx.end()) idx[D] = cnt++;\n\t\t\t\tNG[idx[A]][idx[D]] = 1;\n\t\t\t}\n\t\t}\n\t\tint x = N / 2;\n\t\tint y = N - x;\n\t\tfor (int i = 1; i < (1 << x); i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint bit = 0;\n\t\t\t\tfor (int k = 0; k < x; k++) {\n\t\t\t\t\tif (j != k && !NG[j][k]) bit |= (1 << k);\n\t\t\t\t}\n\t\t\t\tdp1[i] = max(dp1[i], dp1[i ^ (1 << j)]);\n\t\t\t\tdp1[i] = max(dp1[i], dp1[i&bit] + B[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < (1 << y); i++) {\n\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint bit = 0;\n\t\t\t\tfor (int k = 0; k < y; k++) {\n\t\t\t\t\tif (j != k && !NG[j + x][k + x]) bit |= (1 << k);\n\t\t\t\t}\n\t\t\t\tdp2[i] = max(dp2[i], dp2[i ^ (1 << j)]);\n\t\t\t\tdp2[i] = max(dp2[i], dp2[i&bit] + B[j + x]);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint mask = 1;\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\tif (!NG[0][i]) mask |= (1 << i);\n\t\t}\n\t\tfor (int i = 1; i < (1 << x); i++) {\n\t\t\tint bit = (1 << y) - 1;\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\tfor (int k = 0; k < y; k++) {\n\t\t\t\t\tif (!NG[j][k + x]) tmp |= (1 << k);\n\t\t\t\t}\n\t\t\t\tbit &= tmp;\n\t\t\t}\n\t\t\tans = max(ans, dp1[i&mask] + dp2[bit]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n;\nint main(){\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs name(n);\n\t\tvi b(n),co(n);\n\t\tvector<vs>in(n);\n\t\trep(i,n){\n\t\t\tcin>>name[i]>>b[i]>>co[i];\n\t\t\tma[name[i]]=1;\n\t\t\tin[i]=vs(co[i]);\n\t\t\trep(j,co[i]){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tma[in[i][j]]=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\tfor(auto it=ma.begin();it!=ma.end();it++)\n\t\t\tit->second=t++;\n\t\t\n\t\tint cost[41][41]={0};\n\t\trep(i,n)rep(j,in[i].size()){\n\t\t\tint from=ma[name[i]],to=ma[in[i][j]];\n\t\t\tcost[from][to]=cost[to][from]=1;\n\t\t}\n\t\tint N=n/2,nN=n-N;\n\t\tvi dp(1<<nN);\n\t\trep(i,1<<nN){\n\t\t\tbool h=true;\n\t\t\trep(j,nN)loop(k,j+1,nN)if((i&1<<j)&&(i&1<<k)&&cost[ma[name[N+j]]][ma[name[N+k]]])h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,nN)if(i&1<<j)sum+=b[N+j];\n\t\t\t\tdp[i]=sum;\n\t\t\t}\n\t\t}\n\t\trep(i,1<<nN)rep(j,nN)if((i&1<<j)==0)\n\t\t\tdp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n\t\t\n\t\tint out=0;\n\t\trep(i,1<<N)if(i&1){\n\t\t\tbool h=true;\n\t\t\trep(j,N)loop(k,j+1,N)if((i&1<<j)&&(i&1<<k)&&cost[ma[name[j]]][ma[name[k]]])h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,N)if(i&1<<j)sum+=b[j];\n\t\t\t\tt=(1<<nN)-1;\n\t\t\t\trep(j,N)if(i&1<<j)rep(k,nN)if((t&1<<k)&&cost[ma[name[j]]][ma[name[N+k]]])t^=1<<k;\n\t\t\t\tout=max(out,sum+dp[t]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n#include<cassert>\n#include<sstream>\n#include<complex>\n#include<cstdio>\n#include<climits>\n#include<cstdlib>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<ctime>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps) \n#define MAX 40\nusing namespace std;\ntypedef long long ll;\n\nvector<int> G[MAX];\nint N,power[MAX],maxcost,total_cost;\n\nvoid dfs(int cur,int cost,bool *color,int colored,int remain_cost)\n{\n  if(colored == N)\n    {\n      maxcost = max(maxcost,cost);\n      return;\n    }\n\n  if(cost+remain_cost <= maxcost)return;\n\n  REP(next,cur+1,N)\n    {\n      if(color[next])continue;\n      bool next_color[N];\n      int next_colored = colored;\n      int next_remain_cost = remain_cost;\n      next_remain_cost -= power[next];\n      rep(j,N)next_color[j] = color[j];\n      next_color[next] = true;\n      next_colored++;\n      rep(j,G[next].size())\n\t{\n\t  if(!next_color[G[next][j]])\n\t    {\n\t      next_remain_cost -= power[G[next][j]];\n\t      next_color[G[next][j]] = true;\n\t      next_colored++;\n\t    }\n\t}\n      dfs(next,cost+power[next],next_color,next_colored,next_remain_cost);\n      if(remain_cost+cost <= maxcost)return;\n    }\n\n}\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      maxcost = -inf;\n      rep(i,N)G[i].clear();\n      map<string,int> getIndex;\n      int cnt = 0,C;\n      total_cost = 0;\n      string A,D;\n      vector<int> B(N);\n      vector<string> name_list;\n      rep(i,N)\n\t{\n\t  cin >> A >> B[i] >> C;\n\t  total_cost += B[i];\n\t  if(getIndex.find(A) == getIndex.end())getIndex[A] = cnt++;\n\t  int from = getIndex[A];\n\t  name_list.push_back(A);\n\t  rep(j,C)\n\t    {\n\t      cin >> D;\n\t      if(getIndex.find(D) == getIndex.end())getIndex[D] = cnt++;\n\t      int to = getIndex[D];\n\t      G[from].push_back(to);\n\t    }\n\t} \n\n      rep(i,N)power[getIndex[name_list[i]]] = B[i];\n\n      assert(cnt == N);\n      bool color[N];\n      int colored = 0;\n      rep(i,N)color[i] = false;\n      color[0] = true;\n      colored++;\n      total_cost -= power[0];\n      rep(i,G[0].size())\n\t{\n\t  colored++;\n\t  color[G[0][i]] = true;\n\t  total_cost -= power[G[0][i]];\n\t}\n\n      dfs(0,power[0],color,colored,total_cost);\n\n      cout << maxcost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9;\nint n, b[100], c[100], dp1[1 << 20], dp2[1 << 20], sum[1 << 20];\nstring name[100], d[100][100];\nbool e[100][100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(e, 0, sizeof(e));\n\t\tmap<string, int> id;\n\t\t\n\t\trep(i, n){\n\t\t\tcin >> name[i] >> b[i] >> c[i];\n\t\t\trep(j, c[i]) cin >> d[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, c[i]) e[i][id[d[i][j]]] = e[id[d[i][j]]][i] = 1;\n\t\t\n\t\tint N = n / 2, M = n - N;\n\t\trep(i, 1 << N) dp1[i] = -inf;\n\t\trep(i, 1 << M) dp2[i] = -inf, sum[i] = 0;\n\t\tdp1[1] = b[0]; dp2[0] = 0;\n\t\t\n\t\trep(i, 1 << N) if(dp1[i] != -inf) rep(j, N) if(!(i & 1 << j)){\n\t\t\tif(dp1[i | 1 << j] != -inf) continue;\n\t\t\trep(k, N) if((i & 1 << k) && e[j][k]) goto FAIL;\n\t\t\tdp1[i | 1 << j] = dp1[i] + b[j];\n\t\t\tFAIL:;\n\t\t}\n\t\t\n\t\trep(i, 1 << M) if(dp2[i] != -inf) rep(j, M) if(!(i & 1 << j)){\n\t\t\tif(dp2[i | 1 << j] != -inf) continue;\n\t\t\trep(k, M) if((i & 1 << k) && e[j + N][k + N]) goto FAIL2;\n\t\t\tdp2[i | 1 << j] = dp2[i] + b[j + N];\n\t\t\tFAIL2:;\n\t\t}\n\t\t\n\t\trep(i, 1 << M) rep(j, M) if(i & 1 << j)\n\t\t\tdp2[i] = max(dp2[i], dp2[i ^ 1 << j]);\n\t\t\n\t\tint ans = 0;\n\t\trep(i, 1 << N){\n\t\t\tint can = (1 << M) - 1;\n\t\t\trep(j, N) if(i & 1 << j) rep(k, M) if(e[j][k + N])\n\t\t\tcan &= ~(1 << k);\n\t\t\t\n\t\t\tans = max(ans, dp1[i] + dp2[can]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41], wes[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n  if(wsum + wes[N-1] - (curr ? wes[curr] : 0) <= ans) return;\n  if(curr == N-1) {\n    ans = max(ans, wsum);\n    return;\n  }\n  const int next = curr + 1;\n  dfs(S, wsum, next);\n  rep(k, next) if(adjacent[next][k] && (S >> k & 1)) return;\n  dfs(S|(1LL<<next), wsum + weight[next], next);\n}\n\nint main() {\n\n  while(cin >> N && N) {\n    rep(i, 41) weight[i] = 0;\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(i, N) {\n      string s; cin >> s;\n      if(id.find(s) == id.end()) id[s] = v++;\n      cin >> weight[id[s]];\n      int n; cin >> n;\n      rep(_, n) {\n        string t; cin >> t;\n        if(id.find(t) == id.end()) id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) wes[i] = weight[i] + (i ? wes[i-1] : 0);\n\n    ans = 0;\n    dfs(1LL<<0, weight[0], 0);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\n\nint main(){\n    cin >> n;\n    while(n){\n        map<string,int> mp;\n        vector<i64> edges(n + 10,0);\n        vector<int> x(n + 10,0);\n\n        auto get_i = [&](string& s){\n            if(mp.count(s)){\n                return  mp[s];\n            }\n            else{\n                mp[s] = mp.size();\n                return (int)mp.size() - 1;\n            }\n        };\n\n        for(int c = 0;c < n;c++){\n            string s;cin >> s;\n            int i = get_i(s);\n            int C;\n            cin >> x[i] >> C;\n            for(int d = 0;d < C;d++){\n                cin >> s;\n                edges[i] |= (1LL << get_i(s));\n            }\n        }\n\n        vector<int> sum(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        int result = 0;\n        function<void(i64,i64,int)> dfs = [&](int i,i64 bit,int now_sum){\n            result = max(result , now_sum);\n            if(i == n) return;\n            //枝刈り\n            if(now_sum + sum[i] <= result) return;\n            //throw\n            dfs(i + 1,bit,now_sum);\n\n            if(!(bit & edges[i])) dfs(i + 1,bit | (1LL << i),now_sum + x[i]);\n        };\n        dfs(1,1,x[0]);\n        cout << result;\n        cin >> n;\n        if(n) cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n//#include<cctype>\n#include<climits>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n//#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n//#include<numeric>\n#include<utility>\n//#include<memory>\n#include<functional>\n#include<cassert>\n#include<set>\n#include<stack>\n#include<random>\n\nconst int dx[] = {1, 0, -1, 0};\nconst int dy[] = {0, 1, 0, -1};\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<ll> vll;\ntypedef pair<int, int> pii;\n\nconst int MAXN = 50;\n// input ????????????\nstring A[MAXN], D[MAXN][MAXN];\nint B[MAXN], C[MAXN];\nint N;\n\n// ?????¨?????????????????±\nint strength[MAXN];\nbool G[MAXN][MAXN];\n\nll memo[MAXN];\nint dp1[1<<21], dp2[1<<21];\n\n// s ???????????????????????¨???????????£????????????????????????????????§???\nint dfs1(int s) {\n\tint& ret = dp1[s];\n\tif (ret >= 0) return ret;\n\tret = 0;\n\tint n = N/2;\n\tfor (int i = 0; i < n; i++) {\n\t\tif ((s>>i)&1) {\n\t\t\t// i ????????£?????????\n\t\t\tint tmp = strength[i];\n\t\t\tint ns = (int)(((ll)s)&memo[i]);\n\t\t\ttmp += dfs1(ns);\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint dfs2(int s) {\n\tint& ret = dp2[s];\n\tif (ret >= 0) return ret;\n\tret = 0;\n\tint n = N/2, n1 = N-n;\n\tfor (int i = 0; i < n1; i++) {\n\t\tif ((s>>i)&1) {\n\t\t\t// i ????????£?????????\n\t\t\tint tmp = strength[i+n];\n\t\t\tint ns = (int)((ll)s & (memo[i]>>n));\n\t\t\ttmp += dfs2(ns);\n\t\t\tret = max(ret, tmp);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while (cin >> N) {\n    \tif (N==0) break;\n    \tmap<string, int> mp;\n    \tfor (int i = 0; i < N; i++) {\n    \t\tcin >> A[i] >> B[i] >> C[i];\n    \t\tmp[A[i]] = 0;\n    \t\tfor (int j = 0; j < C[i]; j++) {\n    \t\t\tcin >> D[i][j];\n    \t\t}\n    \t}\n    \t{\n    \t\tint k = 0;\n    \t\tfor (auto& p : mp) \n    \t\t\tp.second = k++;\n    \t}\n    \t// ?????±????????¨??????????????????\n    \tfor (int i = 0; i < N; i++) \n    \t\tstrength[mp[A[i]]] = B[i];\n    \t// ??°??????????????????\n    \tmemset(G, false, sizeof(G));\n    \tfor (int i = 0; i < N; i++) {\n    \t\tint v = mp[A[i]];\n    \t\tG[v][v] = true;\n    \t\tfor (int j = 0; j < C[i]; j++) {\n    \t\t\tint u = mp[D[i][j]];\n    \t\t\tG[v][u] = true;\n    \t\t}\n    \t}\n    \t// ?¨???????????????¨\n    \tfor (int i = 0; i < N; i++) {\n    \t\tll tmp = 0;\n    \t\tfor (int j = 0; j < N; j++) {\n    \t\t\tif (G[i][j]) tmp |= 1ll<<j;\n    \t\t}\n    \t\ttmp = ((1ll<<55)-1)^tmp;\n    \t\tmemo[i] = tmp;\n    \t}\n    \tif (N==1) {\n    \t\tcout << strength[0] << endl;\n    \t\tcontinue;\n    \t}\n    \t// ????????¨??????\n    \tmemset(dp1, -1, sizeof(dp1));\n    \tmemset(dp2, -1, sizeof(dp2));\n    \tint n = N/2, n1 = N-n;\n    \tint v = mp[A[0]];\n    \tint ans = 0;\n    \tfor (int s = 0; s < 1<<n; s++) {\n    \t\tbool ng = false;\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tif (G[v][i] && ((s>>i)&1)) ng = true;\n    \t\t}\n    \t\tif (v < n && ((s>>v)&1)) ng = true;\n    \t\tif (ng) continue;\n    \t\tll flag = (1ll<<N)-1;\n    \t\tfor (int i = 0; i < n; i++) {\n    \t\t\tif ((s>>i)&1) {\n    \t\t\t\tflag &= memo[i];\n    \t\t\t}\n    \t\t}\n    \t\tflag &= memo[v];\n    \t\tint ns = (int)(flag>>n);\n    \t\tans = max(ans, strength[v]+dfs1(s)+dfs2(ns));\n    \t}\n    \tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long LL;\nmap<string, int> idx;\nint B[40];\nbool NG[40][40];\nint dp1[1 << 20];\nint dp2[1 << 20];\nint main() {\n\tint N;\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\twhile (cin >> N, N) {\n\t\tmemset(NG, 0, sizeof(NG));\n\t\tmemset(dp1, 0, sizeof(dp1));\n\t\tmemset(dp2, 0, sizeof(dp2));\n\t\tidx.clear();\n\t\tint cnt = 0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tstring A;\n\t\t\tcin >> A;\n\t\t\tif (idx.find(A) == idx.end()) idx[A] = cnt++;\n\t\t\tcin >> B[idx[A]];\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tfor (int j = 0; j < C; j++) {\n\t\t\t\tstring D;\n\t\t\t\tcin >> D;\n\t\t\t\tif (idx.find(D) == idx.end()) idx[D] = cnt++;\n\t\t\t\tNG[idx[A]][idx[D]] = 1;\n\t\t\t}\n\t\t}\n\t\tint x = N / 2;\n\t\tint y = N - x;\n\t\tfor (int i = 1; i < (1 << x); i++) {\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint bit = 0;\n\t\t\t\tfor (int k = 0; k < x; k++) {\n\t\t\t\t\tif (j != k && !NG[j][k]) bit |= (1 << k);\n\t\t\t\t}\n\t\t\t\tdp1[i] = max(dp1[i], dp1[i ^ (1 << j)]);\n\t\t\t\tdp1[i] = max(dp1[i], dp1[i&bit] + B[j]);\n\t\t\t}\n\t\t}\n\t\tfor (int i = 1; i < (1 << y); i++) {\n\t\t\tfor (int j = 0; j < y; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint bit = 0;\n\t\t\t\tfor (int k = 0; k < y; k++) {\n\t\t\t\t\tif (j != k && !NG[j + x][k + x]) bit |= (1 << k);\n\t\t\t\t}\n\t\t\t\tdp2[i] = max(dp2[i], dp2[i ^ (1 << j)]);\n\t\t\t\tdp2[i] = max(dp2[i], dp2[i&bit] + B[j + x]);\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tint mask = 1;\n\t\tfor (int i = 1; i < x; i++) {\n\t\t\tif (!NG[0][i]) mask |= (1 << i);\n\t\t}\n\t\tfor (int i = 1; i < (1 << x); i++) {\n\t\t\tint bit = (1 << y) - 1;\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tif (!(i&(1 << j))) continue;\n\t\t\t\tint tmp = 0;\n\t\t\t\tfor (int k = 0; k < y; k++) {\n\t\t\t\t\tif (!NG[j][k + x]) tmp |= (1 << k);\n\t\t\t\t}\n\t\t\t\tbit &= tmp;\n\t\t\t}\n\t\t\tans = max(ans, dp1[i&mask] + dp2[bit]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (int)(k); i < (int)(n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint n, t, ans;\nmap<string, int> mp;\nvi power;\nvector<vi> es;\nvi sum;\n\nvoid solve(int i, ll team, int sumpow)\n{\n\tif (i == t)\n\t{\n\t\tchmax(ans, sumpow);\n\t\treturn;\n\t}\n\tif (sumpow + sum[t] - sum[i] <= ans) return;\n\tbool f = true;\n\tfor (auto k:es[i])\n\t{\n\t\tif ((team >> k) & 1)\n\t\t{\n\t\t\tf = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (f) solve(i + 1, team | (1ll << i), sumpow + power[i]);\n\tsolve(i + 1, team, sumpow);\n}\n\nint main()\n{\n\tcin.sync_with_stdio(false);\n\twhile (cin >> n, n)\n\t{\n\t\tans = 0;\n\t\tmp.clear(); power.resize(n); es.resize(n); sum.resize(n+1);\n\t\tt = 0;\n\t\tREP(i, n)\n\t\t{\n\t\t\tstring s; cin >> s;\n\t\t\tif (!mp.count(s)) mp[s] = t++;\n\t\t\tint tmp = mp[s];\n\t\t\tint p; cin >> p;\n\t\t\tpower[tmp] = p;\n\t\t\tint m; cin >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring a; cin >> a;\t\t\t\n\t\t\t\tif (!mp.count(a)) mp[a] = t++;\n\t\t\t\tint op = mp[a];\n\t\t\t\tes[tmp].push_back(op);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) sum[i + 1] = sum[i] + power[i];\n\t\tsolve(1, 1, power[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41], wes[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n  if(wsum + wes[N-1] - (curr ? wes[curr-1] : 0) <= ans) return;\n  if(curr == N-1) {\n    ans = max(ans, wsum);\n    return;\n  }\n  const int next = curr + 1;\n  dfs(S, wsum, next);\n  rep(k, next) if(adjacent[next][k] && (S >> k & 1)) return;\n  dfs(S|(1LL<<next), wsum + weight[next], next);\n}\n\nint main() {\n\n  while(cin >> N && N) {\n    rep(i, 41) weight[i] = 0;\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(i, N) {\n      string s; cin >> s;\n      if(id.find(s) == id.end()) id[s] = v++;\n      cin >> weight[id[s]];\n      int n; cin >> n;\n      rep(_, n) {\n        string t; cin >> t;\n        if(id.find(t) == id.end()) id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) wes[i] = weight[i] + (i ? wes[i-1] : 0);\n\n    ans = 0;\n    dfs(1LL<<0, weight[0], 0);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//#include\"bits/stdc++.h\"\n\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<unordered_map>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = (1 << 20) + 1;\nint cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\nbool E[41][41];\nstring A[41];\nint B[41];\nint C[41];\nstring D[41][41];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tmemset(E, 0, sizeof(E));\n\n\t\tunordered_map<string, int> id;\n        int idx = 0;\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n            id[A[i]] = idx++;\n\t\t}\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << B[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\t\t\tmemset(cost, 0, sizeof(cost));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (!indx[mask]) {\n\t\t\t\t\trep(i, 0, n) {\n                        if (!((mask >> i) & 1)) {\n                            indx[mask | (1 << i)] = false;\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (!indy[mask]) {\n\t\t\t\t\trep(i, 0, N - n) {\n                        if (!((mask >> i) & 1)) {\n                            indy[mask | (1 << i)] = false;\n                        }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[mask | (1 << i)] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tx -= dp[mask];\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nint pw[50],N;\n\nclass UnionFind {\npublic:\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nclass Edge\n{\npublic:\n\tint src, dst;\n\tEdge(int src, int dst)\n\t:src(src),dst(dst)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nll paint[40], rest[40];\nll relt;\n\nll dfs(int p, ll used, ll score, Graph& g, vector<int>& group)\n{\t\n\tif(p==group.size()) return score;\n\tif(used >> group[p] & 1) return dfs(p+1, used, score, g, group);\n\tif(score + rest[group[p]] <= relt) return 0;\n\n\tll res = score;\n\tll tmp = used | paint[group[p]];\n\tres = max(res, dfs(p+1, tmp, score+pw[group[p]], g, group));\n\tres = max(res, dfs(p+1, used, score, g, group));\n\t\n\trelt = max(res, relt);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> N, N) {\n\t\tmemset(rest, 0, sizeof(rest));\n\n\t\tint gcnt = 0;\n\t\tmap<string, int> dic;\n\t\tGraph graph(N);\n\t\tUnionFind uf(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tstring src;\n\t\t\tcin >> src;\n\n\t\t\tif(!dic.count(src)) dic[src] = gcnt++;\n\t\t\tint s = dic[src];\n\n\t\t\tcin >> pw[s];\n\t\n\t\t\tint M;\n\t\t\tcin >> M;\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++) {\n\t\t\t\tstring dst;\n\t\t\t\tcin >> dst;\n\t\t\t\t\n\t\t\t\tif(!dic.count(dst)) dic[dst] = gcnt++;\n\t\t\t\tint t = dic[dst];\n\n\t\t\t\tgraph[s].push_back(Edge(s,t));\n\t\t\t\tuf.unionSet(s,t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tpaint[i] = (1LL << i);\n\t\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\t\tpaint[i] |= (1LL << graph[i][j].dst);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > groups(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tgroups[uf.root(i)].push_back(i);\n\t\t\trest[uf.root(i)] += pw[i];\n\t\t}\n\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tfor(int j=1; j<groups[i].size(); j++) {\n\t\t\t\trest[groups[i][j]] = rest[groups[i][j-1]] - pw[groups[i][j-1]];\n\t\t\t}\n\t\t} \n\n\t\tll res = pw[0];\n\t\tll init = paint[0];\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tif(groups[i].size() == 0) continue;\n\t\t\trelt = 0;\n\t\t\tres += dfs(0, init, 0, graph, groups[i]);\n\t\t} \n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_N 41\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Country{\n  int index,power;\n  Country(int index=IINF,int power=IINF):index(index),power(power){}\n  bool operator < (const Country& c)const{ return power > c.power; }\n};\n\nint N,answer,V,sum[MAX_N];\null adj_bitmask[MAX_N],initial_bitmask;\nCountry c_list[MAX_N];\nmap<int,string> debug;\n\ninline void input(){\n  V = 0;\n  initial_bitmask = 1;\n  int dex = 0,i_tmp;\n  map<string,int> getIndex;\n  set<string> ban;\n  string s_tmp;\n  rep(i,N){\n    cin >> s_tmp >> i_tmp;\n    if( ban.find(s_tmp) != ban.end() ){\n      cin >> i_tmp;\n      rep(i,i_tmp)cin>>s_tmp;\n      continue;\n    }\n    if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n    int from = getIndex[s_tmp];\n    debug[from] = s_tmp;\n    if( from == 0 ) answer = i_tmp;\n    c_list[from] = Country(from,i_tmp);\n    adj_bitmask[from] = 0ULL;\n    cin >> i_tmp;\n    rep(j,i_tmp){\n      cin >> s_tmp;\n      if( from == 0 ){\n\tban.insert(s_tmp);\n\tcontinue;\n      }\n      if( ban.find(s_tmp) != ban.end() ) continue;\n      if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n      int to = getIndex[s_tmp];\n      adj_bitmask[from] |= (1<<to);\n    }\n  }\n  V = dex;\n}\n\nvoid dfs(int sp,int power,ull bitmask){\n\n  //if( power + sum[sp] <= answer ) return;\n  answer = max(answer,power);\n  if( sp >= V ) return;\n   \n  REP(i,sp,V){\n    if( (bitmask>>c_list[i].index) & 1 ) continue;\n    if( bitmask & adj_bitmask[c_list[i].index] ) continue;\n    dfs(i+1,power+c_list[i].power,bitmask|adj_bitmask[c_list[i].index]);\n    break;\n  }\n\n}\n\nint main(){\n  while(cin>>N,N){\n    input();\n    sort(c_list,c_list+V);\n    rep(i,V)sum[i] = 0;\n    sum[V-1] = c_list[V-1].power;\n    for(int i=V-2;i>=0;i--) sum[i] = sum[i+1] + c_list[i].power;\n\n    dfs(0,answer,initial_bitmask);\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint r[64], p[64];\nInt f[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nvoid prepare(vector<int>& q) {\n    const int n = q.size();\n    sort(q.begin(), q.end());\n    rep (i, n) r[i] = q[i], p[i] = B[q[i]];\n    rep (i, n) {\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nint rec(int n, int k, Int u) {\n    if (k == n) return 0;\n    rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return -INF;\n    int ans = -INF;\n    if (u&(1LL<<k)) ans = max(ans, rec(n, k+1, u&((1LL<<n)-1-f[k])) + p[k]);\n    if (r[k]) ans = max(ans, rec(n, k+1, u));\n    return ans;\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        ans += rec(q.size(), 0, (1LL<<q.size())-1);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#include\"bits/stdc++.h\"\n\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = 1 << 21;\nint cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nbool E[41][41];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tmemset(E, 0, sizeof(E));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << B[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[mask | (1 << i)] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tx -= dp[mask];\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<int> DD[41];\nHmap<string, int> hm;\n\nvector<ll> dp0(1<<20);\nvector<ll> dp1(1<<20);\n\nint masks[1<<20];\n\nvoid calc (vl& dp, int s, int e) {\n  int l = e - s;\n  rep(mask, 1 << l) {\n    rep(i, l) {\n      if(mask & (1<<i)) continue;\n      bool f = true;\n      for(const auto& t: DD[i+s]) {\n\tif(s <= t && t < e) {\n\t  if(mask&(1<<(t - s))) f = false;\n\t}\n      }\n      if(f) {\n\tint nxt = mask | (1<<i);\n\tdp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n      }\n    }\n  }\n  rep(mask, 1<<l) {\n    rep(i, l) {\n      if(mask&(1<<i)) {\n\tint pre = mask - (1<<i);\n\tdp[mask] = max(dp[mask], dp[pre]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    hm.clear();\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    rep(i, n) {\n      DD[i].resize(D[i].size());\n      rep(j, D[i].size()) {\n\tDD[i][j] = hm[D[i][j]];\n      }\n    }\n    rep(i, 1<<20) dp0[i] = 0;\n    rep(i, 1<<20) dp1[i] = 0;\n    \n    calc(dp0, 0, n/2);\n    calc(dp1, n/2, n);\n\n    int len = n - (n/2);\n    rep(i, 1<<(n+1)/2) masks[i] = (1<<len)-1;\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tfor(const auto& tt : DD[i]) {\n\t  int t = tt - n / 2;\n\t  if(t < 0) continue;\n\t  if(masks[mask] & (1<<t)) masks[mask] -= (1<<t);\n\t}\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp0[mask] + dp1[masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX 45\ntypedef long long ll;\n  \nint N, B[MAX], sum[MAX], mx;\nbool ng_node[MAX], is_adj[MAX][MAX];\n\nvoid dfs(ll v, int strength, ll S)\n{\n    mx = max(mx, strength);\n    if (v == N) {\n        return;\n    }   \n    \n    if (sum[v] + strength <= mx) {\n        return;\n    }\n    \n    dfs(v+1, strength, S);\n    if (!(S >> v & 1) && !is_adj[0][v]) {\n        bool ok = 1;\n        for (ll i = 0; i < (ll)N; i++) {\n            if (S >> i & 1LL) {\n                if (is_adj[i][v]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        if (ok) {           \n            dfs(v+1, strength + B[v], S|(1LL<<v));\n        }\n    }\n}\n  \nint main()\n{\n    while (cin >> N, N) {\n        string A, D;\n        int C;\n        vector<string> DG[MAX];          \n        map<string, int> s2i;\n        \n        memset(is_adj, 0, sizeof(is_adj));\n        \n        for (int i = 0; i < N; i++) {\n            cin >> A >> B[i] >> C;\n            s2i[A] = i;\n            for (int j = 0; j < C; j++) {\n                cin >> D;\n                DG[i].push_back(D);\n            }\n        }\n        \n        sum[N-1] = B[N-1];\n        for (int i = N-2; i >= 0; i--) {\n            sum[i] = sum[i+1] + B[i];\n        }\n        \n        for (ll i = 0; i < (ll)N; i++) {\n            int len = DG[i].size();\n            for (int j = 0; j < len; j++) {\n                ll t = s2i[DG[i][j]];\n                is_adj[i][t] = is_adj[t][i] = 1;\n            }\n        }\n        mx = 0;\n        dfs(1, B[0], 1LL<<0);\n        cout << mx << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nint pw[50],N;\n\nclass UnionFind {\npublic:\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nclass Edge\n{\npublic:\n\tint src, dst;\n\tEdge(int src, int dst)\n\t:src(src),dst(dst)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nll paint[40], rest[40];\nll relt;\n\nll dfs(int p, ll used, ll score, Graph& g, vector<int>& group)\n{\t\n\tif(p==group.size()) return score;\n\tif(used >> group[p] & 1) return dfs(p+1, used, score, g, group);\n\tif(score + rest[group[p]] <= relt) return 0;\n\n\tll res = score;\n\tll tmp = used | paint[group[p]];\n\tres = max(res, dfs(p+1, tmp, score+pw[group[p]], g, group));\n\tres = max(res, dfs(p+1, used, score, g, group));\n\t\n\trelt = max(res, relt);\n\treturn res;\n}\n\nint main()\n{\n\tios_base::sync_with_stdio(false);\n\twhile(cin >> N, N) {\n\t\tmemset(rest, 0, sizeof(rest));\n\n\t\tint gcnt = 0;\n\t\tmap<string, int> dic;\n\t\tGraph graph(N);\n\t\tUnionFind uf(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tstring src;\n\t\t\tcin >> src;\n\n\t\t\tif(!dic.count(src)) dic[src] = gcnt++;\n\t\t\tint s = dic[src];\n\n\t\t\tcin >> pw[s];\n\t\n\t\t\tint M;\n\t\t\tcin >> M;\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++) {\n\t\t\t\tstring dst;\n\t\t\t\tcin >> dst;\n\t\t\t\t\n\t\t\t\tif(!dic.count(dst)) dic[dst] = gcnt++;\n\t\t\t\tint t = dic[dst];\n\n\t\t\t\tgraph[s].push_back(Edge(s,t));\n\t\t\t\tuf.unionSet(s,t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tpaint[i] = (1LL << i);\n\t\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\t\tpaint[i] |= (1LL << graph[i][j].dst);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > groups(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tgroups[uf.root(i)].push_back(i);\n\t\t\trest[uf.root(i)] += pw[i];\n\t\t}\n\n\t\tfor(int i=0; i<N; i++) {\n\t\tfor(int j=0; j<groups[i].size(); j++)\n\t\t\trest[groups[i][j]] = rest[uf.root(groups[i][j])];\n\t\t}\n\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tfor(int j=1; j<groups[i].size(); j++) {\n\t\t\t\trest[groups[i][j]] = rest[groups[i][j-1]] - pw[groups[i][j-1]];\n\t\t\t}\n\t\t} \n\n\t\tll res = pw[0];\n\t\tll init = paint[0];\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tif(groups[i].size() == 0) continue;\n\t\t\trelt = 0;\n\t\t\tres += dfs(0, init, 0, graph, groups[i]);\n\t\t} \n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\nint n;\nint b[44],c[44];\nstring d[44][44];\nvector<int> g[44];\nint dame[44];\nll ans=0,sum=0;\n\nvoid dfs(int v,ll ns){\n  if(v==n){\n    maxch(ans,ns);\n    return ;\n  }\n  \n  ll asum=0;\n  repl(i,v,n){\n    if(!dame[i])asum+=b[i];\n  }\n  if(asum+ns<=ans)return ;\n  \n  if(dame[v]==0){ // use\n    dame[v]++;\n    for(int nv:g[v]){\n      dame[nv]++;\n    }\n    dfs(v+1,ns+b[v]);\n    for(int nv:g[v]){\n      dame[nv]--;\n    }\n    dame[v]--;\n  }\n  // unuse\n  dfs(v+1,ns);\n  return ;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    rep(i,44)g[i].clear();\n    map<string,int> idx;\n    cin>>n;\n    if(n==0)break;\n    ans=sum=0;\n    rep(i,n){\n      string name;\n      cin>>name>>b[i]>>c[i];\n      idx[name]=i;\n      sum+=b[i];\n      rep(j,c[i]){\n        cin>>d[i][j];\n      }\n    }\n    rep(i,n){\n      rep(j,c[i]){\n        int nv=idx[d[i][j]];\n        g[i].pb(nv);\n        //printf(\"(%d %d)\\n\", i,nv);\n      }\n    }\n    memset(dame,0,sizeof(dame));\n    dame[0]++;\n    for(int v:g[0]){\n      dame[v]++;\n    }\n    dfs(1,0);\n    cout<<ans+b[0]<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nstruct before_main {\n  before_main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n  }\n} before_main;\n\n#define REP(i, a, b) for (int i = a; i < (int)b; i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef long long ll;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41];\nint weight_sum[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n\n  if (curr == N) {\n    ans = max(ans, wsum);\n    return;\n  }\n\n  if (wsum + weight_sum[N-1] - (curr ? weight_sum[curr - 1] : 0) <= ans)\n    return;\n\n  dfs(S, wsum, curr + 1);\n\n  rep(k, curr) {\n    if (adjacent[curr][k] && (S >> k & 1)) {\n      return;\n    }\n  }\n\n  dfs(S | (1 << curr), wsum + weight[curr], curr + 1);\n}\n\nint main() {\n\n  while (cin >> N && N) {\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(_, N) {\n      string s;\n      cin >> s;\n      if (id.find(s) == id.end())\n        id[s] = v++;\n      cin >> weight[id[s]];\n      int n;\n      cin >> n;\n      rep(_, n) {\n        string t;\n        cin >> t;\n        if (id.find(t) == id.end())\n          id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) weight_sum[i] = weight[i] + (i ? weight_sum[i-1] : 0);\n\n    ans = 0;\n    dfs(1<<0, weight[0], 1);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\trest -= names[pos].second;\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tint rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\trest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\trest = rest1;\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tans = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tlist.push_back(a);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tbuf.insert(make_pair(name, move(list)));\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second,mb);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint r[64], p[64];\nInt f[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nvoid prepare(vector<int>& q) {\n    const int n = q.size();\n    //vector<pair<int, int> > ps;\n    //rep (i, n) ps.push_back(mp(C[q[i]], q[i]));\n    //sort(ps.begin(), ps.end());\n    //rep (i, n) r[i] = ps[n-1-i].second;\n    rep (i, n) r[i] = q[i];\n    rep (i, n) p[i] = B[r[i]];\n    rep (i, n) {\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nint rec(int n, int k, Int u) {\n    if (k == n) return 0;\n    rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return -INF;\n    int ans = -INF;\n    const int mask = (1LL<<n) - 1;\n    if (u&(1LL<<k)) ans = max(ans, rec(n, k+1, u&(mask-f[k])) + p[k]);\n    if (r[k]) ans = max(ans, rec(n, k+1, u&(mask-(1LL<<k))));\n    return ans;\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        ans += rec(q.size(), 0, (1LL<<q.size())-1);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nvector<string> list[40];\nstring name[40];\nint n, w[40], sum;\nvector<vi> e;\nbool v[40], ok[40];\n\nvoid dfs(int c, vector<pi> &o){\n\to.pb(mp(w[c], c));\n\tv[c] = 1;\n\tok[c] = 1;\n\teach(i, e[c]) if(!v[*i]) dfs(*i, o);\n}\nvoid rec(int c, int cur, const vector<pi> &o){\n\tint next = -1, tmp = 0;\n\tfor(int i = o.size() - 1; i >= c; i--) if(ok[o[i].second]){\n\t\tnext = o[i].second;\n\t\ttmp += o[i].first;\n\t}\n\tif(cur + tmp <= sum) return;\n\tif(next < 0){\n\t\tsum = cur + tmp;\n\t\treturn;\n\t}\n\tif(ok[o[c].second]){\n\t\tbool ok2[40];\n\t\trep(i, o.size()) ok2[i] = ok[i];\n\t\teach(i, e[o[c].second]) ok[*i] = 0;\n\t\trec(c + 1, cur + o[c].first, o);\n\t\trep(i, o.size()) ok[i] = ok2[i];\n\t}\n\tif(o[c].second != 0) rec(c + 1, cur, o);\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(v, 0, sizeof(v));\n\t\te.clear(); e.resize(n);\n\t\tmap<string, int> id;\n\t\trep(i, n){\n\t\t\tint k;\n\t\t\tcin >> name[i] >> w[i] >> k;\n\t\t\tlist[i].clear(); list[i].resize(k);\n\t\t\trep(j, k) cin >> list[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, list[i].size()) e[i].pb(id[list[i][j]]);\n\t\t\n\t\tint ans = 0;\n\t\trep(i, n) if(!v[i]){\n\t\t\tvector<pi> ord;\n\t\t\tdfs(i, ord);\n\t\t\tsort(all(ord), greater<pi>());\n\t\t\tsum = 0;\n\t\t\trec(0, 0, ord);\n\t\t\tans += sum;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], cf[64], ct[64];\nint dp[1<<20];\n\nint solve() {\n    const int n = N / 2, m = N - n;\n    const int nn = 1<<n, mm = 1<<m;\n    memset(cf, 0, sizeof(cf));\n    memset(ct, 0, sizeof(ct));\n    rep (i, n) rep (j, n) if (g[i][j]) cf[i] |= 1<<j;\n    rep (i, m) rep (j, m) if (g[i+n][j+n]) cf[i+n] |= 1<<j;\n    rep (i, m) rep (j, n) if (g[i+n][j]) ct[i] |= 1<<j;\n    rep (i, nn) dp[i] = -INF;\n    rep (b, nn) {\n        if (b&1) {\n            bool ok = true;\n            rep (i, n) if (b&(1<<i) && b&cf[i]) { ok = false; break; }\n            if (ok) {\n                int s = 0;\n                rep (i, n) if (b&(1<<i)) s += B[i];\n                dp[b] = max(dp[b], s);\n            }\n        }\n        rep (i, n) dp[b|(1<<i)] = max(dp[b|(1<<i)], dp[b]);\n    }\n    int ans = 0;\n    rep (b, mm) {\n        bool ok = true;\n        rep (i, m) if (b&(1<<i) && b&cf[i+n]) { ok = false; break; }\n        if (!ok) continue;\n        int s = 0;\n        rep (i, m) if (b&(1<<i)) s += B[i+n];\n        int z = 0;\n        rep (i, m) if (b&(1<<i)) z |= ct[i];\n        ans = max(ans, dp[nn-1-z] + s);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//OBOG2012E 敵の敵は味方 \n//OBOG会解説の方法\n//Debug 60s, Release:6s\n#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\n//ID割り当て用\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n//\nint64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\t\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp){\n\t\t\t\tmax = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);//次数でソート\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 45\ntypedef long long ll;\n\nint n;\nmap<string,int> mp;\nvector<string> g[MAX_N];\nvector<int> G[MAX_N];\nint a[MAX_N];\nll S[MAX_N];\nint total;\nint ans=0;\n\nstring change(ll x){\n  string res=\"\";\n  for(int i=0;i<n;i++){\n    if(x>>i&1)res.push_back('1');\n    else res.push_back( '0' );\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nvoid init(){\n  total=ans=0;\n  mp.clear();\n  for(int i=0;i<MAX_N;i++){\n    g[i].clear();\n    G[i].clear();\n  }\n}\n\nvoid solve(int k,int sum,ll bit,ll bit2){\n  if(total-sum<=ans)return;\n  if(k==n){\n    ans=max(ans,total-sum);\n    return;\n  }\n  if(k)solve(k+1,sum+a[k],bit,bit2);\n  if((bit>>k)&1)return;\n  bit+=(1LL<<k);\n  bit2|=S[k];\n  if(bit&bit2)return;\n  solve(k+1,sum,bit,bit2);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      string str,to;\n      int k;\n      cin>>str>>a[i]>>k;\n      mp[str]=i;\n      total+=a[i];\n      for(int j=0;j<k;j++){\n\tcin>>to;\n\tg[i].push_back(to);\n      }\n    }\n    for(int i=0;i<n;i++){\n      S[i]=0;\n      for(int j=0;j<(int)g[i].size();j++){\n\tG[i].push_back(mp[g[i][j]]);\n\tS[i]+= (1LL<< (G[i].back()));\n      }\n    }\n    solve(0,0,0,0);\n    cout<<ans<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int>& f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tint tt = id.size();\n\t\t\t\tid[t] = tt;\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\nint max_f;\nvoid dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t{\n\t\tmax_swap(max_f, sum);\n\t\treturn;\n\t}\n\n\t{\n\t\tint rem = 0;\n\t\tfor (int i = d; i < m; ++i)\n\t\t\tif (!(enemy >> i & 1))\n\t\t\t\trem += force[i];\n\t\tif (sum + rem < max_f)\n\t\t\treturn;\n\t}\n\n\tif (!(enemy >> d & 1))\n\t\tdfs(d + 1, enemy | on[d], sum + force[d]);\n\tdfs(d + 1, enemy, sum);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t{\n\t\t\t\tint t = id.size();\n\t\t\t\tid[a] = t;\n\t\t\t}\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t{\n\t\t\t\t\tint t = id.size();\n\t\t\t\t\tid[d] = t;\n\t\t\t\t}\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\n\t\tint res;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tmax_f = 0;\n\t\tdfs(1, on[0], force[0]);\n\t\tres = max_f;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tmax_f = 0;\n\t\t\t\tdfs(0, 0, 0);\n\t\t\t\tres += max_f;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nint n;\nstring name[40];\nvector<string> neighbor[40];\nmap<string,int> name2id;\nint a[40],b[40],c[40];\nint G[40][40];\n\nconst int N=1<<20;\nint dp1[N], dp2[N];\nint u1[N], u2[N];\n\nint main()\n{\n    cin.tie(0);ios::sync_with_stdio(false);\n\n    while(cin >>n,n)\n    {\n        // initialize\n        name2id.clear();\n        rep(i,40) neighbor[i].clear();\n        memset(G,0,sizeof(G));\n        memset(dp1,0,sizeof(dp1));\n        memset(dp2,0,sizeof(dp2));\n        memset(u1,0,sizeof(u1));\n        memset(u2,0,sizeof(u2));\n\n        // input\n        rep(i,n)\n        {\n            cin >>name[i] >>b[i] >>c[i];\n            neighbor[i].resize(c[i]);\n            rep(j,c[i]) cin >>neighbor[i][j];\n\n            a[i] = i;\n            name2id[name[i]] = i;\n        }\n\n        rep(i,n)rep(j,c[i]) G[i][name2id[neighbor[i][j]]] = 1;\n\n        int X=n/2, Y=n-X;\n\n        dp1[1] = b[0];\n        u1[1] = 1;\n        for(int mask=1; mask<(1<<X); mask+=2)\n        {\n            // ?¬???????????????????\n            rep(i,X)if(!(mask>>i&1))\n            {\n                int nmask = mask|(1<<i);\n\n                int val = dp1[mask] + b[i];\n                int nu = nmask;\n                rep(j,X)if(mask>>j&1 && G[i][j])\n                {\n                    val -= b[j];\n                    nu &= ~(1<<j);\n                }\n\n                if(dp1[nmask] < dp1[mask])\n                {\n                    dp1[nmask] = dp1[mask];\n                    u1[nmask] = u1[mask];\n                }\n                if(dp1[nmask] < val)\n                {\n                    dp1[nmask] = val;\n                    u1[nmask] = nu;\n                }\n            }\n        }\n\n        rep(mask,1<<Y)\n        {\n            // ?¬???????????????????\n            rep(i,Y)if(!(mask>>i&1))\n            {\n                int nmask = mask|(1<<i);\n\n                int val = dp2[mask] + b[X+i];\n                int nu = nmask;\n                rep(j,Y)if(mask>>j&1 && G[X+i][X+j])\n                {\n                    val -= b[X+j];\n                    nu &= ~(1<<j);\n                }\n\n                if(dp2[nmask] < dp2[mask])\n                {\n                    dp2[nmask] = dp2[mask];\n                    u2[nmask] = u2[mask];\n                }\n                if(dp2[nmask] < val)\n                {\n                    dp2[nmask] = val;\n                    u2[nmask] = nu;\n                }\n            }\n        }\n\n        int ans=0;\n        int M=(1<<Y)-1;\n        for(int mask=1; mask<(1<<X); mask+=2)\n        {\n            int t=0;\n            rep(i,X)if(u1[mask]>>i&1)\n            {\n                rep(j,Y)if(G[i][X+j]) t |= 1<<j;\n            }\n            ans = max(ans, dp1[mask]+dp2[~t&M]);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[40];\nbool G[40][40];\nint NG[40];\nint sum[40];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[fake] < beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef __int64 int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n\ninline int64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\t\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp){\n\t\t\t\tmax = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\tbool nei;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\tnei=false;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t\tif(d==0)nei=true;\n\t\t\t}\n\t\t\tif(nei){\n\t\t\t\tn--;\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,ans,sum;\nstring a[50];\nint b[50],c[50];\nvector<string> d[50];\nmap<string,int> m;\nvoid dfs(int x,int p,int q,set<int> s,set<int> t){\n  //cout<<x<<\" \"<<p<<\" \"<<q<<\":\"<<sum<<\" \"<<ans<<endl;\n  if(sum-q<=ans) return;\n  ans=max(ans,p);\n  if(x==n) return;\n  dfs(x+1,p,q,s,t);\n  if(!t.count(x)){\n    p+=b[x];\n    for(int i=0;i<c[x];i++){\n      if(s.count(m[d[x][i]])) return;\n      if(t.count(m[d[x][i]])) continue;\n      t.insert(m[d[x][i]]);\n      q+=b[m[d[x][i]]];\n    }\n    dfs(x+1,p,q,s,t);\n  }\n}\nsigned main(){\n  while(cin>>n,n){\n    m.clear();\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      m[a[i]]=i;\n      d[i].clear();\n      d[i].resize(c[i]);\n      for(int j=0;j<c[i];j++) cin>>d[i][j];\n    }\n    ans=sum=0;\n    for(int i=0;i<n;i++) sum+=b[i];\n    set<int> s,t;\n    s.insert(0);\n    int p=b[0],q=0;\n    for(int i=0;i<c[0];i++){\n      if(t.count(m[d[0][i]])) continue;\n      t.insert(m[d[0][i]]);\n      q+=b[m[d[0][i]]];\n    }\n    dfs(1,p,q,s,t);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//29\n#include<iostream>\n#include<string>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint N;\nint B[40];\nvector<pair<int,int> > v;\n\nint rec(long long b,long long bb,int c){\n  if(c==v.size()){\n    return 0;\n  }else{\n    int s=v[c].first;\n    int t=v[c].second;\n    if(b>>s&b>>t&1){\n      return -1<<30;\n    }\n    int m=rec(b,bb|1LL<<s|1LL<<t,c+1);\n    if(!(((b|bb)>>s|b>>t)&1)){\n      m=max(m,B[s]+rec(b|1LL<<s,bb|1LL<<t,c+1));\n    }\n    if(!(((b|bb)>>t|b>>s)&1)){\n      m=max(m,B[t]+rec(b|1LL<<t,bb|1LL<<s,c+1));\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>N,N){\n    string A[40];\n    vector<string> D[40];\n    for(int i=0;i<N;i++){\n      int C;\n      cin>>A[i]>>B[i]>>C;\n      D[i].resize(C);\n      while(C--){\n\tcin>>D[i][C];\n      }\n    }\n    v.clear();\n    int m=0;\n    long long b=0;\n    long long bb=0;\n    for(int i=0;i<N;i++){\n      if(i==0||D[i].size()==0){\n\tm+=B[i];\n\tb|=1LL<<i;\n\tfor(int j=0;j<D[i].size();j++){\n\t  int k=find(A,A+N,D[i][j])-A;\n\t  bb|=1LL<<k;\n\t}\n      }\n      for(int j=0;j<D[i].size();j++){\n\tint k=find(A,A+N,D[i][j])-A;\n\tif(i<k){\n\t  v.push_back(make_pair(i,k));\n\t}\n      }\n    }\n    cout<<m+rec(b,bb,0)<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*\n * 2403.cc: The Enemy of My Enemy is My Friend\n */\n\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\n#include<set>\n#include<stack>\n#include<list>\n#include<queue>\n#include<deque>\n#include<algorithm>\n#include<numeric>\n#include<utility>\n#include<complex>\n#include<functional>\n \nusing namespace std;\n\n/* constant */\n\nconst int MAX_N = 40;\n\n/* typedef */\n\ntypedef long long ll;\n\ntypedef vector<string> vs;\ntypedef map<string,int> msi;\ntypedef map<ll,int> mli;\n\n/* global variables */\n\nint n, bs[MAX_N];\nvs ds[MAX_N];\nmsi cmap;\nll masks[MAX_N];\nmli dp;\n\n/* subroutines */\n\nint rec(ll mask, int k) {\n  if (k >= n) return 0;\n  \n  mli::iterator mit = dp.find(mask);\n  if (mit != dp.end()) return mit->second;\n\n  int ret = 0;\n  for (int i = k; i < n; i++) {\n    ll bi = 1LL << i;\n    if (! (mask & bi)) {\n      int b = bs[i] + rec(mask | masks[i], i + 1);\n      if (ret < b) ret = b;\n    }\n  }\n\n  return (dp[mask] = ret);\n}\n\n/* main */\n\nint main() {\n  for (;;) {\n    cin >> n;\n    if (n == 0) break;\n\n    cmap.clear();\n\n    for (int i = 0; i < n; i++) {\n      string ai;\n      int ci;\n      cin >> ai >> bs[i] >> ci;\n\n      masks[i] = 1LL << i;\n      cmap[ai] = i;\n      ds[i].clear();\n      \n      for (int j = 0; j < ci; j++) {\n\tstring dj;\n\tcin >> dj;\n\tds[i].push_back(dj);\n      }\n    }\n\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < ds[i].size(); j++)\n\tmasks[i] |= 1LL << cmap[ds[i][j]];\n\n    dp.clear();\n\n    int maxb = bs[0] + rec(masks[0], 1);\n    printf(\"%d\\n\", maxb);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <iostream>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define VI vector<int>\n#define VVI vector<VI>\n#define PB push_back\n#define LL long long\nusing namespace std;\nmap<string, int> m;\nmap<LL, int> ans;\nVVI g;\nVI s;\nint n;\n\nint DFS(LL p){\n\tif(EXIST(ans,p))return ans[p];\n\tint ret = 0;\n\tREP(i,n){\n\t\tif(!(p&(1LL<<i))){\n\t\t\tLL q = p|(1LL<<i);\n\t\t\tREP(j,g[i].size())q|=(1LL<<g[i][j]);\n\t\t\tret = max(ret,DFS(q)+s[i]); \n\t\t}\n\t}\n\treturn ans[p]=ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint ret=0;\n\t\tLL start=1LL;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)return 0;\n\t\ts=VI(n);\n\t\tg=VVI(n);\n\t\tm.clear();\n\t\tint k=0,idx;\n\t\tREP(i,n){\n\t\t\tstring name;\n\t\t\tcin>>name;\n\t\t\tif(!EXIST(m,name)){\n\t\t\t\tidx=m[name]=k;\n\t\t\t\tk++;\n\t\t\t}else idx=m[name];\n\t\t\tint q;\n\t\t\tcin>>s[idx]>>q;\n\t\t\tif(q==0){\n\t\t\t\tret+=s[idx];\n\t\t\t\tstart|=(1LL<<idx);\n\t\t\t}\n\t\t\tREP(j,q){\n\t\t\t\tcin>>name;\n\t\t\t\tif(!EXIST(m,name)){\n\t\t\t\t\tm[name]=k;\n\t\t\t\t\tg[idx].PB(k);\n\t\t\t\t\tk++;\n\t\t\t\t}else g[idx].PB(m[name]);\n\t\t\t}\n\t\t}\n\t\tREP(i,g[0].size())start|=(1LL<<g[0][i]);\n\t\tcout << DFS(start)+s[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n;\nint main(){\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs name(n);\n\t\tvi b(n),co(n);\n\t\tvector<vs>in(n);\n\t\trep(i,n){\n\t\t\tcin>>name[i]>>b[i]>>co[i];\n\t\t\tma[name[i]]=1;\n\t\t\tin[i]=vs(co[i]);\n\t\t\trep(j,co[i]){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tma[in[i][j]]=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\tfor(auto it=ma.begin();it!=ma.end();it++)\n\t\t\tit->second=t++;\n\t\t\n\t\tint cost[41][41]={0};\n\t\trep(i,n)rep(j,in[i].size()){\n\t\t\tint from=ma[name[i]],to=ma[in[i][j]];\n\t\t\tcost[from][to]=cost[to][from]=1;\n\t\t}\n\t\tint N=n/2,nN=n-N;\n\t\tvi dp(1<<nN);\n\t\trep(i,1<<nN){\n\t\t\tbool h=true;\n\t\t\trep(j,nN)loop(k,j+1,nN)if((i&1<<j)&&(i&1<<k)&&cost[ma[name[N+j]]][ma[name[N+k]]])h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,nN)if(i&1<<j)sum+=b[N+j];\n\t\t\t\tdp[i]=sum;\n\t\t\t}\n\t\t}\n\t\trep(i,1<<nN)rep(j,nN)if((i&1<<j)==0)\n\t\t\tdp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n\t\t\n\t\tint out=0;\n\t\trep(i,1<<N)if(i&1){\n\t\t\tbool h=true;\n\t\t\trep(j,N)loop(k,j+1,N)if((i&1<<j)&&(i&1<<k)&&cost[ma[name[j]]][ma[name[k]]])h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,N)if(i&1<<j)sum+=b[j];\n\t\t\t\tt=(1<<nN)-1;\n\t\t\t\trep(j,N)if(i&1<<j)rep(k,nN)if((t&1<<k)&&cost[ma[name[j]]][ma[name[N+k]]])t^=1<<k;\n\t\t\t\tout=max(out,sum+dp[t]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\ntemplate<class T>\nclass IdMaker{\npublic:\n  std::map<T,int> _m;\n  int getId(const T &v){\n    if(_m.find(v) == _m.end()){\n      int next = _m.size();\n      return _m[v] = next;\n    }\n    return _m[v];\n  }\n};\n\nll adj[40];\nint str[40];\nint memo[40];\nint ans;\n\nvoid solve(ll flag, int now){\n  ll ff = flag;\n\n  while(ff){\n    const ll f = ff & (-ff);\n    const int pos = __builtin_ctzl(f);\n    if((adj[pos] & flag) == 0){\n      now += str[pos];\n      flag ^= f;\n    }\n    ff ^= f;\n  }\n\n  ans = max(ans, now);\n\n  if(flag == 0 || now + memo[__builtin_ctzl(flag)] <= ans)\n    return;\n\n  while(flag){\n    const ll f = flag & (-flag);\n    const int pos = __builtin_ctzl(f);\n    solve((flag ^ (1ll << pos)) & (~adj[pos]), now + str[pos]);\n    flag ^= f;\n  }\n}\n\nint main(){\n  while(const int n = getInt()){\n    IdMaker<string> idm;\n\n    REP(i,n){\n      string s; cin >> s;\n      str[idm.getId(s)] = getInt();\n      const int m = getInt();\n      adj[idm.getId(s)] = 0;\n      REP(j,m){\n        string a; cin >> a;\n        adj[idm.getId(s)] |= (1ll << idm.getId(a));\n      }\n    }\n\n    REP(i,n)\n      for(int j = i; j < n; j++)\n        memo[i] += str[j];\n\n    ll start = (1ll << n) - 1;\n    start ^= 1;\n    start ^= adj[0];\n\n    ans = 0;\n    solve(start, str[0]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\ntemplate<class T>\nclass IdMaker{\npublic:\n  std::map<T,int> _m;\n  int getId(const T &v){\n    if(_m.find(v) == _m.end()){\n      int next = _m.size();\n      return _m[v] = next;\n    }\n    return _m[v];\n  }\n};\n\nll adj[40];\nint str[40];\nint memo[40];\nint ans;\n\nvoid solve(ll flag, int now){\n  ll ff = flag;\n\n  while(ff){\n    const ll f = ff & (-ff);\n    const int pos = __builtin_ctzll(f);\n    if((adj[pos] & flag) == 0){\n      now += str[pos];\n      flag ^= f;\n    }\n    ff ^= f;\n  }\n\n  ans = max(ans, now);\n  if(flag == 0 || now + memo[__builtin_ctzll(flag)] <= ans)\n    return;\n\n  while(flag){\n    const ll f = flag & (-flag);\n    const int pos = __builtin_ctzll(f);\n    solve((flag ^ (1ll << pos)) & (~adj[pos]), now + str[pos]);\n    flag ^= f;\n  }\n}\n\nint main(){\n  while(const int n = getInt()){\n    IdMaker<string> idm;\n\n    REP(i,n){\n      string s; cin >> s;\n      str[idm.getId(s)] = getInt();\n      const int m = getInt();\n      adj[idm.getId(s)] = 0;\n      REP(j,m){\n        string a; cin >> a;\n        adj[idm.getId(s)] |= (1ll << idm.getId(a));\n      }\n    }\n\n    REP(i,n) memo[i] = 0;\n    REP(i,n)\n      for(int j = i; j < n; j++)\n        memo[i] += str[j];\n\n    ll start = (1ll << n) - 1;\n    start ^= 1;\n    start &= ~adj[0];\n\n    ans = 0;\n    solve(start, str[0]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\nint calc(vector<country> &cs){\n   int n = cs.size();\n   int res = 0;\n   ll ne = cs[0].ne;\n   int power = cs[0].power;\n   REP(i, n){\n       if(ne & (1LL<<i) != 0) continue;\n       if((ne | cs[i].ne) == (ne | (1LL<<i))){\n           ne |= cs[i].ne;\n           power += cs[i].power;\n       }\n   }\n\n   set<ll> use;\n   priority_queue<pair<int, ll> > pq;\n   pq.push(pair<int, ll>(power, ne));\n   while(!pq.empty()){\n       ne = pq.top().second;\n       power = pq.top().first;\n       pq.pop();\n       res = max(res, power);\n       if(use.find(ne) != use.end()) continue;\n       //cout << ne << \"*\" << power << endl;\n       use.insert(ne);\n       REP(i, n){\n           if(ne & (1LL<<i) != 0) continue;\n           if((ne | cs[i].ne) == (ne | (1LL<<i))){\n               ne |= cs[i].ne;\n               power += cs[i].power;\n           }\n       }\n       REP(i, n){\n           if(((1LL<<i) & ne) == 0){\n               ll nne = ne | cs[i].ne;\n               int npower = power + cs[i].power;\n               REP(j, n){\n                   if(nne & (1LL<<j) != 0) continue;\n                   if((nne | cs[j].ne) == (nne | (1LL<<i))){\n                       nne |= cs[j].ne;\n                       npower += cs[j].power;\n                   }\n               }        \n               pq.push(pair<int, ll>(npower, nne));  \n           }\n       }\n   }\n   return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n\ninline int64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\t\n\tfor(int j=i;j<n;j++)\n\t\tif( (get_bit(kuni[j].id) & neighbor)==0 )\n\t\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp){\n\t\t\t\tmax = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<algorithm>\n \nusing namespace std;\ntypedef long long ll;\nint n;\nmap<int,int> strength;\nint ans;\nmap<string,int> Iindex;\nvector<int> findex[50];\n \nint rec(bool used[],int sum,int total){\n \n  bool fin=true;\n  for(int i=0;i<n;i++)fin*=used[i];\n  if(fin){\n    if(ans < sum)ans = sum;\n    return -1;\n  }\n \n \n  for(int i=0;i<n;i++){\n    if(!used[i]){\n      int presum = sum;\n      int pretotal = total;\n      presum+=strength[i];\n      pretotal-=strength[i];\n      if(pretotal == 0)continue;\n      bool preused[50];\n      copy(used,used+n,preused);\n      preused[i]=true;\n      for(int j=0;j<findex[i].size();j++){\n\tpreused[findex[i][j]]=true;\n\tpretotal-=strength[j];\n      }    \n      if(pretotal != 0)rec(preused,presum,pretotal);\n    }\n  }\n \n}\n \n \nint main(){\n  string s1,s2;\n  int val,num;\n  int total;\n  vector<string> relation[50];\n  bool used[50];\n  int Fnum,Fcounter;\nstring Me;\n  while(true){\n    scanf(\"%d\",&n);\n    if(n == 0)break;\n    ans=0;\n    total=0;\n    for(int i=0;i<50;i++){\n      relation[i].clear();\n      findex[i].clear();\n    }\n    Iindex.clear();\n    strength.clear();\n    Fcounter=0;\n    for(int i=0;i<50;i++)used[i]=false;\n    for(int i=0;i<n;i++){\n      cin >> s1 >> val >> num;\n      total+=val;\n      if(i == 0){total-=val;Me = s1;Fnum = num; }\n      Iindex[s1]=i;\n      strength[i]=val;\n      for(int j=0;j<num;j++){\n    cin >> s2;\n    relation[i].push_back(s2);\n      }    \n \n    }\n   \n    used[0]=true;\n    Fcounter++;\n  \n    vector<string>::iterator it = relation[0].begin();\n    for(int j=0;j<Fnum;j++,it++){\n      total-=strength[Iindex[*it]];\n      used[Iindex[*it]]=true;\n      Fcounter++;\n    }\n     \n    // cout << \"total - \" << total << endl;\n \n    for(int k=0;k<n;k++){\n      for(int j=0;j<relation[k].size();j++){\n    findex[k].push_back(Iindex[relation[k][j]]);\n      }\n    }\n \n \n    rec(used,strength[0],total);\n    cout << ans << endl;\n \n \n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint reg(map<string, int>& tbl, string& name) {\n\tif (tbl.count(name) == 0) {\n\t\tint id = tbl.size();\n\t\ttbl[name] = id;\n\t}\n\treturn tbl[name];\n}\n\nint N;\nvector< vector<int> > G;\nvector<int> power;\nvector<int> ps;\nvector<int> conv;\nvector<int> adjacent;\n\nint ans = 0, p = 0;\nbool merge(int n) {\n\tif (adjacent[n] > 0) return false;\n\tfor (int i = 0; i < G[n].size(); ++i) {\n\t\tadjacent[G[n][i]]++;\n\t}\n\treturn true;\n}\nbool remove(int n) {\n\tfor (int i = 0; i < G[n].size(); ++i) {\n\t\tadjacent[G[n][i]]--;\n\t}\n}\nvoid dfs(int n) {\n\tif (n == N) {\n\t\tans = max(ans, p);\n\t}\n\telse {\n\t\tif ( merge(conv[n]) ) {\n\t\t\tp += power[n];\n\t\t\tdfs(n+1);\n\t\t\tremove(conv[n]);\n\t\t\tp -= power[n];\n\t\t}\n\t\tdfs(n+1);\n\t}\n}\n\nint main() {\n\twhile ( cin >> N, N ) {\n\t\tmap<string, int> tbl;\n\t\tpower.clear(); power.resize(N);\n\t\tG.clear(); G.resize(N);\n\t\tconv.clear(); conv.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring A; cin >> A; int a = reg(tbl, A);\n\t\t\tint B, C; cin >> B >> C;\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tstring D; cin >> D;\n\t\t\t\tint d = reg(tbl, D);\n\t\t\t\tG[a].push_back(d);\n\t\t\t}\n\t\t\tpower[i] = B;\n\t\t\tconv[i] = a;\n\t\t}\n\t\tps.resize(N+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tps[i] = power[i];\n\t\t}\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tps[i] += ps[i+1];\n\t\t}\n\t\tadjacent = vector<int>(N, 0);\n\t\tans = 0; p = power[0]; merge(conv[0]);\n\t\tdfs(1);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tvi pow(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> pow[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tvector<ll> g(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tg[i] = 1ll << i;\n\t\t\tREP(j, nei[i].size())\n\t\t\t{\n\t\t\t\tg[i] |= 1ll << mp[nei[i][j]];\n\t\t\t}\n\t\t}\n\t\tint ans = 0;\n\t\tset<ll> ok;\n\t\tstack<ll> st;\n\t\tst.push(1);\n\t\twhile (st.size())\n\t\t{\n\t\t\tll tmp = st.top();\n\t\t\tst.pop();\n\t\t\tll can = 0;\n\t\t\tint sum = 0, cansum = 0;\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((tmp >> j) & 1)\n\t\t\t\t{\n\t\t\t\t\tsum += pow[j];\n\t\t\t\t\tcan |= g[j];\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t}\n\t\t\tchmax(ans, sum);\n\t\t\tREP(j, n)\n\t\t\t{\n\t\t\t\tif ((can >> j) & 1) continue;\n\t\t\t\tll nx = tmp | (1ll << j);\n\t\t\t\tif (ok.count(nx)) continue;\n\t\t\t\tint nsum = sum + pow[j];\n\t\t\t\tok.insert(nx);\n\t\t\t\tst.push(nx);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\nconst int HALF=20;\nint dp0[1<<HALF];\nint vs0[HALF];\nint dp1[1<<HALF];\nint vs1[HALF];\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    for(int i=0;i<half;i++){\n        vs0[i]=0;\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=1;i<(1<<half);i+=2){\n        int vs=0;\n        int val=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                val+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) val=-INF;\n            dp0[i]=val;\n        }\n    }\n\n    \n    for(int i=0;i<rest;i++){\n        vs1[i]=0;\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        int val=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                val+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) val=-INF;\n            dp1[i]=val;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n\n    vector<int> vs01(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]>=half) vs01[i]|=(1<<(g[i][j]-half));\n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if(i&(1<<j)) opn&=~vs01[j];\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    //ios_base::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[45];\nbool G[45][45];\nint NG[45];\nint sum[45];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[fake] <= beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 50;\n\nint N;\nmap<string,int> id;\nGraph g;\nint B[MAXN];\n\nlli adj[MAXN];\nint sum[MAXN];\nint ans;\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nvoid rec(int k, lli bit, int now) {\n  ans = max(ans, now);\n  if(now + sum[k] <= ans) return;\n  if(k == N) return;\n  if(!(bit & (1<<k))) rec(k+1, bit|adj[k], now+B[k]);\n  rec(k+1, bit, now);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    for(int v = 0; v < N; ++v) {\n      adj[v] = 0;//1LL<<v;\n      for(int i = 0; i < g[v].size(); ++i) {\n        int nv = g[v][i];\n        adj[v] |= 1LL<<nv;\n      }\n    }\n\n    sum[N] = 0;\n    for(int v = N-1; v >= 0; --v) sum[v] = sum[v+1] + B[v];\n\n    ans = 0;\n    rec(1, adj[0], B[0]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,int>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\nmap<string ,int> ma;\nint po[50];\nbool ok[1<<20]={0};\nint an[1<<20]={0};\nint dp[1<<20]={0};\nbool miok[1<<20]={0};\nint dp2[1<<20]={0};\nint hi,mi;\nvector<int> G[50];\nvector<pa> e1,e2,e3;\nint ichi[50]={0};\n\n\nvoid shoki(int r){\n\te1.clear();\n\te2.clear();\n\te3.clear();\n\tfor(int i=0;i<50;i++){\n\t\tpo[i]=0;\n\t\tG[i].clear();\n\t\tichi[i]=0;\n\t}\n\t\n\tfor(int i=0;i<(1<<r);i++){\n\t\t\n\t\t\n\t\tdp[i]=0;\n\t\t\n\t\tdp2[i]=0;\n\t}\n\t\n}\n\nvoid makeok(){\n\tfor(int i=0;i<(1<<hi);i++)ok[i]=true;\n\t\n\tfor(auto t:e1){\n\t\tok[(1<<t.second)+(1<<t.first)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<hi);i++){\n\t\tbool b=ok[i];\n\t\t\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(ok[i-(1<<j)]==false)b=false;\n\t\t}\n\t\tok[i]=b;\n\t}\n\treturn;\n\t\n}\nvoid makean(){\n\tfor(int i=0;i<(1<<hi);i++)an[i]=(1<<(mi))-1;\n\t\n\tfor(auto t:e3){\n\t\tan[(1<<t.first)]^= (1<<(t.second-hi));\n\t}\n\t\n\tfor(int i=0;i<(1<<hi);i++){\n\t\t\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tan[i]=an[1<<j]&an[i-(1<<j)];\n\t\t}\n\t}\n\t\n}\n\nvoid makedp(){\n\tfor(int i=0;i<(1<<mi);i++)miok[i]=true;\n\t\n\tfor(auto t:e2){\n\t\n\t\tmiok[(1<<t.first)+(1<<t.second)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<mi);i++){\n\t\tbool b=miok[i];\n\t\tif(!b) continue;\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(miok[i-(1<<j)]==false)b=false;\n\t\t}\n\t\tmiok[i]=b;\n\t}\n\t\n\tfor(int i=0;i<(1<<mi);i++)if(miok[i]){\n\t\tint cnt=0;\n\t\tdp[i]=0;\n\t\tfor(int  j=0;j<mi;j++)if(i&(1<<j)){\n\t\t\tdp[i]=dp[i-(1<<j)]+po[hi+j];\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tfor(int i=0;i<(1<<mi);i++){\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tdp[i]=max(dp[i],dp[i-(1<<j)]);\n\t\t}\n\t\t\n\t}\n}\n\n\n\n         signed main(){\nint n;\n         \twhile(1){\n         \tcin>>n;\n         \t\tif(n==0) return 0;\n         \t\t\n         \t\tshoki((n+1)/2);\n         \tint count1=0;\n         \tfor(int i=0;i<n;i++){\n         \t\tstring s1,s2;\n         \t\tcin>>s1;\n         \t\tif(ma.find(s1)==ma.end()){\n         \t\t\tma[s1]=count1;\n         \t\t\tcount1++;\n         \t\t}\n         \t\tint r3,r4;\n         \t\tcin>>r3>>r4;\n         \t\tpo[ma[s1]]=r3;\n         \t\tfor(int j=0;j<r4;j++){\n         \t\t\tcin>>s2;\n         \t\t\tif(ma.find(s2)==ma.end()){\n         \t\t\t\tma[s2]=count1;\n         \t\t\t\tcount1++;\n         \t\t\t}\n         \t\t\tG[ma[s1]].pb(ma[s2]);\n         \t\t}\n         \t}\n         \t\n         \tint n1=n/2;\n         \thi=n1,mi=n-n1;\n         \tfor(int i=0;i<G[0].size();i++)ichi[G[0][i]]=1;\n         \t//for(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j])cout<<i<<\" \"<<G[i][j]<<endl;\n         \tfor(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j]){\n         \n         \t\n         \t\tif(G[i][j]<hi) e1.pb(mp(i,G[i][j]));\n         \t\telse if(i<hi) e3.pb(mp(i,G[i][j]));\n         \t\telse {\n         \t\t\te2.pb(mp(i-hi,G[i][j]-hi));\n         \t\t}\n         \t}\n         \t\n         \t\n         //\tfor(int i=0;i<n;i++)cout<<po[i]<<endl;\n    \tmakeok();\n         \t\t\n    \tmakean();\n         \t\n    \tmakedp();\n    \t \n \t\t for(int i=0;i<(1<<hi);i++)if(ok[i]){\n    \t\tint cnt=0;\n    \t\tfor(int j=0;j<hi;j++)if(i&(1<<j))cnt+=po[j];\n    \t\t\n    \t\tdp2[i]=cnt;\n    \t}\n         \tint ans=-1;\n          for(int i=0;i<(1<<hi);i++)if(ok[i])if(i&1){\n          \n    \t\tfor(int j=0;j<hi;j++)if(i&(1<<j))dp2[i]=max(dp2[i],dp2[i-(1<<j)]);\n    \t\t\n    \t\tans=max(ans,dp2[i]+dp[an[i]]);\n    \t}\n       \n    \tcout<<ans<<endl;\n         }\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\nusing namespace std;\nvector<long long int> G;\nvector<int> B;\nint N;\n\nint solve(int v, long long int t){\n  if(v >= B.size() || t == (1LL<<N) - 1) return 0;\n  int ret = 0;\n  if(!(t>>v & 1)){\n    long long t_ = t | (1LL<<v);\n    t_ |= G[v];\n    int v_ = v + 1;\n    while(t_>>v_ & 1) ++v_;\n    ret = B[v] + solve(v_,t_);\n    /*\n    if(G[v] == 0LL || \n       (G[v].size() == 1 && B[G[v][0]] <= B[v])) return ret;\n    */\n    if(G[v] == 0LL) return ret;\n  }\n  int v_ = v + 1;\n  while(t>>v_ & 1) ++v_;\n  t |= 1LL<<v;\n  ret = max(ret, solve(v_,t));\n  return ret;\n}\n\nint main(){\n  while(cin >> N, N){\n    map<string,int> M;\n    vector< vector<string> > D(N);\n    string a;\n    B = vector<int>(N);\n    int c;\n    for(int i = 0; i < N; ++i){\n      cin >> a >> B[i] >> c;\n      M[a] = i;\n      string d;\n      for(int j = 0; j < c; ++j){\n        cin >> d;\n        D[i].push_back(d);\n      }\n    }\n    G = vector<long long int>(N,0LL);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < D[i].size(); ++j){\n        G[i] |= 1LL<<M[D[i][j]];\n      }\n    }\n    long long int t = 1LL;\n    t |= G[0];\n    cout << B[0] + solve(1,t) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nbitset<40> G[44];\nint B[44];\nint idx[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\nbitset<40> ok;\nbitset<40> used;\nbitset<40> sele;\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[idx[i]] && !used[idx[i]] && !sele[idx[i]] ) cnt++;\n  }\n  //cout << id << \" \"<< cnt << \" \"<< M << endl;\n  //return cnt > M;\n  return false;\n}\nint solve(int num){\n  int id = idx[num];\n  if( num == N ) return 0;\n  if( sele[id] || ok[id] || used[id] ) return solve(num+1);\n  //if( check(num) ) return 0;\n  \n  bitset<40> tmp;\n  sele[id] = true;\n  tmp = used;\n  used |= G[id];\n  int res = solve(num+1)+B[id];\n\n  //cout << \"view\" << endl;\n  //cout << ok << endl;\n  //cout << used << endl;\n  //cout << sele << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << \n  //cout << id << \" \" << res << endl;\n  \n  int sum = 0;\n  //for(int i=id;i<N;i++) if( !sele[i] && !ok[i] && !used[i] ) sum += B[i];\n  for(int i=num+1;i<N;i++) if( !sele[idx[i]] && !ok[idx[i]] && !used[idx[i]] ) sum += B[idx[i]];\n\n  used = tmp;\n  sele[id] = false;\n\n  if( sum > res )\n    res = max( res,solve(num+1) );\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    vector<pair<int,int>> point;\n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id]=0;\n      point.push_back( make_pair( B[id], id ) );\n      assert( id < N );\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id][nd] = true;\n      }\n    }\n\n    sort( point.rbegin(), point.rend() );\n    for(int i=0;i<(int)point.size();i++)\n      idx[i] = point[i].second;\n\n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i]==bitset<40>(0) ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    used = bitset<40>(0);\n    sele = bitset<40>(0);\n    M = (N+1)/2;\n    if( G[0]!=bitset<40>(0) ) res += B[0];\n    sele[0] = true;\n    used |= G[0];\n    res += solve(0);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#ifdef __BORLANDC__\n\ttypedef __int64 ll;\n#else\n\ttypedef long long ll;\n#endif\n\nconst ll L1 = 1;\nconst int N = 40;\nconst int M = 20;\n\nint n;\nll edge[N];\nint power[N];\n\nvoid printbit(ll state){\n\trep(i,n)printf(\"%d\",((L1<<i)&state)>0);puts(\"\");\n}\n\nvoid printedge(){\n\tprintf(\"edge\\n\");\n\trep(i,n)printbit(edge[i]);\n}\n\nbool init(){\n\tcin>>n;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i]=power[i]=0;\n\t\n\tmap<string,int> mp;\n\tvector<string> estr[N];\n\trep(i,n){\n\t\tstring a;\n\t\tint b,c;\n\t\tcin>>a>>b>>c;\n\t\tmp[a]=i;\n\t\tpower[i]=b;\n\t\trep(j,c){\n\t\t\tstring d;\n\t\t\tcin>>d;\n\t\t\testr[i].push_back(d);\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,estr[i].size()){\n\t\t\tedge[i] |= (L1<<mp[estr[i][j]]);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool hasbit(ll state, int bit){return state&(L1<<bit);}\n\nconst int T = (1<<M);\nint half[T];\n\nint left_search(){\n\trep(i,T)half[i]=0;\n\t\n\tint maxi = 0;\n\tfor(int i=1;i<T;i+=2){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\trep(j,M){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\t if(edge[j]&i)ok=false;\n\t\t\t\t sum += power[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ok)half[i]=sum;\n\t\tmaxi = max(maxi,half[i]);\n\t}\n\treturn maxi;\n}\n\nint memo[T];\nint left_memo(int state){\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tint ret = half[state];\n\trep(i,M){\n\t\tif(state&(1<<i)){\n\t\t\tret = max(ret, left_memo(state ^ (1<<i)));\n\t\t}\n\t}\n\treturn memo[state]=ret;\n}\n\nint right_search(){\n\tint ans = 0;\n\tfor(ll i=0; i<(L1<<n); i+=T){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\tll mask = 0;\n\t\treps(j,M,n){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\tif(edge[j]&i)ok=false;\n\t\t\t\tsum+=power[j];\n\t\t\t\tmask |= edge[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ok){\n\t\t\tmask &= (T-1);\n\t\t\tmask ^= (T-1);\n\t\t\t//printf(\"i=%d sum=%d memo[bit]=%d \",i,sum,memo[mask]);\n\t\t\t//printbit(mask);\n\t\t\tans = max(ans, memo[mask]+sum);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid left_dp(){\n\trep(i,T)memo[i]=-1;\n\t\n\tleft_memo(T-1);\n}\n\nvoid printdp(){\n\trep(i,T){\n\t\tprintf(\"%3d \",memo[i]);printbit(i);\n\t}\n}\nvoid printsearch(){\n\trep(i,T){\n\t\tprintf(\"%3d \",half[i]);printbit(i);\n\t}\n}\nint solve(){\n\tint a = left_search();\n\t\n\tleft_dp();\n\t\n\t/*\n\tputs(\"s\");\n\tprintsearch();\n\tputs(\"d\");\n\tprintdp();\n\t*/\n\treturn max(a,right_search());\n}\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n6\nINTERCAL 10 3 Chef Piet COW\nChef 7 3 INTERCAL Piet COW\nPiet 6 2 INTERCAL Chef\nCOW 7 2 INTERCAL Chef\nJ 6 1 A\nA 12 1 J\n0\n\n6\nINTERCAL 20 1 J\nChef 50 3 J A Piet\nPiet 30 2 A Chef\nCOW 15 1 J\nJ 40 3 COW INTERCAL Chef\nA 25 2 Chef Piet\n0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n\nusing namespace std;\n\n#define UNION 1\n#define NEIGHBOR 2\n\nstruct Union{\n\tstring A;\n\tint B,C;\n\tint D[42];\n\tqueue<string> S;\n} \tU[42];\n\nstruct UnionSearch{\n\tint State[42], B;\n};\n\nvoid AddUnion(UnionSearch *us, int u){\n\tus->State[u] = UNION;\n\tfor(int i=0;i<U[u].C;i++) us->State[ U[u].D[i] ] = NEIGHBOR;\n\tus->B += U[u].B;\n}\n\nint N;\nqueue <UnionSearch> US;\n\n\nint Find(string s){\n\tfor(int i=1;i<=N;i++) if(s==U[i].A) return i;\n\tprintf(\"error\");\n\treturn 0;\n}\n\nmain(){\n\tint i,c,Max;\n\tstring s;\n\tUnionSearch q, p;\n\twhile(cin>>N,N){\n\t//\tUS.clear();\n\t\twhile(!US.empty()) US.pop();\n\t\tfor(i=0;i<42;i++){\n\t\t\tU[i].A = \"\";\n\t\t\tU[i].B=0;\n\t\t\tU[i].C=0;\n\t\t\tmemset(U[i].D, 0, 42*sizeof(int));\n\t\t\twhile(!U[i].S.empty()) U[i].S.pop();\n\t\t}\n\t\tMax = 0;\n\t\tmemset(&q, 0, sizeof(q));\n\t\t\n\t\tfor(i=1;i<=N;i++){\n\t\t\tcin>>U[i].A>>U[i].B>>c;\n\t\t\twhile(c--){\n\t\t\t\tcin>>s;\n\t\t\t\tU[i].S.push(s);\n\t\t\t}\n\t\t}\n\n\t\tfor(i=1;i<=N;i++){\n\t\t\twhile(!U[i].S.empty()){\n\t\t\t\tU[i].D[U[i].C++] = Find(U[i].S.front());\n\t\t\t\tU[i].S.pop();\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tAddUnion(&q, 1);\n\t\tUS.push(q);\n\t\twhile(!US.empty()){\n\t\t\tq = US.front();\n\t\t\tUS.pop();\n\t\t\tint t;\n\t\t\tfor(t=1;t<=N;t++){\n\t\t\t\tif(!q.State[t])break;\n\t\t\t\n\t\t\t}\n\t\t\tif(t>N){\n\t\t\t\tMax = max(Max, q.B);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(i=0;i<U[t].C;i++){\n\t\t\t\tp = q;\n\t\t\t\tif(p.State[U[t].D[i]]) continue;\n\t\t\t\tAddUnion(&p, U[t].D[i]);\n\t\t\t\tUS.push(p);\n\t\t\t}\n\t\t\tAddUnion(&q, t);\n\t\t\tUS.push(q);\n\t\t}\n\t\tcout << Max << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nvector<int> G[44];\nint B[44];\nbool ok[44];\nint idx[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\n\nbool used[55];\nbool sele[55];\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[i] && !used[i] && !sele[i] ) cnt++;\n  }\n  //cout << id << \" \"<< cnt << \" \"<< M << endl;\n  return cnt > M;\n}\nint solve(int num){\n  int id = idx[num];\n  if( num == N ) return 0;\n  if( sele[id] || ok[id] || used[id] ) return solve(num+1);\n  if( check(num) ) return 0;\n  \n  bool tmp[41]={};\n  sele[id] = true;\n  for(int i=0;i<N;i++) tmp[i] = used[i];\n  for(int i=0;i<(int)G[id].size();i++) used[G[id][i]] = true;\n  int res = solve(num+1)+B[id];\n\n  //cout << \"view\" << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << endl; }\n  //cout << id << \" \" << res << endl;\n\n  for(int i=0;i<N;i++) used[i] = tmp[i];\n  sele[id] = false;\n  \n  int sum = 0;\n  for(int i=id+1;i<N;i++) if( !ok[i] && !used[i] ) sum += B[i];\n  if( sum > res )\n    res = max( res,solve(num+1) );\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    vector<pair<int,int>> point;\n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id].clear();\n      point.push_back( make_pair( B[id], id ) );\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id].push_back( nd );\n      }\n    }\n\n    sort( point.rbegin(), point.rend() );\n    for(int i=0;i<(int)point.size();i++)\n      idx[i] = point[i].second;\n\n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i].empty() ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    memset(used,0,sizeof(used));\n    memset(sele,0,sizeof(sele));\n    M = (N+1)/2;\n    if( !G[0].empty() ) res += B[0];\n    sele[0] = true;\n    for(int i=0;i<(int)G[0].size();i++) used[G[0][i]] = true;\n    res += solve(0);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<map>\nusing namespace std;\n\n#define M 40\n#define max(a,b) (a>b?a:b)\n\ntypedef unsigned int uint;\n\nstruct Edge {\n\tint to, w;\n\tEdge(int a, int b) : to(a), w(b) {};\n\tEdge() {};\n};\n\ntypedef vector<int> Graph;\n\nGraph g[M];\nint power[M];\nint n;\n\nint solve(int s, int del[M], int pw) {\n\tint _del[M], ret = pw+power[s], r;\n\tfor(int i=0; i<n; ++i) _del[i] = del[i];\n\tfor(uint i=0; i<g[s].size(); ++i) {\n\t\t_del[g[s][i]] = 1;\n\t}\n\tfor(int i=s+1; i<n; ++i) {\n\t\tif(!_del[i]) {\n\t\t\tr = solve(i, _del, pw+power[s]);\n\t\t\tret = max(r, ret);\n\t\t}\n\t}\n\treturn ret;\n}\n\nint main() {\n\tmap<string, int> kuni;\n\tstring name, near_n;\n\tint nc, del[M];\n\twhile(1) {\n\t\tcin >> n;\n\t\tif(!n) break;\n\t\tfor(int i=0; i<n; ++i) g[i].clear();\n\t\tkuni.clear();\n\t\tfor(int i=0, c=0; i<n; ++i) {\n\t\t\tcin >> name;\n\t\t\tif(!kuni.count(name)) {\n\t\t\t\tkuni[name] = c++;\n\t\t\t}\n\t\t\tcin >> power[kuni[name]] >> nc;\n\t\t\tfor(int j=0; j<nc; ++j) {\n\t\t\t\tcin >> near_n;\n\t\t\t\tif(!kuni.count(near_n)) {\n\t\t\t\t\tkuni[near_n] = c++;\n\t\t\t\t}\n\t\t\t\tg[kuni[name]].push_back(kuni[near_n]);\n\t\t\t\tg[kuni[near_n]].push_back(kuni[name]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<M; ++i) del[i] = 0;\n\t\tcout << solve(0, del, 0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <cassert>\n#include <typeinfo>\n#include <vector>\n#include <stack>\n#include <cmath>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\n#include <iomanip>\n#include <cctype>\n#include <random>\n#include <complex>\n#define syosu(x) fixed<<setprecision(x)\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> P;\ntypedef pair<double,double> pdd;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<char> vc;\ntypedef vector<vc> vvc;\ntypedef vector<string> vs;\ntypedef vector<bool> vb;\ntypedef vector<vb> vvb;\ntypedef vector<P> vp;\ntypedef vector<vp> vvp;\ntypedef vector<pll> vpll;\ntypedef pair<P,int> pip;\ntypedef vector<pip> vip;\nconst int inf=1<<29;\nconst ll INF=1ll<<50;\nconst double pi=acos(-1);\nconst double eps=1e-8;\nconst ll mod=1e9+7;\nconst int dx[4]={0,1,0,-1},dy[4]={1,0,-1,0};\n\nint n;\nmap<string,int> a;\nvi b,c;\nvector<vs> d;\n\nvvi g;\n\nint main(){\n\twhile(1){\n\t\tcin>>n;\n\t\tif(!n) break;\n\t\tb=c=vi(n);\n\t\td=vector<vs>(n);\n\t\tg=vvi(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring s;\n\t\t\tcin>>s>>b[i]>>c[i];\n\t\t\ta[s]=i;\n\t\t\td[i]=vs(c[i]);\n\t\t\tfor(int j=0;j<c[i];j++) cin>>d[i][j];\n\t\t}\n\t\tfor(int i=0;i<n;i++) for(int j=0;j<c[i];j++) g[i].push_back(a[d[i][j]]);\n\t\tint N=n/2;\n\t\tvi dp(1<<N);\n\t\tfor(int i=1;i<1<<N;i++){\n\t\t\tint v,I=i;\n\t\t\tfor(int j=0;j<N;j++) if(i&1<<j){\n\t\t\t\tv=j+n-N;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tI-=1<<v-n+N;\n\t\t\tfor(int j=0;j<g[v].size();j++){\n\t\t\t\tint u=g[v][j];\n\t\t\t\tif(u>=n-N&&I&1<<u-n+N) I-=1<<u-n+N;\n\t\t\t}\n\t\t\tdp[i]=max(dp[i&i-1],dp[I]+b[v]);\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<1<<n-N;i++){\n\t\t\tint I=(1<<N)-1,sum=0;\n\t\t\tbool f=1;\n\t\t\tfor(int j=0;j<n-N;j++) if(i&1<<j){\n\t\t\t\tsum+=b[j];/*\n\t\t\t\tfor(int k=0;k<g[j].size();k++){\n\t\t\t\t\tint v=g[j][k];\n\t\t\t\t\tif(v<n-N&&i&1<<v) f=0;\n\t\t\t\t\tif(v>=n-N&&I&1<<v-n+N) I-=1<<v-n+N;\n\t\t\t\t}*/\n\t\t\t}\n\t\t\tif(f&&i&1) res=max(res,dp[I]+sum);\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<algorithm>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<string>\n#include<climits>\n#include<map>\n#include<set>\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 1<<30\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> strength; //国の強さ\nmultimap<string,string> adjacentCountry; //隣接した国の関係\nll ans=0;\n\nint rec(map<string,bool> m,ll sum){\n  bool fin=true;\n  map<string,bool>::iterator it = m.begin();\n  while(it != m.end()){\n    //cout << it->first << \" \" << it->second << endl;\n    fin*=it->second;  \n    it++;\n  }\n  if(fin){\n    if(ans < sum)ans=sum;\n    return 0;\n  }\n\n  map<string,bool> preUsed;\n  ll preSum=0;\n  it = m.begin();\n  while(it != m.end()){\n    if(!it->second){\n      preSum=sum;\n      preSum+=strength[it->first];\n      //cout << \"sum = \" << sum  << \", it->first = \" << it->first << endl;\n   \n      map<string,bool>::iterator preIt = m.begin();\n      while(preIt != m.end()){\n\tpreUsed[preIt->first]=preIt->second;\n\t//cout << preIt->first << \" \" << preIt->second << endl;\n\t++preIt;\n      }\n      multimap<string,string>::iterator cpyIt = adjacentCountry.find(it->first); \n     int counter = adjacentCountry.count(it->first);\n      //cout << \"coutner = \" << counter << endl;\n      while(counter-- > 0){\n\t//cout << \"cpyIt->first = \" << cpyIt->first << endl;\n\tpreUsed[cpyIt->second]=true;\n\t//cout << \"cpyIt->second =\" << cpyIt->second << endl;\n\t++cpyIt;\n      }\n      preUsed[it->first]=true;\n      /*\n  map<string,bool>::iterator wr = preUsed.begin();\n      while(wr != preUsed.end()){\n\tcout << wr->first << \" \" << wr->second << endl;\n\t++wr;\n      }\n      cout << \"----------------------------------------^w^----\" << endl;\n      */\n\n\n      rec(preUsed,preSum);\n    }\n\n    ++it;\n  }\n  \n\n\n\n\n}\n\n\nint main(){\n  int n,val,os;\n  string s,oc;\n  map<string,bool> used;\n  ll sum=0;\n\n  while(true){\n    scanf(\"%d\",&n);\n    if(n == 0)break;\n    ans=0;\n    used.clear();\n    adjacentCountry.clear();\n    strength.clear();\n    rep(i,n){\n      cin >> s;\n      scanf(\"%d %d\",&val,&os);\n      strength[s]=val;\n      if(!used[s])used[s]=false;\n      rep(j,os){\n\tcin >> oc;\n\tadjacentCountry.insert(multimap<string,string>::value_type(s,oc));      \n      }\n      \n      if(i == 0){\n\tsum = val;\n\tused[s]=true;\n\tmultimap<string,string>::iterator sit = adjacentCountry.begin();\n\t//cout << \"IN  ----------------------------\" << endl;\n\twhile(sit != adjacentCountry.end()){\n\t  used[sit->second]=true;\n\t  //cout << sit->second << \" \" <<used[sit->second] << endl;\n\t  ++sit;\n\t}\n\t//cout << \"OTU ========================\" << endl;\n\n      }\n      \n    }\n\n\n\n\n    /*\n    cout << \"-----------------\" << endl;\n    map<string,bool>::iterator it = used.begin();\n    while(it != used.end()){\n      cout << \"it->first = \" << it->first << endl;\n      cout << it->second << endl;\n      ++it;\n    }\n    cout << \"-------------------\" << endl;\n    */\n\n    rec(used,sum);\n    cout << ans << endl;\n    \n\n\n\n  }\n\nreturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if(ne & (1LL<<i) != 0) continue;\n        if(((ne | cs[i].ne) ^ (ne | (1<<i))) < 1LL){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n\n    queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.front().second.second;\n        power = pq.front().second.first;\n        int v = pq.front().first + 1;\n        pq.pop();\n        res = max(res, power);\n        if(v > n - 1) continue;\n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        \n        \n        ll nne = ne;\n        int npower = power;\n        for(int i = v + 1; i < n; i++){\n            if((nne & (1LL<<i)) != 0) continue;\n            if(((nne | cs[i].ne) ^ (nne | (1<<i))) < (1LL<<(v + 1))){\n                nne |= cs[i].ne;\n                npower += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(npower, nne)));\n        \n        \n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if(((ne | cs[i].ne) ^ (ne | (1LL<<i))) < (1LL<<(v + 1))){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nint solve(vector< vector<int> > &G, vector<int> &B, int v, long long int t){\n  if(v >= B.size()) return 0;\n  int ret = 0;\n  ret = max(ret, solve(G,B,v+1,t));\n  if(!(t>>v & 1)){\n    t |= 1LL<<v;\n    for(int i = 0; i < G[v].size(); ++i) t |= 1LL<<G[v][i];\n    ret = max(ret, B[v] + solve(G,B,v+1,t));\n  }\n  return ret;\n}\n\nint main(){\n  int N;\n  while(cin >> N, N){\n    map<string,int> M;\n    vector< vector<string> > D(N);\n    string a;\n    vector<int> B(N);\n    int c;\n    for(int i = 0; i < N; ++i){\n      cin >> a >> B[i] >> c;\n      M[a] = i;\n      string d;\n      for(int j = 0; j < c; ++j){\n        cin >> d;\n        D[i].push_back(d);\n      }\n    }\n    vector< vector<int> > G(N);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < D[i].size(); ++j){\n        G[i].push_back(M[D[i][j]]);\n      }\n    }\n    long long int t = 1LL;\n    for(int i = 0; i < G[0].size(); ++i) t |= 1LL<<G[0][i];\n    cout << B[0] + solve(G,B,0,t) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_N 41\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Country{\n  int index,power;\n  Country(int index=IINF,int power=IINF):index(index),power(power){}\n  bool operator < (const Country& c)const{ return power > c.power; }\n};\n\nint N,answer,V,sum[MAX_N];\null adj_bitmask[MAX_N],initial_bitmask;\nCountry c_list[MAX_N];\nmap<int,string> debug;\n\ninline void input(){\n  V = 0;\n  initial_bitmask = 1;\n  int dex = 0,i_tmp;\n  map<string,int> getIndex;\n  set<string> ban;\n  string s_tmp;\n  rep(i,N){\n    cin >> s_tmp >> i_tmp;\n    if( ban.find(s_tmp) != ban.end() ){\n      cin >> i_tmp;\n      rep(i,i_tmp)cin>>s_tmp;\n      continue;\n    }\n    if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n    int from = getIndex[s_tmp];\n    debug[from] = s_tmp;\n    if( from == 0 ) answer = i_tmp;\n    c_list[from] = Country(from,i_tmp);\n    adj_bitmask[from] = 0ULL;\n    cin >> i_tmp;\n    rep(j,i_tmp){\n      cin >> s_tmp;\n      if( from == 0 ){\n\tban.insert(s_tmp);\n\tcontinue;\n      }\n      if( ban.find(s_tmp) != ban.end() ) continue;\n      if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n      int to = getIndex[s_tmp];\n      adj_bitmask[from] |= (1<<to);\n    }\n  }\n  V = dex;\n}\n\nvoid dfs(int sp,int power,ull bitmask){\n\n  if( power + sum[sp] <= answer ) return;\n  answer = max(answer,power);\n  if( sp >= V ) return;\n   \n  REP(i,sp,V){\n    if( (bitmask>>c_list[i].index) & 1 ) continue;\n    if( bitmask & adj_bitmask[c_list[i].index] ) continue;\n    dfs(i+1,power+c_list[i].power,bitmask|adj_bitmask[c_list[i].index]);\n    break;\n  }\n\n}\n\nint main(){\n  while(cin>>N,N){\n    input();\n    sort(c_list,c_list+V);\n    rep(i,V)sum[i] = 0;\n    sum[V-1] = c_list[V-1].power;\n    for(int i=V-2;i>=0;i--) sum[i] = sum[i+1] + c_list[i].power;\n\n    dfs(0,answer,initial_bitmask);\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], ans;\n\nset<ll> memo;\n\nvoid dfs(ll S){\n\n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  int cnt=0, sum=0;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1<<i))) continue;\n\n    sum+=cost[i];\n    \n    for(int j=i+1;j<n;j++){\n      if(!(S&(1LL<<j))) continue;\n      if(!G[i][j]) cnt++;\n    }\n    \n  }\n\n  int node=__builtin_popcountll(S);\n\n  if(cnt==node*(node-1)/2){\n    \n    ans=max(ans,sum);\n    return ;\n  }\n\n  for(int i=1;i<n;i++){\n    \n    int nS=S;\n      \n    nS=nS&~(1LL<<i);\n\n    dfs(nS);\n      \n  }\n  \n}\n\nint main(){\n  \n  while(1)  {\n\n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cnt=0;\n\n    memset(G,0,sizeof(G));\n    \n    for(int i=0;i<n;i++){\n\n      string s;\n      cin>>s;\n\n      if(!num.count(s)) num[s]=cnt++;\n      \n      int a,b;\n      cin>>a>>b;\n      \n      cost[num[s]]=a;\n\n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n\n    ans=0;\n\n    memo.clear();\n    \n    dfs((1LL<<n)-1);\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nvector<i64> edges(n + 10, 0);\nvector<int> x(n + 10, 0);\nvector<int> sum(n + 10, 0);\nint result = 0;\nvoid dfs(int i, i64 bit, int now_sum) {\n  result = max(result, now_sum);\n  if (i == n)\n    return;\n  //枝刈り\n  if (now_sum + sum[i] <= result)\n    return;\n  // throw\n  dfs(i + 1, bit, now_sum);\n\n  if (!(bit & edges[i]))\n    dfs(i + 1, bit | (1LL << i), now_sum + x[i]);\n};\n\nint main(){\n    cin >> n;\n    while(n){\n        map<string,int> mp;\n        edges.assign(n + 10, 0);\n        x.assign(n + 10, 0);\n\n        auto get_i = [&](string& s){\n            if(mp.count(s)){\n                return  mp[s];\n            }\n            else{\n                mp[s] = mp.size();\n                return (int)mp.size() - 1;\n            }\n        };\n\n        for(int c = 0;c < n;c++){\n            string s;cin >> s;\n            int i = get_i(s);\n            int C;\n            cin >> x[i] >> C;\n            for(int d = 0;d < C;d++){\n                cin >> s;\n                edges[i] |= (1LL << get_i(s));\n            }\n        }\n\n        sum.assign(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        result = 0;\n        dfs(1,1,x[0]);\n        cout << result;\n        cin >> n;\n        if(n) cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <filesystem>\nusing namespace std;\ntypedef long long ll;\n\nint id[40];\nint G[40][40];\nstring name[40];\nint B[40];\nvector<string> D[40];\nint N;\nint ans;\nmap<string, int> m;\n\nvoid f(int n, ll mask, int sum) {\n\tif(n == N) {\n\t\t/*for(int i = 0; i < N; i++) {\n\t\t\tif(mask >> i & 1) cout << name[i] << \" \";\n\t\t}\n\t\tcout << endl;*/\n\t\tans = max(ans, sum);\n\t\treturn;\n\t}\n\n\tint tsum = 0;\n\tfor(int i = n; i < N; i++) {\n\t\ttsum += B[id[i]];\n\t}\n\tif(sum + tsum <= ans) return;\n\n\tbool canUse = true;\n\tfor(int i = 0; i < N; i++) {\n\t\tif((mask >> id[i] & 1) && G[m[name[id[n]]]][m[name[id[i]]]]) {\n\t\t\tcanUse = false;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif(canUse) {\n\t\tf(n + 1, mask | (1LL << id[n]), sum + B[id[n]]);\n\t}\n\n\tf(n + 1, mask, sum);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\twhile(cin >> N, N) {\n\t\tm.clear();\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tcin >> name[i] >> B[i];\n\t\t\tm[name[i]] = i;\n\t\t\tint C;\n\t\t\tcin >> C;\n\t\t\tD[i].assign(C, \"\");\n\t\t\tfor(int j = 0; j < C; j++) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tint myPow = B[0];\n\t\tB[0] = 1e9;\n\n\t\ttypedef pair<int, int> P;\n\t\tvector<P> p;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tp.push_back({ B[i], i });\n\t\t}\n\t\tsort(p.begin(), p.end());\n\t\treverse(p.begin(), p.end());\n\n\t\tB[0] = myPow;\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tid[i] = p[i].second;\n\t\t}\n\n\t\tmemset(G, 0, sizeof G);\n\t\tfor(int i = 0; i < N; i++) {\n\t\t\tfor(auto s : D[i]) {\n\t\t\t\tG[m[name[i]]][m[s]] = G[m[s]][m[name[i]]] = 1;\n\t\t\t}\n\t\t}\n\n\t\tans = 0;\n\t\tf(1, 1, B[0]);\n\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\nmap<string,int> id;\nmap<string,long long> bit;\nmap<long long, long long> memo;\nint n;\nstring a[50], d[50][50];\nint b[50], c[50];\n\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nint dfs(long long used){\n\tif(memo.count(used)) return memo[used];\n\n\tint res = 0;\n\trep(i,n){\n\t\tif(getBit(used,i)) continue;\n\t\t\n\t\tlong long next = used bitor bit[a[i]];\n\t\tres = max(res, dfs(next) + b[i]);\n\t}\n\n\treturn memo[used] = res;\n}\n\nint main(){\n\twhile(cin >> n,n){\n\t\tid.clear();\n\t\tbit.clear();\n\t\tmemo.clear();\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tid[a[i]] = i;\n\t\t\trep(j,c[i]){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tlong long near = setBit(0,i);\n\t\t\trep(j,c[i]){\n\t\t\t\tnear = setBit(near, id[d[i][j]]);\n\t\t\t}\n\t\t\tbit[a[i]] = near;\n\t\t}\n\n\n\t\tcout << dfs(bit[a[0]]) + b[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint country2idx(map<string,int>& dict,string country){\n  int idx = dict.size();\n  if(dict.find(country) == dict.end()){\n    dict[country] = idx;\n    return idx;\n  }\n  return dict[country];\n}\n\nvector<int> edges[41];\nbool used[41];\nbool visited[41];\nint power[41];\n\nbool can_unite(int node){\n  for(int i=0;i<edges[node].size();i++){\n    if(used[edges[node][i]]) return false;\n  }\n  return true;\n}\n\nint dfs(int current,int sum){\n  int res = sum;\n  for(int i = 0; i < edges[current].size();i++){\n    int next = edges[current][i];\n    if(visited[next]) continue;\n    if(can_unite(next)){\n      used[next] = true;\n      visited[next] = true;\n      res = max(res,dfs(next,sum + power[next]));\n      used[next] = false;\n      visited[next] = false;\n    }\n    else{\n      visited[next] = true;\n      res = max(res,dfs(next,sum));\n      visited[next] = false;\n    }\n  }\n  return res;\n}\n\nclass UnionFindTree {\nprivate:\n  int parent[41];\n  int rank[41];\npublic:\n  UnionFindTree(){\n    for(int i = 0; i <= 40; i++){\n      parent[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  void unite(int lhs,int rhs) {\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(lhs == rhs) return;\n    \n    if(rank[lhs] < rank[rhs]){\n      parent[rhs] = lhs;\n      rank[rhs]++;\n    }\n    else{\n      parent[lhs] = rhs;\n      rank[lhs]++;\n    }\n  }\n\n  int find(int current){\n    if(current == parent[current]) return current;\n    else find(parent[current]);\n  }\n};\n\nint main(){\n  int N;\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    for(int i = 0; i <= 40; i++){\n      edges[i].clear();\n    }\n    UnionFindTree uft;\n    map<string,int> dict;\n    for(int country_i = 0; country_i < N; country_i++){\n      string country;\n      int tmp_power;\n      cin >> country >> tmp_power;\n      int adjacent_countries;\n      cin >> adjacent_countries;\n\n      int root = country2idx(dict,country);\n      power[root] = tmp_power;\n      for(int adj_i = 0; adj_i < adjacent_countries; adj_i++){\n        string adj_country;\n        cin >> adj_country;\n        int child = country2idx(dict,adj_country);\n        edges[root].push_back(child);\n        uft.unite(root,child);\n      }\n    }\n\n    bool tree[41];\n    memset(tree,false,sizeof(tree));\n\n    int res = 0;\n    for(int i = 0; i < N; i++){\n      if(tree[uft.find(i)]) continue;\n      tree[uft.find(i)] = true;\n      int tmp = 0;\n      for(int j = 0; j < N; j++){\n        if(uft.find(j) != uft.find(i)) continue;\n        memset(used,false,sizeof(used));\n        memset(visited,false,sizeof(visited));\n        if(i == 0){\n          used[0] = true;\n          visited[0] = true;\n          tmp = max(tmp,dfs(0,power[0]));\n          break;\n        }\n        else{\n          used[j] = true;\n          visited[j] = true;\n          tmp = max(tmp,dfs(j,power[j]));\n        }\n      }\n      res += tmp;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define MAX_N 45\ntypedef long long ll;\n\nint n;\nmap<string,int> mp;\nvector<string> g[MAX_N];\nvector<int> G[MAX_N];\nint a[MAX_N];\nll S[MAX_N];\nint total;\nint ans=0;\n\nstring change(ll x){\n  string res=\"\";\n  for(int i=0;i<n;i++){\n    if(x>>i&1)res.push_back('1');\n    else res.push_back( '0' );\n  }\n  reverse(res.begin(),res.end());\n  return res;\n}\n\nvoid init(){\n  total=ans=0;\n  mp.clear();\n  for(int i=0;i<MAX_N;i++){\n    g[i].clear();\n    G[i].clear();\n  }\n}\n\nvoid solve(int k,int sum,ll bit,ll bit2){\n  if(k==n){\n    //    string str=change(bit);\n    //    cout<<str<<' '<<sum<<endl;\n    ans=max(ans,sum);\n    return;\n  }\n  if(k)solve(k+1,sum,bit,bit2);\n  if((bit>>k)&1)return;\n  bit+=(1LL<<k);\n  bit2|=S[k];\n  if(bit&bit2)return;\n  solve(k+1,sum+a[k],bit,bit2);\n}\n\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    init();\n    for(int i=0;i<n;i++){\n      string str,to;\n      int k;\n      cin>>str>>a[i]>>k;\n      mp[str]=i;\n      total+=a[i];\n      for(int j=0;j<k;j++){\n\tcin>>to;\n\tg[i].push_back(to);\n      }\n    }\n    for(int i=0;i<n;i++){\n      S[i]=0;\n      for(int j=0;j<(int)g[i].size();j++){\n\tG[i].push_back(mp[g[i][j]]);\n\tS[i]+= (1LL<< (G[i].back()));\n      }\n    }\n    solve(0,0,0,0);\n    cout<<ans<<endl;\n  }  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if(ne & (1LL<<i) != 0) continue;\n        if((ne | cs[i].ne) == (ne | (1LL<<i))){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n\n    priority_queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.top().second.second;\n        power = pq.top().second.first;\n        int v = pq.top().first + 1;\n        pq.pop();\n        res = max(res, power);\n        //cout << v << \":\" << ne << \":\" << power << endl;\n        if(v > n - 1) continue;\n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        pq.push(data(v, pair<int, ll>(power, ne)));\n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if((ne | cs[i].ne) == (ne | (1LL<<i))){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = 1 << 21;\nint X[MAX], Y[MAX], cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tvector<vector<bool>> E(N, vector<bool>(N));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << A[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1LL << n;\n\t\t\tint NY = 1LL << (N - n);\n\t\t\tvector<int> X(NX), Y(NY);\n\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nmask = mask | (1 << i);\n\t\t\t\t\tdp[nmask] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tint tmp = dp[mask];\n\n\t\t\t\tx -= tmp;\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tint N;\n\tvector<int> ps;\n\tvector<vector<int>> es;\n\tvector<bool> canselect;\n\t//vector<int> fillc;\n\n\tint Mv;\t\n\tint must;\n\n\tvector<bool> change;\n\tvoid dfs(int v,int val){\n\t\t//DUMP(v);\n\t\tMv=max(Mv,val);\n\t\tif(v>=N)return;\n\t\t//if(val+fillc[v]<=Mv)return;\n\t\tif(canselect[v]){\n\t\t\tvector<int> change;\n\t\t\tselect(v,change);\n\t\t\tdfs(v+1,val+ps[v]);\n\t\t\tunselect(v,change);\n\t\t\t//周りが全て固定されていれば未選択の必要はない\n\t\t\tif(!allfixed(v))dfs(v+1,val);\n\t\t}else{\n\t\t\tdfs(v+1,val);\n\t\t}\n\t}\n\n\tbool allfixed(int v){\n\t\tREP(i,es[v].size())if(es[v][i]>v)return false;\n\t\treturn true;\n\t}\n\n\tvoid select(int v,vector<int>& change){\n\t\tcanselect[v]=false;\n\t\tREP(i,es[v].size()){\n\t\t\tif(canselect[es[v][i]]){\n\t\t\t\tcanselect[es[v][i]]=false;\n\t\t\t\tchange.push_back(es[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid unselect(int v,vector<int>& change){\n\t\tcanselect[v]=true;\n\t\tREP(i,change.size())canselect[change[i]]=true;\n\t}\n\n\tvoid run(){\n\t\t//ifstream fin(\"in\" );\n\t\t//ofstream fout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >>N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> cs(N);\n\t\t\tmap<string,int> stoid;\n\t\t\tps=vector<int>(N);\n\t\t\tvector<vector<string>> ess(N);\n\t\t\tREP(i,N){\n\t\t\t\tcin >> cs[i] >> ps[i];stoid.insert(make_pair(cs[i],i));\n\t\t\t\t\n\t\t\t\tint k;cin >>k;\n\t\t\t\tREP(j,k) {\n\t\t\t\t\tstring s;cin >> s;ess[i].push_back(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tes=vector<vector<int>>(N);\n\t\t\tREP(i,N)REP(j,ess[i].size())es[i].push_back(stoid[ess[i][j]]);\n\t\t\n\t\t\tcanselect=vector<bool>(N,true);\n\t\t\t// fillc=vector<int>(N+1);\n\t\t\t// for(int i=N-1;i>=0;i--)fillc[i]+=fillc[i+1]+ps[i];\n\n\t\t\t//自分\n\t\t\tvector<int> dummy;\n\t\t\tmust=ps[0];select(0,dummy);\n\t\t\t//孤立点\n\t\t\tREP(i,N)if(canselect[i] && es[i].size()==0){must+=ps[i];select(i,dummy);}\n\t\t\t\n\t\t\tMv=must;\n\t\t\tdfs(0,must);\n\n\t\t\tcout<< Mv<<endl;\n\t\t}\n\t}\n};\n int main(){\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll, ll> l_l;\ntypedef pair<int, int> i_i;\ntemplate<class T>\ninline bool chmax(T &a, T b) {\n    if(a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\ntemplate<class T>\ninline bool chmin(T &a, T b) {\n    if(a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nconst long double EPS = 1e-10;\nconst long long INF = 1e18;\nconst long double PI = acos(-1.0L);\n//const ll mod = 1000000007;\nll N;\nvector<string> A;\nvector<ll> B, C;\nvector<vector<string>> D;\nvector<vector<int>> paths;\nvector<ll> adjcent;\n\nvector<ll> dp;\n\nvoid solve() {\n    A.resize(N);\n    B.resize(N);\n    C.resize(N);\n    D.resize(N);\n    paths.resize(N);\n    adjcent.resize(N);\n    for(int i = 0; i < N; i++) {\n        paths[i].resize(N);\n        adjcent[i] = (1LL << N) - 1;\n        for(int j = 0; j < N; j++) {\n            paths[i][j] = 0;\n        }\n        cin >> A[i] >> B[i] >> C[i];\n        D[i].resize(C[i]);\n        for(int j = 0; j < C[i]; j++) {\n            cin >> D[i][j];\n        }\n    }\n    for(int i = 0; i < N; i++) {\n        adjcent[i] ^= (1LL << i);\n        for(int j = 0; j < N; j++) {\n            for(int k = 0; k < C[i]; k++) {\n                if(D[i][k] == A[j]) {\n                    paths[i][j] = 1;\n                    adjcent[i] ^= (1LL << j);\n                }\n            }\n        }\n        //cerr << i << \" \" << bitset<20>(adjcent[i]) << endl;\n    }\n    ll Main = (N + 1) / 2;\n    ll Rest = N - Main;\n    dp.resize((1 << Rest), -1e18);\n    for(ll bits = 0; bits < (1LL << Rest); bits++) {\n        dp[bits] = -1e18;\n        bool ok = false;\n        ll Bsum = 0;\n        ll checker = (1LL << N) - 1;\n        for(int i = 0; i < Rest; i++) {\n            if(!(bits & (1 << i))) continue;\n            Bsum += B[i+Main];\n            checker &= adjcent[i+Main] | (1LL << (i+Main));\n        }\n        ok = ((checker >> Main) & bits) == bits;\n        if(ok) chmax(dp[bits], Bsum);\n        for(int i = 0; i < Rest; i++) {\n            if(bits & (1 << i)) chmax(dp[bits], dp[bits ^ (1 << i)]);\n        }\n        //cerr << bits << \" \" << checker << \" \" << dp[bits] << endl;\n    }\n    ll ans = 0;\n    for(ll bits = 0; bits < (1 << Main); bits++) {\n        if(!(bits & 1LL)) continue;\n        ll Bsum = 0;\n        ll to = (1LL << N) - 1;\n        for(int i = 0; i < Main; i++) {\n            if(!(bits & (1LL << i))) continue;\n            Bsum += B[i];\n            //cerr << bits << \" \" << i << \" \" << adjcent[i] << \" \" << to << endl;\n            to &= (adjcent[i] | (1LL << i));\n            //cerr << bits << \" \" << i << \" \" << adjcent[i] << \" \" << to << endl;\n        }\n        //cerr << bits << \" \" << bitset<20>(to) << endl;\n        if((to & ((1 << Main) - 1) & bits) != bits) Bsum = -1e18;\n        chmax(ans, Bsum + dp[(to >> Main)]);\n    }\n    cout << ans << endl;\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(cin >> N) {\n        if(N == 0) break;\n        solve();\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define ll long long\n#define INF 1000000005\n#define MOD 1000000007\n#define EPS 1e-10\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;--i)\n#define srep(i,s,t) for(int i=(int)(s);i<(int)(t);++i)\n#define each(a,b) for(auto (a): (b))\n#define all(v) (v).begin(),(v).end()\n#define len(v) (int)(v).size()\n#define zip(v) sort(all(v)),v.erase(unique(all(v)),v.end())\n#define cmx(x,y) x=max(x,y)\n#define cmn(x,y) x=min(x,y)\n#define fi first\n#define se second\n#define pb push_back\n#define show(x) cout<<#x<<\" = \"<<(x)<<endl\n#define spair(p) cout<<#p<<\": \"<<p.fi<<\" \"<<p.se<<endl\n#define svec(v) cout<<#v<<\":\";rep(kbrni,v.size())cout<<\" \"<<v[kbrni];cout<<endl\n#define sset(s) cout<<#s<<\":\";each(kbrni,s)cout<<\" \"<<kbrni;cout<<endl\n#define smap(m) cout<<#m<<\":\";each(kbrni,m)cout<<\" {\"<<kbrni.first<<\":\"<<kbrni.second<<\"}\";cout<<endl\n\nusing namespace std;\n\ntypedef pair<int,int> P;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<P> vp;\ntypedef vector<string> vs;\n\nconst int MAX_N = 100005;\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0){\n            break;\n        }\n        int mid = n/2;\n        vi p(n),c(n);\n        vector<vs> s(n);\n        int id = 0;\n        map<string,int> mp;\n        rep(i,n){\n            string t;\n            cin >> t >> p[i] >> c[i];\n            mp[t] = id++;\n            s[i].resize(c[i]);\n            rep(j,c[i]){\n                cin >> s[i][j];\n            }\n        }\n        vi st(mid),ed(n-mid),se(mid);\n        vi sout((1 << mid),0);\n        rep(i,mid){\n            st[i] = (1 << i);\n            rep(j,c[i]){\n                int num = mp[s[i][j]];\n                if(num >= mid){\n                    se[i] |= (1 << (num-mid));\n                }else{\n                    st[i] |= (1 << num);\n                }\n            }\n        }\n        rep(i,n-mid){\n            ed[i] = (1 << i);\n            rep(j,c[i+mid]){\n                int num = mp[s[i+mid][j]];\n                if(num >= mid){\n                    ed[i] |= (1 << (num-mid));\n                }\n            }\n        }\n        vector<bool> dst((1 << mid),false),ded((1 << (n-mid)),false);\n        vi mx((1 << (n-mid)),0);\n        vi p1((1 << mid),0),p2((1 << (n-mid)),0);\n        dst[0] = true;\n        rep(i,(1 << mid)){\n            if(dst[i]){\n                rep(j,mid){\n                    if(!((i >> j) & 1)){\n                        sout[i^(1 << j)] = sout[i] | se[j];\n                        dst[i^(1 << j)] = true;\n                    }else{\n                        p1[i] += p[j];\n                    }\n                }\n            }\n        }\n        ded[0] = true;\n        rep(i,(1 << (n-mid))){\n            if(ded[i]){\n                rep(j,n-mid){\n                    if(!((i >> j) & 1)){\n                        ded[i^(1 << j)] = true;\n                    }else{\n                        p2[i] += p[j+mid];\n                    }\n                }\n                mx[i] = p2[i];\n            }else{\n                rep(j,n-mid){\n                    if((i >> j) & 1){\n                        cmx(mx[i],mx[i^(1 << j)]);\n                    }\n                }\n            }\n        }\n        int ans = 0;\n        rep(i,(1 << mid)){\n            if((i & 1) && dst[i]){\n                cmx(ans,p1[i] + mx[((1 << (n-mid))-1) ^ sout[i]]);\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <string>\n#include <map>\n#include <vector>\n#include <iostream>\n#include <cstring>\n\nusing namespace std;\n\nint n;\nmap<string,int> id;\nvector<int> G[51];\nint p[51];\nint ng[51];\nint ng2[51];\nint dp[1<<21];\nint main(void){\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tid.clear();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tG[i].clear();\n\t\t}\n\t\tmemset(ng,0,sizeof(ng));\n\t\tmemset(ng2,0,sizeof(ng2));\n\t\tfor(int i=0;i<n;i++){\n\t\t\tstring a;\n\t\t\tint b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif(id.find(a)==id.end())id[a]=(int)id.size()-1;\n\t\t\tp[id[a]]=b;\n\t\t\tfor(int i=0;i<c;i++){\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif(id.find(d)==id.end())id[d]=(int)id.size()-1;\n\t\t\t\tG[id[a]].push_back(id[d]);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<G[i].size();j++){\n\t\t\t\tif(G[i][j]<(n/2)){\n\t\t\t\t\tng[i]+=(1<<G[i][j]);\n\t\t\t\t}else{\n\t\t\t\t\tng2[i]+=1<<(G[i][j]-n/2);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint rest=n-n/2;\n\t\tmemset(dp,-1,sizeof(dp));\n\t\tfor(int i=0;i<(1<<(n/2));i++){\n\t\t\tint flag2=0,sum=0;\n\t\t\tbool ok=true;\n\t\t\tif(!(i&1))continue;\n\t\t\tfor(int j=0;j<n/2;j++){\n\t\t\t\tif(i>>j & 1){\n\t\t\t\t\tif(i & ng[j])ok=false;\n\t\t\t\t\tflag2|=ng2[j];\n\t\t\t\t\tsum+=p[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok){\n\t\t\t\tdp[flag2]=max(dp[flag2],sum);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<(1<<rest);i++){\n\t\t\tfor(int j=i;j>0;j=(j-1)&i){\n\t\t\t\tdp[i]=max(dp[j],dp[i]);\n\t\t\t}\n\t\t}\n\t\tint res=0;\n\t\tfor(int i=0;i<(1<<rest);i++){\n\t\t\tint flag=0,sum=0;\n\t\t\tbool ok=true;\n\t\t\tfor(int j=0;j<rest;j++){\n\t\t\t\tif(i>>j & 1){\n\t\t\t\t\tif(i & ng2[n/2+j])ok=false;\n\t\t\t\t\tflag|=ng2[n/2+j];\n\t\t\t\t\tsum+=p[n/2+j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(ok && dp[(1<<rest)-1-i]>=0)res=max(res,sum+dp[(1<<rest)-1-i]);\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[45];\nbool G[45][45];\nint NG[45];\nint sum[45];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[fake] < beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0 && ~(bit >> idx) & 1) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9;\nint n, b[100], c[100], dp1[1 << 20], dp2[1 << 20], sum[1 << 20];\nstring name[100], d[100][100];\nbool e[100][100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(e, 0, sizeof(e));\n\t\tmap<string, int> id;\n\t\t\n\t\trep(i, n){\n\t\t\tcin >> name[i] >> b[i] >> c[i];\n\t\t\trep(j, c[i]) cin >> d[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, c[i]) e[i][id[d[i][j]]] = e[id[d[i][j]]][i] = 1;\n\t\t\n\t\tint N = n / 2, M = n - N;\n\t\trep(i, 1 << N) dp1[i] = -inf;\n\t\trep(i, 1 << M) dp2[i] = -inf, sum[i] = 0;\n\t\tdp1[1] = b[0]; dp2[0] = 0;\n\t\t\n\t\trep(i, 1 << N) if(dp1[i] != -inf) rep(j, N) if(!(i & 1 << j)){\n\t\t\tif(dp1[i | 1 << j] != -inf) continue;\n\t\t\trep(k, N) if((i & 1 << k) && e[j][k]) goto FAIL;\n\t\t\tdp1[i | 1 << j] = dp1[i] + b[j];\n\t\t\tFAIL:;\n\t\t}\n\t\t\n\t\trep(i, 1 << M) if(dp2[i] != -inf) rep(j, M) if(!(i & 1 << j)){\n\t\t\tif(dp2[i | 1 << j] != -inf) continue;\n\t\t\trep(k, M) if((i & 1 << k) && e[j + N][k + N]) goto FAIL2;\n\t\t\tdp2[i | 1 << j] = dp2[i] + b[j + N];\n\t\t\tFAIL2:;\n\t\t}\n\t\t\n\t\trep(i, 1 << M) rep(j, M) if(i & 1 << j) sum[i] += b[j + N];\n\t\t\n\t\tint ans = 0;\n\t\trep(i, 1 << N){\n\t\t\tint can = (1 << M) - 1;\n\t\t\trep(j, N) if(i & 1 << j) rep(k, M) if(e[j][k + N])\n\t\t\tcan &= ~(1 << k);\n\t\t\t\n\t\t\tif(dp1[i] + sum[can] <= ans) continue;\n\t\t\t\n\t\t\tfor(int j = can; ; j = j - 1 & can){\n\t\t\t\tans = max(ans, dp1[i] + dp2[j]);\n\t\t\t\tif(j == 0) break;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint r[64], p[64];\nInt f[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nvoid prepare(vector<int>& q) {\n    const int n = q.size();\n    vector<pair<int, int> > ps;\n    rep (i, n) ps.push_back(mp(C[q[i]], q[i]));\n    sort(ps.begin(), ps.end());\n    rep (i, n) r[i] = ps[n-1-i].second;\n    rep (i, n) p[i] = B[r[i]];\n    rep (i, n) {\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n}\n\nint rec(int n, int k, Int u) {\n    if (k == n) return 0;\n    rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return -INF;\n    int ans = -INF;\n    const int mask = (1LL<<n) - 1;\n    if (u&(1LL<<k)) ans = max(ans, rec(n, k+1, u&(mask-f[k])) + p[k]);\n    if (r[k]) ans = max(ans, rec(n, k+1, u&(mask-(1LL<<k))));\n    return ans;\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        ans += rec(q.size(), 0, (1LL<<q.size())-1);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint ans;\nint bs[114514];\nint cs[114514];\nchar buf[114514];\nbool used[114514];\nstring as[114514];\nvector<int> es[114514];\nvector<string> ds[114514];\nmap<string, int> rev;\n\nvoid calc(set<int> &vs, int sum) {\n  if (vs.empty()) {\n    ans = max(ans, sum);\n    return;\n  }\n\n  int v = *vs.begin();\n  vs.erase(v);\n  calc(vs, sum);\n  vector<int> restores;\n  for (int i=0; i<cs[v]; i++) {\n    int u = es[v][i];\n    if (vs.count(u)) {\n      restores.emplace_back(u);\n      vs.erase(u);\n    }\n  }\n  calc(vs, sum+bs[v]);\n  vs.insert(v);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n    rev.clear();\n    set<int> vs;\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      as[i] = buf;\n      rev[as[i]] = i;\n      scanf(\"%d\", &bs[i]);\n      scanf(\"%d\", &cs[i]);\n      ds[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        scanf(\" %s\", buf);\n        ds[i][j] = buf;\n      }\n    }\n  \n    for (int i=0; i<n; i++) {\n      es[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        es[i][j] = rev[ds[i][j]];\n      }\n      used[i] = false;\n      vs.insert(i);\n    }\n\n    vs.erase(0);\n    for (int u : es[0]) {\n      vs.erase(u);\n    }\n  \n    ans = 0;\n    calc(vs, bs[0]);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tvector<string> log;\n\tfor (; pos < names.size(); pos++) {\n\t\tif (used[names[pos].first])continue;\n\t\trest -= names[pos].second;\n\t\tused[names[pos].first] = 1;\n\t\tlog.push_back(names[pos].first);\n\t\tvector<string> c;\n\t\tint rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\trest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\trest = rest1;\n\t}\n\tfor (auto &a : log)used[a] = 0;\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tbmap.clear();\n\t\tans = 0;\n\t\tmb = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\t//vector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\t//list.push_back(a);\n\t\t\t\tbuf[name].push_back(a);\n\t\t\t\t//buf[a].push_back(name);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tused[names[0].first] = 1;\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tused[a] = 1;\n\t\t\tmb -= bmap[a];\n\t\t}\n\t\tdfs(1, names[0].second,mb-names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\n \n#define MAX 45\ntypedef long long ll;\ntypedef pair<int, ll> P;\n \nint get_node(string s, map<string, int> s2i)\n{\n    if (s2i.count(s) > 0) {\n        return s2i[s];\n    }\n    s2i[s] = s2i.size();\n    return s2i[s];\n}\n \nint N, B[MAX];\nbool ng_node[MAX], is_adj[MAX][MAX];\nmap<ll, int> memo;\n \nint dfs(int v, ll S)\n{\n    if (v == N) {\n        return 0;\n    }\n    int res = dfs(v+1, S);\n    if (!(S >> v & 1) && !is_adj[0][v]) {\n        bool ok = 1;\n        for (ll i = 0; i < (ll)N; i++) {\n            if ((S >> i & 1LL) && !ng_node[i]) {\n                if (is_adj[i][v]) {\n                    ok = 0;\n                    break;\n                }\n            }\n        }\n        if (ok) {\n            res = max(res, dfs(v+1, S|(1LL<<v)) + B[v]);\n        }\n    }\n    return res;   \n}\n \nint main()\n{\n    while (cin >> N, N) {\n        string A, D;\n        int C, sum = 0;\n        ll S = 0;      \n        vector<string> DG[MAX];\n         \n        map<string, int> s2i;\n         \n        memo.clear();\n        memset(is_adj, 0, sizeof(is_adj));\n        memset(ng_node, 0, sizeof(ng_node));\n         \n        for (int i = 0; i < N; i++) {\n            cin >> A >> B[i] >> C;\n            s2i[A] = i;\n            for (int j = 0; j < C; j++) {\n                cin >> D;\n                DG[i].push_back(D);\n            }\n        }\n \n        for (ll i = 0; i < (ll)N; i++) {\n            int len = DG[i].size();\n            if (len == 0) {\n                for (int j = 0; j < N; j++) {\n                    is_adj[i][j] = is_adj[j][i] = 1;\n                }\n                ng_node[i] = 1;\n                sum += B[i];\n                S |= 1LL<<i;\n            }\n            for (int j = 0; j < len; j++) {\n                ll t = s2i[DG[i][j]];\n                is_adj[i][t] = is_adj[t][i] = 1;\n            }\n        }\n         \n        cout << dfs(1, S|(1LL<<0)) + B[0] + sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n \nusing namespace std;\n \n#if __GNUC__\n#include <tr1/unordered_map>\n#include <tr1/unordered_set>\nusing namespace tr1;\n#else\n#include <unordered_map>\n#include <unordered_set>\n#endif\n\n#ifdef __GNUC__\ntemplate <class T> int popcount(T n);\ntemplate <> int popcount(unsigned int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(int n) { return __builtin_popcount(n); }\ntemplate <> int popcount(unsigned long long n) { return __builtin_popcountll(n); }\ntemplate <> int popcount(long long n) { return __builtin_popcountll(n); }\n#else\n#define __typeof__ decltype\ntemplate <class T> int popcount(T n) { return n ? 1 + popcount(n & (n - 1)) : 0; }\n#endif\n \n#define rep(i, n) for (int i = 0; i < (int)n; ++i)\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define rforeach(it, c) for (__typeof__((c).rbegin()) it=(c).rbegin(); it != (c).rend(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CL(arr, val) memset(arr, val, sizeof(arr))\n#define COPY(dest, src) memcpy(dest, src, sizeof(src))\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n \ntypedef long long ll;\ntypedef pair<int, int> pint;\n \ntemplate <class T> string to_s(const T& a) { ostringstream os; os << a; return os.str(); }\n \nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\nbool valid_pos(int x, int y, int w, int h) { return 0 <= x && x < w && 0 <= y && y < h; }\n \ntemplate <class T> void print(T a, int n, int br = 1, const string& deli = \", \") { cout << \"{ \"; for (int i = 0; i < n; ++i) { cout << a[i]; if (i + 1 != n) cout << deli; } cout << \" }\"; while (br--) cout << endl; }\ntemplate <class T> void print(const vector<T>& v, int br = 1, const string& deli = \", \") { print(v, v.size(), br, deli); }\ntemplate <class T> void print2d(T a, int w, int h, int width = -1, int br = 1) { for (int i = 0; i < h; ++i) { for (int j = 0; j < w; ++j) {\tif (width != -1) cout.width(width); cout << a[i][j] << ' ';\t} cout << endl; } while (br--) cout << endl; }\n \ntemplate <class T> void input(int n, T& a) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T, class U> void input(int n, T& a, U& b) { for (int i = 0; i < n; ++i) cin >> a[i] >> b[i]; }\n\n\n\nbool used[43];\n\nint m, force[43];\nll on[43];\nvoid init_subgraph(const vector<vector<int> >& g, const vector<int>& f, int s)\n{\n\tCL(on, 0);\n\tmap<int, int> id;\n\tid[s] = 0;\n\n\tqueue<int> q;\n\tq.push(s);\n\twhile (!q.empty())\n\t{\n\t\tint p = q.front();\n\t\tq.pop();\n\n\t\tused[p] = true;\n\n\t\tint no = id[p];\n\t\tforce[no] = f[p];\n\t\ton[no] = 1LL << no;\n\t\tfor (int i = 0; i < g[p].size(); ++i)\n\t\t{\n\t\t\tint t = g[p][i];\n\t\t\tif (!id.count(t))\n\t\t\t{\n\t\t\t\tid[t] = id.size();\n\t\t\t\tq.push(t);\n\t\t\t}\n\t\t\ton[no] |= 1LL << id[t];\n\t\t}\n\t}\n\n\tm = id.size();\n}\n\nint max_f;\nvoid dfs(int d, ll enemy, int sum)\n{\n\tif (d == m)\n\t{\n\t\tmax_swap(max_f, sum);\n\t\treturn;\n\t}\n\n\t{\n\t\tint rem = 0;\n\t\tfor (int i = d; i < m; ++i)\n\t\t\tif (!(enemy >> i & 1))\n\t\t\t\trem += force[i];\n\t\tif (sum + rem < max_f)\n\t\t\treturn;\n\t}\n\n\tif (!(enemy >> d & 1))\n\t\tdfs(d + 1, enemy | on[d], sum + force[d]);\n\tdfs(d + 1, enemy, sum);\n}\nint main()\n{\n\tios::sync_with_stdio(false);\n\n\tint n;\n\twhile (cin >> n, n)\n\t{\n\t\tCL(used, 0);\n\n\t\tvector<vector<int> > g(n);\n\t\tvector<int> f(n);\n\t\tmap<string, int> id;\n\n\t\trep (_, n)\n\t\t{\n\t\t\tstring a;\n\t\t\tint b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tif (!id.count(a))\n\t\t\t\tid[a] = id.size();\n\t\t\tint v = id[a];\n\t\t\tf[v] = b;\n\n\t\t\twhile (c--)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin >> d;\n\t\t\t\tif (!id.count(d))\n\t\t\t\t\tid[d] = id.size();\n\t\t\t\tint u = id[d];\n\t\t\t\tg[v].push_back(u);\n\t\t\t}\n\t\t}\n\n\t\tn = 40;\n\t\tg = vector<vector<int> >(n);\n\t\tf = vector<int>(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tf[i] = 3333;\n\t\t\tif (i + 1 != n)\n\t\t\t\tg[i].push_back(i + 1);\n\t\t}\n\n\n\t\tint res;\n\t\t\n\t\tinit_subgraph(g, f, 0);\n\t\tmax_f = 0;\n\t\tdfs(1, on[0], force[0]);\n\t\tres = max_f;\n\n\t\tfor (int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif (!used[i])\n\t\t\t{\n\t\t\t\tinit_subgraph(g, f, i);\n\t\t\t\tmax_f = 0;\n\t\t\t\tdfs(0, 0, 0);\n\t\t\t\tres += max_f;\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\nvector<int> G2[N];\n\nset<ll> memo;\n\nvoid dfs(int x,int sum,ll S){\n  \n  for(int i=0;i<G2[x].size();i++){\n    \n    int f=0, nx=G2[x][i];\n    \n    for(int j=0;j<n;j++)\n      if((S&(1<<j))&&G[j][nx]) f=1;\n    \n    if(!f){\n      \n      ll nS=S;\n      \n      nS|=(1<<nx);\n      \n      //      if(memo.count(nS)) continue;\n  \n      //      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[nx]);\n      \n      dfs(x+1,sum+cost[nx],nS);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    for(int i=0;i<n;i++)\n      for(int j=i+1;j<n;j++)\n\tif(!G[i][j]){\n\t  G2[i].push_back(j);\n\t  G2[j].push_back(i);\n\t}\n\t  \n    ans=cost[0];\n    \n    ll S=(1<<0);\n\n    dfs(1,cost[0],S);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tvector<vector<bool>> E(N, vector<bool>(N));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << A[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1LL << n;\n\t\t\tint NY = 1LL << (N - n);\n\t\t\tvector<int> X(NX), Y(NY);\n\n\n\t\t\tvector<bool> indx(NX, true);\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvector<bool> indy(NY, true);\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<int> cost(NY);\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvector<int> dp(NX);\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tint nmask = mask | (1 << i);\n\t\t\t\t\tdp[nmask] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tint tmp = dp[mask];\n\n\t\t\t\tx -= tmp;\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\n\nint main(){\n    cin >> n;\n    while(n){\n        map<string,int> mp;\n        vector<i64> edges(n + 10,0);\n        vector<int> x(n + 10,0);\n\n        auto get_i = [&](string& s){\n            if(mp.count(s)){\n                return  mp[s];\n            }\n            else{\n                mp[s] = mp.size();\n                return mp[s];\n            }\n        };\n\n        for(int c = 0;c < n;c++){\n            string s;cin >> s;\n            int i = get_i(s);\n            int C;\n            cin >> x[i] >> C;\n            for(int d = 0;d < C;d++){\n                cin >> s;\n                edges[i] |= (1LL << get_i(s));\n            }\n        }\n\n        vector<int> sum(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        int result = 0;\n        function<void(i64,i64,int)> dfs = [&](int i,i64 bit,int now_sum){\n            result = max(result , now_sum);\n            if(i == n) return;\n            //枝刈り\n            if(now_sum + sum[i] <= result) return;\n            //throw\n            dfs(i + 1,bit,now_sum);\n\n            if(!(bit & edges[i])) dfs(i + 1,bit | (1LL << i),now_sum + x[i]);\n        };\n        dfs(1,1,x[0]);\n        cout << result;\n        cin >> n;\n        if(n) cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <iostream>\n#include <tuple>\n#include <utility>\n#include <cassert>\n#include <bitset>\n#include <map>\n#include <climits>\nusing namespace std;\n \n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n \n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n \ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n \n// 無向非連結グラフの最大独立集合 (maximal independent set)\n// 頂点の集合 V であって、V の任意の 2 つをつなぐ辺が存在しない場合\n// 次数 1 であれば必ず採用・そうでなければ次数が大きいものから試す、\n// とすると枝刈りがきいて高速になる\n \nconst int GRAPH_SIZE = 40;\nusing gbit = bitset<GRAPH_SIZE>;\n \nnamespace std {\n    bool operator<(const gbit &a, const gbit &b) {\n        gbit mask(ULONG_MAX);\n        gbit aa = a, bb = b;\n        while(1) {\n            unsigned long long va, vb;\n            va = (aa & mask).to_ullong();\n            vb = (bb & mask).to_ullong();\n            if(va != vb) return va < vb;\n            if(va == 0 and vb == 0) return 0;\n            aa >>= 64, bb >>= 64;\n        }\n    }\n}\n \ntemplate <typename CostType = int>\nstruct MaximalIndependentSet {   \n    Graph<int> G;\n    int N; vector<CostType> costs;\n    gbit alive;\n    vector<gbit> adj;\n    bool weighted;\n    map<gbit, CostType> rec;\n \n    // 無向グラフを入力として与える\n    MaximalIndependentSet(Graph<int> G_,\n                          vector<CostType> costs_ = vector<CostType>())\n        : G(G_), costs(costs_) {\n \n        N = G_.size();\n        if(costs.size() != N) {\n            costs = vector<CostType>(N, 1);\n            weighted = false;\n        }\n        else weighted = true;\n    \n        alive = gbit();\n        adj = vector<gbit>(N);\n \n        for(int i=0; i<N; i++) {\n            alive[i] = true;\n            for(auto e : G[i]) adj[i][e.to] = 1;\n        }\n    }\n \n    inline int deg(int v) {\n        return (alive & adj[v]).count();\n    }\n \n    // その時点で次数最大の頂点を見つける\n    int argmax_deg() {\n        int max_deg = -1, res = -1;\n        for(int i=0; i<N; i++) {\n            if(!alive[i]) continue;\n            int d = deg(i);\n            if(d > max_deg) max_deg = d, res = i;\n        }\n        return res;\n    }\n \n    pair< CostType, gbit > solve_part1() {\n        CostType d = 0; gbit res;\n        // 次数 0 または 1 の頂点を全部見つける\n        // 重みがある場合は 0 のみ\n        for(int i=0; i<N; i++) {\n            if(alive[i] and !res[i] and deg(i) <= !weighted) {\n                res[i] = true; d += costs[i];\n                res |= (alive & adj[i]);\n            }\n        }\n        return make_pair(d, res);\n    }\n \n    CostType solve_part2() {\n        int v = argmax_deg(); CostType res = 0;\n        if(v < 0) return CostType(0);\n         \n        // v を使わない\n        alive[v] = false;\n        res = max(res, solve());\n \n        // v を使う\n        gbit vs = alive & adj[v];\n        alive ^= vs;\n        res = max(res, solve() + costs[v]);\n        alive ^= vs;\n \n        alive[v] = true;\n        return res;\n    }\n \n    CostType solve() {\n        if(rec.count(alive)) return rec[alive];\n         \n        CostType v1; gbit vs;\n        tie(v1, vs) = solve_part1();\n        alive ^= vs;\n        CostType v2 = solve_part2();\n        alive ^= vs;\n        return rec[alive] = v1 + v2;\n    }\n};\n \n \nvoid CODE_THANKS_FESTIVAL_2017_G() {\n    int N, M; scanf(\"%d%d\", &N, &M);\n    Graph<int> G(N);\n    for(int i=0; i<M; i++) {\n        int u, v;\n        scanf(\"%d%d\", &u, &v); u--; v--;\n        G[u].emplace_back(v, 1);\n        G[v].emplace_back(u, 1);\n    }\n \n    MaximalIndependentSet<> miset(G);\n    printf(\"%d\\n\", miset.solve());\n}\n \nvoid AOJ2403() {\n    auto solve_testcase = [&]() {\n        int N; cin >> N;\n        if(N == 0) return 1;\n \n        map<string, int> comp;\n        vector<string> A(N); vector< vector<string> > D(N);\n        vector<int> B(N);\n \n        for(int i=0; i<N; i++) {\n            int k; cin >> A[i] >> B[i] >> k;\n            comp[ A[i] ]++;\n            for(int j=0; j<k; j++) {\n                string s; cin >> s;\n                D[i].emplace_back(s);\n                comp[s]++;\n            }\n        }\n \n        int id = 0;\n        for(auto &e : comp) e.second = id++;\n \n        vector<int> costs(N), used(N);\n \n        // 自分の国の隣は選べないため\n        for(auto s : D[0]) {\n            int v = comp[s];\n            used[v] = true;\n        }\n         \n        Graph<int> G(N);\n        for(int i=0; i<N; i++) {\n            int u = comp[ A[i] ];\n            if(used[u]) continue;\n            costs[u] = B[i];\n \n            // 対称らしいので片方だけでいい\n            // 自分の国の隣は選べないので辺を張らない\n            for(auto s : D[i]) {\n                int v = comp[s];\n                if(!used[v]) G[u].emplace_back(v, 1);\n            }\n        }\n \n        MaximalIndependentSet<> miset(G, costs);\n        cout << miset.solve() << endl;\n        return 0;\n    };\n \n    while(!solve_testcase());\n}\n \nint main() {\n    // CODE_THANKS_FESTIVAL_2017_G();\n    AOJ2403();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n#include <bitset>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint l2(uint64_t bit) {\n  int res = 0;\n  res += (bit & UINT64_C(0xFFFFFFFF00000000)) ? 32 : 0;\n  res += (bit & UINT64_C(0xFFFF0000FFFF0000)) ? 16 : 0;\n  res += (bit & UINT64_C(0xFF00FF00FF00FF00)) ? 8 : 0;\n  res += (bit & UINT64_C(0xF0F0F0F0F0F0F0F0)) ? 4 : 0;\n  res += (bit & UINT64_C(0xCCCCCCCCCCCCCCCC)) ? 2 : 0;\n  res += (bit & UINT64_C(0xAAAAAAAAAAAAAAAA)) ? 1 : 0;\n  return res;\n}\n\nint s(uint64_t rem, int sum, int mx_sum, const vector<uint64_t>& g, const vector<int>& strngth, int n) {\n  if (rem == 0) return sum;\n  int mx_prob = sum;\n  REP(i,n) {\n    if (((rem >> i) & 1) == 0) continue;\n    mx_prob += strngth[i];\n    if ((rem & g[i]) == 0) {\n      sum += strngth[i];\n      rem ^= UINT64_C(1) << i;\n    }\n  }\n  if (mx_sum >= mx_prob) return sum;\n  mx_sum = max(mx_sum, sum);\n  if (rem == 0) return sum;\n  uint64_t next = rem & (-rem);\n  int ni = l2(next);\n  uint64_t used = (rem ^ next) & ~g[ni];\n  int usum = s(used, sum + strngth[ni], mx_sum, g, strngth, n);\n  mx_sum = max(mx_sum, usum);\n  uint64_t unused = rem ^ next;\n  int uusum = s(unused, sum, mx_sum, g, strngth, n);\n  return max(usum, uusum);\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    vector<string> cntry;\n    vector<int> strngth;\n    vector<vector<string>> neigh(n);\n    REP(i,n){\n      string a;\n      int b,c;\n      cin>>a>>b>>c;\n      cntry.push_back(a);\n      strngth.push_back(b);\n      REP(j,c){\n        string ng;\n        cin>>ng;\n        neigh[i].push_back(ng);\n      }\n    }\n    vector<uint64_t> g(n,0);\n    REP(i,n){\n      for(string& ng:neigh[i]){\n        auto itr = find(begin(cntry),end(cntry),ng);\n        uint64_t index = itr - begin(cntry);\n        g[i] |= UINT64_C(1) << index;\n      }\n    }\n    uint64_t rem = (UINT64_C(1)<<n)-1;\n    rem ^= UINT64_C(1) | g[0];\n    int res = s(rem, strngth[0], strngth[0], g, strngth, n);\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// g++ -std=c++11 a.cpp\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>   \n#include<map>\n#include<set>\n#include<unordered_map>\n#include<utility>\n#include<cmath>\n#include<random>\n#include<cstring>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<cstdio>\n#include<sstream>\n#include<iomanip>\n#include<assert.h>\n#include<typeinfo>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define FOR(i,a) for(auto i:a)\n#define pb push_back\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\nusing namespace std;\n//kaewasuretyuui\ntypedef long long ll;\n//#define int ll\ntypedef int Def;\ntypedef pair<Def,Def> pii;\ntypedef vector<Def> vi;\ntypedef vector<vi> vvi;\ntypedef vector<pii> vp;\ntypedef vector<vp> vvp;\ntypedef vector<string> vs;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef pair<Def,pii> pip;\ntypedef vector<pip>vip;\n#define mt make_tuple\ntypedef tuple<int,int,int,int> tp;\ntypedef vector<tp> vt;\ntemplate<typename A,typename B>bool cmin(A &a,const B &b){return a>b?(a=b,true):false;}\ntemplate<typename A,typename B>bool cmax(A &a,const B &b){return a<b?(a=b,true):false;}\n//template<class C>constexpr int size(const C &c){return (int)c.size();}\n//template<class T,size_t N> constexpr int size(const T (&xs)[N])noexcept{return (int)N;}\nconst double PI=acos(-1);\nconst double EPS=1e-9;\nDef inf = sizeof(Def) == sizeof(long long) ? 2e18 : 1e9+10;\nint dx[]={0,1,0,-1};\nint dy[]={1,0,-1,0};\n\nint n;\nint main(){\n\twhile(cin>>n,n){\n\t\tmap<string,int>ma;\n\t\tvs name(n);\n\t\tvi b(n),co(n);\n\t\tvector<vs>in(n);\n\t\trep(i,n){\n\t\t\tcin>>name[i]>>b[i]>>co[i];\n\t\t\tma[name[i]]=1;\n\t\t\tin[i]=vs(co[i]);\n\t\t\trep(j,co[i]){\n\t\t\t\tcin>>in[i][j];\n\t\t\t\tma[in[i][j]]=1;\n\t\t\t}\n\t\t}\n\t\tint t=0;\n\t\trep(i,n)ma[name[i]]=i;\n\t\n\t\tvector<ll>A(n);\n\t\trep(i,n)rep(j,in[i].size()){\n\t\t\tint from=ma[name[i]],to=ma[in[i][j]];\n\t\t\tA[from]|=1ll<<to;\n\t\t}\n\t\tint N=n/2,nN=n-N;\n\t\t\n//\t\trep(i,n){\n//\t\t\tcout<<name[i]<<\" \";\n//\t\t\trep(j,n)cout<<((A[i]&1<<j)>>j)<<\" \";cout<<endl;\n//\t\t}\n\t\tvi dp(1<<nN);\n\t\trep(i,1<<nN){\n\t\t\tbool h=true;\n\t\t\trep(j,nN)if((i&1<<j)&&((i&A[j+N]>>N)))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,nN)if(i&1<<j)sum+=b[N+j];\n\t\t\t\tdp[i]=max(dp[i],sum);\n\t\t\t}\n\t\t\trep(j,nN)if((i&1<<j)==0)\n\t\t\t\tdp[i|1<<j]=max(dp[i|1<<j],dp[i]);\n\t\t}\n\t\t\n\t\tint out=0;\n\t\trep(i,1<<N)if(i&1){\n\t\t\tbool h=true;\n\t\t\trep(j,N)if((i&1<<j)&&(i&A[j]))h=false;\n\t\t\tif(h){\n\t\t\t\tint sum=0;\n\t\t\t\trep(j,N)if(i&1<<j)sum+=b[j];\n\t\t\t\tt=(1<<nN)-1;\n\t\t\t\trep(j,N)if((i&1<<j))t&=~(A[j]>>N);\n\t\t\t\tout=max(out,sum+dp[t]);\n\t\t\t}\t\t\t\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}\n\n\n\n/*\nint n,m;\nvi A,B;\nint dp[52][52][110][2][3];\nint mem[52][52][110][2][3];\nint f(int a,int b,int co,int tu,int pas){\n    if(mem[a][b][co][tu][pas]+inf)return mem[a][b][co][tu][pas];\n\tif(pas==3)\n\t\n    int A,B,TU=(tu+co)%2;\n    if(!tu)A=a+(1+co)/2,B=b+co/2;\n    else A=a+co/2,B=b+(1+co)/2;\n    if(TU==0){\n        int ma=-inf;\n        if(A<n)ma=max(ma,f(a,b,co+1,tu,0));\n        if(co)ma=max(ma,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else if(a+b+co)ma=max(ma,0);\n        cout<<\" \"<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<ma<<\" \"<<dp[a][b][co][tu]<<endl;\n        return mem[a][b][co][tu]=ma;\n    }else{\n        int mi=inf;\n        if(B<m)mi=min(mi,f(a,b,co+1,tu,0));\n        if(co)mi=min(mi,dp[a][b][co][tu]+f(A,B,0,TU^1,pas+1));\n        else mi=min(mi,0);\n        cout<<a<<\" \"<<b<<\" \"<<co<<\" \"<<tu<<\" \"<<mi<<endl;\n        return mem[a][b][co][tu]=mi;\n    }\n}\nint main(){\n    cin>>n>>m;\n    A=vi(n);rep(i,n)cin>>A[i];\n    B=vi(m);rep(i,m)cin>>B[i];\n     \n    rep(l,2)rep(i,n+1)rep(j,m+1){\n        int sum=0;\n        int L=l,I=i,J=j;\n        int co=0;\n        while(1){\n            dp[i][j][co][l]=sum;\n            if(L&&J>=m||!L&&I>=n)break;\n            if(L){\n                if(B[J]+1)sum-=B[J];\n                else sum=0;\n                J++;\n            }else{\n                if(A[I]+1)sum+=A[I];\n                else sum=0;\n                I++;\n            }\n            L^=1;\n            co++;\n        }\n    }   \n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][0];cout<<endl;}\n//    rep(i,3)rep(j,3){rep(k,5)cout<<\" \"<<dp[i][j][k][1];cout<<endl;}\n    rep(i,52)rep(j,52)rep(k,110)rep(l,2)rep(q,3)\n        mem[i][j][k][l][q]=-inf;\n    cout<<f(0,0,0,0,1)<<endl;\n}\n*/\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <sstream>\n#include <string>\n#include <vector>\nusing namespace std;\n\n#pragma comment(linker, \"/STACK:400000000\")\n\n#define EPS 1e-9\n#define INF MOD\n#define MOD 1000000007LL\n#define fir first\n#define foreach(it,X) for(it=X.begin();it!=X.end();it++)\n#define iss istringstream\n#define ite iterator\n#define ll long long\n#define mp make_pair\n#define rep(i,n) rep2(i,0,n)\n#define rep2(i,m,n) for(int i=m;i<n;i++)\n#define pi pair<int,int>\n#define pb push_back\n#define sec second\n#define sh(i) (1LL<<i)\n#define sst stringstream\n#define sz size()\n#define vi vector<int>\n#define vc vector\n#define vl vector<ll>\n#define vs vector<string>\n\nint N,p[44];\nvi G[44];\nvector<string> con[44];\nmap<string,int> M;\n\nint f(int cur,int* flag2){\n\tint flag[44],res=p[cur];\n\trep(i,N)flag[i]=flag2[i];\n\tflag[cur]=1;\n\trep(i,G[cur].sz){\n\t\tflag[G[cur][i]]=-1;\n\t}\n\trep2(i,cur+1,N)if(flag[i]==0){\n\t\trep(j,G[i].sz){\n\t\t\tif(flag[G[i][j]]!=-1)goto skip;\n\t\t}\n\t\tflag[i]=1;\n\t\tres+=p[i];\n\t\tskip:;\n\t}\n\tint res2=0;\n\trep2(i,cur+1,N)if(flag[i]==0){\n\t\tres2=max(res2,f(i,flag));\n\t\tflag[i]=-1;\n\t}\n\treturn res+res2;\n}\n\nint main(){\n\twhile(cin>>N && N){\n\t\trep(i,N)G[i].clear(),con[i].clear();\n\t\trep(i,N){\n\t\t\tstring s;\n\t\t\tint m;\n\t\t\tcin>>s>>p[i]>>m;\n\t\t\tM[s]=i;\n\t\t\trep(j,m){\n\t\t\t\tcin>>s;\n\t\t\t\tcon[i].pb(s);\n\t\t\t}\n\t\t}\n\t\trep(i,N){\n\t\t\trep(j,con[i].sz){\n\t\t\t\tG[i].pb(M[con[i][j]]);\n\t\t\t}\n\t\t}\n\t\tint flag[44]={};\n\t\tcout<<f(0,flag)<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\nstruct MaximumIndependentSet {\n    using T = int;\n    MaximumIndependentSet(const int n) : n{n}, former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost(n, 1), elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    MaximumIndependentSet(const vector<T>& cost) : n(cost.size()), former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost{cost}, elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    void addEdge(const int from, const int to)\n    {\n        assert(0 <= from);\n        assert(from < n);\n        assert(0 <= to);\n        assert(to < n);\n        elist[from].push_back(to);\n        elist[to].push_back(from);\n    }\n\n    T calculate()\n    {\n        if (n <= 1) {\n            return max(cost[0], static_cast<T>(0));\n        }\n        for (ll i = 0; i < latter_maximum; i++) {\n            for (int j = 0; j < latter; j++) {\n                if (i & (1LL << j)) {\n                    ll mask = i - (1LL << j);\n                    for (const int to : elist[j + former]) {\n                        if (to >= former) {\n                            if (i & (1LL << (to - former))) {\n                                mask &= ~(1LL << (to - former));\n                            }\n                        }\n                    }\n                    latter_dp[i] = max(latter_dp[i - (1LL << j)], latter_dp[mask] + cost[j + former]);\n                    break;\n                }\n            }\n        }\n\n        T maximum = latter_dp[latter_maximum - 1];\n        for (ll i = 1; i < former_maximum; i++) {\n            for (int j = 0; j < former; j++) {\n                if (i & (1LL << j)) {\n                    if (former_dp[i - (1LL << j)] != -INF<T>) {\n                        bool ok = true;\n                        ll mask = former_next[i - (1LL << j)];\n                        for (const int to : elist[j]) {\n                            if (to >= former) {\n                                mask &= ~(1LL << (to - former));\n                            } else {\n                                if (i & (1LL << to)) {\n                                    ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (ok) {\n                            former_dp[i] = former_dp[i - (1LL << j)] + cost[j];\n                            former_next[i] = mask;\n                            maximum = max(maximum, former_dp[i] + latter_dp[mask]);\n                        } else {\n                            former_dp[i] = -INF<T>;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        return maximum;\n    }\n\n    const int n;\n    const int former;\n    const int latter;\n    const ll former_maximum;\n    const ll latter_maximum;\n    const vector<T> cost;\n    vector<vector<int>> elist;\n    vector<T> former_dp;\n    vector<T> latter_dp;\n    vector<ll> former_next;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        map<string, int> id;\n        vector<vector<string>> neighbor(N);\n        vector<int> power(N);\n        for (int i = 0; i < N; i++) {\n            string s;\n            cin >> s;\n            id[s] = i;\n            int B;\n            cin >> B;\n            power[i] = B;\n            int C;\n            cin >> C;\n            for (int j = 0; j < C; j++) {\n                string d;\n                cin >> d;\n                neighbor[i].push_back(d);\n            }\n        }\n        set<int> far;\n        for (int i = 1; i < N; i++) {\n            far.insert(i);\n        }\n        for (const string& s : neighbor[0]) {\n            far.erase(id[s]);\n        }\n        const int size = far.size();\n        map<int, int> mp;\n        int cnt = 0;\n        for (const int f : far) {\n            mp[f] = cnt;\n            cnt++;\n        }\n\n        vector<int> B;\n        for (const int f : far) {\n            B.push_back(power[f]);\n        }\n        MaximumIndependentSet st{B};\n        for (const int f : far) {\n            for (const string& name : neighbor[f]) {\n                const int ind = id[name];\n                if (far.find(ind) != far.end()) {\n                    st.addEdge(mp[f], mp[ind]);\n                }\n            }\n        }\n        cout << power[0] + st.calculate() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<vector<int>,int> P2;\ntypedef pair<P,P2> P3;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<vector<int> > memo;\n\nqueue<P3> q;\n\nvoid bfs(){\n\n  vector<int> s;\n  \n  q.push(P3(P(0,0),P2(s,0)));\n\n  while(!q.empty()){\n\n    P3 t=q.front(); q.pop();\n\n    int idx=t.second.second;\n    vector<int> S=t.second.first;\n    int x=t.first.first;\n    int sum=t.first.second;\n    \n    for(int i=idx;i<n;i++){\n    \n      if(!x&&i) continue;\n    \n      int f=0;\n    \n      for(int j=0;j<S.size();j++)\n\tif(G[S[j]][i]) f=1;\n    \n      if(!f){\n      \n\tvector<int> nS=S;\n      \n\tnS.push_back(i);\n      \n\tsort(nS.begin(),nS.end());\n      \n\tif(memo.count(nS)) continue;\n  \n\tmemo.insert(nS);\n      \n\tans=max(ans,sum+cost[i]);\n\t\n\tq.push(P3(P(x+1,sum+cost[i]),P2(nS,i+1)));\n      }\n    \n    }\n  }\n}\n\nvoid dfs(int x,int sum,vector<int> S,int idx){\n  \n  for(int i=idx;i<n;i++){\n    \n    if(!x&&i) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<S.size();j++)\n      if(G[S[j]][i]) f=1;\n    \n    if(!f){\n      \n      vector<int> nS=S;\n      \n      nS.push_back(i);\n      \n      sort(nS.begin(),nS.end());\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[i]);\n\t\n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=0;\n\n        vector<int> S;\n    \n    dfs(0,0,S,0);\n    //bfs();\n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bitset>\n#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\nint calc(vector<country> &cs){\n   int n = cs.size();\n   int res = 0;\n   ll ne = cs[0].ne;\n   int power = cs[0].power;\n   REP(i, n){\n       if(ne & (1LL<<i) != 0) continue;\n       if((ne | cs[i].ne) == (ne | (1LL<<i))){\n           ne |= cs[i].ne;\n           power += cs[i].power;\n       }\n   }\n\n   set<ll> use;\n   priority_queue<pair<int, ll> > pq;\n   pq.push(pair<int, ll>(power, ne));\n   while(!pq.empty()){\n       ne = pq.top().second;\n       power = pq.top().first;\n       pq.pop();\n       res = max(res, power);\n       if(power < res) continue;\n       if(use.find(ne) != use.end()) continue;\n       //cout << ne << \"*\" << power << endl;\n       use.insert(ne);\n       REP(i, n){\n           if(ne & (1LL<<i) != 0) continue;\n           if((ne | cs[i].ne) == (ne | (1LL<<i))){\n               ne |= cs[i].ne;\n               power += cs[i].power;\n           }\n       }\n       REP(i, n){\n           if(((1LL<<i) & ne) == 0){\n                pq.push(pair<int, ll>(power + cs[i].power, ne | cs[i].ne));  \n           }\n       }\n   }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9;\nint n, b[100], c[100], dp1[1 << 20], dp2[1 << 20];\nint ng1[100], ng2[100], ng[100];\nstring name[100], d[100][100];\nbool e[100][100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(e, 0, sizeof(e));\n\t\tmap<string, int> id;\n\t\t\n\t\trep(i, n){\n\t\t\tcin >> name[i] >> b[i] >> c[i];\n\t\t\trep(j, c[i]) cin >> d[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, c[i]) e[i][id[d[i][j]]] = e[id[d[i][j]]][i] = 1;\n\t\t\n\t\tint N = n / 2, M = n - N;\n\t\trep(i, 1 << N) dp1[i] = -inf;\n\t\trep(i, 1 << M) dp2[i] = -inf;\n\t\tdp1[1] = b[0]; dp2[0] = 0;\n\t\t\n\t\trep(i, N) ng1[i] = ng[i] = 0;\n\t\trep(i, M) ng2[i] = 0;\n\t\t\n\t\trep(i, N) rep(j, N) if(e[i][j]) ng1[i] |= 1 << j;\n\t\trep(i, M) rep(j, M) if(e[i + N][j + N]) ng2[i] |= 1 << j;\n\t\trep(i, N) rep(j, M) if(e[i][j + N]) ng[i] |= 1 << j;\n\t\t\n\t\tfor(int i = 1; i < 1 << N; i++){\n\t\t\tint l = 0;\n\t\t\tfor(; !(i & 1 << l); l++);\n\t\t\tint j = i ^ 1 << l;\n\t\t\tif(dp1[j] == -inf || (j & ng1[l])) continue;\n\t\t\tdp1[i] = dp1[j] + b[l];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < 1 << M; i++){\n\t\t\tint l = 0;\n\t\t\tfor(; !(i & 1 << l); l++);\n\t\t\tint j = i ^ 1 << l;\n\t\t\tif(dp2[j] == -inf || (j & ng2[l])) continue;\n\t\t\tdp2[i] = dp2[j] + b[l + N];\n\t\t}\n\t\t\n\t\trep(i, 1 << M) rep(j, M) if(i & 1 << j)\n\t\t\tdp2[i] = max(dp2[i], dp2[i ^ 1 << j]);\n\t\t\n\t\tvector<pi> v;\n\t\trep(i, 1 << N) v.pb(mp(dp1[i], i));\n\t\tsort(all(v), greater<pi>());\n\t\t\n\t\tint ans = 0;\n\t\trep(i, v.size()){\n\t\t\tif(v[i].second + dp2[(1 << M) - 1] <= ans) break;\n\t\t\tint mask = 0;\n\t\t\trep(j, N) if(v[i].second & 1 << j) mask |= ng[j];\n\t\t\tans = max(ans, v[i].first + dp2[(1 << M) - 1 ^ mask]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <numeric>\n#include <tuple>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <string>\n#include <bitset>\n\n#define FOR(i, a, b) for(int i = (int)a; i < (int)b; ++i)\n#define REP(i, n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\nusing ll = long long;\ntemplate <class T, class U> void CHMAX(T & a, const U & b) { if (a < b) a = b; }\ntemplate <class T, class U> void CHMIN(T& a, const U& b) { if (a > b) a = b; }\n\nusing B = long long;\nB g[41];\nbool ok1[1 << 21];\nbool ok2[1 << 21];\nint set[1 << 21];\nint dp[1 << 21];\nint cost1[1 << 21];\nint cost2[1 << 21];\n\nclass MaxIndependentSet { // V = V1 \\cup V2\n\tint n, n1, n2;\n\t//std::vector<B> g;\n\t//std::vector<bool> ok1, ok2; // ok[S] : Is S\\subseteq V stable?\n\t//std::vector<B> set; // set[S] : node-set \\subseteq V2 which not adjacent to S\n\t//std::vector<int> dp; // dp[S] : max independent set in S \\subseteq V2\n\t//std::vector<int> cost1, cost2; // cost[S] : cost S\n\npublic:\n\tMaxIndependentSet(const std::vector<std::vector<int>>& g_) { setG(g_); }\n\n\tvoid setG(const std::vector<std::vector<int>>& g_) {\n\t\tn = g_.size();\n\t\tn1 = n / 2;\n\t\tn2 = n - n1;\n\t\tREP(i, n) g[i] = 0ll;\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (auto& to : g_[i]) {\n\t\t\t\tg[i] |= 1ll << to;\n\t\t\t\tg[to] |= 1ll << i;\n\t\t\t}\n\t\t}\n\t}\n\n\tint calc(std::vector<int> s) {\n\t\t{ // ok1\n\t\t\tREP(i, 1 << n1) ok1[i] = true;\n\t\t\tREP(i, n1) FOR(j, i + 1, n1) if (g[i] & 1 << j) ok1[1 << i ^ 1 << j] = false;\n\n\t\t\tREP(bit, 1 << n1) {\n\t\t\t\tif (!ok1[bit]) continue;\n\t\t\t\tint tbit = bit;\n\t\t\t\twhile (tbit) {\n\t\t\t\t\tint i = tbit & -tbit;\n\t\t\t\t\tif (!ok1[bit ^ i]) {\n\t\t\t\t\t\tok1[bit] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttbit ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t{ // ok2\n\t\t\tREP(i, 1 << n2) ok2[i] = true;\n\t\t\tREP(i, n2) FOR(j, i + 1, n2) if (g[i + n1] >> n1 & 1 << j) ok2[1 << i ^ 1 << j] = false;\n\n\t\t\tREP(bit, 1 << n2) {\n\t\t\t\tif (!ok2[bit]) continue;\n\t\t\t\tint tbit = bit;\n\t\t\t\twhile (tbit) {\n\t\t\t\t\tint i = tbit & -tbit;\n\t\t\t\t\tif (!ok2[bit ^ i]) {\n\t\t\t\t\t\tok2[bit] = false;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\ttbit ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{ // set\n\t\t\tREP(i, 1 << n1) set[i] = (1 << n2) - 1;\n\t\t\tREP(i, n1) set[1 << i] &= ~g[i] >> n1;\n\n\t\t\tREP(bit, 1 << n1) {\n\t\t\t\tint tbit = ~bit & ((1 << n1) - 1);\n\t\t\t\twhile (tbit) {\n\t\t\t\t\tint i = tbit & -tbit;\n\t\t\t\t\tset[bit | i] = set[bit] & set[i];\n\t\t\t\t\ttbit ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t{ // cost1\n\t\t\tREP(bit, 1 << n1) {\n\t\t\t\tcost1[bit] = 0;\n\t\t\t\tREP(i, n1) if (bit & 1 << i) cost1[bit] += s[i];\n\t\t\t}\n\t\t}\n\t\t{ // cost2\n\t\t\tREP(bit, 1 << n2) {\n\t\t\t\tcost2[bit] = 0;\n\t\t\t\tREP(i, n2) if (bit & 1 << i) cost2[bit] += s[i + n1];\n\t\t\t}\n\t\t}\n\n\t\t{ // dp\n\t\t\tREP(i, 1 << n2) dp[i] = 0;\n\t\t\tREP(bit, 1 << n2) if (ok2[bit]) dp[bit] = cost2[bit];\n\n\t\t\tREP(bit, 1 << n2) {\n\t\t\t\tint tbit = ~bit & ((1 << n2) - 1);\n\t\t\t\twhile (tbit) {\n\t\t\t\t\tint i = tbit & -tbit;\n\t\t\t\t\tdp[bit | i] = std::max(dp[bit | i], dp[bit]);\n\t\t\t\t\ttbit ^= i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint res = 0;\n\t\tREP(bit, 1 << n1) {\n\t\t\tif (!ok1[bit]) continue;\n\t\t\tres = std::max(res, cost1[bit] + dp[set[bit]]);\n\t\t}\n\t\treturn res;\n\t}\n};\n\nsigned main() {\n\tMaxIndependentSet mis({});\n\n\tint n;\n\twhile (std::cin >> n, n) {\n\t\tstd::vector<int> s(n); // strength\n\t\tstd::vector<std::vector<int>> g;\n\t\t{\n\t\t\tstd::unordered_map<std::string, int> map;\n\t\t\tstd::vector<std::string> a(n);\n\t\t\tstd::vector<int> b(n);\n\t\t\tstd::vector<std::vector<std::string>> d(n);\n\n\t\t\tREP(i, n) {\n\t\t\t\tint sz = -1;\n\t\t\t\tstd::cin >> a[i] >> b[i] >> sz;\n\t\t\t\tmap[a[i]];\n\t\t\t\td[i].reserve(sz);\n\t\t\t\tREP(_, sz) {\n\t\t\t\t\tstd::string t;\n\t\t\t\t\tstd::cin >> t;\n\t\t\t\t\td[i].emplace_back(t);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint p = 0;\n\t\t\tfor (auto& e : map) e.second = p++;\n\t\t\tg.resize(p);\n\n\t\t\tREP(i, n) {\n\t\t\t\tint idx = map[a[i]];\n\t\t\t\ts[idx] = b[i];\n\t\t\t\tfor (auto& t : d[i]) g[idx].emplace_back(map[t]);\n\t\t\t}\n\t\t\tfor (auto& t : d[0]) s[map[t]] = -10000000;\n\t\t}\n\n\t\tmis.setG(g);\n\t\tstd::cout << mis.calc(s) << std::endl;\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<bitset<40> > neighbor;\nvector<int> strong;\n\nvector<int> memo;\n\nint solve(int i, bitset<40> ng)\n{\n    if(i == -1)\n        return 0;\n\n    bitset<40> ng2((1<<20) - 1);\n    ng2 &= ng;\n    if(i < 20 && memo[ng2.to_ulong()] != -1)\n        return memo[ng2.to_ulong()];\n\n    int ret = solve(i-1, ng);\n    if(!ng[i])\n        ret = max(ret, solve(i-1, ng |= neighbor[i]) + strong[i]);\n\n    if(i < 20)\n        memo[ng2.to_ulong()] = ret;\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<string> > d(n);\n        strong.resize(n);\n        for(int i=n-1; i>=0; --i){\n            string s;\n            int m;\n            cin >> s >> strong[i] >> m;\n            index[s] = i;\n            d[i].resize(m);\n            for(int j=0; j<m; ++j)\n                cin >> d[i][j];\n        }\n\n        neighbor.assign(n, 0);\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<d[i].size(); ++j){\n                int k = index[d[i][j]];\n                neighbor[i][k] = true;\n            }\n        }\n\n        memo.assign(1<<20, -1);\n        cout << (solve(n-2, neighbor[n-1]) + strong[n-1]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define endl '\\n'\n#define FOR(i, a, n) for (int i = (a); i < (n); ++i)\n#define REP(i, n) FOR(i, 0, n)\nusing namespace std;\n\nint N;\nstring A[40], D[40][40];\nint B[40], C[40], mask[40];\n\nint dfs(int v, int seen) {\n    if (v == N || seen == (1LL << N) - 1) return 0;\n    if (seen >> v & 1) return dfs(v + 1, seen);\n    int newSeen = seen | mask[v], newV = v + 1;\n    while (newV < N && (newSeen >> newV & 1)) ++newV;\n    int res = B[v] + dfs(newV, newSeen);\n    if (newSeen == (seen | 1LL << v)) return res;\n    newV = v + 1;\n    while (newV < N && (seen >> newV & 1)) ++newV;\n    res = max(res, dfs(newV, seen | 1LL << v));\n    return res;\n}\n\nsigned main() {\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    while (cin >> N, N) {\n        map<string, int> id;\n        REP (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            REP (j, C[i]) cin >> D[i][j];\n            id[A[i]] = i;\n        }\n        REP (i, N) {\n            mask[i] = 1LL << i;\n            REP (j, C[i]) {\n                mask[i] |= 1LL << id[D[i][j]];\n            }\n        }\n        cout << B[0] + dfs(1, mask[0]) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1e+8;\n\n// ノード数\nint n;\n// H[国名] := ノード番号 (文字列 と ノード番号の対応付け)\nmap<string,int> H;\n// 国名の保持, v.size() == n \nvector<string> v;\n// i 番目の国の強さ\nint power[40];\n// 答え\nint ans;\n\n// G := グラフ\n// pos := これから使おうとしている頂点の開始番号\n// used[i] := 頂点 i を使えないときは true, 使えるときは false\n// p := 強さの総和\nvoid solve(vector< vector<int> >& G, int pos, vector<bool> used, int p){\n\tans = max( ans , p );\n\tfor(int i=pos ; i < n ; i++ ){\n\t\tif( !used[i] ){\n\t\t\tvector<bool> used_ = used;\n\t\t\tused_[i] = true;\n\t\t\tfor(int j=0 ; j < G[i].size() ; j++ ){\n\t\t\t\tint v = G[i][j];\n\t\t\t\tused_[v] = true;\n\t\t\t}\n\t\t\tsolve( G , pos+1 , used_ , p+power[i] );\n\t\t}\n\t}\n}\n\nint main(){\n\twhile( cin >> n, n ){\n\t\t// 初期化\n\t\tH.clear();\n\t\tv.clear();\n\t\t// グラフ\n\t\tvector< vector<int> > G(n);\n\t\t\n\t\tvector< vector<string> > D(n);\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tstring A;\n\t\t\tint B, C;\n\t\t\tcin >> A >> B >> C;\n\t\t\tH[A] = i;\n\t\t\tv.push_back(A);\n\t\t\tpower[i] = B;\n\t\t\t\n\t\t\tD[i] = vector<string>(C);\n\t\t\tfor(int j=0 ; j < C ; j++ ){\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\t\tfor(int i=0 ; i < n ; i++ ){\n\t\t\tfor(int j=0 ; j < D[i].size() ; j++ ){\n\t\t\t\tint v = H[ D[i][j] ];\n\t\t\t\tG[i].push_back( v );\n\t\t\t}\n\t\t}\n\t\tans = 0;\n\t\tvector<bool> used(n,false);\n\t\tused[0] = true;\n\t\tfor(int i=0 ; i < G[0].size() ; i++ ){\n\t\t\tused[ G[0][i] ] = true;\n\t\t}\n\t\tsolve( G , 1 , used , power[0] );\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\nusing namespace std;\n\nint mx_tmp =0;\nvector<int> a,b;\nvector<vector<string> > c;\nvector<long long> g;\n\nint n;\nint dfs(int x,long long y){\n    \n    int tmp = a[x];\n    int mx = 0;\n    y |= g[x];\n    long long z = y;\n    for(int i=x+1;i<n;i++){\n        if((y>>i)&1)continue;\n        int tmp2 = dfs(i,y);\n        if(mx < tmp2){\n            mx = tmp2;\n        }\n    }\n    return tmp + mx;\n}\n\nint main(){\n    while(cin>>n &&n!=0){\n        map<string,int>mp;\n        int cnt = 0;\n        a.clear();\n        b.clear();\n        c.clear();\n        g.clear();\n        a.resize(n);\n        b.resize(n);\n        c.resize(n);\n        g.resize(n);\n        for(int i=0;i<n;i++){\n            string s;\n            cin >> s;\n            mp[s] = cnt;\n            cnt++;\n            cin >> a[i] >> b[i];\n            for(int j=0;j<b[i];j++){\n                cin >> s;\n                c[i].push_back(s);\n            }\n        }\n        for(int i=0;i<n;i++){\n            g[i] = 1LL<<i;\n            for(int j=0;j<b[i];j++){\n                g[i]+=(1LL<<mp[c[i][j]]);\n            }\n        }\n        mx_tmp=0;\n        int ans = dfs(0,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include\"bits/stdc++.h\"\n\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = (1 << 20) + 1;\nint cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nbool E[41][41];\n\nconst int MAX_N = 41;\nint weight[MAX_N];\nvector<int> G[MAX_N];\nint N;\nint dfs(long long flag, int w) {\n\t//cerr << bitset<7>(flag) << \" \" << w << endl;\n\tif ((1LL << N) - 1 == flag)return w;\n\tint v = 0;\n\t//int x = ~flag;\n\t//x& (-x);\n\trep(i, 0, N) {\n\t\tif (!(flag >> i & 1)) {\n\t\t\tv = i;\n\t\t\tbreak;\n\t\t}\n\t}\n\tint deg = 0;\n\tint max_weight = weight[v];\n\tfor (auto x : G[v])\n\t\tif (!(flag >> x & 1)) {\n\t\t\tdeg++;\n\t\t\tmax_weight = max(max_weight, weight[x]);\n\t\t}\n\tint ret = 0;\n\t// v を使わない\n\tflag |= 1LL << v;\n\tif (v != 0 && (deg >= 2 || max_weight > weight[v])) {\n\t\tret = dfs(flag, w);\n\t}\n\t// v を使う\n\tfor (auto x : G[v])\n\t\tflag |= 1LL << x;\n\tret = max(ret, dfs(flag, w + weight[v]));\n\treturn ret;\n}\n\nsigned main() {\n\n\tfor (; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)\n\t\t\tG[i].clear();\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tG[i].push_back(id[D[i][j]]);\n\t\t}\n\n\t\trep(i, 0, N)\n\t\t\tweight[i] = B[i];\n\n\t\tcout << dfs(0, 0) << endl;\n\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nmap<string,int> m;\nint idx=0;\nvector<int> G[101];\nvector<string> CS[101];\nstring names[101];\nint strong[101];\nbool used[101];\nint optNum;\n\n// 現在選べるものから選ぶ\nvoid dfs(int idx,int sum){\n  if(idx==N){\n    optNum=max(optNum,sum);\n    return;\n  }\n  int allSum=0;\n  bool cur[50];\n  for(int i=0;i<N;i++){\n    cur[i]=used[i];\n    if(!used[i])allSum+=strong[i];\n  }\n  bool ok=true;\n  // これから選ぶ頂点のどれかと隣接しているかチェック\n  for(int i=idx+1;i<N;i++){\n    if(used[i])continue;\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j]==idx){\n\tok=false;\n\tbreak;\n      }\n    }\n    if(!ok)break;\n  }\n  if(allSum+sum<=optNum)return;\n  // 隣接している頂点が存在する場合\n  if(idx!=0&&(!ok||used[idx])){\n    // 取らない\n    dfs(idx+1,sum);\n  }\n  if(!used[idx]){\n    used[idx]=true;\n    for(int j=0;j<(int)G[idx].size();j++){\n      int to=G[idx][j];\n      used[to]=true;\n    }\n    dfs(idx+1,sum+strong[idx]);\n    for(int j=0;j<N;j++)used[j]=cur[j];\n  }\n}\n\nint main(){\n  while(cin>>N&&N){\n    idx=0;\n    optNum=-1;\n    for(int i=0;i<101;i++){\n      G[i].clear();\n      CS[i].clear();\n    }\n    m.clear();\n    for(int i=0;i<N;i++){\n      cin>>names[i]>>strong[i];\n      int C;\n      cin>>C;\n      for(int j=0;j<C;j++){\n\tstring s;\n\tcin>>s;\n\tif(m.count(s)==0)m[s]=idx++;\n\tCS[i].push_back(s);\n      }\n    }\n    for(int i=0;i<N;i++)\n      m[names[i]]=i;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<(int)CS[i].size();j++){\n\tG[m[names[i]]].push_back(m[CS[i][j]]);\n\tG[m[CS[i][j]]].push_back(m[names[i]]);\n      }\n    }\n    memset(used,0,sizeof(used));\n    dfs(0,0);\n    cout<<optNum<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\n\nint main(){\n    while(cin >> n , n){\n        map<string,int> mp;\n        vector<i64> edges(n + 10,0);\n        vector<int> x(n + 10,0);\n\n        auto get_i = [&](string& s){\n            if(mp.count(s)){\n                return  mp[s];\n            }\n            else{\n                mp[s] = mp.size();\n                return (int)mp.size() - 1;\n            }\n        };\n\n        for(int c = 0;c < n;c++){\n            string s;cin >> s;\n            int i = get_i(s);\n            int C;\n            cin >> x[i] >> C;\n            for(int d = 0;d < C;d++){\n                cin >> s;\n                edges[i] |= (1LL << get_i(s));\n            }\n        }\n\n        vector<int> sum(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        int result = 0;\n        function<void(i64,i64,int)> dfs = [&](int i,i64 bit,int now_sum){\n            result = max(result , now_sum);\n            if(i == n) return;\n            //枝刈り\n            if(now_sum + sum[i] <= result) return;\n            //throw\n            dfs(i + 1,bit,now_sum);\n\n            if(!(bit & edges[i])) dfs(i + 1,bit | (1LL << i),now_sum + x[i]);\n        };\n        dfs(1,1,x[0]);\n        cout << result << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#include <string>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n\nusing namespace std;\n#define N 40\n#define TEST 0\n\n\n\tstring a[N];\n\tint b[N],c[N];\n\tstring d[N][N];\n\tint edges[N][N];\n\tint n;\n\ntypedef long long i64;\nint maxv;\ni64 maxi;\n\n\nvoid rec(i64 bits,int sum){\n\tif(sum<=maxv){\n\t\treturn;\n\t}\n\tif((bits&1LL)==0LL)return;\n\tbool clique=true;\n\tint minind=100000;\n\tint mini=-1;\n\tfor(int i=0;i<n;i++){\n\t\tif((bits&(1LL<<i))==0)continue;\n\t\tint ind=0;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tif((bits&(1LL<<j))==0)continue;\n\t\t\tif(i==j)continue;\n\t\t\tif(edges[i][j])\n\t\t\t\tind+=1;\n\t\t\telse\n\t\t\t\tclique=false;\n\t\t}\n\t\tif(minind>ind){\n\t\t\tmini=i;\n\t\t\tminind=ind;\n\t\t}\n\t}\n\tif(mini==-1)assert(!\"error mini==-1\");\n\tint sub1=b[mini];\n\ti64 set1=1LL<<mini;\n\tfor(int i=0;i<n;i++){\n\t\tif((bits&(1LL<<i))==0)continue;\n\t\tif(i==mini)continue;\n\t\tif(edges[mini][i]){\n\t\t\tsub1+=b[i];\n\t\t\tset1|=1LL<<i;\n\t\t}\n\t}\n\tif(!clique){\n\t\trec(set1,sub1);\n\t\trec(bits&~(1LL<<mini),sum-b[mini]);\n\t\treturn;\n\t}\n\t//clique\n\tif(maxv<sub1){\n\t\tmaxv=max(maxv,sub1);\n\t\tmaxi=bits;\n\t}\n}\n\n\n\nint main(void){\n\tint di[N][N];\n\twhile(1){\n\t\tcin>>n;\n\t\tif(TEST)cerr<<\"n=\"<<n<<endl;\n\t\tif(n==0)break;\n\t\tmap<string,int> m;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcin>>a[i]>>b[i]>>c[i];\n\t\t\tfor(int j=0;j<c[i];j++){\n\t\t\t\tcin>>d[i][j];\n\t\t\t}\n\t\t}\n\t\tint cnt=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tm.insert(pair<string,int>(a[i],i));\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfill_n(edges[i],n,1);\n\t\t\tedges[i][i]=0;\n\t\t}\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<c[i];j++){\n\t\t\t\tdi[i][j]=m[d[i][j]];\n\t\t\t\tedges[i][di[i][j]]=0;\n\t\t\t}\n\t\t}\n\t\tif(TEST){\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tfor(int  j=0;j<n;j++){\n\t\t\t\t\tcerr<<edges[i][j]<<\" \";\n\t\t\t\t}\n\t\t\t\tcout<<\":\"<<b[i]<<endl;\n\t\t\t}\n\t\t}\n\t\tmaxv=0;\n\t\tint sum=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tsum+=b[i];\n\t\t}\n\t\trec((1LL<<n)-1,sum);\n\t\tcout<<maxv<<endl;\n\t\tif(TEST){\n\t\t\tfprintf(stderr,\"set=%llx\\n\",maxi);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long int ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n;\nstring vertex[45];\nint m[45];\nint power[45];\nstring adj[45][45];\n\null graph[45];\n\nint dfs(int cur,ull used){\n\tif(cur==n) return 0;\n\tif(used>>cur&1) return dfs(cur+1,used);\n\n\tint res=0;\n\tull nused=used|(1LL<<cur);\n\n\tif(__builtin_popcountll((~nused)&(graph[cur]))<=1){\n\t\tres=power[cur]+dfs(cur+1,nused|graph[cur]);\n\t}else{\n\t\tres=dfs(cur+1,nused);\n\t\tres=max(res,power[cur]+dfs(cur+1,nused|graph[cur]));\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n){\n\t\t\tcin >> vertex[i] >> power[i];\n\t\t\tcin >> m[i];\n\t\t\trep(j,m[i]) cin >> adj[i][j];\n\t\t}\n\t\tfor(int i=1;i<n;++i){\n\t\t\tfor(int j=i+1;j<n;++j){\n\t\t\t\tif(power[i]<power[j]){\n\t\t\t\t\tswap(vertex[i],vertex[j]);\n\t\t\t\t\tswap(power[i],power[j]);\n\t\t\t\t\tswap(m[i],m[j]);\n\t\t\t\t\trep(k,45) swap(adj[i][k],adj[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tgraph[i]=0LL;\n\t\t\trep(j,m[i])rep(k,n)\n\t\t\t\tif(adj[i][j]==vertex[k])\n\t\t\t\t\tgraph[i]|=(1LL<<k);\n\t\t}\n\t\tcout << power[0]+dfs(1,graph[0]|1LL) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(ll i = (ll)(s); i < (ll)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\n\n#define LINE cout << \"LINE : \" << __LINE__ << endl\n#define dump(v) cout << #v << \" : \" << v << \" \"\n#define dumpl(v) dump(v) << endl\n\nusing ll = int_fast64_t;\n\nstring A[41];\nll B[41];\nvector<string> D[41];\n\n\nvoid calc(vector<ll>& dp, ll l, ll r, const vector<ll>& maskNg) {\n  rep(mask, 1LL << (r - l)) {\n    rep(i, r - l) {\n      if(mask&maskNg[i]) continue;\n      if(mask&(1LL<<i)) continue;\n      ll nxt = mask | (1LL << i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i + l]);\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n;\n  while(cin >> n) {\n    if(n == 0) break;\n    rep(i, n) {\n      ll c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n    }\n    map<string, ll> mp;\n    rep(i, n) mp[A[i]] = i;\n    vector<vector<ll>> d(n);\n    rep(i, n) {\n      d[i].resize(D[i].size());\n      rep(j, D[i].size()) d[i][j] = mp[D[i][j]];\n    }\n\n    ll l = 0, m = n/2, r = n;\n    vector<vector<ll>> maskNg;\n    maskNg.push_back(vector<ll>(m - l, 0));\n    maskNg.push_back(vector<ll>(r - m, 0));\n    maskNg.push_back(vector<ll>(m - l, 0));\n    \n    rep(i, m - l) {\n      auto& mask = maskNg[0][i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j];\n\tif(k >= m) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, r - m) {\n      auto& mask = maskNg[1][i];\n      rep(j, d[i + m].size()) {\n\tll k = d[i + m][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n    rep(i, m - l) {\n      auto& mask = maskNg[2][i];\n      rep(j, d[i].size()) {\n\tll k = d[i][j] - m;\n\tif(k < 0) continue;\n\tmask |= (1LL << k);\n      }\n    }\n\n    vector<ll> dp0(1<<(m - l), 0LL);\n    vector<ll> dp1(1<<(r - m), 0LL);\n    calc(dp0, l, m, maskNg[0]);\n    calc(dp1, m, r, maskNg[1]);\n\n    rep(mask, (1LL << (r - m))) {\n      rep(i, r - m) {\n\tif(mask&(1LL<<i)) dp1[mask] = max(dp1[mask], dp1[mask - (1LL<<i)]);\n      }\n    }\n    \n    ll ans = 0LL;\n    rep(x, 1LL<<(m - l)) {\n      if(x&1LL) {\n\tll y = (1LL<<(r - m)) - 1LL;\n\trep(i, m - l) {\n\t  if(x & (1LL << i)) {\n\t    y -= (y & maskNg[2][i]);\n\t  }\n\t}\n\tans = max(ans, dp0[x] + dp1[y]);\n      }\n    }\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\n#include <map>\n#include <string>\n#include <iostream>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define VI vector<int>\n#define VVI vector<VI>\n#define PB push_back\n#define LL long long\nusing namespace std;\nmap<string, int> m;\nVVI g;\nVI s;\nint n;\n\nint DFS(LL p){\n\tint ret = 0;\n\tREP(i,n){\n\t\tif(!(p&(1LL<<i))){\n\t\t\tLL q = p|(1LL<<i);\n\t\t\tREP(j,g[i].size())q|=(1LL<<g[i][j]);\n\t\t\tret = max(ret,DFS(q)+s[i]); \n\t\t}\n\t}\n\treturn ret;\n}\n\nint main(){\n\twhile(1){\n\t\tint ret=0;\n\t\tLL start=1LL;\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)return 0;\n\t\ts=VI(n);\n\t\tg=VVI(n);\n\t\tm.clear();\n\t\tint k=0,idx;\n\t\tREP(i,n){\n\t\t\tstring name;\n\t\t\tcin>>name;\n\t\t\tif(!EXIST(m,name)){\n\t\t\t\tidx=m[name]=k;\n\t\t\t\tk++;\n\t\t\t}else idx=m[name];\n\t\t\tint q;\n\t\t\tcin>>s[idx]>>q;\n\t\t\tif(q==0){\n\t\t\t\tret+=s[idx];\n\t\t\t\tstart|=(1LL<<idx);\n\t\t\t}\n\t\t\tREP(j,q){\n\t\t\t\tcin>>name;\n\t\t\t\tif(!EXIST(m,name)){\n\t\t\t\t\tm[name]=k;\n\t\t\t\t\tg[idx].PB(k);\n\t\t\t\t\tk++;\n\t\t\t\t}else g[idx].PB(m[name]);\n\t\t\t}\n\t\t}\n\t\tREP(i,g[0].size())start|=(1LL<<g[0][i]);\n\t\tcout << DFS(start)+s[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<queue>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define all(c) (c).begin(),(c).end()\n#define mp make_pair\n#define pb push_back\n#define each(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\nconst int inf = (int)1e9;\nconst double INF = 1e12, EPS = 1e-9;\n\nvector<string> list[40];\nstring name[40];\nint n, w[40], sum;\nvector<vi> e;\nbool v[40], ok[40];\n\nvoid dfs(int c, vector<pi> &o){\n\to.pb(mp(w[c], c));\n\tv[c] = 1;\n\tok[c] = 1;\n\teach(i, e[c]) if(!v[*i]) dfs(*i, o);\n}\nvoid rec(int c, int cur, const vector<pi> &o){\n\tint next = -1, tmp = 0;\n\tfor(int i = o.size() - 1; i >= c; i--) if(ok[o[i].second]){\n\t\tif(i > c) next = i;\n\t\ttmp += o[i].first;\n\t}\n\tif(cur + tmp <= sum) return;\n\tif(next < 0){\n\t\tsum = cur + tmp;\n\t\treturn;\n\t}\n\tif(ok[o[c].second]){\n\t\tbool ok2[40];\n\t\trep(i, n) ok2[i] = ok[i];\n\t\teach(i, e[o[c].second]) ok[*i] = 0;\n\t\tok[o[c].second] = 0;\n\t\trec(next, cur + o[c].first, o);\n\t\trep(i, n) ok[i] = ok2[i];\n\t}\n\tif(o[c].second != 0) rec(next, cur, o);\n}\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(v, 0, sizeof(v));\n\t\te.clear(); e.resize(n);\n\t\tmap<string, int> id;\n\t\trep(i, n){\n\t\t\tint k;\n\t\t\tcin >> name[i] >> w[i] >> k;\n\t\t\tlist[i].clear(); list[i].resize(k);\n\t\t\trep(j, k) cin >> list[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, list[i].size()) e[i].pb(id[list[i][j]]);\n\t\t\n\t\tint ans = 0;\n\t\trep(i, n) if(!v[i]){\n\t\t\tvector<pi> ord;\n\t\t\tdfs(i, ord);\n\t\t\tsort(all(ord), greater<pi>());\n\t\t\tint p = -1;\n\t\t\trep(j, ord.size()) if(ord[j].second == 0) p = j;\n\t\t\tif(p >= 0) swap(ord[p], ord[0]);\n\t\t\tsum = 0;\n\t\t\trec(0, 0, ord);\n\t\t\tans += sum;\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Country\n{\npublic:\n  string A;\n  int B, C;\n  long long int D;\n  vector<string> d;\n  bool operator < (const Country& c) const\n  {\n    return this->C > c.C;\n  }\n};\n\nint solve(int idx, long long int visited, const vector<Country>& c)\n{\n  if (idx >= (int)c.size())\n    return 0;\n\n  int ret = 0;\n  if (!((1LL << idx) & visited) && (c[idx].D - ((1LL << (idx+1))-1) <= 0)) {\n    ret = solve(idx+1, visited | c[idx].D, c) + c[idx].B;\n  } else {\n    if (!((1LL << idx) & visited))\n      ret = solve(idx+1, visited | c[idx].D, c) + c[idx].B;\n    ret = max(ret, solve(idx+1, visited, c));\n  }\n  return ret;\n}\n\nint main()\n{\n  int N;\n  while (cin >> N) {\n    if (N == 0)\n      break;\n\n    vector<Country> c(N);\n    for (int i = 0; i < N; ++i) {\n      cin >> c[i].A >> c[i].B >> c[i].C;\n      for (int j = 0; j < c[i].C; ++j) {\n        string dij;\n        cin >> dij;\n        c[i].d.push_back(dij);\n      }\n    }\n\n    sort(c.begin()+1, c.end());\n    for (int i = 0; i < N; ++i) {\n      c[i].D = 1LL << i;\n      for (unsigned int j = 0; j < c[i].d.size(); ++j) {\n        for (int k = 0; k < N; ++k) {\n          if (c[i].d[j] == c[k].A) {\n            c[i].D |= 1LL << k;\n            break;\n          }\n        }\n      }\n    }\n\n    cout << solve(1, c[0].D, c)+c[0].B << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\ntemplate<class T>\nclass IdMaker{\npublic:\n  std::map<T,int> _m;\n  int getId(const T &v){\n    if(_m.find(v) == _m.end()){\n      int next = _m.size();\n      return _m[v] = next;\n    }\n    return _m[v];\n  }\n};\n\nll adj[40];\nint str[40];\nint memo[40];\nint ans;\n\nvoid solve(ll flag, int now){\n  ll ff = flag;\n\n  while(ff){\n    const ll f = ff & (-ff);\n    const int pos = __builtin_ctzl(f);\n    if((adj[pos] & flag) == 0){\n      now += str[pos];\n      flag ^= f;\n    }\n    ff ^= f;\n  }\n\n  ans = max(ans, now);\n  if(flag == 0 || now + memo[__builtin_ctzl(flag)] <= ans)\n    return;\n\n  while(flag){\n    const ll f = flag & (-flag);\n    const int pos = __builtin_ctzl(f);\n    solve((flag ^ (1ll << pos)) & (~adj[pos]), now + str[pos]);\n    flag ^= f;\n  }\n}\n\nint main(){\n  while(const int n = getInt()){\n    IdMaker<string> idm;\n\n    REP(i,n){\n      string s; cin >> s;\n      str[idm.getId(s)] = getInt();\n      const int m = getInt();\n      adj[idm.getId(s)] = 0;\n      REP(j,m){\n        string a; cin >> a;\n        adj[idm.getId(s)] |= (1ll << idm.getId(a));\n      }\n    }\n\n    REP(i,n) memo[i] = 0;\n    REP(i,n)\n      for(int j = i; j < n; j++)\n        memo[i] += str[j];\n\n    ll start = (1ll << n) - 1;\n    start ^= 1;\n    start ^= adj[0];\n\n    ans = 0;\n    solve(start, str[0]);\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define int long long\nint n,ans,sum;\nstring a[50];\nint b[50],c[50];\nvector<string> d[50];\nvector<int> e[50];\nmap<string,int> m;\nmap<int,int> memo[40];\nvoid dfs(int x,int p,int q,int t){\n  if(x==n) return;\n  //cout<<x<<\" \"<<p<<\" \"<<q<<\":\"<<sum<<\" \"<<ans<<endl;\n  if(p<=memo[x][t>>x]) return;\n  memo[x][t>>x]=p;\n  if(sum-q<=ans) return;\n  ans=max(ans,p);\n  if(!((t>>x)&1)){\n    int np=p,nq=1,nt=t;\n    np+=b[x];\n    for(int i=0;i<c[x];i++){\n      if((nt>>e[x][i])&1) continue;\n      nt+=1LL<<e[x][i];\n      nq+=b[e[x][i]];\n    }\n    dfs(x+1,np,nq,nt);\n  }\n  dfs(x+1,p,q,t);\n}\nsigned main(){\n  while(cin>>n,n){\n    m.clear();\n    for(int i=0;i<40;i++) memo[i].clear();\n    for(int i=0;i<n;i++){\n      cin>>a[i]>>b[i]>>c[i];\n      m[a[i]]=i;\n      d[i].clear();\n      d[i].resize(c[i]);\n      for(int j=0;j<c[i];j++) cin>>d[i][j];\n    }\n    for(int i=0;i<n;i++){\n      e[i].clear();\n      e[i].resize(c[i]);\n      for(int j=0;j<c[i];j++) e[i][j]=m[d[i][j]];\n    }\n    ans=sum=0;\n    for(int i=0;i<n;i++) sum+=b[i];\n    int t=0;\n    int p=b[0],q=0;\n    for(int i=0;i<c[0];i++){\n      if((t>>e[0][i])&1) continue;\n      t+=1LL<<e[0][i];\n      q+=b[e[0][i]];\n    }\n    dfs(1,p,q,t);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint b[40], c[40];\nstring d[40][40];\nstring a[40];\n\nlong long can[40]; //いけないところは1\n\nmap< string , int > java;\n \nint rec(long long ikeru, long long used){ //いけるとこ0\n  int ret = 0;\n  for(int i = 0; i < N; i++){\n    if((ikeru >> i) & 1) continue;\n    if((used >> i) & 1) continue;\n    if(used & can[i]) continue;\n    ret = max( ret, rec((ikeru|can[i]),used|(1 << i)) + b[i]);\n  }\n  return ret;\n}\n\nint main(){\n\n  while(cin >> N, N){\n    java.clear();\n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> b[i] >> c[i];\n      java[a[i]] = i;\n\n      for(int j = 0; j < c[i]; j++){\n        cin >> d[i][j];\n      }\n    }\n\n    for(int i = 0; i < N; i++){\n      can[i] = 0;\n      for(int j = 0; j < c[i]; j++){\n        can[i] |= 1 << java[d[i][j]];\n      }\n    }\n\n    \n    cout << rec( can[0], 1) + b[0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nvector<int> DD[41];\nHmap<string, int> hm;\n\nvector<ll> dp0(1<<20);\nvector<ll> dp1(1<<20);\n\nint masks[1<<20];\n\nvoid calc (vl& dp, int s, int e) {\n  int l = e - s;\n  vector<int> ngs(l);\n  rep(i, l) {\n    for(const auto& t: DD[i+s]) {\n      if(s <= t && t < e) {\n\tngs[i] |= (1<<(t-s));\n      }\n    }\n  }\n  rep(mask, 1 << l) {\n    rep(i, l) {\n      if(mask & (1<<i)) continue;\n      if(mask&ngs[i]) continue;\n      int nxt = mask | (1<<i);\n      dp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n    }\n  }\n  rep(mask, 1<<l) {\n    rep(i, l) {\n      if(mask&(1<<i)) {\n\tint pre = mask - (1<<i);\n\tdp[mask] = max(dp[mask], dp[pre]);\n      }\n    }\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    hm.clear();\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    rep(i, n) {\n      DD[i].resize(D[i].size());\n      rep(j, D[i].size()) {\n\tDD[i][j] = hm[D[i][j]];\n      }\n    }\n    rep(i, 1<<20) dp0[i] = 0;\n    rep(i, 1<<20) dp1[i] = 0;\n    \n    calc(dp0, 0, n/2);\n    calc(dp1, n/2, n);\n\n    int len = n - (n/2);\n    rep(i, 1<<(n+1)/2) masks[i] = (1<<len)-1;\n    vector<int> ngs(n/2);\n    rep(i, n) {\n      for(const auto& tt : DD[i]) {\n\tint t = tt - n / 2;\n\tif(t < 0) continue;\n\tngs[i] |= (1<<t);\n      }\n    }\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tint tmp = masks[mask]&ngs[i];\n\tmasks[mask] -= tmp;\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp0[mask] + dp1[masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint ans;\nint bs[114514];\nint cs[114514];\nchar buf[114514];\nbool used[114514];\nstring as[114514];\nvector<int> es[114514];\nvector<string> ds[114514];\nmap<string, int> rev;\n\nvoid calc(int v, int sum) {\n  if (v >= n) {\n    ans = max(ans, sum);\n    return;\n  }\n\n  if (!used[v]) {\n    vector<int> restores;\n    used[v] = true;\n    for (int i=0; i<cs[v]; i++) {\n      int u = es[v][i];\n      if (!used[u]) {\n        used[u] = true;\n        restores.emplace_back(u);\n      }\n    }\n    calc(v+1, sum+bs[v]);\n    for (int u : restores) used[u] = false;\n  } \n  calc(v+1, sum);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n    rev.clear();\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      as[i] = buf;\n      rev[as[i]] = i;\n      scanf(\"%d\", &bs[i]);\n      scanf(\"%d\", &cs[i]);\n      ds[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        scanf(\" %s\", buf);\n        ds[i][j] = buf;\n      }\n    }\n  \n    for (int i=0; i<n; i++) {\n      es[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        es[i][j] = rev[ds[i][j]];\n      }\n    }\n\n    int pre = bs[0];\n    used[0] = true;\n    for (int u : es[0]) {\n      vs.erase(u)\n      used[u] = true;\n    }\n\n    for (int i=1; i<n; i++) {\n      if (used[u]) continue;\n      if (cs[i] == 0 || (cs[i] == 1 && bs[i] >= bs[es[i][0]])) {\n        pre += bs[i];\n        used[i] = true;\n        for (int u : es[i]) {\n          used[u] = true;\n        }\n      }\n    }\n  \n    ans = 0;\n    calc(vs, pre);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) a.begin(), a.end()\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10 fixed<<setprecision(10)\ntypedef long long ll;\ntypedef long double ld;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\nconst int MOD = 1000000007;\nconst int INF = MOD + 1;\nconst ld EPS = 1e-12;\ntemplate<class T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<class T> T &chmax(T &a, const T &b) { return a = max(a, b); }\n\n/*--------------------template--------------------*/\nint n, ans;\nvector<ll> g;\nvi power;\nvi ss;\n\nvoid solve(int i, int res, ll ok)\n{\n\tif (i == n)\n\t{\n\t\tchmax(ans, res);\n\t\treturn;\n\t}\n\tif (res + ss[n] - ss[i] <= ans) return;\n\tif (((ok >> i) & 1) == 0) solve(i + 1, res + power[i], ok | g[i]);\n\tsolve(i + 1, res, ok);\n}\n\nint main()\n{\n\twhile (cin >> n, n)\n\t{\n\t\tans = 0;\n\t\tg.resize(n);\n\t\tunordered_map<string, int> mp;\n\t\tvs name(n);\n\t\tpower.resize(n);\n\t\tvector<vs> nei(n);\n\t\tREP(i, n)\n\t\t{\n\t\t\tint m;\n\t\t\tcin >> name[i] >> power[i] >> m;\n\t\t\tREP(j, m)\n\t\t\t{\n\t\t\t\tstring s; cin >> s;\n\t\t\t\tnei[i].push_back(s);\n\t\t\t}\n\t\t}\n\t\tREP(i, n) mp[name[i]] = i;\n\t\tREP(i, n)\n\t\t{\n\t\t\tg[i] = 1ll << i;\n\t\t\tREP(j, nei[i].size())\n\t\t\t{\n\t\t\t\tg[i] |= 1ll << mp[nei[i][j]];\n\t\t\t}\n\t\t}\n\n\t\tss.resize(n + 1);\n\t\tREP(i, n) ss[i + 1] = ss[i] + power[i];\n\n\t\tll ok = g[0];\n\t\tsolve(1, power[0], ok);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <utility>\nusing namespace std;\ntypedef long long int lli;\n\n// returns (最大値, 集合)\n// 負の重みなし\npair<int, lli> weighted_max_indep_set(vector<lli> adj_bit, vector<int> weight){\n    adj_bit.emplace_back();\n    weight.emplace_back();\n    int n = adj_bit.size();\n    int half = n/2;\n    lli halfmask = (1LL<<half) -1;\n    // グラフと重みを２つに分割する\n    vector<vector<int>> adj(2, vector<int>(half));\n    vector<vector<int>> w(2, vector<int>(half));\n    for(int i=0; i<half; i++){\n        adj[0][i] = adj_bit[i] & halfmask;\n        adj[1][i] = adj_bit[half+i] >> half;\n        w[0][i] = weight[i];\n        w[1][i] = weight[half+i];\n    }\n    vector<int> unusable(half, 0);\n    for(int i=0; i<half; i++){\n        unusable[i] = adj_bit[i] >> half;\n    }\n    // それぞれbitDPして全列挙\n    vector<vector<int>> gain(2, vector<int>(1<<half, -1));\n    gain[0][0] = gain[1][0] = 0;\n    vector<int> cover(1<<half, 0);\n    for(int i=0; i<(1<<half); i++){\n        if(gain[0][i] == -1) continue;\n        for(int j=0; j<half; j++){\n            if(i>>j&1) continue;\n            int next = i | (1<<j);\n            cover[next] = cover[i] | unusable[j];\n            if(i&adj[0][j]) continue;\n            gain[0][next] = max(gain[0][next], gain[0][i]+w[0][j]);\n        }\n    }\n    for(int i=0; i<(1<<half); i++){\n        for(int j=0; j<half; j++){\n            if(i>>j&1) continue;\n            int next = i | (1<<j);\n            if(i&adj[1][j]){\n                gain[1][next] = max(gain[1][next], gain[1][i]);\n            }else{\n                gain[1][next] = max(gain[1][next], gain[1][i]+w[1][j]);\n            }\n        }\n    }\n    // 対応付け\n    pair<int, lli> res(0, 0);\n    for(int i=0; i<(1<<half); i++){\n        if(gain[0][i] == -1) continue;\n        int ok = cover[i]^halfmask;\n        pair<lli, lli> sub(gain[0][i]+gain[1][ok], i | ((lli)ok<<half));\n        if(sub.first > res.first){\n            res = sub;\n        }\n    }\n    return res;\n}\n\nint main(){\n    while(1){\n        int n;\n        cin >> n;\n        if(n == 0) break;\n        \n        vector<string> a(n);\n        vector<int> b(n);\n        vector<vector<string>> d(n);\n        map<string, int> str2idx;\n        for(int i=0; i<n; i++){\n            int c;\n            cin >> a[i] >> b[i] >> c;\n            str2idx[a[i]] = i;\n            d[i].resize(c);\n            for(int j=0; j<c; j++){\n                cin >> d[i][j];\n            }\n        }\n        vector<long long int> adj(n);\n        for(int i=0; i<n; i++){\n            for(string s: d[i]){\n                adj[i] |= 1LL<<str2idx[s];\n            }\n        }\n        for(int i=1; i<n; i++){\n            if(adj[0]>>i&1) b[i] = 0;\n        }\n        cout << weighted_max_indep_set(adj, b).first << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<string>\n#include<map>\n#include<vector>\nusing namespace std;\nchar str[50];\nstring name[50];\nint b[50];\nint c[50];\nstring d[50][50];\nint g[50][50];\nint n;\nint deg[50];\nint dfs(vector<int>use){\n\tbool ok=true;\n\tint ret=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(use[i]==1)ret+=b[i];\n\t\tif(use[i]==-1)ok=false;\n\t}\n\tif(ok){\n\t\t/*if(ret>40){\n\t\t\tfor(int i=0;i<use.size();i++)printf(\"%d \",use[i]);\n\t\t\tprintf(\": %d\\n\",ret);\n\t\t}*/\n\t\treturn ret;\n\t}\n\tint m=-1;\n\tint at=0;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]&&m<deg[i]){\n\t\t\tm=deg[i];at=i;\n\t\t}\n\t}\n\t// use\n\tret=0;\n\tvector<int> to=use;\n\tto[at]=1;\n\tfor(int i=0;i<n;i++){\n\t\tif(!~use[i]&&g[at][i]){\n\t\t\tto[i]=0;\n\t\t}\n\t}\n\tret=max(ret,dfs(to));\n\t// non use\n\tto=use;\n\tto[at]=0;\n\tret=max(ret,dfs(to));\n\treturn ret;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tn=a;\n\t\tmap<string,int>m;\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint p,q;scanf(\"%s%d%d\",str,&p,&q);\n\t\t\tname[i]=str;\n\t\t\tb[i]=p;\n\t\t\tc[i]=q;\n\t\t\tm[name[i]]=i;\n\t\t\tfor(int j=0;j<q;j++){\n\t\t\t\tscanf(\"%s\",str);\n\t\t\t\td[i][j]=str;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<c[i];j++)\n\t\t\tg[i][m[d[i][j]]]=1;\n\t\tfor(int i=0;i<a;i++)deg[i]=0;\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)deg[i]+=g[i][j];\n//\t\tfor(int i=0;i<a;i++){\n\t//\t\tfor(int j=0;j<a;j++)printf(\"%d \",g[i][j]);printf(\"\\n\");\n\t\t//}\n\t\tvector<int> s(a,-1);\n\t\ts[0]=1;\n\t\tfor(int i=0;i<a;i++)if(g[0][i])s[i]=0;\n\t\tprintf(\"%d\\n\",dfs(s));\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if(ne & (1LL<<i) != 0) continue;\n        if((ne | cs[i].ne) <= ne){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n\n    priority_queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.top().second.second;\n        power = pq.top().second.first;\n        int v = pq.top().first + 1;\n        pq.pop();\n        res = max(res, power);\n        if(v > n - 1) continue;\n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        \n        \n        ll nne = ne;\n        int npower = power;\n        for(int i = v + 1; i < n; i++){\n            if((nne & (1LL<<i)) != 0) continue;\n            if(((nne | cs[i].ne) ^ nne) < (1LL<<v)){\n                nne |= cs[i].ne;\n                npower += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(npower, nne)));\n        \n        \n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if(((ne | cs[i].ne) ^ ne) < (1LL<<v)){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\nstruct MaximumIndependentSet {\n    using T = int;\n    MaximumIndependentSet(const int n) : n{n}, former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost(n, 1), elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    MaximumIndependentSet(const vector<T>& cost) : n(cost.size()), former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost{cost}, elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    void addEdge(const int from, const int to)\n    {\n        assert(0 <= from);\n        assert(from < n);\n        assert(0 <= to);\n        assert(to < n);\n        elist[from].push_back(to);\n        elist[to].push_back(from);\n    }\n\n    T calculate()\n    {\n        if (n == 0) {\n            return 0;\n        } else if (n == 1) {\n            return max(cost[0], static_cast<T>(0));\n        }\n        for (ll i = 0; i < latter_maximum; i++) {\n            for (int j = 0; j < latter; j++) {\n                if (i & (1LL << j)) {\n                    ll mask = i - (1LL << j);\n                    for (const int to : elist[j + former]) {\n                        if (to >= former) {\n                            if (i & (1LL << (to - former))) {\n                                mask &= ~(1LL << (to - former));\n                            }\n                        }\n                    }\n                    latter_dp[i] = max(latter_dp[i - (1LL << j)], latter_dp[mask] + cost[j + former]);\n                    break;\n                }\n            }\n        }\n\n        T maximum = latter_dp[latter_maximum - 1];\n        for (ll i = 1; i < former_maximum; i++) {\n            for (int j = 0; j < former; j++) {\n                if (i & (1LL << j)) {\n                    if (former_dp[i - (1LL << j)] != -INF<T>) {\n                        bool ok = true;\n                        ll mask = former_next[i - (1LL << j)];\n                        for (const int to : elist[j]) {\n                            if (to >= former) {\n                                mask &= ~(1LL << (to - former));\n                            } else {\n                                if (i & (1LL << to)) {\n                                    ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (ok) {\n                            former_dp[i] = former_dp[i - (1LL << j)] + cost[j];\n                            former_next[i] = mask;\n                            maximum = max(maximum, former_dp[i] + latter_dp[mask]);\n                        } else {\n                            former_dp[i] = -INF<T>;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        return maximum;\n    }\n\n    const int n;\n    const int former;\n    const int latter;\n    const ll former_maximum;\n    const ll latter_maximum;\n    const vector<T> cost;\n    vector<vector<int>> elist;\n    vector<T> former_dp;\n    vector<T> latter_dp;\n    vector<ll> former_next;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        map<string, int> id;\n        vector<vector<string>> neighbor(N);\n        vector<int> power(N);\n        for (int i = 0; i < N; i++) {\n            string s;\n            cin >> s;\n            id[s] = i;\n            int B;\n            cin >> B;\n            power[i] = B;\n            int C;\n            cin >> C;\n            for (int j = 0; j < C; j++) {\n                string d;\n                cin >> d;\n                neighbor[i].push_back(d);\n            }\n        }\n        constexpr int LARGE = INF<int> / 16;\n        int ans = power[0] - LARGE;\n        power[0] = LARGE;\n        MaximumIndependentSet g{power};\n        for (int i = 0; i < N; i++) {\n            for (const string& s : neighbor[i]) {\n                g.addEdge(i, id[s]);\n            }\n        }\n        cout << ans + g.calculate() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nvector<i64> edges(n + 10, 0);\nvector<int> x(n + 10, 0);\nvector<int> sum(n + 10, 0);\nint result = 0;\nvoid dfs(int i, i64 bit, int now_sum) {\n  result = max(result, now_sum);\n  if (i == n)\n    return;\n  //枝刈り\n  if (now_sum + sum[i] <= result)\n    return;\n  // throw\n  dfs(i + 1, bit, now_sum);\n\n  if (!(bit & edges[i]))\n    dfs(i + 1, bit | (1LL << i), now_sum + x[i]);\n};\nint get_i(map<string,int> &mp,string &s) {\n  if (mp.count(s)) {\n    return mp[s];\n  } else {\n    mp[s] = mp.size();\n    return (int)mp.size() - 1;\n  }\n};\n\nint main(){\n    cin >> n;\n    while(n){\n        edges.assign(n + 10, 0);\n        x.assign(n + 10, 0);\n        map<string,int> mp;\n        for (int c = 0; c < n; c++) {\n          string s;\n          cin >> s;\n          int i = get_i(mp,s);\n          int C;\n          cin >> x[i] >> C;\n          for (int d = 0; d < C; d++) {\n            cin >> s;\n            edges[i] |= (1LL << get_i(mp,s));\n          }\n        }\n\n        sum.assign(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        result = 0;\n        dfs(1,1,x[0]);\n        cout << result;\n        cin >> n;\n        if(n) cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    vector<vector<string>> graph_(n);\n    map<string,int> encode;\n    vector<string> decode(n);\n    vector<int> strength(n),sum(n);\n    rep(i,0,n){\n        string a;\n        int b,c;\n        cin >> a >> b >> c;\n        encode[a]=i;\n        decode[i]=a;\n        strength[i]=b;\n        sum[i]=b;\n        if(i>0) sum[i]+=sum[i-1];\n        rep(j,0,c){\n            string d;\n            cin >> d;\n            graph_[i].push_back(d);\n        }\n    }\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        rep(j,0,graph_[i].size()){\n            graph[i].push_back(encode[graph_[i][j]]);\n        }\n    }\n\n    int maxi=0;\n    function<int(int,int,int)> rec=[&](int s,int i,int k){\n        if(i==n) return k;\n        if(k+sum[n-1]-sum[i-1]<=maxi) return 0;\n        int res=0;\n        bool f=true;\n        for(int j:graph[i]) if((s>>j)&1){\n            f=false;\n            break;\n        }\n        res=rec(s,i+1,k);\n        if(f) res=max(res,rec(s|(1<<i),i+1,k+strength[i]));\n        return maxi=max(maxi,res);\n    };\n\n    cout << rec(1,1,strength[0]) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N;\nint b[50], c[50];\nstring d[50][50];\nstring a[50];\n\nlong long can[50]; //いけないところは1\n\nmap< string , int > java;\nmap< long long, int> dp; \n\nint rec(long long ikeru, long long used){ //いけるとこ0\n  if(dp.find(used)!=dp.end()) return dp[used];\n  int ret = 0;\n  for(int i = 0; i < N; i++){\n    if((ikeru >> i) & 1) continue;\n    if((used >> i) & 1) continue;\n    if(used & can[i]) continue;\n    ret = max( ret, rec((ikeru|can[i]),used|(1 << i)) + b[i]);\n  }\n  return dp[used] = ret;\n}\n\nint main(){\n\n  while(cin >> N, N){\n    java.clear();\n    dp.clear();\n    for(int i = 0; i < N; i++){\n      cin >> a[i] >> b[i] >> c[i];\n      java[a[i]] = i;\n\n      for(int j = 0; j < c[i]; j++){\n        cin >> d[i][j];\n      }\n    }\n\n    for(int i = 0; i < N; i++){\n      can[i] = 0;\n      for(int j = 0; j < c[i]; j++){\n        can[i] |= 1 << java[d[i][j]];\n      }\n    }\n\n    \n    cout << rec( can[0], 1) + b[0] << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nvector<int> atk, bit;\n\nvoid input(int n){\n\tvector<string> name(n);\n\tvector<vector<string>> near(n);\n\n\tmap<string, int> id;\n\trep(i,n){\n\t\tint d;\n\t\tcin >> name[i] >> atk[i] >> d;\n\t\tid[name[i]] = i;\n\t\twhile(d--){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tnear[i].emplace_back(s);\n\t\t}\n\t}\n\n\trep(i,n){\n\t\t//bit[i] |= 1 << i;\n\t\tfor(auto s : near[i]){\n\t\t\tbit[i] |= 1 << id[s];\n\t\t}\n\t\t//cout << bitset<10>(bit[i]) << endl;\n\t}\n}\n\nvoid dfs(int& n, int& low, int& high, map<pair<int, int>, int>& memo, int enemy, int frined, int sum){\n\tif(memo.count(make_pair(enemy, frined))){\n\t\tif(memo[make_pair(enemy, frined)] >= sum) return;\n\t}\n\tmemo[make_pair(enemy, frined)] = sum;\n\trange(i,low,high){\n\t\tif(getBit(enemy,i)) continue;\n\t\tif(getBit(frined,i)) continue;\n\t\tdfs(n, low, high, memo, enemy bitor bit[i], frined bitor (1 << i), sum + atk[i]);\n\t}\n}\n\nconst int MAX = 16;\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tatk = vector<int>(n);\n\t\tbit = vector<int>(n,0);\n\t\tinput(n);\n\n\t\tint half = n / 2;\n\n\t\tmap<pair<int,int>, int> memo1, memo2;\n\t\tint s = 0;\n\t\tdfs(n, s, half, memo1, 1, bit[0], atk[0]);\n\t\tdfs(n, half, n, memo2, 0, 0, 0);\n\n\t\tvector<int> dp(1 << MAX, 0); // dp[s] := 集合sから任意の数, 仲間を選べるときの最大値\n\t\tfor(auto i : memo2){\n\t\t\tdp[i.first.second] = i.second;\n\t\t}\n\t\trep(i, 1 << MAX){\n\t\t\trep(j,MAX){\n\t\t\t\tdp[setBit(i,j)] = max(dp[setBit(i,j)], dp[i]);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\tfor(auto i : memo1){\n\t\t\tbitset<MAX> b(i.first.second);\n\t\t\tans = max(ans, i.second + dp[(~b).to_ulong()]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nint N;\nint B[40];\nlong long pb[40];\nmap<int,map<long long,int> > mem;\n\nint dfs(int x,long long cpb){\n  if(x==N)return 0;\n  long long fpb=cpb>>x;\n  if(mem[x].count(fpb))return mem[x][fpb];\n  int r=dfs(x+1,cpb);\n  if(!(cpb>>x&1)){\n    r=max(r,B[x]+dfs(x+1,cpb|pb[x]));\n  }\n  return mem[x][cpb]=r;\n}\n\nint main(){\n  while(cin>>N,N){\n    mem.clear();\n    map<string,int> m;\n    vector<string> d[40];\n    for(int i=0;i<N;i++){\n      string a;\n      int c;\n      cin>>a>>B[i]>>c;\n      m[a]=i;\n      d[i].resize(c);\n      for(int j=0;j<c;j++){\n\tcin>>d[i][j];\n      }\n    }\n    for(int i=0;i<N;i++){\n      pb[i]=0;\n      for(auto e:d[i]){\n\tpb[i]|=1LL<<m[e];\n      }\n    }\n    cout<<B[0]+dfs(1,pb[0])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N, B[40];\nvector<int> D[40];\n\nint dfs(int n, int *flag_)\n{\n    int preproc = 0, res = 0;\n    int flag[40];\n    for(int i = 0; i < N; ++i)\n        flag[i] = flag_[i];\n    \n    flag[n] = 1;\n    for(int i = 0; i < D[n].size(); ++i)\n        flag[D[n][i]] = -1;\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n    \tif(flag[i] != 0) continue;\n        bool f = true;\n        for(int j = 0; j < D[i].size(); ++j)\n            if(flag[D[i][j]] != -1) {\n                f = false; break;\n            }\n        if(f)\n            flag[i] = 1, preproc += B[i];\n    }\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n        if(flag[i] != 0) continue;\n        int tmp = B[i] + dfs(i, flag);\n        res = max(res, tmp);\n        flag[i] = -1;\n    }\n    \n    return preproc + res;\n}\n\nint main()\n{\n    int C;\n    string A, Dt;\n    \n    while(cin >> N && N)\n    {\n        map<string, int> table;\n        vector<string> Ds[40];\n        for(int i = 0; i < 40; ++i) D[i].clear();\n        \n        for(int i = 0; i < N; ++i)\n        {\n            cin >> A >> B[i] >> C;\n            for(int j = 0; j < C; ++j)\n                cin >> Dt, Ds[i].push_back(Dt);\n            table[A] = i;\n        }\n        for(int i = 0; i < N; ++i)\n            for(int j = 0; j < Ds[i].size(); ++j)\n                D[i].push_back(table[Ds[i][j]]);\n        \n        int flag[40] = {};\n        int res = B[0] + dfs(0, flag);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nvector<int> G[44];\nint B[44];\nbool ok[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\n\nbool used[55];\nbool sele[55];\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[i] && !used[i] && !sele[i] ) cnt++;\n  }\n  //cout << id << \" \"<< cnt << \" \"<< M << endl;\n  return cnt > M;\n}\nint solve(int id){\n  if( id == N ) return 0;\n  if( ok[id] || used[id] ) return solve(id+1);\n  if( check(id) ) return 0;\n  \n  bool tmp[41]={};\n  sele[id] = true;\n  for(int i=0;i<N;i++) tmp[i] = used[i];\n  for(int i=0;i<(int)G[id].size();i++) used[G[id][i]] = true;\n  int res = solve(id+1)+B[id];\n\n  //cout << \"view\" << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << endl; }\n  //cout << id << \" \" << res << endl;\n\n  for(int i=0;i<N;i++) used[i] = tmp[i];\n  sele[id] = false;\n  \n  int sum = 0;\n  for(int i=id+1;i<N;i++) if( !ok[i] && !used[i] ) sum += B[i];\n  if( sum > res )\n    res = max( res,solve(id+1) );\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id].clear();\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id].push_back( nd );\n      }\n    }\n\n    \n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i].empty() ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    memset(used,0,sizeof(used));\n    memset(sele,0,sizeof(sele));\n    M = (N+1)/2;\n    if( !G[0].empty() ) res += B[0];\n    sele[0] = true;\n    for(int i=0;i<(int)G[0].size();i++) used[G[0][i]] = true;\n    res += solve(1);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin >> N,N){\n\tmap<string,int> country;\n\tvector<vector<string>> adj(N);\n\tVI bs(N);\n\tREP(i,N){\n\t  string s;\n\t  cin >> s;\n\t  country[s] = i;\n\t  cin >> bs[i];\n\t  int C; cin >> C;\n\t  REP(j,C){\n\t\tcin >> s;\n\t\tadj[i].EB(s);\n\t  }\n\t}\n\tif(N == 1){\n\t  cout << bs[0] << endl;\n\t  continue;\n\t}\n\n\tVVI G(N);\n\tREP(i,N){\n\t  for(auto& s: adj[i])\n\t\tG[i].PB(country[s]);\n\t}\n\tVL ban(N);\n\tREP(i,N){\n\t  for(int to: G[i])\n\t\tban[i] = ban[i] | (1<<to);\n\t}\n\n\tint N2 = N / 2;\n\tint NR = N - N2;\n\tVI dp(1<<NR);\n\tREP(i,1<<NR){\n\t  int sum = 0;\n\t  LL x = (LL)(i) << N2;\n\t  REP(j,NR)\n\t\tif(i>>j&1){\n\t\t  sum += bs[j+N2];\n\t\t  if((ban[j+N2] & x) != 0){\n\t\t\tsum = -1e9;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t  if(sum >= 0)\n\t\tdp[((1<<NR)-1)^i] = sum;\n\t}\n\t\n\tfor(int i=0;i<NR;++i){\n\t  for(int b=0;b<(1<<NR);++b){\n\t\tif((b>>i&1) == 0)\n\t\t  maxi(dp[b], dp[b|(1<<i)]);\n\t  }\n\t}\n\t//REP(i,1<<N2) cout << bitset<4>(i) << \": \" << dp[i] << endl;\n\tint ans = 0;\n\tfor(int b=1;b<1<<N2;b+=2){\n\t  int sum = 0;\n\t  LL x = b;\n\t  LL b2 = 0;\n\t  REP(j,N2)\n\t\tif(b>>j&1){\n\t\t  b2 = b2 | ban[j];\n\t\t  sum += bs[j];\n\t\t  if((ban[j] & x) != 0){\n\t\t\tsum = -1e9;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t  if(sum < 0) continue;\n\t  b2 = b2 >> N2;\n\t  ans = max(ans, sum + dp[b2]);\n\t}\n\tcout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\nint ans;\nvoid dfs(int pos, int b) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tfor (; pos < names.size(); pos++) {\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t}\n}\nint main() {\n\tint n;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tans = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\tvector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\tlist.push_back(a);\n\t\t\t}\n\t\t\tbuf.insert(make_pair(name, move(list)));\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\nusing pll = pair<ll, ll>;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\nvector<pair<int, pll>> buf;\npll m;\nvoid dfs(int f,int pos,int cnt,ll s) {\n\tif (buf.size() == pos) {\n\t\tm = max(m, pll(cnt,s));\n\t\treturn;\n\t}\n\tif (buf.size() - pos + cnt <= m.first)return;\n\tif (!(f&buf[pos].second.first))dfs(f | 1<<pos, pos + 1, cnt + 1, s | 1ll << pos);\n\tdfs(f, pos + 1, cnt, s);\n}\nint main() {\n\tint n;\n\tcin >> n;\n\twhile (n--) {\n\t\tint a;\n\t\tcin >> a;\n\t\tm = pii();\n\t\tdfs(0,0,0,0);\n\t\tll f = m.second;\n\t\tll s = 0;\n\t\tint k = 0;\n\t\tint mf = 0;\n\t\tfor (int i = 0; 1ll << i <= f; i++)if (f & 1ll << i) if( buf[i].first > 1)mf |= 1ll << (buf.size() + k++); else mf |= 1ll << i;\n\t\tif (a > m.first)mf |= 1 << buf.size() + k;\n\t\tint l = 0;\n\t\tfor (int i = 0; f >= 1ll << i&&a; i++) {\n\t\t\tif (f & 1ll << i) {\n\t\t\t\tif (buf[i].first == 1) {\n\t\t\t\t\tbuf[i].second.first |= mf;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tbuf.push_back(make_pair(1, pii(buf[i].second.first | mf, buf[i].second.second)));\n\t\t\t\t\tbuf[i].first--;\n\t\t\t\t\tbuf[i].second.first |= 1 << i;\n\t\t\t\t}\n\t\t\t\ta--;\n\t\t\t}\n\t\t}\n\t\tif (a) {\n\t\t\tbuf.push_back(make_pair(a, pll(mf, buf.size())));\n\t\t}\n\t}\n\tint ans = 0;\n\tfor (auto &a : buf)ans += a.first;\n\tcout << ans << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N, B[40];\nvector<int> D[40];\n\nint dfs(int n, int *flag_)\n{\n    int preproc = 0, res = 0;\n    int flag[40];\n    for(int i = 0; i < N; ++i)\n        flag[i] = flag_[i];\n    \n    flag[n] = 1;\n    for(int i = 0; i < D[n].size(); ++i)\n        flag[D[n][i]] = -1;\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n    \tif(flag[i] != 0) continue;\n        bool f = true;\n        for(int j = 0; j < D[i].size(); ++j)\n            if(flag[D[i][j]] != -1) {\n                f = false; break;\n            }\n        if(f)\n            flag[i] = 1, preproc += B[i];\n    }\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n        if(flag[i] != 0) continue;\n        int tmp = B[i] + dfs(i, flag);\n        res = max(res, tmp);\n        flag[i] = -1;\n    }\n    \n    return preproc + res;\n}\n\nint main()\n{\n    int C;\n    string A, Dt;\n    while(cin >> N && N)\n    {\n        map<string, int> table;\n        vector<string> Ds[40];\n        for(int i = 0; i < 40; ++i) D[i].clear();\n        \n        for(int i = 0; i < N; ++i)\n        {\n            cin >> A >> B[i] >> C;\n            for(int j = 0; j < C; ++j)\n                cin >> Dt, Ds[i].push_back(Dt);\n            table[A] = i;\n        }\n        for(int i = 0; i < N; ++i)\n            for(int j = 0; j < Ds[i].size(); ++j)\n                D[i].push_back(table[Ds[i][j]]);\n        \n        int flag[40] = {};\n        int res = B[0] + dfs(0, flag);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\nconst ld eps=1e-9;\n\n//// < \"D:\\D_Download\\Visual Studio 2015\\Projects\\programing_contest_c++\\Debug\\a.txt\"\n\nint ans = 0;\nint N;\nvector<int>rests;\n\nvoid getans(const int sum,const int now, const vector < pair<int, vector<int>>>&connects, vector<int>&oks) {\n\tif (now == N)ans =max(ans, sum);\n\telse {\n\t\t//if (sum + rests[now] < ans)return;\n\t\tif (oks[now]) {\n\t\t\tvector<int>preoks(oks);\n\t\t\tpreoks[now] = false;\n\t\t\tfor (auto e : connects[now].second) {\n\t\t\t\tpreoks[e] = false;\n\t\t\t}\n\t\t\tgetans(sum + connects[now].first, now+1, connects, preoks);\n\t\t\t\n\t\t}\n\t\tif (now) {\n\n\t\t\tgetans(sum, now + 1, connects, oks);\n\t\t}\n\t}\n}\nint main() {\n\twhile (1) {\n\t\tcin >> N;\n\t\tif (!N)break;\n\t\tans = 0;\n\t\trests.clear();\n\t\trests.resize(N);\n\t\tif (!N)break;\n\t\tmap<string, int>mp;\n\t\tvector<pair<int,vector<int>>>connects(N);\n\t\tint num = 0;\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring name; int b, c; cin >> name >> b >> c;\n\t\t\tif (mp.find(name) == mp.end()) {\n\t\t\t\tmp[name] = num;\n\t\t\t\tnum++;\n\t\t\t}\n\t\t\tint myid = mp[name];\n\t\t\tconnects[myid].first = b;a\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\tif (mp.find(st) == mp.end()) {\n\t\t\t\t\tmp[st] = num;\n\t\t\t\t\tnum++;\n\t\t\t\t}\n\t\t\t\tint opid = mp[st];\n\n\t\t\t\tconnects[mp[name]].second.emplace_back(opid);\n\t\t\t}\n\t\t}\n\t\t//sort(connects.begin(), connects.end());\n\t\t//reverse(connects.begin(), connects.end());\n\t\trests[N - 1] = connects[N - 1].first;\n\t\tfor (int i = N - 2; i >= 0; --i) {\n\t\t\trests[i] = rests[i + 1] + connects[i].first;\n\t\t}\n\n\t\tvector<int>oks(N, true);\n\t\tgetans(0, 0, connects, oks);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint N,M;\n\nvector<int> G[44];\nint B[44];\nbool ok[44];\nint idx[44];\n\nint checkstr( map<string,int> &mp, const string &s,int &cnt ){\n  if( mp.count(s) == 0 )\n    mp[s] = cnt++;\n  return mp[s];\n}\n\n\nbool used[55];\nbool sele[55];\nbool check(int id){\n  int cnt = 0;\n  for(int i=0;i<id;i++){\n    if( !ok[i] && !used[i] && !sele[i] ) cnt++;\n  }\n  //cout << id << \" \"<< cnt << \" \"<< M << endl;\n  // return cnt > M;\n  return false;\n}\nint solve(int num){\n  int id = idx[num];\n  if( num == N ) return 0;\n  if( sele[id] || ok[id] || used[id] ) return solve(num+1);\n  if( check(num) ) return 0;\n  \n  bool tmp[41]={};\n  sele[id] = true;\n  for(int i=0;i<N;i++) tmp[i] = used[i];\n  for(int i=0;i<(int)G[id].size();i++) used[G[id][i]] = true;\n  int res = solve(num+1)+B[id];\n\n  //cout << \"view\" << endl;\n  //for(int i=0;i<N;i++) { cout << ok[i] << \" \" << used[i] << \" \" << sele[i] << endl; }\n  //cout << id << \" \" << res << endl;\n  \n  int sum = 0;\n  //for(int i=id;i<N;i++) if( !sele[i] && !ok[i] && !used[i] ) sum += B[i];\n  for(int i=num+1;i<N;i++) if( !sele[idx[i]] && !ok[idx[i]] && !used[idx[i]] ) sum += B[idx[i]];\n\n  for(int i=0;i<N;i++) used[i] = tmp[i];\n  sele[id] = false;\n\n  if( sum > res )\n    res = max( res,solve(num+1) );\n  return res;\n}\n\nint main(){\n  while( cin >> N && N ){\n    int cnt = 0;\n    map<string,int> mp;    \n    vector<pair<int,int>> point;\n    for(int i=0;i<N;i++){\n      string s; cin >> s;\n      int id = checkstr( mp, s, cnt );\n      int c; \n      cin >> B[id] >> c;      \n      G[id].clear();\n      point.push_back( make_pair( B[id], id ) );\n      assert( id < N );\n      for(int j=0;j<c;j++){\n        string d; cin >> d;\n        int nd = checkstr( mp, d, cnt );\n        G[id].push_back( nd );\n      }\n    }\n\n    sort( point.rbegin(), point.rend() );\n    for(int i=0;i<(int)point.size();i++)\n      idx[i] = point[i].second;\n\n    int res = 0;\n    for(int i=0;i<N;i++){\n      ok[i] = false;\n      if( G[i].empty() ){\n        ok[i] = true;\n        res += B[i];\n      }\n    }\n    memset(used,0,sizeof(used));\n    memset(sele,0,sizeof(sele));\n    M = (N+1)/2;\n    if( !G[0].empty() ) res += B[0];\n    sele[0] = true;\n    for(int i=0;i<(int)G[0].size();i++) used[G[0][i]] = true;\n    res += solve(0);\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_N 41\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Country{\n  int index,power;\n  Country(int index=IINF,int power=IINF):index(index),power(power){}\n  bool operator < (const Country& c)const{ return power > c.power; }\n};\n\nint N,answer,V,sum[MAX_N];\null adj_bitmask[MAX_N],initial_bitmask;\nCountry c_list[MAX_N];\nmap<int,string> debug;\n\ninline void input(){\n  V = 0;\n  initial_bitmask = 1;\n  int dex = 0,i_tmp;\n  map<string,int> getIndex;\n  set<string> ban;\n  string s_tmp;\n  rep(i,N){\n    cin >> s_tmp >> i_tmp;\n    if( ban.find(s_tmp) != ban.end() ){\n      cin >> i_tmp;\n      rep(i,i_tmp)cin>>s_tmp;\n      continue;\n    }\n    if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n    int from = getIndex[s_tmp];\n    debug[from] = s_tmp;\n    if( from == 0 ) answer = i_tmp;\n    c_list[from] = Country(from,i_tmp);\n    adj_bitmask[from] = 0ULL;\n    cin >> i_tmp;\n    rep(j,i_tmp){\n      cin >> s_tmp;\n      if( from == 0 ){\n\tban.insert(s_tmp);\n\tcontinue;\n      }\n      if( ban.find(s_tmp) != ban.end() ) continue;\n      if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n      int to = getIndex[s_tmp];\n      adj_bitmask[from] |= (1<<to);\n    }\n  }\n  V = dex;\n}\n\nvoid dfs(int sp,int power,ull bitmask){\n\n  if( power + sum[sp] <= answer ) return;\n  answer = max(answer,power);\n  if( sp >= V ) return;\n   \n  REP(i,sp,V){\n    if( (bitmask>>c_list[i].index) & 1 ) continue;\n    if( bitmask & adj_bitmask[c_list[i].index] ) continue;\n    dfs(i+1,power+c_list[i].power,bitmask|adj_bitmask[c_list[i].index]);\n    break;\n  }\n\n}\n\nint main(){\n  while(cin>>N,N){\n    input();\n    sort(c_list,c_list+V);\n    rep(i,V)sum[i] = 0;\n    sum[0] = c_list[0].power;\n    REP(i,1,V) sum[i] = sum[i-1] + c_list[i].power;\n    dfs(0,answer,initial_bitmask);\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nint ans;\nint bs[114514];\nint cs[114514];\nchar buf[114514];\nbool used[114514];\nstring as[114514];\nvector<int> es[114514];\nvector<string> ds[114514];\nmap<string, int> rev;\n\nvoid calc(int v, int sum) {\n  if (v >= n) {\n    ans = max(ans, sum);\n    return;\n  }\n\n  if (!used[v]) {\n    vector<int> restores;\n    used[v] = true;\n    for (int i=0; i<cs[v]; i++) {\n      int u = es[v][i];\n      if (!used[u]) {\n        used[u] = true;\n        restores.emplace_back(u);\n      }\n    }\n    calc(v+1, sum+bs[v]);\n    for (int u : restores) used[u] = false;\n  } \n  calc(v+1, sum);\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n    rev.clear();\n    for (int i=0; i<n; i++) {\n      scanf(\" %s\", buf);\n      as[i] = buf;\n      rev[as[i]] = i;\n      scanf(\"%d\", &bs[i]);\n      scanf(\"%d\", &cs[i]);\n      ds[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        scanf(\" %s\", buf);\n        ds[i][j] = buf;\n      }\n    }\n  \n    for (int i=0; i<n; i++) {\n      es[i].resize(cs[i]);\n      for (int j=0; j<cs[i]; j++) {\n        es[i][j] = rev[ds[i][j]];\n      }\n    }\n\n    int pre = bs[0];\n    used[0] = true;\n    for (int u : es[0]) {\n      used[u] = true;\n    }\n\n    for (int i=1; i<n; i++) {\n      if (used[i]) continue;\n      if (cs[i] == 0 || (cs[i] == 1 && bs[i] >= bs[es[i][0]])) {\n        pre += bs[i];\n        used[i] = true;\n        for (int u : es[i]) {\n          used[u] = true;\n        }\n      }\n    }\n  \n    ans = 0;\n    calc(1, pre);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef unsigned long long ull;\nmap<string,int> M;\nvector<string> NG[41];\nstring A[41];\nint n,B[41],ans;\nbool G[41][41];\null g[41];\n\nunordered_set <ull> S[41];\null used;\nvoid dfs(int pos,int sum,ull U){\n\n  ans=max(ans,sum);\n  while(pos<n&&(g[pos]&1LL))pos++;\n  if(pos==n)return;\n  if(S[pos].count(used))return;\n  S[pos].insert(used);\n  ull tmp=used,nU=U;\n  int nsum=sum;\n\n  if(U&(1LL<<pos)){\n    used=0,nU=0,nsum=0;\n    for(int i=0;i<pos;i++){\n      if((tmp&(1LL<<i))==0) continue; \n      if((g[pos]&(1LL<<i))==0) nU|=g[i],used|=(1LL<<i),nsum+=B[i];\n    }\n  }\n  \n  used|=(1LL<<pos);\n  dfs(pos+1,nsum+B[pos],nU|g[pos]);\n  used&=~(1LL<<pos);\n  if(used!=tmp)used=tmp,dfs(pos+1,sum,U);\n} \n\n\n\nint main(){\n  while(cin>>n,n){\n    M.clear();\n    for(int i=0;i<n;i++) S[i].clear();\n\n    for(int i=0,C;i<n;i++){\n      cin>>A[i]>>B[i]>>C;\n      M[A[i]]=i;\n      NG[i].resize(C);\n      for(int j=0;j<C;j++)cin>>NG[i][j];\n    }\n\n    \n    for(int i=0;i<n;i++){\n      g[i]=1LL<<i;\n      for(int j=0;j<(int)NG[i].size();j++)g[i]|=1LL<<M[NG[i][j]];\n    }\n    \n    ans=0;\n    used=1;\n    dfs(1,B[0],g[0]);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<sstream>\n#include<vector>\n#include<map>\n#include<queue>\n#include<set>\n#include<algorithm>\n#include<complex>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i, n) for(int i = 0; i < (int)n; i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(), (c).end()\n#define each(i, c) for(__typeof(c.begin()) i = c.begin(); i != c.end(); i++)\n#define dbg(x) cerr<<__LINE__<<\": \"<<#x<<\" = \"<<(x)<<endl\n\ntypedef pair<int, int> pi;\n\nconst int inf = (int)1e9;\nint n, b[100], c[100], dp1[1 << 20], dp2[1 << 20];\nint ng1[100], ng2[100], ng[100];\nstring name[100], d[100][100];\nbool e[100][100];\n\nint main(){\n\twhile(cin >> n, n){\n\t\tmemset(e, 0, sizeof(e));\n\t\tmap<string, int> id;\n\t\t\n\t\trep(i, n){\n\t\t\tcin >> name[i] >> b[i] >> c[i];\n\t\t\trep(j, c[i]) cin >> d[i][j];\n\t\t\tid[name[i]] = i;\n\t\t}\n\t\trep(i, n) rep(j, c[i]) e[i][id[d[i][j]]] = e[id[d[i][j]]][i] = 1;\n\t\t\n\t\tint N = (n + 1) / 2, M = n - N;\n\t\trep(i, 1 << N) dp1[i] = -inf;\n\t\trep(i, 1 << M) dp2[i] = -inf;\n\t\tdp1[1] = b[0]; dp2[0] = 0;\n\t\t\n\t\trep(i, N) ng1[i] = ng[i] = 0;\n\t\trep(i, M) ng2[i] = 0;\n\t\t\n\t\trep(i, N) rep(j, N) if(e[i][j]) ng1[i] |= 1 << j;\n\t\trep(i, M) rep(j, M) if(e[i + N][j + N]) ng2[i] |= 1 << j;\n\t\trep(i, N) rep(j, M) if(e[i][j + N]) ng[i] |= 1 << j;\n\t\t\n\t\tfor(int i = 1; i < 1 << N; i++){\n\t\t\tint l = 0;\n\t\t\tfor(; !(i & 1 << l); l++);\n\t\t\tint j = i ^ 1 << l;\n\t\t\tif(dp1[j] == -inf || (j & ng1[l])) continue;\n\t\t\tdp1[i] = dp1[j] + b[l];\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < 1 << M; i++){\n\t\t\tint l = 0;\n\t\t\tfor(; !(i & 1 << l); l++);\n\t\t\tint j = i ^ 1 << l;\n\t\t\tif(dp2[j] == -inf || (j & ng2[l])) continue;\n\t\t\tdp2[i] = dp2[j] + b[l + N];\n\t\t}\n\t\t\n\t\trep(i, 1 << M) rep(j, M) if(i & 1 << j)\n\t\t\tdp2[i] = max(dp2[i], dp2[i ^ 1 << j]);\n\t\t\n\t\tvector<pi> v;\n\t\trep(i, 1 << N) v.pb(mp(dp1[i], i));\n\t\tsort(all(v), greater<pi>());\n\t\t\n\t\tint ans = 0;\n\t\trep(i, v.size()){\n\t\t\tif(v[i].second + dp2[(1 << M) - 1] <= ans) break;\n\t\t\tint mask = 0;\n\t\t\trep(j, N) if(v[i].second & 1 << j) mask |= ng[j];\n\t\t\tans = max(ans, v[i].first + dp2[(1 << M) - 1 ^ mask]);\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cmath>\n#include<algorithm>\n#include<iomanip>\n#include<cassert>\n#include<sstream>\n#include<complex>\n#include<cstdio>\n#include<climits>\n#include<cstdlib>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<ctime>\n#include<cctype>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<28)\n#define all(n) (n).begin(),(n).end()\n#define eps (1e-10)\n#define equals(a,b) (fabs((a)-(b)) < eps) \n#define MAX 40\nusing namespace std;\n\nvector<int> G[MAX];\nint N,power[MAX],maxcost;\n\nvoid dfs(bool *color,int cost,int colored,int remain_cost)\n{\n  if(colored == N)\n    {\n      maxcost = max(maxcost,cost);\n      return;\n    }\n\n  if(remain_cost+cost <= maxcost)return;\n\n  rep(i,N)\n    {\n      if(color[i])continue;\n      bool next_color[N];\n      int next_colored = colored;\n      int next_remain_cost = remain_cost;\n      next_remain_cost -= power[i];\n      rep(j,N)next_color[j] = color[j];\n      next_color[i] = true;\n      next_colored++;\n      rep(j,G[i].size())\n\t{\n\t  if(!next_color[G[i][j]])\n\t    {\n\t      next_remain_cost -= power[G[i][j]];\n\t      next_color[G[i][j]] = true;\n\t      next_colored++;\n\t    }\n\t}\n      dfs(next_color,cost+power[i],next_colored,next_remain_cost);\n    }\n\n}\n\nint main()\n{\n  while(cin >> N,N)\n    {\n      maxcost = -inf;\n      rep(i,N)G[i].clear();\n      map<string,int> getIndex;\n      int cnt = 0,C,total_cost = 0;\n      string A,D;\n      vector<int> B(N);\n      vector<string> name_list;\n      rep(i,N)\n\t{\n\t  cin >> A >> B[i] >> C;\n\t  total_cost += B[i];\n\t  if(getIndex.find(A) == getIndex.end())getIndex[A] = cnt++;\n\t  int from = getIndex[A];\n\t  name_list.push_back(A);\n\t  rep(j,C)\n\t    {\n\t      cin >> D;\n\t      if(getIndex.find(D) == getIndex.end())getIndex[D] = cnt++;\n\t      int to = getIndex[D];\n\t      G[from].push_back(to);\n\t    }\n\t} \n\n      rep(i,N)power[getIndex[name_list[i]]] = B[i];\n\n\n      assert(cnt == N);\n      bool color[N];\n      int colored = 0;\n      rep(i,N)color[i] = false;\n      color[0] = true;\n      colored++;\n      total_cost -= power[0];\n      rep(i,G[0].size())\n\t{\n\t  colored++;\n\t  color[G[0][i]] = true;\n\t  total_cost -= power[G[0][i]];\n\t}\n\n      dfs(color,power[0],colored,total_cost);\n      cout << maxcost << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        vector<int> power(n);\n        map<string, int> mp;\n        vector<vector<string>> nearby(n);\n        for (int i = 0; i < n; ++i) {\n            string s;\n            int c;\n            cin >> s >> power[i] >> c;\n            if (i) {\n                for (auto& j : nearby[0]) {\n                    if (s == j) {\n                        --i;\n                        --n;\n                        for (int k = 0; k < c; ++k)\n                            cin >> s;\n\n                        goto A;\n                    }\n                }\n            }\n            mp[s] = i;\n            nearby[i].resize(c);\n            for (int j = 0; j < c; ++j)\n                cin >> nearby[i][j];\n\n            A:\n            continue;\n        }\n        power.resize(n);\n        nearby.resize(n);\n        vector<long long> isnearby(n, 0LL);\n        for (int i = 0; i < n; ++i)\n            for (auto& j : nearby[i])\n                if (mp.count(j))\n                    isnearby[i] |= 1LL << mp[j];\n\n        int n1 = n / 2;\n        int n2 = n - n1;\n        vector<int> dp(1 << n1, 0);\n        for (int i = 1; i < (1 << n1); i += 2) {\n            int ma = 0;\n            long long inb = 0;\n            for (int j = 0; j < n1; ++j) {\n                if ((i >> j) & 1) {\n                    inb |= isnearby[j];\n                    dp[i] += power[j];\n                    ma = max(ma, dp[i ^ (1 << j)]);\n                }\n            }\n            if (i & inb)\n                dp[i] = ma;\n        }\n        int msk = (1 << n1) - 1;\n        int ans = dp[msk];\n        for (int i = 1; i < (1 << n2); ++i) {\n            int sum = 0;\n            long long inb = 0;\n            for (int j = 0; j < n2; ++j) {\n                if ((i >> j) & 1) {\n                    inb |= isnearby[n1 + j];\n                    sum += power[n1 + j];\n                    if (i & (inb >> n1)) break;\n                }\n            }\n            if (!(i & (inb >> n1)))\n                ans = max(ans, sum + dp[(inb & msk) ^ msk]);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nmap<string,int> m;\nint idx=0;\nvector<int> G[101];\nvector<string> CS[101];\nstring names[101];\nint strong[101];\nbool used[101];\nint optNum;\n\n// 現在選べるものから選ぶ\nvoid dfs(int idx,int sum,int leftSum){\n  if(idx==N){\n    optNum=max(optNum,sum);\n    return;\n  }\n  if(used[idx]){\n    dfs(idx+1,sum,leftSum);\n    return;\n  }\n  if(leftSum+sum<=optNum)return;\n  bool ok=true;\n  // これから選ぶ頂点のどれかと隣接しているかチェック\n  for(int i=idx+1;i<N;i++){\n    if(used[i])continue;\n    for(int j=0;j<(int)G[i].size();j++){\n      if(G[i][j]==idx){\n\tok=false;\n\tbreak;\n      }\n    }\n    if(!ok)break;\n  }\n  // 隣接している頂点が存在する場合\n  if(idx!=0&&!ok){\n    // 取らない\n    dfs(idx+1,sum,leftSum-strong[idx]);\n  }\n  if(!used[idx]){\n    bool cur[50];\n    for(int i=0;i<N;i++)cur[i]=used[i];\n    int nLeftSum=leftSum;\n    nLeftSum-=strong[idx];\n    used[idx]=true;\n    for(int j=0;j<(int)G[idx].size();j++){\n      int to=G[idx][j];\n      if(!used[to])nLeftSum-=strong[to];\n      used[to]=true;\n    }\n    dfs(idx+1,sum+strong[idx],nLeftSum);\n    for(int j=0;j<N;j++)used[j]=cur[j];\n  }\n}\n\nint main(){\n  while(cin>>N&&N){\n    idx=0;\n    optNum=-1;\n    for(int i=0;i<101;i++){\n      G[i].clear();\n      CS[i].clear();\n    }\n    m.clear();\n    int sum=0;\n    for(int i=0;i<N;i++){\n      cin>>names[i]>>strong[i];\n      sum+=strong[i];\n      int C;\n      cin>>C;\n      for(int j=0;j<C;j++){\n\tstring s;\n\tcin>>s;\n\tif(m.count(s)==0)m[s]=idx++;\n\tCS[i].push_back(s);\n      }\n    }\n    for(int i=0;i<N;i++)\n      m[names[i]]=i;\n    for(int i=0;i<N;i++){\n      for(int j=0;j<(int)CS[i].size();j++){\n\tG[m[names[i]]].push_back(m[CS[i][j]]);\n\tG[m[CS[i][j]]].push_back(m[names[i]]);\n      }\n    }\n    memset(used,0,sizeof(used));\n    dfs(0,0,sum);\n    cout<<optNum<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint r[64], p[64];\nInt f[64];\n\nvoid collect(vector<int>& q, int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q.push_back(at);\n    rep (i, N) if (g[at][i]) collect(q, i);\n}\n\nvoid prepare(vector<int>& q) {\n    const int n = q.size();\n    sort(q.begin(), q.end());\n    rep (i, n) r[i] = q[i], p[i] = B[q[i]];\n    rep (i, n) {\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1<<j;\n    }\n}\n\nint rec(int n, int k, int u) {\n    if (k == n) return 0;\n    rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return -INF;\n    int ans = -INF;\n    if (u&(1<<k)) ans = max(ans, rec(n, k+1, u&((1<<n)-1-f[k])) + p[k]);\n    if (r[k]) ans = max(ans, rec(n, k+1, u));\n    return ans;\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        vector<int> q;\n        collect(q, i);\n        prepare(q);\n        ans += rec(q.size(), 0, (1<<q.size())-1);\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\nusing namespace std;\n\nint mx_tmp =0;\nvector<int> a,b;\nvector<vector<string> > c;\nvector<long long> g;\n\nint n;\nint dfs(int x,int s,long long y){\n    int xxx = 0;\n    for(int i=x;i<n;i++){\n        if((y>>i)&1)continue;\n        xxx += a[i];\n    }\n    if(s+xxx<mx_tmp)return -1;\n    int tmp = a[x];\n    int mx = 0;\n    y |= g[x];\n    long long z = y;\n    for(int i=x+1;i<n;i++){\n        if((y>>i)&1)continue;\n        int tmp2 = dfs(i,s+tmp,y);\n        if(mx < tmp2){\n            mx = tmp2;\n        }\n        mx_tmp = max(mx_tmp,tmp+mx);\n    }\n    return tmp + mx;\n}\n\nint main(){\n    while(cin>>n &&n!=0){\n        map<string,int>mp;\n        int cnt = 0;\n        a.clear();\n        b.clear();\n        c.clear();\n        g.clear();\n        a.resize(n);\n        b.resize(n);\n        c.resize(n);\n        g.resize(n);\n        for(int i=0;i<n;i++){\n            string s;\n            cin >> s;\n            mp[s] = cnt;\n            cnt++;\n            cin >> a[i] >> b[i];\n            for(int j=0;j<b[i];j++){\n                cin >> s;\n                c[i].push_back(s);\n            }\n        }\n        for(int i=0;i<n;i++){\n            g[i] = 1LL<<i;\n            for(int j=0;j<b[i];j++){\n                g[i]+=(1LL<<mp[c[i][j]]);\n            }\n        }\n        mx_tmp=0;\n        int ans = dfs(0,0,0);\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring a[40];\nint b[40];\nvector<string> d[40];\nmap<string,int> sn;\nvector<int> dn[40];\nint mr[40];\n\nbool cmp(int pa,int pb){\n  return b[pa]>b[pb];\n}\n\nint dfs(long long u,int c,int cm){\n  if(c==n){\n    return cm;\n  }else{\n    int m=dfs(u,c+1,cm);\n    int pr=0;\n    for(int i=c;i<n;i++){\n      pr+=b[mr[i]];\n    }\n    if(pr+cm>m&&!(u>>mr[c]&1)){\n      long long nu=u|1LL<<mr[c];\n      for(int i=0;i<dn[mr[c]].size();i++){\n\tnu|=1LL<<dn[mr[c]][i];\n      }\n      m=max(m,dfs(nu,c+1,cm+b[mr[c]]));\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    sn.clear();\n    for(int i=0;i<n;i++){\n      int c;\n      cin>>a[i]>>b[i]>>c;\n      sn[a[i]]=i;\n      d[i].resize(c);\n      while(c--){\n\tcin>>d[i][c];\n      }\n    }\n    for(int i=0;i<n;i++){\n      dn[i].resize(n);\n      for(int j=0;j<d[i].size();j++){\n\tdn[i][j]=sn[d[i][j]];\n      }\n    }\n    for(int i=0;i<n;i++){\n      mr[i]=i;\n    }\n    sort(mr,mr+n,cmp);\n    long long n=1;\n    for(int i=0;i<dn[0].size();i++){\n      n|=1LL<<dn[0][i];\n    }\n    cout<<dfs(n,0,b[0])<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef pair<int,int> P;\n\nint n,G[N][N],A[N],ans;\nvector<P> idx;\n\nvoid dfs(int x,int sum,vector<int> S){\n  \n  ans=max(ans,sum);\n  \n  if(x==n||ans>=sum+A[x]) return;\n  \n  dfs(x+1,sum,S);\n  \n  for(int i=0;i<S.size();i++)\n    if(G[S[i]][idx[x].second]) return;\n\n  S.push_back(idx[x].second);\n  \n  dfs(x+1,sum+idx[x].first,S);\n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cost,cnt=0;\n    \n    memset(G,0,sizeof(G));\n    idx.clear();\n    \n    for(int i=0;i<n;i++){\n      \n      string s;\n      cin>>s;\n\n      if(!num.count(s)) num[s]=cnt++;\n\n      int a, b;\n      cin>>a>>b;\n\n      if(i) idx.push_back(P(a,num[s]));\n      else cost=a;\n      \n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n      }\n      \n    }\n    \n    sort(idx.begin(),idx.end(),greater<P>());\n    \n    A[n-1]=idx[n-1].first;\n    \n    for(int i=n-2;i>=0;i--)\n      A[i]=A[i+1]+idx[i].first;\n    \n    ans=0;\n    \n    vector<int> s;\n    \n    s.push_back(0);\n    \n    dfs(0,cost,s);\n    \n    cout<<ans<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <string>\n#include <cstdint>\n#include <cassert>\n#include <functional>\n#include <vector>\n#include <unordered_map>\n#include <iostream>\nnamespace lc {\nstruct Edge {\n\tint to;\n\texplicit Edge(int to) : to(to) { }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType>\nclass AdjacencyList {\npublic:\n\ttypedef std::vector<EdgeType> ListType;\nprivate:\n\tstd::vector<ListType> m_lists;\npublic:\n\texplicit AdjacencyList(int n = 0)\n\t\t: m_lists(n)\n\t{ }\n\tint size() const { return m_lists.size(); }\n\ttemplate <typename... Args>\n\tvoid add_edge(int u, Args&&... args){\n\t\tm_lists[u].emplace_back(args...);\n\t}\n\tconst ListType &operator[](int u) const { return m_lists[u]; }\n};\n}\nnamespace lc {\ntemplate <typename EdgeType, typename Func>\nvoid enumerate_maximal_independent_sets(\n\tconst AdjacencyList<EdgeType> &graph, Func func)\n{\n\tconst int n = graph.size();\n\tstd::vector<uint64_t> bit_graph(n), incr_bit_graph(n + 1);\n\tfor(int i = n - 1; i >= 0; --i){\n\t\tuint64_t mask = 0;\n\t\tfor(const auto &e : graph[i]){ mask |= (1ull << e.to); }\n\t\tbit_graph[i] = mask;\n\t\tincr_bit_graph[i] = mask | incr_bit_graph[i + 1];\n\t}\n\tstd::function<void(int, uint64_t, uint64_t)> recur =\n\t\t[&, n](int i, uint64_t picked, uint64_t eliminated) -> void {\n\t\t\tif(i == n){\n\t\t\t\tif((picked | eliminated) == (1ull << n) - 1){ func(picked); }\n\t\t\t}else if((incr_bit_graph[i + 1] | eliminated) & (1ull << i)){\n\t\t\t\trecur(i + 1, picked, eliminated);\n\t\t\t\tif(!(eliminated & (1ull << i))){\n\t\t\t\t\trecur(\n\t\t\t\t\t\ti + 1, picked | (1ull << i),\n\t\t\t\t\t\teliminated | bit_graph[i]);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\trecur(i + 1, picked | (1ull << i), eliminated | bit_graph[i]);\n\t\t\t}\n\t\t};\n\trecur(0, 0, 0);\n}\n}\nnamespace lc {\nclass NameTable {\nprivate:\n\tstd::unordered_map<std::string, int> m_table;\n\tstd::vector<std::string> m_inv_table;\npublic:\n\tNameTable(){ }\n\tint operator[](const std::string &s){\n\t\tconst auto it = m_table.find(s);\n\t\tif(it != m_table.end()){ return it->second; }\n\t\tconst int t = m_inv_table.size();\n\t\tm_table.insert(std::make_pair(s, t));\n\t\tm_inv_table.push_back(s);\n\t\treturn t;\n\t}\n};\n}\nusing namespace std;\ntypedef lc::Edge Edge;\nint main(){\n\tios_base::sync_with_stdio(false);\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\t\tif(n == 0){ break; }\n\t\tlc::NameTable name_table;\n\t\tvector<int> powers(n);\n\t\tlc::AdjacencyList<Edge> graph(n);\n\t\tfor(int i = 0; i < n; ++i){\n\t\t\tstring u_name;\n\t\t\tint p, m;\n\t\t\tcin >> u_name >> p >> m;\n\t\t\tconst int u = name_table[u_name];\n\t\t\tpowers[u] = p;\n\t\t\tfor(int j = 0; j < m; ++j){\n\t\t\t\tstring v_name;\n\t\t\t\tcin >> v_name;\n\t\t\t\tconst int v = name_table[v_name];\n\t\t\t\tgraph.add_edge(u, v);\n\t\t\t}\n\t\t}\n\t\tint answer = 0;\n\t\tlc::enumerate_maximal_independent_sets(graph, [&](uint64_t s){\n\t\t\tif((s & 1) == 0){ return; }\n\t\t\tint sum = 0;\n\t\t\tfor(int i = 0; i < n; ++i){\n\t\t\t\tif(s & (1ull << i)){ sum += powers[i]; }\n\t\t\t}\n\t\t\tanswer = max(answer, sum);\n\t\t});\n\t\tcout << answer << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n//\nint64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp)max = tmp;\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<queue>\n\nusing namespace std;\n\n\n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#ifdef __BORLANDC__\n\ttypedef __int64 ll;\n#else\n\ttypedef long long ll;\n#endif\n\nconst ll L1 = 1;\nconst int N = 40;\nint M = 20;\n\nint n;\nll edge[N];\nint power[N];\n\nvoid printbit(ll state){\n\trep(i,n)printf(\"%d\",((L1<<i)&state)>0);puts(\"\");\n}\n\nvoid printedge(){\n\tprintf(\"edge\\n\");\n\trep(i,n)printbit(edge[i]);\n}\n\nbool init(){\n\tcin>>n;\n\tif(n==0)return false;\n\t\n\trep(i,N)edge[i]=power[i]=0;\n\t\n\tmap<string,int> mp;\n\tvector<string> estr[N];\n\trep(i,n){\n\t\tstring a;\n\t\tint b,c;\n\t\tcin>>a>>b>>c;\n\t\tmp[a]=i;\n\t\tpower[i]=b;\n\t\trep(j,c){\n\t\t\tstring d;\n\t\t\tcin>>d;\n\t\t\testr[i].push_back(d);\n\t\t}\n\t}\n\trep(i,n){\n\t\trep(j,estr[i].size()){\n\t\t\tedge[i] |= (L1<<mp[estr[i][j]]);\n\t\t}\n\t}\n\treturn true;\n}\n\nbool hasbit(ll state, int bit){return state&(L1<<bit);}\n\nint T = (1<<M);\nconst int TM = (1<<20);\nint half[TM];\n\nint left_search(){\n\trep(i,T)half[i]=0;\n\t\n\tint maxi = 0;\n\tfor(int i=1;i<T;i+=2){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\trep(j,M){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\t if(edge[j]&i)ok=false;\n\t\t\t\t sum += power[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ok)half[i]=sum;\n\t\tmaxi = max(maxi,half[i]);\n\t}\n\treturn maxi;\n}\n\nint memo[TM];\nint left_memo(int state){\n\tif(memo[state]!=-1)return memo[state];\n\t\n\tint ret = half[state];\n\trep(i,M){\n\t\tif(state&(1<<i)){\n\t\t\tret = max(ret, left_memo(state ^ (1<<i)));\n\t\t}\n\t}\n\treturn memo[state]=ret;\n}\n\nint right_search(){\n\tint ans = 0;\n\tfor(ll i=0; i<(L1<<n); i+=T){\n\t\tbool ok = true;\n\t\tint sum = 0;\n\t\tll mask = 0;\n\t\treps(j,M,n){\n\t\t\tif(hasbit(i,j)){\n\t\t\t\tif(edge[j]&i)ok=false;\n\t\t\t\tsum+=power[j];\n\t\t\t\tmask |= edge[j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(ok){\n\t\t\tmask &= (T-1);\n\t\t\tmask ^= (T-1);\n\t\t\t//printf(\"i=%d sum=%d memo[bit]=%d \",i,sum,memo[mask]);\n\t\t\t//printbit(mask);\n\t\t\tans = max(ans, memo[mask]+sum);\n\t\t}\n\t}\n\treturn ans;\n}\nvoid left_dp(){\n\trep(i,T)memo[i]=-1;\n\t\n\tleft_memo(T-1);\n}\n\nvoid printdp(){\n\trep(i,T){\n\t\tprintf(\"%3d \",memo[i]);printbit(i);\n\t}\n}\nvoid printsearch(){\n\trep(i,T){\n\t\tprintf(\"%3d \",half[i]);printbit(i);\n\t}\n}\nint solve(){\n\tM = (n+1)/2;\n\tT = (1<<M);\n\t\n\tint a = left_search();\n\tleft_dp();\n\t\n\t/*\n\tputs(\"s\");\n\tprintsearch();\n\tputs(\"d\");\n\tprintdp();\n\t*/\n\treturn max(a,right_search());\n}\n\nint main(){\n\twhile(init()){\n\t\tprintf(\"%d\\n\",solve());\n\t}\n}\n\n/*\n6\nINTERCAL 10 3 Chef Piet COW\nChef 7 3 INTERCAL Piet COW\nPiet 6 2 INTERCAL Chef\nCOW 7 2 INTERCAL Chef\nJ 6 1 A\nA 12 1 J\n0\n\n6\nINTERCAL 20 1 J\nChef 50 3 J A Piet\nPiet 30 2 A Chef\nCOW 15 1 J\nJ 40 3 COW INTERCAL Chef\nA 25 2 Chef Piet\n0\n\n*/"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint country2idx(map<string,int>& dict,string country){\n  int idx = dict.size();\n  if(dict.find(country) == dict.end()){\n    dict[country] = idx;\n    return idx;\n  }\n  return dict[country];\n}\n\nvector<int> edges[41];\nbool used[41];\nint power[41];\nint limit_gain[41];\n\nbool can_unite(int node){\n  if(used[node]) return false;\n  for(int i=0;i<edges[node].size();i++){\n    if(used[edges[node][i]]) return false;\n  }\n  return true;\n}\n\nint gRes;\nint dfs(int current,int sum,const vector<int>& subset){\n  if(current == subset.size()) return sum;\n  if(sum + limit_gain[current] < gRes) return 0;\n\n  gRes = max(gRes,sum);\n  int next = subset[current];\n  if(can_unite(next)){\n    used[next] = true;\n    gRes = max(gRes,dfs(current+1,sum + power[next],subset));\n    used[next] = false;\n  }\n  gRes = max(gRes,dfs(current+1,sum,subset));\n  return gRes;\n}\n\nclass UnionFindTree {\nprivate:\n  int parent[41];\n  int rank[41];\npublic:\n  UnionFindTree(){\n    for(int i = 0; i <= 40; i++){\n      parent[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  void unite(int lhs,int rhs) {\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(lhs == rhs) return;\n    \n    if(rank[lhs] < rank[rhs]){\n      parent[rhs] = lhs;\n      rank[rhs]++;\n    }\n    else{\n      parent[lhs] = rhs;\n      rank[lhs]++;\n    }\n  }\n\n  int find(int current){\n    if(current == parent[current]) return current;\n    else find(parent[current]);\n  }\n};\n\nint N;\nvoid make_subset(UnionFindTree* uft,int root,vector<int>& subset){\n  for(int i = 0; i < N; i++){\n    if(uft->find(i) == root){\n      subset.push_back(i);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    for(int i = 0; i <= 40; i++){\n      edges[i].clear();\n    }\n    UnionFindTree uft;\n    map<string,int> dict;\n    for(int country_i = 0; country_i < N; country_i++){\n      string country;\n      int tmp_power;\n      cin >> country >> tmp_power;\n      int adjacent_countries;\n      cin >> adjacent_countries;\n\n      int root = country2idx(dict,country);\n      power[root] = tmp_power;\n      for(int adj_i = 0; adj_i < adjacent_countries; adj_i++){\n        string adj_country;\n        cin >> adj_country;\n        int child = country2idx(dict,adj_country);\n        edges[root].push_back(child);\n        uft.unite(root,child);\n      }\n    }\n\n    bool tree[41];\n    memset(tree,false,sizeof(tree));\n\n    int res = 0;\n    for(int i = 0; i < N; i++){\n      if(tree[uft.find(i)]) continue;\n      tree[uft.find(i)] = true;\n      int tmp = 0;\n      vector<int> subset;\n      make_subset(&uft,uft.find(i),subset);\n\n      memset(limit_gain,0,sizeof(limit_gain));\n      gRes = 0;\n      for(int j = 0,k = subset.size(); j < subset.size(); k--,j++){\n        limit_gain[k-1] = limit_gain[k] + power[subset[j]];\n      }\n      memset(used,false,sizeof(used));\n      if(i == 0){\n        used[0] = true;\n        for(int j = 0; j < subset.size(); j++){\n          limit_gain[j] -= power[subset[0]];\n        }\n        tmp = max(tmp,dfs(0,power[0],subset));\n      }\n      else{\n        tmp = max(tmp,dfs(0,0,subset));\n      }\n      res += tmp;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nclass Edge\n{\n\tpublic:\n\tint to,cost;\n\tEdge(int t,int c)\n\t{\n\t\tto=t;cost=c;\n\t}\n};\nmap<string,int> mp;\nint strong[41];\nint rui[42];\nvector<Edge> g[41];\nint ans=0;\nint saiki(int now,int power,ll dou,ll ng,int n)\n{\n\tint ret=power;\n\tans=max(ret,ans);\n\tif(ret+rui[n]-rui[now]<ans)\n\t\treturn ret;\n\t//cerr<<now<<\" \"<<ret<<endl;\n\t//頂点nowにおいてngの更新をする\n\tfor(int i=0;i<g[now].size();i++)\n\t{\n\t\tEdge e=g[now][i];\n\t\tng|=(1LL<<(ll)e.to);\n\t}\n\tif((dou|ng|1)==(1LL<<(ll)(n+1))-1)\n\t\treturn ret;\n\t//全頂点について調べる\n\tfor(int i=now+1;i<n+1;i++)\n\t{\n\t\t//すでに使われているor使えない頂点は飛ばす\n\t\tll tmp=(1LL<<(ll)i);\n\t\tif((tmp&dou)>0 || (ng&tmp)>0)\n\t\t\tcontinue;\n\t\tans=max(ans,saiki(i,power+strong[i],dou|tmp,ng,n));\n\t}\n\treturn ret;\n}\n\nint main()\n{\n\twhile(1)\n\t{\n\t\tint n;\n\t\tint cnt=1;\n\t\tans=0;\n\t\tcin>>n;\n\t\tfor(int i=0;i<41;i++)\n\t\t\tg[i].clear();\n\t\tmp.clear();\n\t\tll dou=(1<<1);//自国を含む同盟の国\n\t\tll str=0;\n\t\tif(n==0)\n\t\t\tbreak;\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tstring a;\n\t\t\tcin>>a;\n\t\t\tif(mp[a]==0)\n\t\t\t{\n\t\t\t\tmp[a]=cnt;\n\t\t\t\tcnt++;\n\t\t\t}\n\t\t\tcin>>strong[mp[a]];\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\tif(mp[a]==1 || c==0)\n\t\t\t{\n\t\t\t\t//無条件に同盟に入れる\n\t\t\t\tstr+=strong[mp[a]];\n\t\t\t\tdou|=(1LL<<(ll)mp[a]);\n\t\t\t}\n\t\t\tfor(int j=0;j<c;j++)\n\t\t\t{\n\t\t\t\tstring d;\n\t\t\t\tcin>>d;\n\t\t\t\tif(mp[d]==0)\n\t\t\t\t{\n\t\t\t\t\tmp[d]=cnt;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t\tg[mp[a]].push_back(Edge(mp[d],1));\n\t\t\t}\n\t\t}\n\t\t//input end\n\t\trui[0]=0;\n\t\tfor(int i=1;i<n+1;i++)\n\t\t\trui[i]=rui[i-1]+strong[i];\n\t\t//cerr<<strong[mp[\"Qi\"]]<<endl;\n\t\tsaiki(1,str,dou,0,n);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\n\ninline int64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\t\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp){\n\t\t\t\tmax = tmp;\n\t\t\t}\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\ntypedef long long int64; \n\nint nstr;\nchar strings[40][17];\nvoid init_id(){\n\tnstr=0;\n}\nint get_id(char str[]){\n\tfor(int i=0;i<nstr;i++)\n\t\tif(strcmp(str,strings[i])==0)return i;\n\tstrcpy(strings[nstr],str);\n\treturn nstr++;\n}\nint64 get_bit(int id){\n\treturn (int64)1<<id;\n}\n\nstruct A{\n\tint id;\n\tint power;\n\tint64 neighbor;\n\tint count()const{\n\t\tint res=0;\n\t\tfor(int i=0;i<64;i++)res+= neighbor>>i&1;\n\t\treturn res;\n\t}\n\tbool operator <(const A&a)const{\n\t\treturn count() > a.count();\n\t}\n}kuni[40];\n\nint search(int i,int n,int power,int64 neighbor){\n\tint tmp,max;\t\n\tint64 a=neighbor;\n\n\tfor(int j=i;j<n;j++)\n\t\ta |= kuni[j].neighbor;\n\tfor(int j=i;j<n;j++){\n\t\tif( (get_bit(kuni[j].id) & a)==0){\n\t\t\tpower += kuni[j].power;\n\t\t\tneighbor |= get_bit(kuni[j].id);\n\t\t}\n\t}\n\tmax = power;\n\tfor(;i<n;i++){\n\t\tif( (get_bit(kuni[i].id) & neighbor)==0 ){\n\t\t\ttmp = search(i+1,n,power+kuni[i].power,neighbor|kuni[i].neighbor);\n\t\t\tif(max < tmp)max = tmp;\n\t\t}\n\t}\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tinit_id();\n\t\tfor(int i=0;i<n;i++){\n\t\t\tchar a[17],d[17];\n\t\t\tint b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tkuni[i].id = get_id(a);\n\t\t\tkuni[i].power = b;\n\t\t\tkuni[i].neighbor = 0;\n\t\t\twhile(c--){\n\t\t\t\tcin>>d;\n\t\t\t\tkuni[i].neighbor |= get_bit(get_id(d));\n\t\t\t}\n\t\t}\n\t\tsort(kuni+1,kuni+n);\n\t\tcout<<search(1,n,kuni[0].power,kuni[0].neighbor)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//46\n#include<iostream>\n#include<string>\n#include<map>\n#include<vector>\n#include<algorithm>\n\nusing namespace std;\n\nint n;\nstring a[40];\nint b[40];\nvector<string> d[40];\nmap<string,int> sn;\nvector<int> dn[40];\n\nint dfs(long long u,int c){\n  if(c==n){\n    return 0;\n  }else{\n    int m=dfs(u,c+1);\n    int i;\n    if(!(u>>c&1)){\n      long long nu=u|1LL<<c;\n      for(int i=0;i<dn[c].size();i++){\n\tnu|=1LL<<dn[c][i];\n      }\n      m=max(m,dfs(nu,c+1)+b[c]);\n    }\n    return m;\n  }\n}\n\nint main(){\n  while(cin>>n,n){\n    sn.clear();\n    for(int i=0;i<n;i++){\n      int c;\n      cin>>a[i]>>b[i]>>c;\n      sn[a[i]]=i;\n      d[i].resize(c);\n      while(c--){\n\tcin>>d[i][c];\n      }\n    }\n    for(int i=0;i<n;i++){\n      dn[i].resize(n);\n      for(int j=0;j<d[i].size();j++){\n\tdn[i][j]=sn[d[i][j]];\n      }\n    }\n    long long n=1;\n    for(int i=0;i<dn[0].size();i++){\n      n|=1LL<<dn[0][i];\n    }\n    cout<<dfs(n,1)+b[0]<<endl;\n  }\n  return 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nstruct before_main {\n  before_main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n  }\n} before_main;\n\n#define REP(i, a, b) for (int i = a; i < (int)b; i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef long long ll;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41];\nint weight_sum[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n\n  if (curr == N) {\n    ans = max(ans, wsum);\n    return;\n  }\n\n  if (wsum + weight_sum[N-1] - (curr ? weight_sum[curr - 1] : 0) <= ans)\n    return;\n\n  dfs(S, wsum, curr + 1);\n\n  rep(k, curr) {\n    if (adjacent[curr][k] && (S >> k & 1)) {\n      return;\n    }\n  }\n\n  dfs(S | (1LL << curr), wsum + weight[curr], curr + 1);\n}\n\nint main() {\n\n  while (cin >> N && N) {\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(_, N) {\n      string s;\n      cin >> s;\n      if (id.find(s) == id.end())\n        id[s] = v++;\n      cin >> weight[id[s]];\n      int n;\n      cin >> n;\n      rep(_, n) {\n        string t;\n        cin >> t;\n        if (id.find(t) == id.end())\n          id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) weight_sum[i] = weight[i] + (i ? weight_sum[i-1] : 0);\n\n    ans = 0;\n    dfs(1, weight[0], 1);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    vector<vector<string>> graph_(n);\n    map<string,int> encode;\n    vector<int> strength(n),sum(n);\n    rep(i,0,n){\n        string a;\n        int b,c;\n        cin >> a >> b >> c;\n        encode[a]=i;\n        strength[i]=b;\n        sum[i]=b;\n        if(i>0) sum[i]+=sum[i-1];\n        rep(j,0,c){\n            string d;\n            cin >> d;\n            graph_[i].push_back(d);\n        }\n    }\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        rep(j,0,graph_[i].size()){\n            graph[i].push_back(encode[graph_[i][j]]);\n        }\n    }\n\n    int maxi=0;\n    function<int(int,int,int)> rec=[&](int s,int i,int k){\n        if(i==n) return k;\n        if(k+sum[n-1]-sum[i-1]<=maxi) return 0;\n        int res=0;\n        bool f=true;\n        for(int j:graph[i]) if((s>>j)&1){\n            f=false;\n            break;\n        }\n        res=rec(s,i+1,k);\n        if(f) res=max(res,rec(s|(1<<i),i+1,k+strength[i]));\n        return maxi=max(maxi,res);\n    };\n\n    cout << rec(1,1,strength[0]) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nstruct renamer\n{\n  map<string,int> m;\n  int operator()(const string& s)\n  {\n    if (m.count(s)) {\n      return m[s];\n    } else {\n      const int id = m.size();\n      m.insert(make_pair(s, id));\n      return id;\n    }\n  }\n};\n\ntypedef unsigned long long ull;\n\null invalidate(const vector<vector<int> >& g, ull invalid, int u)\n{\n  const int N = g.size();\n  for (int i = 0; i < N; i++) {\n    if (g[u][i]) {\n      invalid |= 1ULL<<i;\n    }\n  }\n  invalid |= 1ULL<<u;\n  return invalid;\n}\n\nint solve(const vector<vector<int> >& g, const vector<int>& scores, int u, ull used, ull invalid, int acc)\n{\n  const int N = g.size();\n  if (u == N) {\n    return acc;\n  }\n  for (int i = u; i < N; i++) {\n    if (invalid & (1ULL<<i)) {\n      continue;\n    }\n    for (int j = 0; j < N; j++) {\n      if (g[j][i]) {\n        if (j >= u) {\n          goto NEXT;\n        }\n        if (used << (1ULL<<j)) {\n          goto NEXT;\n        }\n      }\n    }\n    used |= 1ULL<<i;\n    invalid = invalidate(g, invalid, i);\n    acc += scores[i];\nNEXT:\n    ;\n  }\n  if (invalid & (1ULL<<u)) {\n    return solve(g, scores, u+1, used, invalid, acc);\n  }\n  // if u is excluded\n  int m = solve(g, scores, u+1, used, invalid, acc);\n\n  // if u is included\n  for (int i = 0; i < N; i++) {\n    if (g[i][u]) {\n      if (used & (1ULL<<i)) {\n        goto FAIL;\n      }\n    }\n  }\n  used |= 1ULL<<u;\n  invalid = invalidate(g, invalid, u);\n  m = max(m, solve(g, scores, u+1, used, invalid, acc + scores[u]));\nFAIL:\n  return m;\n}\n\nint main()\n{\n  int N;\n  while (cin >> N && N != 0) {\n    vector<vector<int> > g(N, vector<int>(N, false));\n    vector<int> scores(N);\n    renamer rename;\n    for (int i = 0; i < N; i++) {\n      string s;\n      int b, c;\n      cin >> s >> b >> c;\n      const int u = rename(s);\n      scores[u] = b;\n      for (int j = 0; j < c; j++) {\n        cin >> s;\n        const int v = rename(s);\n        g[u][v] = true;\n      }\n    }\n\n    ull invalid = invalidate(g, 0, 0);\n    cout << solve(g, scores, 1, 1ULL<<0, invalid, scores[0]) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define IINF (INT_MAX)\n#define MAX_N 41\n\nusing namespace std;\n\ntypedef unsigned long long ull;\n\nstruct Country{\n  int index,power;\n  Country(int index=IINF,int power=IINF):index(index),power(power){}\n  bool operator < (const Country& c)const{ return power > c.power; }\n};\n\nint N,answer,V,sum[MAX_N];\null adj_bitmask[MAX_N];\nCountry c_list[MAX_N];\n\ninline void input(){\n  V = 0;\n  int dex = 0,i_tmp;\n  map<string,int> getIndex;\n  set<string> ban;\n  string s_tmp;\n  rep(i,N){\n    cin >> s_tmp >> i_tmp;\n    if( ban.find(s_tmp) != ban.end() ){\n      cin >> i_tmp;\n      rep(i,i_tmp)cin>>s_tmp;\n      continue;\n    }\n    if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n    int from = getIndex[s_tmp];\n    if( from == 0 ) answer = i_tmp;\n    c_list[from] = Country(from,i_tmp);\n    adj_bitmask[from] = 0ULL;\n    cin >> i_tmp;\n    rep(j,i_tmp){\n      cin >> s_tmp;\n      if( from == 0 ){\n\tban.insert(s_tmp);\n\tcontinue;\n      }\n      if( ban.find(s_tmp) != ban.end() ) continue;\n      if( getIndex.find(s_tmp) == getIndex.end() ) getIndex[s_tmp] = dex++;\n      int to = getIndex[s_tmp];\n      adj_bitmask[from] |= (1<<to);\n    }\n  }\n  V = dex;\n}\n\nvoid dfs(int sp,int power,ull friend_bitmask,ull enemy_bitmask){\n  if( power + sum[sp] <= answer ) return;\n  answer = max(answer,power);\n  if( sp >= V ) return;\n   \n  REP(i,sp,V){\n    if( ((friend_bitmask|enemy_bitmask)>>c_list[i].index) & 1 ) continue;\n    if( friend_bitmask & adj_bitmask[c_list[i].index] ) continue;\n    dfs(i+1,power+c_list[i].power,friend_bitmask|(1<<c_list[i].index),enemy_bitmask|adj_bitmask[c_list[i].index]);\n    dfs(i+1,power,friend_bitmask,enemy_bitmask);\n    break;\n  }\n\n}\n\nint main(){\n  while(cin>>N,N){\n    input();\n    sort(c_list,c_list+V);\n    rep(i,V)sum[i] = 0;\n    sum[V-1] = c_list[V-1].power;\n    for(int i=V-2;i>=0;i--) sum[i] = sum[i+1] + c_list[i].power;\n    dfs(0,answer,1,0);\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define _overload(_1,_2,_3,name,...) name\n#define _rep(i,n) _range(i,0,n)\n#define _range(i,a,b) for(int i=int(a);i<int(b);++i)\n#define rep(...) _overload(__VA_ARGS__,_range,_rep,)(__VA_ARGS__)\n\n#define _rrep(i,n) _rrange(i,n,0)\n#define _rrange(i,a,b) for(int i=int(a)-1;i>=int(b);--i)\n#define rrep(...) _overload(__VA_ARGS__,_rrange,_rrep,)(__VA_ARGS__)\n\n#define _all(arg) begin(arg),end(arg)\n#define uniq(arg) sort(_all(arg)),(arg).erase(unique(_all(arg)),end(arg))\n#define getidx(ary,key) lower_bound(_all(ary),key)-begin(ary)\n#define clr(a,b) memset((a),(b),sizeof(a))\n#define bit(n) (1LL<<(n))\n#define popcount(n) (__builtin_popcountll(n))\n\nusing namespace std;\n\ntemplate<class T>bool chmax(T &a, const T &b) { return (a<b)?(a=b,1):0;}\ntemplate<class T>bool chmin(T &a, const T &b) { return (b<a)?(a=b,1):0;}\n\nusing ll=long long;\nusing R=long double;\nconst R EPS=1e-9L; // [-1000,1000]->EPS=1e-8 [-10000,10000]->EPS=1e-7\ninline int sgn(const R& r){return(r > EPS)-(r < -EPS);}\ninline R sq(R x){return sqrt(max(x,0.0L));}\n\nconst int dx[8]={1,0,-1,0,1,-1,-1,1};\nconst int dy[8]={0,1,0,-1,1,1,-1,-1};\n\n// Problem Specific Parameter:\n\n\nint n;\nstring vertex[45];\nint m[45];\nint power[45];\nstring adj[45][45];\nll graph[50];\n\nrandom_device seed_gen;\nmt19937 engine(seed_gen());\n\nvector<int> ary;\n\nint run(int n) {\n\tll cur = (1LL << n) - 1;\n\tshuffle(begin(ary) + 1, end(ary), engine);\n\trep(i, n) if (cur & (1LL << ary[i])) cur &= graph[ary[i]];\n\tint ret = 0;\n\trep(i, n) if(cur & (1LL << i)) ret += power[i];\n\treturn ret;\n}\n\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n){\n\t\t\tcin >> vertex[i] >> power[i];\n\t\t\tcin >> m[i];\n\t\t\trep(j,m[i]) cin >> adj[i][j];\n\t\t}\n\n\t\tmap<string,int> ref;\n\t\trep(i,n) ref[vertex[i]] = i;\t\n\n\t\tary.resize(n);\n\t\tiota(begin(ary),end(ary),0);\n\n\t\trep(i,n) graph[i] = (1LL << n) -1LL;\n\n\t\trep(i,n){\n\t\t\trep(j,m[i]){\n\t\t\t\tconst int idx = ref[adj[i][j]];\n\t\t\t\tgraph[i] &= ~(1LL << idx);\n\t\t\t}\n\t\t}\n\n\t\tint ans = 0;\n\t\trep(loop,n * 10000) ans = max(ans,run(n));\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define show(x) cerr << #x << \" = \" << x << endl\n\nusing namespace std;\nusing ll = long long;\n\ntemplate <typename T>\nconstexpr T INF = numeric_limits<T>::max() / 16;\n\ntemplate <typename T>\nostream& operator<<(ostream& os, const vector<T>& v)\n{\n    os << \"sz:\" << v.size() << \"\\n[\";\n    for (const auto& p : v) {\n        os << p << \",\";\n    }\n    os << \"]\\n\";\n    return os;\n}\n\nstruct MaximumIndependentSet {\n    using T = int;\n    MaximumIndependentSet(const int n) : n{n}, former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost(n, 1), elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    MaximumIndependentSet(const vector<T>& cost) : n(cost.size()), former{n / 2}, latter{n - former}, former_maximum{1LL << former}, latter_maximum{1LL << latter}, cost{cost}, elist(n), former_dp(former_maximum, 0), latter_dp(latter_maximum, 0), former_next(former_maximum, latter_maximum - 1LL) {}\n    void addEdge(const int from, const int to)\n    {\n        assert(0 <= from);\n        assert(from < n);\n        assert(0 <= to);\n        assert(to < n);\n        elist[from].push_back(to);\n        elist[to].push_back(from);\n    }\n\n    T calculate()\n    {\n        for (ll i = 0; i < latter_maximum; i++) {\n            for (int j = 0; j < latter; j++) {\n                if (i & (1LL << j)) {\n                    bool ok = true;\n                    for (const int to : elist[j + former]) {\n                        if (to >= former) {\n                            if (i & (1LL << (to - former))) {\n                                ok = false;\n                                break;\n                            }\n                        }\n                    }\n                    if (ok) {\n                        latter_dp[i] = latter_dp[i - (1LL << j)] + cost[j + former];\n                    } else {\n                        latter_dp[i] = latter_dp[i - (1LL << j)];\n                    }\n                    break;\n                }\n            }\n        }\n\n        T maximum = latter_dp[latter_maximum - 1];\n        for (ll i = 1; i < former_maximum; i++) {\n            for (int j = 0; j < former; j++) {\n                if (i & (1LL << j)) {\n                    if (former_dp[i - (1LL << j)] != -INF<T>) {\n                        bool ok = true;\n                        ll mask = former_next[i - (1LL << j)];\n                        for (const int to : elist[j]) {\n                            if (to >= former) {\n                                mask &= ~(1LL << (to - former));\n                            } else {\n                                if (i & (1LL << to)) {\n                                    ok = false;\n                                    break;\n                                }\n                            }\n                        }\n                        if (ok) {\n                            former_dp[i] = former_dp[i - (1LL << j)] + cost[j];\n                            former_next[i] = mask;\n                            maximum = max(maximum, former_dp[i] + latter_dp[mask]);\n                        } else {\n                            former_dp[i] = -INF<T>;\n                        }\n                    }\n                    break;\n                }\n            }\n        }\n        return maximum;\n    }\n\n    const int n;\n    const int former;\n    const int latter;\n    const ll former_maximum;\n    const ll latter_maximum;\n    const vector<T> cost;\n    vector<vector<int>> elist;\n    vector<T> former_dp;\n    vector<T> latter_dp;\n    vector<ll> former_next;\n};\n\nint main()\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while (true) {\n        int N;\n        cin >> N;\n        if (N == 0) {\n            break;\n        }\n        map<string, int> id;\n        vector<vector<string>> neighbor(N);\n        vector<int> power(N);\n        for (int i = 0; i < N; i++) {\n            string s;\n            cin >> s;\n            id[s] = i;\n            int B;\n            cin >> B;\n            power[i] = B;\n            int C;\n            cin >> C;\n            for (int j = 0; j < C; j++) {\n                string d;\n                cin >> d;\n                neighbor[i].push_back(d);\n            }\n        }\n        set<int> far;\n        for (int i = 1; i < N; i++) {\n            far.insert(i);\n        }\n        for (const string& s : neighbor[0]) {\n            far.erase(id[s]);\n        }\n        const int size = far.size();\n        map<int, int> mp;\n        int cnt = 0;\n        for (const int f : far) {\n            mp[f] = cnt;\n            cnt++;\n        }\n\n        vector<int> B;\n        for (const int f : far) {\n            B.push_back(power[f]);\n        }\n        MaximumIndependentSet st{B};\n        for (const int f : far) {\n            for (const string& name : neighbor[f]) {\n                const int ind = id[name];\n                if (far.find(ind) != far.end()) {\n                    st.addEdge(mp[f], mp[ind]);\n                }\n            }\n        }\n        cout << power[0] + st.calculate() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], ans;\n\nset<ll> memo;\n\nvoid dfs(ll S){\n\n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  int cnt=0, sum=0;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1LL<<i))) continue;\n\n    sum+=cost[i];\n    \n    for(int j=i+1;j<n;j++){\n      if(!(S&(1LL<<j))) continue;\n      if(!G[i][j]) cnt++;\n    }\n    \n  }\n  \n  if(sum<ans) return ;\n  \n  int node=__builtin_popcountll(S);\n\n  if(cnt==node*(node-1)/2){\n    \n    ans=max(ans,sum);\n    return ;\n  }\n\n  for(int i=1;i<n;i++){\n     \n    int nS=S;\n       \n    nS=nS&~(1LL<<i);\n \n    dfs(nS);\n       \n  }\n   \n  \n  /*  for(int i=0;i<n;i++){\n\n    if(!(S&(1LL<<i))) continue;\n    \n    for(int j=i+1;j<n;j++){\n      \n      if(!(S&(1LL<<j))) continue;\n\n      if(G[i][j]) continue;\n      \n      dfs(S&~(1<<j));\n      \n      if(i) dfs(S&~(1<<i));\n      \n    }\n    }*/\n  \n}\n\nint main(){\n  \n  while(1)  {\n\n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cnt=0;\n\n    memset(G,0,sizeof(G));\n    \n    for(int i=0;i<n;i++){\n\n      string s;\n      cin>>s;\n\n      if(!num.count(s)) num[s]=cnt++;\n      \n      int a,b;\n      cin>>a>>b;\n      \n      cost[num[s]]=a;\n\n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n\n    ans=0;\n\n    memo.clear();\n    \n    dfs((1LL<<n)-1);\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tint N;\n\tvector<int> ps;\n\tvector<vector<int>> es;\n\tvector<bool> selected;\n\tvector<bool> canselect;\n\n\tint Mv;\t\n\tint must;\n\n\tvector<bool> change;\n\tvoid dfs(int v,int val){\n\t\tMv=max(Mv,val);\n\t\tif(v>=N)return;\n\t\tif(canselect[v]){\n\t\t\tvector<int> change;\n\t\t\tselect(v,change);\n\t\t\tdfs(v+1,val+ps[v]);\n\t\t\tunselect(v,change);\n\t\t}\n\t\tif(!checkuse(v))//必ず使う\n\t\t\tdfs(v+1,val);\n\t}\n\n\tbool checkuse(int v){\n\t\tREP(i,es[v].size()){\n\t\t\tif(es[v][i]>=v)return false;\n\t\t\tif(selected[es[v][i]])return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tvoid select(int v,vector<int>& change){\n\t\tselected[v]=true;canselect[v]=false;\n\t\tREP(i,es[v].size()){\n\t\t\tif(canselect[es[v][i]]){\n\t\t\t\tcanselect[es[v][i]]=false;\n\t\t\t\tchange.push_back(es[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid unselect(int v,vector<int>& change){\n\t\tselected[v]=false;canselect[v]=true;\n\t\tREP(i,change.size())canselect[change[i]]=true;\n\t}\n\n\tvoid run(){\n\t\twhile(true){\n\t\t\tcin >>N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> cs(N);\n\t\t\tmap<string,int> stoid;\n\t\t\tps=vector<int>(N);\n\t\t\tvector<vector<string>> ess(N);\n\t\t\tREP(i,N){\n\t\t\t\tcin >> cs[i] >> ps[i];stoid.insert(make_pair(cs[i],i));\n\t\t\t\t\n\t\t\t\tint k;cin >>k;\n\t\t\t\tREP(j,k) {\n\t\t\t\t\tstring s;cin >> s;ess[i].push_back(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tes=vector<vector<int>>(N);\n\t\t\tREP(i,N)REP(j,ess[i].size())es[i].push_back(stoid[ess[i][j]]);\n\t\t\n\t\t\tcanselect=vector<bool>(N,true);\n\t\t\tselected=vector<bool>(N);\n\t\t\t//自分\n\t\t\tvector<int> dummy;\n\t\t\tmust=ps[0];select(0,dummy);\n\t\t\t//孤立点\n\t\t\tREP(i,N)if(canselect[i] && es[i].size()==0){must+=ps[i];select(i,dummy);}\n\t\t\t\n\t\t\tMv=must;\n\t\t\tdfs(0,must);\n\n\t\t\tcout<< Mv<<endl;\n\t\t}\n\t}\n};\n int main(){\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \n#define MAX 45\ntypedef long long ll;\n  \nint N, B[MAX], sum[MAX], mx;\nll ng[MAX];\n\nvoid dfs(ll v, int strength, ll S)\n{\n    mx = max(mx, strength);\n    \n    if (v == N || sum[v] + strength <= mx) {\n        return;\n    }    \n    dfs(v+1, strength, S);\n    if (!(S >> v & 1) && (ng[v] & S) == 0) {\n        dfs(v+1, strength + B[v], S|(1LL<<v));\n    }\n}\n  \nint main()\n{\n    while (cin >> N, N) {\n        string A, D;\n        int C;\n        vector<string> DG[MAX];          \n        map<string, int> s2i;\n        \n        for (int i = 0; i < N; i++) {\n            cin >> A >> B[i] >> C;\n            s2i[A] = i;\n            for (int j = 0; j < C; j++) {\n                cin >> D;\n                DG[i].push_back(D);\n            }\n        }\n        \n        sum[N-1] = B[N-1];\n        for (int i = N-2; i >= 0; i--) {\n            sum[i] = sum[i+1] + B[i];\n        }\n        \n        for (int i = 0; i < N; i++) {\n            int len = DG[i].size();\n            ng[i] = 0;\n            for (int j = 0; j < len; j++) {\n                ll t = s2i[DG[i][j]];\n                ng[i] |= 1LL<<t;\n            }\n        }\n        mx = 0;\n        dfs(1, B[0], 1<<0);\n        cout << mx << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> adj[50];\nint power[50];\nbool used[50];\nint ans, rest, sum;\nint N;\nvoid dfs(int k){\n  //printf(\"%d:%d %d %d\\n\", k,sum , rest, ans);\n  if(k == N){\n    ans = max(ans,  sum);\n    return ;\n  }\n  if(sum + rest <= ans){\n    ans = max(ans,  sum);\n    return;\n  }\n  bool usedtmp[50];\n  REP(i, 50) usedtmp[i] = used[i];\n  int sumtmp = sum;\n  int resttmp = rest;\n  if(!used[k]){\n    used[k] = true;\n    sum += power[k];\n    rest -= power[k];\n    FORIT(it, adj[k])if(!used[*it]){\n      rest -= power[*it];\n      used[*it] = true;\n    }\n    dfs(k + 1);\n    REP(i, 50) used[i] = usedtmp[i];\n    sum = sumtmp;\n    rest = resttmp;\n  }\n  if(k != 0){\n    if(!used[k])rest -= power[k];\n    used[k] = true;\n    dfs(k + 1);\n    rest += power[k];\n    used[k] = false;\n  }\n}\n\nint main(){\n  while(cin>>N && N){\n    ans = 0, rest = 0, sum = 0;\n    REP(i, 50) adj[i].clear();\n    memset(used, 0, sizeof(used));\n    map<string, int> id;\n    vector<string> adjstr[50];\n    REP(i, N){\n      string s; cin>>s; id[s] = i;\n      cin>>power[i];\n      rest += power[i];\n      int k; cin>>k;\n      while(k--){\n        string str; cin>>str;\n        adjstr[i].push_back(str);\n      }\n    }\n    REP(i, N){\n      REP(j, adjstr[i].size()){\n        adj[i].push_back(id[adjstr[i][j]]);\n      }\n    }\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,int>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\nmap<string ,int> ma;\nint po[50];\nbool ok[1<<20]={0};\nint an[1<<20]={0};\nint dp[1<<20]={0};\nbool miok[1<<20]={0};\nint dp2[1<<20]={0};\nint hi,mi;\nvector<int> G[50];\nvector<pa> e1,e2,e3;\nint ichi[50]={0};\n\n\nvoid shoki(int r){\n\te1.clear();\n\te2.clear();\n\te3.clear();\n\tma.clear();\n\tfor(int i=0;i<50;i++){\n\t\tpo[i]=0;\n\t\tG[i].clear();\n\t\tichi[i]=0;\n\t}\n\t\n\tfor(int i=0;i<(1<<r);i++){\n\t\t\n\t\t\n\t\tdp[i]=0;\n\t\t\n\t\tdp2[i]=0;\n\t}\n\t\n}\n\nvoid makeok(){\n\tfor(int i=0;i<(1<<hi);i++)ok[i]=true;\n\t\n\tfor(auto t:e1){\n\t\tok[(1<<t.second)+(1<<t.first)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<hi);i++){\n\t\tbool b=ok[i];\n\t\tif(b==false) continue;\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(ok[i-(1<<j)]==false){\n\t\t\t\tb=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tok[i]=b;\n\t}\n\treturn;\n\t\n}\nvoid makean(){\n\tfor(int i=0;i<(1<<hi);i++)an[i]=(1<<(mi))-1;\n\t\n\tfor(auto t:e3){\n\t\tan[(1<<t.first)]^= (1<<(t.second-hi));\n\t}\n\t\n\tfor(int i=0;i<(1<<hi);i++){\n\t\t\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tan[i]=an[1<<j]&an[i-(1<<j)];\n\t\t}\n\t}\n\t\n}\n\nvoid makedp(){\n\tfor(int i=0;i<(1<<mi);i++)miok[i]=true;\n\t\n\tfor(auto t:e2){\n\t\n\t\tmiok[(1<<t.first)+(1<<t.second)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<mi);i++){\n\t\tbool b=miok[i];\n\t\tif(!b) continue;\n\t\tmiok[i]=true;\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(miok[i-(1<<j)]==false){\n\t\t\t\tmiok[i]=false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\n\t\t}\n\t}\n\tfor(int i=0;i<(1<<mi);i++)if(miok[i]){\n\t\tint cnt=0;\n\t\tdp[i]=0;\n\t\tfor(int  j=0;j<mi;j++)if(i&(1<<j)){\n\t\t\tdp[i]=dp[i-(1<<j)]+po[hi+j];\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tfor(int i=0;i<(1<<mi);i++)if(!miok[i]){\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tdp[i]=max(dp[i],dp[i-(1<<j)]);\n\t\t}\n\t\t\n\t}\n}\n\n\n\n         signed main(){\nint n;\n         \twhile(1){\n         \tcin>>n;\n         \t\tif(n==0) return 0;\n         \t\t\n         \t\tshoki((n+1)/2);\n         \tint count1=0;\n         \tfor(int i=0;i<n;i++){\n         \t\tstring s1,s2;\n         \t\tcin>>s1;\n         \t\tif(ma.find(s1)==ma.end()){\n         \t\t\tma[s1]=count1;\n         \t\t\tcount1++;\n         \t\t}\n         \t\tint r3,r4;\n         \t\tcin>>r3>>r4;\n         \t\tpo[ma[s1]]=r3;\n         \t\tfor(int j=0;j<r4;j++){\n         \t\t\tcin>>s2;\n         \t\t\tif(ma.find(s2)==ma.end()){\n         \t\t\t\tma[s2]=count1;\n         \t\t\t\tcount1++;\n         \t\t\t}\n         \t\t\tG[ma[s1]].pb(ma[s2]);\n         \t\t}\n         \t}\n         \t\n         \tint n1=n/2;\n         \thi=n1,mi=n-n1;\n         \tfor(int i=0;i<G[0].size();i++)ichi[G[0][i]]=1;\n         \t//for(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j])cout<<i<<\" \"<<G[i][j]<<endl;\n         \tfor(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j]){\n         \n         \t\n         \t\tif(G[i][j]<hi) e1.pb(mp(i,G[i][j]));\n         \t\telse if(i<hi) e3.pb(mp(i,G[i][j]));\n         \t\telse {\n         \t\t\te2.pb(mp(i-hi,G[i][j]-hi));\n         \t\t}\n         \t}\n         \t\n         \t\n         //\tfor(int i=0;i<n;i++)cout<<po[i]<<endl;\n    \tmakeok();\n         \t\t\n    \tmakean();\n         \t\n    \tmakedp();\n    \t \n \t\t for(int i=0;i<(1<<hi);i++)if(ok[i]){\n    \t\tint cnt=0;\n    \t\tfor(int j=0;j<hi;j++)if(i&(1<<j))cnt+=po[j];\n    \t\t\n    \t\tdp2[i]=cnt;\n    \t}\n         \tint ans=-1;\n          for(int i=0;i<(1<<hi);i++)if(ok[i])if(i&1){\n          \n    \t\tfor(int j=0;j<hi;j++)if(i&(1<<j))dp2[i]=max(dp2[i],dp2[i-(1<<j)]);\n    \t\t\n    \t\tans=max(ans,dp2[i]+dp[an[i]]);\n    \t\t}\n       \n    \tcout<<ans<<endl;\n         }\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nint reg(map<string, int>& tbl, string& name) {\n\tif (tbl.count(name) == 0) {\n\t\tint id = tbl.size();\n\t\ttbl[name] = id;\n\t}\n\treturn tbl[name];\n}\n\nint N;\nvector< vector<int> > G;\nvector<int> power;\nvector<int> ps;\nvector<int> conv;\nvector<int> adjacent;\n\nint ans = 0, p = 0;\nbool merge(int n) {\n\tif (adjacent[n] > 0) return false;\n\tfor (int i = 0; i < G[n].size(); ++i) {\n\t\tadjacent[G[n][i]]++;\n\t}\n\treturn true;\n}\nbool remove(int n) {\n\tfor (int i = 0; i < G[n].size(); ++i) {\n\t\tadjacent[G[n][i]]--;\n\t}\n}\nvoid dfs(int n) {\n\tif (n == N) {\n\t\tans = max(ans, p);\n\t}\n\telse if (p + ps[n] > ans) {\n\t\tif ( merge(conv[n]) ) {\n\t\t\tp += power[n];\n\t\t\tdfs(n+1);\n\t\t\tremove(conv[n]);\n\t\t\tp -= power[n];\n\t\t}\n\t\tif ( G[conv[n]].size() > 0 ) dfs(n+1);\n\t}\n}\n\nint main() {\n\twhile ( cin >> N, N ) {\n\t\tmap<string, int> tbl;\n\t\tpower.clear(); power.resize(N);\n\t\tG.clear(); G.resize(N);\n\t\tconv.clear(); conv.resize(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring A; cin >> A; int a = reg(tbl, A);\n\t\t\tint B, C; cin >> B >> C;\n\t\t\tfor (int j = 0; j < C; ++j) {\n\t\t\t\tstring D; cin >> D;\n\t\t\t\tint d = reg(tbl, D);\n\t\t\t\tG[a].push_back(d);\n\t\t\t}\n\t\t\tpower[i] = B;\n\t\t\tconv[i] = a;\n\t\t}\n\t\tps.resize(N+1);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tps[i] = power[i];\n\t\t}\n\t\tfor (int i = N-1; i >= 0; --i) {\n\t\t\tps[i] += ps[i+1];\n\t\t}\n\t\tadjacent = vector<int>(N, 0);\n\t\tans = 0; p = power[0]; merge(conv[0]);\n\t\tdfs(1);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\n#define M 20\nusing namespace std;\n\nint n, cost[N], G[N][N];\n\nint memo[2][(1<<M)],m;\n\nvoid dfs(int x,int S,int sum,int idx){\n\n  memo[idx][S]=max(memo[idx][S],sum);\n  \n  if((!idx&&x>m)||(idx&&x>=n)) return;\n\n  if(!idx){\n    \n    int f=0;\n    \n    if(G[x][0]) f=1;\n    \n    for(int i=0;i<m-1;i++)\n\n      if(S&(1<<i)&&G[x][i]) f=1;\n    \n    if(!f) dfs(x+1,S|(1<<x),sum+cost[x],idx);\n    \n  }else{\n    \n    int f=0;\n\n    if(G[x][0]) f=1;\n    \n    for(int i=0;i<n-(m+1)+1;i++)\n      \n      if(S&(1<<i)&&G[x][i]) f=1;\n    \n    if(!f) dfs(x+1,S|(1<<x),sum+cost[x],idx);\n    \n  }\n\n  dfs(x+1,S,sum,idx);\n  \n}\n\n\nint main(){\n  \n  while(1){\n\n    cin>>n;\n    \n    if(!n) break;\n    \n    int cnt=0;\n    map<string,int> num;\n\n    memset(G,0,sizeof(G));\n    \n    for(int i=0;i<n;i++){\n      \n      string s;\n      cin>>s;\n      if(!num.count(s)) num[s]=cnt++;\n      \n      int a, b;\n      cin>>a>>b;\n      \n      cost[num[s]]=a;\n\n      for(int i=0;i<b;i++){\n\n\tstring t;\n\tcin>>t;\n\n\tif(!num.count(t)) num[t]=cnt++;\n\t\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n    \n    for(int i=0;i<2;i++)\n      for(int j=0;j<(1<<M);j++) memo[i][j]=0;\n\n    m=(n-1)/2+1;\n    \n    dfs(1,0,0,0);\n\n    dfs(m+1,0,0,1);\n\n    \n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define rep(i,n) for(int i = 0; i < n; i++)\n#define MAX_N 40\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,int> P;\nconst long long int MOD = 1000000007;\nconst long long int INF = 100000000000000;\n\nstruct UF{\n\tint par[MAX_N];\n\tint rank[MAX_N];\n\tint si[MAX_N];\n\n\tvoid init(int n){\n\t\trep(i,n){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t\tsi[i] = 1;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t\tsi[y] += si[x];\n\t\t} else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\tsi[x] += si[y];\n\t\t}\n\t}\n\n\tbool same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n} uf;\n\nint n;\nmap<string,int> id;\nmap<P,int> dp;\nint b[40];\nint c[40];\nvector<string> d[40];\nvector<int> e[40];\nvector<int> fa;\nint ans = 0;\n\nint func(ll bo, int now){\n    if(now == fa.size()) return 0;\n    if(dp.count(P(bo,now))) return dp[P(bo,now)];\n    ll prebo = bo;\n    int ret = 0;\n    int f = fa[now];\n    if(f == 0){\n        ret = b[0];\n        bo++;\n        rep(i,e[f].size()){\n            bo += (1LL<<e[f][i]);\n        }\n        //cout << ret << endl;\n        ret += func(bo,now+1);\n        dp[P(prebo,now)] = ret;\n        //cout << func(bo,now+1) << endl;\n        return ret;\n    }\n    if(bo&(1LL<<f)){\n        dp[P(prebo,now)] = func(bo,now+1);\n        return dp[P(prebo,now)];\n    }\n    bo += (1LL<<f);\n    ret = func(bo,now+1);\n    int ret2 = b[f];\n    rep(i,e[f].size()){\n        if(bo&(1LL<<e[f][i])) continue;\n        bo += (1LL<<e[f][i]);\n    }\n    ret2 += func(bo,now+1);\n    //cout << f << \" \" << bo << \" \" << now << \" \" << ret << \" \" << ret2 << endl;\n    dp[P(prebo,now)] = max(ret,ret2);\n    return max(ret,ret2);\n}\n\nvoid solve(){\n    uf.init(n);\n    rep(i,40) d[i].clear();\n    rep(i,40) e[i].clear();\n    fa.clear();\n    id.clear();\n    dp.clear();\n    ans = 0;\n    rep(i,n){\n        string a;\n        cin >> a >> b[i] >> c[i];\n        id[a] = i;\n        rep(j,c[i]){\n            string tmp;\n            cin >> tmp;\n            d[i].push_back(tmp);\n        }\n    }\n    rep(i,n){\n        rep(j,c[i]){\n            e[i].push_back(id[d[i][j]]);\n            uf.unite(i,id[d[i][j]]);\n        }\n    }\n    rep(i,n){\n        if(uf.par[i] != i) continue;\n        vector<int> now;\n        dp.clear();\n        rep(j,n){\n            if(uf.find(j) != i) continue;\n            now.push_back(j);\n        }\n        fa = now;\n        ans += func(0,0);\n        //cout << \" \" << ans << endl;\n    }\n    cout << ans << endl;\n}\n\nint main(){\n    while(cin >> n){\n        if(n == 0) break;\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//#include\"bits/stdc++.h\"\n\n#include<iostream>\n#include<vector>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<cstring>\n\nusing namespace std;\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n//#define int long long\nusing vi=vector<int>;\nusing vvi=vector<vi>;\n\n//#define INF 0x3f3f3f3f\n\n\nconst int MAX = 1 << 21;\nint cost[MAX], dp[MAX];\nbool indx[MAX], indy[MAX];\n\nbool E[41][41];\n\nsigned main() {\n\n\tfor (int N; cin >> N && N;) {\n\t\tvector<string> A(N);\n\t\tvector<int> B(N), C(N);\n\t\tvector<vector<string>> D(N);\n\t\tmemset(E, 0, sizeof(E));\n\n\t\trep(i, 0, N) {\n\t\t\tcin >> A[i] >> B[i] >> C[i];\n\t\t\tD[i].assign(C[i], \"\");\n\t\t\trep(j, 0, C[i]) {\n\t\t\t\tcin >> D[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> id;\n\t\trep(i, 0, N)id[A[i]] = i;\n\n\t\trep(i, 0, N)rep(j, 0, C[i]) {\n\t\t\tE[i][id[D[i][j]]] = true;\n\t\t}\n\n\t\t//rep(i, 0, N)rep(j, 0, N) {\n\t\t//\tcerr << i << \" \" << j << \" E:\" << E[i][j] << endl;\n\t\t//}\n\n\t\tif (N == 1) {\n\t\t\tcout << B[0] << endl;\n\t\t}\n\t\telse {\n\t\t\tint n = N / 2;\n\t\t\tint NX = 1 << n;\n\t\t\tint NY = 1 << (N - n);\n\n\t\t\tmemset(indx, 1, sizeof(indx));\n\t\t\tmemset(indy, 1, sizeof(indy));\n\n\t\t\trep(i, 0, n)rep(j, 0, n) {\n\t\t\t\tif (E[i][j]) {\n\t\t\t\t\tindx[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (indx[mask])continue;\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tindx[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i, 0, N - n)rep(j, 0, N - n) {\n\t\t\t\tif (E[i + n][j + n]) {\n\t\t\t\t\tindy[(1 << i) | (1 << j)] = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(mask, 0, NY) {\n\t\t\t\tif (indy[mask])continue;\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tindy[mask | (1 << i)] = false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(cost, 0, sizeof(cost));\n\t\t\trep(mask, 0, NY) {\n\t\t\t\t// ある頂点を追加して\n\t\t\t\trep(i, 0, N - n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tint nmask = mask | (1 << i);\n\n\t\t\t\t\tif (indy[nmask])\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask] + B[i + n]);\n\t\t\t\t\telse\n\t\t\t\t\t\tcost[nmask] = max(cost[nmask], cost[mask]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tmemset(dp, 0, sizeof(dp));\n\t\t\trep(i, 0, n) {\n\t\t\t\tint maska = 1 << i;\n\t\t\t\tint maskb = 0;\n\t\t\t\trep(j, 0, N - n) {\n\t\t\t\t\tif (E[i][j + n])\n\t\t\t\t\t\tmaskb |= 1 << j;\n\t\t\t\t}\n\t\t\t\tdp[maska] = maskb;\n\t\t\t}\n\t\t\trep(mask, 0, NX) {\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1)\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\tdp[mask | (1 << i)] |= dp[mask];\n\t\t\t\t}\n\t\t\t\t//cerr << bitset<4>(mask) << \" \" << bitset<4>(dp[mask]) << endl;\n\t\t\t}\n\n\t\t\tint ans = 0;\n\t\t\trep(mask, 0, NX) {\n\t\t\t\tif (!indx[mask])continue;\n\t\t\t\tif (!(mask & 1))continue; // 自国\n\n\t\t\t\tint cost_a = 0;\n\t\t\t\tint x = (1 << (N - n)) - 1;\n\t\t\t\tx -= dp[mask];\n\n\t\t\t\trep(i, 0, n) {\n\t\t\t\t\tif ((mask >> i) & 1) {\n\t\t\t\t\t\tcost_a += B[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tans = max(ans, cost_a + cost[x]);\n\n\t\t\t}\n\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin >> N,N){\n\tmap<string,int> country;\n\tvector<vector<string>> adj(N);\n\tVI bs(N);\n\tREP(i,N){\n\t  string s;\n\t  cin >> s;\n\t  country[s] = i;\n\t  cin >> bs[i];\n\t  int C; cin >> C;\n\t  REP(j,C){\n\t\tcin >> s;\n\t\tadj[i].EB(s);\n\t  }\n\t}\n\tif(N == 1){\n\t  cout << bs[0] << endl;\n\t  continue;\n\t}\n\n\tVVI G(N);\n\tREP(i,N){\n\t  for(auto& s: adj[i])\n\t\tG[i].PB(country[s]);\n\t}\n\tVL ban(N);\n\tREP(i,N){\n\t  for(int to: G[i])\n\t\tban[i] = ban[i] | (1ll<<to);\n\t}\n\n\tint N2 = N / 2;\n\tint NR = N - N2;\n\tVI dp(1<<NR);\n\tREP(i,1<<NR){\n\t  int sum = 0;\n\t  LL x = (LL)(i) << N2;\n\t  REP(j,NR)\n\t\tif(i>>j&1){\n\t\t  sum += bs[j+N2];\n\t\t  if((ban[j+N2] & x) != 0){\n\t\t\tsum = -1e9;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t  if(sum >= 0)\n\t\tdp[((1<<NR)-1)^i] = sum;\n\t}\n\t\n\tfor(int i=0;i<NR;++i){\n\t  for(int b=0;b<(1<<NR);++b){\n\t\tif((b>>i&1) == 0)\n\t\t  maxi(dp[b], dp[b|(1<<i)]);\n\t  }\n\t}\n\t//REP(i,1<<N2) cout << bitset<4>(i) << \": \" << dp[i] << endl;\n\tint ans = 0;\n\tfor(int b=1;b<1<<N2;b+=2){\n\t  int sum = 0;\n\t  LL x = b;\n\t  LL b2 = 0;\n\t  REP(j,N2)\n\t\tif(b>>j&1){\n\t\t  b2 = b2 | ban[j];\n\t\t  sum += bs[j];\n\t\t  if((ban[j] & x) != 0){\n\t\t\tsum = -1e9;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t  if(sum < 0) continue;\n\t  b2 = b2 >> N2;\n\t  ans = max(ans, sum + dp[b2]);\n\t}\n\tcout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <cstring>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <queue>\n#include <stack>\n#include <map>\n#include <set>\n#include <numeric>\n#include <cctype>\n#include <tuple>\n#include <array>\n#include <climits>\n#include <bitset>\n#include <cassert>\n\n#ifdef _MSC_VER\n#include <agents.h>\n#endif\n\n#define FOR(i, a, b) for(int i = (a); i < (int)(b); ++i)\n#define rep(i, n) FOR(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define REV(v) v.rbegin(), v.rend()\n#define MEMSET(v, s) memset(v, s, sizeof(v))\n#define UNIQUE(v) (v).erase(unique(ALL(v)), (v).end())\n#define MP make_pair\n#define MT make_tuple\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n\nconst int N = 44;\nvector<int> G[N];\nint used[N];\nint deg[N];\nint b[N];\n\nint n;\nint max_deg(){\n\tint d = -1, idx = -1;\n\trep(i, n){\n\t\tif (used[i]) continue;\n\t\tif (deg[i] > d) d = deg[i], idx = i;\n\t}\n\treturn idx;\n}\n\nint dfs(int v){\n\tif (v < 0) return 0;\n\tused[v] = 1;\n\tint res = 0;\n\t// use\n\tvector<int> adj;\n\tfor (auto u : G[v]){\n\t\tif (used[u]) continue;\n\t\tadj.push_back(u);\n\t\tused[u] = 1;\n\t\t--deg[u];\n\t}\n\tres = b[v] + dfs(max_deg());\n\tfor (auto u : adj){\n\t\tused[u] = 0;\n\t\t++deg[u];\n\t}\n\n\t// not use\n\treturn max(res, dfs(max_deg()));\n}\n\nint main(){\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\tcout.setf(ios::fixed);\n\tcout.precision(20);\n\n\twhile (cin >> n, n){\n\t\trep(i, N){\n\t\t\tG[i].clear();\n\t\t\tused[i] = deg[i] = b[i] = 0;\n\t\t}\n\t\tmap<string, int> m;\n\t\tvector<vector<string>> adj(n);\n\n\t\tset<int> ng;\n\t\trep(i, n){\n\t\t\tstring s;\n\t\t\tint c;\n\t\t\tcin >> s >> b[i] >> c;\n\t\t\tm[s] = i;\n\t\t\trep(j, c){\n\t\t\t\tstring t;\n\t\t\t\tcin >> t;\n\t\t\t\tadj[i].push_back(t);\n\t\t\t\tif (m.count(t) && m[t] == 0) ng.insert(i);\n\t\t\t}\n\t\t}\n\n\t\tused[0] = 1;\n\t\tFOR(i, 1, n){\n\t\t\tif (ng.count(i)){\n\t\t\t\tused[i] = 1;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor (auto s : adj[i]){\n\t\t\t\tG[i].push_back(m[s]);\n\t\t\t}\n\t\t\tdeg[i] = G[i].size();\n\t\t}\n\n\t\tcout << dfs(max_deg()) + b[0] << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing ll = long long;\nvector<ll> mask;\n\nint dfs(int l, int N, int b, vector<vector<int>>& g, vector<int>& str, vector<int>& dp) {\n    int& res = dp[b];\n    if(res != -1) {\n        return res;\n    }\n    res = 0;\n    for(int i=0; i<N; ++i) {\n        if((b >> i) & 1) {\n            int nb = b & ~(1 << i);\n            nb &= ~(int)(mask[l+i] >> l);\n            res = max(res, dfs(l, N, nb, g, str, dp) + str[l+i]);\n        }\n    }\n    return res;\n}\n\nint main() {\n    int N;\n    while(cin >> N, N) {\n        map<string, int> id;\n        vector<vector<int>> g(N, vector<int>(N));\n        mask.resize(N);\n        vector<int> str(N);\n        for(int i=0; i<N; ++i) {\n            string A;\n            int B, C;\n            cin >> A >> B >> C;\n            if(id.count(A) == 0) {\n                id[A] = id.size() - 1;\n            }\n            str[id[A]] = B;\n            for(int j=0; j<C; ++j) {\n                string D;\n                cin >> D;\n                if(id.count(D) == 0) {\n                    id[D] = id.size() - 1;\n                }\n                g[id[A]][id[D]] = g[id[D]][id[A]] = 1;\n            }\n        }\n        if(N == 1) {\n            cout << str[0] << endl;\n            continue;\n        }\n        int N1 = N/2, N2 = N - N1;\n        for(int i=0; i<N; ++i) {\n            ll m = 0;\n            for(int j=0; j<N; ++j) {\n                if(g[i][j]) {\n                    m |= (1LL << j);\n                }\n            }\n            mask[i] = m;\n        }\n        vector<int> dp1(1 << N1, -1), dp2(1 << N2, -1);\n        int res = 0;\n        for(int b=0; b<1<<N1; b+=2) {\n            bool ignore = false;\n            for(int i=0; i<N1; ++i) {\n                if(g[0][i] && (b >> i) & 1) {\n                    ignore = true;\n                }\n            }\n            if(ignore) {\n                continue;\n            }\n            int b2 = (1 << N2) - 1;\n            for(int i=0; i<N1; ++i) {\n                if(b & (1 << i)) {\n                    b2 &= ~(int)(mask[i] >> N1);\n                }\n            }\n            b2 &= ~(int)(mask[0] >> N1);\n            res = max(res, dfs(0, N1, b, g, str, dp1) + dfs(N1, N2, b2, g, str, dp2) + str[0]);\n        }\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\nusing namespace std;\n\nint N, B[40];\nvector<int> D[40];\n\nint dfs(int n, int *flag_)\n{\n    int preproc = 0, res = 0;\n    int flag[40];\n    copy(flag_, flag_ + N, flag);\n    \n    flag[n] = 1;\n    for(int i = 0; i < D[n].size(); ++i)\n        flag[D[n][i]] = -1;\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n    \tif(flag[i] != 0) continue;\n        bool f = true;\n        for(int j = 0; j < D[i].size(); ++j)\n            if(flag[D[i][j]] != -1) {\n                f = false; break;\n            }\n        if(f)\n            flag[i] = 1, preproc += B[i];\n    }\n    \n    for(int i = n + 1; i < N; ++i)\n    {\n        if(flag[i] != 0) continue;\n        res = max(res, B[i] + dfs(i, flag));\n        flag[i] = -1;\n    }\n    \n    return preproc + res;\n}\n\nint main()\n{\n    int C;\n    string A, Dt;\n    \n    while(cin >> N && N)\n    {\n        map<string, int> table;\n        vector<string> Ds[40];\n        for(int i = 0; i < 40; ++i) D[i].clear();\n        \n        for(int i = 0; i < N; ++i)\n        {\n            cin >> A >> B[i] >> C;\n            for(int j = 0; j < C; ++j)\n                cin >> Dt, Ds[i].push_back(Dt);\n            table[A] = i;\n        }\n        for(int i = 0; i < N; ++i)\n            for(int j = 0; j < Ds[i].size(); ++j)\n                D[i].push_back(table[Ds[i][j]]);\n        \n        int flag[40] = {};\n        int res = B[0] + dfs(0, flag);\n        cout << res << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <set>\nusing namespace std;\nmap<int,int> country;\nint solve(map<set<int>,int> &visited,map<int,set<int> > &bannedlist,set<int> &banned,int power){\n\tif(banned.size()==country.size())return power;\n\tif(visited.find(banned)!=visited.end())return visited[banned];\n\tint max=power;\n\tfor(int i=0,t;i<country.size();++i){\n\t\tif(banned.find(i)==banned.end()){\n\t\t\tset<int> b = banned;\n\t\t\tb.insert(i);\n\t\t\tfor(set<int>::iterator it=bannedlist[i].begin();it!=bannedlist[i].end();++it) b.insert(*it);\n\t\t\tt=solve(visited,bannedlist,b,power+country[i]);\n\t\t\tif(t>max)max=t;\n\t\t}\n\t}\n\tvisited[banned]=max;\n\treturn max;\n}\nint main(){\n\tint n;\n\twhile(cin>>n){\n\t\tif(!n)break;\n\t\tcountry.clear();\n\t\tmap<string,int> c_name;\n\t\tmap<int,set<string> > banned_c;\n\t\tint power,ncount;\n\t\tfor(int i=0;i<n;++i){\n\t\t\tstring s;\n\t\t\tcin>>s>>power>>ncount;\n\t\t\tc_name[s]=i;\n\t\t\tcountry[i]=power;\n\t\t\tfor(int j=0;j<ncount;++j){\n\t\t\t\tstring ban;\n\t\t\t\tcin>>ban;\n\t\t\t\tbanned_c[i].insert(ban);\n\t\t\t}\n\t\t}\n\t\tmap<int,set<int> > banned;\n\t\tfor(int i=0;i<n;++i) for(set<string>::iterator it=banned_c[i].begin();it!=banned_c[i].end();++it) banned[i].insert(c_name[*it]);\n\t\tmap<set<int>,int> visited;\n\t\tset<int> b=banned[0];\n\t\tb.insert(0);\n\t\tint ans = solve(visited,banned,b,country[0]);\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n//C++11\n#if __cplusplus == 201103L\n#include <tuple>\n#endif\n \nusing namespace std;\n \n#define FOR(i,k,n) for(int i=(k); i<(int)n; ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n \ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cout<<*i<<\" \"; cout<<endl; }\n \ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nvector<int> adj[50];\nint power[50];\nll used;\nint ans, rest, sum;\nint N;\nvector<int> per;\nvoid dfs(int k_){\n  if(k_ == N){\n    ans = max(ans,  sum);\n    return ;\n  }\n  int k = per[k_];\n  //printf(\"%d:%d %d %d\\n\", k,sum , rest, ans);\n  if(sum + rest <= ans){\n    return;\n  }\n  ll usedtmp = used;\n  int sumtmp = sum;\n  int resttmp = rest;\n  if(!(used >> k & 1)){\n    used |= 1LL << k;\n    sum += power[k];\n    rest -= power[k];\n    FORIT(it, adj[k])if(!(used >> (*it) & 1)){\n      rest -= power[*it];\n      used |= 1LL<<(*it);\n    }\n    dfs(k_ + 1);\n    used = usedtmp;\n    sum = sumtmp;\n    rest = resttmp;\n  }\n  if(k != 0){\n    if(!(used >> k & 1))rest -= power[k];\n    used |= 1LL << k;\n    dfs(k_ + 1);\n  }\n}\n \ntypedef pair<int, int> P;\nint main(){\n  while(cin>>N && N){\n    ans = 0, rest = 0, sum = 0;\n    REP(i, 50) adj[i].clear();\n    used = 0;\n    map<string, int> id;\n    vector<string> adjstr[50];\n    REP(i, N){\n      string s; cin>>s; id[s] = i;\n      cin>>power[i];\n      rest += power[i];\n      int k; cin>>k;\n      while(k--){\n        string str; cin>>str;\n        adjstr[i].push_back(str);\n      }\n    }\n    REP(i, N){\n      REP(j, adjstr[i].size()){\n        adj[i].push_back(id[adjstr[i][j]]);\n      }\n    }\n    vector<P> ps(N-1);\n    REP(i, N-1)ps[i] = P(-power[i+1], i+1);\n    sort(ps.begin(), ps.end());\n    per = vector<int>(N, 0);\n    REP(i, N-1) per[i+1] = ps[i].second;\n    used = 0;\n    dfs(0);\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#define INF 0x3f3f3f3f\n\n#include <iostream>\n#include <cstdio>\n#include <sstream>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n#include <bitset>\n#include <list>\n#include <cctype>\n#include <utility>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef pair <int,int> P;\ntypedef pair <int,P> PP;\n  \nstatic const double EPS = 1e-8;\n  \nstatic const int tx[] = {0,1,0,-1};\nstatic const int ty[] = {-1,0,1,0};\n\nint country2idx(map<string,int>& dict,string country){\n  int idx = dict.size();\n  if(dict.find(country) == dict.end()){\n    dict[country] = idx;\n    return idx;\n  }\n  return dict[country];\n}\n\nvector<int> edges[41];\nbool used[41];\nint power[41];\nint limit_gain[101];\n\nbool can_unite(int node){\n  if(used[node]) return false;\n  for(int i=0;i<edges[node].size();i++){\n    if(used[edges[node][i]]) return false;\n  }\n  return true;\n}\n\nint gRes;\nvoid dfs(int current,int sum,const vector<int>& subset){\n  if(sum + limit_gain[current] <= gRes) return;\n\n  if(current == subset.size()){\n    gRes = max(gRes,sum);\n    return;\n  }\n\n  int next = subset[current];\n  if(can_unite(next)){\n    used[next] = true;\n    dfs(current+1,sum + power[next],subset);\n    used[next] = false;\n  }\n  dfs(current+1,sum,subset);\n}\n\nclass UnionFindTree {\nprivate:\n  int parent[41];\n  int rank[41];\npublic:\n  UnionFindTree(){\n    for(int i = 0; i <= 40; i++){\n      parent[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  void unite(int lhs,int rhs) {\n    lhs = find(lhs);\n    rhs = find(rhs);\n    if(lhs == rhs) return;\n    \n    if(rank[lhs] < rank[rhs]){\n      parent[lhs] = rhs;\n    }\n    else{\n      parent[rhs] = lhs;\n      if(rank[lhs] == rank[rhs]) rank[lhs]++;\n    }\n  }\n\n  int find(int current){\n    if(current == parent[current]) return current;\n    else find(parent[current]);\n  }\n};\n\nint N;\nvoid make_subset(UnionFindTree* uft,int root,vector<int>& subset){\n  for(int i = 0; i < N; i++){\n    if(uft->find(i) == root){\n      subset.push_back(i);\n    }\n  }\n}\n\nint main(){\n  while(~scanf(\"%d\",&N)){\n    if(N == 0) break;\n    for(int i = 0; i <= 40; i++){\n      edges[i].clear();\n    }\n    UnionFindTree uft;\n    map<string,int> dict;\n    for(int country_i = 0; country_i < N; country_i++){\n      string country;\n      int tmp_power;\n      cin >> country >> tmp_power;\n      int adjacent_countries;\n      cin >> adjacent_countries;\n\n      int root = country2idx(dict,country);\n      power[root] = tmp_power;\n      for(int adj_i = 0; adj_i < adjacent_countries; adj_i++){\n        string adj_country;\n        cin >> adj_country;\n        int child = country2idx(dict,adj_country);\n        edges[root].push_back(child);\n        uft.unite(root,child);\n      }\n    }\n\n    bool tree[41];\n    memset(tree,false,sizeof(tree));\n\n    int res = 0;\n    for(int i = 0; i < N; i++){\n      if(tree[uft.find(i)]) continue;\n      tree[uft.find(i)] = true;\n      vector<int> subset;\n      make_subset(&uft,uft.find(i),subset);\n\n      gRes = 0;\n      int sum = 0;\n      memset(limit_gain,0,sizeof(limit_gain));\n      for(int j = 0; j < subset.size(); j++){\n        sum += power[subset[j]];\n      }\n      for(int j = 0; j < subset.size(); j++){\n        limit_gain[j] = sum;\n        sum -= power[subset[j]];\n      }\n      memset(used,false,sizeof(used));\n      int tmp = 0;\n      if(i == 0){\n        used[0] = true;\n        dfs(0,power[0],subset);\n        tmp = gRes;\n      }\n      else{\n        dfs(0,0,subset);\n        tmp = gRes;\n      }\n      res += tmp;\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <iostream>\n#include <map>\n#include <algorithm>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n#define INF (1<<28)\ntypedef long long Int;\n\nint N, B[64], C[64];\nstring A[64], D[64][64];\nint g[64][64], vis[64];\nint m, q[64];\n\nvoid collect(int at) {\n    if (vis[at]) return ;\n    vis[at] = 1;\n    q[m++] = at;\n    rep (i, N) if (g[at][i]) collect(i);\n}\n\nint n, a, r[64], p[64], w[4][1024];\nInt f[64];\n\nvoid prepare() {\n    n = m;\n    a = 0;\n    rep (i, n) r[i] = q[i];\n    rep (i, n) {\n        p[i] = B[r[i]];\n        f[i] = 0;\n        rep (j, n) if (g[r[i]][r[j]]) f[i] |= 1LL<<j;\n    }\n    rep (k, 4) rep (b, 1024) {\n        int s = 0;\n        for (int i = 0; i < 10 && k*10+i < n; i++) if (b&(1<<i)) s += p[k*10+i];\n        w[k][b] = s;\n    }\n}\n\nvoid rec(int k, Int u) {\n    int s = w[0][u&1023] + w[1][(u>>10)&1023]\n        + w[2][(u>>20)&1023] + w[3][(u>>30)&1023];\n    if (s < a) return ;\n    if (k == n) a = s;\n    else {\n        rep (i, k) if (!(u&(1LL<<i)) && !(f[i]&u)) return ;\n        const int mask = (1LL<<n) - 1;\n        if (u&(1LL<<k)) rec(k+1, u&(mask-f[k]));\n        if (r[k]) rec(k+1, u&(mask-(1LL<<k)));\n    }\n}\n\nint solve() {\n    memset(vis, 0, sizeof(vis));\n    int ans = 0;\n    rep (i, N) if (!vis[i]) {\n        m = 0;\n        collect(i);\n        prepare();\n        rec(0, (1LL<<n)-1);\n        ans += a;\n    }\n    return ans;\n}\n\nint main() {\n    for (;;) {\n        cin >> N;\n        if (N == 0) return 0;\n        map<string, int> of;\n        rep (i, N) {\n            cin >> A[i] >> B[i] >> C[i];\n            of[A[i]] = i;\n            rep (j, C[i]) cin >> D[i][j];\n        }\n        memset(g, 0, sizeof(g));\n        rep (i, N) rep (j, C[i]) g[i][of[D[i][j]]] = 1;\n        printf(\"%d\\n\", solve());\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i,x,y) for(int i=(x);i<(y);++i)\n#define debug(x) #x << \"=\" << (x)\n\n#ifdef DEBUG\n#define _GLIBCXX_DEBUG\n#define print(x) std::cerr << debug(x) << \" (L:\" << __LINE__ << \")\" << std::endl\n#else\n#define print(x)\n#endif\n\nconst int inf=1e9;\nconst int64_t inf64=1e18;\nconst double eps=1e-9;\n\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T> &vec){\n    os << \"[\";\n    for (const auto &v : vec) {\n    \tos << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\nvoid solve(int n){\n    vector<vector<string>> graph_(n);\n    map<string,int> encode;\n    vector<int> strength(n),sum(n);\n    rep(i,0,n){\n        string a;\n        int b,c;\n        cin >> a >> b >> c;\n        encode[a]=i;\n        strength[i]=b;\n        sum[i]=b;\n        if(i>0) sum[i]+=sum[i-1];\n        rep(j,0,c){\n            string d;\n            cin >> d;\n            graph_[i].push_back(d);\n        }\n    }\n    vector<vector<int>> graph(n);\n    rep(i,0,n){\n        rep(j,0,graph_[i].size()){\n            graph[i].push_back(encode[graph_[i][j]]);\n        }\n    }\n\n    int maxi=0;\n    function<int(int,int,int)> rec=[&](int s,int i,int k){\n        if(i==n) return k;\n        if(k+sum[n-1]-sum[i-1]<=maxi) return 0;\n        int res=0;\n        bool f=true;\n        for(int j:graph[i]) if((s>>j)&1){\n            f=false;\n            break;\n        }\n        res=rec(s,i+1,k);\n        if(f) res=max(res,rec(s|(1<<i),i+1,k+strength[i]));\n        maxi=max(maxi,res);\n        return res;\n    };\n\n    cout << rec(1,1,strength[0]) << endl;\n}\n\nint main(){\n    std::cin.tie(0);\n    std::ios::sync_with_stdio(false);\n    cout.setf(ios::fixed);\n    cout.precision(10);\n    for(;;){\n        int n;\n        cin >> n;\n        if(!n) break;\n        solve(n);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<ll> memo;\n\nvoid dfs(int x,int sum,ll S,int idx){\n  \n  for(int i=idx;i<n;i++){\n    \n    int f=0;\n    \n    for(int j=0;j<n;j++)\n      if((S&(1<<j))&&G[j][i]) f=1;\n    \n    if(!f){\n      \n      ll nS=S;\n\n      nS|=(1<<i);\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[i]);\n      \n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=cost[0];\n    \n    ll S=(1<<0);\n\n    dfs(1,cost[0],S,1);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <set>\n#include <cstdio>\n#include <map>\n#include <iostream>\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n\ninline int getInt(){ int s; scanf(\"%d\", &s); return s; }\n\ntypedef long long ll;\n\nusing namespace std;\n\ntemplate<class T>\nclass IdMaker{\npublic:\n  std::map<T,int> _m;\n  int getId(const T &v){\n    if(_m.find(v) == _m.end()){\n      int next = _m.size();\n      return _m[v] = next;\n    }\n    return _m[v];\n  }\n};\n\nll adj[40];\nint str[40];\n\nint solve(ll flag, int pos){\n  int sum = 0;\n\n  for(int i = pos; flag >= (1ll << i); i++){\n    if((flag & (1ll << i)) != 0 && (adj[i] & flag) == 0){\n      sum += str[i];\n      flag ^= 1ll << i;\n    }\n  }\n\n  int ret = sum;\n  for(int i = pos; flag >= (1ll << i); i++){\n    if((flag & (1ll << i)) != 0){\n      ret = max(ret, sum + str[i] + solve((flag ^ (1ll << i)) & (~adj[i]), i + 1));\n    }\n  }\n\n  return ret;\n}\n\nint main(){\n  while(const int n = getInt()){\n    IdMaker<string> idm;\n\n    REP(i,n){\n      string s; cin >> s;\n      str[idm.getId(s)] = getInt();\n      const int m = getInt();\n      adj[idm.getId(s)] = 0;\n      REP(j,m){\n        string a; cin >> a;\n        adj[idm.getId(s)] |= (1ll << idm.getId(a));\n      }\n    }\n\n    ll start = (1ll << n) - 1;\n    start ^= 1;\n    start ^= adj[0];\n\n    printf(\"%d\\n\", str[0] + solve(start, 0));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\nusing namespace std;\n\ntemplate<typename T>\nostream& operator << (ostream& os, vector<T>& v){\n\trep(i,v.size()){ os << v[i] << (i == v.size() - 1 ? \"\" : \" \"); } return os;\n}\ntemplate<typename T>\nistream& operator >> (istream& is, vector<T>& v){\n\tfor(T& x: v){ is >> x; } return is;\n}\n\n//i番目のビットを返す\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\n//i番目を1にする\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\n//i番目を0にする\nint clearBit(int num, int i){\n\tint mask = ~(1 << i);\n\treturn num & mask;\n}\n\n//i番目をvで置き換える\nint updateBit(int num, int i, int v){\n\tint mask = ~(1 << i);\n\treturn (num & mask) | (v << i);\n}\n\nvoid input(int n, vector<int>& atk, vector<int>& bit){\n\tvector<string> name(n);\n\tvector<vector<string>> near(n);\n\n\tmap<string, int> id;\n\trep(i,n){\n\t\tint d;\n\t\tcin >> name[i] >> atk[i] >> d;\n\t\tid[name[i]] = i;\n\t\twhile(d--){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\tnear[i].emplace_back(s);\n\t\t}\n\t}\n\n\trep(i,n){\n\t\tbit[i] |= 1 << i;\n\t\tfor(auto s : near[i]){\n\t\t\tbit[i] |= 1 << id[s];\n\t\t}\n\t\t//cout << bitset<10>(bit[i]) << endl;\n\t}\n}\n\nmap<int,int> memo;\nint dfs(int& n, vector<int>&atk, vector<int>& bit, int enemy){\n\tif(memo.count(enemy)) return memo[enemy];\n\n\tint res = 0;\n\trep(i,n){\n\t\tif(getBit(enemy,i)) continue;\n\t\tres = max(res, dfs(n, atk, bit, enemy bitor bit[i]) + atk[i]);\n\t}\n\treturn memo[enemy] = res;\n}\n\nint main(){\n\tint n;\n\twhile(cin >> n,n){\n\t\tvector<int> atk(n), bit(n,0);\n\t\tinput(n, atk, bit);\n\n\t\tmemo.clear();\n\t\tcout << dfs(n, atk, bit, bit[0]) + atk[0] << endl;\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <cassert>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <queue>\n#include <deque>\n#include <stack>\n#include <list>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <complex>\n#include <iomanip>\n#include <bitset>\n#include <random>\n\nusing namespace std;\nusing i64 = int_fast64_t;\nusing db = double;\nusing ldb = long double;\nusing pii = pair<int, int>;\nusing pli = pair<int_fast64_t, int>;\nusing pll = pair<int_fast64_t, int_fast64_t>;\nusing pdi = pair<double, int>;\nusing pdd = pair<double, double>;\ntemplate <class T> using vct = vector<T>;\ntemplate <class T> using heap = priority_queue<T>;\ntemplate <class T> using minheap = priority_queue<T, vector<T>, greater<T>>;\ntemplate <class T> constexpr T inf = numeric_limits<T>::max() / (T)8;\nconstexpr int dx[9] = {1, 0, -1, 0, 1, -1, -1, 1, 0};\nconstexpr int dy[9] = {0, 1, 0, -1, 1, 1, -1, -1, 0};\nconstexpr long double Pi = 3.1415926535897932384626433832795028841971;\nconstexpr long double Golden = 1.61803398874989484820;\nconstexpr long double eps = 1e-15;\n\n#define iostream_untie true\n#define mod 1000000007LL\n#define stdout_precision 10\n#define stderr_precision 6\n#define itrep(i,v) for(auto i = begin(v); i != end(v); ++i)\n#define ritrep(i,v) for(auto i = rbegin(v); i != rend(v); ++i)\n#define rep(i,n) for(int i = 0; i < (n); ++i)\n#define rrep(i,n) for(int i = (n) - 1; i >= 0; --i)\n#define all(v) begin(v), end(v)\n#define rall(v) rbegin(v), rend(v)\n#define fir first\n#define sec second\n#define u_map unordered_map\n#define u_set unordered_set\n#define l_bnd lower_bound\n#define u_bnd upper_bound\n#define rsz resize\n#define ers erase\n#define emp emplace\n#define emf emplace_front\n#define emb emplace_back\n#define pof pop_front\n#define pob pop_back\n#define mkp make_pair\n#define mkt make_tuple\n#define popcnt __builtin_popcount\n\nnamespace setup {\n    struct setupper {\n        setupper() {\n            if(iostream_untie) {\n                ios::sync_with_stdio(false);\n                std::cin.tie(nullptr);\n                std::cout.tie(nullptr);\n                std::cerr.tie(nullptr);\n            }\n            std::cout << fixed << setprecision(stdout_precision);\n            std::cerr << fixed << setprecision(stderr_precision);\n    #ifdef LOCAL\n            if(!freopen(\"input.txt\",\"rt\",stdin)) {\n                cerr << \"Failed to open the input file.\\n\"; exit(EXIT_FAILURE);\n            }\n            // if(!freopen(\"output.txt\",\"wt\",stdout)) {\n            //     cerr << \"Failed to open the output file.\\n\"; exit(EXIT_FAILURE);\n            // }\n            // std::cerr << \"\\n---stderr---\\n\";\n            // auto print_atexit = []() {\n            //     std::cerr << \"Exec time : \" << clock() / (double)CLOCKS_PER_SEC * 1000.0 << \"ms\\n\";\n            //     std::cerr << \"------------\\n\";\n            // };\n            // atexit((void(*)())print_atexit);\n            // atexit((void(*)())fclose(stdin));\n    #endif\n        }\n    } __setupper;\n}\n\nnamespace std {\n    template <class RAitr> void rsort(RAitr __first, RAitr __last) {\n        sort(__first, __last, greater<>());\n    }\n    template <class T> void hash_combine(size_t &seed, T const &key) {\n        seed ^= hash<T>()(key) + 0x9e3779b9 + (seed << 6) + (seed >> 2);\n    }\n    template <class T, class U> struct hash<pair<T,U>> {\n        size_t operator()(pair<T,U> const &pr) const\n        {\n            size_t seed = 0;\n            hash_combine(seed,pr.first);\n            hash_combine(seed,pr.second);\n            return seed;\n        }\n    };\n    template <class Tup, size_t index = tuple_size<Tup>::value - 1> struct hashval_calc {\n        static void apply(size_t& seed, Tup const& tup) {\n            hashval_calc<Tup, index - 1>::apply(seed, tup);\n            hash_combine(seed,get<index>(tup));\n        }\n    };\n    template <class Tup> struct hashval_calc<Tup,0> {\n        static void apply(size_t& seed, Tup const& tup) {\n            hash_combine(seed,get<0>(tup));\n        }\n    };\n    template <class ...T> struct hash<tuple<T...>> {\n        size_t operator()(tuple<T...> const& tup) const\n        {\n            size_t seed = 0;\n            hashval_calc<tuple<T...>>::apply(seed,tup);\n            return seed;\n        }\n    };\n}\n\ntemplate <class T, class U> istream &operator>> (istream &s, pair<T,U> &p) { return s >> p.first >> p.second; }\ntemplate <class T, class U> ostream &operator<< (ostream &s, const pair<T,U> p) { return s << p.first << \" \" << p.second; }\ntemplate <class T> ostream &operator<< (ostream &s, const vector<T> &v) {\n    for(size_t i = 0; i < v.size(); ++i) s << (i ? \" \" : \"\") << v[i]; return s;\n}\n#define dump(...) cerr << \" [ \" << __LINE__ << \" : \" << __FUNCTION__ << \" ] \" << #__VA_ARGS__ << \" : \";\\\ndump_func(__VA_ARGS__)\ntemplate <class T> void dump_func(T x) { cerr << x << '\\n'; }\ntemplate <class T,class ...Rest> void dump_func(T x, Rest ... rest) { cerr << x << \",\"; dump_func(rest...); }\ntemplate <class T = i64> T read() { T x; return cin >> x, x; }\ntemplate <class T> void write(T x) { cout << x << '\\n'; }\ntemplate <class T, class ...Rest> void write(T x, Rest ... rest) { cout << x << ' '; write(rest...); }\nvoid writeln() {}\ntemplate <class T, class ...Rest> void writeln(T x, Rest ... rest) { cout << x << '\\n'; writeln(rest...); }\n#define esc(...) writeln(__VA_ARGS__), exit(0)\n\nnamespace updater {\n    template <class T> static void add(T &x, const T &y) { x += y; }\n    template <class T> static void ext_add(T &x, const T &y, size_t w) { x += y * w; }\n    template <class T> static void mul(T &x, const T &y) { x *= y; }\n    template <class T> static void ext_mul(T &x, const T &y, size_t w) { x *= (T)pow(y,w); }\n    template <class T> static bool chmax(T &x, const T &y) { return x < y ? x = y,true : false; }\n    template <class T> static bool chmin(T &x, const T &y) { return x > y ? x = y,true : false; }\n};\nusing updater::add;\nusing updater::chmax;\nusing updater::chmin;\n\ntemplate <class T> constexpr T minf(const T &x, const T &y) { return min(x,y); }\ntemplate <class T> constexpr T maxf(const T &x, const T &y) { return max(x,y); }\nconstexpr bool bit(i64 n, int e) { return (n >> e) & 1; }\nconstexpr int_fast64_t mask(int_fast64_t n, int e) { return n & ((1 << e) - 1); }\nconstexpr int ilog(int_fast64_t x, int_fast64_t b = 2) { return x ? 1 + ilog(x / b, b) : -1; }\ntemplate <class F> int_fast64_t binry(int_fast64_t ok, int_fast64_t ng, const F &fn) {\n    while (abs(ok - ng) > 1) {\n        int_fast64_t mid = (ok + ng) / 2;\n        (fn(mid) ? ok : ng) = mid;\n    }\n    return ok;\n}\ntemplate <class A, size_t N, class T> void init(A (&array)[N], const T &val) { fill((T*)array,(T*)(array + N),val); }\ntemplate <class T> vector<int> cmprs(const vector<T> &v) {\n    vector<T> tmp = v; vector<int> ret;\n    sort(begin(tmp),end(tmp));\n    tmp.erase(unique(begin(tmp),end(tmp)), end(tmp));\n    for(T i : v) ret.emplace_back(lower_bound(begin(tmp),end(tmp),i) - begin(tmp));\n    return ret;\n}\ntemplate <class T> vector<int> cmprs(const T *__first, const T *__last) {\n    return cmprs(vector<T>(__first, __last));\n}\ntemplate <class F> void for_subset(uint_fast64_t s, const F &fn) {\n    uint_fast64_t tmp = s;\n    do { fn(tmp); } while((--tmp &= s) != s);\n}\n\n\n/* The main code follows. */\n\nint n;\nint b[51];\nint le[45],re[45];\nint l[1<<20],r[1<<20];\nint lsz,rsz;\n\nvoid solve() {\n    int ans=-inf<int>;\n    for(int s=0; s<(1<<lsz); ++s) {\n        if(s & le[0]) {\n            l[s]=-inf<int>;\n            continue;\n        }\n        bool flag=false;\n        for(int i=0; i<lsz; ++i) {\n            if(s>>i & 1) {\n                if(s & le[i+1]) {\n                    flag=true;\n                    break;\n                }\n                l[s]+=b[i+1];\n            }\n        }\n        if(flag) l[s]=-inf<int>;\n    }\n    for(int s=0; s<(1<<rsz); ++s) {\n        bool flag=false;\n        if(s & re[0]) {\n            r[s]=-inf<int>;\n            continue;\n        }\n        for(int i=0; i<rsz; ++i) {\n            if(s>>i & 1) {\n                if(s & re[i+1+lsz]) {\n                    flag=true;\n                    break;\n                }\n                r[s]+=b[i+1+lsz];\n            }\n        }\n        if(flag) r[s]=-inf<int>;\n    }\n    for(int i=0; i<rsz; ++i) {\n        for(int s=0; s<(1<<rsz); ++s) {\n            if(s>>i & 1) {\n                chmax(r[s],r[s^1<<i]);\n            }\n        }\n    }\n    for(int s=0; s<(1<<lsz); ++s) {\n        int tmp=0;\n        for(int i=0; i<lsz; ++i) {\n            if(s>>i & 1) {\n                tmp|=re[i+1];\n            }\n        }\n        int ok=(1<<rsz)-1;\n        ok^=tmp;\n        chmax(ans,r[ok]+l[s]);\n    }\n    ans+=b[0];\n    cout<<ans<<endl;\n} \n\nsigned main() {\n    while(cin>>n,n) {\n        lsz=n/2;\n        rsz=n-1-lsz;\n        map<string,int> cont;\n        init(le,0);\n        init(re,0);\n        init(l,0);\n        init(r,0);\n        vector<string> d[51];\n        rep(i,n) {\n            string a; cin>>a;\n            cont[a]=i;\n            cin>>b[i];\n            int c; cin>>c;\n            d[i].resize(c);\n            rep(j,c) {\n                cin>>d[i][j];\n            }\n        }\n        rep(i,n) {\n            rep(j,d[i].size()) {\n                int co=cont[d[i][j]];\n                if(co<=lsz && co>0) {\n                    le[i]|=1<<(co-1);\n                } else if(co>0) {\n                    re[i]|=1<<(co-lsz-1);\n                }\n            }\n        }\n        solve();\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) for(int i = 0; i < (b); i++)\n#define all(a) (a).begin(), (a).end()\n#define show(x)  cerr << #x << \" = \" << (x) << endl;\n//const int INF = 1e8;\nusing namespace std;\n\n#define int long long\n\nmap<string,int> id;\nmap<string,long long> bit;\nmap<long long, long long> memo;\nvector<int> sum(50);\nint n;\nint maximum;\nstring a[50], d[50][50];\nint b[50], c[50];\n\nbool getBit(int num, int i){\n\treturn ((num & (1 << i)) != 0);\n}\n\nint setBit(int num, int i){\n\treturn num | (1 << i);\n}\n\nvoid dfs(int p, long long used , int score){\n\tmaximum = max(maximum, score);\n\tif(p == n) return;\n\tif(score + sum[p] <= maximum) return;\n\n\tlong long next = used bitor bit[a[p]];\n\tif(not getBit(used,p)) dfs(p, next, score + b[p]);\n\n\tdfs(p + 1, used, score);\n\n}\n\nsigned main(){\n\twhile(cin >> n,n){\n\t\tid.clear();\n\t\tbit.clear();\n\t\tmemo.clear();\n\t\tsum.clear();\n\t\tmaximum = 0;\n\n\t\trep(i,n){\n\t\t\tcin >> a[i] >> b[i] >> c[i];\n\t\t\tsum[i] = b[i];\n\t\t\tid[a[i]] = i;\n\t\t\trep(j,c[i]){\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\t\trep(i,n - 1){\n\t\t\tsum[i + 1] += sum[i];\n\t\t}\n\t\trep(i,n){\n\t\t\tlong long near = setBit(0,i);\n\t\t\trep(j,c[i]){\n\t\t\t\tnear = setBit(near, id[d[i][j]]);\n\t\t\t}\n\t\t\tbit[a[i]] = near;\n\t\t}\n\n\n\n\t\tdfs(1, bit[a[0]], b[0]);\n\t\tcout << maximum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\n\nstring A[41];\nll B[41];\nvector<string> D[41];\nll dp[2][1<<20];\n\nint main() {\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    Hmap<string, int> hm;\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    auto calc = [&](vl& dp, int s, int e) {\n      int l = e - s;\n      rep(mask, 1 << l) {\n\trep(i, l) {\n\t  if(mask & (1<<i)) continue;\n\t  bool f = true;\n\t  for(const auto& str: D[i+s]) {\n\t    int t = hm[str];\n\t    if(s <= t && t < e) {\n\t      if(mask&(1<<(t - s))) f = false;\n\t    }\n\t  }\n\t  if(f) {\n\t    int nxt = mask | (1<<i);\n\t    dp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n\t  }\n\t}\n      }\n      rep(mask, 1<<l) {\n\trep(i, l) {\n\t  if(mask&(1<<i)) {\n\t    int pre = mask - (1<<i);\n\t    dp[mask] = max(dp[mask], dp[pre]);\n\t  }\n\t}\n      }\n    };\n\n    vector<vector<ll>> dp(2, vl(1<<((n+1)/2), 0LL));\n    \n    calc(dp[0], 0, n/2);\n    calc(dp[1], n/2, n);\n\n    int len = n - (n/2);\n    vector<int> masks(1<<(n/2), (1<<len)-1);\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tfor(const auto& str : D[i]) {\n\t  int t = hm[str] - n / 2;\n\t  if(t < 0) continue;\n\t  if(masks[mask] & (1<<t)) masks[mask] -= (1<<t);\n\t}\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp[0][mask] + dp[1][masks[mask]]);\n    cout << ans << '\\n';\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        vector<int> power(n);\n        map<string, int> mp;\n        vector<vector<string>> nearby(n);\n        for (int i = 0; i < n; ++i) {\n            string s;\n            int c;\n            cin >> s >> power[i] >> c;\n            mp[s] = i;\n            nearby[i].resize(c);\n            for (int j = 0; j < c; ++j)\n                cin >> nearby[i][j];\n        }\n        vector<long long> isnearby(n, 0LL);\n        for (int i = 0; i < n; ++i)\n            for (auto& j : nearby[i])\n                isnearby[i] |= 1LL << mp[j];\n\n        for (int i = 0; i < n; ++i)\n            if ((isnearby[0] >> i) & 1)\n                power[i] = -1000000;\n\n        int n1 = n / 2;\n        int n2 = n - n1;\n        vector<int> dp(1 << n1, -1000000);\n        for (int i = 1; i < (1 << n1); i += 2) {\n            int ma = 0;\n            long long inb = 0;\n            dp[i] = 0;\n            for (int j = 0; j < n1; ++j) {\n                if ((i >> j) & 1) {\n                    inb |= isnearby[j];\n                    dp[i] += power[j];\n                    ma = max(ma, dp[i ^ (1 << j)]);\n                }\n            }\n            if (i & inb)\n                dp[i] = ma;\n        }\n        int ans = 0;\n        int msk = (1 << n1) - 1;\n        for (int i = 0; i < (1 << n2); ++i) {\n            int sum = 0;\n            long long inb = 0;\n            for (int j = 0; j < n2; ++j) {\n                if ((i >> j) & 1) {\n                    inb |= isnearby[n1 + j];\n                    sum += power[n1 + j];\n                }\n            }\n            if (!(i & (inb >> n1)))\n                ans = max(ans, sum + dp[(inb & msk) ^ msk]);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<string>\n#include<vector>\n\nusing namespace std;\n\nint N;\nint B[40];\nlong long pb[40];\nmap<int,map<long long,int> > mem;\n\nint dfs(int x,long long cpb){\n  if(x==N)return 0;\n  long long fpb=cpb>>x;\n  if(mem[x].count(fpb))return mem[x][fpb];\n  int r=dfs(x+1,cpb);\n  if(!(cpb>>x&1)){\n    r=max(r,B[x]+dfs(x+1,cpb|pb[x]));\n  }\n  return mem[x][fpb]=r;\n}\n\nint main(){\n  while(cin>>N,N){\n    mem.clear();\n    map<string,int> m;\n    vector<string> d[40];\n    for(int i=0;i<N;i++){\n      string a;\n      int c;\n      cin>>a>>B[i]>>c;\n      m[a]=i;\n      d[i].resize(c);\n      for(int j=0;j<c;j++){\n\tcin>>d[i][j];\n      }\n    }\n    for(int i=0;i<N;i++){\n      pb[i]=0;\n      for(auto e:d[i]){\n\tpb[i]|=1LL<<m[e];\n      }\n    }\n    cout<<B[0]+dfs(1,pb[0])<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nconst int BIT = 1<<21;\nint N;\nmap<string,int> id;\nint B[MAXN];\nGraph g;\nint S[BIT], T[BIT], D[BIT];\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    int b = N/2;\n    int a = N - b;\n    vector<pair<int,int> > esS, esT, esU;\n    for(int v = 0; v < N; ++v) {\n      for(int j = 0; j < g[v].size(); ++j) {\n        int nv = g[v][j];\n        if(v < a && nv < a && v < nv) esS.push_back(make_pair(v, nv));\n        if(v >= a && nv >= a && v < nv) esT.push_back(make_pair(v, nv));\n        if(v < a && nv >= a) esU.push_back(make_pair(v, nv));\n      }\n    }\n\n    fill(S, S+BIT, 0);\n    for(int i = 0; i < esS.size(); ++i) {\n      int p = esS[i].first;\n      int q = esS[i].second;\n      int j = ((1<<p) | (1<<q));\n      for(int k = j; k < (1<<a); k = ((k + 1)|j)) S[k] = -1;\n    }\n    for(int j = 0; j < (1<<a); ++j) {\n      vector<int> used(N);\n      if(S[j] == -1) continue;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n        if(used[v]) S[j] += B[v];\n      }\n    }\n\n    fill(T, T+BIT, 0);\n    for(int i = 0; i < esT.size(); ++i) {\n      int p = esT[i].first;\n      int q = esT[i].second;\n      int j = ((1<<(p-a)) | (1<<(q-a)));\n      for(int k = j; k < (1<<a); k = ((k + 1)|j)) T[k] = -1;\n    }\n    for(int j = 0; j < (1<<b); ++j) {\n      vector<int> used(N);\n      if(T[j] == -1) continue;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v >= a && (j & (1<<(v-a)));\n        if(used[v]) T[j] += B[v];\n      }\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      for(int k = 0; k < b; ++k) {\n        if(j & (1<<k)) continue;\n        T[j|(1<<k)] = max(T[j|(1<<k)], T[j]);\n      }\n    }\n\n    fill(D, D+BIT, (1<<b)-1);\n    vector<int> bits(N, 0);\n    for(int i = 0; i < esU.size(); ++i) {\n      int p = esU[i].first;\n      int q = esU[i].second;\n      bits[p] |= (1<<(q-a));\n    }\n    for(int i = 0; i < a; ++i) {\n      int j = 1<<i;\n      for(int k = j; k < (1<<a); k = ((k+1)|j)) D[k] &= ~bits[i];\n    }\n\n    int res = 0;\n\n    for(int j = 0; j < (1<<a); ++j) {\n      if(S[j] == -1) continue;\n      if(!(j & 1)) continue;\n      /*\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n      }\n      int bit = (1<<b)-1;\n      for(int i = 0; i < esU.size(); ++i) {\n        int p = esU[i].first;\n        int q = esU[i].second;\n        if(used[p]) {\n          bit &= ~(1<<(q-a));\n        }\n      }\n      */\n      int bit = D[j];\n      if(T[bit] == -1) continue;\n      res = max(res, S[j] + T[bit]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\n\nmap<string,int> num;\nint n, cost[N], ans;\nint G[N][N];\n\nset<vector<int> > memo;\n\nvoid dfs(int x,int sum,vector<int> S,int idx){\n  \n  for(int i=idx;i<n;i++){\n\n    if(!x&&i) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<S.size();j++)\n      if(G[S[j]][i]) f=1;\n    \n    if(!f){\n      \n      vector<int> nS=S;\n      \n      nS.push_back(i);\n      \n      sort(nS.begin(),nS.end());\n      \n      if(memo.count(nS)) continue;\n  \n      memo.insert(nS);\n      \n      ans=max(ans,sum+cost[i]);\n\t\n      dfs(x+1,sum+cost[i],nS,i+1);\n    }\n    \n  }\n  \n}\n\nint main(){\n  \n  while(1){\n    \n    cin>>n;\n    if(!n) break;\n    \n    int cnt=0;\n  \n    for(int i=0;i<n;i++){\n    \n      string s;\n      int a, b;\n    \n      cin>>s>>a;\n\n      if(!num.count(s)) num[s]=cnt++;\n    \n      cost[num[s]]=a;\n    \n      cin>>b;\n\n      for(int j=0;j<b;j++){\n      \n\tstring t;\n      \n\tcin>>t;\n      \n\tif(!num.count(t)) num[t]=cnt++;\n      \n\tG[num[s]][num[t]]=1;\n\t\n      }\n    \n    }\n\n    ans=0;\n\n    vector<int> S;\n    \n    dfs(0,0,S,0);\n    \n    cout<<ans<<endl;\n\n    memset(G,0,sizeof(G));\n    num.clear();\n    memo.clear();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<map>\n#include<vector>\nusing namespace std;\n\ntypedef pair<long long ,int> P;\n\nint ans,n;\nint b[50],c[50];\nlong long adj[50],mask;\nstring a[50];\nvector<string> d[50];\nmap< P, int> memo;\n\nint rec(long long can,int sum, int l){\n  if(!can)return 0;\n  if(memo.find(P(can,l)) != memo.end())return memo[P(can,l)];\n\n  /*\n  for(int i=0;i<n;i++){\n    cout << ((can>>i)&1);\n  }\n  cout << endl;\n  */\n\n  int tmp = 0;\n  for(int i=l;i<n;i++)\n    if( (can>>i)&1 )tmp += b[i];\n  if(tmp + sum <= ans)return 0;\n  \n  tmp = 0;\n  for(int i=l;i<n;i++){\n    if( (can>>i)&1 ){\n      tmp = max(tmp,rec( (adj[i]^mask) & can,sum+b[i],i+1) + b[i]);\n    }\n  }\n\n  if(ans<sum + tmp)ans = sum+tmp;\n  if(can<(1LL<<15))memo[P(can,l)] = tmp;\n  return tmp;\n}\n\nint main(){\n  while(cin >> n, n){\n    for(int i=0;i<n;i++){\n      cin >> a[i] >> b[i] >> c[i];\n      d[i].resize(c[i]);\n      for(int j=0;j<c[i];j++)cin >> d[i][j];\n    }\n    string mine = a[0];\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tif(b[i] < b[j]){\n\t  swap(a[i],a[j]);\n\t  swap(b[i],b[j]);\n\t  swap(c[i],c[j]);\n\t  swap(d[i],d[j]);\n\t}\n      }\n    }\n\n    map<string,int> m;\n    for(int i=0;i<n;i++)m[a[i]] = i;\n    mask = (1LL<<n) -1LL;\n\n    for(int i=0;i<n;i++){\n      adj[i] = 1LL<<i;\n      for(int j=0;j<c[i];j++)adj[i] |= 1LL << m[d[i][j]];\n    }\n\n\n    ans = 0; memo.clear();\n    rec(adj[m[mine]]^mask,b[m[mine]],0);\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\n\nint main(){\n    cin >> n;\n    while(n){\n        map<string,int> mp;\n        vector<i64> edges(n + 10,0);\n        vector<int> x(n + 10,0);\n\n        auto get_i = [&](string& s){\n            if(mp.count(s)){\n                return  mp[s];\n            }\n            else{\n                mp[s] = mp.size();\n                return (int)mp.size() - 1;\n            }\n        };\n\n        for(int c = 0;c < n;c++){\n            string s;cin >> s;\n            int i = get_i(s);\n            int C;\n            cin >> x[i] >> C;\n            for(int d = 0;d < C;d++){\n                cin >> s;\n                edges[i] |= (1LL << get_i(s));\n            }\n        }\n\n        vector<int> sum(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        int result = 0;\n        function<void(i64,i64,int)> dfs = [&](int i,i64 bit,int now_sum){\n            result = max(result , now_sum);\n            if(i == n) return;\n            //枝刈り\n            if(now_sum + sum[i] <= result) return;\n            //throw\n            dfs(i + 1,bit,now_sum);\n\n            if(!(bit & edges[i])) dfs(i + 1,bit | (1LL << i),now_sum + x[i]);\n        };\n        dfs(1,1,x[0]);\n        cout << result;\n        cin >> n;\n        if(n) cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\nconst int HALF=20;\nint dp0[1<<HALF];\nint vs0[HALF];\nint dp1[1<<HALF];\nint vs1[HALF];\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    for(int i=0;i<half;i++){\n        vs0[i]=0;\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=1;i<(1<<half);i+=2){\n        int vs=0;\n        int val=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                val+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) val=-INF;\n            dp0[i]=val;\n        }\n    }\n\n    \n    for(int i=0;i<rest;i++){\n        vs1[i]=0;\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        int val=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                val+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) val=-INF;\n            dp1[i]=val;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n\n    vector<int> vs01(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]>=half) vs01[i]|=(1<<(g[i][j]-half));\n        }\n    }\n    int res=0;\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if(i&(1<<j)) opn&=~vs01[j];\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    //ios_base::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <string>\n#include <cstring>\n\nusing namespace std;\n\nint N;\nmap<string,int> m;\nint idx=0;\nvector<int> G[101];\nvector<string> CS[101];\nstring names[101];\nint strong[101];\nbool used[101];\nint optNum;\n\n// 現在選べるものから選ぶ\nvoid dfs(int sum){\n  int allSum=0;\n  for(int i=0;i<N;i++)\n    if(!used[i])allSum+=strong[i];\n  if(allSum+sum<=optNum)return;\n  bool cur[101];\n  for(int j=0;j<N;j++)\n    cur[j]=used[j];\n  for(int i=0;i<N;i++){\n    if(used[i])continue;\n    used[i]=true;\n    for(int j=0;j<(int)G[i].size();j++){\n      int to=G[i][j];\n      used[to]=true;\n    }\n    dfs(sum+strong[i]);\n    for(int j=0;j<N;j++)used[j]=cur[j];\n  }\n  optNum=max(optNum,sum);\n}\n\nint main(){\n  while(cin>>N&&N){\n    idx=0;\n    optNum=-1;\n    for(int i=0;i<101;i++){\n      G[i].clear();\n      CS[i].clear();\n    }\n    m.clear();\n    for(int i=0;i<N;i++){\n      cin>>names[i]>>strong[i];\n      int C;\n      cin>>C;\n      for(int j=0;j<C;j++){\n\tstring s;\n\tcin>>s;\n\tif(m.count(s)==0)m[s]=idx++;\n\tCS[i].push_back(s);\n      }\n    }\n    for(int i=0;i<N;i++)\n      m[names[i]]=i;\n    // for(map<string,int>::iterator it=m.begin();it!=m.end();it++){\n    //   cout<<it->first<<\" \"<<it->second<<endl;\n    // }\n    for(int i=0;i<N;i++)\n      for(int j=0;j<(int)CS[i].size();j++)\n\tG[m[names[i]]].push_back(m[CS[i][j]]);\n    memset(used,0,sizeof(used));\n    for(int i=0;i<(int)G[0].size();i++)\n      used[G[0][i]]=true;\n    used[0]=true;\n    dfs(0);\n    cout<<optNum+strong[0]<<endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#include<unordered_map>\n#include<unordered_set>\n#pragma warning(disable:4996)\nusing namespace std;\nusing ld = long double;\ntemplate<class T>\nusing Table = vector<vector<T>>;\n\nint ans = 0;\nvector<int>powers;\nint restp[41];\nbool check(const vector<vector<int>>&tonari,const vector<bool>&oks, const int next, int pow) {\n\tfor (int c = next; c < powers.size(); ++c) {\n\t\tif (oks[c]) {\n\t\t\tpow += powers[c];\n\t\t}\n\t}\n\treturn pow > ans;\n}\nint getans(const vector<vector<int>>&tonari,vector<bool>oks,const int next,const int pow) {\n\tif (check(tonari,oks,next,pow))return pow;\n\telse {\n\t\tif (next == powers.size())return pow;\n\t\tint nans = 0;\n\t\tif(oks[next]){\n\t\t\tvector<bool>noks(oks);\n\t\t\tfor (int c = next + 1; c < powers.size(); ++c) {\n\t\t\t\tif (tonari[next][c])noks[c] = false;\n\t\t\t}\n\t\t\tnans = max(nans, getans(tonari,noks, next + 1, pow + powers[next]));\n\t\t}\n\t\tnans = max(nans,getans(tonari, oks, next + 1, pow));\n\t\tans = max(ans, nans);\n\t\treturn nans;\n\t}\n\n}\n\nstruct country {\n\n};\n\nint main() {\n\twhile (1) {\n\t\tint N; cin >> N;\n\t\tans = 0;\n\t\tmemset(restp, 0, sizeof(restp));\n\t\tpowers.clear();\n\t\tif (!N)break;\n\t\tvector<string>names;\n\t\tvector<vector<string>>rins(N);\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tstring a; int  b, c; cin >> a >> b >> c;\n\t\t\tnames.push_back(a);\n\t\t\tpowers.push_back(b);\n\t\t\tfor (int j = 0; j < c; ++j) {\n\t\t\t\tstring st; cin >> st;\n\t\t\t\trins[i].push_back(st);\n\t\t\t}\n\t\t}\n\t\tvector<vector<int>>tonari(N, vector<int>(N));\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tfor (auto n : rins[i]) {\n\t\t\t\tint r = find(names.begin(), names.end(), n) - names.begin();\n\t\t\t\ttonari[i][r] = true;\n\t\t\t}\n\t\t}\n\t\tvector<bool>oks(N,true);\n\t\tfor (int c = 1; c < powers.size(); ++c) {\n\t\t\tif (tonari[0][c])oks[c] = false;\n\t\t}\n\t\tfor (int c = 0; c < N; ++c) {\n\t\t\trestp[c] = accumulate(powers.begin() + c, powers.end(), 0);\n\t\t}\n\t\tint ans = getans(tonari, oks, 1, powers[0]);\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define fi first\n#define se second\n#define repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define rep(i,n) repl(i,0,n)\n#define each(itr,v) for(auto itr:v)\n#define pb(s) push_back(s)\n#define mp(a,b) make_pair(a,b)\n#define all(x) (x).begin(),(x).end()\n#define dbg(x) cout<<#x\"=\"<<x<<endl\n#define maxch(x,y) x=max(x,y)\n#define minch(x,y) x=min(x,y)\n#define uni(x) x.erase(unique(all(x)),x.end())\n#define exist(x,y) (find(all(x),y)!=x.end())\n#define bcnt(x) bitset<32>(x).count()\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> PPI;\ntypedef pair<ll, ll> PL;\ntypedef pair<P, ll> PPL;\n\n#define INF INT_MAX/3\n\nint n;\nint b[44],c[44];\nstring d[44][44];\nvector<int> g[44];\nint dame[44];\n\nll dfs(int v,ll nmax){\n  if(v==n)return 0;\n  /*\n  ll sum=0;\n  repl(i,v,n){\n    if(!dame[i])sum+=b[i];\n  }\n  if(sum<=nmax)return 0;\n  */\n  ll res=0;\n  { // unuse\n    maxch(res,dfs(v+1,max(nmax,res)));\n  }\n  { // use\n    if(dame[v]>0)return res;\n    dame[v]++;\n    for(int nv:g[v]){\n      dame[nv]++;\n    }\n    maxch(res,dfs(v+1,max(nmax,res))+b[v]);\n    for(int nv:g[v]){\n      dame[nv]--;\n    }\n    dame[v]--;\n  }\n  return res;\n}\n\nint main(){\n\tcin.sync_with_stdio(false);\n  while(1){\n    rep(i,44)g[i].clear();\n    map<string,int> idx;\n    cin>>n;\n    if(n==0)break;\n    rep(i,n){\n      string name;\n      cin>>name>>b[i]>>c[i];\n      idx[name]=i;\n      rep(j,c[i]){\n        cin>>d[i][j];\n      }\n    }\n    rep(i,n){\n      rep(j,c[i]){\n        int nv=idx[d[i][j]];\n        g[i].pb(nv);\n        //printf(\"(%d %d)\\n\", i,nv);\n      }\n    }\n    memset(dame,0,sizeof(dame));\n    dame[0]++;\n    for(int v:g[0]){\n      dame[v]++;\n    }\n    cout<<dfs(1,0)+b[0]<<endl;\n  }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass solution {\n   private:\n    int N;\n    int MAX;\n    int weight[40] = {}, weightSum[40] = {};\n    bool adj[40][40] = {};\n\n    void dfs(vector<bool> &bits, int sum, int index) {\n        if (index == N) {\n            if (sum > MAX) {\n                MAX = sum;\n            }\n            return;\n        }\n        if (sum + weightSum[index] < MAX) {\n            return;\n        }\n        dfs(bits, sum, index + 1);\n        for (int i = 0; i < index; i++) {\n            if (bits[i] & adj[i][index]) {\n                return;\n            }\n        }\n        bits[index] = true;\n        dfs(bits, sum + weight[index], index + 1);\n        bits[index] = false;\n        return;\n    }\n\n   public:\n    int solve() {\n        MAX = weight[0];\n        vector<bool> bits(N, false);\n        bits[0] = true;\n        dfs(bits, weight[0], 1);\n        return MAX;\n    }\n\n    void getInput() {\n        int C[N];\n        string A[N], D[N][N];\n        map<string, int> m;\n        for (int i = 0; i < N; i++) {\n            cin >> A[i] >> weight[i] >> C[i];\n            for (int j = 0; j < C[i]; j++) {\n                cin >> D[i][j];\n            }\n            m[A[i]] = i;\n        }\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < C[i]; j++) {\n                adj[m[A[i]]][m[D[i][j]]] = true;\n            }\n        }\n        weightSum[N - 1] = weight[N - 1];\n        for (int i = N - 2; 0 <= i; i--) {\n            weightSum[i] = weight[i] + weightSum[i + 1];\n        }\n    }\n\n    solution(int x) : N(x){};\n};\n\nint main() {\n    int N;\n    while (true) {\n        cin >> N;\n        if (N == 0) break;\n        solution s(N);\n        s.getInput();\n        cout << s.solve() << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "                                        #include <bits/stdc++.h>\n                                        #include<iostream>\n                                        #include<cstdio>\n                                        #include<vector>\n                                        #include<queue>\n                                        #include<map>\n                                        #include<cstring>\n                                        #include<string>\n                                        #include <math.h>\n                                        #include<algorithm>\n                                    //    #include <boost/multiprecision/cpp_int.hpp>\n                                        #include<functional>\n                                #define int long long\n                                        #define inf  1000000007\n                                        #define pa pair<int,int>\n                                        #define ll long long\n                                        #define pal pair<double,int>\n                                        #define ppa pair<int,int>\n                                        #define ppap pair<int,pa>\n                                        #define ssa pair<string,int>\n                                        #define  mp make_pair\n                                        #define  pb push_back\n                                        #define EPS (1e-12)\n                                        #define equals(a,b) (fabs((a)-(b))<EPS)\n                                  #define VI vector<int>\n                                        using namespace std;\n                                        \n                                  class pas{\n                                    \tpublic:\n                                    \tint x,y;\n                                    \tpas(int x=0,int y=0):x(x),y(y) {}\n                                    \tpas operator + (pas p) {return pas(x+p.x,y+p.y);}\n                                    \tpas operator - (pas p) {return pas(x-p.x,y-p.y);}\n                                    \tpas operator * (int a) {return pas(x*a,y*a);}\n                                    \tpas operator / (int a) {return pas(x/a,y/a);}\n                                    //\tdouble absv() {return sqrt(norm());}\n                                    \tint norm() {return x*x+y*y;}\n                                    \tbool operator < (const pas &p) const{\n                                   \t\treturn x != p.x ? x<p.x: y<p.y;\n                                   \t}\n                                  //\t\tbool operator < (const pas &p) const{\n                                    //\t\treturn y != p.y ? y<p.y: x<p.x;\n                                    //\t}\n                                    \tbool operator == (const pas &p) const{\n                                    \t\treturn x==p.x && y==p.y;\n                                    \t}\n                                    };\n\n                                        class Point{\n                                        \tpublic:\n                                        \tdouble x,y;\n                                        \tPoint(double x=0,double y=0):x(x),y(y) {}\n                                        \tPoint operator + (Point p) {return Point(x+p.x,y+p.y);}\n                                        \tPoint operator - (Point p) {return Point(x-p.x,y-p.y);}\n                                        \tPoint operator * (double a) {return Point(x*a,y*a);}\n                                        \tPoint operator / (double a) {return Point(x/a,y/a);}\n                                        \tdouble absv() {return sqrt(norm());}\n                                        \tdouble norm() {return x*x+y*y;}\n                                        \tbool operator < (const Point &p) const{\n                                        \t\treturn x != p.x ? x<p.x: y<p.y;\n                                        \t}\n                                        \tbool operator == (const Point &p) const{\n                                        \t\treturn fabs(x-p.x)<EPS && fabs(y-p.y)<EPS;\n                                        \t}\n                                        };\n                                        typedef Point Vector;\n                                 #define pl pair<int,pas>\n                                        struct Segment{\n                                        Point p1,p2;\n                                        };\n                                         double dot(Vector a,Vector b){\n                                        \treturn a.x*b.x+a.y*b.y;\n                                        }\n                                        double cross(Vector a,Vector b){\n                                        \treturn a.x*b.y-a.y*b.x;\n                                        }\n                                    \n            bool parareru(Point a,Point b,Point c,Point d){\n            //\tif(abs(cross(a-b,d-c))<EPS)cout<<\"dd \"<<cross(a-b,d-c)<<endl;\n            \treturn abs(cross(a-b,d-c))<EPS;\n            }\n            double distance_ls_p(Point a, Point b, Point c) {\n              if ( dot(b-a, c-a) < EPS ) return (c-a).absv();\n              if ( dot(a-b, c-b) < EPS ) return (c-b).absv();\n              return abs(cross(b-a, c-a)) / (b-a).absv();\n            }\n            bool is_intersected_ls(Segment a,Segment b) {\n            \tif(a.p1==b.p1||a.p2==b.p1||a.p1==b.p2||a.p2==b.p2) return false;\n            \tif(parareru((a.p2),(a.p1),(a.p1),(b.p2))&&parareru((a.p2),(a.p1),(a.p1),(b.p1))){\n            //\t\tcout<<\"sss\"<<endl;\n            \t\tif(dot(a.p1-b.p1,a.p1-b.p2)<EPS) return true;\n            \t\tif(dot(a.p2-b.p1,a.p2-b.p2)<EPS) return true;\n            \t\tif(dot(a.p1-b.p1,a.p2-b.p1)<EPS) return true;\n            \t\tif(dot(a.p1-b.p2,a.p2-b.p2)<EPS) return true;\n            \t\treturn false;\n            \t}\n              else return ( cross(a.p2-a.p1, b.p1-a.p1) * cross(a.p2-a.p1, b.p2-a.p1) < EPS ) && ( cross(b.p2-b.p1, a.p1-b.p1) * cross(b.p2-b.p1, a.p2-b.p1) < EPS );\n            }\n            double segment_len(Segment a){\n            \t\n            \treturn (a.p1-a.p2).absv();\n            }\n            double segment_dis(Segment a,Segment b){\n            \tif(is_intersected_ls(a,b))return 0;\n            \tdouble r=distance_ls_p(a.p1, a.p2, b.p1);\n            \tr=min(r,distance_ls_p(a.p1, a.p2, b.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p2));\n            \tr=min(r,distance_ls_p(b.p1, b.p2, a.p1));\n            \treturn r;\n            }\n            Point intersection_ls(Segment a, Segment b) {\n              Point ba = b.p2-b.p1;\n              double d1 = abs(cross(ba, a.p1-b.p1));\n              double d2 = abs(cross(ba, a.p2-b.p1));\n              double t = d1 / (d1 + d2);\n             \n              return a.p1 + (a.p2-a.p1) * t;\n            }\n\t\t\tpair<Point,Point> circle_intersection(Point c1,double r1,Point c2,double r2){\n\t\t\t\tdouble d=(c1-c2).absv();\n\t\t\t\tdouble h=(r1*r1-r2*r2+d*d)/2.0/d;\n\t\t\t\tdouble l=sqrt(r1*r1-h*h);\n\t\t\t//\tcout<<d<<\" \"<<h<<\" \"<<l<<endl;\n\t\t\t\tPoint asi=c1+(c2-c1)*h/((c2-c1).absv());\n\t\t\t\tVector r1r2=(c2-c1)/((c2-c1).absv());\n\t\t\t\tVector sui={r1r2.y,-r1r2.x};\n\t\t\t//\tcout<<sui.x<<\" \"<<sui.y<<endl;\n\t\t\t\tpair<Point,Point> z=mp(asi+sui*l,asi-sui*l);\n\t\t\t\tif(z.first.x>z.second.x) swap(z.first,z.second);\n\t\t\t\treturn z;\n\t\t\t}\nmap<string ,int> ma;\nint po[50];\nbool ok[1<<20]={0};\nint an[1<<20]={0};\nint dp[1<<20]={0};\nbool miok[1<<20]={0};\nint dp2[1<<20]={0};\nint hi,mi;\nvector<int> G[50];\nvector<pa> e1,e2,e3;\nint ichi[50]={0};\n\n\nvoid shoki(){\n\te1.clear();\n\te2.clear();\n\te3.clear();\n\tfor(int i=0;i<50;i++){\n\t\tpo[i]=0;\n\t\tG[i].clear();\n\t\tichi[i]=0;\n\t}\n\tfor(int i=0;i<(1<<20);i++){\n\t\tok[i]=0;\n\t\tan[i]=0;\n\t\tdp[i]=0;\n\t\tmiok[i]=0;\n\t\tdp2[i]=0;\n\t}\n}\n\nvoid makeok(){\n\tfor(int i=0;i<(1<<hi);i++)ok[i]=true;\n\t\n\tfor(auto t:e1){\n\t\tok[(1<<t.second)+(1<<t.first)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<hi);i++){\n\t\tbool b=ok[i];\n\t\t\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(ok[i-(1<<j)]==false)b=false;\n\t\t}\n\t\tok[i]=b;\n\t}\n\treturn;\n\t\n}\nvoid makean(){\n\tfor(int i=0;i<(1<<hi);i++)an[i]=(1<<(mi))-1;\n\t\n\tfor(auto t:e3){\n\t\tan[(1<<t.first)]^= (1<<(t.second-hi));\n\t}\n\t\n\tfor(int i=0;i<(1<<hi);i++){\n\t\t\n\t\tfor(int j=0;j<hi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tan[i]=an[1<<j]&an[i-(1<<j)];\n\t\t}\n\t}\n\t\n}\n\nvoid makedp(){\n\tfor(int i=0;i<(1<<mi);i++)miok[i]=true;\n\t\n\tfor(auto t:e2){\n\t\n\t\tmiok[(1<<t.first)+(1<<t.second)]=false;\n\t}\n\t\n\tfor(int i=1;i<(1<<mi);i++){\n\t\tbool b=miok[i];\n\t\t\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tif(miok[i-(1<<j)]==false)b=false;\n\t\t}\n\t\tmiok[i]=b;\n\t}\n\t\n\tfor(int i=0;i<(1<<mi);i++)if(miok[i]){\n\t\tint cnt=0;\n\t\tfor(int  j=0;j<mi;j++)if(i&(1<<j))cnt+=po[j+hi];\n\t\tdp[i]=cnt;\n\t\t\n\t}\n\t\n\t\n\t\n\t\n\tfor(int i=0;i<(1<<mi);i++){\n\t\tfor(int j=0;j<mi;j++){\n\t\t\tif(0==(i&(1<<j)))continue;\n\t\t\tdp[i]=max(dp[i],dp[i-(1<<j)]);\n\t\t}\n\t\t\n\t}\n}\n\n\n\n         signed main(){\nint n;\n         \twhile(1){\n         \tcin>>n;\n         \t\tif(n==0) return 0;\n         \t\t\n         \t\tshoki();\n         \tint count1=0;\n         \tfor(int i=0;i<n;i++){\n         \t\tstring s1,s2;\n         \t\tcin>>s1;\n         \t\tif(ma.find(s1)==ma.end()){\n         \t\t\tma[s1]=count1;\n         \t\t\tcount1++;\n         \t\t}\n         \t\tint r3,r4;\n         \t\tcin>>r3>>r4;\n         \t\tpo[ma[s1]]=r3;\n         \t\tfor(int j=0;j<r4;j++){\n         \t\t\tcin>>s2;\n         \t\t\tif(ma.find(s2)==ma.end()){\n         \t\t\t\tma[s2]=count1;\n         \t\t\t\tcount1++;\n         \t\t\t}\n         \t\t\tG[ma[s1]].pb(ma[s2]);\n         \t\t}\n         \t}\n         \t\n         \tint n1=n/2;\n         \thi=n1,mi=n-n1;\n         \tfor(int i=0;i<G[0].size();i++)ichi[G[0][i]]=1;\n         \t//for(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j])cout<<i<<\" \"<<G[i][j]<<endl;\n         \tfor(int i=0;i<n;i++)for(int j=0;j<G[i].size();j++)if(i<G[i][j]){\n         \n         \t\n         \t\tif(G[i][j]<hi) e1.pb(mp(i,G[i][j]));\n         \t\telse if(i<hi) e3.pb(mp(i,G[i][j]));\n         \t\telse {\n         \t\t\te2.pb(mp(i-hi,G[i][j]-hi));\n         \t\t}\n         \t}\n         \t\n         \t\n         //\tfor(int i=0;i<n;i++)cout<<po[i]<<endl;\n    \tmakeok();\n         \t\t\n    \tmakean();\n         \t\n    \tmakedp();\n    \t \n \t\t for(int i=0;i<(1<<hi);i++)if(ok[i]){\n    \t\tint cnt=0;\n    \t\tfor(int j=0;j<hi;j++)if(i&(1<<j))cnt+=po[j];\n    \t\t\n    \t\tdp2[i]=cnt;\n    \t}\n         \tint ans=-1;\n          for(int i=0;i<(1<<hi);i++)if(ok[i])if(i&1){\n          //\tcout<<bitset<5>(i)<<\" \"<<dp2[i]<<\" \"<<bitset<5>(an[i])<<endl;\n    \t\tfor(int j=0;j<hi;j++)if(i&(1<<j))dp2[i]=max(dp2[i],dp2[i-(1<<j)]);\n    \t\t\n    \t\tans=max(ans,dp2[i]+dp[an[i]]);\n    \t}\n       \n    \tcout<<ans<<endl;\n         }\n           \treturn 0;\n           }\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvector<bitset<40> > neighbor;\nvector<int> strong;\n\nvector<vector<int> > memo;\n\nint solve(int i, bitset<40> ng)\n{\n    if(i == -1)\n        return 0;\n\n    bitset<40> ng2((1<<(i+1)) - 1);\n    ng2 &= ng;\n    if(i < 22 && memo[i][ng2.to_ulong()] != -1)\n        return memo[i][ng2.to_ulong()];\n\n    int ret = solve(i-1, ng);\n    if(!ng[i])\n        ret = max(ret, solve(i-1, ng |= neighbor[i]) + strong[i]);\n\n    if(i < 22)\n        memo[i][ng2.to_ulong()] = ret;\n\n    return ret;\n}\n\nint main()\n{\n    for(;;){\n        int n;\n        cin >> n;\n        if(n == 0)\n            return 0;\n\n        map<string, int> index;\n        vector<vector<string> > d(n);\n        strong.resize(n);\n        for(int i=n-1; i>=0; --i){\n            string s;\n            int m;\n            cin >> s >> strong[i] >> m;\n            index[s] = i;\n            d[i].resize(m);\n            for(int j=0; j<m; ++j)\n                cin >> d[i][j];\n        }\n\n        neighbor.assign(n, 0);\n        for(int i=0; i<n; ++i){\n            for(unsigned j=0; j<d[i].size(); ++j){\n                int k = index[d[i][j]];\n                neighbor[i][k] = true;\n            }\n        }\n\n        memo.resize(22);\n        for(int i=0; i<22; ++i)\n            memo[i].assign(1<<(i+1), -1);\n\n        cout << (solve(n-2, neighbor[n-1]) + strong[n-1]) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nconst int BIT = 1<<21;\nint N;\nmap<string,int> id;\nint B[MAXN];\nbool vis[MAXN];\nGraph g;\nint S[BIT], T[BIT];\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\nvoid addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    int b = N/2;\n    int a = N - b;\n    vector<pair<int,int> > esS, esT, esU;\n    for(int v = 0; v < N; ++v) {\n      for(int j = 0; j < g[v].size(); ++j) {\n        int nv = g[v][j];\n        if(v < a && nv < a && v < nv) esS.push_back(make_pair(v, nv));\n        if(v >= a && nv >= a && v < nv) esT.push_back(make_pair(v, nv));\n        if(v < a && nv >= a) esU.push_back(make_pair(v, nv));\n      }\n    }\n\n    for(int j = 0; j < (1<<a); ++j) {\n      vector<int> used(N);\n      S[j] = 0;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n        if(used[v]) S[j] += B[v];\n      }\n      for(int i = 0; i < esS.size(); ++i) {\n        int p = esS[i].first;\n        int q = esS[i].second;\n        if(used[p] && used[q]) {\n          S[j] = -1;\n          break;\n        }\n      }\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      vector<int> used(N);\n      T[j] = 0;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v >= a && (j & (1<<(v-a)));\n        if(used[v]) T[j] += B[v];\n      }\n      for(int i = 0; i < esT.size(); ++i) {\n        int p = esT[i].first;\n        int q = esT[i].second;\n        if(used[p] && used[q]) {\n          T[j] = -1;\n          break;\n        }\n      }\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      for(int k = 0; k < b; ++k) {\n        if(j & (1<<k)) continue;\n        T[j|(1<<k)] = max(T[j|(1<<k)], T[j]);\n      }\n    }\n\n    int res = 0;\n    for(int j = 0; j < (1<<a); ++j) {\n      if(S[j] == -1) continue;\n      if(!(j & 1)) continue;\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n      }\n      int bit = (1<<b)-1;\n      for(int i = 0; i < esU.size(); ++i) {\n        int p = esU[i].first;\n        int q = esU[i].second;\n        if(used[p]) {\n          bit &= ~(1<<(q-a));\n        }\n      }\n      res = max(res, S[j] + T[bit]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <vector>\n#include <algorithm>\n#include <set>\n#include <queue>\n#include <map>\n#include <climits>\n#include <complex>\n#include <numeric>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define RREP(i,n) for(int i=(int)n-1; i>=0; i--)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define RFOR(i,c) for(__typeof((c).rbegin())i=(c).rbegin();i!=(c).rend();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef pair<int, pair<int, int> > pipii;\ntypedef vector<int> vi;\n\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\n\ntypedef struct c{\n    int id;\n    vector<string> nes;\n    string name;\n    int power;\n    ll ne;\n} country;\n\ntypedef pair<int, pair<int, ll> > data;\n\nint calc(vector<country> &cs){\n    int n = cs.size();\n    int res = 0;\n    ll ne = cs[0].ne;\n    int power = cs[0].power;\n    REP(i, n){\n        if(ne & (1LL<<i) != 0) continue;\n        if(((ne | cs[i].ne) ^ (ne | (1<<i))) < 1LL){\n            ne |= cs[i].ne;\n            power += cs[i].power;\n        }\n    }\n\n    queue<data> pq;\n\n    pq.push(data(0, pair<int, ll>(power, ne)));\n\n    while(!pq.empty()){\n        ne = pq.front().second.second;\n        power = pq.front().second.first;\n        int v = pq.front().first + 1;\n        pq.pop();\n        res = max(res, power);\n        if(v > n - 1) continue;\n        while(((ne & (1LL << v)) != 0LL) && v < n) v++;\n        if(v == n) continue;\n        \n        \n        ll nne = ne;\n        int npower = power;\n        for(int i = v + 1; i < n; i++){\n            if((nne & (1LL<<i)) != 0) continue;\n            if(((nne | cs[i].ne) ^ (nne | (1<<i))) < (1LL<<(v + 1))){\n                nne |= cs[i].ne;\n                npower += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(npower, nne)));\n        \n        \n        ne |= cs[v].ne;\n        power += cs[v].power;\n        for(int i = v + 1; i < n; i++){\n            if(ne & (1LL<<i) != 0) continue;\n            if(((ne | cs[i].ne) ^ (ne | (1LL<<i))) < (1LL<<(v + 1))){\n                ne |= cs[i].ne;\n                power += cs[i].power;\n            }\n        }\n        pq.push(data(v, pair<int, ll>(power, ne)));\n    }\n    return res;\n}\n\nint main(void){\n    int n;\n    while(cin >> n, n){\n        vector<country> cs(n);\n        map<string, int> cnames;\n        REP(i, n){\n            int c;\n            cs[i].id = i;\n            cin >> cs[i].name >> cs[i].power;\n            cnames[cs[i].name] = i;\n            cs[i].ne = 0LL;\n            cin >> c;\n            REP(j, c){\n                string s;\n                cin >> s;\n                cs[i].nes.push_back(s);\n            }\n        }\n        REP(i, n){\n            cs[i].ne |= (1LL<<i);\n            REP(j, cs[i].nes.size()){\n                int k = cnames[cs[i].nes[j]];\n                cs[i].ne |= (1LL<<k);    \n            }\n        }\n        cout << calc(cs) << endl;         \n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nconst int BIT = 1<<21;\nint N;\nmap<string,int> id;\nint B[MAXN];\nbool vis[MAXN];\nGraph g;\nint S[BIT], T[BIT];\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\nvoid addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n    int b = N/2;\n    int a = N - b;\n    for(int j = 0; j < (1<<a); ++j) {\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n      }\n      try {\n        S[j] = 0;\n        for(int v = 0; v < N; ++v) {\n          if(used[v]) {\n            for(int k = 0; k < g[v].size(); ++k) {\n              int nv = g[v][k];\n              if(used[nv]) {\n                S[j] = -1;\n                throw 0;\n              }\n            }\n            S[j] += B[v];\n          }\n        }\n      } catch(...) {}\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v >= a && (j & (1<<(v-a)));\n      }\n      try {\n        T[j] = 0;\n        for(int v = 0; v < N; ++v) {\n          if(used[v]) {\n            for(int k = 0; k < g[v].size(); ++k) {\n              int nv = g[v][k];\n              if(used[nv]) {\n                T[j] = -1;\n                throw 0;\n              }\n            }\n            T[j] += B[v];\n          }\n        }\n      } catch(...) {}\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      for(int k = 0; k < b; ++k) {\n        if(j & (1<<k)) continue;\n        T[j|(1<<k)] = max(T[j|(1<<k)], T[j]);\n      }\n    }\n\n    int res = 0;\n    for(int j = 0; j < (1<<a); ++j) {\n      if(S[j] == -1) continue;\n      if(!(j & 1)) continue;\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n      }\n      int bit = (1<<b)-1;\n      for(int v = 0; v < N; ++v) {\n        if(used[v]) {\n          for(int k = 0; k < g[v].size(); ++k) {\n            int nv = g[v][k];\n            if(nv >= a) bit &= ~(1<<(nv-a));\n          }\n        }\n      }\n      res = max(res, S[j] + T[bit]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ninline ll gcd(ll a, ll b) { return b ? gcd(b, a%b) : a; }\ninline ll lcm(ll a, ll b) { return a / gcd(a, b)*b; }\n\nll ans = 0;\nint N;\nvector<int> B;\nvector<ll> masks;\nvector<vector<int>> G;\n\nvoid rec(int n,ll mask,ll cost,vector<ll>& sum){\n    if(n == N){\n        ans = max(ans,cost);\n        return;\n    }\n    for(int i = n; i < N;i++){\n        if(cost+sum[i] <= ans) break;\n        if((mask>>i)&1) continue;\n        rec(i+1,mask | masks[i],cost+B[i],sum);\n    }\n    rec(N,mask,cost,sum);\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    while(cin >> N,N){\n        ans = 0;\n        map<string,int> A2idx;\n        vector<string> A(N);\n        B = vector<int>(N);\n        vector<vector<string>> D(N);\n        for(int i = 0; i < N;i++){\n            cin >> A[i] >> B[i];\n            A2idx[A[i]] = i;\n            int C; cin >> C;\n            for(int j = 0; j < C;j++){\n                string S; cin >> S;\n                D[i].push_back(S);\n            }\n        }\n        \n        G =  vector<vector<int>>(N);\n        for(int i = 0; i < N;i++){\n            for(auto S:D[i]){\n                G[i].push_back(A2idx[S]);\n            }\n        }\n        \n//        for(int i = 0; i < N;i++){\n//            cout << i << \" : \"; for(auto v:G[i]) cout << v << \" \"; cout << endl;\n//        }\n        \n        \n        masks = vector<ll>(N);\n        for(int i = 0; i < N;i++){\n            masks[i] |= (1LL<<i);\n            for(auto v:G[i]){\n                masks[i] |= (1LL<<v);\n            }\n        }\n        \n        \n        vector<ll> sum(N);\n        for(int i = 0; i < N;i++){\n            for(int j = i; j < N;j++){\n                sum[i] += B[j];\n            }\n        }\n        \n        rec(1,masks[0],B[0],sum);\n        cout << ans << endl;\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2403\n\n#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\nusing namespace std;\n\nmap <string, int> M;\nint Bs[40];\nvector<string> Dstemp[40];\nlong long Ds[40];\nint N;\nmap <long long, int> C[40];\n\nvoid init() {\n  M.clear();\n  fill(Bs, Bs+40, 0);\n  for (auto i=0; i<40; i++) {\n    Dstemp[i].clear();\n    C[i].clear();\n  }\n  fill(Ds, Ds+40, 0);\n}\n\nint DFS(long long saiyo, int x) {\n  if (x == N) {\n    int ans = 0;\n    for (auto i=0; i<N; i++) {\n      if (saiyo & ((long long)1 << i)) {\n\tans += Bs[i];\n      }\n    }\n    return ans;\n  }\n  long long rinsetsu = 0;\n  for (auto i=0; i<N; i++) {\n    if (saiyo >> i & 1) {\n      rinsetsu = rinsetsu | Ds[i];\n    }\n  }\n  long long nowrin = rinsetsu;\n  /* cerr << \"saiyo = \" << saiyo << \", x = \" << x \n       << \", rinsetsu = \" << rinsetsu\n       << \", N = \" << N\n       << \", notrin = \" << ((~nowrin) & (((long long)1 << N) - 1)) << endl; */\n  for (auto i=x; i<N; i++) {\n    rinsetsu = rinsetsu | Ds[i];\n  }\n  long long kyokudai = (~rinsetsu & (((long long)1 << N) - 1)) | saiyo;\n  if (saiyo != kyokudai) {\n    return DFS(kyokudai, x);\n  }\n  int ans;\n  if (C[x].find(saiyo) != C[x].end()) {\n    return C[x][saiyo];\n  }\n  if ( ((~nowrin) & (((long long)1 << N) - 1)) >> x & 1) {\n    ans = max(DFS(saiyo | ((long long)1 << x), x+1), DFS(saiyo, x+1));\n  } else {\n    ans = DFS(saiyo, x+1);\n  }\n  C[x][saiyo] = ans;\n  return ans;\n}\n\nint main() {\n  while(cin >> N && N) {\n    init();\n    for (auto i=0; i<N; i++) {\n      string A;\n      int C;\n      cin >> A >> Bs[i] >> C;\n      M[A] = i;\n      for (auto j=0; j<C; j++) {\n\tstring D;\n\tcin >> D;\n\tDstemp[i].push_back(D);\n      }\n    }\n    for (auto i=0; i<N; i++) {\n      for (auto j=0; j<Dstemp[i].size(); j++) {\n\tDs[i] += (1 << M[Dstemp[i][j]]);\n      }\n      // cerr << \"Ds[\" << i << \"] = \" << Ds[i] << endl;\n    }\n    cout << DFS(1, 1) << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\n\nint N;\nvector<vector<int> > L;\nvector<int> power;\nvector<bool> ok;\nint ans;\nvector<int> total;\n\nvoid calc(int now,int sum){\n\tans=max(ans,sum);\n\tif(sum+total[now]<=ans)return;\n\tif(now>=N) return;\n\tif(!ok[now]){calc(now+1,sum);return;}\n\n\tbool can_cut=true;\n\n\tfor(int i=0;i<L[now].size();i++){//枝狩れるかチェック!\n\t\tif(ok[L[now][i]]){can_cut=false;break;}\n\t}\n\n\tvector<int> memo;\n\tfor(int i=0;i<L[now].size();i++){\n\t\tif(ok[L[now][i]]=true){memo.push_back(L[now][i]);ok[L[now][i]]=false;}\n\t}\n\n//\tcout<<\"put \"<<now<<\" \"<<sum+power[now]<<endl;\n\tcalc(now+1,sum+power[now]);\n\n\tfor(int i=0;i<memo.size();i++)\n\t\tok[memo[i]]=true;\n\n\tif(!can_cut) calc(now+1,sum);//枝刈り\n}\n\nint main()\n{\n\twhile(cin>>N && N!=0){\n\t\tans=0;\n\t\tint c=0;\n\t\tmap<string,int> Idx;\n\t\tL.clear();L.resize(N,vector<int>());\n\t\tok.clear();ok.resize(N,true);\n\t\tpower.clear(); power.resize(N,0);\n//\t\tvector<vector<string> > memo(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring nation;\n\t\t\tcin>>nation;\n\t\t\tif(!Idx.count(nation))Idx[nation]=c++;\n\t\t\tcin>>power[Idx[nation]];\n\t\t\tint m=0;cin>>m;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tstring s; cin>>s;\n//\t\t\t\tmemo[i].push_back(s);\n\t\t\t\tif(!Idx.count(s))Idx[s]=c++;\n\t\t\t\tL[Idx[nation]].push_back(Idx[s]);\n\t\t\t}\n\t\t}\n\n\t\ttotal.clear();total.resize(N+1,0);\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\ttotal[i]=total[i+1]+power[i];\n\t\t}\n\n\n\t\tok[0]=false;\n\t\tans+=power[0];\n\t\tfor(int i=0;i<L[0].size();i++)\n\t\t\tok[L[0][i]]=false;\n\n\t\tcalc(0,ans);\n\t\t\n\tcout<<ans<<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<n; i++)\n#define FOR(i,a,b) for(int i=a; i<b; i++)\n\ntemplate<typename T>\nvoid fillall(T& arr, const T& value) {\n    arr = value;\n}\ntemplate<typename T,typename ARR>\nvoid fillall(ARR& arr, const T& value) {\n    for(auto& i:arr) fillall(i,value);\n}\n\nvoid FZT2(int n, int *a){\n    // REP(i,1<<n)printf(\"%d: %d\\n\",i,a[i]);\n    REP(i,n)REP(j,(1<<n)){\n        if((j&(1<<i)))a[j] = max(a[j],a[j^(1<<i)]);\n    }\n}\n\nint n;\nbool g[42][42];\nint v[42];\nchar buf[25];\nstring name[42];\nvector<string> lst[42];\n\nbool memo[1<<20];\nint dp[1<<20];\n\nint os[25];\n\nint main(){\n    while(true){\n        scanf(\"%d\",&n);\n        if(n==0)break;\n        REP(i,n){\n            fill(buf,buf+25,'\\0');scanf(\"%s\",buf);\n            name[i] = string(buf);\n            scanf(\"%d\",v+i);\n            int m;\n            scanf(\"%d\",&m);\n            lst[i].clear();\n            REP(j,m){\n                fill(buf,buf+25,'\\0');scanf(\"%s\",buf);\n                lst[i].push_back(string(buf));\n            }\n        }\n        REP(i,n)REP(j,n)g[i][j] = false;\n        REP(i,n)for(string s : lst[i]){\n            REP(j,n)if(name[j]==s){\n                g[i][j] = true;\n            }\n        }\n\n        if(n==1){\n            printf(\"%d\\n\",v[0]);\n            continue;\n        }\n        int a = n/2;\n        int b = n-a;\n        // first brute-force\n        fill(dp,dp+(1<<a),-1<<28);\n        fill(memo,memo+(1<<a),false);\n        REP(msk,(1<<a)){\n            if(!(msk&1))continue;\n            if(msk==0){\n                memo[msk] = true;\n            }else{\n                int id = 0;\n                REP(i,a)if(msk>>i&1)id=i;\n                int m2 = msk - (1<<id);\n                if(m2!=0 && !memo[m2])continue;\n                memo[msk] = true;\n                REP(i,a)if(m2>>i&1){\n                    if(g[id][i]){\n                        memo[msk] = false; break;\n                    }\n                }\n                if(!memo[msk])continue;\n            }\n            dp[msk] = 0;\n            REP(i,a)if(msk>>i&1)dp[msk] += v[i];\n        }\n        // z\n        FZT2(a,dp);\n        // second\n        REP(i,b){\n            os[i] = 0;\n            REP(j,a)if(g[j][i+a]){\n                os[i] = os[i] | (1<<j);\n            }\n        }\n        fill(memo,memo+(1<<a),false);\n        int ans = 0;\n        REP(msk,(1<<b)){\n            if(msk==0){\n                memo[msk] = true;\n            }else{\n                int id = 0;\n                REP(i,b)if(msk>>i&1)id=i;\n                int m2 = msk - (1<<id);\n                if(!memo[m2])continue;\n                memo[msk] = true;\n                REP(i,b)if(m2>>i&1){\n                    if(g[id+a][i+a]){\n                        memo[msk] = false; break;\n                    }\n                }\n                if(!memo[msk])continue;\n            }\n            int sum = 0;\n            REP(i,b)if(msk>>i&1)sum += v[i+a];\n            int omsk = 0;\n            REP(i,b)if(msk>>i&1){\n                omsk = omsk | os[i];\n            }\n            omsk = ((1<<a)-1)-omsk;\n            ans = max(ans, sum + dp[omsk]);\n        }\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "7\nINTERCAL 10 3 Chef Piet COW\nChef 7 3 INTERCAL Piet COW\nPiet 6 2 INTERCAL Chef\nCOW 7 2 INTERCAL Chef\nJ 6 1 A\nA 12 1 J\nGrass 0 0\n7\nQin 105 4 Zhao Wei Han Chu\nZhao 81 4 Qin Wei Qi Yan\nWei 70 5 Qin Zhao Han Qi Chu\nHan 45 3 Qin Wei Chu\nQi 79 4 Zhao Wei Chu Yan\nChu 102 4 Qin Wei Han Qi\nYan 53 2 Zhao Qi\n14\nMagadha 98 8 Macedonia Kalinga Surashtra Ashmaka Kantala Andhra Gangaridai Kamapura\nMacedonia 79 2 Magadha Surashtra\nKalinga 51 2 Magadha Andhra\nSurashtra 13 3 Magadha Macedonia Ashmaka\nAshmaka 11 3 Magadha Surashtra Kantala\nKantala 12 3 Magadha Ashmaka Andhra\nAndhra 14 3 Magadha Kantala Kalinga\nCholas 15 3 Cheras Pandyas Anuradhapuras\nCheras 8 2 Cholas Pandyas\nPandyas 10 3 Cholas Cheras Anuradhapuras\nAnuradhapuras 7 2 Cholas Pandyas\nGangaridai 20 3 Magadha Kamapura Arakan\nKamapura 18 2 Magadha Gangaridai\nArakan 7 1 Gangaridai\n0\n"
  },
  {
    "language": "C++",
    "code": "v"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <map>\nusing namespace std;\n\nmap<string,int> dictionary;\n\nint dic(string name){\n\tif( dictionary.count(name) ) return dictionary[name];\n\telse{\n\t\tint t = dictionary.size();\n\t\treturn dictionary[name] = t;\n\t}\n}\n\nvector<int> g[40];\nint P[40];\n\nint dmg[40]={};\nint deg[40]={};\nint cover[40] = {};\n\nvoid cCover(int x,int v){\n\tcover[x]+= v;\n\tfor(int i = 0; i < g[x].size() ; i++){\n\t\tif( cover[g[x][i]] == 0 ){\n\t\t\tdeg[g[x][i]]--;\n\t\t\tdeg[x]--;\n\t\t\tdmg[g[x][i]] -= P[x];\n\t\t\tdmg[x] -= P[g[x][i]];\n\t\t}\n\t\tcover[g[x][i]] += v;\n\t\tif( cover[g[x][i]] == 0 ){\n\t\t\tdeg[g[x][i]]++;\n\t\t\tdeg[x]++;\n\t\t\tdmg[g[x][i]] += P[x];\n\t\t\tdmg[x] += P[g[x][i]];\t\t\t\n\t\t}\n\t}\n}\n\nint n;\nint maximum = 0;\nint current = 0;\n\nint dfs(){\n\tint allsum = 0;\n\tvector< pair<int,int> > good;\n\tfor(int i = 0 ; i < n ; i++){\t\t\n\t\tif( cover[i] == 0 ){\n\t\t\tallsum += P[i];\n\t\t\tgood.push_back(make_pair(dmg[i],i));\n\t\t}\n\t}\n\t\n\tif( current+allsum <= maximum ){\n\t\treturn 0;\n\t}else{\n\t\tmaximum = max(current,maximum);\n\t}\n\tsort(good.begin(),good.end());\n\tfor(int i = 0 ; i < good.size() ; i++){\n\t\tcCover(good[i].second,1);\n\t\tcurrent += P[good[i].second];\n\t\tdfs();\n\t\tcurrent -= P[good[i].second];\n\t\tcCover(good[i].second,-1);\n\t}\n\t\n}\n\nint main(){\n\twhile(cin >> n && n){\n\t\tdictionary.clear();\n\t\tfor(int i = 0 ; i < 40 ; i++){\n\t\t\tg[i].clear();\n\t\t\tdmg[i] = 0;\n\t\t\tdeg[i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tstring name;\n\t\t\tint power,num;\n\t\t\tcin >> name >> power >> num;\n\t\t\tP[dic(name)] = power;\n\t\t\tdeg[dic(name)] = num;\n\t\t\tfor(int j = 0 ; j < num ; j++){\n\t\t\t\tstring connect;\n\t\t\t\tcin >> connect;\n\t\t\t\tg[dic(name)].push_back(dic(connect));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < n ; i++){\n\t\t\tfor(int j = 0 ; j < g[i].size() ; j++){\n\t\t\t\tdmg[i] += P[g[i][j]];\n\t\t\t}\n\t\t}\n\t\t\n\t\tmaximum = 0;\n\t\tcurrent = P[0];\n\t\t\n\t\tcCover(0,1);\n\t\tdfs();\n\t\tcCover(0,-1);\n\t\t\n\n\t\t\n\t\tcout << maximum << endl;\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef long long lli;\ntypedef vector<vector<int> > Graph;\n\nconst int MAXN = 50;\n\nint N;\nmap<string,int> id;\nGraph g;\nint B[MAXN];\n\nlli adj[MAXN];\nint sum[MAXN];\nint ans;\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\ninline void addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nvoid rec(int k, lli bit, int now) {\n  ans = max(ans, now);\n  if(now + sum[k] <= ans) return;\n  if(k == N) return;\n  rec(k+1, bit, now);\n  if(!(bit & (1LL<<k))) rec(k+1, bit|adj[k], now+B[k]);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    for(int v = 0; v < N; ++v) {\n      adj[v] = 0;//1LL<<v;\n      for(int i = 0; i < g[v].size(); ++i) {\n        int nv = g[v][i];\n        adj[v] |= 1LL<<nv;\n      }\n    }\n\n    sum[N] = 0;\n    for(int v = N-1; v >= 0; --v) sum[v] = sum[v+1] + B[v];\n\n    ans = 0;\n    rec(1, adj[0], B[0]);\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\n\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    vector<int> dp0(1<<half);\n    vector<int> vs0(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=0;i<(1<<half);i++){\n        int vs=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                dp0[i]+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) dp0[i]=-INF;\n        }\n    }\n\n    vector<int> dp1(1<<rest);\n    vector<int> vs1(rest,0);\n    for(int i=0;i<rest;i++){\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                dp1[i]+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) dp1[i]=-INF;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        if(__builtin_popcount(i)==1){\n            int j=__builtin_ctz(i);\n            for(int k=0;k<g[j].size();k++){\n                if(g[j][k]>=half){\n                    opn[i]=opn[i]&(~(1<<(g[j][k]-half)));\n                }\n            }\n        }\n        for(int j=0;j<half;j++){\n            opn[i|(1<<j)]&=opn[i];\n        }\n        res=max(res,dp0[i]+dp1[opn[i]]);\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\n\nint N;\nvector<vector<int> > L;\nvector<int> power;\nvector<bool> ok;\nint ans;\n\nvoid calc(int now,int sum){\n\tans=max(ans,sum);\n\tif(now>=N) return;\n\tif(!ok[now]){calc(now+1,sum);return;}\n\n\tbool can_cut=true;\n\n\tfor(int i=0;i<L[now].size();i++){//枝狩れるかチェック!\n\t\tif(ok[L[now][i]]){can_cut=false;break;}\n\t}\n\n\tvector<int> memo;\n\tfor(int i=0;i<L[now].size();i++){\n\t\tif(ok[L[now][i]]=true){memo.push_back(L[now][i]);ok[L[now][i]]=false;}\n\t}\n//\tcout<<\"put \"<<now<<\" \"<<sum+power[now]<<endl;\n\tcalc(now+1,sum+power[now]);\n\n\tfor(int i=0;i<memo.size();i++)\n\t\tok[memo[i]]=true;\n\n\tif(!can_cut) calc(now+1,sum);//枝刈り\n}\n\nint main()\n{\n\twhile(cin>>N && N!=0){\n\t\tans=0;\n\t\tint c=0;\n\t\tmap<string,int> Idx;\n\t\tL.clear();L.resize(N,vector<int>());\n\t\tok.clear();ok.resize(N,true);\n\t\tpower.clear(); power.resize(N,0);\n//\t\tvector<vector<string> > memo(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring nation;\n\t\t\tcin>>nation;\n\t\t\tif(!Idx.count(nation))Idx[nation]=c++;\n\t\t\tcin>>power[Idx[nation]];\n\t\t\tint m=0;cin>>m;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tstring s; cin>>s;\n//\t\t\t\tmemo[i].push_back(s);\n\t\t\t\tif(!Idx.count(s))Idx[s]=c++;\n\t\t\t\tL[Idx[nation]].push_back(Idx[s]);\n\t\t\t}\n\t\t}\n\n\t\tok[0]=false;\n\t\tans+=power[0];\n\t\tfor(int i=0;i<L[0].size();i++)\n\t\t\tok[L[0][i]]=false;\n\n\t\tcalc(0,ans);\n\t\t\n\tcout<<ans<<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int64;\n\nint N, V[45];\nbool G[45][45];\nint NG[45];\nint sum[45];\nint beet;\n\nvoid dfs(int64 idx, int64 bit, int fake)\n{\n  beet = max(beet, fake);\n  if(idx == N) return;\n  if(fake + sum[fake] < beet) return;\n  dfs(idx + 1, bit, fake);\n  if((NG[idx] & bit) == 0) dfs(idx + 1, bit | (1LL << idx), fake + V[idx]);\n}\n\nint main()\n{\n  while(cin >> N, N) {\n    memset(G, false, sizeof(G));\n    map< string, int > conv;\n\n    vector< vector< string > > gg(N);\n    for(int i = 0; i < N; i++) {\n      string A;\n      cin >> A;\n      conv[A] = i;\n      int sz;\n      cin >> V[i];\n      cin >> sz;\n      for(int j = 0; j < sz; j++) {\n        string D;\n        cin >> D;\n        gg[i].push_back(D);\n      }\n    }\n    for(int i = 0; i < N; i++) {\n      for(auto &s : gg[i]) {\n        G[i][conv[s]] = true;\n      }\n    }\n\n    memset(sum, 0, sizeof(sum));\n    for(int i = N - 1; i >= 0; i--) {\n      sum[i] = sum[i + 1] + V[i + 1];\n    }\n\n    for(int i = 0; i < N; i++) {\n      NG[i] = 0;\n      for(int j = 0; j < N; j++) {\n        if(G[i][j]) NG[i] |= 1LL << j;\n      }\n    }\n    beet = 0;\n    dfs(1, 1, V[0]);\n    cout << beet << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <stack>\nusing namespace std;\nvector<long long int> G;\nvector<int> B;\nint N;\n\nint solve(int v, long long int t){\n  if(v >= B.size() || t == (1LL<<N) - 1LL) return 0;\n  int ret = 0;\n  if(!(t>>v & 1)){\n    long long t_ = t | (1LL<<v);\n    t_ |= G[v];\n    int v_ = v + 1;\n    while(t_>>v_ & 1) ++v_;\n    ret = B[v] + solve(v_,t_);\n    if(t_ == (t|1LL<<v)) return ret;\n  }\n  int v_ = v + 1;\n  while(t>>v_ & 1) ++v_;\n  t |= 1LL<<v;\n  ret = max(ret, solve(v_,t));\n  return ret;\n}\n\nint main(){\n  while(cin >> N, N){\n    map<string,int> M;\n    vector< vector<string> > D(N);\n    string a;\n    B = vector<int>(N);\n    int c;\n    for(int i = 0; i < N; ++i){\n      cin >> a >> B[i] >> c;\n      M[a] = i;\n      string d;\n      for(int j = 0; j < c; ++j){\n        cin >> d;\n        D[i].push_back(d);\n      }\n    }\n    G = vector<long long int>(N,0LL);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < D[i].size(); ++j){\n        G[i] |= 1LL<<M[D[i][j]];\n      }\n    }\n    long long int t = 1LL;\n    t |= G[0];\n    cout << B[0] + solve(1,t) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing VI = vector<int>;\nusing VVI = vector<VI>;\nusing PII = pair<int, int>;\nusing LL = long long;\nusing VL = vector<LL>;\nusing VVL = vector<VL>;\nusing PLL = pair<LL, LL>;\nusing VS = vector<string>;\n\n#define ALL(a)  begin((a)),end((a))\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define EB emplace_back\n#define MP make_pair\n#define SZ(a) int((a).size())\n#define SORT(c) sort(ALL((c)))\n#define RSORT(c) sort(RALL((c)))\n#define UNIQ(c) (c).erase(unique(ALL((c))), end((c)))\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n#define FF first\n#define SS second\ntemplate<class S, class T>\nistream& operator>>(istream& is, pair<S,T>& p){\n  return is >> p.FF >> p.SS;\n}\ntemplate<class S, class T>\nostream& operator<<(ostream& os, const pair<S,T>& p){\n  return os << p.FF << \" \" << p.SS;\n}\ntemplate<class T>\nvoid maxi(T& x, T y){\n  if(x < y) x = y;\n}\ntemplate<class T>\nvoid mini(T& x, T y){\n  if(x > y) x = y;\n}\n\n\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst LL MOD = 1e9+7;\n\nint main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n\n  int N;\n  while(cin >> N,N){\n\tmap<string,int> country;\n\tvector<vector<string>> adj(N);\n\tVI bs(N);\n\tREP(i,N){\n\t  string s;\n\t  cin >> s;\n\t  country[s] = i;\n\t  cin >> bs[i];\n\t  int C; cin >> C;\n\t  REP(j,C){\n\t\tcin >> s;\n\t\tadj[i].EB(s);\n\t  }\n\t}\n\n\tVVI G(N);\n\tREP(i,N){\n\t  for(auto& s: adj[i])\n\t\tG[i].PB(country[s]);\n\t}\n\tVL ban(N);\n\tREP(i,N){\n\t  for(int to: G[i])\n\t\tban[i] = ban[i] | (1<<to);\n\t}\n\n\tint N2 = N / 2;\n\tint NR = N - N2;\n\tVI dp(1<<NR);\n\tREP(i,1<<NR){\n\t  int sum = 0;\n\t  LL x = (LL)(i) << N2;\n\t  REP(j,NR)\n\t\tif(i>>j&1){\n\t\t  sum += bs[j+N2];\n\t\t  if((ban[j+N2] & x) != 0){\n\t\t\tsum = -1e9;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t  if(sum >= 0)\n\t\tdp[((1<<NR)-1)^i] = sum;\n\t}\n\t\n\tfor(int i=0;i<NR;++i){\n\t  for(int b=0;b<(1<<NR);++b){\n\t\tif((b>>i&1) == 0)\n\t\t  maxi(dp[b], dp[b|(1<<i)]);\n\t  }\n\t}\n\t//REP(i,1<<N2) cout << bitset<4>(i) << \": \" << dp[i] << endl;\n\tint ans = 0;\n\tfor(int b=1;b<1<<N2;b+=2){\n\t  int sum = 0;\n\t  LL x = b;\n\t  LL b2 = 0;\n\t  REP(j,N2)\n\t\tif(b>>j&1){\n\t\t  b2 = b2 | ban[j];\n\t\t  sum += bs[j];\n\t\t  if((ban[j] & x) != 0){\n\t\t\tsum = -1e9;\n\t\t\tbreak;\n\t\t  }\n\t\t}\n\t  if(sum < 0) continue;\n\t  b2 = b2 >> N2;\n\t  ans = max(ans, sum + dp[b2]);\n\t}\n\tcout << ans << endl;\n  }\n \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<iomanip>\n#include<queue>\n#include<vector>\n#include<complex>\n#include<map>\n#include<set>\nusing namespace std;\n#define int long long\n\nvector<vector<int> > g;\nvector<int> A;\nmap<int, int> dp;\nint N;\nint rec(int a) {\n\tif (dp.count(a) != 0) {\n\t\treturn dp[a];\n\t}\n\tint res = 0;\n\tfor (int i = 0; i < N; i++) {\n\t\tif ((int)g[i].size() != 0) {\n\t\t\tif ((a & ((int)1 << i)) == 0) {\n\t\t\t\tint b = a | ((int)1 << i);\n\t\t\t\tfor (auto j : g[i]) {\n\t\t\t\t\tb |= ((int)1 << j);\n\t\t\t\t}\n\t\t\t\tres = max(res, rec(b) + A[i]);\n\t\t\t}\n\t\t}\n\t}\n\treturn (dp[a] = res);\n}\nsigned main() {\n\twhile (true) {\n\n\t\tcin >> N;\n\t\tif (N == 0)break;\n\t\tint t = 0;\n\t\tg.clear();\n\t\tg.resize(N);\n\t\tA.clear();\n\t\tA.resize(N);\n\t\tint a0 = 0;\n\t\tmap<string, int> mp;\n\t\tset<string> st;\n\t\tstring S;\n\t\tcin >> S >> a0;\n\t\tst.insert(S);\n\t\tint c;\n\t\tcin >> c;\n\t\tfor (int j = 0; j < c; j++) {\n\t\t\tcin >> S;\n\t\t\tst.insert(S);\n\t\t}\n\n\t\tfor (int i = 1; i < N; i++) {\n\t\t\tstring S;\n\t\t\tcin >> S;\n\t\t\tif (st.count(S) != 0) {\n\t\t\t\tint c;\n\t\t\t\tcin >> c >> c;\n\t\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\t\tcin >> S;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (mp.count(S) == 0) {\n\t\t\t\tmp[S] = t;\n\t\t\t\tt++;\n\t\t\t}\n\t\t\tint k = mp[S];\n\t\t\tcin >> A[k];\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tfor (int j = 0; j < c; j++) {\n\t\t\t\tcin >> S;\n\t\t\t\tif (st.count(S) != 0) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (mp.count(S) == 0) {\n\t\t\t\t\tmp[S] = t;\n\t\t\t\t\tt++;\n\t\t\t\t}\n\t\t\t\tg[k].push_back(mp[S]);\n\t\t\t}\n\t\t}\n\t\t//cerr << a0 << endl;\n\t\t//cerr << t << endl;\n\t\t/*for (auto m : mp) {\n\t\t\tcerr << m.first << \" \" << m.second << \" \" << A[m.second] << endl;\n\t\t}*/\n\t\tN = t;\n\t\tint res = a0;\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tif ((int)g[i].size() == 0) {\n\t\t\t\tres += A[i];\n\t\t\t}\n\t\t}\n\t\t//cerr << res << endl;\n\t\tdp.clear();\n\t\tres += rec(0);\n\t\tcout << res << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <iostream>\n#include <utility>\n#include <algorithm>\n#include <string>\n#include <deque>\n#include <tuple>\n#include <queue>\n#include <functional>\n#include <cmath>\n#include <iomanip>\n#include <map>\n#include <numeric>\n#include <unordered_map>\n#include <unordered_set>\n//cin.sync_with_stdio(false);\n//streambuf\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nusing vi = vector<int>;\nusing vpii = vector<pii>;\ntemplate<class T, class T2> using umap = unordered_map<T, T2>;\ntemplate<class T> using uset = unordered_set<T>;\n#define ALL(a) a.begin(),a.end()\n#define rep(i,a) for(int i=0;i<a;i++)\n#define rep1(i,a) for(int i=1;i<=a;i++)\numap<string, vector<string>> buf;\numap<string, bool> used;\nvector<pair<string,int>> names;\numap<string, int> bmap;\nint ans;\nvoid dfs(int pos, int b,int rest) {\n\tans = max(ans, b);\n\tif (pos == names.size()) {\n\t\treturn;\n\t}\n\tif (ans >= b + rest)return;\n\tfor (; pos < names.size(); pos++) {\n\t\trest -= names[pos].second;\n\t\tif (used[names[pos].first])continue;\n\t\tvector<string> c;\n\t\t//int rest1 = rest;\n\t\tfor (auto &a : buf[names[pos].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tc.push_back(a);\n\t\t\t\tused[a] = 1;\n\t\t\t\t//rest -= bmap[a];\n\t\t\t}\n\t\t}\n\t\tdfs(pos + 1, b + names[pos].second,rest);\n\t\tfor (auto &a : c) {\n\t\t\tused[a] = 0;\n\t\t}\n\t\t//rest = rest1;\n\t}\n}\nint main() {\n\tint n;\n\tint mb = 0;\n\twhile (cin>>n,n) {\n\t\tbuf.clear();\n\t\tused.clear();\n\t\tnames.clear();\n\t\tbmap.clear();\n\t\tans = 0;\n\t\tmb = 0;\n\t\trep(i,n) {\n\t\t\tint k,b;\n\t\t\tstring name;\n\t\t\t//vector<string> list;\n\t\t\tcin >> name >> b >> k;\n\t\t\trep(j, k) {\n\t\t\t\tstring a;\n\t\t\t\tcin >> a;\n\t\t\t\t//list.push_back(a);\n\t\t\t\tbuf[name].push_back(a);\n\t\t\t\tbuf[a].push_back(name);\n\t\t\t}\n\t\t\tmb += b;\n\t\t\tused.insert(make_pair(name, 0));\n\t\t\tnames.push_back(make_pair(name,b));\n\t\t\tbmap.insert(make_pair(name, b));\n\t\t}\n\t\tfor (auto &a : buf[names[0].first]) {\n\t\t\tif (!used[a]) {\n\t\t\t\tused[a] = 1;\n\t\t\t}\n\t\t}\n\t\tdfs(1, names[0].second,mb-names[0].second);\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nusing Edges=vector<int>;\nusing Graph=vector<Edges>;\n\nint solve(Graph& g,vector<int>& b){\n    int n=g.size();\n    if(n==1){\n        return b[0];\n    }\n    int half=n/2;\n    int rest=n-half;\n    const int INF=1e6;\n    vector<int> dp0(1<<half);\n    vector<int> vs0(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]<half) vs0[i]|=(1<<g[i][j]);\n        }\n    }\n    for(int i=0;i<(1<<half);i++){\n        int vs=0;\n        for(int j=0;j<half;j++){\n            if((1<<j)&i){\n                dp0[i]+=b[j];\n                vs|=vs0[j];\n            }\n            if(vs&i) dp0[i]=-INF;\n        }\n    }\n\n    vector<int> dp1(1<<rest);\n    vector<int> vs1(rest,0);\n    for(int i=0;i<rest;i++){\n        for(int j=0;j<g[i+half].size();j++){\n            if(g[i+half][j]>=half) vs1[i]|=(1<<(g[i+half][j]-half));\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        bool isok=true;\n        int vs=0;\n        for(int j=0;j<rest;j++){\n            if((1<<j)&i){\n                dp1[i]+=b[j+half];\n                vs|=vs1[j];\n            }\n            if(i&vs) dp1[i]=-INF;\n        }\n    }\n    for(int i=0;i<(1<<rest);i++){\n        for(int j=0;j<rest;j++){\n            dp1[i|(1<<j)]=max(dp1[i|(1<<j)],dp1[i]); \n        }\n    }\n\n    vector<int> vs01(half,0);\n    for(int i=0;i<half;i++){\n        for(int j=0;j<g[i].size();j++){\n            if(g[i][j]>=half) vs01[i]|=(1<<(g[i][j]-half));\n        }\n    }\n    int res=0;\n    vector<int> opn(1<<half,(1<<rest)-1);\n    for(int i=1;i<(1<<half);i+=2){\n        int opn=(1<<rest)-1;\n        for(int j=0;j<half;j++){\n            if(i&(1<<j)) opn&=~vs01[j];\n        }\n        res=max(res,dp0[i]+dp1[opn]);\n    }\n    return res;\n}\n\nint main(){\n    ios_base::sync_with_stdio(false);\n    int n;\n    while(cin>>n,n){\n        vector<string> a(n);\n        vector<int> b(n);\n        vector<int> c(n);\n        vector<vector<string>> d(n);\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            d[i].assign(c[i],\"\");\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n\n        map<string,int> dic;\n        for(int i=0;i<n;i++) dic[a[i]]=i;\n        Graph g(n);\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                int v=dic[d[i][j]];\n                g[i].push_back(v);\n            }\n        }\n        cout<<solve(g,b)<<\"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n \n#include <string>\n#include <map>\n#include <algorithm>\n#include <cassert>\n#include <cstdio>\n \nusing namespace std;\n#define N 40\n#define TEST 0\n \n \n    string a[N];\n    int b[N],c[N];\n    string d[N][N];\n    int edges[N][N];\n    int n;\n \ntypedef long long i64;\nint maxv;\ni64 maxi;\n \ni64 edg[N];\n \nvoid rec(i64 bits,int sum){\n    if(sum<=maxv){\n        return;\n    }\n    if((bits&1LL)==0LL)return;\n    bool clique=true;\n    int minind=100000;\n    int mini=-1;\n    for(int i=0;i<n;i++){\n        if((bits&(1LL<<i))==0)continue;\n        int ind=0;\n\ti64 is=bits&edg[i];\n        for(int j=0;j<n;j++){\n            if((is&(1LL<<j)))\n                ind+=1;\n        }\n\tif(bits!=(is|(1LL<<i)))\n\t\tclique=false;\n        if(minind>ind){\n            mini=i;\n            minind=ind;\n        }\n    }\n    if(mini==-1)assert(!\"error mini==-1\");\n    int sub1=b[mini];\n    i64 set1=1LL<<mini;\n    set1|=bits&edg[mini];\n    for(int i=0;i<n;i++){\n        if((set1&(1LL<<i))==0)continue;\n        if(i==mini)continue;\n        if(set1&(1LL<<i)){\n            sub1+=b[i];\n        }\n    }\n    if(!clique){\n        rec(set1,sub1);\n        rec(bits&~(1LL<<mini),sum-b[mini]);\n        return;\n    }\n    //clique\n    if(maxv<sub1){\n        maxv=max(maxv,sub1);\n        maxi=bits;\n    }\n}\n \n \n \nint main(void){\n    int di[N][N];\n    while(1){\n        cin>>n;\n        if(TEST)cerr<<\"n=\"<<n<<endl;\n        if(n==0)break;\n        map<string,int> m;\n        for(int i=0;i<n;i++){\n            cin>>a[i]>>b[i]>>c[i];\n            for(int j=0;j<c[i];j++){\n                cin>>d[i][j];\n            }\n        }\n        int cnt=0;\n        for(int i=0;i<n;i++){\n            m.insert(pair<string,int>(a[i],i));\n        }\n        for(int i=0;i<n;i++){\n            fill_n(edges[i],n,1);\n            edges[i][i]=0;\n        }\n        for(int i=0;i<n;i++){\n            for(int j=0;j<c[i];j++){\n                di[i][j]=m[d[i][j]];\n                edges[i][di[i][j]]=0;\n            }\n\t    i64 s=0;\n\t    for(int j=0;j<n;j++){\n\t\ts|=edges[i][j]?1LL<<j:0;\n\t    }\n\t    edg[i]=s;\n        }\n        if(TEST){\n            for(int i=0;i<n;i++){\n                for(int  j=0;j<n;j++){\n                    cerr<<edges[i][j]<<\" \";\n                }\n                cout<<\":\"<<b[i]<<endl;\n            }\n        }\n        maxv=0;\n        int sum=0;\n        for(int i=0;i<n;i++){\n            sum+=b[i];\n        }\n        rec((1LL<<n)-1,sum);\n        cout<<maxv<<endl;\n        if(TEST){\n            fprintf(stderr,\"set=%llx\\n\",maxi);\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<string>\nusing namespace std;\n\nint N;\nvector<vector<int> > L;\nvector<int> power;\nvector<bool> ok;\nint ans;\nvector<int> total;\n\nvoid calc(int now,int sum){\n\tans=max(ans,sum);\n//\tif(sum+total[now]<=ans)return;\n\tif(now>=N) return;\n\tif(!ok[now]){calc(now+1,sum);return;}\n\n\tbool can_cut=true;\n\n\tfor(int i=0;i<L[now].size();i++){//枝狩れるかチェック!\n\t\tif(ok[L[now][i]]){can_cut=false;break;}\n\t}\n\n\tvector<int> memo;\n\tfor(int i=0;i<L[now].size();i++){\n\t\tif(ok[L[now][i]]=true){memo.push_back(L[now][i]);ok[L[now][i]]=false;}\n\t}\n\n//\tcout<<\"put \"<<now<<\" \"<<sum+power[now]<<endl;\n\tcalc(now+1,sum+power[now]);\n\n\tfor(int i=0;i<memo.size();i++)\n\t\tok[memo[i]]=true;\n\n\tif(!can_cut) calc(now+1,sum);//枝刈り\n}\n\nint main()\n{\n\twhile(cin>>N && N!=0){\n\t\tans=0;\n\t\tint c=0;\n\t\tmap<string,int> Idx;\n\t\tL.clear();L.resize(N,vector<int>());\n\t\tok.clear();ok.resize(N,true);\n\t\tpower.clear(); power.resize(N,0);\n//\t\tvector<vector<string> > memo(N);\n\t\tfor(int i=0;i<N;i++){\n\t\t\tstring nation;\n\t\t\tcin>>nation;\n\t\t\tif(!Idx.count(nation))Idx[nation]=c++;\n\t\t\tcin>>power[Idx[nation]];\n\t\t\tint m=0;cin>>m;\n\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\tstring s; cin>>s;\n//\t\t\t\tmemo[i].push_back(s);\n\t\t\t\tif(!Idx.count(s))Idx[s]=c++;\n\t\t\t\tL[Idx[nation]].push_back(Idx[s]);\n\t\t\t}\n\t\t}\n\n\t\ttotal.clear();total.resize(N+1,0);\n\t\tfor(int i=N-1;i>=0;i--){\n\t\t\ttotal[i]=total[i+1]+power[i];\n\t\t}\n\n\n\t\tok[0]=false;\n\t\tans+=power[0];\n\t\tfor(int i=0;i<L[0].size();i++)\n\t\t\tok[L[0][i]]=false;\n\n\t\tcalc(1,ans);\n\t\t\n\t\tcout<<ans<<endl;\n\t}\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define reps(i,j,k) for(int i=j; i<k;++i)\n#define rep(i,j) reps(i,0,j)\n#define pb emplace_back\n#define mk make_pair\n\nint n;\nvector<string> a;\nvector<int> b;\nvector<vector<string>> d;\nvector<vector<int>> g;\nvector<long long> e;\n\ntypedef long long ll;\n\nint dfs(int i, ll s) {\n\tif(i == n) {\n\t\treturn 0;\n\t}\n\n\tif((s >> i) & 1) {\n\t\treturn dfs(i + 1, s);\n\t}\n\n\tint ret = 0;\n\tll mask = (1LL << n) - 1;\n\tmask = mask - ((1LL << i) - 1);\n\t\n\tif(i != 0 && !((s & e[i] & mask) == (e[i] & mask))) {\n\t\tret = dfs(i + 1, s);\n\t}\n\n\t{\n\t\tll ns = s | e[i];\n\n\t\tret = max(ret, dfs(i + 1, ns) + b[i]);\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(n == 0) {\n\t\t\tbreak;\n\t\t}\n\n\t\ta = vector<string>(n);\n\t\tb = vector<int>(n);\n\t\td = vector<vector<string>>(n);\n\t\te = vector<long long>(n);\n\t\trep(i, n) {\n\t\t\tint c;\n\t\t\tcin >> a[i] >> b[i] >> c;\n\t\t\td[i].resize(c);\n\n\t\t\trep(j, c) {\n\t\t\t\tcin >> d[i][j];\n\t\t\t}\n\t\t}\n\n\t\tmap<string, int> m;\n\t\trep(i, n) {\n\t\t\tm.insert(make_pair(a[i], m.size()));\n\t\t}\n\n\t\tg = vector<vector<int>>(n);\n\n\t\trep(i, n) {\n\t\t\tfor(auto to : d[i]) {\n\t\t\t\tg[i].push_back(m[to]);\n\t\t\t\te[i] = e[i] | (1LL << g[i].back());\n\t\t\t}\n\t\t}\n\n\t\tcout << dfs(0, 0) << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\n\nint pw[50],N;\n\nclass UnionFind {\npublic:\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\nclass Edge\n{\npublic:\n\tint src, dst;\n\tEdge(int src, int dst)\n\t:src(src),dst(dst)\n\t{}\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nll paint[40], rest[40];\nll relt;\n\nll dfs(int p, ll used, ll score, Graph& g, vector<int>& group)\n{\t\n\tif(p==group.size()) return score;\n\tif(used >> group[p] & 1) return dfs(p+1, used, score, g, group);\n\tif(score + rest[group[p]] <= relt) return 0;\n\n\tll res = score;\n\tll tmp = used | paint[group[p]];\n\tres = max(res, dfs(p+1, tmp, score+pw[group[p]], g, group));\n\tres = max(res, dfs(p+1, used, score, g, group));\n\t\n\trelt = max(res, relt);\n\treturn res;\n}\n\nint main()\n{\n\twhile(cin >> N, N) {\n\t\tmemset(rest, 0, sizeof(rest));\n\n\t\tcerr << N << endl;\n\t\tint gcnt = 0;\n\t\tmap<string, int> dic;\n\t\tGraph graph(N);\n\t\tUnionFind uf(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tstring src;\n\t\t\tcin >> src;\n\n\t\t\tif(!dic.count(src)) dic[src] = gcnt++;\n\t\t\tint s = dic[src];\n\n\t\t\tcin >> pw[s];\n\t\n\t\t\tint M;\n\t\t\tcin >> M;\n\t\t\t\n\t\t\tfor(int i=0; i<M; i++) {\n\t\t\t\tstring dst;\n\t\t\t\tcin >> dst;\n\t\t\t\t\n\t\t\t\tif(!dic.count(dst)) dic[dst] = gcnt++;\n\t\t\t\tint t = dic[dst];\n\n\t\t\t\tgraph[s].push_back(Edge(s,t));\n\t\t\t\tuf.unionSet(s,t);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tpaint[i] = (1LL << i);\n\t\t\tfor(int j=0; j<graph[i].size(); j++) {\n\t\t\t\tpaint[i] |= (1LL << graph[i][j].dst);\n\t\t\t}\n\t\t}\n\n\t\tvector<vector<int> > groups(N);\n\n\t\tfor(int i=0; i<N; i++) {\n\t\t\tgroups[uf.root(i)].push_back(i);\n\t\t\trest[uf.root(i)] += pw[i];\n\t\t}\n\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tfor(int j=1; j<groups[i].size(); j++) {\n\t\t\t\trest[groups[i][j]] = rest[groups[i][j-1]] - pw[groups[i][j-1]];\n\t\t\t}\n\t\t} \n\n\t\tll res = pw[0];\n\t\tll init = paint[0];\n\t\tfor(int i=0; i<groups.size(); i++) {\n\t\t\tif(groups[i].size() == 0) continue;\n\t\t\trelt = 0;\n\t\t\tres += dfs(0, init, 0, graph, groups[i]);\n\t\t} \n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef vector<vector<int> > Graph;\nconst int MAXN = 50;\nconst int BIT = 1<<21;\nint N;\nmap<string,int> id;\nint B[MAXN];\nGraph g;\nint S[BIT], T[BIT];\n\ninline int getId(const string &s) {\n  if(!id.count(s)) id[s] = id.size()-1;\n  return id[s];\n}\n\nvoid addEdge(int src, int dst, Graph &g) {\n  g[src].push_back(dst);\n}\n\nint main() {\n  while(cin >> N && N) {\n    id.clear();\n    g = Graph(N);\n    for(int i = 0; i < N; ++i) {\n      string src;\n      int C;\n      cin >> src;\n      cin >> B[getId(src)] >> C;\n      while(C--) {\n        string dst;\n        cin >> dst;\n        addEdge(getId(src), getId(dst), g);\n      }\n    }\n\n    int b = N/2;\n    int a = N - b;\n    vector<pair<int,int> > esS, esT, esU;\n    for(int v = 0; v < N; ++v) {\n      for(int j = 0; j < g[v].size(); ++j) {\n        int nv = g[v][j];\n        if(v < a && nv < a && v < nv) esS.push_back(make_pair(v, nv));\n        if(v >= a && nv >= a && v < nv) esT.push_back(make_pair(v, nv));\n        if(v < a && nv >= a) esU.push_back(make_pair(v, nv));\n      }\n    }\n\n    for(int j = 0; j < (1<<a); ++j) {\n      vector<int> used(N);\n      S[j] = 0;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n        if(used[v]) S[j] += B[v];\n      }\n      for(int i = 0; i < esS.size(); ++i) {\n        int p = esS[i].first;\n        int q = esS[i].second;\n        if(used[p] && used[q]) {\n          S[j] = -1;\n          break;\n        }\n      }\n    }\n    cout << 0 << endl;\n    continue;\n    for(int j = 0; j < (1<<b); ++j) {\n      vector<int> used(N);\n      T[j] = 0;\n      for(int v = 0; v < N; ++v) {\n        used[v] = v >= a && (j & (1<<(v-a)));\n        if(used[v]) T[j] += B[v];\n      }\n      for(int i = 0; i < esT.size(); ++i) {\n        int p = esT[i].first;\n        int q = esT[i].second;\n        if(used[p] && used[q]) {\n          T[j] = -1;\n          break;\n        }\n      }\n    }\n\n    for(int j = 0; j < (1<<b); ++j) {\n      for(int k = 0; k < b; ++k) {\n        if(j & (1<<k)) continue;\n        T[j|(1<<k)] = max(T[j|(1<<k)], T[j]);\n      }\n    }\n\n    int res = 0;\n    for(int j = 0; j < (1<<a); ++j) {\n      if(S[j] == -1) continue;\n      if(!(j & 1)) continue;\n      vector<int> used(N);\n      for(int v = 0; v < N; ++v) {\n        used[v] = v < a && (j & (1<<v));\n      }\n      int bit = (1<<b)-1;\n      for(int i = 0; i < esU.size(); ++i) {\n        int p = esU[i].first;\n        int q = esU[i].second;\n        if(used[p]) {\n          bit &= ~(1<<(q-a));\n        }\n      }\n      res = max(res, S[j] + T[bit]);\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <bitset>\n#include <cassert>\n#include <cctype>\n#include <climits>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <deque>\n#include <functional>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\nusing namespace std;\n\n#define lengthof(array) (sizeof(array) / sizeof(*array))\n#define dump(a) (cerr << (#a) << \" = \" << (a) << endl)\n#define FOR(it,c) for(__typeof((c).begin())it=(c).begin(); it!=(c).end();++it)\n\ntemplate<class T> inline void chmax(T& a, T b) { if(b > a) a = b; }\ntemplate<class T> inline void chmin(T& a, T b) { if(b < a) a = b; }\n\nint ans;\nvector<int> power;\nvector<vector<int> > adj;\n\nvoid dfs(char country, long long ng, int sum) {\n\tif(country == power.size()) {\n\t\tchmax(ans, sum);\n\t\treturn;\n\t}\n\n\tif(ng & (1ll << country)) {\n\t\tdfs(country + 1, ng, sum);\n\t\treturn;\n\t}\n\n\tif(adj[country].size() == 0) {\n\t\tdfs(country + 1, ng, sum + power[country]);\n\t\treturn;\n\t}\n\n\tint mx = sum;\n\tfor(int i = country; i < power.size(); ++i)\n\t\tif((ng & (1ll << i)) == 0)\n\t\t\tmx += power[i];\n\n\tif(mx <= ans)\n\t\treturn;\n\n\tdfs(country + 1, ng, sum);\n\n\tfor(int i = 0; i < adj[country].size(); ++i)\n\t\tng |= (1ll << adj[country][i]);\n\n\tdfs(country + 1, ng, sum + power[country]);\n}\n\nint main() {\n\tcin.tie(false);\n\tios::sync_with_stdio(false);\n\n\tfor(int n = 0; cin >> n, n;) {\n\t\tmap<string, int> convert;\n\t\tvector<vector<string> > d(n);\n\t\tpower.clear();\n\t\tpower.resize(n);\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tstring a;\n\t\t\tint c;\n\t\t\tcin >> a >> power[i] >> c;\n\n\t\t\tconvert[a] = i;\n\n\t\t\td[i].resize(c);\n\t\t\tfor(int j = 0; j < c; ++j)\n\t\t\t\tcin >> d[i][j];\n\t\t}\n\n\t\tadj.clear();\n\t\tadj.resize(n);\n\t\tfor(int i = 0; i < n; ++i)\n\t\t\tfor(int j = 0; j < d[i].size(); ++j)\n\t\t\t\tif(i < convert[d[i][j]])\n\t\t\t\t\tadj[i].push_back(convert[d[i][j]]);\n\n\t\tlong long ng = 0;\n\t\tfor(int i = 0; i < adj[0].size(); ++i)\n\t\t\tng |= (1ll << adj[0][i]);\n\n\t\tans = power[0];\n\t\tdfs(1, ng, power[0]);\n\t\tcout << ans << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <iomanip>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <bitset>\n#include <stack>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <cctype>\n#include <complex>\n#include <string>\n#include <sstream>\n#include <fstream>\n#include <cassert>\nusing namespace std;\n\n//common\ntypedef int  i32;\ntypedef long long i64,ll;\ntypedef vector<int> vi; typedef pair<int,int> pii; typedef vector<pair<int,int> > vpii;\ntypedef long long ll; typedef vector<long long> vl; typedef pair<long long,long long> pll; typedef vector<pair<long long,long long> > vpll;\ntypedef vector<string> vs; typedef long double ld;\n\n#define BR \"\\n\"\n#define ALL(c) (c).begin(),(c).end()\n#define REP(i,n) for(int i=0;i<(int)(n);++i)\n#define EACH(it,o) for(auto it = (o).begin(); it != (o).end(); ++it)\n#define IN(l,v,r) ((l)<=(v) && (v)<(r))\n\n//config\n//#undef NDEBUG\n//#define INF 1<<30\n//#define EPS 1e-8\n//const ll MOD =100000007;\n\n//debug\n#ifdef NDEBUG\n#define DUMP(x)\n#define DUMPLN(x)\n#define DEBUG(x)\n#define DEBUGLN(x)\n#define LINE()\n#define LINELN()\n#define CHECK(exp,act)\n#define STOP(e)\n#else\n#define DUMP(x)  cerr << #x << \" = \" << (x)\n#define DUMPLN(x)  DUMP(x) <<endl\n#define DEBUG(x) DUMP(x) << LINE() << \" \" << __FILE__\n#define DEBUGLN(x) DEBUG(x)<<endl\n#define LINE()    cerr<< \" (L\" << __LINE__ << \")\"\n#define LINELN()    LINE()<<endl\n#define CHECK(exp,act)  if(exp!=act){DUMPLN(exp);DEBUGLN(act);}\n#define STOP(e)  CHECK(e,true);if(!(e)) exit(1);\n#endif\n\ntemplate<class T> inline string toString(const vector<T>& x) {\n\tstringstream ss;\n\tREP(i,x.size()){\n\t\tif(i!=0)ss<<\" \";\n\t\tss<< x[i];\n\t}\n\treturn ss.str();\n}\n\ntemplate<class T> inline string toString(const vector<vector<T> >& map) {\n\tstringstream ss;\n\tREP(i,map.size()){\n\t\tif(i!=0)ss<<BR;\n\t\tss<< toString(map[i]);\n\t}\n\treturn ss.str();\n}\ntemplate<class K,class V>  string toString(map<K,V>& x) {\n\tstring res;stringstream ss;\n\tfor(auto& p:x)ss<< p.first<<\":\" << p.second<<\" \";\n\treturn ss.str();\n}\n\nstring BITtoString(int bit){\n    stringstream ss;\n    while(bit!=0){ss<<(bit%2);bit/=2;}\n    string res=ss.str();reverse(ALL(res));\n    return res;\n}\n\ntemplate<typename T,typename V> inline T mod(T v,V MOD){\n\treturn (v%MOD+MOD)%MOD;\n}\n\nclass Main{\npublic:\n\n\tint N;\n\tvector<int> ps;\n\tvector<vector<int>> es;\n\tvector<bool> canselect;\n\tvector<int> fillc;\n\n\tint Mv;\t\n\tint must;\n\n\tvector<bool> change;\n\tvoid dfs(int v,int val){\n\t\t//DUMP(v);\n\t\tMv=max(Mv,val);\n\t\tif(v>=N)return;\n\t\tif(val+fillc[v]<=Mv)return;\n\t\tif(canselect[v]){\n\t\t\tvector<int> change;\n\t\t\tselect(v,change);\n\t\t\tdfs(v+1,val+ps[v]);\n\t\t\tunselect(v,change);\n\t\t\t//周りが全て固定されていれば未選択の必要はない\n\t\t\tif(!allfixed(v))dfs(v+1,val);\n\t\t}else{\n\t\t\tdfs(v+1,val);\n\t\t}\n\t}\n\n\tbool allfixed(int v){\n\t\tREP(i,es[v].size())if(es[v][i]>v)return false;\n\t\treturn true;\n\t}\n\n\tvoid select(int v,vector<int>& change){\n\t\tcanselect[v]=false;\n\t\tREP(i,es[v].size()){\n\t\t\tif(canselect[es[v][i]]){\n\t\t\t\tcanselect[es[v][i]]=false;\n\t\t\t\tchange.push_back(es[v][i]);\n\t\t\t}\n\t\t}\n\t}\n\tvoid unselect(int v,vector<int>& change){\n\t\tcanselect[v]=true;\n\t\tREP(i,change.size())canselect[change[i]]=true;\n\t}\n\n\tvoid run(){\n\t\t//ifstream fin(\"in\" );\n\t\t//ofstream fout( \"out\" );\n\t\twhile(true){\n\t\t\tcin >>N;\n\t\t\tif(N==0)break;\n\t\t\tvector<string> cs(N);\n\t\t\tmap<string,int> stoid;\n\t\t\tps=vector<int>(N);\n\t\t\tvector<vector<string>> ess(N);\n\t\t\tREP(i,N){\n\t\t\t\tcin >> cs[i] >> ps[i];stoid.insert(make_pair(cs[i],i));\n\t\t\t\t\n\t\t\t\tint k;cin >>k;\n\t\t\t\tREP(j,k) {\n\t\t\t\t\tstring s;cin >> s;ess[i].push_back(s);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tes=vector<vector<int>>(N);\n\t\t\tREP(i,N)REP(j,ess[i].size())es[i].push_back(stoid[ess[i][j]]);\n\t\t\n\t\t\tcanselect=vector<bool>(N,true);\n\t\t\tfillc=vector<int>(N+1);\n\t\t\tfor(int i=N-1;i>=0;i--)fillc[i]+=fillc[i+1]+ps[i];\n\n\t\t\t//自分\n\t\t\tvector<int> dummy;\n\t\t\tmust=ps[0];select(0,dummy);\n\t\t\t//孤立点\n\t\t\tREP(i,N)if(canselect[i] && es[i].size()==0){must+=ps[i];select(i,dummy);}\n\t\t\t\n\t\t\tMv=must;\n\t\t\tdfs(0,must);\n\n\t\t\tcout<< Mv<<endl;\n\t\t}\n\t}\n};\n int main(){\n \tMain().run();\n \treturn 0;\n }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <array>\n#include <assert.h>\n#include <bitset>\n#include <cmath>\n#include <complex>\n#include <cstdio>\n#include <cstring>\n#include <deque>\n#include <fstream>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <random>\n#include <set>\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\nusing namespace std;\n\nstruct before_main {\n  before_main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n  }\n} before_main;\n\n#define REP(i, a, b) for (int i = a; i < (int)b; i++)\n#define rep(i, n) REP(i, 0, n)\n\ntypedef bitset<42> BS;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41];\nint weight_sum[41];\nint ans;\n\nvoid dfs(BS& bs, int wsum, int curr) {\n\n  if (curr == N) {\n    ans = max(ans, wsum);\n    return;\n  }\n\n  if (wsum + weight_sum[N-1] - (curr ? weight_sum[curr - 1] : 0) <= ans)\n    return;\n\n  dfs(bs, wsum, curr + 1);\n\n  rep(k, curr) {\n    if (adjacent[curr][k] && bs[k]) {\n      return;\n    }\n  }\n\n  bs.set(curr);\n  dfs(bs, wsum + weight[curr], curr + 1);\n  bs.reset(curr);\n}\n\nint main() {\n\n  while (cin >> N && N) {\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(_, N) {\n      string s;\n      cin >> s;\n      if (id.find(s) == id.end())\n        id[s] = v++;\n      cin >> weight[id[s]];\n      int n;\n      cin >> n;\n      rep(_, n) {\n        string t;\n        cin >> t;\n        if (id.find(t) == id.end())\n          id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) weight_sum[i] = weight[i] + (i ? weight_sum[i-1] : 0);\n\n    ans = 0;\n    BS bs;\n    bs.set(0);\n    dfs(bs, weight[0], 1);\n    cout << ans << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define REP(i, s, e) for(int i = (int)(s); i < (int)(e); ++i)\n#define rep(i, n) REP(i, 0, n)\ntypedef long long ll;\ntemplate<typename T, typename U>\nusing Hmap = unordered_map<T, U>;\nusing vl = vector<ll>;\n#define fi first\n#define se second\nint main() {\n  int n;\n  while(cin >> n) {\n    if(n == 0) break;\n    Hmap<string, int> hm;\n    vector<string> A(n);\n    vector<ll> B(n);\n    vector<vector<string>> D(n);\n    rep(i, n) {\n      int c;\n      cin >> A[i] >> B[i] >> c;\n      D[i].resize(c);\n      rep(j, c) cin >> D[i][j];\n      hm[A[i]]=i;\n    }\n    auto calc = [&](vl& dp, int s, int e) {\n      int l = e - s;\n      rep(mask, 1 << l) {\n\trep(i, l) {\n\t  if(mask & (1<<i)) continue;\n\t  bool f = true;\n\t  for(const auto& str: D[i+s]) {\n\t    int t = hm[str];\n\t    if(s <= t && t < e) {\n\t      if(mask&(1<<(t - s))) f = false;\n\t    }\n\t  }\n\t  if(f) {\n\t    int nxt = mask | (1<<i);\n\t    dp[nxt] = max(dp[nxt], dp[mask] + B[i+s]);\n\t  }\n\t}\n      }\n      rep(mask, 1<<l) {\n\trep(i, l) {\n\t  if(mask&(1<<i)) {\n\t    int pre = mask - (1<<i);\n\t    dp[mask] = max(dp[mask], dp[pre]);\n\t  }\n\t}\n      }\n    };\n\n    vector<vl> dp(2, vl(1<<20, 0));\n    calc(dp[0], 0, n/2);\n    calc(dp[1], n/2, n);\n\n    int len = n - (n/2);\n    vector<int> masks(1<<(n/2), (1<<len)-1);\n    rep(mask, 1<<(n/2)) {\n      rep(i, n/2) {\n\tif((mask & (1<<i)) == 0) continue;\n\tfor(const auto& str : D[i]) {\n\t  int t = hm[str] - n / 2;\n\t  if(t < 0) continue;\n\t  if(masks[mask] & (1<<t)) masks[mask] -= (1<<t);\n\t}\n      }\n    }\n    ll ans = 0LL;\n    rep(mask, n/2) if(mask&1) ans = max(ans, dp[0][mask] + dp[1][masks[mask]]);\n    cout << ans << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <cstring>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint n, ans, finalAns, cost[42], lim[42];\nll used, near[42];\nvector<P> v;\nvector<int> t[42];\nmap<string,int> name;\n\nint nameToInt(string s){\n  if(name.find(s) != name.end()){\n    return name[s];\n  }\n  int size = name.size();\n  name[s] = size;\n  return name[s];\n}\n\nvoid dfs(int id, ll &bit){\n  if(bit & (1LL << (ll)id)) return;\n  bit |= (1LL << (ll)id);\n\n  for(int i = 0; i < t[id].size(); i++){\n    int to = t[id][i];\n    dfs(to, bit);\n  }\n}\n\nvoid solve(int idx, int sum, ll bit, ll okBit){\n  if(idx == n){\n    ans = max(ans, sum);\n    return;\n  }\n\n  int id = v[idx].second;\n\n  if((okBit & (1LL << (ll)id)) &&\n     (bit & near[id]) == 0 &&\n     ans < sum + lim[idx]){\n    solve(idx + 1, sum + cost[id], bit | (1LL << (ll)id), okBit);\n  }\n\n  if(ans < sum + lim[idx + 1]){\n    solve(idx + 1, sum, bit, okBit);\n  }\n}\n\nvoid show(ll bit){\n  for(int i = 0; bit != 0; i++){\n    if(bit & 1LL){\n      cout<<i<<\", \";\n    }\n    bit /= 2LL;\n  }\n  cout<<endl;\n}\n\nint main(){\n  while(cin >> n, n){\n    name.clear();\n    memset(near, 0, sizeof(near));\n\n    for(int i = 0; i < 42; i++){\n      t[i].clear();\n    }\n\n    v.clear();\n\n    for(int i = 0; i < n; i++){\n      int from, m;\n      string s;\n      cin >> s;\n\n      from = nameToInt(s);\n      cin >> cost[from] >> m;\n      v.push_back(P(m, from));\n      near[from] |= (1LL << (ll)from);\n\n      for(int j = 0; j < m; j++){\n        cin >> s;\n        int to = nameToInt(s);\n        t[from].push_back(to);\n        near[from] |= (1LL << (ll)to);\n      }\n    }\n\n    sort(v.begin(), v.end(), greater<P>());\n    finalAns = cost[0];\n    used = 1;\n\n    for(int i = 0; i < n; i++){\n      int id = v[i].second;\n      if(used & (1LL << (ll)id)) continue;\n\n      ll bit = 0;\n      dfs(id, bit);\n\n      memset(lim, 0, sizeof(lim));\n\n      for(int j = n - 1; j >= 0; j--){\n        int tid = v[j].second;\n        if(bit & (1LL << tid)){\n          lim[j] = cost[tid];\n        }\n        lim[j] += lim[j + 1];\n      }\n\n      ans = 0;\n\n      if(bit & 1LL){\n        solve(i, 0, 1, bit);\n      }\n      else{\n        solve(i, 0, 0, bit);\n      }\n\n      finalAns += ans;\n      used |= bit;\n    }\n\n    cout << finalAns << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\n\nint main(){\n    while(cin >> n , n){\n        map<string,int> mp;\n        vector<i64> edges(n + 10,0);\n        vector<int> x(n + 10,0);\n\n        auto get_i = [&](string& s){\n            if(mp.count(s)){\n                return  mp[s];\n            }\n            else{\n                mp[s] = mp.size();\n                return (int)mp.size() - 1;\n            }\n        };\n\n        for(int c = 0;c < n;c++){\n            string s;cin >> s;\n            int i = get_i(s);\n            int C;\n            cin >> x[i] >> C;\n            for(int d = 0;d < C;d++){\n                cin >> s;\n                edges[i] |= (1LL << get_i(s));\n            }\n        }\n\n        vector<int> sum(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        int result = 0;\n        function<void(i64,i64,int)> dfs = [&](int i,i64 bit,int now_sum){\n            result = max(result , now_sum);\n            if(i == n) return;\n            //枝刈り\n            if(now_sum + sum[i] <= result) return;\n            //throw\n            dfs(i + 1,bit,now_sum);\n\n            if(!(bit & edges[i])) dfs(i + 1,bit | (1LL << i),now_sum + x[i]);\n        };\n        dfs(1,1,x[0]);\n        cout << result << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cmath>\n#include <vector>\n#include <complex>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <unordered_set>\n#include <unordered_map>\n#include <iomanip>\n#include <assert.h>\n#include <array>\n#include <cstdio>\n#include <cstring>\n#include <random>\n#include <functional>\n#include <numeric>\n#include <bitset>\n#include <fstream>\n\nusing namespace std;\n\nstruct before_main{before_main(){cin.tie(0); ios::sync_with_stdio(false);}} before_main;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n#define all(c) (c).begin(), (c).end()\n#define zero(a) memset(a, 0, sizeof a)\n#define minus(a) memset(a, -1, sizeof a)\ntemplate<class T1, class T2> inline bool minimize(T1 &a, T2 b) { return b < a && (a = b, 1); }\ntemplate<class T1, class T2> inline bool maximize(T1 &a, T2 b) { return a < b && (a = b, 1); }\n\ntypedef long long ll;\nint const inf = 1<<29;\n\nint N;\nmap<string, int> id;\nbool adjacent[41][41];\nint weight[41], wes[41];\nint ans;\n\nvoid dfs(ll S, int wsum, int curr) {\n\n  ans = max(ans, wsum);\n\n  if(wsum + wes[N-1] - (curr ? wes[curr-1] : 0) <= ans) return;\n\n  if(curr == N-1) return;\n\n  const int next = curr + 1;\n\n  dfs(S, wsum, next);\n\n  bool ok = 1;\n  rep(k, next) if(adjacent[next][k] && (S >> k & 1)) { ok = 0; break; }\n\n  if (ok) {\n    dfs(S|(1LL<<next), wsum + weight[next], next);\n  }\n}\n\nint main() {\n\n  while(cin >> N && N) {\n    rep(i, 41) weight[i] = 0;\n    rep(i, 41) rep(j, 41) adjacent[i][j] = 0;\n    id.clear();\n    int v = 0;\n\n    rep(i, N) {\n      string s; cin >> s;\n      if(id.find(s) == id.end()) id[s] = v++;\n      cin >> weight[id[s]];\n      int n; cin >> n;\n      rep(_, n) {\n        string t; cin >> t;\n        if(id.find(t) == id.end()) id[t] = v++;\n        adjacent[id[s]][id[t]] = 1;\n      }\n    }\n\n    rep(i, N) wes[i] = weight[i] + (i ? wes[i-1] : 0);\n\n    ans = 0;\n    dfs(1LL<<0, weight[0], 0);\n\n    cout << ans << endl;\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 40\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], ans;\n\nset<ll> memo;\n\nvoid dfs(ll S){\n\n  if(memo.count(S)) return ;\n\n  memo.insert(S);\n  \n  int cnt=0, sum=0;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1<<i))) continue;\n\n    sum+=cost[i];\n    \n    for(int j=i+1;j<n;j++){\n      if(!(S&(1LL<<j))) continue;\n      if(!G[i][j]) cnt++;\n    }\n    \n  }\n\n  int node=__builtin_popcountll(S);\n\n  if(cnt==node*(node-1)/2){\n    \n    ans=max(ans,sum);\n    return ;\n  }\n\n  for(int i=1;i<n;i++)\n    for(int j=i;j<n;j++){\n      \n      int nS=S;\n      \n      for(int k=i;k<=j;k++) nS=nS&~(1LL<<k);\n\n      dfs(nS);\n      \n    }\n  \n}\n\nint main(){\n  \n  while(1)  {\n\n    cin>>n;\n    if(!n) break;\n\n    map<string,int> num;\n    int cnt=0;\n\n    memset(G,0,sizeof(G));\n    \n    for(int i=0;i<n;i++){\n\n      string s;\n      cin>>s;\n\n      if(!num.count(s)) num[s]=cnt++;\n      \n      int a,b;\n      cin>>a>>b;\n      \n      cost[num[s]]=a;\n\n      for(int j=0;j<b;j++){\n\n\tstring t;\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n\n    ans=0;\n\n    memo.clear();\n    \n    dfs((1LL<<n)-1);\n    \n    cout<<ans<<endl;\n    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int, int> P;\nconst int M = 1000000007;\n\nint main() {\n    while (1) {\n        int n;\n        cin >> n;\n        if (!n) return 0;\n\n        vector<int> power(n);\n        map<string, int> mp;\n        vector<vector<string>> nearby(n);\n        for (int i = 0; i < n; ++i) {\n            string s;\n            int c;\n            cin >> s >> power[i] >> c;\n            mp[s] = i;\n            nearby[i].resize(c);\n            for (int j = 0; j < c; ++j)\n                cin >> nearby[i][j];\n        }\n        vector<long long> isnearby(n, 0LL);\n        for (int i = 0; i < n; ++i)\n            for (auto& j : nearby[i])\n                isnearby[i] |= 1LL << mp[j];\n\n        for (int i = 0; i < n; ++i)\n            if ((isnearby[0] >> i) & 1)\n                power[i] = -1000000;\n\n        int n1 = n / 2;\n        int n2 = n - n1;\n        vector<int> dp(1 << n1, -1000000);\n        for (int i = 1; i < (1 << n1); i += 2) {\n            int ma = 0;\n            long long inb = 0;\n            dp[i] = 0;\n            for (int j = 0; j < n1; ++j) {\n                if ((i >> j) & 1) {\n                    inb |= isnearby[j];\n                    dp[i] += power[j];\n                    ma = max(ma, dp[i ^ (1 << j)]);\n                }\n            }\n            if (i & inb)\n                dp[i] = ma;\n        }\n        int ans = 0;\n        int msk = (1 << n1) - 1;\n        for (int i = 1; i < (1 << n2); ++i) {\n            int sum = 0;\n            long long inb = 0;\n            for (int j = 0; j < n2; ++j) {\n                if ((i >> j) & 1) {\n                    inb |= isnearby[n1 + j];\n                    sum += power[n1 + j];\n                }\n            }\n            if (!(i & (inb >> n1)))\n                ans = max(ans, sum + dp[(inb & msk) ^ msk]);\n        }\n        cout << ans << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <bitset>\n#include <functional>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <queue>\n#include <set>\n#include <map>\n#include <cmath>\nusing namespace std;\ntypedef long long i64;\ntypedef long double ld;\ntypedef pair<i64,i64> P;\n#define rep(i,s,e) for(int i = (s);i <= (e);i++)\n\nint n;\nvector<i64> edges(n + 10, 0);\nvector<int> x(n + 10, 0);\nvector<int> sum(n + 10, 0);\nint result = 0;\nvoid dfs(i64 i, i64 bit, int now_sum) {\n  result = max(result, now_sum);\n  if (i == n)\n    return;\n  //枝刈り\n  if (now_sum + sum[i] <= result)\n    return;\n  // throw\n  dfs(i + 1, bit, now_sum);\n\n  if (0 == (bit & edges[i]))\n    dfs(i + 1, bit | (1LL << i), now_sum + x[i]);\n};\nint get_i(map<string,int> &mp,string &s) {\n  if (mp.count(s)) {\n    return mp[s];\n  } else {\n    mp[s] = mp.size();\n    return (int)mp.size() - 1;\n  }\n};\n\nint main(){\n    cin >> n;\n    while(n){\n        edges.assign(n + 10, 0);\n        x.assign(n + 10, 0);\n        map<string,int> mp;\n        for (int c = 0; c < n; c++) {\n          string s;\n          cin >> s;\n          int i = get_i(mp,s);\n          int C;\n          cin >> x[i] >> C;\n          for (int d = 0; d < C; d++) {\n            cin >> s;\n            edges[i] |= (1LL << get_i(mp,s));\n          }\n        }\n\n        sum.assign(n + 10,0);\n        for(int i = n - 1;i >= 0;i--){\n            sum[i] = sum[i + 1] + x[i];\n        }\n        result = 0;\n        dfs(1,1,x[0]);\n        cout << result;\n        cin >> n;\n        if(n) cout << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<cstdio>\n#include<vector>\n#include<iostream>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nint n,val[40];\nvector<int> G[40];\n\nbool vis[40],used[40];\n\nvoid dfs1(int u,vector<int> &order){\n\tvis[u]=true;\n\torder.push_back(u);\n\trep(i,G[u].size()){\n\t\tint v=G[u][i];\n\t\tif(!vis[v]) dfs1(v,order);\n\t}\n}\n\nint res;\nvoid dfs2(int i,const vector<int> &order,int sum){\n\t// pruning!!\n\tint sum2=0;\n\tfor(int j=i;j<order.size();j++) sum2+=val[order[j]];\n\tif(sum+sum2<=res) return;\n\n\tif(i==order.size()){\n\t\tres=max(res,sum);\n\t\treturn;\n\t}\n\n\tint u=order[i];\n\n\t// 頂点 u を選べるかどうかを判定\n\tbool ok=true;\n\trep(j,G[u].size()){\n\t\tint v=G[u][j];\n\t\tif(used[v]) ok=false;\n\t}\n\n\tint res=0;\n\tif(u!=0){\n\t\tdfs2(i+1,order,sum);\n\t}\n\tif(ok){\n\t\tused[u]=true;\n\t\tdfs2(i+1,order,sum+val[u]);\n\t\tused[u]=false;\n\t}\n}\n\nint main(){\n\tfor(;cin>>n,n;){\n\t\trep(u,n) G[u].clear();\n\n\t\tint nf=0;\n\t\tmap<string,int> f;\n\t\trep(i,n){\n\t\t\tstring s;\n\t\t\tint tmp,m; cin>>s>>tmp>>m;\n\t\t\tif(f.count(s)==0) f[s]=nf++;\n\t\t\tint u=f[s];\n\t\t\tval[u]=tmp;\n\t\t\trep(i,m){\n\t\t\t\tstring t; cin>>t;\n\t\t\t\tif(f.count(t)==0) f[t]=nf++;\n\t\t\t\tint v=f[t];\n\t\t\t\tG[u].push_back(v);\n\t\t\t}\n\t\t}\n\n\t\trep(u,n){\n\t\t\tvis[u]=false;\n\t\t\tused[u]=false;\n\t\t}\n\n\t\tint ans=0;\n\t\trep(u,n) if(!vis[u]) {\n\t\t\tvector<int> order;\n\t\t\tdfs1(u,order);\n\t\t\tres=0;\n\t\t\tdfs2(0,order,0);\n\t\t\tans+=res;\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tr1/unordered_map>\n#include <map>\n#include <string>\n\nusing namespace std;\nusing namespace tr1;\n\ntypedef long long LL;\n\nstruct Dict {\n    map<string,int> dict;\n    int id;\n\n    Dict() : id(0) {}\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        return dict[str] = id++;\n    }\n};\n\nstruct Hasher {\n    size_t operator ()(const pair<int,LL> &key) const {\n        return key.first + key.second;\n    }\n};\n\nunordered_map<pair<int,LL>,int,Hasher> memo;\nint ans = 0;\nvoid dfs(int pos, LL mask, int acc, const vector<int> &power, const vector<LL> &graph) {\n    const int N = power.size();\n    if(pos == N) {\n        ans = max(ans, acc);\n        return;\n    }\n\n    // テ」ツ?禿」ツつ古」ツ?凝」ツつ嘉・ツ?暗」ツ?ョテ・ツ渉ッティツδステ」ツ?ェテ」ツつづ」ツ?ョテ」ツつ津・ツ?ィテ」ツ?ヲテ・ツ渉姪」ツ?」テ」ツ?ヲテ」ツつづッツシツ古、ツサツ甘」ツ?セテ」ツ?ァテ」ツ?ョテヲツ慊?ィツ可ッティツァツ」テ」ツつ津ィツカツ?」ツ?暗」ツつ嘉」ツつ古」ツ?ェテ」ツ??」ツ?ェテ」ツつ嘉ヲツ楪敕・ツ按暗」ツつ?\n    int expected = acc;\n    for(int i = pos; i < N; ++i) {\n        if(!(mask & (1LL<<i))) expected += power[i];\n    }\n    if(expected <= ans) return;\n\n    pair<int,LL> key(pos, mask);\n    if(memo.count(key) && memo[key] >= acc) return;\n    memo[key] = acc;\n    dfs(pos+1, mask, acc, power, graph);\n    if(!(mask & (1LL<<pos))) {\n        dfs(pos+1, mask | graph[pos], acc + power[pos], power, graph);\n    }\n}\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<int> power(N);\n        vector<LL> graph(N);\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            int B, C;\n            string cn;\n            cin >> cn >> B >> C;\n            int cid = dict.get(cn);\n            power[cid] = B;\n            while(C--) {\n                string neighbor;\n                cin >> neighbor;\n                int nid = dict.get(neighbor);\n                graph[cid] |= 1LL << nid;\n            }\n            graph[cid] |= 1LL << cid;\n        }\n        memo.clear();\n        ans = 0;\n        dfs(0, graph[0], power[0], power, graph);\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\nusing namespace std;\nvector< vector<int> > G;\nvector<int> B;\nint N;\n\nint solve(int v, long long int t){\n  if(v >= B.size() || t == (1LL<<N) - 1) return 0;\n  int ret = 0;\n  if(!(t>>v & 1)){\n    long long t_ = t | (1LL<<v);\n    for(int i = 0; i < G[v].size(); ++i) t_ |= 1LL<<G[v][i];\n    ret = B[v] + solve(v+1,t_);\n    if(G[v].empty() || \n       (G[v].size() == 1 && B[G[v][0]] <= B[v])) return ret;\n  }\n  ret = max(ret, solve(v+1,t));\n  return ret;\n}\n\nint main(){\n  while(cin >> N, N){\n    map<string,int> M;\n    vector< vector<string> > D(N);\n    string a;\n    B = vector<int>(N);\n    int c;\n    for(int i = 0; i < N; ++i){\n      cin >> a >> B[i] >> c;\n      M[a] = i;\n      string d;\n      for(int j = 0; j < c; ++j){\n        cin >> d;\n        D[i].push_back(d);\n      }\n    }\n    G = vector< vector<int> >(N);\n    for(int i = 0; i < N; ++i){\n      for(int j = 0; j < D[i].size(); ++j){\n        G[i].push_back(M[D[i][j]]);\n      }\n    }\n    long long int t = 1LL;\n    for(int i = 0; i < G[0].size(); ++i) t |= 1LL<<G[0][i];\n    cout << B[0] + solve(0,t) << endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\ntypedef unsigned long long int ull;\n\n#define all(a)  (a).begin(),(a).end()\n#define rall(a) (a).rbegin(), (a).rend()\n#define pb push_back\n#define mp make_pair\n#define each(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define exist(s,e) ((s).find(e)!=(s).end())\n#define range(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n)  range(i,0,n)\n#define clr(a,b) memset((a), (b) ,sizeof(a))\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst double eps = 1e-10;\nconst double pi  = acos(-1.0);\nconst ll INF =1LL << 62;\nconst int inf =1 << 29;\n\nint n;\nstring vertex[45];\nint m[45];\nint power[45];\nstring adj[45][45];\n\n\null graph[45];\n\nint dfs(int cur,ull used){\n\tint res=0;\n\tull nused=used|(1LL<<cur);\n\tif(cur==n) return res;\n\tif(__builtin_popcountll(graph[cur])<=1){\n\t\tif(!(used>>cur&1)){\n\t\t\tres=power[cur]+dfs(cur+1,nused|graph[cur]);\n\t\t}else{\n\t\t\tres=dfs(cur+1,nused);\n\t\t}\n\t}else{\n\t\tres=dfs(cur+1,nused);\n\t\tif(!(used>>cur&1)) res=max(res,power[cur]+dfs(cur+1,nused|graph[cur]));\n\t}\n\treturn res;\n}\n\nint main(void){\n\twhile(cin >> n,n){\n\t\trep(i,n){\n\t\t\tcin >> vertex[i] >> power[i];\n\t\t\tcin >> m[i];\n\t\t\trep(j,m[i]) cin >> adj[i][j];\n\t\t}\n\t\tfor(int i=1;i<n;++i){\n\t\t\tfor(int j=i+1;j<n;++j){\n\t\t\t\tif(power[i]<power[j]){\n\t\t\t\t\tswap(vertex[i],vertex[j]);\n\t\t\t\t\tswap(power[i],power[j]);\n\t\t\t\t\tswap(m[i],m[j]);\n\t\t\t\t\trep(k,45) swap(adj[i][k],adj[j][k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,n){\n\t\t\tgraph[i]=0LL;\n\t\t\trep(j,m[i])rep(k,n)\n\t\t\t\tif(adj[i][j]==vertex[k])\n\t\t\t\t\tgraph[i]|=(1LL<<k);\n\t\t}\n\t\tcout << power[0]+dfs(1,graph[0]|1LL) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <map>\n\nusing namespace std;\n\ntypedef long long LL;\n\nstruct Dict {\n    map<string,int> dict;\n\n    int get(const string &str) {\n        if(dict.count(str)) return dict[str];\n        int id = dict.size();\n        return dict[str] = id;\n    }\n};\n\nint best = 0;\nvoid dfs(int pos, LL used, int score, const vector<LL> &neighbors, const vector<LL> &neighbors_rem, const vector<int> &scores, const vector<int> &scores_rem) {\n    const int N = neighbors.size();\n    if(pos == N) {\n        best = max(best, score);\n        return; \n    }\n    if(score + scores_rem[pos] <= best) {\n        return;\n    }\n    LL mask = 1LL<<pos;\n\n    if(!(used & mask)) {\n        dfs(pos+1, used | neighbors[pos] | mask, score + scores[pos], neighbors, neighbors_rem, scores, scores_rem);\n    }\n    if((used & mask) || (pos+1 < N && (neighbors_rem[pos+1] & mask))) {\n        dfs(pos+1, used, score, neighbors, neighbors_rem, scores, scores_rem);\n    }\n}\n\nint main() {\n    ios::sync_with_stdio(0);\n    cin.tie(0);\n\n    while(true) {\n        int N;\n        cin >> N;\n        if(!N) break;\n\n        vector<LL> neighbors(N, 0);\n        vector<int> scores(N, 0);\n        Dict dict;\n        for(int i = 0; i < N; ++i) {\n            string name;\n            int score, ncnt;\n            cin >> name >> score >> ncnt;\n            const int cid = dict.get(name);\n            scores[cid] = score;\n            while(ncnt--) {\n                string nname;\n                cin >> nname;\n                const int nid = dict.get(nname);\n                neighbors[cid] |= 1LL<<nid;\n            }\n        }\n\n        vector<LL> neighbors_rem(N, 0);\n        vector<int> scores_rem(N, 0);\n        scores_rem[N-1] = scores[N-1];\n        for(int i = N-2; i >= 0; --i) {\n            neighbors_rem[i] = neighbors_rem[i+1] | neighbors[i];\n            scores_rem[i] = scores_rem[i+1] + scores[i];\n        }\n        best = 0;\n        dfs(1, neighbors[0] | 1, scores[0], neighbors, neighbors_rem, scores, scores_rem);\n        cout << best << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// compile in C++11. use -std=c++11.\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <valarray>\n#include <map>\n#include <set>\n#include <list>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <functional>\n#include <complex>\n#include <string>\n#include <sstream>\n\n#include <cstdio>\n#include <cstdlib>\n#include <cctype>\n#include <cstring>\n\n// these require C++11\n#include <unordered_set>\n#include <unordered_map>\n#include <random>\n\nusing namespace std;\n\n#define all(c) c.begin(),c.end()\n#define repeat(i,n) for(int i=0;i<static_cast<int>(n);i++)\n#define debug(x) #x << \"=\" << (x)\n#define dump(x) cerr << debug(x) << \" (L:\" << __LINE__ << \")\"<< endl\n\ntypedef long long ll;\ntypedef complex<double> point;\n\ntemplate<typename T>\nostream& operator<<(ostream& os,const vector<T>& vec){\n    os << \"[\";\n    for(const auto& v : vec){\n        os << v << \",\";\n    }\n    os << \"]\";\n    return os;\n}\n\ntypedef long long ll;\n\nll solve(ll k,ll cur,ll mask,const vector<ll>& power,\n         const vector<ll>& masks,const vector<ll>& sum,ll& current_max){\n    int n = power.size();\n    if(k == n) return cur;\n    if(cur + sum[n] - sum[k] <= current_max) return cur;\n    if(mask & (1 << k)){\n        // already masked\n        return solve(k+1,cur,mask,power,masks,sum,current_max);\n    }else{\n        current_max = max(current_max,cur+power[k]);\n        return max(solve(k+1,cur+power[k],mask | masks[k],power,masks,sum,current_max),\n                   solve(k+1,cur,mask,power,masks,sum,current_max));\n    }\n}\n\nint main(){\n    while(true){\n        int n;cin >> n;\n        if(n == 0) break;\n        unordered_map<string,int> index_of;\n        int k = 0;\n        vector<ll> mask(n);\n        vector<ll> power(n);\n        for(int i=0;i<n;i++){\n            string A;int B,C;\n            cin >> A >> B >> C;\n            if(index_of.find(A) == index_of.end()){\n                index_of[A] = k;k++;\n            }\n            power[index_of[A]] = B;\n            for(int j=0;j<C;j++){\n                string d;cin >> d;\n                if(index_of.find(d) == index_of.end()){\n                    index_of[d] = k;k++;\n                }\n                mask[index_of[A]] = mask[index_of[A]] | (1 << index_of[d]);\n            }\n        }\n        // sum of [0..i)\n        vector<ll> sum(n+1);\n        for(int i=1;i<=n;i++){\n            sum[i] = sum[i-1] + power[i-1];\n        }\n        ll p = power[0];\n        cout << solve(1,power[0],mask[0],power,mask,sum,p) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define N 45\nusing namespace std;\ntypedef long long ll;\n\nint n, cost[N], G[N][N], m, ans;\n\nset<ll> memo;\n\nvoid dfs(int x,ll S,int sum){\n\n  ans=max(ans,sum);\n  \n  //if(memo.count(S)) return ;\n\n  //  memo.insert(S);\n  \n  if(x==m) return ;\n  \n  for(int i=0;i<n;i++){\n    \n    if(S&(1LL<<i)) continue;\n    \n    int f=0;\n    \n    for(int j=0;j<n;j++)\n\n      if((S&(1LL<<j))&&G[j][i]) f=1;\n    \n    if(!f) dfs(x+1,S|(1LL<<i),sum+cost[i]);\n    \n  }\n  \n}\n\nvoid dfs2(int x,ll S,int sum){\n\n  int f=0;\n  \n  for(int i=0;i<n;i++){\n    if(!(S&(1LL<<i))) continue;\n    for(int j=i+1;j<n;j++){\n      if(!(S&(1LL<<j))) continue;\n      if(G[i][j]) f=1;\n    }\n  }\n  \n  if(!f) ans=max(ans,sum);\n\n  //  if(memo.count(S)) return;\n\n  //  memo.insert(S);\n  \n  if(x==n) return ;\n  \n  for(int i=0;i<n;i++){\n    \n    if(!(S&(1LL<<i))) continue;\n    \n    for(int j=i+1;j<n;j++){\n      \n      if(!(S&(1LL<<j))) continue;\n      \n      if(G[i][j]){\n\t\n\tif(i) dfs2(x+1,S|(1LL<<i),sum-cost[i]);\n\t\n\tdfs2(x+1,S|(1LL<<j),sum-cost[j]);\n\t\n      }\n      \n    }\n    \n  }\n  \n}\n\n\nint main(){\n\n  while(1){\n  \n    cin>>n;\n\n    if(!n) break;\n    \n    map<string,int> num;\n    int cnt=0, sum=0;\n    \n    memset(G,0,sizeof(G));\n\n    for(int i=0;i<n;i++){\n      \n      string s;\n      \n      cin>>s;\n      \n      if(!num.count(s)) num[s]=cnt++;\n      \n      cin>>cost[num[s]];\n\n      if(i) sum+=cost[num[s]];\n      \n      int x;\n      cin>>x;\n      \n      for(int j=0;j<x;j++){\n\t\n\tstring t;\n\t\n\tcin>>t;\n\t\n\tif(!num.count(t)) num[t]=cnt++;\n\t\n\tG[num[s]][num[t]]=1;\n\t\n      }\n      \n    }\n    \n    ans=0;\n    \n    m=(n-1)/2;\n    \n    memo.clear();\n    \n    dfs(0,1,0);\n\n    dfs2(m+1,(1LL<<n)-1,sum);\n\n    cout<<ans+cost[0]<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nusing Graph = vector< vector<int> >;\n\n// generate binary string (not less than k-digit)\nstring to_binString(int n, int k) {\n    string ret = \"\";\n    while(n) ret += ('0' + (n&1)), n >>= 1;\n    while(ret.length() < k) ret += '0';\n    // reverse(ret.begin(), ret.end());\n    return ret;\n}\n\nint N;\n\nmap<long long int, int> checked;\n\nint solve(const Graph &G, const vector<int> &cost, vector<int> &deg, long long int bit) {\n    if(checked.count(bit)) {\n        return checked[bit];\n    }\n\n    long long int nbit;\n\n    int ret = 0, tmp;\n    for(int i=0; i<N; i++) {\n        if(!(bit >> i & 1)) continue;\n\n        // その頂点を使う\n        nbit = bit ^ (1LL << i); tmp = cost[i];\n        vector<int> diff;\n        for(auto v : G[i]) {\n            if(nbit >> v & 1) {\n                nbit ^= (1LL << v);\n                for(auto to : G[v]) {\n                    deg[to]--;\n                    diff.push_back(to);\n                }\n            }\n        }\n\n        // 孤立している頂点\n        for(int k=0; k<N; k++) {\n            if(deg[k] == 0 && nbit >> k & 1) {\n                tmp += cost[k];\n                nbit ^= (1LL << k);\n            }\n        }\n\n        tmp += solve(G, cost, deg, nbit);\n        ret = max(ret, tmp);\n\n        // 次数を元にもどす\n        for(auto v : diff) deg[v]++;\n\n        // 使わない\n        nbit = bit ^ (1LL << i), tmp = 0;\n\n        for(auto v : G[i]) deg[v]--;\n        for(int k=0; k<N; k++) {\n            if(deg[k] == 0 && nbit >> k & 1) {\n                tmp += cost[k];\n                nbit ^= (1LL << k);\n            }\n        }\n\n        tmp += solve(G, cost, deg, nbit);\n        ret = max(ret, tmp);\n\n        for(auto v : G[i]) deg[v]++;\n    }\n\n    return checked[bit] = ret;\n}\n\nint main() {\n    while(cin >> N, N) {\n        checked.clear();\n        map<string, int> mp;\n\n        string root = \"\";\n        vector<string> adj[50], name(N);\n        vector<int> tmp(N), cost(N);\n        for(int i=0; i<N; i++) {\n            cin >> name[i];\n            if(i == 0) {\n                root = name[i];\n            }\n\n            mp[ name[i] ]++;\n            cin >> tmp[i];\n\n            int x; cin >> x;\n            for(int k=0; k<x; k++) {\n                string s; cin >> s;\n                mp[s]++;\n                adj[i].push_back(s);\n            }\n        }\n\n        int id = 0;\n        for(auto &x : mp) {\n            x.second = id++;\n        }\n\n        Graph G(N);\n        vector<int> deg(N);\n        for(int i=0; i<N; i++) {\n            int u = mp[ name[i] ];\n            cost[u] = tmp[i];\n            for(auto s : adj[i]) {\n                int v = mp[s];\n                G[u].push_back(v);\n                G[v].push_back(u);\n                deg[u]++; deg[v]++;\n            }\n        }\n\n        long long int bit = (1LL << N) - 1;\n        int root_v = mp[root], isolate = cost[root_v];\n\n        // root_v に隣接する頂点\n        bit ^= (1LL << root_v);\n        for(auto v : G[root_v]) {\n            if(bit >> v & 1) {\n                bit ^= (1LL << v);\n                for(auto to : G[v]) {\n                    deg[to]--;\n                }\n            }\n        }\n\n        // 孤立している頂点\n        for(int i=0; i<N; i++) {\n            if(deg[i] == 0 && bit >> i & 1) {\n                isolate += cost[i];\n                bit ^= (1LL << i);\n            }\n        }\n\n        cout << isolate + solve(G, cost, deg, bit) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2403\nTitle\n*/\n#include <stdio.h>\n#include <string.h>\n#define MAXCOUNTRY 40\n#define NAMELENGTH 16\n#define max(x,y) (((x)>(y))?(x):(y))\n//Global data section\nint n;\nchar name_table[MAXCOUNTRY][NAMELENGTH+1];\nint  strength[MAXCOUNTRY];\nchar  neighbor[MAXCOUNTRY][MAXCOUNTRY];\nchar  readbuffer[MAXCOUNTRY][1000];\nchar  doumei[MAXCOUNTRY];\nint total_strength;\nint select_count;\n//\nvoid clear_neighbor()\n{\n        int i,j;\n        for(i=0;i<MAXCOUNTRY;i++)\n                for(j=0;j<MAXCOUNTRY;j++)\n                        neighbor[i][j]=0;\n        for(i=0;i<MAXCOUNTRY;i++)\n                doumei[i]=0;\n}\nint get_county_num(char * name)\n{\n        int i;\n        for(i=0;i<MAXCOUNTRY;i++)\n                if(0==strcmp(name,name_table[i]))\n                        return(i);\n        return(-1);\n}\nvoid regist_country_name_and_strength()\n{\n        int i;\n\n        for(i=0;i<n;i++)\n        {\n                sscanf(&readbuffer[i][0],\"%s %d\",&name_table[i][0],\n                       &strength[i]);\n        }\n}\nvoid regist_neighbor()\n{\n        int i,j,m,neib;\n        char *p;\n\n        for(i=0;i<n;i++)\n        {\n                p=strtok(&readbuffer[i][0],\" \");  //skip country name\n                p=strtok(NULL,\" \");               //skip strength\n                p=strtok(NULL,\" \"); //get number of neighbor countries\n                m=atoi(p);\n                for(j=0;j<m;j++)\n                {\n                        p=strtok(NULL,\" \\r\\n\");\n                        neib=get_county_num(p);\n                        neighbor[i][neib]=neighbor[neib][i]=-1;\n                }\n        }\n}\nvoid dump()\n{\n        int i,j;\n        for(i=0;i<n;i++)\n        {\n                printf(\"%2d|\",i);\n                for(j=0;j<n;j++)\n                        printf(\"%c\",neighbor[i][j]?'+':'-');\n                printf(\"|(%s:%d)\\n\",&name_table[i][0],strength[i]);\n        }\n}\nint is_doumei_neighbor(int country_num)\n{\n        int i;\n\n        for(i=0;i<n;i++)\n                if(neighbor[i][country_num] && doumei[i])\n                        return(-1);\n        return(0);\n}\nint  max_sum_strength2(int start,int total)\n{\n        int ret1,ret2,c;\n#ifdef DEBUG\n        printf(\"st,t=%d %d\\n\",start,total);\n#endif\n        if(start >= n)\n                return(total);\n        c=start;\n        while(is_doumei_neighbor(c))\n                c++;\n        if(c >= n)\n                return(total);\n        ret1=max_sum_strength2(c+1,total);\n        doumei[c]=-1;\n        ret2=max_sum_strength2(c+1,total+strength[c]);\n        return(max(ret1,ret2));\n}\nint  max_sum_strength()\n{\n        doumei[0]=-1;\n        total_strength=strength[0];\n        select_count=1;\n        return(max_sum_strength2(1,total_strength));\n}\nint main()\n{\n        int i,ret;\n\n        while(EOF!=scanf(\"%d \",&n) && n)\n        {\n                clear_neighbor();\n                for(i=0;i<n;i++)  \n                        fgets(&readbuffer[i][0],1000,stdin);\n      \n                regist_country_name_and_strength();\n                regist_neighbor();\n#ifdef DEBUG\n                dump();\n#endif\n\n                ret=max_sum_strength();\n                printf(\"%d\\n\",ret);\n\n        }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2403\n  Title:The Enemy of My Enemy is My Friend\n  @kankichi573\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n\nchar country[40][17];\nchar adjoin[40][40]; \nint strength[40];\nint n,n2;\nchar doumei[40];\nvoid dump()\n{\n  int i,j;\n\n  for(i=0;i<n;i++)\n    {\n      printf(\"%-16s [%2d]|\",&country[i][0],strength[i]);\n      \n      for(j=0;j<n;j++)\n        if(adjoin[i][j])\n\t  printf(\"%s :\",&country[j][0]);\n      \n      printf(\"\\n\");\n      \n    }\n\n}\nvoid dump_doumei(char doumei[],int lv)\n{\n  int i;\n  printf(\"D:[%d]\",lv);\n  for(i=0;i<n;i++)\n    if(doumei[i]==1)\n      printf(\"%s:\",country[i]);\n    else if(doumei[i]==2)\n      printf(\"[%s]\",country[i]);\n  printf(\"\\n\");\n}\n\nint solve2(char doumei[],int from,int lv)\n{\n  char doumei0[40],doumei1[40];\n  int i,ret1,ret2,dm;\n#ifdef DEBUG\n  dump_doumei(doumei,lv);\n#endif  \n  for(i=from;i<n;i++)\n    {\n      if(doumei[i]==0)\n\tgoto NEXT;\n    }\n  return(0);\n NEXT:\n  dm=i;\n  memcpy(doumei0,doumei,40);\n  memcpy(doumei1,doumei,40);\n  doumei0[dm]=2;\n  doumei1[dm]=1;\n\n  ret1=solve2(doumei0,from+1,lv+1);\n  for(i=0;i<n;i++)\n    if(adjoin[dm][i])\n      {\n\tdoumei1[i]=2;\n      }\n  ret2=strength[dm]+solve2(doumei1,from+1,lv+1);\n  return(max(ret1,ret2));\n  \n  return(0);\n}\n\nint solve()\n{\n  int ret,i;\n\n  memset(doumei,0,40);\n  doumei[0]=1;\n  for(i=0;i<n;i++)\n    if(adjoin[0][i])\n      {\n\tdoumei[i]=2;\n      }\n\n  ret = strength[0];\n  ret += solve2(doumei,1,1);\n  return(ret);\n}\n\nint register_country(char *s)\n{\n  int i;\n  for(i=0;i<n2;i++)\n    if(0==strcmp(s,&country[i][0]))\n      return(i);\n  strcpy(&country[n2][0],s);\n  n2++;\n  return(n2-1);\n}\n\nmain()\n{\n  int i,j,ret;\n  char name[17];\n\n  int str,num,country_no,rinsetu_no;\n\n  while(scanf(\"%d\",&n) && n)\n  {\n    n2=0;\n    for(i=0;i<n;i++)\n      {\n\tscanf(\"%s %d %d\",name,&str,&num);\n\t\t\n\tcountry_no=register_country(name);\n\tstrength[country_no]=str;\n\t\n\tfor(j=0;j<num;j++)\n\t  {\n\t    scanf(\"%s\",name);\n\t    rinsetu_no=register_country(name);\n\t    adjoin[country_no][rinsetu_no]=1;\n\t  }\n      }\n#ifdef DEBUG\n      dump();\n#endif    \n\n    ret=solve();\n    printf(\"%d\\n\",ret);\n  }\n    return(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A2403\nTitle The Enemy of My Enemy is My Friend\n7/27 TLE\n*/\n#include <stdio.h>\n#include <string.h>\n#define MAXCOUNTRY 40\n#define NAMELENGTH 16\n#define max(x,y) (((x)>(y))?(x):(y))\n//Global data section\nint n;\nchar name_table[MAXCOUNTRY][NAMELENGTH+1];\nint  strength[MAXCOUNTRY];\nchar  neighbor[MAXCOUNTRY][MAXCOUNTRY];\nchar  readbuffer[MAXCOUNTRY][1000];\nchar  doumei[MAXCOUNTRY];\nchar  isolate[MAXCOUNTRY];\nint total_strength;\nint select_count;\n//\nvoid clear_neighbor()\n{\n        int i,j;\n        for(i=0;i<MAXCOUNTRY;i++)\n                for(j=0;j<MAXCOUNTRY;j++)\n                        neighbor[i][j]=0;\n        for(i=0;i<MAXCOUNTRY;i++)\n        {\n                doumei[i]=0;\n                isolate[i]=0;\n        }\n}\nint get_county_num(char * name)\n{\n        int i;\n        for(i=0;i<MAXCOUNTRY;i++)\n                if(0==strcmp(name,name_table[i]))\n                        return(i);\n        return(-1);\n}\nvoid regist_country_name_and_strength()\n{\n        int i;\n\n        for(i=0;i<n;i++)\n        {\n                sscanf(&readbuffer[i][0],\"%s %d\",&name_table[i][0],\n                       &strength[i]);\n        }\n}\nvoid regist_neighbor()\n{\n        int i,j,m,neib;\n        char *p;\n\n        for(i=0;i<n;i++)\n        {\n                p=strtok(&readbuffer[i][0],\" \");  //skip country name\n                p=strtok(NULL,\" \");               //skip strength\n                p=strtok(NULL,\" \"); //get number of neighbor countries\n                m=atoi(p);\n                if(m==0)\n                        isolate[i]=-1;\n                else\n                        for(j=0;j<m;j++)\n                        {\n                                p=strtok(NULL,\" \\r\\n\");\n                                neib=get_county_num(p);\n                                neighbor[i][neib]=neighbor[neib][i]=-1;\n                        }\n        }\n}\nvoid dump()\n{\n        int i,j;\n        for(i=0;i<n;i++)\n        {\n                printf(\"%2d|\",i);\n                for(j=0;j<n;j++)\n                        printf(\"%c\",neighbor[i][j]?'+':'-');\n                printf(\"|(%s:%d:%c)\\n\",&name_table[i][0],strength[i],\n                       isolate[i]?'*':' ');\n        }\n}\nint is_doumei_neighbor(int country_num)\n{\n        int i;\n\n        for(i=0;i<n;i++)\n                if(neighbor[i][country_num] && doumei[i])\n                        return(-1);\n        return(0);\n}\nint  max_sum_strength2(int start,int total)\n{\n        int ret1,ret2,c;\n#ifdef DEBUG2\n        printf(\"st,t=%d %d\\n\",start,total);\n#endif\n        if(start >= n)\n                return(total);\n        c=start;\n        while(is_doumei_neighbor(c))\n                c++;\n        if(c >= n)\n                return(total);\n        if(!isolate[c])\n                ret1=max_sum_strength2(c+1,total);\n        else\n                ret1=0;\n        doumei[c]=-1;\n        ret2=max_sum_strength2(c+1,total+strength[c]);\n        doumei[c]=0;\n        return(max(ret1,ret2));\n}\nint  max_sum_strength()\n{\n        doumei[0]=-1;\n        total_strength=strength[0];\n        select_count=1;\n        return(max_sum_strength2(1,total_strength));\n}\nint main()\n{\n        int i,ret;\n\n        while(EOF!=scanf(\"%d \",&n) && n)\n        {\n                clear_neighbor();\n                for(i=0;i<n;i++)  \n                        fgets(&readbuffer[i][0],1000,stdin);\n      \n                regist_country_name_and_strength();\n                regist_neighbor();\n#ifdef DEBUG\n                dump();\n#endif\n\n                ret=max_sum_strength();\n                printf(\"%d\\n\",ret);\n\n        }\n\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "/*\n  AOJ 2403\n  Title:The Enemy of My Enemy is My Friend\n  @kankichi573\n  14/11/02 TLE 0/4\n*/\n#include <stdio.h>\n#include <string.h>\n#define max(x,y) (((x)>(y))?(x):(y))\n\nchar country[40][17];\nchar adjoin[40][40]; \nint strength[40];\nint n,n2;\nchar doumei[40];\nint init_power;\nint answer;\nint runsum_strength[40];\nvoid dump()\n{  int i,j;\n\n  for(i=0;i<n;i++)\n    {\n      \n      printf(\"%-16s [%d][%d]|\",&country[i][0],strength[i],runsum_strength[i]);\n      for(j=0;j<n;j++)\n        if(adjoin[i][j])\n\t  printf(\"%d :\",j);\n      \n      printf(\"\\n\");\n      \n    }\n\n}\n\nvoid dump_n()\n{\n  int i,j,cnt;\n  char buf1[4],buf[121];\n\n  printf(\"%d\\n\",n);\n  for(i=0;i<n;i++)\n    {\n      printf(\"%-2d %-5d [%-5d]\",i,strength[i],runsum_strength[i]);\n      buf[0]='\\0';\n      cnt=0;\n      for(j=0;j<n;j++)\n\t{\n        if(adjoin[i][j])\n\t  {\n\t    sprintf(buf1,\"%-2d \",j);\n\t    strcat(buf,buf1);\n\t    cnt++;\n\t  }\n\t}\n      \n      printf(\"%d %s \\n\",cnt,buf);\n    }\n  printf(\"0\\n\");\n}\nvoid dump_doumei(char doumei[],int lv)\n{\n  int i;\n  printf(\"D:[%d]\",lv);\n  for(i=0;i<n;i++)\n    if(doumei[i]==1)\n      printf(\"%s:\",country[i]);\n    else if(doumei[i]==2)\n      printf(\"[%s]\",country[i]);\n  printf(\"\\n\");\n}\n\nsolve2(char doumei[],int from,int acc,int lv)\n{\n  char doumei0[40],doumei1[40];\n  int i,dm,flag;\n\n#ifdef DEBUG\n  dump_doumei(doumei,lv);\n#endif  \n  for(i=from;i<n;i++)\n    {\n      if(doumei[i]==0)\n\tgoto NEXT;\n    }\n  answer=max(answer,acc);\n  return;\n NEXT:\n  dm=i;\n\n  if(acc + runsum_strength[dm] < answer)\n    return;  //edakari 2\n\n  memcpy(doumei0,doumei,40);\n  memcpy(doumei1,doumei,40);\n  doumei0[dm]=2;\n  doumei1[dm]=1;\n\n\n  flag=0;\n  for(i=0;i<n;i++)\n    if(adjoin[dm][i])\n      {\n\tif(doumei[i]==0)\n\t  {\n\t    flag=1; //edakari\n\t    doumei1[i]=2;\n\t  }\n      }\n  \n  solve2(doumei1,from+1,acc+strength[dm],lv+1); \n  if(flag)\n    solve2(doumei0,from+1,acc,lv+1);\n}\n\nvoid solve()\n{\n  int ret,i;\n\n  answer=0;\n  for(i=0;i<n;i++)\n    if(adjoin[0][i])\n      doumei[i]=2;\n        \n  solve2(doumei,1,init_power,1);\n}\n\nint register_country(char *s)\n{\n  int i;\n  for(i=0;i<n2;i++)\n    if(0==strcmp(s,&country[i][0]))\n      return(i);\n  strcpy(&country[n2][0],s);\n  n2++;\n  return(n2-1);\n}\n\nmain()\n{\n  int i,j,ret;\n  char name[17];\n\n  int str,num,country_no,rinsetu_no;\n\n  while(scanf(\"%d\",&n) && n)\n  {\n    n2=0;\n    memset(doumei,0,40);\n    memset(adjoin,0,40*40);\n    init_power=0;\n    for(i=0;i<n;i++)\n      {\n\tscanf(\"%s %d %d\",name,&str,&num);\n\t\t\n\tcountry_no=register_country(name);\n\tstrength[country_no]=str;\n\tif(num==0 || i==0)\n\t  {\n\t    doumei[country_no]=1; // rinsetukoku nasi => must union\n\t    init_power+=str;\n\t  }\n\tfor(j=0;j<num;j++)\n\t  {\n\t    scanf(\"%s\",name);\n\t    rinsetu_no=register_country(name);\n\t    adjoin[country_no][rinsetu_no]=1;\n\t  }\n      }\n    runsum_strength[n-1]=strength[n-1];\n    if(n>1)\n      for(i=n-2;i>=0;i--)\n\trunsum_strength[i]=runsum_strength[i+1]+strength[i];\n#ifdef DEBUG2\n      dump_n();\n#else\n    solve();\n    printf(\"%d\\n\",answer);\n#endif    \n  }\n    return(0);\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 2403: The Enemy of My Enemy is My Friend\n// 2018.1.19 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define HASHSIZ 199\ntypedef struct { char *s; int id; } HASH;\nHASH hash[HASHSIZ+2], *hashend = hash + HASHSIZ;\t\t\t// Hash table\n\nvoid insert(char *s, int id, int w)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\ttp->s = s, tp->id = id;\n}\n\nint lookup(char *s, int w)\n{\n\tint i = (101 * *s + 103 * *(s+w-1) + 107 * w) % HASHSIZ;\n\tHASH *tp = hash + i;\n\n\twhile (tp->s != NULL) {\n\t\tif (!strcmp(tp->s, s)) return tp->id;\n\t\tif (++tp == hashend) tp = hash;\n\t}\n\treturn -1;\n}\n\nint n, ans;\nchar name[41][18];\nint to[41][41], hi[41], b[41];\nchar our[41], done[41];\nchar buf[41][700], *top[41];\nchar done[41];\nlong long tbl[41];\nint sum[41];\n\nvoid calc(int k, int power, long long mask)\n{\n\tif (power > ans) ans = power;\n\tif (k == n) return;\n\tif (power+sum[k] <= ans) return;\n\tif (done[k]) calc(k+1, power, mask);\n\telse {\n\t\tif (!((mask >> k) & 1)) calc(k+1, power+ b[k], mask|tbl[k]);\n\t\tcalc(k+1, power, mask);\n\t}\n}\n\nint main()\n{\n\tint i, j, c;\n\tchar s[10], *p, *q;\n\tlong long mask;\n\n\twhile (fgets(s, 10, stdin) && *s != '0') {\n\t\tn = atoi(s);\n\t\tmemset(hi, 0, sizeof(hi));\n\t\tmemset(tbl, 0, sizeof(tbl));\n\t\tmemset(done, 0, sizeof(done));\n\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tfgets(p=buf[i], 700, stdin);\n\t\t\tq = p; while (*p > ' ') p++;\n\t\t\t*p = 0, insert(q, i, p-q);\n\t\t\ttop[i] = p+1;\n\t\t}\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tb[i] = atoi(top[i]);\n\t\t\tp = top[i]; while (*p > ' ') p++;\n\t\t\tc = atoi(++p); while (*p > ' ') p++; p++;\n\t\t\twhile (c--) {\n\t\t\t\tq = p; while (*p > ' ') p++;\n\t\t\t\t*p = 0, j = lookup(q, p-q); p++;\n\t\t\t\tto[i][hi[i]++] = j;\n\t\t\t\ttbl[i] |= 1LL << j;\n\t\t\t}\n\t\t}\n\t\tsum[n] = 0;\n\t\tfor (i = n-1; i >= 0; i--) sum[i] = sum[i+1] + b[i];\n\n\t\tans = b[0], mask = tbl[0];\n\t\tdone[0] = 1; for (i = 0; i < hi[0]; i++) done[to[0][i]] = 1;\n\t\tfor (i = 1; i < n; i++) if (!hi[i]) done[i] = 1, ans += b[i], mask |= tbl[i];\n\n\t\tcalc(1, ans, mask);\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] costs;\n\tlong[] enemies;\n\tint n;\n\tint max;\n\tHashMap<String, Integer> name2int;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcosts = new int[n];\n\t\t\tenemies = new long[n];\n\t\t\tname2int = new HashMap<String, Integer>();\n\t\t\tString[][] names = new String[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tname2int.put(name, i);\n\t\t\t\tcosts[i] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tnames[i] = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tnames[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<names[i].length;j++){\n\t\t\t\tenemies[i] |= 1L<<name2int.get(names[i][j]);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) enemies[i] |= 1L<<i;\n\t\t\tmax = 0;\n\t\t\tdfs(1, enemies[0], costs[0]);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemy, int cost) {\n\t\tif( x == n ) {\n\t\t\tmax = max(max, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemy>>x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemy, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( notConnected(enemy, enemies[x], x) ) {\n\t\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(x+1, enemy, cost);\n\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t}\n\t\n\tboolean notConnected(long a, long b, int x) {\n\t\tfor(int i=0;i<n;i++) if( ((a>>i)&(b>>i)) == 1 ) return false;\n\t\tfor(int i=0;i<n-x-1;i++) {\n\t\t\tif( (((a>>(x+i+1))^1)&(b>>(x+i+1))) == 1 ) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//国名\n\tpublic static String[] name;\n\t//軍事力\n\tpublic static int[] power;\n\t//隣接国の数\n\tpublic static int[] num;\n\t//隣接国のインデックス\n\tpublic static int[][] list;\n\t//敵味方マップ\n\tpublic static int[] map;\n\n\tpublic static final int UNDEF = 0;\n\tpublic static final int FRIEND = 1;\n\tpublic static final int ENEMY = 2;\n\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\t}\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\twhile(n != 0){\n\t\t\tname = new String[n];\n\t\t\tpower = new int[n];\n\t\t\tnum = new int[n];\n\t\t\tlist = new int[n][n];\n\t\t\tString[][] str = new String[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tpower[i] = sc.nextInt();\n\t\t\t\tnum[i] = sc.nextInt();\n\t\t\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\t\t\tstr[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\t//System.out.println(str + \"a\");\n\t\t\t}\n\t\t\t//strをlistにする\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(str[i][j].equals(name[k])){\n\t\t\t\t\t\t\tlist[i][j] = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println(str + \"a\");\n\t\t\t}\n\t\t\t\n\t\t\t//mapを作る\n\t\t\tmap = new int[n];\n\t\t\t//自分の国は味方\n\t\t\tmap[0] = FRIEND;\n\t\t\t//printList(0);\n\t\t\tfor(int i = 0; i < num[0]; i++){\n\t\t\t\tmap[list[0][i]] = ENEMY;\n\t\t\t}\n//\t\t\tint tmp = 0;\n//\t\t\tfor(int i = 1; i < n; i++){\n//\t\t\t\tif(map[i] == UNDEF){\n//\t\t\t\t\ttmp = i;\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\t//printMap();\n//\t\t\tif(tmp < n){\n//\t\t\t\tSystem.out.println(getMax(1) + power[0]);\n//\t\t\t}\n//\t\t\telse{\n//\t\t\t\tSystem.out.println(power[0]);\n//\t\t\t}\n\t\t\tSystem.out.println(getMax(1) + power[0]);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\t//最大の軍事力を返す\n\t//startより後の國のみ考えれば良い\n\tpublic static int getMax(int start){\n\t\t//printMap();\n\t\tint ret = 0;\n\t\tint i;\n\t\tfor(i = start; i < n; i++){\n\t\t\tif(map[i] == UNDEF){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i == n - 1){\n\t\t\treturn power[i];\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn ret;\n\t\t}\n\t\t//味方\n\t\tmap[i] = FRIEND;\n\t\tint[] temp = new int[num[i]];\n\t\tint t = 0;\n\t\t//printList(i);\n\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\tint ene = list[i][j];\n\t\t\tif(map[ene] == UNDEF){\n\t\t\t\tmap[ene] = ENEMY;\n\t\t\t\t//新たに敵に成ったものを記憶\n\t\t\t\ttemp[t] = ene;\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\tret = getMax(start + 1);\n\t\t//System.out.println(\"if \" + i +  \" is friend, ret =  \" + ret);\n\t\t\n\t\tret += power[i];\n\t\tfor(int j = 0; j < t; j++){\n\t\t\tmap[temp[j]] = UNDEF;\n\t\t}\n\t\t\n\t\t//敵\n\t\tmap[i] = ENEMY;\n\t\tint tmp = getMax(start + 1);\n\t\t//System.out.println(\"if \" + i +  \" is enemy, ret =  \" + tmp);\n\t\tif(tmp > ret){\n\t\t\t//System.out.println(i + \" is Enemy \");\n\t\t\tret = tmp;\n\t\t}\n\t\t//UNDEFに戻す\n\t\tmap[i] = UNDEF;\n\t\t\n\t\t//System.out.println(\"i = \" + i + \", ret = \" + ret + \", start = \" + start);\n\t\treturn ret;\n\t}\n\t\n\tpublic static void printMap(){\n\t\tfor(int i : map){\n\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic static void printList(int index){\n\t\tfor(int i : list[index]){\n\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tHashMap<String, Integer> civ2int;\n\tCiv[] civs;\n\tint max;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tcivs = new Civ[n];\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tint ind = 0;\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint val = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tString[] neighbor = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tneighbor[j] = sc.next();\n\t\t\t\t}\n\t\t\t\tcivs[i] = new Civ(name, val, neighbor);\n\t\t\t\tciv2int.put(name, ind++);\n\t\t\t}\n\t\t\t\n\t\t\tint tmp = civs[0].val;\n\t\t\tcivs[0].val = 10000;\n\t\t\tsort(civs);\n\t\t\tcivs[0].val = tmp;\n\t\t\t\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) civ2int.put(civs[i].name, i);\n\t\t\tdebug(civ2int);\n\t\t\tfor(Civ civ: civs) {\n\t\t\t\tciv.setEnemy();\n\t\t\t\tdebug(civ.name, civ.enemy, civ.val, civ.neighbor);\n\t\t\t\t\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tdfs(0, 0, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemyes, int val) {\n\t\tdebug(x, enemyes, (enemyes >> x), val);\n\t\tif( x == n ) {\n\t\t\tmax = max( max, val );\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemyes >> x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemyes,  val);\n\t\t\treturn;\n\t\t}\n\t\tif( (enemyes >> x) == 0 ) {\n\t\t\tdfs(x+1, enemyes|civs[x].enemy, val+civs[x].val);\n\t\t\treturn;\n\t\t}\n\t\tenemyes += 1<<x;\n\t\tdfs(x+1, enemyes|civs[x].enemy, val+civs[x].val);\n\t\tenemyes -= 1<<x;\n\t\tif(x!=0) dfs(x+1, enemyes, val);\n\t}\n\t\n\tclass Civ implements Comparable<Civ> {\n\t\tString name;\n\t\tint val;\n\t\tString[] neighbor;\n\t\tlong enemy;\n\t\tCiv (String name,int val, String[] neighbor) {\n\t\t\tthis.name = name;\n\t\t\tthis.val = val;\n\t\t\tthis.neighbor = neighbor;\n\t\t\tenemy = 0;\n\t\t}\n\t\t\n\t\tvoid setEnemy() {\n\t\t\tfor(String str: neighbor) {\n\t\t\t\tenemy |= 1 << (civ2int.get(str));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint neighborCost() {\n\t\t\tint sum = 0;\n\t\t\tfor(String str: neighbor) sum += civ2int.get(str);\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Civ o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn (o.val-o.neighborCost()) - (val-o.neighborCost());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])>Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tmis(0, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>_[k]&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\n\t\tif(1!=2){\n\t\t\treturn;\n\t\t}\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] costs;\n\tlong[] enemies;\n\tint n;\n\tint max;\n\tHashMap<String, Integer> name2int;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcosts = new int[n];\n\t\t\tenemies = new long[n];\n\t\t\tname2int = new HashMap<String, Integer>();\n\t\t\tString[][] names = new String[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tname2int.put(name, i);\n\t\t\t\tcosts[i] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tnames[i] = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tnames[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<names[i].length;j++){\n\t\t\t\tenemies[i] |= 1L<<name2int.get(names[i][j]);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) enemies[i] |= 1L<<i;\n\t\t\tmax = 0;\n\t\t\tdfs(1, enemies[0], costs[0]);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemy, int cost) {\n\t\tif( x == n ) {\n\t\t\tmax = max(max, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemy>>x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemy, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( notConnected(enemy, x) ) {\n\t\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(x+1, enemy, cost);\n\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t}\n\t\n\tboolean notConnected(long enemy, int x) {\n//\t\tfor(int i=0;i<n;i++) if( ((a>>i)&(b>>i)) == 1 ) return false;\n\t\tlong mask = 0;\n\t\tfor(int i=x+1;i<n;i++) if( ((enemy>>i)&1) == 0 ) mask |= enemies[i];\n\t\t\n\t\treturn ((mask>>x)&1) == 0;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\tstatic long[] sum;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tsum = new long[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\t\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\t\tsum[i] = (i + 1 < N ? sum[i + 1] : 0) + B[i];\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tid.clear();\n\t\t\tD = null;\n\t\t\tA=null;\n\t\t\topt = B[0];\n\t\t\tSystem.out.println(dfs(1, 1, B[0]) + B[0]);\n//\t\t\tif ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1000 < 450)\n//\t\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tstatic long opt;\n\n\tstatic long dfs(long used, int cur, long cursum) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tif (sum[cur] + cursum < opt) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, dfs(used | (1L << cur), cur + 1, cursum + B[cur]) + B[cur]);\n\t\t}\n\t\tif (!unadj) {\n\t\t\tres = Math.max(res, dfs(used, cur + 1, cursum));\n\t\t}\n\t\topt = Math.max(opt, cursum + res);\n\t\treturn res;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tmis(1, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// TODO\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&g[k])==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++)\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\tif((rem>>>k&1)==0)\n\t\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tString name = in.next();\n\t\t\t\tint pow = in.nextInt();\n\t\t\t\tint c = in.nextInt();\n\t\t\t\ttable.put(name, i);\n\t\t\t\tnode[i] = new Node(i, name, pow);\n\t\t\t\tfor(int j=0; j<c; j++){\n\t\t\t\t\tnode[i].names.add(in.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(String s: node[i].names){\n\t\t\t\t\tnode[i].createEdge(node[table.get(s)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQueue<Info> qu = new LinkedList<Info>();\n\t\t\tHM dp = new HM();\n\t\t\tqu.add(new Info(node[0].next, node[0].power));\n\t\t\tint res = 0;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tInfo s = qu.poll();\n\t\t\t\tif(!dp.put(s.used, s.power)) continue;\n\t\t\t\tres = Math.max(res, s.power);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif((s.used&1L<<i)>0) continue;\n\t\t\t\t\tif((~s.used & node[i].next & ~(1L<<i))>0) continue;\n\t\t\t\t\ts.used |= node[i].next;\n\t\t\t\t\ts.power += node[i].power;\n\t\t\t\t}\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif((s.used&1L<<i)>0) continue;\n\t\t\t\t\tqu.add(new Info(s.used|node[i].next, s.power+node[i].power));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}\n\nclass HM{\n\tHashMap<Long, Integer> dp = new HashMap<Long, Integer>();\n\tboolean put(long key, int pow){\n\t\tif(!dp.containsKey(key)){\n\t\t\tdp.put(key, pow);\n\t\t\treturn true;\n\t\t}\n\t\tint p = dp.get(key);\n\t\tif(p < pow){\n\t\t\tdp.put(key, pow);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nclass Info{\n\tlong used;\n\tint power;\n\tpublic Info(long u, int p){\n\t\tused = u;\n\t\tpower = p;\n\t}\n}\n\nclass Node{\n\tint id;\n\tString name;\n\tlong next;\n\tint power;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tArrayList<String> names = new ArrayList<String>();\n\tpublic Node(int id, String name, int power){\n\t\tthis.id = id;\n\t\tthis. name = name;\n\t\tthis.power = power;\n\t\tnext |= 1L<<id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tedge.add(nd);\n\t\tnext |= 1L<<nd.id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[] B;\n\tstatic boolean[][] g;\n\tstatic boolean[] used;\n\tstatic HashMap<Long, Integer> memo;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tCountry[] cs = new Country[N];\n\t\t\tused = new boolean[N];\n\t\t\tB = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tcs[i] = new Country();\n\t\t\t\tB[i] = cs[i].b;\n\t\t\t}\n\t\t\tused[0] = true;\n\t\t\tg = new boolean[N][N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (String o : cs[i].c) {\n\t\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\t\tif (o.equals(cs[j].a)) {\n\t\t\t\t\t\t\tg[i][j] = true;\n\t\t\t\t\t\t\tif (i == 0) used[j] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = B[0];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!used[i]) ans += solve(i);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int solve(int cur) {\n\t\tint pos = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tlist.add(cur);\n\t\tused[cur] = true;\n\t\twhile (pos < list.size()) {\n\t\t\tint c = list.get(pos++);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (g[c][i] && !used[i]) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tlist.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo = new HashMap<Long, Integer>();\n\t\treturn dfs(0, list, 0);\n\t}\n\n\tstatic int dfs(int pos, ArrayList<Integer> list, long st) {\n\t\tif (pos == list.size()) return 0;\n\t\tif (pos > 15 && memo.containsKey(st)) {\n\t\t\treturn memo.get(st);\n\t\t}\n\t\tint cur = list.get(pos);\n\n\t\t// not use cur\n\t\tint ret = dfs(pos + 1, list, st | (1L << cur));\n\n\t\t// use cur\n\t\tif ((st & (1L << cur)) == 0) {\n\t\t\tst |= 1L << cur;\n\t\t\tint sum = B[cur];\n\t\t\tfor (int i = pos + 1; i < list.size(); ++i) {\n\t\t\t\tif (g[cur][list.get(i)]) {\n\t\t\t\t\tst |= 1L << list.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dfs(pos + 1, list, st);\n\t\t\tret = Math.max(ret, sum);\n\t\t}\n\n\t\tif (pos > 15) {\n\t\t\tmemo.put(st, ret);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic class Country {\n\t\tString a;\n\t\tint b;\n\t\tString[] c;\n\n\t\tCountry() {\n\t\t\ta = sc.next();\n\t\t\tb = sc.nextInt();\n\t\t\tint cc = sc.nextInt();\n\t\t\tc = new String[cc];\n\t\t\tfor (int i = 0; i < cc; ++i) {\n\t\t\t\tc[i] = sc.next();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])<Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tmis(1, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\n\t\tif(false){\n\t\t\tif((choosed&(g[k]|(1L<<k)))==0){\n\t\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\t\t// long rem=0;\n\t\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\t\trem|=g[i];\n\t\t\t\t}\n\t\t\t\tif((rem>>>k&1)==0){\n\t\t\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[_[k]]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tmis(k+1, choosed, sum);\n\t\t}\n\n\t\tif(1!=2){\n\t\t\treturn;\n\t\t}\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>_[k]&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[k]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])<Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tmis(0, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>_[k]&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\n\t\tif(1!=2){\n\t\t\treturn;\n\t\t}\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\tstatic long[] sum;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tsum = new long[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\t\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\t\tsum[i] = (i + 1 < N ? sum[i + 1] : 0) + B[i];\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\topt = B[0];\n\t\t\tSystem.out.println(dfs(1, 1, B[0]) + B[0]);\n\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tstatic long opt;\n\n\tstatic long dfs(long used, int cur, long cursum) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tif (sum[cur] + cursum < opt) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, dfs(used | (1L << cur), cur + 1, cursum + B[cur]) + B[cur]);\n\t\t}\n\t\tif (!unadj) {\n\t\t\tres = Math.max(res, dfs(used, cur + 1, cursum));\n\t\t}\n\t\topt = Math.max(opt, cursum + res);\n\t\treturn res;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//The Enemy of My Enemy is My Friend\npublic class Main{\n\n\tMap<String, Integer> ref;\n\tint ID;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\n\tint N, res;\n\tint[] b;\n\tSet<Integer>[] adj;\n\tboolean[] u;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tadj = new Set[N];\n\t\t\tb = new int[N];\n\t\t\tfor(int i=0;i<N;i++)adj[i]=new HashSet<Integer>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint id = reg(sc.next());\n\t\t\t\tb[id] = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\twhile(c--!=0)adj[id].add(reg(sc.next()));\n\t\t\t}\n\t\t\tint[] MASK = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int x:adj[i])MASK[i]+=1<<x;\n\t\t\t}\n\t\t\tres = b[0];\n\t\t\tif(N<=18){\n\t\t\t\tfor(int S=(1<<(N-1))-1;S>0;S--){\n\t\t\t\t\tint v = 1+(S<<1), sum = 0;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0)sum+=b[i];\n\t\t\t\t\tif(sum<res)continue;\n\t\t\t\t\tboolean ok = true;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0&&(MASK[i]&v)!=0)ok=false;\n\t\t\t\t\tif(ok)res = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint K = 200000;\n\t\t\t\tSet<Long> u = new HashSet<Long>();\n\t\t\t\twhile(K--!=0){\n\t\t\t\t\tlong v = 1;\n\t\t\t\t\tint sum = 0;;\n\t\t\t\t\tRandom rand = new Random();\n\t\t\t\t\tfor(int i=1;i<N;i++)if(rand.nextBoolean()){\n\t\t\t\t\t\tv+=1<<i;\n\t\t\t\t\t\tsum += b[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(u.contains(v))continue;\n\t\t\t\t\tu.add(v);\n\t\t\t\t\tif(sum<res)continue;\n\t\t\t\t\tboolean ok = true;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0&&(MASK[i]&v)!=0)ok=false;\n\t\t\t\t\tif(ok)res=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//The Enemy of My Enemy is My Friend\npublic class Main{\n\n\tMap<String, Integer> ref;\n\tint ID;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\t\n\tint N, res;\n\tint[] sum, B;\n\tlong[] adj;\n\t\n\tvoid f(int k, int score, long mask){\n\t\tres = Math.max(res, score);\n\t\tif(k==N)return;\n\t\tif(score+sum[k]<=res)return;\n\t\tif(((mask>>k)&1)==0)f(k+1, score+B[k], mask|adj[k]);\n\t\tf(k+1, score, mask);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tadj = new long[N];\n\t\t\tB = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint id = reg(sc.next());\n\t\t\t\tB[id] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\twhile(m--!=0)adj[id]+=1L<<reg(sc.next());\n\t\t\t}\n\t\t\tsum = new int[N+1];\n\t\t\tfor(int i=N-1;i>=0;i--)sum[i]=sum[i+1]+B[i];\n\t\t\tres = 0;\n\t\t\tf(1, B[0], adj[0]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\tstatic long[] sum;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tsum = new long[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\t\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\t\tsum[i] = (i + 1 < N ? sum[i + 1] : 0) + B[i];\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\topt = B[0];\n\t\t\tSystem.out.println(dfs(1, 1, B[0]) + B[0]);\n\t\t\t// System.out.println(opt);\n\t\t}\n\t}\n\n\tstatic long opt;\n\n\tstatic long dfs(long used, int cur, long cursum) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tif (sum[cur] + cursum < opt) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, dfs(used | (1L << cur), cur + 1, cursum + B[cur]) + B[cur]);\n\t\t}\n\t\tif (!unadj) {\n\t\t\tres = Math.max(res, dfs(used, cur + 1, cursum));\n\t\t}\n\t\topt = Math.max(opt, cursum + res);\n\t\treturn res;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//The Enemy of My Enemy is My Friend\npublic class Main{\n\n\tMap<String, Integer> ref;\n\tint ID;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\n\tint N, res;\n\tint[] b;\n\tSet<Integer>[] adj;\n\tboolean[] u;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tadj = new Set[N];\n\t\t\tb = new int[N];\n\t\t\tfor(int i=0;i<N;i++)adj[i]=new HashSet<Integer>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint id = reg(sc.next());\n\t\t\t\tb[id] = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\twhile(c--!=0)adj[id].add(reg(sc.next()));\n\t\t\t}\n\t\t\tint[] MASK = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int x:adj[i])MASK[i]+=1<<x;\n\t\t\t}\n\t\t\tres = b[0];\n\t\t\tif(N<=18){\n\t\t\t\tfor(int S=(1<<(N-1))-1;S>0;S--){\n\t\t\t\t\tint v = 1+(S<<1), sum = 0;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0)sum+=b[i];\n\t\t\t\t\tif(sum<res)continue;\n\t\t\t\t\tboolean ok = true;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0&&(MASK[i]&v)!=0)ok=false;\n\t\t\t\t\tif(ok)res = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint K = 750000;\n\t\t\t\tSet<Long> u = new HashSet<Long>();\n\t\t\t\twhile(K--!=0){\n\t\t\t\t\tlong v = 1;\n\t\t\t\t\tint sum = 0;;\n\t\t\t\t\tRandom rand = new Random();\n\t\t\t\t\tfor(int i=1;i<N;i++)if(rand.nextBoolean()){\n\t\t\t\t\t\tv+=1<<i;\n\t\t\t\t\t\tsum += b[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(u.contains(v))continue;\n\t\t\t\t\tu.add(v);\n\t\t\t\t\tif(sum<res)continue;\n\t\t\t\t\tboolean ok = true;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0&&(MASK[i]&v)!=0)ok=false;\n\t\t\t\t\tif(ok)res=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//国名\n\tpublic static String[] name;\n\t//軍事力\n\tpublic static int[] power;\n\t//隣接国の数\n\tpublic static int[] num;\n\t//隣接国のインデックス\n\tpublic static int[][] list;\n\t//敵味方マップ\n\tpublic static int[] map;\n\n\tpublic static final int UNDEF = 0;\n\tpublic static final int FRIEND = 1;\n\tpublic static final int ENEMY = 2;\n\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\t}\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\twhile(n != 0){\n\t\t\tname = new String[n];\n\t\t\tpower = new int[n];\n\t\t\tnum = new int[n];\n\t\t\tlist = new int[n][n];\n\t\t\tString[][] str = new String[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tpower[i] = sc.nextInt();\n\t\t\t\tnum[i] = sc.nextInt();\n\t\t\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\t\t\tstr[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\t//System.out.println(str + \"a\");\n\t\t\t}\n\t\t\t//strをlistにする\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(str[i][j].equals(name[k])){\n\t\t\t\t\t\t\tlist[i][j] = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println(str + \"a\");\n\t\t\t}\n\t\t\t\n\t\t\t//mapを作る\n\t\t\tmap = new int[n];\n\t\t\t//自分の国は味方\n\t\t\tmap[0] = FRIEND;\n\t\t\t//printList(0);\n\t\t\tfor(int i = 0; i < num[0]; i++){\n\t\t\t\tmap[list[0][i]] = ENEMY;\n\t\t\t}\n\t\t\tint tmp = 0;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tif(map[i] == UNDEF){\n\t\t\t\t\ttmp = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printMap();\n\t\t\tif(tmp < n){\n\t\t\t\tSystem.out.println(getMax(1) + power[0]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(power[0]);\n\t\t\t}\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\t//最大の軍事力を返す\n\t//startより後の國のみ考えれば良い\n\tpublic static int getMax(int start){\n\t\t//printMap();\n\t\tint ret = 0;\n\t\tint i;\n\t\tfor(i = start; i < n; i++){\n\t\t\tif(map[i] == UNDEF){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i == n - 1){\n\t\t\treturn power[i];\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn ret;\n\t\t}\n\t\t//味方\n\t\tmap[i] = FRIEND;\n\t\tint[] temp = new int[num[i]];\n\t\tint t = 0;\n\t\t//printList(i);\n\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\tint ene = list[i][j];\n\t\t\tif(map[ene] == UNDEF){\n\t\t\t\tmap[ene] = ENEMY;\n\t\t\t\t//新たに敵に成ったものを記憶\n\t\t\t\ttemp[t] = ene;\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\tret = getMax(start + 1);\n\t\t//System.out.println(\"if \" + i +  \" is friend, ret =  \" + ret);\n\t\t\n\t\tret += power[i];\n\t\tfor(int j = 0; j < t; j++){\n\t\t\tmap[temp[j]] = UNDEF;\n\t\t}\n\t\t\n\t\t//敵\n\t\tmap[i] = ENEMY;\n\t\tint tmp = getMax(start + 1);\n\t\t//System.out.println(\"if \" + i +  \" is enemy, ret =  \" + tmp);\n\t\tif(tmp > ret){\n\t\t\t//System.out.println(i + \" is Enemy \");\n\t\t\tret = tmp;\n\t\t}\n\t\telse{\n\t\t\t//System.out.println(i + \" is Friend \");\n\t\t}\n\n\t\t//System.out.println(\"i = \" + i + \", ret = \" + ret + \", start = \" + start);\n\n\t\treturn ret;\n\n\t}\n\t\n\tpublic static void printMap(){\n\t\tfor(int i : map){\n\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic static void printList(int index){\n\t\tfor(int i : list[index]){\n\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])<Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tmis(1, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[k]|(1L<<k)))==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\t}\n\t\t\tif((rem>>>k&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[_[k]]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\n\t\tif(1!=2){\n\t\t\treturn;\n\t\t}\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>_[k]&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[k]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Queue;\nimport java.util.Scanner;\n\npublic class Main{\n\tpublic static char[] s;\n\tpublic static void main(String[] args) throws IOException{\n\t\tScanner in = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = in.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> table = new HashMap<String, Integer>();\n\t\t\tNode[] node = new Node[n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tString name = in.next();\n\t\t\t\tint pow = in.nextInt();\n\t\t\t\tint c = in.nextInt();\n\t\t\t\ttable.put(name, i);\n\t\t\t\tnode[i] = new Node(i, name, pow);\n\t\t\t\tfor(int j=0; j<c; j++){\n\t\t\t\t\tnode[i].names.add(in.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tfor(String s: node[i].names){\n\t\t\t\t\tnode[i].createEdge(node[table.get(s)]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tQueue<Info> qu = new LinkedList<Info>();\n\t\t\tHM dp = new HM();\n\t\t\tqu.add(new Info(node[0].next, node[0].power));\n\t\t\tint res = 0;\n\t\t\twhile(!qu.isEmpty()){\n\t\t\t\tInfo s = qu.poll();\n\t\t\t\tif(!dp.put(s.used, s.power)) continue;\n\t\t\t\tres = Math.max(res, s.power);\n\t\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\t\tif((s.used&1L<<i)>0) continue;\n\t\t\t\t\tqu.add(new Info(s.used|node[i].next, s.power+node[i].power));\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n}\n\nclass HM{\n\tHashMap<Long, Integer> dp = new HashMap<Long, Integer>();\n\tboolean put(long key, int pow){\n\t\tif(!dp.containsKey(key)){\n\t\t\tdp.put(key, pow);\n\t\t\treturn true;\n\t\t}\n\t\tint p = dp.get(key);\n\t\tif(p < pow){\n\t\t\tdp.put(key, pow);\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n\nclass Info{\n\tlong used;\n\tint power;\n\tpublic Info(long u, int p){\n\t\tused = u;\n\t\tpower = p;\n\t}\n}\n\nclass Node{\n\tint id;\n\tString name;\n\tlong next;\n\tint power;\n\tArrayList<Node> edge = new ArrayList<Node>();\n\tArrayList<String> names = new ArrayList<String>();\n\tpublic Node(int id, String name, int power){\n\t\tthis.id = id;\n\t\tthis. name = name;\n\t\tthis.power = power;\n\t\tnext |= 1L<<id;\n\t}\n\t\n\tpublic void createEdge(Node nd){\n\t\tedge.add(nd);\n\t\tnext |= 1L<<nd.id;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Random;\nimport java.util.Scanner;\nimport java.util.Set;\n\n//The Enemy of My Enemy is My Friend\npublic class Main{\n\n\tMap<String, Integer> ref;\n\tint ID;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\n\tint N, res;\n\tint[] b;\n\tSet<Integer>[] adj;\n\tboolean[] u;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tadj = new Set[N];\n\t\t\tb = new int[N];\n\t\t\tfor(int i=0;i<N;i++)adj[i]=new HashSet<Integer>();\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint id = reg(sc.next());\n\t\t\t\tb[id] = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\twhile(c--!=0)adj[id].add(reg(sc.next()));\n\t\t\t}\n\t\t\tint[] MASK = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int x:adj[i])MASK[i]+=1<<x;\n\t\t\t}\n\t\t\tres = b[0];\n\t\t\tif(N<=18){\n\t\t\t\tfor(int S=(1<<(N-1))-1;S>0;S--){\n\t\t\t\t\tint v = 1+(S<<1), sum = 0;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0)sum+=b[i];\n\t\t\t\t\tif(sum<res)continue;\n\t\t\t\t\tboolean ok = true;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0&&(MASK[i]&v)!=0)ok=false;\n\t\t\t\t\tif(ok)res = sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse{\n\t\t\t\tint K = 100000;\n\t\t\t\tSet<Long> u = new HashSet<Long>();\n\t\t\t\twhile(K--!=0){\n\t\t\t\t\tlong v = 1;\n\t\t\t\t\tint sum = 0;;\n\t\t\t\t\tRandom rand = new Random();\n\t\t\t\t\tfor(int i=1;i<N;i++)if(rand.nextBoolean()){\n\t\t\t\t\t\tv+=1<<i;\n\t\t\t\t\t\tsum += b[i];\n\t\t\t\t\t}\n\t\t\t\t\tif(u.contains(v))continue;\n\t\t\t\t\tu.add(v);\n\t\t\t\t\tif(sum<res)continue;\n\t\t\t\t\tboolean ok = true;\n\t\t\t\t\tfor(int i=0;i<N;i++)if(((v>>i)&1)>0&&(MASK[i]&v)!=0)ok=false;\n\t\t\t\t\tif(ok)res=sum;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\tstatic long[] sum;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tsum = new long[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\t\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\t\tsum[i] = (i + 1 < N ? sum[i + 1] : 0) + B[i];\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tid.clear();\n\t\t\tD = null;\n\t\t\tA = null;\n\t\t\topt = B[0];\n\t\t\tSystem.out.println(dfs(1, 1, B[0]) + B[0]);\n\t\t\tB = null;\n\t\t\tC = null;\n//\t\t\tif ((Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory()) / 1000 < 450)\n//\t\t\t\tSystem.gc();\n\t\t}\n\t}\n\n\tstatic long opt;\n\n\tstatic long dfs(long used, int cur, long cursum) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tif (sum[cur] + cursum < opt) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, dfs(used | (1L << cur), cur + 1, cursum + B[cur]) + B[cur]);\n\t\t}\n\t\tif (!unadj) {\n\t\t\tres = Math.max(res, dfs(used, cur + 1, cursum));\n\t\t}\n\t\topt = Math.max(opt, cursum + res);\n\t\treturn res;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[] B;\n\tstatic boolean[][] g;\n\tstatic boolean[] used;\n\tstatic HashMap<Long, Integer> memo;\n\tstatic long[] mask;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tCountry[] cs = new Country[N];\n\t\t\tused = new boolean[N];\n\t\t\tB = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tcs[i] = new Country();\n\t\t\t\tB[i] = cs[i].b;\n\t\t\t}\n\t\t\tused[0] = true;\n\t\t\tg = new boolean[N][N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (String o : cs[i].c) {\n\t\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\t\tif (o.equals(cs[j].a)) {\n\t\t\t\t\t\t\tg[i][j] = true;\n\t\t\t\t\t\t\tif (i == 0) used[j] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = B[0];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!used[i]) ans += solve(i);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int solve(int cur) {\n\t\tint pos = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tlist.add(cur);\n\t\tused[cur] = true;\n\t\twhile (pos < list.size()) {\n\t\t\tint c = list.get(pos++);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (g[c][i] && !used[i]) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tlist.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask = new long[list.size()];\n\t\tfor (int i = 0; i < list.size(); ++i) {\n\t\t\tfor (int j = 0; j < list.size(); ++j) {\n\t\t\t\tif (g[list.get(i)][list.get(j)]) {\n\t\t\t\t\tmask[i] |= 1L << list.get(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask[i] |= 1L << list.get(i);\n\t\t}\n\t\tmemo = new HashMap<Long, Integer>();\n\t\treturn dfs(0, list, 0);\n\t}\n\n\tstatic int dfs(int pos, ArrayList<Integer> list, long st) {\n\t\tif (pos == list.size()) return 0;\n\t\tif (pos > 20 && memo.containsKey(((long) pos << 50) | st)) {\n\t\t\treturn memo.get(((long) pos << 50) | st);\n\t\t}\n\t\tint cur = list.get(pos);\n\n\t\t// not use cur\n\t\tint ret = dfs(pos + 1, list, st | (1L << cur));\n\n\t\t// use cur\n\t\tif ((st & (1L << cur)) == 0) {\n\t\t\tint sum = B[cur];\n\t\t\tsum += dfs(pos + 1, list, st | mask[pos]);\n\t\t\tret = Math.max(ret, sum);\n\t\t}\n\n\t\tif (pos > 20) {\n\t\t\tmemo.put(((long) pos << 50) | st, ret);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic class Country {\n\t\tString a;\n\t\tint b;\n\t\tString[] c;\n\n\t\tCountry() {\n\t\t\ta = sc.next();\n\t\t\tb = sc.nextInt();\n\t\t\tint cc = sc.nextInt();\n\t\t\tc = new String[cc];\n\t\t\tfor (int i = 0; i < cc; ++i) {\n\t\t\t\tc[i] = sc.next();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tArrayList<Integer> group;\n\tint [] notused, power;\n\tint resDfs;\n\tArrayList<ArrayList<Integer>> otherListInd;\n\tboolean [] used;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> toindex = new HashMap<String, Integer>();\n\t\t\tArrayList<ArrayList<String>> otherList = new ArrayList<ArrayList<String>>();\n\t\t\tpower = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\totherList.add(new ArrayList<String>());\n\t\t\t\tString name = sc.next();\n\t\t\t\ttoindex.put(name, i);\n\t\t\t\tpower[i] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\twhile(m-- > 0){\n\t\t\t\t\tString other = sc.next();\n\t\t\t\t\totherList.get(i).add(other);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherListInd = new ArrayList<ArrayList<Integer>>();\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\totherListInd.add(new ArrayList<Integer>());\n\t\t\t\tfor(int j = 0; j < otherList.get(i).size(); j++){\n\t\t\t\t\tString temp = otherList.get(i).get(j);\n\t\t\t\t\tint ind = toindex.get(temp);\n\t\t\t\t\totherListInd.get(i).add(ind);\n\t\t\t\t\tuf.unite(i, ind);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tboolean [] searched = new boolean[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint root = uf.find(i);\n\t\t\t\tif(searched[root]) continue;\n\t\t\t\tsearched[root] = true;\n\t\t\t\tgroup = new ArrayList<Integer>();\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(root == uf.find(j)){\n\t\t\t\t\t\tgroup.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresDfs = 0;\n\t\t\t\tnotused = new int[n];\n\t\t\t\tused = new boolean[n];\n\t\t\t\tdfs(0, 0);\n\t\t\t\tsum += resDfs;\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tprivate void dfs(int deep, int sum) {\n\t\tif(deep == group.size()){\n\t\t\tresDfs = Math.max(sum, resDfs);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\t//use\n\t\tint nowind = group.get(deep);\n\t\tboolean flg = true;\n\t\tused[nowind] = true;\n\t\t\n\t\tif(notused[nowind] == 0){\n\t\t\tboolean AllT = true;\n\t\t\tfor(int i = 0; i < otherListInd.get(nowind).size(); i++){\n\t\t\t\tint otherind = otherListInd.get(nowind).get(i);\n\t\t\t\tif(! used[otherind]){\n\t\t\t\t\tAllT = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(AllT) flg = false;\n\t\t\t\n\t\t\tfor(int i = 0; i < otherListInd.get(nowind).size(); i++){\n\t\t\t\tint otherind = otherListInd.get(nowind).get(i);\n\t\t\t\tnotused[otherind]++;\n\t\t\t}\n\t\t\tdfs(deep + 1, sum + power[nowind]);\n\t\t\tfor(int i = 0; i < otherListInd.get(nowind).size(); i++){\n\t\t\t\tint otherind = otherListInd.get(nowind).get(i);\n\t\t\t\tnotused[otherind]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//notuse\n\t\tif(nowind != 0 && flg){\n\t\t\tdfs(deep + 1, sum);\n\t\t}\n\t\tused[nowind] = false;\n\t}\n\n\tclass UnionFind{\n\t\tint [] par, rank;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t\t//rank[i] = 0;\n\t\t\t}\n\t\t\tnum = n;\n\t\t}\n\t\tint find(int x){\n\t\t\tif(par[x] == x)return x;\n\t\t\telse return par[x] = find(par[x]);\n\t\t}\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return ;\n\t\t\tif(rank[x] < rank[y]) par[x] = y;\n\t\t\telse{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t\tnum--;\n\t\t}\n\t\tboolean same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tmis(1, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(covered), Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nimport javax.xml.bind.ParseConversionEvent;\n\npublic class Main {\n\n\tpublic static int dfs(int cur, final int N, int[] powers, boolean[][] adj, long block, ArrayList<HashMap<Long, Integer>> memo){\n\t\tif(memo.get(cur).containsKey(block)){\n\t\t\treturn memo.get(cur).get(block);\n\t\t}\n\t\t\n\t\tlong next_block = block;\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif((block & (1 << i)) == 0 && (cur == i || adj[cur][i])){\n\t\t\t\tnext_block |= (1 << i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int pos = cur + 1; pos < N; pos++){\n\t\t\tif((next_block & (1 << pos)) == 0){\n\t\t\t\tret = Math.max(ret, dfs(pos, N, powers, adj, next_block, memo));\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.get(cur).put(next_block, ret + powers[cur]);\n\t\treturn ret + powers[cur];\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tString[] names = new String[N];\n\t\t\tint[] powers = new int[N];\n\t\t\tint[] adjusts = new int[N];\n\t\t\tString[][] ad_names = new String[N][];\n\t\t\t\n\t\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnames[i] = sc.next();\n\t\t\t\tmap.put(names[i], i);\n\t\t\t\tpowers[i] = sc.nextInt();\n\t\t\t\tadjusts[i] = sc.nextInt();\n\t\t\t\tad_names[i] = new String[adjusts[i]];\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tad_names[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] adj = new boolean[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tadj[i][map.get(ad_names[i][j])] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<HashMap<Long, Integer>> maps = new ArrayList<HashMap<Long,Integer>>();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tmaps.add(new HashMap<Long, Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, N, powers, adj, 0L, maps));\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tlong[] memo;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tString s=Long.toBinaryString(g[i]);\n\t\t\tfor(; s.length()<n; s=\"0\"+s);\n\t\t\t// debug(s);\n\t\t}\n\n\t\tans=0;\n\t\tmemo=new long[n];\n\t\tfor(int i=n-2; i>=0; i--){\n\t\t\tmemo[i]=memo[i+1]|g[i+1];\n\t\t}\n\t\tmis(1, 1|g[0], 1, pow[0]);\n\t\t// debug(ans);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long covered, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(covered), Long.toBinaryString(choosed));\n\n\t\t// long choosed\n\t\t// long\n\t\t// 今まで使った頂点とこれから使うかどうか決める頂点のどれとも隣接していない頂点はかならず使う\n\n\t\t// covered & (g[k] | (1L<<k)) != 0\n\t\t// 使わん\n\t\t// (covered | memo[k]) & (g[k] | (1L<<k)) == 0\n\n\t\t// Aの時，aだけ\n\t\t// Bの時，bだけ\n\t\t// それ以外，aとb\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\t// つかわん\n\t\t\tmis(k+1, covered, choosed, sum);\n\t\t\treturn;\n\t\t}\n\t\tlong korekara=((1L<<n)-1)^((1L<<(k+1))-1);\n\t\tif(((choosed|korekara)&(g[k]|(1L<<k)))==0){\n\t\t\tmis(k+1, covered|(g[k]|(1L<<k)), choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, covered, choosed, sum);\n\t\tmis(k+1, covered|(g[k]|(1L<<k)), choosed|(1L<<k), sum+pow[k]);\n\n\t\t// 両方か，片方か\n\n\t\t// g[k]\n\n\t\t// mis(k+1, choosed, temp|(1L<<k));\n\t\t// mis(k+1, choosed|(1L<<k), temp|g[k]);\n\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])<Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tmis(1, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\t\t/*\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t*/\n\t\tif((choosed&(g[k]|(1L<<k)))==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\t}\n\t\t\tif((rem>>>k&1)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>_[k]&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[k]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])<Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tmis(0, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[k]|(1L<<k)))==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\t}\n\t\t\tif((rem>>>k&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[_[k]]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\n\t\tif(1!=2){\n\t\t\treturn;\n\t\t}\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>_[k]&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[k]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int i=n-1; i>=1; i--){\n\t\t\tint j=(int)(random()*(i+1));\n\t\t\tint t=_[i];\n\t\t\t_[i]=_[j];\n\t\t\t_[j]=t;\n\t\t}\n\t\tif(false)\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\t\tif(Long.bitCount(g[_[i]])>Long.bitCount(g[_[j]])){\n\t\t\t\t\t\tint t=_[i];\n\t\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t\t_[j]=t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tans=0;\n\t\t// mis(1, 1, pow[0]);\n\t\tmis_(0, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis_(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>>_[k]&1)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmis_(k+1, choosed, sum);\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&(g[k]|(1L<<k)))==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\t}\n\t\t\tif((rem>>>k&1)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\tstatic long[] sum;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tsum = new long[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\t\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\t\tsum[i] = (i + 1 < N ? sum[i + 1] : 0) + B[i];\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tid.clear();\n\t\t\tD = null;\n\t\t\tA = null;\n\t\t\topt = B[0];\n\t\t\tSystem.out.println(dfs(1, 1, B[0]) + B[0]);\n\t\t\tB = null;\n\t\t\tC = null;\n\t\t\tsum = null;\n\t\t\t System.gc();\n\t\t}\n\t}\n\n\tstatic long opt;\n\n\tstatic long dfs(long used, int cur, long cursum) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tif (sum[cur] + cursum < opt) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, dfs(used | (1L << cur), cur + 1, cursum + B[cur]) + B[cur]);\n\t\t}\n\t\tif (!unadj) {\n\t\t\tres = Math.max(res, dfs(used, cur + 1, cursum));\n\t\t}\n\t\topt = Math.max(opt, cursum + res);\n\t\treturn res;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nimport javax.xml.bind.ParseConversionEvent;\n\npublic class Main {\n\n\tpublic static int dfs(int cur, final int N, int[] powers, boolean[][] adj, long block, ArrayList<HashMap<Long, Integer>> memo){\n\t\tif(memo.get(cur).containsKey(block & ((1 << (N - cur)) -1))){\n\t\t\treturn memo.get(cur).get(block & ((1 << (N - cur)) - 1));\n\t\t}\n\t\t\n\t\tlong next_block = block;\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif((block & (1 << i)) == 0 && (cur == i || adj[cur][i])){\n\t\t\t\tnext_block |= (1 << i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int pos = cur + 1; pos < N; pos++){\n\t\t\tif((next_block & (1 << pos)) == 0){\n\t\t\t\tret = Math.max(ret, dfs(pos, N, powers, adj, next_block, memo));\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.get(cur).put(block & ((1 << (N - cur)) - 1), ret + powers[cur]);\n\t\treturn ret + powers[cur];\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tString[] names = new String[N];\n\t\t\tint[] powers = new int[N];\n\t\t\tint[] adjusts = new int[N];\n\t\t\tString[][] ad_names = new String[N][];\n\t\t\t\n\t\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnames[i] = sc.next();\n\t\t\t\tmap.put(names[i], i);\n\t\t\t\tpowers[i] = sc.nextInt();\n\t\t\t\tadjusts[i] = sc.nextInt();\n\t\t\t\tad_names[i] = new String[adjusts[i]];\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tad_names[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] adj = new boolean[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tadj[i][map.get(ad_names[i][j])] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<HashMap<Long, Integer>> maps = new ArrayList<HashMap<Long,Integer>>();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tmaps.add(new HashMap<Long, Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, N, powers, adj, 0L, maps));\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] count;\n\tstatic boolean[][] g;\n\tstatic boolean[] used;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tCountry[] cs = new Country[N];\n\t\t\tused = new boolean[N];\n\t\t\tB = new int[N];\n\t\t\tcount = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tcs[i] = new Country();\n\t\t\t\tB[i] = cs[i].b;\n\t\t\t}\n\t\t\tused[0] = true;\n\t\t\tg = new boolean[N][N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (String o : cs[i].c) {\n\t\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\t\tif (o.equals(cs[j].a)) {\n\t\t\t\t\t\t\tg[i][j] = true;\n\t\t\t\t\t\t\tif (i == 0) used[j] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = B[0];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!used[i]) ans += solve(i);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int solve(int cur) {\n\t\tint pos = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tlist.add(cur);\n\t\tused[cur] = true;\n\t\twhile (pos < list.size()) {\n\t\t\tint c = list.get(pos++);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (g[c][i] && !used[i]) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tlist.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn dfs(0, list);\n\t}\n\n\tstatic int dfs(int pos, ArrayList<Integer> list) {\n\t\tif (pos == list.size()) return 0;\n\t\tint ret = 0;\n\t\tint cur = list.get(pos);\n\n\t\t// use cur\n\t\tif (count[cur] == 0) {\n\t\t\tint sum = B[cur];\n\t\t\tfor (int i = pos + 1; i < list.size(); ++i) {\n\t\t\t\tif (g[cur][list.get(i)]) {\n\t\t\t\t\tcount[list.get(i)]++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dfs(pos + 1, list);\n\t\t\tfor (int i = pos + 1; i < list.size(); ++i) {\n\t\t\t\tif (g[cur][list.get(i)]) {\n\t\t\t\t\tcount[list.get(i)]--;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret = sum;\n\t\t}\n\n\t\t// not use cur\n\t\tret = Math.max(ret, dfs(pos + 1, list));\n\n\t\treturn ret;\n\t}\n\n\tstatic class Country {\n\t\tString a;\n\t\tint b;\n\t\tString[] c;\n\n\t\tCountry() {\n\t\t\ta = sc.next();\n\t\t\tb = sc.nextInt();\n\t\t\tint cc = sc.nextInt();\n\t\t\tc = new String[cc];\n\t\t\tfor (int i = 0; i < cc; ++i) {\n\t\t\t\tc[i] = sc.next();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tlong ans = 0;\n\n\t\t\tans = Math.max(ans, dfs(1, 1) + B[0]);\n\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic long dfs(long used, int cur) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (!unrestriected && unadj)\n\t\t\tthrow new AssertionError();\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, res + dfs(used | (1L << cur), cur + 1) + B[cur]);\n\t\t}\n\t\tif (!unadj)\n\t\t\tres = Math.max(res, dfs(used, cur + 1));\n\t\treturn res;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nimport javax.xml.bind.ParseConversionEvent;\n\npublic class Main {\n\n\tpublic static int dfs(int cur, final int N, int[] powers, boolean[][] adj, long block, ArrayList<HashMap<Long, Integer>> memo){\n\t\tif(memo.get(cur).containsKey(block & ((1 << (N - cur)) -1))){\n\t\t\treturn memo.get(cur).get(block & ((1 << (N - cur)) - 1));\n\t\t}\n\t\t\n\t\tlong next_block = block;\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif((block & (1 << i)) == 0 && (cur == i || adj[cur][i])){\n\t\t\t\tnext_block |= (1 << i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int pos = cur + 1; pos < N; pos++){\n\t\t\tif((next_block & (1 << pos)) == 0){\n\t\t\t\tret = Math.max(ret, dfs(pos, N, powers, adj, next_block, memo));\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.get(cur).put(block & ((1 << (N - cur)) - 1), ret + powers[cur]);\n\t\treturn ret + powers[cur];\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tString[] names = new String[N];\n\t\t\tint[] powers = new int[N];\n\t\t\tint[] adjusts = new int[N];\n\t\t\tString[][] ad_names = new String[N][];\n\t\t\t\n\t\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnames[i] = sc.next();\n\t\t\t\tmap.put(names[i], i);\n\t\t\t\tpowers[i] = sc.nextInt();\n\t\t\t\tadjusts[i] = sc.nextInt();\n\t\t\t\tad_names[i] = new String[adjusts[i]];\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tad_names[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] adj = new boolean[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tadj[i][map.get(ad_names[i][j])] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<HashMap<Long, Integer>> maps = new ArrayList<HashMap<Long,Integer>>();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tmaps.add(new HashMap<Long, Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, N, powers, adj, 0L, maps));\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tHashMap<String, Integer> civ2int;\n\tCiv[] civs;\n\tboolean[] visited;\n\tint max;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tcivs = new Civ[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint val = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tString[] neighbor = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tneighbor[j] = sc.next();\n\t\t\t\t}\n\t\t\t\tcivs[i] = new Civ(name, val, neighbor);\n\t\t\t}\n\t\t\t\n\t\t\tint tmp = civs[0].val;\n\t\t\tcivs[0].val = 10000;\n\t\t\tsort(civs);\n\t\t\tcivs[0].val = tmp;\n\t\t\t\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) civ2int.put(civs[i].name, i);\n\t\t\tdebug(civ2int);\n\t\t\tfor(Civ civ: civs) debug(civ.name, civ.val, civ.neighbor);\n\t\t\tmax = 0;\n\t\t\tvisited = new boolean[n];\n\t\t\tdfs(0, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, int val) {\n\t\tdebug(x, val);\n\t\tdebug(visited);\n\t\tif( x == n ) {\n\t\t\tmax = max( max, val );\n\t\t\treturn;\n\t\t}\n\t\tif( visited[x] ) {\n\t\t\tdfs(x+1, val);\n\t\t\treturn;\n\t\t}\n\t\tvisited[x] = true;\n\t\tboolean flg = false;\n\t\tfor(String neighbor: civs[x].neighbor) {\n\t\t\tint next = civ2int.get(neighbor);\n\t\t\tflg |= visited[ next ];\n\t\t\tvisited[next] = true;\n\t\t}\n\t\tdfs(x+1, val+civs[x].val);\n\t\tvisited[x] = false;\n\t\tif(flg && x != 0) dfs(x+1, val);\n\t\tfor(String neighbor: civs[x].neighbor) {\n\t\t\tint next = civ2int.get(neighbor);\n\t\t\tvisited[next] = false;\n\t\t}\n\t}\n\t\n\tclass Civ implements Comparable<Civ> {\n\t\tString name;\n\t\tint val;\n\t\tString[] neighbor;\n\t\tCiv (String name,int val, String[] neighbor) {\n\t\t\tthis.name = name;\n\t\t\tthis.val = val;\n\t\t\tthis.neighbor = neighbor;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(Civ o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn o.val - val;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nimport javax.xml.bind.ParseConversionEvent;\n\npublic class Main {\n\n\tpublic static int dfs(int cur, final int N, int[] powers, boolean[][] adj, long block, ArrayList<HashMap<Long, Integer>> memo){\n\t\tif(memo.get(cur).containsKey(block & ((1 << (N - cur)) -1))){\n\t\t\treturn memo.get(cur).get(block & ((1 << (N - cur)) - 1));\n\t\t}\n\t\t\n\t\tlong next_block = block;\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif((block & (1 << i)) == 0 && (cur == i || adj[cur][i])){\n\t\t\t\tnext_block |= (1 << i);\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int pos = cur + 1; pos < N; pos++){\n\t\t\tif((next_block & (1 << pos)) == 0){\n\t\t\t\tret = Math.max(ret, dfs(pos, N, powers, adj, next_block, memo));\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.get(cur).put(block & ((1 << (N - cur)) - 1), ret + powers[cur]);\n\t\treturn ret + powers[cur];\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tString[] names = new String[N];\n\t\t\tint[] powers = new int[N];\n\t\t\tint[] adjusts = new int[N];\n\t\t\tString[][] ad_names = new String[N][];\n\t\t\t\n\t\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnames[i] = sc.next();\n\t\t\t\tmap.put(names[i], i);\n\t\t\t\tpowers[i] = sc.nextInt();\n\t\t\t\tadjusts[i] = sc.nextInt();\n\t\t\t\tad_names[i] = new String[adjusts[i]];\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tad_names[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] adj = new boolean[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tadj[i][map.get(ad_names[i][j])] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<HashMap<Long, Integer>> maps = new ArrayList<HashMap<Long,Integer>>();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tmaps.add(new HashMap<Long, Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, N, powers, adj, 0L, maps));\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tint n;\n\n\tclass Country{\n\t\tint id;\n\t\tint string;\n\t\tlong enemy;\n\t\tList<String> Node=new ArrayList<String>();\n\n\t\tpublic void parseNode(){\n\t\t\tenemy=0;\n\t\t\tfor(String node:Node){\n\t\t\t\tenemy+=(1<<nametoId.get(node));\n\t\t\t}\n\t\t}\n\t}\n\n\tHashMap<String,Integer> nametoId;\n\n\tpublic void run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tnametoId=new HashMap<String, Integer>();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCountry[] colist=new Country[n];\n\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcolist[i]=new Country();\n\t\t\t\tString name=sc.next();\n\t\t\t\tint string=sc.nextInt();\n\t\t\t\tif(!nametoId.containsKey(name)){\n\t\t\t\t\tnametoId.put(name,nametoId.size());\n\t\t\t\t}\n\t\t\t\tcolist[i].id=i;\n\t\t\t\tcolist[i].string=string;\n\n\t\t\t\tint links=sc.nextInt();\n\n\t\t\t\tfor(int j=0;j<links;j++){\n\t\t\t\t\tString name1=sc.next();\n\t\t\t\t\tcolist[i].Node.add(name1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(Country c :colist){\n\t\t\t\tc.parseNode();\n\t\t\t}\n\n\t\t\tSet<Long> dp=new HashSet<Long>();\n\t\t\tdp.add(1L);\n\t\t\tint res=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(colist[i].enemy==0){\n\t\t\t\t\tres+=colist[i].string;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSet<Long> tmp=new HashSet<Long>();\n\t\t\t\tfor(Long d:dp){\n\t\t\t\t\tLong nxtmap=d+(1<<i);\n\t\t\t\t\tif((colist[i].enemy & nxtmap)==0){\n\t\t\t\t\t\ttmp.add(nxtmap);\n\t\t\t\t\t}else{\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp.addAll(tmp);\n\t\t\t}\n\t\t\tint max=0;\n\t\t\tfor(Long d:dp){\n\t\t\t\tint i=0;\n\t\t\t\tint val=0;\n\t\t\t\twhile(d>0){\n\t\t\t\t\tif(d%2==1){\n\t\t\t\t\t\tval+=colist[i].string;\n\t\t\t\t\t}\n\t\t\t\t\td/=2;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tmax=Math.max(val,max);\n\t\t\t}\n\t\t\tpr(max+res);\n\t\t}\n\t}\n\n\n\n\n\tpublic static void main(String[] _) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tHashMap<String, Integer> civ2int;\n\tCiv[] civs;\n\tint max;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tcivs = new Civ[n];\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tint ind = 0;\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint val = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tString[] neighbor = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tneighbor[j] = sc.next();\n\t\t\t\t}\n\t\t\t\tcivs[i] = new Civ(name, val, neighbor);\n\t\t\t\tciv2int.put(name, ind++);\n\t\t\t}\n\t\t\t\n\t\t\tint tmp = civs[0].val;\n\t\t\tcivs[0].val = 10000;\n\t\t\tsort(civs);\n\t\t\tcivs[0].val = tmp;\n\t\t\t\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) civ2int.put(civs[i].name, i);\n\t\t\tdebug(civ2int);\n\t\t\tfor(Civ civ: civs) {\n\t\t\t\tciv.setEnemy();\n//\t\t\t\tdebug(civ.name, civ.enemy, civ.val, civ.neighbor);\n\t\t\t\t\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tdfs(0, 0, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemyes, int val) {\n//\t\tdebug(x, enemyes, (enemyes >> x), val);\n\t\tif( x == n ) {\n\t\t\tmax = max( max, val );\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemyes >> x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemyes,  val);\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemyes|civs[x].enemy) >> x) == 0 ) {\n\t\t\tdfs(x+1, enemyes|civs[x].enemy, val+civs[x].val);\n\t\t\treturn;\n\t\t}\n\t\tenemyes += 1<<x;\n\t\tdfs(x+1, enemyes|civs[x].enemy, val+civs[x].val);\n\t\tenemyes -= 1<<x;\n\t\tif(x!=0) dfs(x+1, enemyes, val);\n\t}\n\t\n\tclass Civ implements Comparable<Civ> {\n\t\tString name;\n\t\tint val;\n\t\tString[] neighbor;\n\t\tlong enemy;\n\t\tCiv (String name,int val, String[] neighbor) {\n\t\t\tthis.name = name;\n\t\t\tthis.val = val;\n\t\t\tthis.neighbor = neighbor;\n\t\t\tenemy = 0;\n\t\t}\n\t\t\n\t\tvoid setEnemy() {\n\t\t\tfor(String str: neighbor) {\n\t\t\t\tenemy |= 1 << (civ2int.get(str));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint neighborCost() {\n\t\t\tint sum = 0;\n\t\t\tfor(String str: neighbor) sum += civ2int.get(str);\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Civ o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn (o.val-o.neighborCost()) - (val-o.neighborCost());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] costs;\n\tlong[] enemies;\n\tint n;\n\tint max;\n\tHashMap<String, Integer> name2int;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcosts = new int[n];\n\t\t\tenemies = new long[n];\n\t\t\tname2int = new HashMap<String, Integer>();\n\t\t\tString[][] names = new String[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tname2int.put(name, i);\n\t\t\t\tcosts[i] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tnames[i] = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tnames[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<names[i].length;j++){\n\t\t\t\tenemies[i] |= 1L<<name2int.get(names[i][j]);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) enemies[i] |= 1L<<i;\n\t\t\tmax = 0;\n\t\t\tdfs(1, enemies[0], costs[0]);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemy, int cost) {\n\t\tif( x == n ) {\n\t\t\tmax = max(max, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemy>>x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemy, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( notConnected(x) ) {\n\t\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(x+1, enemy, cost);\n\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t}\n\t\n\tboolean notConnected(int x) {\n//\t\tfor(int i=0;i<n;i++) if( ((a>>i)&(b>>i)) == 1 ) return false;\n\t\tlong mask = 0;\n\t\tfor(int i=x+1;i<n;i++) mask |= enemies[i];\n\t\t\n\t\treturn ((mask>>x)&1) == 0;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tHashMap<String, Integer> civ2int;\n\tCiv[] civs;\n\tint max;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tcivs = new Civ[n];\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tint ind = 0;\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint val = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tString[] neighbor = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tneighbor[j] = sc.next();\n\t\t\t\t}\n\t\t\t\tcivs[i] = new Civ(name, val, neighbor);\n\t\t\t\tciv2int.put(name, ind++);\n\t\t\t}\n\t\t\t\n\t\t\tint tmp = civs[0].val;\n\t\t\tcivs[0].val = 10000;\n\t\t\tsort(civs);\n\t\t\tcivs[0].val = tmp;\n\t\t\t\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) civ2int.put(civs[i].name, i);\n\t\t\tdebug(civ2int);\n\t\t\tfor(Civ civ: civs) {\n\t\t\t\tciv.setEnemy();\n\t\t\t\tdebug(civ.name, civ.enemy, civ.val, civ.neighbor);\n\t\t\t\t\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tdfs(0, 0, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemyes, int val) {\n\t\tdebug(x, enemyes, (enemyes >> x), val);\n\t\tif( x == n ) {\n\t\t\tmax = max( max, val );\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemyes >> x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemyes,  val);\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemyes|civs[x].enemy) >> x) == 0 ) {\n\t\t\tdfs(x+1, enemyes|civs[x].enemy, val+civs[x].val);\n\t\t\treturn;\n\t\t}\n\t\tenemyes += 1<<x;\n\t\tdfs(x+1, enemyes|civs[x].enemy, val+civs[x].val);\n\t\tenemyes -= 1<<x;\n\t\tif(x!=0) dfs(x+1, enemyes, val);\n\t}\n\t\n\tclass Civ implements Comparable<Civ> {\n\t\tString name;\n\t\tint val;\n\t\tString[] neighbor;\n\t\tlong enemy;\n\t\tCiv (String name,int val, String[] neighbor) {\n\t\t\tthis.name = name;\n\t\t\tthis.val = val;\n\t\t\tthis.neighbor = neighbor;\n\t\t\tenemy = 0;\n\t\t}\n\t\t\n\t\tvoid setEnemy() {\n\t\t\tfor(String str: neighbor) {\n\t\t\t\tenemy |= 1 << (civ2int.get(str));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint neighborCost() {\n\t\t\tint sum = 0;\n\t\t\tfor(String str: neighbor) sum += civ2int.get(str);\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Civ o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn (o.val-o.neighborCost()) - (val-o.neighborCost());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tprivate static final Scanner sc = new Scanner(System.in);\n\n\tpublic static void main(String... args) {\n\t\twhile (sc.hasNext()) {\n\t\t\tfinal int N = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tsolve(N);\n\t\t}\n\t}\n\n\tprivate static void solve(final int N) {\n\t\tsc.nextLine();\n\t\tfinal String[] lines = new String[N];\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tlines[i] = sc.nextLine();\n\t\tfinal Map<String, Integer> map = new HashMap<String, Integer>();\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tmap.put(lines[i].split(\" \", 2)[0], i);\n\t\tfinal int[] powers = new int[N];\n\t\tfinal long[] masks = new long[N];\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tfinal String[] ss = lines[i].split(\" \");\n\t\t\tpowers[i] = Integer.parseInt(ss[1]);\n\t\t\tmasks[i] = 1L << i;\n\t\t\tfinal int M = Integer.parseInt(ss[2]);\n\t\t\tfor (int j = 0; j < M; j++)\n\t\t\t\tmasks[i] |= 1L << map.get(ss[3 + j]);\n\t\t}\n\t\tSystem.out.println(powers[0] + dfs(N, 1, masks[0], powers, masks));\n\t}\n\n\tprivate static int dfs(final int N, final int c, final long used, final int[] powers, final long[] masks) {\n\t\tif (c == N)\n\t\t\treturn 0;\n\t\tint ret = 0;\n\t\tif ((used & 1L << c) == 0) {\n\t\t\tret = dfs(N, c + 1, used | masks[c], powers, masks) + powers[c];\n\t\t\tlong rem = 0L;\n\t\t\tfor (int k = c + 1; k < N; k++)\n\t\t\t\tif ((used & 1L << k) == 0)\n\t\t\t\t\trem |= masks[k];\n\t\t\tif ((rem & 1L << c) == 0)\n\t\t\t\treturn ret;\n\t\t}\n\t\treturn Math.max(ret, dfs(N, c + 1, used, powers, masks));\n\t}\n\n\tprivate static void debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])<Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\tmis(1, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\n\t\tif(false){\n\t\t\tif((choosed&(g[k]|(1L<<k)))==0){\n\t\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\t\t// long rem=0;\n\t\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\t\trem|=g[i];\n\t\t\t\t}\n\t\t\t\tif((rem>>>k&1)==0){\n\t\t\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[_[k]]);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tmis(k+1, choosed, sum);\n\t\t}\n\n\t\tif(1!=2){\n\t\t\treturn;\n\t\t}\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t//long rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>_[k]&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[k]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t */\n\t//国名\n\tpublic static String[] name;\n\t//軍事力\n\tpublic static int[] power;\n\t//隣接国の数\n\tpublic static int[] num;\n\t//隣接国のインデックス\n\tpublic static int[][] list;\n\t//敵味方マップ\n\tpublic static int[] map;\n\n\tpublic static final int UNDEF = 0;\n\tpublic static final int FRIEND = 1;\n\tpublic static final int ENEMY = 2;\n\n\tpublic static int n;\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tdoIt();\n\t}\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tn = sc.nextInt();\n\t\twhile(n != 0){\n\t\t\tname = new String[n];\n\t\t\tpower = new int[n];\n\t\t\tnum = new int[n];\n\t\t\tlist = new int[n][n];\n\t\t\tString[][] str = new String[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tname[i] = sc.next();\n\t\t\t\tpower[i] = sc.nextInt();\n\t\t\t\tnum[i] = sc.nextInt();\n\t\t\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\t\t\tstr[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\t//System.out.println(str + \"a\");\n\t\t\t}\n\t\t\t//strをlistにする\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(str[i][j].equals(name[k])){\n\t\t\t\t\t\t\tlist[i][j] = k;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//System.out.println(str + \"a\");\n\t\t\t}\n\t\t\t\n\t\t\t//mapを作る\n\t\t\tmap = new int[n];\n\t\t\t//自分の国は味方\n\t\t\tmap[0] = FRIEND;\n\t\t\t//printList(0);\n\t\t\tfor(int i = 0; i < num[0]; i++){\n\t\t\t\tmap[list[0][i]] = ENEMY;\n\t\t\t}\n\t\t\tint tmp = 0;\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tif(map[i] == UNDEF){\n\t\t\t\t\ttmp = i;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t//printMap();\n\t\t\tif(tmp < n){\n\t\t\t\tSystem.out.println(getMax(1) + power[0]);\n\t\t\t}\n\t\t\telse{\n\t\t\t\tSystem.out.println(power[0]);\n\t\t\t}\n\t\t}\n\t}\n\t//最大の軍事力を返す\n\t//startより後の國のみ考えれば良い\n\tpublic static int getMax(int start){\n\t\t//printMap();\n\t\tint ret = 0;\n\t\tint i;\n\t\tfor(i = start; i < n; i++){\n\t\t\tif(map[i] == UNDEF){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(i == n - 1){\n\t\t\treturn power[i];\n\t\t}\n\t\telse if(i >= n){\n\t\t\treturn ret;\n\t\t}\n\t\t//味方\n\t\tmap[i] = FRIEND;\n\t\tint[] temp = new int[num[i]];\n\t\tint t = 0;\n\t\t//printList(i);\n\t\tfor(int j = 0; j < num[i]; j++){\n\t\t\tint ene = list[i][j];\n\t\t\tif(map[ene] == UNDEF){\n\t\t\t\tmap[ene] = ENEMY;\n\t\t\t\t//新たに敵に成ったものを記憶\n\t\t\t\ttemp[t] = ene;\n\t\t\t\tt++;\n\t\t\t}\n\t\t}\n\t\tret = getMax(start + 1);\n\t\t//System.out.println(\"if \" + i +  \" is friend, ret =  \" + ret);\n\t\t\n\t\tret += power[i];\n\t\tfor(int j = 0; j < t; j++){\n\t\t\tmap[temp[j]] = UNDEF;\n\t\t}\n\t\t\n\t\t//敵\n\t\tmap[i] = ENEMY;\n\t\tint tmp = getMax(start + 1);\n\t\t//System.out.println(\"if \" + i +  \" is enemy, ret =  \" + tmp);\n\t\tif(tmp > ret){\n\t\t\t//System.out.println(i + \" is Enemy \");\n\t\t\tret = tmp;\n\t\t}\n\t\telse{\n\t\t\t//System.out.println(i + \" is Friend \");\n\t\t}\n\n\t\t//System.out.println(\"i = \" + i + \", ret = \" + ret + \", start = \" + start);\n\n\t\treturn ret;\n\n\t}\n\t\n\tpublic static void printMap(){\n\t\tfor(int i : map){\n\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\tpublic static void printList(int index){\n\t\tfor(int i : list[index]){\n\t\t\tSystem.out.print(i + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\thoge();\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid hoge(){\n\t\tif(1==1)return;\n\t\tn=10;\n\t\tg=new long[n];\n\t\tpow=new int[n];\n\t\tRandom rand=new Random(1);\n\t\tfor(int t=0; t<100; t++){\n\t\t\tint i=rand.nextInt(n);\n\t\t\tint j=rand.nextInt(n);\n\t\t\tif(i!=j){\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t\tg[j]|=1L<<i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tString s=Long.toBinaryString(g[i]);\n\t\t\tfor(; s.length()<n; s=\"0\"+s);\n\t\t\tdebug(s);\n\t\t}\n\t\tmis(0, 0, 0, 0);\n\t}\n\n\tlong[] g;\n\tlong[] memo;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tString s=Long.toBinaryString(g[i]);\n\t\t\tfor(; s.length()<n; s=\"0\"+s);\n\t\t\t// debug(s);\n\t\t}\n\n\t\tans=0;\n\t\tmemo=new long[n];\n\t\tfor(int i=n-2; i>=0; i--){\n\t\t\tmemo[i]=memo[i+1]|g[i+1];\n\t\t}\n\t\tmis(1, 1|g[0], 1, pow[0]);\n\t\t// debug(ans);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis_(int k, long used, int sum){\n\t}\n\t\n\tvoid mis(int k, long covered, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(covered), Long.toBinaryString(choosed));\n\n\t\t// long choosed\n\t\t// long\n\t\t// 今まで使った頂点とこれから使うかどうか決める頂点のどれとも隣接していない頂点はかならず使う\n\n\t\t// covered & (g[k] | (1L<<k)) != 0\n\t\t// 使わん\n\t\t// (covered | memo[k]) & (g[k] | (1L<<k)) == 0\n\n\t\t// Aの時，aだけ\n\t\t// Bの時，bだけ\n\t\t// それ以外，aとb\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\t// つかわん\n\t\t\tmis(k+1, covered, choosed, sum);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong rem=0;\n\t\tfor(int i=k+1;i<n;i++){\n\t\t\t// iが現状使えたら\n\t\t\tif\t((choosed&g[i])==0)\n//\t\t\t\tif((covered>>i&1)==0)\n\t\t\trem|=g[i];\n\t\t}\n\t\t\n\t\t// [0, n)-[0, k+1) = [k+1, n)\n\t\tlong korekara=((1L<<n)-1)^((1L<<(k+1))-1);\n//\t\tif(((choosed|korekara)&(g[k]|(1L<<k)))==0){\n\t\tif((rem>>k&1)==0){\n\t\t\t// mis(k+1, covered|(g[k]|(1L<<k)), choosed|(1L<<k), sum+pow[k]);\n\t\t\tmis(k+1, covered|(g[k]), choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, covered, choosed, sum);\n\t\t// mis(k+1, covered|(g[k]|(1L<<k)), choosed|(1L<<k), sum+pow[k]);\n\t\tmis(k+1, covered|(g[k]), choosed|(1L<<k), sum+pow[k]);\n\n\t\t// 両方か，片方か\n\n\t\t// g[k]\n\n\t\t// mis(k+1, choosed, temp|(1L<<k));\n\t\t// mis(k+1, choosed|(1L<<k), temp|g[k]);\n\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tArrayList<Integer> group;\n\tint [] notused;\n\tint resDfs, myind;\n\tArrayList<ArrayList<Integer>> otherListInd;\n\tboolean [] used;\n\tC[] data;\n\t\n\tclass C implements Comparable<C>{\n\t\tString name;\n\t\tint value;\n\t\tArrayList<String> list;\n\t\tpublic C(String name, int value, ArrayList<String> list) {\n\t\t\tthis.name = name;\n\t\t\tthis.value = value;\n\t\t\tthis.list = list;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(C o) {\n\t\t\treturn o.list.size() - this.list.size();\n\t\t}\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"C [name=\" + name + \", value=\" + value + \", list=\" + list\n\t\t\t\t\t+ \"]\";\n\t\t}\n\t\t\n\t}\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> toindex = new HashMap<String, Integer>();\n\t\t\tdata = new C[n];\n\t\t\tString myname = null;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrayList<String> list = new ArrayList<String>();\n\t\t\t\tString name = sc.next();\n\t\t\t\tif(i == 0) myname = name;\n\t\t\t\tint power = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\twhile(m-- > 0){\n\t\t\t\t\tString other = sc.next();\n\t\t\t\t\tlist.add(other);\n\t\t\t\t}\n\t\t\t\tdata[i] = new C(name, power, list);\n\t\t\t}\n\t\t\tArrays.sort(data);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\ttoindex.put(data[i].name, i);\n\t\t\t}\n\t\t\tmyind = toindex.get(myname);\n\t\t\t\n\t\t\totherListInd = new ArrayList<ArrayList<Integer>>();\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\totherListInd.add(new ArrayList<Integer>());\n\t\t\t\tfor(int j = 0; j < data[i].list.size(); j++){\n\t\t\t\t\tString temp = data[i].list.get(j);\n\t\t\t\t\tint ind = toindex.get(temp);\n\t\t\t\t\totherListInd.get(i).add(ind);\n\t\t\t\t\tuf.unite(i, ind);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tboolean [] searched = new boolean[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint root = uf.find(i);\n\t\t\t\tif(searched[root]) continue;\n\t\t\t\tsearched[root] = true;\n\t\t\t\tgroup = new ArrayList<Integer>();\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(root == uf.find(j)){\n\t\t\t\t\t\tgroup.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresDfs = 0;\n\t\t\t\tnotused = new int[n];\n\t\t\t\tused = new boolean[n];\n\t\t\t\tdfs(0, 0);\n\t\t\t\tsum += resDfs;\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tprivate void dfs(int deep, int sum) {\n\t\tif(deep == group.size()){\n\t\t\tresDfs = Math.max(sum, resDfs);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\tint nowind = group.get(deep);\n\t\tboolean flg = true;\n\t\tused[nowind] = true;\n\t\t\n\t\tif(notused[nowind] == 0){\n\t\t\tboolean AllT = true;\n\t\t\tfor(int i = 0; i < otherListInd.get(nowind).size(); i++){\n\t\t\t\tint otherind = otherListInd.get(nowind).get(i);\n\t\t\t\tif(! used[otherind]){\n\t\t\t\t\tAllT = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(AllT) flg = false;\n\t\t\t\n\t\t\tfor(int i = 0; i < otherListInd.get(nowind).size(); i++){\n\t\t\t\tint otherind = otherListInd.get(nowind).get(i);\n\t\t\t\tnotused[otherind]++;\n\t\t\t}\n\t\t\tdfs(deep + 1, sum + data[nowind].value);\n\t\t\tfor(int i = 0; i < otherListInd.get(nowind).size(); i++){\n\t\t\t\tint otherind = otherListInd.get(nowind).get(i);\n\t\t\t\tnotused[otherind]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(nowind != myind && flg){\n\t\t\tdfs(deep + 1, sum);\n\t\t}\n\t\tused[nowind] = false;\n\t}\n\n\tclass UnionFind{\n\t\tint [] par, rank;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t\t//rank[i] = 0;\n\t\t\t}\n\t\t\tnum = n;\n\t\t}\n\t\tint find(int x){\n\t\t\tif(par[x] == x)return x;\n\t\t\telse return par[x] = find(par[x]);\n\t\t}\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return ;\n\t\t\tif(rank[x] < rank[y]) par[x] = y;\n\t\t\telse{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t\tnum--;\n\t\t}\n\t\tboolean same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\n\n//The Enemy of My Enemy is My Friend\npublic class Main{\n\n\tMap<String, Integer> ref;\n\tint ID;\n\tint reg(String s){\n\t\tif(ref.containsKey(s))return ref.get(s);\n\t\tref.put(s, ID);\n\t\treturn ID++;\n\t}\n\t\n\tint N, res;\n\tint[] sum, B;\n\tlong[] adj;\n\t\n\tvoid f(int k, int score, long mask){\n\t\tres = Math.max(res, score);\n\t\tif(k==N)return;\n\t\tif(score+sum[k]<=res)return;\n\t\tif(((mask>>k)&1)>0){\n\t\t\tf(k+1, score, mask); return;\n\t\t}\n\t\tf(k+1, score+B[k], mask|adj[k]);\n\t\tf(k+1, score, mask);\n\t}\n\t\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN = sc.nextInt();\n\t\t\tif(N==0)break;\n\t\t\tref = new HashMap<String, Integer>();\n\t\t\tID = 0;\n\t\t\tadj = new long[N];\n\t\t\tB = new int[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint id = reg(sc.next());\n\t\t\t\tB[id] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\twhile(m--!=0)adj[id]+=1L<<reg(sc.next());\n\t\t\t}\n\t\t\tsum = new int[N+1];\n\t\t\tfor(int i=N-1;i>=0;i--)sum[i]=sum[i+1]+B[i];\n\t\t\tres = 0;\n\t\t\tf(1, B[0], adj[0]);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nimport javax.xml.bind.ParseConversionEvent;\n\npublic class Main {\n\n\tpublic static int dfs(int cur, final int N, int[] powers, boolean[][] adj, boolean[] block){\t\t\n\t\tboolean[] now_block = new boolean[N];\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(!block[i] && (cur == i || adj[cur][i])){\n\t\t\t\tblock[i] = true;\n\t\t\t\tnow_block[i] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int pos = cur + 1; pos < N; pos++){\n\t\t\tif(!block[pos]){\n\t\t\t\tret = Math.max(ret, dfs(pos, N, powers, adj, block));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(now_block[i]){\n\t\t\t\tblock[i] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ret + powers[cur];\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tString[] names = new String[N];\n\t\t\tint[] powers = new int[N];\n\t\t\tint[] adjusts = new int[N];\n\t\t\tString[][] ad_names = new String[N][];\n\t\t\t\n\t\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnames[i] = sc.next();\n\t\t\t\tmap.put(names[i], i);\n\t\t\t\tpowers[i] = sc.nextInt();\n\t\t\t\tadjusts[i] = sc.nextInt();\n\t\t\t\tad_names[i] = new String[adjusts[i]];\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tad_names[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] adj = new boolean[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tadj[i][map.get(ad_names[i][j])] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, N, powers, adj, new boolean[N]));\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "public class Main {\n\n\tint n;\n\n\tclass Country{\n\t\tint id;\n\t\tint string;\n\t\tlong enemy;\n\t\tList<String> Node=new ArrayList<String>();\n\n\t\tpublic void parseNode(){\n\t\t\tenemy=0L;\n\t\t\tfor(String node:Node){\n\t\t\t\tenemy+=(1<<nametoId.get(node));\n\t\t\t}\n\t\t}\n\t}\n\n\tHashMap<String,Integer> nametoId;\n\n\tpublic void run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tnametoId=new HashMap<String, Integer>();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCountry[] colist=new Country[n];\n\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcolist[i]=new Country();\n\t\t\t\tString name=sc.next();\n\t\t\t\tint string=sc.nextInt();\n\t\t\t\tif(!nametoId.containsKey(name)){\n\t\t\t\t\tnametoId.put(name,nametoId.size());\n\t\t\t\t}\n\t\t\t\tcolist[i].id=i;\n\t\t\t\tcolist[i].string=string;\n\n\t\t\t\tint links=sc.nextInt();\n\n\t\t\t\tfor(int j=0;j<links;j++){\n\t\t\t\t\tString name1=sc.next();\n\t\t\t\t\tcolist[i].Node.add(name1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(Country c :colist){\n\t\t\t\tc.parseNode();\n\t\t\t}\n\t\t\t//BitSet dp=new BitSet(n);\n\n\t\t\tSet<Long> dp=new HashSet<Long>();\n\t\t\tdp.add(1L);\n\t\t\tint res=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(colist[i].enemy==0){\n\t\t\t\t\tres+=colist[i].string;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSet<Long> tmp=new HashSet<Long>();\n\t\t\t\tfor(long d:dp){\n\t\t\t\t\tlong nxtmap=d+(1<<i);\n\t\t\t\t\tif((colist[i].enemy & nxtmap)==0){\n\t\t\t\t\t\ttmp.add(nxtmap);\n\t\t\t\t\t}else{\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp.addAll(tmp);\n\t\t\t}\n\t\t\tint max=0;\n\t\t\tfor(long d:dp){\n\t\t\t\tint i=0;\n\t\t\t\tint val=0;\n\t\t\t\twhile(d>0){\n\t\t\t\t\tif(d%2==1){\n\t\t\t\t\t\tval+=colist[i].string;\n\t\t\t\t\t}\n\t\t\t\t\td/=2;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tmax=Math.max(val,max);\n\t\t\t}\n\t\t\tpr(max+res);\n\t\t}\n\t}\n\n\n\n\n\tpublic static void main(String[] _) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[] B;\n\tstatic boolean[][] g;\n\tstatic boolean[] used;\n\tstatic HashMap<Long, Integer> memo;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tCountry[] cs = new Country[N];\n\t\t\tused = new boolean[N];\n\t\t\tB = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tcs[i] = new Country();\n\t\t\t\tB[i] = cs[i].b;\n\t\t\t}\n\t\t\tused[0] = true;\n\t\t\tg = new boolean[N][N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (String o : cs[i].c) {\n\t\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\t\tif (o.equals(cs[j].a)) {\n\t\t\t\t\t\t\tg[i][j] = true;\n\t\t\t\t\t\t\tif (i == 0) used[j] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = B[0];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!used[i]) ans += solve(i);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int solve(int cur) {\n\t\tint pos = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tlist.add(cur);\n\t\tused[cur] = true;\n\t\twhile (pos < list.size()) {\n\t\t\tint c = list.get(pos++);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (g[c][i] && !used[i]) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tlist.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo = new HashMap<Long, Integer>();\n\t\treturn dfs(0, list, 0);\n\t}\n\n\tstatic int dfs(int pos, ArrayList<Integer> list, long st) {\n\t\tif (pos == list.size()) return 0;\n\t\tif (pos > 20 && memo.containsKey(((long) pos << 50) | st)) {\n\t\t\treturn memo.get(st);\n\t\t}\n\t\tint cur = list.get(pos);\n\n\t\t// not use cur\n\t\tint ret = dfs(pos + 1, list, st | (1L << cur));\n\n\t\t// use cur\n\t\tif ((st & (1L << cur)) == 0) {\n\t\t\tst |= 1L << cur;\n\t\t\tint sum = B[cur];\n\t\t\tfor (int i = pos + 1; i < list.size(); ++i) {\n\t\t\t\tif (g[cur][list.get(i)]) {\n\t\t\t\t\tst |= 1L << list.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dfs(pos + 1, list, st);\n\t\t\tret = Math.max(ret, sum);\n\t\t}\n\n\t\tif (pos > 20) {\n\t\t\tmemo.put(((long) pos << 50) | st, ret);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic class Country {\n\t\tString a;\n\t\tint b;\n\t\tString[] c;\n\n\t\tCountry() {\n\t\t\ta = sc.next();\n\t\t\tb = sc.nextInt();\n\t\t\tint cc = sc.nextInt();\n\t\t\tc = new String[cc];\n\t\t\tfor (int i = 0; i < cc; ++i) {\n\t\t\t\tc[i] = sc.next();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] costs;\n\tlong[] enemies;\n\tint n;\n\tint max;\n\tHashMap<String, Integer> name2int;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcosts = new int[n];\n\t\t\tenemies = new long[n];\n\t\t\tname2int = new HashMap<String, Integer>();\n\t\t\tString[][] names = new String[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tname2int.put(name, i);\n\t\t\t\tcosts[i] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tnames[i] = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tnames[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<names[i].length;j++){\n\t\t\t\tenemies[i] |= 1L<<name2int.get(names[i][j]);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) enemies[i] |= 1L<<i;\n\t\t\tmax = 0;\n\t\t\tdfs(1, enemies[0], costs[0]);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemy, int cost) {\n//\t\tdebug(x, enemy, cost);\n\t\tif( x == n ) {\n\t\t\tmax = max(max, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemy>>x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemy, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( notConnected(enemy, enemies[x], x) ) {\n\t\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(x+1, enemy, cost);\n\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t}\n\t\n\tboolean notConnected(long a, long b, int x) {\n//\t\tfor(int i=0;i<n;i++) if( ((a>>i)&(b>>i)) == 1 ) return false;\n\t\treturn ((b>>(x+1))==0);\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[] B;\n\tstatic boolean[][] g;\n\tstatic boolean[] used;\n\tstatic HashMap<Long, Integer> memo;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tCountry[] cs = new Country[N];\n\t\t\tused = new boolean[N];\n\t\t\tB = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tcs[i] = new Country();\n\t\t\t\tB[i] = cs[i].b;\n\t\t\t}\n\t\t\tused[0] = true;\n\t\t\tg = new boolean[N][N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (String o : cs[i].c) {\n\t\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\t\tif (o.equals(cs[j].a)) {\n\t\t\t\t\t\t\tg[i][j] = true;\n\t\t\t\t\t\t\tif (i == 0) used[j] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = B[0];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!used[i]) ans += solve(i);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int solve(int cur) {\n\t\tint pos = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tlist.add(cur);\n\t\tused[cur] = true;\n\t\twhile (pos < list.size()) {\n\t\t\tint c = list.get(pos++);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (g[c][i] && !used[i]) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tlist.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmemo = new HashMap<Long, Integer>();\n\t\treturn dfs(0, list, 0);\n\t}\n\n\tstatic int dfs(int pos, ArrayList<Integer> list, long st) {\n\t\tif (pos == list.size()) return 0;\n\t\tlong ost = st;\n\t\tif (pos > 20 && memo.containsKey(((long) pos << 50) | ost)) {\n\t\t\treturn memo.get(((long) pos << 50) | ost);\n\t\t}\n\t\tint cur = list.get(pos);\n\n\t\t// not use cur\n\t\tint ret = dfs(pos + 1, list, st | (1L << cur));\n\n\t\t// use cur\n\t\tif ((st & (1L << cur)) == 0) {\n\t\t\tst |= 1L << cur;\n\t\t\tint sum = B[cur];\n\t\t\tfor (int i = pos + 1; i < list.size(); ++i) {\n\t\t\t\tif (g[cur][list.get(i)]) {\n\t\t\t\t\tst |= 1L << list.get(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum += dfs(pos + 1, list, st);\n\t\t\tret = Math.max(ret, sum);\n\t\t}\n\n\t\tif (pos > 20) {\n\t\t\tmemo.put(((long) pos << 50) | ost, ret);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic class Country {\n\t\tString a;\n\t\tint b;\n\t\tString[] c;\n\n\t\tCountry() {\n\t\t\ta = sc.next();\n\t\t\tb = sc.nextInt();\n\t\t\tint cc = sc.nextInt();\n\t\t\tc = new String[cc];\n\t\t\tfor (int i = 0; i < cc; ++i) {\n\t\t\t\tc[i] = sc.next();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Main {\n\n\tint n;\n\n\tclass Country{\n\t\tint id;\n\t\tint string;\n\t\tlong enemy;\n\t\tList<String> Node=new ArrayList<String>();\n\n\t\tpublic void parseNode(){\n\t\t\tenemy=0L;\n\t\t\tfor(String node:Node){\n\t\t\t\tenemy+=(1<<nametoId.get(node));\n\t\t\t}\n\t\t}\n\t}\n\n\tHashMap<String,Integer> nametoId;\n\n\tpublic void run(){\n\t\tScanner sc=new Scanner(System.in);\n\t\twhile(true){\n\t\t\tn=sc.nextInt();\n\t\t\tnametoId=new HashMap<String, Integer>();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCountry[] colist=new Country[n];\n\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcolist[i]=new Country();\n\t\t\t\tString name=sc.next();\n\t\t\t\tint string=sc.nextInt();\n\t\t\t\tif(!nametoId.containsKey(name)){\n\t\t\t\t\tnametoId.put(name,nametoId.size());\n\t\t\t\t}\n\t\t\t\tcolist[i].id=i;\n\t\t\t\tcolist[i].string=string;\n\n\t\t\t\tint links=sc.nextInt();\n\n\t\t\t\tfor(int j=0;j<links;j++){\n\t\t\t\t\tString name1=sc.next();\n\t\t\t\t\tcolist[i].Node.add(name1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(Country c :colist){\n\t\t\t\tc.parseNode();\n\t\t\t}\n\t\t\t//BitSet dp=new BitSet(n);\n\n\t\t\tSet<Long> dp=new HashSet<Long>();\n\t\t\tdp.add(1L);\n\t\t\tint res=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(colist[i].enemy==0){\n\t\t\t\t\tres+=colist[i].string;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tSet<Long> tmp=new HashSet<Long>();\n\t\t\t\tfor(long d:dp){\n\t\t\t\t\tlong nxtmap=d+(1<<i);\n\t\t\t\t\tif((colist[i].enemy & nxtmap)==0){\n\t\t\t\t\t\ttmp.add(nxtmap);\n\t\t\t\t\t}else{\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp.addAll(tmp);\n\t\t\t}\n\t\t\tint max=0;\n\t\t\tfor(long d:dp){\n\t\t\t\tint i=0;\n\t\t\t\tint val=0;\n\t\t\t\twhile(d>0){\n\t\t\t\t\tif(d%2==1){\n\t\t\t\t\t\tval+=colist[i].string;\n\t\t\t\t\t}\n\t\t\t\t\td/=2;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tmax=Math.max(val,max);\n\t\t\t}\n\t\t\tpr(max+res);\n\t\t}\n\t}\n\n\n\n\n\tpublic static void main(String[] _) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.println(o);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tHashMap<String, Integer> civ2int;\n\tCiv[] civs;\n\tint max;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tcivs = new Civ[n];\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tint ind = 0;\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint val = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tString[] neighbor = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tneighbor[j] = sc.next();\n\t\t\t\t}\n\t\t\t\tcivs[i] = new Civ(name, val, neighbor);\n\t\t\t\tciv2int.put(name, ind++);\n\t\t\t}\n\t\t\t\n\t\t\tint tmp = civs[0].val;\n\t\t\tcivs[0].val = 10000;\n\t\t\tsort(civs);\n\t\t\tcivs[0].val = tmp;\n\t\t\t\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) civ2int.put(civs[i].name, i);\n\t\t\tdebug(civ2int);\n\t\t\tfor(Civ civ: civs) {\n\t\t\t\tciv.setEnemy();\n\t\t\t\tdebug(civ.name, civ.enemy, civ.val, civ.neighbor);\n\t\t\t\t\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tdfs(0, 0, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemyes, int val) {\n\t\tdebug(x, enemyes, (enemyes >> x), val);\n\t\tif( x == n ) {\n\t\t\tmax = max( max, val );\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemyes >> x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemyes,  val);\n\t\t\treturn;\n\t\t}\n\t\tenemyes += 1<<x;\n\t\tdfs(x+1, enemyes|civs[x].enemy, val+civs[x].val);\n\t\tenemyes -= 1<<x;\n\t\tif((enemyes&civs[x].enemy) != 0&&x != 0) dfs(x+1, enemyes, val);\n\t}\n\t\n\tclass Civ implements Comparable<Civ> {\n\t\tString name;\n\t\tint val;\n\t\tString[] neighbor;\n\t\tlong enemy;\n\t\tCiv (String name,int val, String[] neighbor) {\n\t\t\tthis.name = name;\n\t\t\tthis.val = val;\n\t\t\tthis.neighbor = neighbor;\n\t\t\tenemy = 0;\n\t\t}\n\t\t\n\t\tvoid setEnemy() {\n\t\t\tfor(String str: neighbor) {\n\t\t\t\tenemy |= 1 << (civ2int.get(str));\n\t\t\t}\n\t\t}\n\t\t\n\t\tint neighborCost() {\n\t\t\tint sum = 0;\n\t\t\tfor(String str: neighbor) sum += civ2int.get(str);\n\t\t\treturn sum;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Civ o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn (o.val-o.neighborCost()) - (val-o.neighborCost());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nimport javax.xml.bind.ParseConversionEvent;\n\npublic class Main {\n\n\tpublic static int dfs(int cur, final int N, int[] powers, boolean[][] adj, long block, ArrayList<HashMap<Long, Integer>> memo){\n\t\t//System.out.println(Long.toBinaryString(block >> cur) + \" \" + cur);\n\t\tif(memo.get(cur).containsKey(block >> cur)){\n\t\t\treturn memo.get(cur).get(block >> cur);\n\t\t}\n\t\t//System.out.println(\"=> \" + Long.toBinaryString(block >> cur) + \" \" + cur);\n\t\t\n\t\t\n\t\tlong next_block = block;\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif((block & (1L << i)) == 0 && (cur == i || adj[cur][i])){\n\t\t\t\tnext_block |= (1L << i);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int pos = cur + 1; pos < N; pos++){\n\t\t\tif((next_block & (1L << pos)) == 0){\n\t\t\t\tret = Math.max(ret, dfs(pos, N, powers, adj, next_block, memo));\n\t\t\t}\n\t\t}\n\t\t\n\t\tmemo.get(cur).put(block >> cur, ret + powers[cur]);\n\t\treturn ret + powers[cur];\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tString[] names = new String[N];\n\t\t\tint[] powers = new int[N];\n\t\t\tint[] adjusts = new int[N];\n\t\t\tString[][] ad_names = new String[N][];\n\t\t\t\n\t\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnames[i] = sc.next();\n\t\t\t\tmap.put(names[i], i);\n\t\t\t\tpowers[i] = sc.nextInt();\n\t\t\t\tadjusts[i] = sc.nextInt();\n\t\t\t\tad_names[i] = new String[adjusts[i]];\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tad_names[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] adj = new boolean[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tadj[i][map.get(ad_names[i][j])] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<HashMap<Long, Integer>> maps = new ArrayList<HashMap<Long,Integer>>();\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tmaps.add(new HashMap<Long, Integer>());\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, N, powers, adj, 0L, maps));\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint n;\n\tHashMap<String, Integer> civ2int;\n\tCiv[] civs;\n\tint max;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\t\n\t\t\tcivs = new Civ[n];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tint val = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tString[] neighbor = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tneighbor[j] = sc.next();\n\t\t\t\t}\n\t\t\t\tcivs[i] = new Civ(name, val, neighbor);\n\t\t\t}\n\t\t\t\n\t\t\tint tmp = civs[0].val;\n\t\t\tcivs[0].val = 10000;\n\t\t\tsort(civs);\n\t\t\tcivs[0].val = tmp;\n\t\t\t\n\t\t\tciv2int = new HashMap<String, Integer>();\n\t\t\tfor(int i=0;i<n;i++) civ2int.put(civs[i].name, i);\n\t\t\tdebug(civ2int);\n\t\t\tfor(Civ civ: civs) {\n\t\t\t\tciv.setEnemy();\n\t\t\t\tdebug(civ.name, civ.enemy, civ.val, civ.neighbor);\n\t\t\t\t\n\t\t\t}\n\t\t\tmax = 0;\n\t\t\tdfs(0, 0, 0);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemyes, int val) {\n\t\tdebug(x, enemyes, (enemyes >> x), val);\n\t\tif( x == n ) {\n\t\t\tmax = max( max, val );\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemyes >> x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemyes,  val);\n\t\t\treturn;\n\t\t}\n\t\tenemyes += 1<<x;\n\t\tdfs(x+1, enemyes|civs[x].enemy, val+civs[x].val);\n\t\tenemyes -= 1<<x;\n\t\tif(x != 0) dfs(x+1, enemyes, val);\n\t}\n\t\n\tclass Civ implements Comparable<Civ> {\n\t\tString name;\n\t\tint val;\n\t\tString[] neighbor;\n\t\tlong enemy;\n\t\tCiv (String name,int val, String[] neighbor) {\n\t\t\tthis.name = name;\n\t\t\tthis.val = val;\n\t\t\tthis.neighbor = neighbor;\n\t\t\tenemy = 0;\n\t\t}\n\t\t\n\t\tvoid setEnemy() {\n\t\t\tfor(String str: neighbor) {\n\t\t\t\tenemy |= 1 << (civ2int.get(str));\n\t\t\t}\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic int compareTo(Civ o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn o.val - val;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n//\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\nimport javax.xml.bind.ParseConversionEvent;\n\npublic class Main {\n\n\tpublic static int dfs(int cur, final int N, int[] powers, boolean[][] adj, boolean[] block, int[] memo){\n\t\tif(memo[cur] > 0){\n\t\t\treturn memo[cur];\n\t\t}\n\t\t\n\t\tboolean[] now_block = new boolean[N];\n\t\t\n\t\tint ret = 0;\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(!block[i] && (cur == i || adj[cur][i])){\n\t\t\t\tblock[i] = true;\n\t\t\t\tnow_block[i] = true;\n\t\t\t}\n\t\t}\n\t\t\n\t\t\n\t\tfor(int pos = cur + 1; pos < N; pos++){\n\t\t\tif(!block[pos]){\n\t\t\t\tret = Math.max(ret, dfs(pos, N, powers, adj, block, memo));\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < N; i++){\n\t\t\tif(now_block[i]){\n\t\t\t\tblock[i] = false;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn memo[cur] = ret + powers[cur];\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException {\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tfinal int N = sc.nextInt();\n\t\t\t\n\t\t\tif(N == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tString[] names = new String[N];\n\t\t\tint[] powers = new int[N];\n\t\t\tint[] adjusts = new int[N];\n\t\t\tString[][] ad_names = new String[N][];\n\t\t\t\n\t\t\tMap<String, Integer> map = new HashMap<String, Integer>();\n\t\t\t\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tnames[i] = sc.next();\n\t\t\t\tmap.put(names[i], i);\n\t\t\t\tpowers[i] = sc.nextInt();\n\t\t\t\tadjusts[i] = sc.nextInt();\n\t\t\t\tad_names[i] = new String[adjusts[i]];\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tad_names[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean[][] adj = new boolean[N][N];\n\t\t\tfor(int i = 0; i < N; i++){\n\t\t\t\tfor(int j = 0; j < adjusts[i]; j++){\n\t\t\t\t\tadj[i][map.get(ad_names[i][j])] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(dfs(0, N, powers, adj, new boolean[N], new int[N]));\n\t\t}\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\tstatic long[] sum;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tsum = new long[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\t\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\t\tsum[i] = (i + 1 < N ? sum[i + 1] : 0) + B[i];\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tid.clear();\n\t\t\tD = null;\n\t\t\tA = null;\n\t\t\topt = B[0];\n\t\t\tSystem.out.println(dfs(1, 1, B[0]) + B[0]);\n\t\t\tB = null;\n\t\t\tC = null;\n\t\t\tsum = null;\n\t\t\t if ((Runtime.getRuntime().totalMemory() -\n\t\t\t Runtime.getRuntime().freeMemory()) / 1000 < 300)\n\t\t\t System.gc();\n\t\t}\n\t}\n\n\tstatic long opt;\n\n\tstatic long dfs(long used, int cur, long cursum) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tif (sum[cur] + cursum < opt) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, dfs(used | (1L << cur), cur + 1, cursum + B[cur]) + B[cur]);\n\t\t}\n\t\tif (!unadj) {\n\t\t\tres = Math.max(res, dfs(used, cur + 1, cursum));\n\t\t}\n\t\topt = Math.max(opt, cursum + res);\n\t\treturn res;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\thoge();\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tvoid hoge(){\n\t\tif(1==1)return;\n\t\tn=10;\n\t\tg=new long[n];\n\t\tpow=new int[n];\n\t\tRandom rand=new Random(1);\n\t\tfor(int t=0; t<100; t++){\n\t\t\tint i=rand.nextInt(n);\n\t\t\tint j=rand.nextInt(n);\n\t\t\tif(i!=j){\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t\tg[j]|=1L<<i;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0; i<n; i++){\n\t\t\tString s=Long.toBinaryString(g[i]);\n\t\t\tfor(; s.length()<n; s=\"0\"+s);\n\t\t\tdebug(s);\n\t\t}\n\t\tmis(0, 0, 0, 0);\n\t}\n\n\tlong[] g;\n\tlong[] memo;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tString s=Long.toBinaryString(g[i]);\n\t\t\tfor(; s.length()<n; s=\"0\"+s);\n\t\t\t// debug(s);\n\t\t}\n\n\t\tans=0;\n\t\tmemo=new long[n];\n\t\tfor(int i=n-2; i>=0; i--){\n\t\t\tmemo[i]=memo[i+1]|g[i+1];\n\t\t}\n\t\tmis(1, 1|g[0], 1, pow[0]);\n\t\t// debug(ans);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long covered, long choosed, int sum){\n\t\tif(k==n){\n\t\t\tString c=Long.toBinaryString(choosed);\n\t\t\tfor(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(covered), Long.toBinaryString(choosed));\n\n\t\t// long choosed\n\t\t// long\n\t\t// 今まで使った頂点とこれから使うかどうか決める頂点のどれとも隣接していない頂点はかならず使う\n\n\t\t// covered & (g[k] | (1L<<k)) != 0\n\t\t// 使わん\n\t\t// (covered | memo[k]) & (g[k] | (1L<<k)) == 0\n\n\t\t// Aの時，aだけ\n\t\t// Bの時，bだけ\n\t\t// それ以外，aとb\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\t// つかわん\n\t\t\tmis(k+1, covered, choosed, sum);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tlong rem=0;\n\t\tfor(int i=k+1;i<n;i++){\n\t\t\t// iが現状使えたら\n\t\t\tif\t((choosed&g[i])==0)\n//\t\t\t\tif((covered>>i&1)==0)\n\t\t\trem|=g[i];\n\t\t}\n\t\t\n\t\t// [0, n)-[0, k+1) = [k+1, n)\n\t\tlong korekara=((1L<<n)-1)^((1L<<(k+1))-1);\n//\t\tif(((choosed|korekara)&(g[k]|(1L<<k)))==0){\n\t\tif((rem>>k&1)==0){\n\t\t\t// mis(k+1, covered|(g[k]|(1L<<k)), choosed|(1L<<k), sum+pow[k]);\n\t\t\tmis(k+1, covered|(g[k]), choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, covered, choosed, sum);\n\t\t// mis(k+1, covered|(g[k]|(1L<<k)), choosed|(1L<<k), sum+pow[k]);\n\t\tmis(k+1, covered|(g[k]), choosed|(1L<<k), sum+pow[k]);\n\n\t\t// 両方か，片方か\n\n\t\t// g[k]\n\n\t\t// mis(k+1, choosed, temp|(1L<<k));\n\t\t// mis(k+1, choosed|(1L<<k), temp|g[k]);\n\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\tint[] costs;\n\tlong[] enemies;\n\tint n;\n\tint max;\n\tHashMap<String, Integer> name2int;\n\t\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tn = sc.nextInt();\n\t\t\tif( n == 0 ) break;\n\t\t\tcosts = new int[n];\n\t\t\tenemies = new long[n];\n\t\t\tname2int = new HashMap<String, Integer>();\n\t\t\tString[][] names = new String[n][];\n\t\t\tfor(int i=0;i<n;i++) {\n\t\t\t\tString name = sc.next();\n\t\t\t\tname2int.put(name, i);\n\t\t\t\tcosts[i] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\tnames[i] = new String[m];\n\t\t\t\tfor(int j=0;j<m;j++) {\n\t\t\t\t\tnames[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++) for(int j=0;j<names[i].length;j++){\n\t\t\t\tenemies[i] |= 1L<<name2int.get(names[i][j]);\n\t\t\t}\n\t\t\tfor(int i=0;i<n;i++) enemies[i] |= 1L<<i;\n\t\t\tmax = 0;\n\t\t\tdfs(1, enemies[0], costs[0]);\n\t\t\tSystem.out.println(max);\n\t\t}\n\t}\n\t\n\tvoid dfs(int x, long enemy, int cost) {\n\t\tif( x == n ) {\n\t\t\tmax = max(max, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( ((enemy>>x)&1) == 1 ) {\n\t\t\tdfs(x+1, enemy, cost);\n\t\t\treturn;\n\t\t}\n\t\tif( notConnected(enemy>>(x+1), enemies[x]>>(x+1), n-(x+1)) ) {\n\t\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t\t\treturn;\n\t\t}\n\n\t\tdfs(x+1, enemy, cost);\n\t\tdfs(x+1, enemy|enemies[x], cost+costs[x]);\n\t}\n\t\n\tboolean notConnected(long a, long b, int n) {\n\t\tfor(int i=0;i<n;i++) {\n\t\t\tif( (((a>>i)^1)&(b>>i)) == 1 ) return false;\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tif(false)\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\t\tif(Long.bitCount(g[_[i]])<Long.bitCount(g[_[j]])){\n\t\t\t\t\t\tint t=_[i];\n\t\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t\t_[j]=t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\tans=0;\n\t\tmis(0, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\n\t\t// debug(k, Long.toBinaryString(choosed));\n\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>_[k]&1)==0){\n\t\t\t\tmis(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\n\t\tif(1!=2){\n\t\t\treturn;\n\t\t}\n\n\t\tif((choosed&(g[k]|(1L<<k)))!=0){\n\t\t\tmis(k+1, choosed, sum);\n\t\t\treturn;\n\t\t}\n\n\t\tlong rem=0;\n\t\tfor(int i=k+1; i<n; i++){\n\t\t\tif((choosed&g[i])==0)\n\t\t\t\trem|=g[i];\n\t\t}\n\n\t\tif((rem>>k&1)==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\t// mis(1, 1, pow[0]);\n\t\tmais(1, 1|g[0], pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mais(long choosed, long removed, int sum){\n\t\tint k=-1;\n\t\tlong remained=~removed&((1L<<n)-1);\n\t\tfor(; remained!=0;){\n\t\t\tint i=Long.numberOfTrailingZeros(remained);\n\t\t\tif(Long.bitCount(g[i]&~removed)==0){\n\t\t\t\tk=i;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif(k==-1||Long.bitCount(g[i]&~removed)>Long.bitCount(g[k]&~removed))\n\t\t\t\tk=i;\n\t\t\tremained^=1L<<i;\n\t\t}\n\t\tif(k==-1){\n\t\t\t// String s=Long.toBinaryString(choosed);\n\t\t\t// for(; s.length()<n; s=\"0\"+s);\n\t\t\t// debug(s, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif(Long.bitCount(g[k]&~removed)>=1)\n\t\t\tmais(choosed, removed|(1L<<k), sum);\n\t\tmais(choosed|(1L<<k), removed|(1L<<k)|g[k], sum+pow[k]); // choose k\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// TODO\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&g[k])==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++)\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\tif((rem>>>k&1)==0)\n\t\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// TODO\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&g[k])==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++)\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\tif((rem>>>k&1)==0)\n\t\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int N;\n\tstatic int[] B;\n\tstatic boolean[][] g;\n\tstatic boolean[] used;\n\tstatic HashMap<Long, Integer> memo;\n\tstatic long[] mask;\n\n\tpublic static void main(String[] args) {\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0) break;\n\t\t\tCountry[] cs = new Country[N];\n\t\t\tused = new boolean[N];\n\t\t\tB = new int[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tcs[i] = new Country();\n\t\t\t\tB[i] = cs[i].b;\n\t\t\t}\n\t\t\tused[0] = true;\n\t\t\tg = new boolean[N][N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (String o : cs[i].c) {\n\t\t\t\t\tfor (int j = 0; j < N; ++j) {\n\t\t\t\t\t\tif (o.equals(cs[j].a)) {\n\t\t\t\t\t\t\tg[i][j] = true;\n\t\t\t\t\t\t\tif (i == 0) used[j] = true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint ans = B[0];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (!used[i]) ans += solve(i);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\n\tstatic int solve(int cur) {\n\t\tint pos = 0;\n\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\tlist.add(cur);\n\t\tused[cur] = true;\n\t\twhile (pos < list.size()) {\n\t\t\tint c = list.get(pos++);\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tif (g[c][i] && !used[i]) {\n\t\t\t\t\tused[i] = true;\n\t\t\t\t\tlist.add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tmask = new long[list.size()];\n\t\tfor (int i = 0; i < list.size(); ++i) {\n\t\t\tfor (int j = 0; j < list.size(); ++j) {\n\t\t\t\tif (g[list.get(i)][list.get(j)]) {\n\t\t\t\t\tmask[i] |= 1L << list.get(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tmask[i] |= 1L << list.get(i);\n\t\t}\n\t\tmemo = new HashMap<Long, Integer>();\n\t\treturn dfs(0, list, 0);\n\t}\n\n\tstatic int dfs(int pos, ArrayList<Integer> list, long st) {\n\t\tif (pos == list.size()) return 0;\n\t\tif (pos > 15 && memo.containsKey(((long) pos << 50) | st)) {\n\t\t\treturn memo.get(((long) pos << 50) | st);\n\t\t}\n\t\tint cur = list.get(pos);\n\n\t\t// not use cur\n\t\tint ret = dfs(pos + 1, list, st | (1L << cur));\n\n\t\t// use cur\n\t\tif ((st & (1L << cur)) == 0) {\n\t\t\tint sum = B[cur];\n\t\t\tsum += dfs(pos + 1, list, st | mask[pos]);\n\t\t\tret = Math.max(ret, sum);\n\t\t}\n\n\t\tif (pos > 15) {\n\t\t\tmemo.put(((long) pos << 50) | st, ret);\n\t\t}\n\t\treturn ret;\n\t}\n\n\tstatic class Country {\n\t\tString a;\n\t\tint b;\n\t\tString[] c;\n\n\t\tCountry() {\n\t\t\ta = sc.next();\n\t\t\tb = sc.nextInt();\n\t\t\tint cc = sc.nextInt();\n\t\t\tc = new String[cc];\n\t\t\tfor (int i = 0; i < cc; ++i) {\n\t\t\t\tc[i] = sc.next();\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main{\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\tstatic long[] sum;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tsum = new long[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\t\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\t\tsum[i] = (i + 1 < N ? sum[i + 1] : 0) + B[i];\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tid.clear();\n\t\t\tD = null;\n\t\t\tA = null;\n\t\t\topt = B[0];\n\t\t\tSystem.out.println(dfs(1, 1, B[0]) + B[0]);\n\t\t\tB = null;\n\t\t\tC = null;\n\t\t\tsum = null;\n\t\t\t if ((Runtime.getRuntime().totalMemory() -\n\t\t\t Runtime.getRuntime().freeMemory()) / 1000 < 400)\n\t\t\t System.gc();\n\t\t}\n\t}\n\n\tstatic long opt;\n\n\tstatic long dfs(long used, int cur, long cursum) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tif (sum[cur] + cursum < opt) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, dfs(used | (1L << cur), cur + 1, cursum + B[cur]) + B[cur]);\n\t\t}\n\t\tif (!unadj) {\n\t\t\tres = Math.max(res, dfs(used, cur + 1, cursum));\n\t\t}\n\t\topt = Math.max(opt, cursum + res);\n\t\treturn res;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\n\npublic class Main{\n\tArrayList<Integer> group;\n\tboolean [] used;\n\tint [] notused, power;\n\tint resDfs;\n\tArrayList<ArrayList<Integer>> otherListInd;\n\t\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tHashMap<String, Integer> toindex = new HashMap<String, Integer>();\n\t\t\tArrayList<ArrayList<String>> otherList = new ArrayList<ArrayList<String>>();\n\t\t\tpower = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\totherList.add(new ArrayList<String>());\n\t\t\t\tString name = sc.next();\n\t\t\t\ttoindex.put(name, i);\n\t\t\t\tpower[i] = sc.nextInt();\n\t\t\t\tint m = sc.nextInt();\n\t\t\t\twhile(m-- > 0){\n\t\t\t\t\tString other = sc.next();\n\t\t\t\t\totherList.get(i).add(other);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\totherListInd = new ArrayList<ArrayList<Integer>>();\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\totherListInd.add(new ArrayList<Integer>());\n\t\t\t\tfor(int j = 0; j < otherList.get(i).size(); j++){\n\t\t\t\t\tString temp = otherList.get(i).get(j);\n\t\t\t\t\tint ind = toindex.get(temp);\n\t\t\t\t\totherListInd.get(i).add(ind);\n\t\t\t\t\tuf.unite(i, ind);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tboolean [] searched = new boolean[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tint root = uf.find(i);\n\t\t\t\tif(searched[root]) continue;\n\t\t\t\tsearched[root] = true;\n\t\t\t\tgroup = new ArrayList<Integer>();\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tif(root == uf.find(j)){\n\t\t\t\t\t\tgroup.add(j);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresDfs = 0;\n\t\t\t\tused = new boolean[group.size()];\n\t\t\t\tnotused = new int[n];\n\t\t\t\tdfs(0, 0);\n\t\t\t\tsum += resDfs;\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n\t\n\tprivate void dfs(int deep, int sum) {\n\t\tif(deep == group.size()){\n\t\t\tresDfs = Math.max(sum, resDfs);\n\t\t\treturn ;\n\t\t}\n\t\t\n\t\t//use\n\t\tint nowind = group.get(deep);\n\t\tif(notused[nowind] == 0){\n\t\t\tfor(int i = 0; i < otherListInd.get(nowind).size(); i++){\n\t\t\t\tint otherind = otherListInd.get(nowind).get(i);\n\t\t\t\tnotused[otherind]++;\n\t\t\t}\n\t\t\tdfs(deep + 1, sum + power[nowind]);\n\t\t\tfor(int i = 0; i < otherListInd.get(nowind).size(); i++){\n\t\t\t\tint otherind = otherListInd.get(nowind).get(i);\n\t\t\t\tnotused[otherind]--;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//notuse\n\t\tif(nowind != 0){\n\t\t\tdfs(deep + 1, sum);\n\t\t}\n\t}\n\n\tclass UnionFind{\n\t\tint [] par, rank;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i = 0 ; i < n; i++){\n\t\t\t\tpar[i] = i;\n\t\t\t\t//rank[i] = 0;\n\t\t\t}\n\t\t\tnum = n;\n\t\t}\n\t\tint find(int x){\n\t\t\tif(par[x] == x)return x;\n\t\t\telse return par[x] = find(par[x]);\n\t\t}\n\t\tvoid unite(int x, int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y) return ;\n\t\t\tif(rank[x] < rank[y]) par[x] = y;\n\t\t\telse{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t\t}\n\t\t\tnum--;\n\t\t}\n\t\tboolean same(int x, int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\n\tprivate void debug(Object... o) {\n\t\tSystem.out.println(\"debug = \" + Arrays.deepToString(o));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic ArrayList<Integer>[] g;\n\tstatic int N;\n\tstatic int[] B;\n\tstatic int[] C;\n\tstatic long[] sum;\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tN = sc.nextInt();\n\t\t\tif (N == 0)\n\t\t\t\tbreak;\n\t\t\tString[] A = new String[N];\n\t\t\tB = new int[N];\n\t\t\tC = new int[N];\n\t\t\tString[][] D = new String[N][];\n\t\t\tHashMap<String, Integer> id = new HashMap<>();\n\t\t\tsum = new long[N];\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tA[i] = sc.next();\n\t\t\t\tB[i] = sc.nextInt();\n\t\t\t\tC[i] = sc.nextInt();\n\t\t\t\tD[i] = new String[C[i]];\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tD[i][j] = sc.next();\n\t\t\t\t}\n\t\t\t\tid.put(A[i], i);\n\t\t\t}\n\t\t\tfor (int i = N - 1; i >= 0; --i) {\n\t\t\t\tsum[i] = (i + 1 < N ? sum[i + 1] : 0) + B[i];\n\t\t\t}\n\n\t\t\tg = new ArrayList[N];\n\t\t\tfor (int i = 0; i < N; ++i)\n\t\t\t\tg[i] = new ArrayList<>();\n\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tfor (int j = 0; j < C[i]; ++j) {\n\t\t\t\t\tint dst = id.get(D[i][j]);\n\t\t\t\t\tg[i].add(dst);\n\t\t\t\t\tg[dst].add(i);\n\t\t\t\t}\n\t\t\t}\n\t\t\tid.clear();\n\t\t\tD = null;\n\t\t\tA = null;\n\t\t\topt = B[0];\n\t\t\tSystem.out.println(dfs(1, 1, B[0]) + B[0]);\n\t\t\tB = null;\n\t\t\tC = null;\n\t\t\tsum = null;\n\t\t\t// if ((Runtime.getRuntime().totalMemory() -\n\t\t\t// Runtime.getRuntime().freeMemory()) / 1000 < 450)\n\t\t\t// System.gc();\n\t\t}\n\t}\n\n\tstatic long opt;\n\n\tstatic long dfs(long used, int cur, long cursum) {\n\t\tif (cur >= N)\n\t\t\treturn 0;\n\t\tif (sum[cur] + cursum < opt) {\n\t\t\treturn 0;\n\t\t}\n\t\tlong res = 0;\n\t\tboolean unadj = true;\n\t\tboolean unrestriected = true;\n\t\tfor (int dst : g[cur]) {\n\t\t\tif (!(dst < cur && ((used >> dst) & 1) == 0)) {\n\t\t\t\tunadj = false;\n\t\t\t}\n\t\t\tif (((used >> dst) & 1) == 1) {\n\t\t\t\tunrestriected = false;\n\t\t\t}\n\t\t}\n\t\tif (unrestriected) {\n\t\t\tres = Math.max(res, dfs(used | (1L << cur), cur + 1, cursum + B[cur]) + B[cur]);\n\t\t}\n\t\tif (!unadj) {\n\t\t\tres = Math.max(res, dfs(used, cur + 1, cursum));\n\t\t}\n\t\topt = Math.max(opt, cursum + res);\n\t\treturn res;\n\t}\n\n\tstatic void tr(Object... objects) {\n\t\tSystem.out.println(Arrays.deepToString(objects));\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])>Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\t// mis(1, 1, pow[0]);\n\t\tmis_(0, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis_(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>>_[k]&1)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmis_(k+1, choosed, sum);\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&(g[k]|(1L<<k)))==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\t}\n\t\t\tif((rem>>>k&1)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint[] _;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\t// _:順番->ID\n\t\t_=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\t_[i]=i;\n\t\t}\n\t\tfor(int j=0; j<n; j++){\n\t\t\tfor(int i=j+1; i<n; i++){\n\t\t\t\tif(Long.bitCount(g[_[i]])<Long.bitCount(g[_[j]])){\n\t\t\t\t\tint t=_[i];\n\t\t\t\t\t_[i]=_[j];\n\t\t\t\t\t_[j]=t;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tans=0;\n\t\t// mis(1, 1, pow[0]);\n\t\tmis_(0, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis_(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&(g[_[k]]|(1L<<_[k])))==0){\n\t\t\tmis_(k+1, choosed|(1L<<_[k]), sum+pow[_[k]]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[_[i]])==0)\n\t\t\t\t\trem|=g[_[i]];\n\t\t\t}\n\t\t\tif((rem>>>_[k]&1)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmis_(k+1, choosed, sum);\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// String c=Long.toBinaryString(choosed);\n\t\t\t// for(; c.length()<n; c=\"0\"+c);\n\t\t\t// debug(c, sum);\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&(g[k]|(1L<<k)))==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++){\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\t}\n\t\t\tif((rem>>>k&1)==0){\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\n\npublic class Main{\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-12;\n\n\tint n;\n\tint[] pow;\n\tString[] names;\n\tHashSet<String>[] sets;\n\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tfor(;;){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tnames=new String[n];\n\t\t\tpow=new int[n];\n\t\t\tsets=new HashSet[n];\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tnames[j]=sc.next();\n\t\t\t\tpow[j]=sc.nextInt();\n\t\t\t\tsets[j]=new HashSet<String>();\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\t\tsets[j].add(sc.next());\n\t\t\t\t}\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tlong[] g;\n\tint ans;\n\n\tvoid solve(){\n\t\tHashMap<String, Integer> map=new HashMap<String, Integer>();\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmap.put(names[i], i);\n\t\t}\n\t\tg=new long[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(String s : sets[i]){\n\t\t\t\tint j=map.get(s);\n\t\t\t\tg[i]|=1L<<j;\n\t\t\t}\n\t\t}\n\t\tans=0;\n\t\tmis(1, 1, pow[0]);\n\t\tprintln(ans+\"\");\n\t}\n\n\tvoid mis(int k, long choosed, int sum){\n\t\tif(k==n){\n\t\t\t// TODO\n\t\t\tans=max(ans, sum);\n\t\t\treturn;\n\t\t}\n\t\tif((choosed&g[k])==0){\n\t\t\tmis(k+1, choosed|(1L<<k), sum+pow[k]);\n\t\t\tlong rem=0;\n\t\t\tfor(int i=k+1; i<n; i++)\n\t\t\t\tif((choosed&g[i])==0)\n\t\t\t\t\trem|=g[i];\n\t\t\tif((rem>>>k&1)==0)\n\t\t\t\treturn;\n\t\t}\n\t\tmis(k+1, choosed, sum);\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.OutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.io.BufferedWriter;\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.io.InputStreamReader;\nimport java.io.UncheckedIOException;\nimport java.nio.charset.Charset;\nimport java.util.StringTokenizer;\nimport java.util.Map;\nimport java.io.Writer;\nimport java.io.OutputStreamWriter;\nimport java.io.BufferedReader;\nimport java.io.InputStream;\n\n/**\n * Built using CHelper plug-in\n * Actual solution is at the top\n *\n * @author mikit\n */\npublic class Main {\n    public static void main(String[] args) {\n        InputStream inputStream = System.in;\n        OutputStream outputStream = System.out;\n        LightScanner in = new LightScanner(inputStream);\n        LightWriter out = new LightWriter(outputStream);\n        JAG2012E solver = new JAG2012E();\n        solver.solve(1, in, out);\n        out.close();\n    }\n\n    static class JAG2012E {\n        private Map<String, Integer> nameToIndex = new HashMap<>();\n        private int n;\n        private long[] adj;\n        private int[] power;\n        private int[] powerSumFrom;\n        private int res = 0;\n\n        public void solve(int testNumber, LightScanner in, LightWriter out) {\n            while (true) {\n                n = in.ints();\n                if (n == 0) break;\n\n                nameToIndex.clear();\n                adj = new long[n];\n                power = new int[n];\n                powerSumFrom = new int[n + 1];\n                for (int i = 0; i < n; i++) {\n                    int index = toIndex(in.string());\n                    power[index] = in.ints();\n                    adj[index] = 0;\n                    int m = in.ints();\n                    for (int j = 0; j < m; j++) {\n                        adj[index] |= 1L << toIndex(in.string());\n                    }\n                }\n                for (int i = n - 1; i >= 0; i--) powerSumFrom[i] = powerSumFrom[i + 1] + power[i];\n                res = 0;\n                solve(1, power[0], adj[0]);\n                out.ans(res).ln();\n            }\n        }\n\n        private int toIndex(String name) {\n            if (!nameToIndex.containsKey(name)) nameToIndex.put(name, nameToIndex.size());\n            return nameToIndex.get(name);\n        }\n\n        private int solve(int k, int sum, long forbid) {\n            if (k == n) return res = Math.max(res, sum);\n            if (sum + powerSumFrom[k] <= res) return 0;\n            int ans = solve(k + 1, sum, forbid);\n            if (((forbid >> k) & 1) == 0) ans = Math.max(ans, solve(k + 1, sum + power[k], forbid | adj[k]));\n            return ans;\n        }\n\n    }\n\n    static class LightScanner {\n        private BufferedReader reader = null;\n        private StringTokenizer tokenizer = null;\n\n        public LightScanner(InputStream in) {\n            reader = new BufferedReader(new InputStreamReader(in));\n        }\n\n        public String string() {\n            if (tokenizer == null || !tokenizer.hasMoreTokens()) {\n                try {\n                    tokenizer = new StringTokenizer(reader.readLine());\n                } catch (IOException e) {\n                    throw new UncheckedIOException(e);\n                }\n            }\n            return tokenizer.nextToken();\n        }\n\n        public int ints() {\n            return Integer.parseInt(string());\n        }\n\n    }\n\n    static class LightWriter implements AutoCloseable {\n        private final Writer out;\n        private boolean autoflush = false;\n        private boolean breaked = true;\n\n        public LightWriter(Writer out) {\n            this.out = out;\n        }\n\n        public LightWriter(OutputStream out) {\n            this(new BufferedWriter(new OutputStreamWriter(out, Charset.defaultCharset())));\n        }\n\n        public LightWriter print(char c) {\n            try {\n                out.write(c);\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter print(String s) {\n            try {\n                out.write(s, 0, s.length());\n                breaked = false;\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n            return this;\n        }\n\n        public LightWriter ans(String s) {\n            if (!breaked) {\n                print(' ');\n            }\n            return print(s);\n        }\n\n        public LightWriter ans(int i) {\n            return ans(Integer.toString(i));\n        }\n\n        public LightWriter ln() {\n            print(System.lineSeparator());\n            breaked = true;\n            if (autoflush) {\n                try {\n                    out.flush();\n                } catch (IOException ex) {\n                    throw new UncheckedIOException(ex);\n                }\n            }\n            return this;\n        }\n\n        public void close() {\n            try {\n                out.close();\n            } catch (IOException ex) {\n                throw new UncheckedIOException(ex);\n            }\n        }\n\n    }\n}\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Collections;\n\nnamespace ProgramContestCS {\n  class Program {\n    int n;\n\n\tclass Country{\n\t\tpublic int id;\n        public int strong;\n        public long enemy;\n        public List<string> Node = new List<string>();\n\n        public Program m;\n        public Country(Program m) {\n          this.m = m;\n        }\n\n\t\tpublic void parseNode(){\n\t\t\tenemy=0L;\n\t\t\tforeach(string node in Node){\n\t\t\t\tenemy+=(1<<m.nametoId[node]);\n\t\t\t}\n\t\t}\n\t}\n\n    Dictionary<string,int> nametoId;\n\n    public static string[] read() {\n      return Console.ReadLine().Split(' ');\n    }\n\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tn=int.Parse(read()[0]);\n\t\t\tnametoId=new Dictionary<string,int>();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCountry[] colist=new Country[n];\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcolist[i]=new Country(this);\n                string[] st=read();\n\t\t\t\tString name=st[0];\n\t\t\t\tint strong=int.Parse(st[1]);\n\t\t\t\tif(!nametoId.ContainsKey(name)){\n\t\t\t\t\tnametoId.Add(name,nametoId.Count);\n\t\t\t\t}\n\t\t\t\tcolist[i].id=i;\n\t\t\t\tcolist[i].strong=strong;\n\n\t\t\t\tint links=int.Parse(st[2]);\n\n\t\t\t\tfor(int j=0;j<links;j++){\n\t\t\t\t\tString name1=st[j+3];\n\t\t\t\t\tcolist[i].Node.Add(name1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach(Country c in colist){\n\t\t\t\tc.parseNode();\n\t\t\t}\n\t\t\t//BitSet dp=new BitSet(n);\n\n\t\t\tHashSet<long> dp=new HashSet<long>();\n\t\t\tdp.Add(1L);\n\t\t\tint res=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(colist[i].enemy==0){\n\t\t\t\t\tres+=colist[i].strong;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tISet<long> tmp=new HashSet<long>();\n\t\t\t\tforeach(long d in dp){\n\t\t\t\t\tlong nxtmap=d+(1<<i);\n\t\t\t\t\tif((colist[i].enemy & nxtmap)==0){\n\t\t\t\t\t\ttmp.Add(nxtmap);\n\t\t\t\t\t}else{\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp.UnionWith(tmp);\n\t\t\t}\n\t\t\tint max=0;\n\t\t\tforeach(long d in dp){\n\t\t\t\tint i=0;\n\t\t\t\tint val=0;\n                long _d = d;\n\t\t\t\twhile(_d>0){\n\t\t\t\t\tif(_d%2==1){\n\t\t\t\t\t\tval+=colist[i].strong;\n\t\t\t\t\t}\n\t\t\t\t\t_d/=2;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tmax=Math.Max(val,max);\n\t\t\t}\n\t\t\tpr(max+res);\n\t\t}\n\t}\n\n\n    static void Main(string[] args) {\t\n      new Program().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tConsole.Write(o);\n\t}\n  }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Collections;\n\nnamespace ProgramContestCS {\n  class Program {\n    int n;\n\n\tclass Country{\n\t\tpublic int id;\n        public int strong;\n        public long enemy;\n        public List<string> Node = new List<string>();\n\n        public Program m;\n        public Country(Program m) {\n          this.m = m;\n        }\n\n\t\tpublic void parseNode(){\n\t\t\tenemy=0L;\n\t\t\tforeach(string node in Node){\n\t\t\t\tenemy+=(1<<m.nametoId[node]);\n\t\t\t}\n\t\t}\n\t}\n\n    Dictionary<string,int> nametoId;\n\n    public static string[] read() {\n      return Console.ReadLine().Split(' ');\n    }\n\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tn=int.Parse(read()[0]);\n\t\t\tnametoId=new Dictionary<string,int>();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCountry[] colist=new Country[n];\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcolist[i]=new Country(this);\n                string[] st=read();\n\t\t\t\tString name=st[0];\n\t\t\t\tint strong=int.Parse(st[1]);\n\t\t\t\tif(!nametoId.ContainsKey(name)){\n\t\t\t\t\tnametoId.Add(name,nametoId.Count);\n\t\t\t\t}\n\t\t\t\tcolist[i].id=i;\n\t\t\t\tcolist[i].strong=strong;\n\n\t\t\t\tint links=int.Parse(st[2]);\n\n\t\t\t\tfor(int j=0;j<links;j++){\n\t\t\t\t\tString name1=st[j+3];\n\t\t\t\t\tcolist[i].Node.Add(name1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach(Country c in colist){\n\t\t\t\tc.parseNode();\n\t\t\t}\n\t\t\t//BitSet dp=new BitSet(n);\n\n\t\t\tHashSet<long> dp=new HashSet<long>();\n\t\t\tdp.Add(1L);\n\t\t\tint res=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(colist[i].enemy==0){\n\t\t\t\t\tres+=colist[i].strong;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tISet<long> tmp=new HashSet<long>();\n\t\t\t\tforeach(long d in dp){\n\t\t\t\t\tlong nxtmap=d+(1<<i);\n\t\t\t\t\tif((colist[i].enemy & nxtmap)==0){\n\t\t\t\t\t\ttmp.Add(nxtmap);\n\t\t\t\t\t}else{\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp.UnionWith(tmp);\n\t\t\t}\n\t\t\tint max=0;\n\t\t\tforeach(long d in dp){\n\t\t\t\tint i=0;\n\t\t\t\tint val=0;\n                long _d = d;\n\t\t\t\twhile(_d>0){\n\t\t\t\t\tif(_d%2==1){\n\t\t\t\t\t\tval+=colist[i].strong;\n\t\t\t\t\t}\n\t\t\t\t\t_d/=2;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tmax=Math.Max(val,max);\n\t\t\t}\n\t\t\tpr(max+res);\n\t\t}\n\t}\n\n\n    static void Program(string[] args) {\t\n      new Program().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tConsole.Write(o);\n\t}\n  }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Linq;\nusing System.Collections.Generic;\nusing Debug = System.Diagnostics.Debug;\nusing SB = System.Text.StringBuilder;\nusing System.Numerics;\nusing static System.Math;\nusing Point = System.Numerics.Complex;\nusing Number = System.Int64;\nnamespace Program {\n    public class Solver {\n        Random rnd = new Random(0);\n        public void Solve() {\n            var n = ri;\n            if (n == 0) return;\n            var a = new string[n];\n            var b = new long[n];\n            var g = Enumerate(n, x => new List<string>());\n            for (int i = 0; i < n; i++)\n            {\n                a[i] = rs;\n                b[i] = ri;\n                var c = ri;\n                for (int j = 0; j < c; j++)\n                    g[i].Add(rs);\n            }\n\n            var G = new long[n];\n            for (int i = 0; i < n; i++)\n                foreach (var to in g[i])\n                    G[i] |= 1L << Array.FindIndex(a, x => x == to);\n            solve(n, b, G);\n            Solve();\n        }\n        void solve(int n, long[] a, long[] G) {\n            int m = Min(20, n);\n            var k = n - m;\n            a[0] += 1000000000;\n            var mask = new long[1 << k];\n            for (int i = 0; i < 1 << m; i++)\n            {\n                var dame = 0L;\n                var score = 0L;\n                for (int j = 0; j < m; j++)\n                {\n                    if ((i >> j & 1) == 0) continue;\n                    dame |= G[j];\n                    score += a[j];\n                }\n                if ((i & dame) > 0) continue;\n                mask[dame >> m] = Max(mask[dame >> m], score);\n            }\n            for (int i = 0; i < 1 << k; i++)\n                for (int j = 0; j < k; j++)\n                    mask[i | (1 << j)] = Max(mask[i | (1 << j)], mask[i]);\n            var ans = 0L;\n            var all = (1L << n) - 1;\n            for (long i = 0; i < (1L << n) - 1; i += 1 << m)\n            {\n                var dame = 0L;\n                var score = 0L;\n                for (int j = m; j < n; j++)\n                {\n                    if ((i >> j & 1) == 0) continue;\n                    dame |= G[j];\n                    score += a[j];\n                }\n                if ((i & dame) > 0) continue;\n                var rem = (i ^ all) >> m;\n\n                ans = Max(ans, score + mask[rem]);\n            }\n            ans -= 1000000000;\n            Console.WriteLine(ans);\n        }\n        const long INF = 1L << 60;\n        int ri { get { return sc.Integer(); } }\n        long rl { get { return sc.Long(); } }\n        double rd { get { return sc.Double(); } }\n        string rs { get { return sc.Scan(); } }\n        public IO.StreamScanner sc = new IO.StreamScanner(Console.OpenStandardInput());\n\n        static T[] Enumerate<T>(int n, Func<int, T> f) {\n            var a = new T[n];\n            for (int i = 0; i < n; ++i) a[i] = f(i);\n            return a;\n        }\n        static public void Swap<T>(ref T a, ref T b) { var tmp = a; a = b; b = tmp; }\n    }\n}\n\n#region main\nstatic class Ex {\n    static public string AsString(this IEnumerable<char> ie) { return new string(ie.ToArray()); }\n    static public string AsJoinedString<T>(this IEnumerable<T> ie, string st = \" \") {\n        return string.Join(st, ie);\n    }\n    static public void Main() {\n        Console.SetOut(new Program.IO.Printer(Console.OpenStandardOutput()) { AutoFlush = false });\n        var solver = new Program.Solver();\n        solver.Solve();\n        Console.Out.Flush();\n    }\n}\n#endregion\n#region Ex\nnamespace Program.IO {\n    using System.IO;\n    using System.Text;\n    using System.Globalization;\n\n    public class Printer: StreamWriter {\n        public override IFormatProvider FormatProvider { get { return CultureInfo.InvariantCulture; } }\n        public Printer(Stream stream) : base(stream, new UTF8Encoding(false, true)) { }\n    }\n\n    public class StreamScanner {\n        public StreamScanner(Stream stream) { str = stream; }\n\n        public readonly Stream str;\n        private readonly byte[] buf = new byte[1024];\n        private int len, ptr;\n        public bool isEof = false;\n        public bool IsEndOfStream { get { return isEof; } }\n\n        private byte read() {\n            if (isEof) return 0;\n            if (ptr >= len)\n            {\n                ptr = 0;\n                if ((len = str.Read(buf, 0, 1024)) <= 0)\n                {\n                    isEof = true;\n                    return 0;\n                }\n            }\n            return buf[ptr++];\n        }\n\n        public char Char() {\n            byte b = 0;\n            do b = read(); while ((b < 33 || 126 < b) && !isEof);\n            return (char)b;\n        }\n        public string Scan() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b >= 33 && b <= 126; b = (char)read()) sb.Append(b);\n            return sb.ToString();\n        }\n        public string ScanLine() {\n            var sb = new StringBuilder();\n            for (var b = Char(); b != '\\n' && b != 0; b = (char)read()) if (b != '\\r') sb.Append(b);\n            return sb.ToString();\n        }\n        public long Long() { return isEof ? long.MinValue : long.Parse(Scan()); }\n        public int Integer() { return isEof ? int.MinValue : int.Parse(Scan()); }\n        public double Double() { return isEof ? double.NaN : double.Parse(Scan(), CultureInfo.InvariantCulture); }\n    }\n}\n\n#endregion\n\n\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Collections;\n\nnamespace ProgramContestCS {\n  class Program {\n    int n;\n\n\tclass Country{\n\t\tpublic int id;\n        public int strong;\n        public long enemy;\n        public List<string> Node = new List<string>();\n\n        public Program m;\n        public Country(Program m) {\n          this.m = m;\n        }\n\n\t\tpublic void parseNode(){\n\t\t\tenemy=0L;\n\t\t\tforeach(string node in Node){\n\t\t\t\tenemy+=(1<<m.nametoId[node]);\n\t\t\t}\n\t\t}\n\t}\n\n    Dictionary<string,int> nametoId;\n\n    public static string[] read() {\n      return Console.ReadLine().Split(' ');\n    }\n\n\tpublic void run(){\n\t\twhile(true){\n\t\t\tn=int.Parse(read()[0]);\n\t\t\tnametoId=new Dictionary<string,int>();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tCountry[] colist=new Country[n];\n\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tcolist[i]=new Country(this);\n                string[] st=read();\n\t\t\t\tString name=st[0];\n\t\t\t\tint strong=int.Parse(st[1]);\n\t\t\t\tif(!nametoId.ContainsKey(name)){\n\t\t\t\t\tnametoId.Add(name,nametoId.Count);\n\t\t\t\t}\n\t\t\t\tcolist[i].id=i;\n\t\t\t\tcolist[i].strong=strong;\n\n\t\t\t\tint links=int.Parse(st[2]);\n\n\t\t\t\tfor(int j=0;j<links;j++){\n\t\t\t\t\tString name1=st[j+3];\n\t\t\t\t\tcolist[i].Node.Add(name1);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tforeach(Country c in colist){\n\t\t\t\tc.parseNode();\n\t\t\t}\n\t\t\t//BitSet dp=new BitSet(n);\n\n\t\t\tHashSet<long> dp=new HashSet<long>();\n\t\t\tdp.Add(1L);\n\t\t\tint res=0;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(colist[i].enemy==0){\n\t\t\t\t\tres+=colist[i].strong;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n                HashSet<long> tmp = new HashSet<long>();\n\t\t\t\tforeach(long d in dp){\n\t\t\t\t\tlong nxtmap=d+(1<<i);\n\t\t\t\t\tif((colist[i].enemy & nxtmap)==0){\n\t\t\t\t\t\ttmp.Add(nxtmap);\n\t\t\t\t\t}else{\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdp.UnionWith(tmp);\n\t\t\t}\n\t\t\tint max=0;\n\t\t\tforeach(long d in dp){\n\t\t\t\tint i=0;\n\t\t\t\tint val=0;\n                long _d = d;\n\t\t\t\twhile(_d>0){\n\t\t\t\t\tif(_d%2==1){\n\t\t\t\t\t\tval+=colist[i].strong;\n\t\t\t\t\t}\n\t\t\t\t\t_d/=2;\n\t\t\t\t\ti++;\n\t\t\t\t}\n\t\t\t\tmax=Math.Max(val,max);\n\t\t\t}\n\t\t\tpr(max+res);\n\t\t}\n\t}\n\n\n    static void Main(string[] args) {\t\n      new Program().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tConsole.Write(o);\n\t}\n  }\n}"
  },
  {
    "language": "Ruby",
    "code": "class GraphBits\n\tdef initialize(n)\n\t\t@n = n\n\n\t\t@bits = 1\n\t\t(n-1).times {\n\t\t\t@bits = (@bits << @n + 1) | 1\n\t\t}\n\n\t\t@ones = 1\n\t\t(n-1).times { @ones = (@ones << @n) | 1 }\n\t\t@select_mask = (0..@n-1).map{|i| @ones << i}\n\n\t\t@pos = {}\n\t\tx = 1\n\t\t@n.times {|i|\n\t\t\t@pos[x] = i\n\t\t\tx = (x << 1) | 1\n\t\t}\n\tend\n\n\tdef add_edge(i, j)\n\t\t@bits |= (1 << i * @n + j)\n\t\t@select_mask[i] |= (@ones << j)\n\tend\n\n\tdef del_node(i)\n\t\ttmp = @bits & (@ones << i)\n\t\t@bits -= tmp\n\tend\n\n\tdef select_node(i)\n\t\t@bits -= (@bits & @select_mask[i])\n\tend\n\n\tdef deleted?(i)\n\t\t@bits[i * @n + i] == 0\n\tend\n\n\tdef deg_zero?(i)\n\t\ttmp = subbits(i)\n\t\ttmp & (tmp - 1) == 0\n\tend\n\n\tdef deg_one?(i)\n\t\ttmp = subbits(i)\n\t\ttmp &= (tmp - 1) \n\t\ttmp & (tmp - 1) == 0\n\tend\n\n\tdef subbits(i)\n\t\t(@bits >> i * @n) & ((1 << @n) - 1)\n\tend\n\n\tdef opposite(i)\n\t\ttmp = subbits(i)\n\t\ttmp -= (1 << i)\n\t\t@pos[(tmp ^ (tmp - 1))]\n\tend\nend\n\ndef search(w, graph, i)\n\treturn w if i >= $weight.size\n\treturn $lower_bound if w + $accum[i] <= $lower_bound\n\treturn search(w, graph, i+1) if graph.deleted?(i)\n\treturn search(w + $weight[i], graph, i+1) if graph.deg_zero?(i)\n\n\tg = graph.dup\n\tg.select_node(i)\n\tx =  search(w + $weight[i], g, i+1)\n\n\tg = graph\n\tif g.deg_one?(i)\n\t\tk = g.opposite(i)\n\t\tg.select_node(k)\n\t\ty = search(w + $weight[k], g, i+1)\t\t\n\telse\n\t\tg.del_node(i)\n   \t\ty = search(w, g, i+1)\n\tend\n\n\tans = x > y ? x : y\n\t$lower_bound = ans if ans > $lower_bound\n\tans\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tindex = {}\n\tgraph = GraphBits.new(n)\n\t$weight = Array.new(n)\n\t\t\n\tn.times {\n\t\tcountry, $weight_str, _, *neighbours = gets.split\n\n\t\ti = (index[country] ||= index.size)\n\t\t$weight[i] = $weight_str.to_i\n\n\t\tneighbours.each{|neighbour|\n\t\t\tj = (index[neighbour] ||= index.size)\n\t\t\tgraph.add_edge(i, j)\n\t\t}\n\t}\n\n\t$lower_bound = 0\n\t$accum = $weight.reverse.inject([0]){|a, w| a + [a[-1] + w]}\n\t$accum = $accum[1..-1].reverse\n\n\tgraph.select_node(0)\n\tp search($weight[0], graph, 1)\n}"
  },
  {
    "language": "Ruby",
    "code": "class GraphBits\n\tdef initialize(n)\n\t\t@n = n\n\t\t@bits = 1\n\t\t(n-1).times { @bits = (@bits << @n + 1) | 1 }\n\t\t@ones = 1\n\t\t(n-1).times { @ones = (@ones << @n) | 1 }\n\t\t@mask = (0..@n-1).map{|i| @ones << i}\n\n\t\t@pos = {}\n\t\tx = 1\n\t\ti = 0\n\t\t@n.times {\n\t\t\t@pos[x] = i\n\t\t\tx = (x << 1) | 1\n\t\t\ti += 1\n\t\t}\n\n\tend\n\n\tdef add_edge(i, j)\n\t\t@bits |= (1 << i * @n + j)\n\t\t@mask[i] |= (@ones << j)\n\tend\n\n\tdef del_node(i)\n\t\ttmp = @bits & (@ones << i)\n\t\t@bits -= tmp\n\tend\n\n\tdef select_node(i)\n\t\t@bits -= (@bits & @mask[i])\n\tend\n\n\tdef deleted?(i)\n\t\t@bits[i * @n + i] == 0\n\tend\n\n\tdef deg_zero?(i)\n\t\ttmp = subbits(i)\n\t\ttmp & (tmp - 1) == 0\n\tend\n\n\tdef deg_one?(i)\n\t\ttmp = subbits(i)\n\t\ttmp &= (tmp - 1) \n\t\ttmp & (tmp - 1) == 0\n\tend\n\n\tdef subbits(i)\n\t\t(@bits >> i * @n) & ((1 << @n) -1 )\n\tend\n\n\tdef opposite(i)\n\t\ttmp = subbits(i)\n\t\ttmp -= (1 << i)\n\t\t@pos[(tmp ^ (tmp - 1))]\n\tend\n\n\tdef inspect\n\t\ta = (0..@n-1).map{|i|\n\t\t\t\t[$name[i], (0..@n-1).select{|j| subbits(i)[j] == 1 }.map{|j| $name[j]}]\n\t\t\t}\n\t\tHash[*a.flatten(1)]\n\tend\nend\n\ndef search(graph, weight, i)\n\treturn 0 if i >= weight.size\n\n\treturn search(graph, weight, i+1) if graph.deleted?(i)\n\t\n\treturn weight[i] + search(graph, weight, i+1) if graph.deg_zero?(i)\n\n\tg = graph.dup\n\tg.select_node(i)\n\tx = weight[i] + search(g, weight, i+1)\n\n\ty = 0\n\tg = graph.dup\n\tif g.deg_one?(i)\n\t\tk = g.opposite(i)\n\t\tg.select_node(k)\n\t\ty = weight[k] + search(g, weight, i+1)\t\t\n\telse\n\t\tg.del_node(i)\n   \ty = search(g, weight, i+1)\n\tend\n\n\tx > y ? x : y\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tindex = {}\n\tgraph = GraphBits.new(n)\n\tweight = Array.new(n)\n\t$name = Array.new(n)\n\t\t\n\tn.times {\n\t\tcountry, weight_str, _, *neighbours = gets.split\n\n\t\ti = (index[country] ||= index.size)\n\t\t$name[i] = country\n\t\tweight[i] = weight_str.to_i\n\n\t\tneighbours.each{|neighbour|\n\t\t\tj = (index[neighbour] ||= index.size)\n\t\t\tgraph.add_edge(i, j)\n\t\t}\n\t}\n\n\t\n\tgraph.select_node(0)\n\tp weight[0] + search(graph, weight, 1)\n}"
  },
  {
    "language": "Ruby",
    "code": "class GraphBits\n\tdef initialize(n)\n\t\t@n = n\n\t\t@bits = 1\n\n\t\t(n-1).times {\n\t\t\t@bits = (@bits << @n + 1) | 1\n\t\t}\n\n\t\t@ones = 1\n\t\t(n-1).times { @ones = (@ones << @n) | 1 }\n\t\t@select_mask = (0..@n-1).map{|i| @ones << i}\n\n\t\t@succ_ones = (1 << @n) - 1\n\n\t\t@pos = {}\n\t\tx = 1\n\t\ti = 0\n\t\t@n.times {\n\t\t\t@pos[x] = i\n\t\t\tx = (x << 1) | 1\n\t\t\ti += 1\n\t\t}\n\tend\n\n\tdef add_edge(i, j)\n\t\t@bits |= (1 << i * @n + j)\n\t\t@select_mask[i] |= (@ones << j)\n\tend\n\n\tdef del_node(i)\n\t\ttmp = @bits & (@ones << i)\n\t\t@bits -= tmp\n\tend\n\n\tdef select_node(i)\n\t\t@bits -= (@bits & @select_mask[i])\n\tend\n\n\tdef deleted?(i)\n\t\t@bits[i * @n + i] == 0\n\tend\n\n\tdef deg_zero?(i)\n\t\ttmp = subbits(i)\n\t\ttmp & (tmp - 1) == 0\n\tend\n\n\tdef deg_one?(i)\n\t\ttmp = subbits(i)\n\t\ttmp &= (tmp - 1) \n\t\ttmp & (tmp - 1) == 0\n\tend\n\n\tdef subbits(i)\n\t\t(@bits >> i * @n) & @succ_ones\n\tend\n\n\tdef opposite(i)\n\t\ttmp = subbits(i)\n\t\ttmp -= (1 << i)\n\t\t@pos[(tmp ^ (tmp - 1))]\n\tend\n\n\tdef next(i)\n\t\ttmp = @bits & @diag\n\t\ttmp ^= tmp - 1\n\t\t@hoge[tmp]\n\tend\n\n\tdef inspect\n\t\ta = (0..@n-1).map{|i|\n\t\t\t\t[$name[i], (0..@n-1).select{|j| subbits(i)[j] == 1 }.map{|j| $name[j]}]\n\t\t\t}\n\t\tHash[*a.flatten(1)]\n\tend\n\n\tdef hash\n\t\t@bits.hash\t\n\tend\nend\n\ndef search(w, graph, i)\n\treturn w if i >= $weight.size\n\n\treturn $lower_bound if w + $accum[i] <= $lower_bound\n\n\treturn search(w, graph, i+1) if graph.deleted?(i)\n\t\n\treturn search(w + $weight[i], graph, i+1) if graph.deg_zero?(i)\n\n\tg = graph.dup\n\tg.select_node(i)\n\tx =  search(w + $weight[i], g, i+1)\n\n\ty = 0\n\tg = graph\n\tif g.deg_one?(i)\n\t\tk = g.opposite(i)\n\t\tg.select_node(k)\n\t\ty = search(w + $weight[k], g, i+1)\t\t\n\telse\n\t\tg.del_node(i)\n   \t\ty = search(w, g, i+1)\n\tend\n\n\tans = x > y ? x : y\n\t$lower_bound = ans if ans > $lower_bound\n\tans\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tindex = {}\n\tgraph = GraphBits.new(n)\n\t$weight = Array.new(n)\n\t$name = Array.new(n)\n\t\t\n\tn.times {\n\t\tcountry, $weight_str, _, *neighbours = gets.split\n\n\t\ti = (index[country] ||= index.size)\n\t\t$name[i] = country\n\t\t$weight[i] = $weight_str.to_i\n\n\t\tneighbours.each{|neighbour|\n\t\t\tj = (index[neighbour] ||= index.size)\n\t\t\tgraph.add_edge(i, j)\n\t\t}\n\t}\n\n\t$lower_bound = 0\n\t#graph.select_node(0)\n\t$accum = $weight.reverse.inject([0]){|a, w| a + [a[-1] + w]}\n\t$accum = $accum[1..-1].reverse\n\n\tgraph.select_node(0)\n\tp search($weight[0], graph, 1)\n}"
  },
  {
    "language": "Ruby",
    "code": "class GraphBits\n\tdef initialize(n)\n\t\t@n = n\n\t\t@bits = 1\n\t\t(n-1).times { @bits = (@bits << @n + 1) | 1 }\n\t\t@ones = 1\n\t\t(n-1).times { @ones = (@ones << @n) | 1 }\n\tend\n\n\tdef add_edge(i, j)\n\t\t@bits |= (1 << i * @n + j)\n\tend\n\n\tdef del_node(i)\n\t\ttmp = @bits & (@ones << i)\n\t\t@bits -= tmp\n\tend\n\n\tdef select_node(i)\n\t\tdel_node(i)\n\t\t(0..@n-1).each{|j|\n\t\t\tdel_node(j) if @bits[i * @n + j] == 1\n\t\t}\n\tend\n\n\tdef deleted?(i)\n\t\t@bits[i * @n + i] == 0\n\tend\n\nend\n\n\ndef search(graph, weight, i)\n\treturn 0 if i >= weight.size\n\tmax = 0\t\n\tfor j in i..weight.size-1\n\t\tunless graph.deleted?(j)\n\t\t\tg = graph.dup\n\t\t\tg.select_node(j)\n\t\t\tret = weight[j] + search(g, weight, j+1)\t\n\t\t\tmax = ret if ret > max\n\t\tend\n\tend\n\tmax\nend\n\t\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tindex = {}\n\tgraph = GraphBits.new(n)\n\tweight = Array.new(n)\n\t\t\n\tn.times {\n\t\tcountry, weight_str, _, *neighbours = gets.split\n\n\t\ti = (index[country] ||= index.size)\n\t\tweight[i] = weight_str.to_i\n\n\t\tneighbours.each{|neighbour|\n\t\t\tj = (index[neighbour] ||= index.size)\n\t\t\tgraph.add_edge(i, j)\n\t\t}\n\t}\n\n\tgraph.select_node(0)\n\tp weight[0] + search(graph, weight, 0)\n}"
  },
  {
    "language": "Ruby",
    "code": "class GraphBits\n\tdef initialize(n)\n\t\t@n = n\n\t\t@bits = 1\n\t\t(n-1).times { @bits = (@bits << @n + 1) | 1 }\n\t\t@ones = 1\n\t\t(n-1).times { @ones = (@ones << @n) | 1 }\n\t\t@mask = (0..@n-1).map{|i| @ones << i}\n\tend\n\n\tdef add_edge(i, j)\n\t\t@bits |= (1 << i * @n + j)\n\t\t@mask[i] |= (@ones << j)\n\tend\n\n\tdef del_node(i)\n\t\ttmp = @bits & (@ones << i)\n\t\t@bits -= tmp\n\tend\n\n\tdef select_node(i)\n\t\t@bits -= (@bits & @mask[i])\n\tend\n\n\tdef deleted?(i)\n\t\t@bits[i * @n + i] == 0\n\tend\n\n\tdef deg(i)\n\t\t(i*@n .. (i+1)*@n-1).count{|j| @bits[j] == 1} - (deleted?(i) ? 0 : 1)\n\tend\n\n\tdef opposite(i)\n\t\tj = i * @n \n\t\tj += 1 until j % @n != i && @bits[j] == 1\n\t\tj % @n\n\tend\n\nend\n\ndef search(graph, weight, i)\n\treturn 0 if i >= weight.size\n\t\n\tbase = 0\n\tfor j in i..weight.size-1\n\t\tif !graph.deleted?(j) && graph.deg(j) == 0\n\t\t\tgraph.select_node(j)\n\t\t\tbase += weight[j]\n\t\tend\n\tend\n\n\tmax = base\t\n\tfor j in i..weight.size-1\n\t\tnext if graph.deleted?(j)\n\n\t\tg = graph.dup\n\t\tg.select_node(j)\n\t\tret = base + weight[j] + search(g, weight, j+1)\t\n\t\tmax = ret if ret > max\n\n\t\tif graph.deg(j) == 1\n\t\t\tk = graph.opposite(j)\n\t\t\tgraph.select_node(k)\n\t\t\tbase += weight[k]\n\t\t\tmax = base if base > max\n\t\tend\n\tend\n\tmax\nend\n\nloop {\n\tn = gets.to_i\n\tbreak if n == 0\n\n\tindex = {}\n\tgraph = GraphBits.new(n)\n\tweight = Array.new(n)\n\t\t\n\tn.times {\n\t\tcountry, weight_str, _, *neighbours = gets.split\n\n\t\ti = (index[country] ||= index.size)\n\t\tweight[i] = weight_str.to_i\n\n\t\tneighbours.each{|neighbour|\n\t\t\tj = (index[neighbour] ||= index.size)\n\t\t\tgraph.add_edge(i, j)\n\t\t}\n\t}\n\n\tgraph.select_node(0)\n\tp weight[0] + search(graph, weight, 0)\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.string;\nimport std.algorithm;\n\nclass Graph {\n    int[] value;\n    int[][] next;\n    int size;\n    this(int size) {\n        this.size = size;\n        value = new int[size];\n        next = new int[][size];\n        groupId = new int[size];\n    }\n\n    int[] groupId;\n    long[] group;\n    int gidCount;\n    void initGroupId() {\n        void dfs(int v, int id) {\n            groupId[v] = id;\n            foreach (u; next[v]) {\n                if (!groupId[u]) {\n                    dfs(u, id);\n                }\n            }\n        }\n        int cid = 0;\n        foreach (v; 0 .. size) {\n            if (!groupId[v]) dfs(v, ++cid);\n        }\n        gidCount = cid;\n\n        group = new long[gidCount + 1];\n        foreach (i; 1 .. gidCount + 1) {\n            foreach (v; 0 .. size) {\n                if (groupId[v] == i) {\n                    group[i] |= (1L << v);\n                }\n            }\n        }\n    }\n\n    int first(long flag) {\n        foreach (i; 0 .. size) {\n            if (flag & (1L << i)) return i;\n        }\n        assert(0);\n    }\n\n    int maximum() {\n        int maxInGroup(int v, long used) {\n            int ans = 0;\n            void dfs(int v, long used, int cans) {\n                if (v == size) {\n                    ans = max(ans, cans);\n                    return;\n                }\n                if (used & (1L << v)) {\n                    dfs(v + 1, used, cans);\n                    return;\n                }\n                int a = cans;\n                foreach (i; 0 .. size) {\n                    if (!(used & (1L << i))) {\n                        a += value[i];\n                    }\n                }\n                if (a <= ans) return;\n\n                used |= (1L << v);\n                long _used = used;\n\n                foreach (u; next[v]) used |= (1L << u);\n                dfs(v + 1, used, cans + value[v]);\n\n                if (v == 0) return;\n\n                used = _used;\n                dfs(v + 1, used, cans);\n            }\n            dfs(v, used, 0);\n            return ans;\n        }\n\n        initGroupId;\n        int ret = 0;\n        long u = 0;\n        foreach (i; 1 .. gidCount + 1) {\n            //writeln(i, \" \", first(group[i]), \" \", popcnt(group[i]));\n            ret += maxInGroup(first(group[i]), ~group[i]);\n        }\n        //writeln(\"called \", called, \" times.\");\n        return ret;\n    }\n\n    int n(int v, long used) {\n        foreach (u; v + 1 .. size) {\n            if (!(used & (1L << u))) return u;\n        }\n        return -1;\n    }\n\n    int popcnt(long x) {\n        int c = 0;\n        foreach (i; 0 .. size) {\n            if (x & (1L << i)) {\n                c++;\n            }\n        }\n        return c;\n    }\n}\n\nvoid main() {\n    int N; \n    while (readf(\"%d\\n\", &N), N) {\n        int[string] id; int cid = 0;\n        Graph g = new Graph(N);\n        foreach (i; 0 .. N) {\n            string A; int B, C;\n            readf(\"%s %d %d\", &A, &B, &C);\n            if (id.get(A, -1) == -1) id[A] = cid++;\n            g.value[id[A]] = B;\n            if (C != 0) readf(\" \");\n            string[] Ds = readln.chomp.split(\" \");\n            foreach (D; Ds) {\n                if (id.get(D, -1) == -1) id[D] = cid++;\n                g.next[id[A]] ~= id[D];\n            }\n        }\n        g.maximum.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.array;\nimport std.conv;\nimport std.string;\nimport std.algorithm;\n\nclass Graph {\n    int[] value;\n    int[][] next;\n    int size;\n    this(int size) {\n        this.size = size;\n        value = new int[size];\n        next = new int[][size];\n    }\n    int max() {\n        int[] groupId = new int[size]; // 連結グラフの集合に分割する\n        int gidCount;\n        void initGroupId() {\n            void dfs(int v, int id) {\n                groupId[v] = id;\n                foreach (u; next[v]) {\n                    if (!groupId[u]) {\n                        dfs(u, id);\n                    }\n                }\n            }\n            int cid = 0;\n            foreach (v; 0 .. size) {\n                if (!groupId[v]) dfs(v, ++cid);\n            }\n            gidCount = cid;\n        }\n        initGroupId;\n\n        auto used = new bool[size];\n\n        int dfs(int v) {\n            if (used[v]) return 0;\n\n            used[v] = true;\n\n            bool[] _used = used.dup;\n\n            foreach (u; next[v]) used[u] = true;\n            int ret = value[v];\n            foreach (u; v + 1 .. size) {\n                if (!used[u] && groupId[v] == groupId[u]) {\n                    ret += dfs(u);\n                    break;\n                }\n            }\n\n            if (v == 0) return ret;\n\n            used = _used;\n\n            foreach (u; next[v]) {\n                if (!used[u]) {\n                    ret = std.algorithm.max(ret, dfs(u));\n                    break;\n                }\n            }\n\n            return ret;\n        }\n        \n        int ret = 0;\n        foreach (i; 0 .. size) {\n            ret += dfs(i);\n        }\n        return ret;\n    }\n}\n\nvoid main() {\n    int N; \n    while (readf(\"%d\\n\", &N), N) {\n        int[string] id; int cid = 0;\n        Graph g = new Graph(N);\n        foreach (i; 0 .. N) {\n            string A; int B, C;\n            readf(\"%s %d %d\", &A, &B, &C);\n            if (id.get(A, -1) == -1) id[A] = cid++;\n            g.value[id[A]] = B;\n            if (C != 0) readf(\" \");\n            string[] Ds = readln.chomp.split(\" \");\n            foreach (D; Ds) {\n                if (id.get(D, -1) == -1) id[D] = cid++;\n                g.next[id[A]] ~= id[D];\n            }\n        }\n        g.max.writeln;\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.functional;\nimport std.array;\nimport std.conv;\nimport std.string;\nimport std.algorithm;\n\nclass Graph {\n    int[] value;\n    int[][] next;\n    int size;\n    this(int size) {\n        this.size = size;\n        value = new int[size];\n        next = new int[][size];\n    }\n    int max() {\n        int[] groupId = new int[size]; // 連結グラフの集合に分割する\n        int gidCount;\n        void initGroupId() {\n            void dfs(int v, int id) {\n                groupId[v] = id;\n                foreach (u; next[v]) {\n                    if (!groupId[u]) {\n                        dfs(u, id);\n                    }\n                }\n            }\n            int cid = 0;\n            foreach (v; 0 .. size) {\n                if (!groupId[v]) dfs(v, ++cid);\n            }\n            gidCount = cid;\n        }\n        initGroupId;\n\n        int dfs(int v, long used) {\n            int gid = groupId[v];\n            if (used & (1L << v)) return 0;\n\n            used |= (1L << v);\n\n            long _used = used;\n\n            foreach (u; next[v]) used |= (1L << u);\n            int ret = value[v];\n            foreach (u; 0 .. size) {\n                if (!(used & (1L << u)) && groupId[u] == gid) {\n                    ret += dfs(u, used);\n                    break;\n                }\n            }\n\n            if (v == 0) return ret;\n\n            used = _used;\n\n            foreach (u; next[v]) {\n                if (!(used & (1L << u)) && groupId[u] == gid) {\n                    ret = std.algorithm.max(ret, dfs(u, used));\n                    break;\n                }\n            }\n\n            return ret;\n        }\n        \n        int ret = 0;\n        foreach (i; 1 .. gidCount + 1) {\n            foreach (j; 0 .. size) {\n                if (groupId[j] == i) {\n                    //[i, groupId.count(i)].writeln;\n                    ret += dfs(j, 0);\n                    break;\n                }\n            }\n        }\n        return ret;\n    }\n}\n\nvoid main() {\n    int N; \n    while (readf(\"%d\\n\", &N), N) {\n        int[string] id; int cid = 0;\n        Graph g = new Graph(N);\n        foreach (i; 0 .. N) {\n            string A; int B, C;\n            readf(\"%s %d %d\", &A, &B, &C);\n            if (id.get(A, -1) == -1) id[A] = cid++;\n            g.value[id[A]] = B;\n            if (C != 0) readf(\" \");\n            string[] Ds = readln.chomp.split(\" \");\n            foreach (D; Ds) {\n                if (id.get(D, -1) == -1) id[D] = cid++;\n                g.next[id[A]] ~= id[D];\n            }\n        }\n        g.max.writeln;\n    }\n}"
  },
  {
    "language": "Python",
    "code": "import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 / 10**13\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    rr = []\n\n    def f(n):\n        a = [LS() for _ in range(n)]\n        sn = {}\n        for i in range(n):\n            sn[a[i][0]] = i\n        b = []\n        bs = {}\n        bb = {}\n        kr = int(a[0][1])\n        for i in range(1, n):\n            ai = a[i]\n            if a[0][0] in ai[3:]:\n                continue\n            if ai[2] == '0':\n                kr += int(ai[1])\n                continue\n            b.append([2**sn[ai[0]],int(ai[1]), sum(map(lambda x: 2**sn[x],ai[3:]))])\n            bs[b[-1][0]] = b[-1][-1]\n            bb[b[-1][0]] = b[-1][1]\n\n        fm = {}\n        def _f(i):\n            if i == 0:\n                return 0\n            if i in fm:\n                return fm[i]\n            r = 0\n            si = 0\n            kr = 0\n            nsi = 0\n            while i > si:\n                ti = i - si\n                ni = ti - (ti & (ti-1))\n                si += ni\n                if (bs[ni] & i) == 0:\n                    nsi += ni\n                    kr += bb[ni]\n\n            si = nsi\n            while i > si:\n                ti = i - si\n                ni = ti - (ti & (ti-1))\n                nr = bb[ni]\n                si += ni\n                nr += _f(i - nsi - ni - (i & bs[ni]))\n                if r < nr:\n                    r = nr\n\n            fm[i] = r + kr\n            return r + kr\n\n        r = 0\n        l = len(b)\n        l2 = l//2\n        ii = [b[i][0] for i in range(l2)]\n        ab = sum(map(lambda x: x[0], b))\n        anb = sum(map(lambda x: x[0], b[l2:]))\n        # print('ii',ii)\n        # print('b',b)\n        # print('bb',bb)\n        # print('bs',bs)\n        # return _f(anb)\n        for i in range(l2+1):\n            for ia in itertools.combinations(ii, i):\n                ti = sum(ia)\n                tf = False\n                tr = 0\n                ts = 0\n                for j in ia:\n                    if bs[j] & ti:\n                        tf = True\n                        break\n                    tr += bb[j]\n                    ts |= bs[j]\n                if tf:\n                    continue\n                # print('tr',tr)\n                tr += _f(anb - (anb & ts))\n                # print('i',i,ti,tr,ts)\n                if r < tr:\n                    r = tr\n\n        return r + kr\n\n    while 1:\n        n = I()\n        if n == 0:\n            break\n        rr.append(f(n))\n        # print(n, rr[-1])\n\n    return '\\n'.join(map(str, rr))\n\n\nprint(main())\n\n"
  },
  {
    "language": "Rust",
    "code": "extern crate core;\n\nuse std::fmt;\nuse std::cmp::{Ordering, min, max};\nuse std::fmt::{Display, Error, Formatter};\nuse std::f32::MAX;\nuse std::ops::{Add, Sub, Mul, Div, Neg, Index, IndexMut};\nuse std::collections::BTreeMap;\n\nfn show<T: Display>(vec: &Vec<T>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        print!(\"[{}\", vec[0]);\n        for i in 1 .. vec.len() {\n            print!(\", {}\", vec[i]);\n        }\n        println!(\"]\");\n    }\n}\nfn show2<T: Display>(vec: &Vec<Vec<T>>) {\n    if vec.is_empty() {\n        println!(\"[]\");\n    }else {\n        for l in vec {\n            show(l);\n        }\n    }\n}\nmacro_rules! read_line{\n    () => {{\n        let mut line = String::new();\n        std::io::stdin().read_line(&mut line).ok();\n        line\n    }};\n    (delimiter: ' ') => {\n        read_line!().split_whitespace().map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (delimiter: $p:expr) => {\n        read_line!().split($p).map(|x|x.to_string()).collect::<Vec<_>>()\n    };\n    (' ') => {\n        read_line!(delimiter: ' ')\n    };\n    ($delimiter:expr) => {\n        read_line!(delimiter: $delimiter)\n    };\n    (' '; $ty:ty) => {\n        read_line!().split_whitespace().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n    ($delimiter:expr; $ty:ty) => {\n        read_line!($delimiter).into_iter().map(|x|x.parse::<$ty>().ok().unwrap()).collect::<Vec<$ty>>()\n    };\n}\nmacro_rules! read_value{\n    () => {\n        read_line!().trim().parse().ok().unwrap()\n    }\n}\nmacro_rules! let_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\nmacro_rules! let_mut_all {\n    ($($n:ident:$t:ty),*) => {\n        let line = read_line!(delimiter: ' ');\n        let mut iter = line.iter();\n        $(let mut $n:$t = iter.next().unwrap().parse().ok().unwrap();)*\n    };\n}\n\nfn main() {\n    loop {\n        let_all!(n: usize);\n        if n == 0 {\n            return\n        }\n        let mut map = BTreeMap::new();\n        let mut strength = Vec::<i32>::with_capacity(n);\n        let mut neighbors = Vec::with_capacity(n);\n        for _ in 0 .. n {\n            let line = read_line!(' ');\n            map.insert(line[0].clone(), strength.len());\n            strength.push(line[1].parse().ok().unwrap());\n            let mut n = Vec::with_capacity(line[2].parse().ok().unwrap());\n            for i in 3 .. line.len() {\n                n.push(line[i].clone());\n            }\n            neighbors.push(n);\n        }\n        let mut neighbor = vec![Vec::new(); n];\n        for i in 0 .. n {\n            for j in 0 .. neighbors[i].len() {\n                neighbor[i].push(map[&neighbors[i][j]]);\n            }\n        }\n        let mut memo = vec![vec![-1; 1 << (n / 2)]; n / 2];\n        println!(\"{}\", solve(n - 1, neighbor[0].iter().fold(1, |acc, &a| acc | (1 << a as i64)), &strength, &neighbor, &mut memo) + strength[0]);\n    }\n}\nfn solve(current: usize, cant_use: i64, strength: &Vec<i32>, neighbors: &Vec<Vec<usize>>, memo: &mut Vec<Vec<i32>>) -> i32 {\n    if current == 0 {\n        if cant_use & 1 == 0 {\n            strength[current]\n        }else {\n            0\n        }\n    }else if current < memo.len() {\n        let state = (cant_use & ((1_i64 << memo.len() as i64) - 1)) as usize;\n        match memo[current][state] {\n            -1 => {\n                let r = if cant_use & (1_i64 << current as i64) == 0 {\n                    let not_use_current = solve(current - 1, cant_use, strength, neighbors, memo);\n                    let use_current = solve(current - 1, neighbors[current].iter().fold(cant_use, |acc, &a| acc | (1_i64 << a as i64)), strength, neighbors, memo) + strength[current];\n                    max(not_use_current, use_current)\n                }else {\n                    solve(current - 1, cant_use, strength, neighbors, memo)\n                };\n                memo[current][state] = r;\n                r\n            }\n            cache => cache\n        }\n    }else {\n        if cant_use & (1_i64 << current as i64) == 0 {\n            let not_use_current = solve(current - 1, cant_use, strength, neighbors, memo);\n            let use_current = solve(current - 1, neighbors[current].iter().fold(cant_use, |acc, &a| acc | (1_i64 << a as i64)), strength, neighbors, memo) + strength[current];\n            max(not_use_current, use_current)\n        }else {\n            solve(current - 1, cant_use, strength, neighbors, memo)\n        }\n    }\n}\n"
  }
]