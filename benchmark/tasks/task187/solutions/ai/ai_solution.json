[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 100\n\ntypedef struct {\n    int node;\n    int weight;\n} Edge;\n\nEdge graph[MAX_NODES][MAX_NODES];\nint graph_size[MAX_NODES] = {0};\nint dist[MAX_NODES];\nint shortest_paths[MAX_NODES];\nint count[MAX_NODES];\ndouble probability[MAX_NODES];\n\nvoid dijkstra(int start, int n) {\n    int visited[MAX_NODES] = {0};\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        shortest_paths[i] = 0;\n    }\n    dist[start] = 0;\n    shortest_paths[start] = 1;\n\n    for (int i = 0; i < n; i++) {\n        int u = -1;\n        for (int j = 0; j < n; j++) {\n            if (!visited[j] && (u == -1 || dist[j] < dist[u])) {\n                u = j;\n            }\n        }\n        if (dist[u] == INT_MAX) break;\n        visited[u] = 1;\n\n        for (int k = 0; k < graph_size[u]; k++) {\n            Edge e = graph[u][k];\n            int v = e.node;\n            int weight = e.weight;\n            if (dist[v] > dist[u] + weight) {\n                dist[v] = dist[u] + weight;\n                shortest_paths[v] = shortest_paths[u];\n            } else if (dist[v] == dist[u] + weight) {\n                shortest_paths[v] += shortest_paths[u];\n            }\n        }\n    }\n}\n\nvoid calculate_counts(int n) {\n    for (int i = 0; i < n; i++) {\n        count[i] = 0;\n    }\n    count[n-1] = 1;\n\n    int queue[MAX_NODES];\n    int front = 0, rear = 0;\n    queue[rear++] = n-1;\n\n    int visited[MAX_NODES] = {0};\n    visited[n-1] = 1;\n\n    while (front < rear) {\n        int u = queue[front++];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < graph_size[i]; j++) {\n                Edge e = graph[i][j];\n                if (e.node == u && dist[i] + e.weight == dist[u]) {\n                    count[i] += count[u];\n                    if (!visited[i]) {\n                        visited[i] = 1;\n                        queue[rear++] = i;\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid calculate_probability(int n) {\n    for (int i = 0; i < n; i++) {\n        probability[i] = 0.0;\n    }\n    probability[0] = 1.0;\n\n    int queue[MAX_NODES];\n    int front = 0, rear = 0;\n    queue[rear++] = 0;\n\n    int visited[MAX_NODES] = {0};\n    visited[0] = 1;\n\n    while (front < rear) {\n        int u = queue[front++];\n        for (int k = 0; k < graph_size[u]; k++) {\n            Edge e = graph[u][k];\n            int v = e.node;\n            if (dist[v] == dist[u] + e.weight) {\n                probability[v] += probability[u] * (shortest_paths[u] / (double)shortest_paths[v]) * (count[v] / (double)count[u]);\n                if (!visited[v]) {\n                    visited[v] = 1;\n                    queue[rear++] = v;\n                }\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, p;\n    scanf(\"%d %d %d\", &n, &m, &p);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        graph[u][graph_size[u]].node = v;\n        graph[u][graph_size[u]++].weight = w;\n        graph[v][graph_size[v]].node = u;\n        graph[v][graph_size[v]++].weight = w;\n    }\n\n    dijkstra(0, n);\n    calculate_counts(n);\n    calculate_probability(n);\n\n    for (int i = 0; i < p; i++) {\n        int child_node;\n        scanf(\"%d\", &child_node);\n        printf(\"%.8f\\n\", probability[child_node]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:59:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass SantaDelivery {\n    public double[] probabilityOfSeeingSanta(int n, int[][] edges, int[] children) {\n        // Create adjacency list representation of graph\n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(new int[]{edge[1], edge[2]});\n            graph.get(edge[1]).add(new int[]{edge[0], edge[2]});\n        }\n\n        // Find shortest distance from node 0 to all other nodes\n        int[] distances = new int[n];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[0] = 0;\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[]{0, 0});\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int node = current[0], dist = current[1];\n\n            if (dist > distances[node]) continue;\n\n            for (int[] neighbor : graph.get(node)) {\n                int nextNode = neighbor[0], weight = neighbor[1];\n                int newDist = dist + weight;\n\n                if (newDist < distances[nextNode]) {\n                    distances[nextNode] = newDist;\n                    pq.offer(new int[]{nextNode, newDist});\n                }\n            }\n        }\n\n        // Count shortest paths using DP\n        long[] shortestPaths = new long[n];\n        shortestPaths[0] = 1;\n\n        boolean[] visited = new boolean[n];\n        pq = new PriorityQueue<>((a, b) -> distances[a] - distances[b]);\n        pq.offer(0);\n\n        while (!pq.isEmpty()) {\n            int node = pq.poll();\n            if (visited[node]) continue;\n            visited[node] = true;\n\n            for (int[] neighbor : graph.get(node)) {\n                int nextNode = neighbor[0], weight = neighbor[1];\n                if (distances[node] + weight == distances[nextNode]) {\n                    shortestPaths[nextNode] += shortestPaths[node];\n                    if (!visited[nextNode]) {\n                        pq.offer(nextNode);\n                    }\n                }\n            }\n        }\n\n        // Calculate probability for each child\n        double[] result = new double[children.length];\n        long totalPaths = shortestPaths[n - 1];\n\n        for (int i = 0; i < children.length; i++) {\n            long pathsThroughChild = countPathsThroughNode(graph, children[i], distances, shortestPaths, n);\n            result[i] = (double) pathsThroughChild / totalPaths;\n        }\n\n        return result;\n    }\n\n    private long countPathsThroughNode(List<List<int[]>> graph, int targetNode, int[] distances, long[] shortestPaths, int n) {\n        long[] paths = new long[n];\n        paths[0] = 1;\n\n        boolean[] visited = new boolean[n];\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> distances[a] - distances[b]);\n        pq.offer(0);\n\n        while (!pq.isEmpty()) {\n            int node = pq.poll();\n            if (visited[node]) continue;\n            visited[node] = true;\n\n            for (int[] neighbor : graph.get(node)) {\n                int nextNode = neighbor[0], weight = neighbor[1];\n                if (distances[node] + weight == distances[nextNode]) {\n                    paths[nextNode] += paths[node];\n                    if (!visited[nextNode]) {\n                        pq.offer(nextNode);\n                    }\n                }\n            }\n        }\n\n        long pathsThroughTarget = node(graph, targetNode, distances, shortestPaths, n);\n        return pathsThroughTarget;\n    }\n\n    private long node(List<List<int[]>> graph, int targetNode, int[] distances, long[] shortestPaths, int n) {\n        long[] paths = new long[n];\n        paths[0] = 1;\n\n        boolean[] visited = new boolean[n];\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> distances[a] - distances[b]);\n        pq.offer(0);\n\n        while (!pq.isEmpty()) {\n            int node = pq.poll();\n            if (visited[node]) continue;\n            visited[node] = true;\n\n            for (int[] neighbor : graph.get(node)) {\n                int nextNode = neighbor[0], weight = neighbor[1];\n                if (distances[node] + weight == distances[nextNode]) {\n                    paths[nextNode] += paths[node];\n                    if (!visited[nextNode]) {\n                        pq.offer(nextNode);\n                    }\n                }\n            }\n        }\n\n        return paths[n - 1];\n    }\n}",
    "timestamp": "2025-08-05 19:00:00"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n\nusing namespace std;\n\nvector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int start) {\n    int n = graph.size();\n    vector<int> dist(n, INT_MAX);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    dist[start] = 0;\n    pq.push({0, start});\n\n    while (!pq.empty()) {\n        int current_dist = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (current_dist > dist[u]) continue;\n\n        for (const auto& edge : graph[u]) {\n            int v = edge.first;\n            int weight = edge.second;\n            if (dist[v] > dist[u] + weight) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n    return dist;\n}\n\nvoid countPaths(const vector<vector<pair<int, int>>>& graph, int u, int target, const vector<int>& dist, vector<int>& path_count) {\n    if (u == target) {\n        path_count[u] = 1;\n        return;\n    }\n    if (path_count[u] != 0) return;\n\n    for (const auto& edge : graph[u]) {\n        int v = edge.first;\n        int weight = edge.second;\n        if (dist[u] + weight == dist[v]) {\n            countPaths(graph, v, target, dist, path_count);\n            path_count[u] += path_count[v];\n        }\n    }\n}\n\nvector<double> calculateProbabilities(int n, const vector<vector<int>>& edges, const vector<int>& children) {\n    vector<vector<pair<int, int>>> graph(n);\n    for (const auto& edge : edges) {\n        int u = edge[0], v = edge[1], w = edge[2];\n        graph[u].emplace_back(v, w);\n        graph[v].emplace_back(u, w);\n    }\n\n    vector<int> dist = dijkstra(graph, 0);\n    vector<int> path_count(n, 0);\n    countPaths(graph, 0, n - 1, dist, path_count);\n    int total_paths = path_count[0];\n\n    vector<double> probabilities(n, 0.0);\n    for (int u : children) {\n        if (path_count[u] > 0) {\n            vector<int> path_count_from_u(n, 0);\n            countPaths(graph, u, n - 1, dist, path_count_from_u);\n            probabilities[u] = static_cast<double>(path_count_from_u[u]) * path_count[u] / total_paths;\n        }\n    }\n\n    vector<double> result;\n    for (int u : children) {\n        result.push_back(probabilities[u]);\n    }\n    return result;\n}\n\nint main() {\n    int n, m, p;\n    cin >> n >> m >> p;\n    vector<vector<int>> edges;\n    for (int i = 0; i < m; ++i) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        edges.push_back({u, v, w});\n    }\n    vector<int> children(p);\n    for (int i = 0; i < p; ++i) {\n        cin >> children[i];\n    }\n\n    vector<double> probabilities = calculateProbabilities(n, edges, children);\n    for (double prob : probabilities) {\n        printf(\"%.8f\\n\", prob);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 19:01:02"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h>\n#include <float.h>\n\n#define MAX_NODES 1000\n#define MAX_CHILDREN 100\n\ntypedef struct {\n    int dest;\n    int weight;\n} Edge;\n\ntypedef struct {\n    int node;\n    double prob;\n} PathInfo;\n\nint graph[MAX_NODES][MAX_NODES];\nint n, m, p;\nint children[MAX_CHILDREN];\ndouble child_probs[MAX_CHILDREN];\n\nvoid dijkstra(int start, int end, int* dist, int* prev) {\n    int visited[MAX_NODES] = {0};\n    for (int i = 0; i < n; i++) {\n        dist[i] = INT_MAX;\n        prev[i] = -1;\n    }\n    dist[start] = 0;\n\n    for (int count = 0; count < n - 1; count++) {\n        int u = -1, min_dist = INT_MAX;\n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && dist[v] < min_dist) {\n                min_dist = dist[v];\n                u = v;\n            }\n        }\n\n        if (u == -1) break;\n        visited[u] = 1;\n\n        for (int v = 0; v < n; v++) {\n            if (!visited[v] && graph[u][v] && \n                dist[u] + graph[u][v] < dist[v]) {\n                dist[v] = dist[u] + graph[u][v];\n                prev[v] = u;\n            }\n        }\n    }\n}\n\nvoid count_paths(int start, int end, int* dist, int* prev, double* probabilities) {\n    int paths[MAX_NODES] = {0};\n    paths[start] = 1;\n\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (graph[i][j] && dist[i] + graph[i][j] == dist[j]) {\n                paths[j] += paths[i];\n            }\n        }\n    }\n\n    for (int i = 0; i < p; i++) {\n        int child_node = children[i];\n        probabilities[i] = (double)paths[child_node] / paths[end];\n    }\n}\n\nint main() {\n    scanf(\"%d %d %d\", &n, &m, &p);\n\n    memset(graph, 0, sizeof(graph));\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        graph[u-1][v-1] = w;\n        graph[v-1][u-1] = w;\n    }\n\n    for (int i = 0; i < p; i++) {\n        scanf(\"%d\", &children[i]);\n        children[i]--;\n    }\n\n    int dist[MAX_NODES];\n    int prev[MAX_NODES];\n\n    dijkstra(0, n-1, dist, prev);\n    count_paths(0, n-1, dist, prev, child_probs);\n\n    for (int i = 0; i < p; i++) {\n        printf(\"%.6f\\n\", child_probs[i]);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 19:01:13"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <vector>\n#include <queue>\n#include <limits>\n#include <algorithm>\n\nclass ChristmasSantaDelivery {\nprivate:\n    int n, p;\n    std::vector<std::vector<std::pair<int, int>>> graph;\n    std::vector<int> shortestDist;\n    std::vector<double> childProbability;\n\n    void dijkstraShortestPath() {\n        shortestDist.assign(n, std::numeric_limits<int>::max());\n        std::vector<int> pathCount(n, 0);\n        shortestDist[0] = 0;\n        pathCount[0] = 1;\n\n        std::priority_queue<std::pair<int, int>, std::vector<std::pair<int, int>>, std::greater<>> pq;\n        pq.push({0, 0});\n\n        while (!pq.empty()) {\n            auto [dist, node] = pq.top();\n            pq.pop();\n\n            if (dist > shortestDist[node]) continue;\n\n            for (auto [neighbor, weight] : graph[node]) {\n                int newDist = dist + weight;\n                \n                if (newDist < shortestDist[neighbor]) {\n                    shortestDist[neighbor] = newDist;\n                    pathCount[neighbor] = pathCount[node];\n                    pq.push({newDist, neighbor});\n                } else if (newDist == shortestDist[neighbor]) {\n                    pathCount[neighbor] += pathCount[node];\n                }\n            }\n        }\n    }\n\n    void calculateChildProbabilities(const std::vector<int>& childNodes) {\n        childProbability.assign(p, 0.0);\n        \n        for (int child = 0; child < p; ++child) {\n            int childNode = childNodes[child];\n            \n            if (shortestDist[childNode] == std::numeric_limits<int>::max()) {\n                childProbability[child] = 0.0;\n                continue;\n            }\n\n            std::vector<std::vector<int>> paths;\n            findAllShortestPaths(0, childNode, paths);\n\n            for (const auto& path : paths) {\n                double pathProb = 1.0 / paths.size();\n                childProbability[child] += pathProb;\n            }\n        }\n    }\n\n    void findAllShortestPaths(int start, int end, std::vector<std::vector<int>>& paths) {\n        std::vector<std::vector<int>> tempPaths;\n        tempPaths.push_back({start});\n\n        while (!tempPaths.empty()) {\n            std::vector<std::vector<int>> newPaths;\n\n            for (auto& path : tempPaths) {\n                int currentNode = path.back();\n\n                if (currentNode == end) {\n                    paths.push_back(path);\n                    continue;\n                }\n\n                for (auto [neighbor, weight] : graph[currentNode]) {\n                    if (shortestDist[neighbor] == shortestDist[currentNode] + weight) {\n                        std::vector<int> newPath = path;\n                        newPath.push_back(neighbor);\n                        newPaths.push_back(newPath);\n                    }\n                }\n            }\n\n            tempPaths = newPaths;\n        }\n    }\n\npublic:\n    ChristmasSantaDelivery(int nodes, int children, const std::vector<std::vector<int>>& edges) {\n        n = nodes;\n        p = children;\n        graph.resize(n);\n        \n        for (const auto& edge : edges) {\n            int u = edge[0], v = edge[1], w = edge[2];\n            graph[u].push_back({v, w});\n            graph[v].push_back({u, w});\n        }\n    }\n\n    std::vector<double> getProbabilities(const std::vector<int>& childNodes) {\n        dijkstraShortestPath();\n        calculateChildProbabilities(childNodes);\n        return childProbability;\n    }\n};",
    "timestamp": "2025-08-05 19:01:28"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class SantaDelivery {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int m = scanner.nextInt();\n        int p = scanner.nextInt();\n        \n        List<List<int[]>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (int i = 0; i < m; i++) {\n            int u = scanner.nextInt();\n            int v = scanner.nextInt();\n            int w = scanner.nextInt();\n            graph.get(u).add(new int[]{v, w});\n            graph.get(v).add(new int[]{u, w});\n        }\n        \n        int[] children = new int[p];\n        for (int i = 0; i < p; i++) {\n            children[i] = scanner.nextInt();\n        }\n        \n        // Dijkstra's algorithm to find shortest distances and count paths\n        PriorityQueue<int[]> pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        int[] dist = new int[n];\n        Arrays.fill(dist, Integer.MAX_VALUE);\n        dist[0] = 0;\n        pq.offer(new int[]{0, 0});\n        \n        long[] count = new long[n];\n        count[0] = 1;\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int d = current[1];\n            \n            if (d > dist[u]) continue;\n            \n            for (int[] edge : graph.get(u)) {\n                int v = edge[0];\n                int w = edge[1];\n                if (dist[v] > dist[u] + w) {\n                    dist[v] = dist[u] + w;\n                    count[v] = count[u];\n                    pq.offer(new int[]{v, dist[v]});\n                } else if (dist[v] == dist[u] + w) {\n                    count[v] += count[u];\n                }\n            }\n        }\n        \n        // Reverse Dijkstra's to count paths from node n-1\n        long[] reverseCount = new long[n];\n        reverseCount[n-1] = 1;\n        pq = new PriorityQueue<>(Comparator.comparingInt(a -> a[1]));\n        int[] reverseDist = new int[n];\n        Arrays.fill(reverseDist, Integer.MAX_VALUE);\n        reverseDist[n-1] = 0;\n        pq.offer(new int[]{n-1, 0});\n        \n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int u = current[0];\n            int d = current[1];\n            \n            if (d > reverseDist[u]) continue;\n            \n            for (int[] edge : graph.get(u)) {\n                int v = edge[0];\n                int w = edge[1];\n                if (reverseDist[v] > reverseDist[u] + w) {\n                    reverseDist[v] = reverseDist[u] + w;\n                    reverseCount[v] = reverseCount[u];\n                    pq.offer(new int[]{v, reverseDist[v]});\n                } else if (reverseDist[v] == reverseDist[u] + w) {\n                    reverseCount[v] += reverseCount[u];\n                }\n            }\n        }\n        \n        long totalPaths = count[n-1];\n        double[] probabilities = new double[p];\n        \n        for (int i = 0; i < p; i++) {\n            int node = children[i];\n            if (dist[node] + reverseDist[node] != dist[n-1]) {\n                probabilities[i] = 0.0;\n            } else {\n                probabilities[i] = (double) (count[node] * reverseCount[node]) / totalPaths;\n            }\n        }\n        \n        for (double prob : probabilities) {\n            System.out.printf(\"%.8f\\n\", prob);\n        }\n    }\n}",
    "timestamp": "2025-08-05 19:02:03"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict\nimport heapq\n\ndef santa_probability(n, edges, children):\n    # Function to find all shortest paths from source to destination\n    def dijkstra():\n        dist = [float('inf')] * n\n        dist[0] = 0\n        ways = [0] * n\n        ways[0] = 1\n\n        heap = [(0, 0)]  # cost, node\n        while heap:\n            d, u = heapq.heappop(heap)\n            if d > dist[u]:\n                continue\n            for v, weight in graph[u]:\n                new_dist = dist[u] + weight\n                if new_dist < dist[v]:\n                    dist[v] = new_dist\n                    ways[v] = ways[u]\n                    heapq.heappush(heap, (new_dist, v))\n                elif new_dist == dist[v]:\n                    ways[v] += ways[u]\n\n        return dist, ways\n\n    # Build graph\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    # Get the shortest path distances and ways\n    dist, ways = dijkstra()\n    shortest_paths_through_node = [0] * n\n\n    # Use backtracking to count nodes that appear in all shortest paths\n    def dfs(node, path, min_cost):\n        if node == n - 1:\n            for p in path:\n                shortest_paths_through_node[p] += 1\n            return\n        if len(path) > n:\n            return\n        for neighbor, weight in graph[node]:\n            if dist[neighbor] == dist[node] + weight:\n                dfs(neighbor, path + [neighbor], min_cost)\n\n    dfs(0, [0], dist[n-1])\n\n    total_shortest_paths = ways[n-1]\n    probabilities = []\n    \n    for child in children:\n        if total_shortest_paths == 0:\n            probabilities.append(0.0)\n        else:\n            probabilities.append(shortest_paths_through_node[child] / total_shortest_paths)\n    \n    return probabilities\n\n# Example usage:\nn = 4\nedges = [(0, 1, 1), (1, 2, 1), (0, 2, 2), (2, 3, 1)]\nchildren = [1, 2]\nprint(santa_probability(n, edges, children))",
    "timestamp": "2025-08-13 01:52:18"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class SantaDelivery {\n    static class Edge {\n        int node, weight;\n        Edge(int node, int weight) {\n            this.node = node;\n            this.weight = weight;\n        }\n    }\n\n    public static void main(String[] args) {\n        // Example graph input:\n        int n = 5; // Number of nodes\n        int[][] edges = {\n            {0, 1, 1},\n            {0, 2, 3},\n            {1, 2, 1},\n            {1, 3, 4},\n            {2, 3, 1},\n            {3, 4, 2}\n        };\n        Set<Integer> childrenNodes = new HashSet<>(Arrays.asList(1, 2, 3));\n\n        List<List<Edge>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) graph.add(new ArrayList<>());\n\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(new Edge(edge[1], edge[2]));\n            graph.get(edge[1]).add(new Edge(edge[0], edge[2]));\n        }\n\n        double[] probabilities = calculateSantaProbabilities(n, graph, childrenNodes);\n\n        for (int i = 0; i < n; i++) {\n            if (childrenNodes.contains(i)) {\n                System.out.printf(\"Probability of child seeing Santa at node %d: %.2f%%\\n\", i, probabilities[i] * 100);\n            }\n        }\n    }\n\n    public static double[] calculateSantaProbabilities(int n, List<List<Edge>> graph, Set<Integer> childrenNodes) {\n        int[] distances = new int[n];\n        int[] pathCount = new int[n];\n        Arrays.fill(distances, Integer.MAX_VALUE);\n        distances[0] = 0;\n        pathCount[0] = 1;\n\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[1] - b[1]);\n        pq.offer(new int[] {0, 0});\n\n        while (!pq.isEmpty()) {\n            int[] current = pq.poll();\n            int node = current[0];\n            int dist = current[1];\n\n            if (dist > distances[node]) continue;\n\n            for (Edge edge : graph.get(node)) {\n                int nextNode = edge.node;\n                int newDist = dist + edge.weight;\n                if (newDist < distances[nextNode]) {\n                    distances[nextNode] = newDist;\n                    pathCount[nextNode] = pathCount[node];\n                    pq.offer(new int[] {nextNode, newDist});\n                } else if (newDist == distances[nextNode]) {\n                    pathCount[nextNode] += pathCount[node];\n                }\n            }\n        }\n\n        double[] probabilities = new double[n];\n        int totalShortestPaths = pathCount[n - 1];\n\n        for (int i = 0; i < n; i++) {\n            probabilities[i] = (double) pathCount[i] / totalShortestPaths;\n        }\n\n        return probabilities;\n    }\n}",
    "timestamp": "2025-08-13 01:52:30"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\n#define MAX_NODES 1000\n#define MAX_EDGES 10000\n\ntypedef struct {\n    int u, v, weight;\n} Edge;\n\ntypedef struct {\n    int node;\n    int weight;\n} NodeWeight;\n\ntypedef struct {\n    NodeWeight heap[MAX_NODES];\n    int size;\n    int position[MAX_NODES];\n} MinHeap;\n\ntypedef struct {\n    int vertex;\n    int edges[MAX_EDGES];\n    int edge_count;\n} GraphNode;\n\ntypedef struct {\n    GraphNode nodes[MAX_NODES];\n    int node_count;\n} Graph;\n\nvoid swap(MinHeap* heap, int i, int j) {\n    NodeWeight temp = heap->heap[i];\n    heap->heap[i] = heap->heap[j];\n    heap->heap[j] = temp;\n\n    int tempPos = heap->position[heap->heap[i].node];\n    heap->position[heap->heap[i].node] = heap->position[heap->heap[j].node];\n    heap->position[heap->heap[j].node] = tempPos;\n}\n\nvoid heapify(MinHeap* heap, int idx) {\n    int smallest = idx;\n    int left = 2 * idx + 1;\n    int right = 2 * idx + 2;\n\n    if (left < heap->size && heap->heap[left].weight < heap->heap[smallest].weight)\n        smallest = left;\n    if (right < heap->size && heap->heap[right].weight < heap->heap[smallest].weight)\n        smallest = right;\n\n    if (smallest != idx) {\n        swap(heap, smallest, idx);\n        heapify(heap, smallest);\n    }\n}\n\nNodeWeight extractMin(MinHeap* heap) {\n    NodeWeight root = heap->heap[0];\n    heap->heap[0] = heap->heap[heap->size - 1];\n    heap->position[heap->heap[0].node] = 0;\n    heap->size--;\n    heapify(heap, 0);\n    return root;\n}\n\nvoid decreaseKey(MinHeap* heap, int node, int weight) {\n    int i = heap->position[node];\n    heap->heap[i].weight = weight;\n\n    while (i && heap->heap[i].weight < heap->heap[(i - 1) / 2].weight) {\n        swap(heap, i, (i - 1) / 2);\n        i = (i - 1) / 2;\n    }\n}\n\nvoid insertMinHeap(MinHeap* heap, int node, int weight) {\n    heap->size++;\n    int i = heap->size - 1;\n    heap->heap[i].node = node;\n    heap->heap[i].weight = weight;\n    heap->position[node] = i;\n\n    while (i && heap->heap[i].weight < heap->heap[(i - 1) / 2].weight) {\n        swap(heap, i, (i - 1) / 2);\n        i = (i - 1) / 2;\n    }\n}\n\nMinHeap createMinHeap(int node_count) {\n    MinHeap heap;\n    heap.size = 0;\n    for (int v = 0; v < node_count; ++v) {\n        heap.position[v] = -1;\n    }\n    return heap;\n}\n\nGraph createGraph(int node_count) {\n    Graph graph;\n    graph.node_count = node_count;\n    for (int i = 0; i < node_count; ++i) {\n        graph.nodes[i].vertex = i;\n        graph.nodes[i].edge_count = 0;\n    }\n    return graph;\n}\n\nvoid addEdge(Graph* graph, int u, int v, int weight) {\n    Edge edge = {u, v, weight};\n    graph->nodes[u].edges[graph->nodes[u].edge_count++] = edge;\n    graph->nodes[v].edges[graph->nodes[v].edge_count++] = edge;\n}\n\nvoid dijkstra(Graph* graph, int src, int* dist, int* count_paths) {\n    MinHeap heap = createMinHeap(graph->node_count);\n\n    for (int v = 0; v < graph->node_count; v++)\n        dist[v] = INT_MAX;\n\n    insertMinHeap(&heap, src, 0);\n    dist[src] = 0;\n    count_paths[src] = 1;\n\n    while (heap.size > 0) {\n        NodeWeight nw = extractMin(&heap);\n        int u = nw.node;\n\n        for (int i = 0; i < graph->nodes[u].edge_count; i++) {\n            Edge edge = graph->nodes[u].edges[i];\n            int v = edge.u == u ? edge.v : edge.u;\n\n            int alt = dist[u] + edge.weight;\n            if (alt < dist[v]) {\n                dist[v] = alt;\n                count_paths[v] = count_paths[u];\n                insertMinHeap(&heap, v, dist[v]);\n            } else if (alt == dist[v]) {\n                count_paths[v] += count_paths[u];\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, p;\n    scanf(\"%d %d %d\", &n, &m, &p);\n\n    Graph graph = createGraph(n);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        scanf(\"%d %d %d\", &u, &v, &w);\n        addEdge(&graph, u, v, w);\n    }\n\n    int children[p];\n    for (int i = 0; i < p; i++) {\n        scanf(\"%d\", &children[i]);\n    }\n\n    int dist[MAX_NODES], count_paths[MAX_NODES];\n    dijkstra(&graph, 0, dist, count_paths);\n\n    int total_paths = count_paths[n-1];\n\n    for (int i = 0; i < p; i++) {\n        int child_node = children[i];\n        double probability = (double)count_paths[child_node] / total_paths;\n        printf(\"Child %d probability: %.6lf\\n\", child_node, probability);\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 01:52:54"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "from collections import defaultdict, deque\nimport heapq\n\ndef santa_path_probabilities(n, edges, children_nodes):\n    # Create adjacency list representation of graph\n    graph = defaultdict(list)\n    for u, v, w in edges:\n        graph[u].append((v, w))\n        graph[v].append((u, w))\n    \n    # Dijkstra's algorithm to find shortest paths\n    def dijkstra(start):\n        distances = [float('inf')] * n\n        paths = [[] for _ in range(n)]\n        distances[start] = 0\n        paths[start] = [[start]]\n        \n        pq = [(0, start)]\n        while pq:\n            curr_dist, curr_node = heapq.heappop(pq)\n            \n            if curr_dist > distances[curr_node]:\n                continue\n            \n            for neighbor, weight in graph[curr_node]:\n                dist = curr_dist + weight\n                \n                if dist < distances[neighbor]:\n                    distances[neighbor] = dist\n                    paths[neighbor] = [path + [neighbor] for path in paths[curr_node]]\n                    heapq.heappush(pq, (dist, neighbor))\n                elif dist == distances[neighbor]:\n                    paths[neighbor].extend([path + [neighbor] for path in paths[curr_node]])\n        \n        return distances, paths\n    \n    # Find shortest distance and all paths from node 0 to node n-1\n    shortest_distances, all_paths = dijkstra(0)\n    target_distance = shortest_distances[n-1]\n    \n    # Track child visibility probabilities\n    child_probabilities = [0] * len(children_nodes)\n    \n    # Count total shortest paths\n    total_paths = len(all_paths[n-1])\n    \n    # Compute child visibility probabilities\n    for i, child in enumerate(children_nodes):\n        child_paths = 0\n        for path in all_paths[n-1]:\n            if child in path:\n                child_paths += 1\n        child_probabilities[i] = child_paths / total_paths\n    \n    return child_probabilities",
    "timestamp": "2025-08-13 01:53:08"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import heapq\nfrom collections import defaultdict\n\ndef solve():\n    import sys\n    input = sys.stdin.read\n    data = input().split()\n    idx = 0\n    \n    n = int(data[idx])\n    idx += 1\n    m = int(data[idx])\n    idx += 1\n    p = int(data[idx])\n    idx += 1\n    \n    adj = [[] for _ in range(n)]\n    for _ in range(m):\n        u = int(data[idx])\n        idx += 1\n        v = int(data[idx])\n        idx += 1\n        w = int(data[idx])\n        idx += 1\n        adj[u].append((v, w))\n        adj[v].append((u, w))\n    \n    children = []\n    for _ in range(p):\n        c = int(data[idx])\n        idx += 1\n        children.append(c)\n    \n    # Dijkstra's algorithm to find shortest distances from node 0\n    dist = [float('inf')] * n\n    dist[0] = 0\n    heap = [(0, 0)]\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if current_dist > dist[u]:\n            continue\n        for v, w in adj[u]:\n            if dist[v] > dist[u] + w:\n                dist[v] = dist[u] + w\n                heapq.heappush(heap, (dist[v], v))\n    \n    # Dijkstra's algorithm to find shortest distances from node n-1\n    dist_rev = [float('inf')] * n\n    dist_rev[n-1] = 0\n    heap = [(0, n-1)]\n    \n    while heap:\n        current_dist, u = heapq.heappop(heap)\n        if current_dist > dist_rev[u]:\n            continue\n        for v, w in adj[u]:\n            if dist_rev[v] > dist_rev[u] + w:\n                dist_rev[v] = dist_rev[u] + w\n                heapq.heappush(heap, (dist_rev[v], v))\n    \n    total_length = dist[n-1]\n    \n    # Count number of shortest paths from 0 to u and from u to n-1\n    # Forward pass: count paths from 0 to u\n    count = [0] * n\n    count[0] = 1\n    nodes = sorted([(dist[u], u) for u in range(n)], key=lambda x: x[0])\n    \n    for d, u in nodes:\n        for v, w in adj[u]:\n            if dist[v] == dist[u] + w:\n                count[v] += count[u]\n    \n    # Backward pass: count paths from u to n-1\n    count_rev = [0] * n\n    count_rev[n-1] = 1\n    nodes_rev = sorted([(dist_rev[u], u) for u in range(n)], key=lambda x: x[0])\n    \n    for d, u in nodes_rev:\n        for v, w in adj[u]:\n            if dist_rev[v] == dist_rev[u] + w:\n                count_rev[v] += count_rev[u]\n    \n    total_paths = count[n-1]\n    \n    # Calculate probability for each child\n    res = []\n    for c in children:\n        if dist[c] + dist_rev[c] == total_length:\n            prob = (count[c] * count_rev[c]) / total_paths\n        else:\n            prob = 0.0\n        res.append(prob)\n    \n    for prob in res:\n        print(\"{0:.8f}\".format(prob))\n\nsolve()",
    "timestamp": "2025-08-13 01:53:35"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <climits>\n\nusing namespace std;\n\n// Helper function to perform Dijkstra's algorithm to calculate shortest path distances\nvector<int> dijkstra(int n, vector<vector<pair<int, int>>>& adj) {\n    vector<int> dist(n, INT_MAX);\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n\n    dist[0] = 0;\n    pq.push({0, 0});\n\n    while (!pq.empty()) {\n        int d = pq.top().first;\n        int u = pq.top().second;\n        pq.pop();\n\n        if (d != dist[u]) continue;\n\n        for (auto& edge : adj[u]) {\n            int v = edge.first, weight = edge.second;\n            if (dist[u] + weight < dist[v]) {\n                dist[v] = dist[u] + weight;\n                pq.push({dist[v], v});\n            }\n        }\n    }\n\n    return dist;\n}\n\n// Helper function to count paths considering nodes involved in possible shortest paths\nvoid count_paths(int u, vector<vector<pair<int, int>>>& adj, vector<long long>& count, vector<int>& dist) {\n    priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;\n    pq.push({0, u});\n    count[u] = 1;\n\n    while (!pq.empty()) {\n        int d = pq.top().first;\n        int v = pq.top().second;\n        pq.pop();\n\n        if (d != dist[v]) continue;\n\n        for (auto& edge : adj[v]) {\n            int next = edge.first;\n            int weight = edge.second;\n            if (dist[next] == dist[v] + weight) {\n                count[next] += count[v];\n            }\n        }\n    }\n}\n\nint main() {\n    int n, m, p;\n    cin >> n >> m >> p;\n\n    vector<vector<pair<int, int>>> adj(n);\n\n    for (int i = 0; i < m; i++) {\n        int u, v, w;\n        cin >> u >> v >> w;\n        adj[u].emplace_back(v, w);\n        adj[v].emplace_back(u, w);\n    }\n\n    vector<int> children(p);\n    for (int i = 0; i < p; i++) {\n        cin >> children[i];\n    }\n\n    vector<int> dist_from_start = dijkstra(n, adj);\n    vector<vector<pair<int, int>>> rev_adj(n);\n    for (int u = 0; u < n; ++u) {\n        for (auto& edge : adj[u]) {\n            int v = edge.first, w = edge.second;\n            rev_adj[v].emplace_back(u, w);\n        }\n    }\n    \n    vector<int> dist_from_end = dijkstra(n, rev_adj);\n    vector<long long> count_from_start(n, 0), count_from_end(n, 0);\n\n    count_paths(0, adj, count_from_start, dist_from_start);\n    count_paths(n - 1, rev_adj, count_from_end, dist_from_end);\n\n    double total_paths = count_from_start[n - 1];\n\n    for (int child : children) {\n        double on_shortest_path = count_from_start[child] * count_from_end[child];\n        cout << on_shortest_path / total_paths << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-13 11:03:06"
  }
]