[
  {
    "language": "Scala",
    "code": "import scala.collection.mutable\n\nobject Main extends App {\n  import scala.io.StdIn._\n  solve\n  def solve: Unit = {\n    val Array(n, m, p) = readLine.trim.split(' ').map(_.toInt)\n    if (n == 0) return\n    val edges = Array.tabulate(n){_ ⇒ Nil: List[(Int, Int)]}\n    for (_ ← 0 until m){\n      val Array(u, v, w) = readLine.trim.split(' ').map(_.toInt)\n      edges(u) ::= (v, w)\n      edges(v) ::= (u, w)\n    }\n    val children = Array.tabulate(p){_ ⇒ readInt}\n    solve(edges, children)\n    println()\n    solve\n  }\n  def solve(array: Array[List[(Int, Int)]], children: Array[Int]): Unit = {\n    val minCost = Array.tabulate(array.length){_ ⇒ Int.MaxValue}.also(a ⇒ a(0) = 0)\n    val queue = mutable.PriorityQueue()(Ordering.by[(Int, Int), Int](_._2).reverse).also(q ⇒ q.enqueue((0, 0)))\n    val prevEdges = Array.tabulate(array.length){_ ⇒ Nil: List[Int]}\n    while (queue.nonEmpty) {\n      val (current, cost) = queue.dequeue()\n      if (minCost(current) == cost){\n        for ((next, c) ← array(current)){\n          if (minCost(next) > cost + c) {\n            minCost(next) = cost + c\n            prevEdges(next) = List(current)\n            queue.enqueue((next, minCost(next)))\n          }else if (minCost(next) == cost + c){\n            prevEdges(next) ::= current\n          }\n        }\n      }\n    }\n    val prevPath = Array.tabulate(array.length){_ ⇒ 0D}.also(a ⇒ a(0) = 1)\n    val nextPath = Array.tabulate(array.length){_ ⇒ 0D}.also(a ⇒ a(a.length - 1) = 1)\n    val nextEdges = Array.tabulate(array.length){_ ⇒ Nil: List[Int]}\n    for (next ← prevEdges.indices){\n      for (prev ← prevEdges(next)){\n        nextEdges(prev) ::= next\n      }\n    }\n    def calPrevPath(current: Int): Unit = {\n      for (prev ← prevEdges(current)) {\n        calPrevPath(prev)\n        prevPath(current) += prevPath(prev)\n      }\n      prevEdges(current) = Nil\n    }\n    def calNextPath(current: Int): Unit = {\n      for (next ← nextEdges(current)){\n        calNextPath(next)\n        nextPath(current) += nextPath(next)\n      }\n      nextEdges(current) = Nil\n    }\n    calPrevPath(array.length - 1)\n    calNextPath(0)\n    val wholePath = prevPath.last\n    println(children.map(i ⇒ prevPath(i) * nextPath(i).toDouble / wholePath).mkString(\"\\n\"))\n  }\n  implicit class Scope[T](val value: T) extends AnyVal {\n    @inline def also(@inline func: T ⇒ Unit): T = {\n      func(value)\n      value\n    }\n    @inline def let[A](@inline func: T ⇒ A): A = func(value)\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M, C;\n\ntypedef long long ll;\n\nstruct Edge {\n  int to; ll cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nvector<int> cs;\n\nvector<vector<int> > prev_;\ndouble ans[110];\n\nvoid dfs(int idx, double prob) {\n  ans[idx] += prob;\n  rep(i, prev_[idx].size()) {\n    dfs(prev_[idx][i], prob/prev_[idx].size());\n  }\n}\n\nstruct state {\n  int curr; ll cost;\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> N >> M >> C && (N|M|C)) {\n    g.clear(); g.resize(N);\n    cs.clear(); cs.resize(C);\n    rep(i, M) {\n      int a, b; ll c; cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c});\n      g[b].push_back((Edge){a, c});\n    }\n    rep(i, C) cin >> cs[i];\n    \n    ll dist[N];\n    fill(dist, dist+N, INF);\n    dist[0] = 0;\n    \n    prev_.clear(); prev_.resize(N);\n    \n    priority_queue<state> pq;\n    pq.push((state){0, dist[0]});\n    while(!pq.empty()) {\n      int curr = pq.top().curr;\n      ll cost = pq.top().cost;\n      pq.pop();\n      \n      rep(i, g[curr].size()) {\n        Edge& e = g[curr][i];\n        if(dist[e.to] == cost+e.cost) {\n          prev_[e.to].push_back(curr);\n        }\n        if(dist[e.to] <= cost+e.cost) { continue; }\n        prev_[e.to].clear();\n        prev_[e.to].push_back(curr);\n        dist[e.to] = cost+e.cost;\n        pq.push((state){e.to, dist[e.to]});\n      }\n    }\n    \n    rep(i, N) ans[i] = 0.;\n    dfs(N-1, 1.);\n    rep(i, C) {\n      printf(\"%.10f\\n\", ans[cs[i]]);\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n\nstruct edge {\n\tint to, cost;\n\tedge(int to_, int cost_):to(to_), cost(cost_) {}\n};\n\ntypedef pair<int, int> P;\n\nvector<int> dijkstra(int s, const vector<vector<edge>> &G) {\n\tconst int n = G.size();\n\n\tvector<int> dist(n, INT_MAX);\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tdist[s] = 0;\n\tque.push({0, s});\n\n\twhile(!que.empty()) {\n\t\tconst int d = que.top().first;\n\t\tconst int v = que.top().second;\n\t\tque.pop();\n\n\t\tif(dist[v] < d) continue;\n\n\t\tfor(const auto &e : G[v]) {\n\t\t\tconst int next_dist = d + e.cost;\n\t\t\tif(dist[e.to] > next_dist) {\n\t\t\t\tdist[e.to] = next_dist;\n\t\t\t\tque.push({next_dist, e.to});\n\t\t\t}\n\t\t}\n\t}\n\n\treturn dist;\n}\n\nint main() {\n\tcin.tie(nullptr);\n\tios::sync_with_stdio(false);\n\tcout.precision(8);\n\tcout.setf(ios::fixed);\n\n\tfor(int n, m, p; cin >> n >> m >> p && n;) {\n\t\tvector<vector<edge>> G(n);\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tint a, b, cost;\n\t\t\tcin >> a >> b >> cost;\n\t\t\tG[a].emplace_back(b, cost);\n\t\t\tG[b].emplace_back(a, cost);\n\t\t}\n\n\t\tconst auto dist = dijkstra(n - 1, G);\n\t\tvector<double> probability(n, 0.0);\n\t\tpriority_queue<P, vector<P>, greater<P>> que;\n\t\tprobability[0] = 1.0;\n\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tque.push({dist[i], i});\n\t\t}\n\n\t\twhile(!que.empty()) {\n\t\t\tconst int d = que.top().first;\n\t\t\tconst int v = que.top().second;\n\t\t\tque.pop();\n\n\t\t\tvector<int> next_nodes;\n\n\t\t\tfor(const auto &e : G[v]) {\n\t\t\t\tif(d - e.cost == dist[e.to]) {\n\t\t\t\t\tnext_nodes.emplace_back(e.to);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(const auto &u : next_nodes) {\n\t\t\t\tprobability[u] += probability[v] / next_nodes.size();\n\t\t\t}\n\t\t}\n\n\t\twhile(p--) {\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tcout << probability[v] << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\treturn EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "//RE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct route{\n\tint w;\n\tbitset<100> b;\n\n\troute(int w_, int p_, const bitset<100> &b_):\n\t\tw(w_), b(b_)\n\t{\n\t\tb.set(p_);\n\t}\n\t\n\tbool operator() (const route &r1, const route &r2){\n\t\treturn r1.w > r2.w;\n\t}\n} first( 0, 0, bitset<100>() );\n\nint main(){\n\tint n, m, p, a, b, w;\n\tvector<route>::iterator it1;\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<route> > rts(n);\n\t\trts[0].push_back( first );\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\n\t\t\tif( p.first != rts[p.second].front().w ){\tcontinue;\t}\n\n\t\t\trts[p.second].front().w = -1;\n\t\t\tvector<route> &rt = rts[p.second];\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( it1 = rt.begin(); it1 != rt.end(); ++it1 ){\n\t\t\t\tvector<pii>::iterator it2;\n\t\t\t\tfor( it2 = wt.begin(); it2 != wt.end(); ++it2 ){\n\t\t\t\t\tw = p.first + it2->second;\n\t\t\t\t\tif(\n\t\t\t\t\t\trts[it2->first].empty() ||\n\t\t\t\t\t\trts[it2->first].front().w > w\n\t\t\t\t\t){\n\t\t\t\t\t\trts[it2->first].clear();\n\t\t\t\t\t\trts[it2->first].push_back(\n\t\t\t\t\t\t\troute( w, it2->first, it1->b )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tqu.push( pii( w, it2->first ) );\n\n\t\t\t\t\t}\n\t\t\t\t\telse if( rts[it2->first].front().w == w ){\n\t\t\t\t\t\trts[it2->first].push_back(\n\t\t\t\t\t\t\troute( w, it2->first, it1->b )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tvector<double> ans(n);\n\t\tdouble x = 1.0 / rts[n-1].size();\n\t\tfor( it1 = rts[n-1].begin(); it1 != rts[n-1].end(); ++it1 ){\n\t\t\tfor( int i = 0; i < n; i++ ){\n\t\t\t\tif( it1->b[i] ){\n\t\t\t\t\tans[i] += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%f\\n\", ans[a] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#define MAXN 105\n#define MAXM 20005\n\nint n,m,p;\nint totaledge,v[MAXM],w[MAXM],next[MAXM],point[MAXN];\nint dist[MAXN],ddist[MAXN];\nint vis[MAXN];\nint ind[MAXN];\ndouble pp[MAXN];\n\nvoid addedge(int x,int y,int z){\n    int i;\n    i = ++totaledge;\n    v[i] = y;\n    w[i] = z;\n    next[i] = point[x];\n    point[x] = i;\n}\n\nvoid dijk(){\n    int i,j,now,md;\n    memset(dist,1,sizeof(dist));\n    memset(vis,0,sizeof(vis));\n    dist[n-1] = 0;\n    now = n - 1;\n    for(i=1;i<n;i++){\n        for (j=point[now];j;j=next[j])\n            if (dist[now]+w[j]<dist[v[j]]) dist[v[j]] = dist[now] + w[j];\n        vis[now] = 1;\n        md = dist[n];\n        for (j=0;j<n;j++)\n            if (vis[j]==0 && dist[j]<md){\n                md = dist[j];\n                now = j;\n            }\n    }\n    memset(ddist,1,sizeof(ddist));\n    memset(vis,0,sizeof(vis));\n    ddist[0] = 0;\n    now = 0;\n    for(i=1;i<n;i++){\n        for (j=point[now];j;j=next[j])\n            if (ddist[now]+w[j]<ddist[v[j]]) ddist[v[j]] = ddist[now] + w[j];\n        vis[now] = 1;\n        md = ddist[n];\n        for (j=0;j<n;j++)\n            if (vis[j]==0 && ddist[j]<md){\n                md = ddist[j];\n                now = j;\n            }\n    }\n}\n\nvoid psh(){\n    int i,j,cc,now,flag;\n    double tmp;\n    memset(pp,0,sizeof(pp));\n    memset(vis,0,sizeof(vis));\n    memset(ind,0,sizeof(ind));\n    for (i=0;i<n;i++)\n        for (j=point[i];j;j=next[j])\n            if (dist[i]+ddist[i]==dist[0])\n                if (dist[i]+w[j]==dist[v[j]]){\n                    ind[i]++;\n                }\n    pp[0] = 1;\n    now = 0;\n    flag = 1;\n    while (flag){\n        flag = 0;\n        cc = 0;\n        for (i=point[now];i;i=next[i])\n            if (dist[v[i]]+ddist[v[i]]==dist[0])\n                if (dist[now]==dist[v[i]]+w[i]){\n                    cc++;\n                }\n        if (cc>0){\n            tmp = pp[now] / cc;\n            for (i=point[now];i;i=next[i])\n                if (dist[v[i]]+ddist[v[i]]==dist[0])\n                    if (dist[now]==dist[v[i]]+w[i]){\n                        pp[v[i]] += tmp;\n                        ind[v[i]]--;\n                    }\n            vis[now] = 1;\n            for (i=0;i<n;i++)\n                if (dist[i]+ddist[i]==dist[0])\n                    if (ind[i]==0 && vis[i]==0){\n                        now = i;\n                        flag = 1;\n                        break;\n                    }\n        }\n    }\n}\n\nint main(){\n  //  freopen(\"h.in\",\"r\",stdin);\n    int i,x,y,z;\n    while (scanf(\"%d%d%d\",&n,&m,&p)!=EOF && (n>0)){\n        memset(point,0,sizeof(point));\n        totaledge = 0;\n        for (i=1;i<=m;i++){\n            scanf(\"%d%d%d\",&x,&y,&z);\n            addedge(x,y,z);\n            addedge(y,x,z);\n        }\n        dijk();\n        psh();\n        while (p--){\n            scanf(\"%d\",&i);\n            printf(\"%.8f\\n\",pp[i]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist, vector<vector<bool> >& from)\n{\n    int n = edges.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    from.assign(n, vector<bool>(n, false));\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n                from[e.to].assign(n, false);\n            }\n            if(dist[v] + e.cost <= dist[e.to]){\n                from[e.to][v] = true;\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid solve(vector<vector<Edge> >& edges, vector<double>& p)\n{\n    int n = edges.size();\n    vector<int> dist;\n    vector<vector<bool> > from;\n    shortestPath(edges, 0, dist, from);\n\n    multimap<int, int> m;\n    m.insert(make_pair(0, 0));\n    p.resize(n, 0.0);\n    p[0] = 1.0;\n    vector<bool> check(n, false);\n    while(!m.empty()){\n        int cost = m.begin()->first;\n        int pos = m.begin()->second;\n        double prob = p[pos];\n        m.erase(m.begin());\n        if(check[pos])\n            continue;\n        check[pos] = true;\n\n        int num = 0;\n        for(unsigned i=0; i<edges[pos].size(); ++i){\n            int to = edges[pos][i].to;\n            if(from[to][pos]){\n                ++ num;\n                m.insert(make_pair(dist[to], to));\n            }\n        }\n        for(unsigned i=0; i<edges[pos].size(); ++i){\n            int to = edges[pos][i].to;\n            if(from[to][pos]){\n                p[to] += prob / num;\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            edges[a].push_back(Edge(b, c));\n        }\n\n        vector<double> prob;\n        solve(edges, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            dfs(e.to,d);\n            dp[e.to] *= dp[v]*(1./cnt); \n        }\n    }\n}\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,0,sizeof(visited));\n        fill(dp,dp+MAX,1);\n        dfs(n-1,d);\n        for(int i = 0 ; i < n ; i++){\n            if(!visited[i]){\n                dp[i] = 0;\n            }\n        }\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.12f\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid printMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\ndouble check[110];\nArray dist;\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n  MEMSET(check, 0);\n  const int n = g.size();\n  vector<bool> visit(n, false);\n  dist = Array(n, 1000000000LL);\n  priority_queue<Edge> que;\n  que.push(Edge(s, s, 0));\n  Weight ans = -1;\n  while (!que.empty()) {\n    Edge edge = que.top();\n    que.pop();\n    int from = edge.dest;\n    if (edge.weight == dist[from]) {\n      check[from] += check[edge.src];\n    }\n    check[s] = 1;\n    if (visit[from]) { continue; }\n    visit[from] = true;\n    dist[from] = edge.weight;\n    for (int i = 0; i < (int)g[from].size(); i++) {\n      int to = g[from][i].dest;\n      Weight ncost = edge.weight + g[from][i].weight;\n      if (ncost > dist[to]) { continue; }\n      dist[to] = ncost;\n      que.push(Edge(from, to, ncost));\n    }\n  }\n  return ans;\n}\n\ndouble cnt[2][110];\n\nint n, m, p;\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &p), n|m|p) {\n    Graph g(n);\n    REP(i, m) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      g[f].push_back(Edge(f, t, c));\n      g[t].push_back(Edge(t, f, c));\n    }\n    priority_queue<Edge> que;\n    Dijkstra(g, 0, n - 1);\n    memcpy(cnt[0], check, sizeof(check));\n    Array d1 = dist;\n    Dijkstra(g, n - 1, 0);\n    memcpy(cnt[1], check, sizeof(check));\n    Array d2 = dist;\n    REP(i, p) {\n      int index;\n      scanf(\"%d\", &index);\n      double q = cnt[0][index] * cnt[1][index] / cnt[0][n - 1];\n      if (d1[index] + d2[index] != d1[n - 1]) {\n        q = 0.0;\n      }\n      printf(\"%.8lf\\n\", q);\n      assert(0.0 <= q && q <= 1.0);\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 30;\n\nint N, M, P;\nint v1[100], v2[100];\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, int *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(8);\n\n  while(cin >> N >> M >> P, N) {\n    g.resize(N);\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n\n    g.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\n#define EPS 1e-10\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\nlong double dp[MAX];\nlong double cnt[MAX];\nvector<Edge> G[MAX];\nbool visited[MAX];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n        dp[i] = cnt[i] = 0;\n        visited[i] = 0;\n    }\n}\n\nvector<int> dijkstra(int n){\n    vector<int> d(n, INF); d[0] = 0;\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,0));\n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost < d[e.to]){\n                d[e.to] = d[v] + e.cost;\n                Q.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n    return d;\n}\n\nvoid dijkstra2(int s,int n,vector<int> &d2){\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,s));\n    vector<int> d(n,INF); d[s] = 0;\n    if(s == n-1) cnt[s] = 1;\n    else dp[s] = 1;\n    \n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost <= d[e.to]){\n                if(s == n-1){\n                    if(d2[v]-d2[e.to] == e.cost){\n                        cnt[e.to] += cnt[v];\n                    }\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }else{\n                    dp[e.to] += dp[v]/cnt[v]*cnt[e.to] + EPS;\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        vector<int> d = dijkstra(n);\n\n        dijkstra2(n-1,n,d);\n        dijkstra2(0,n,d);\n        \n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.12Lf\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint g[110][110];\nvector<int>g2[110];\nint p[11000];\nint q[11000];\nint r[11000];\npair<int,int> pt[110];\nlong long dp[110];\nlong long dp2[110];\nint main(){\n    int a,b,c;\n    while(scanf(\"%d%d%d\",&a,&b,&c),a){\n        for(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=999999999;\n        for(int i=0;i<a;i++)g[i][i]=0;\n        for(int i=0;i<a;i++){g2[i].clear();}\n        for(int i=0;i<b;i++){\n            scanf(\"%d%d%d\",p+i,q+i,r+i);\n            g[p[i]][q[i]]=g[q[i]][p[i]]=r[i];\n        }\n        for(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        for(int i=0;i<b;i++){\n            int P=p[i];\n            int Q=q[i];\n            int R=r[i];\n            if(g[0][P]+R==g[0][Q]&&g[Q][a-1]+R==g[P][a-1]){\n                g2[P].push_back(Q);\n            }\n            swap(P,Q);\n            if(g[0][P]+R==g[0][Q]&&g[Q][a-1]+R==g[P][a-1]){\n                g2[P].push_back(Q);\n            }\n        }\n        for(int i=0;i<110;i++)dp[i]=0;\n        dp[0]=1;\n        for(int i=0;i<a;i++)pt[i]=make_pair(g[0][i],i);\n        std::sort(pt,pt+a);\n        for(int i=0;i<a;i++){\n            int at=pt[i].second;\n            for(int j=0;j<g2[at].size();j++){\n                dp[g2[at][j]]+=dp[at];\n            }\n        }\n\t\tlong long tot=dp[a-1];\n\t\t\n        for(int i=0;i<c;i++){\n            int t;scanf(\"%d\",&t);\n\t\t\tfor(int j=0;j<a;j++)dp2[j]=0;\n\t\t\tdp2[t]=1;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint at=pt[j].second;\n\t\t\t\tfor(int k=0;k<g2[at].size();k++){\n\t\t\t\t\tdp2[g2[at][k]]+=dp2[at];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%.12f\\n\",(double)dp2[a-1]*dp[t]/tot);\n        }\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 100000000 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint g[100][100];\nint c[100];\nint memo[100];\nll r[100];\n\nint main(){\n  while(true){\n    int n = getInt();\n    int m = getInt();\n    int p = getInt();\n\n    if(n+m+p == 0) break;\n\n    REP(i,n) REP(j,n) g[i][j] = 0;\n    REP(i,n){\n      memo[i] = -1;\n      r[i] = 0;\n    }\n\n    REP(i,m){\n      int a = getInt();\n      int b = getInt();\n      int c = getInt();\n\n      g[a][b] = g[b][a] = c;\n    }\n\n    REP(i,p) c[i] = getInt();\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    pq.push(mp(0,0));\n    int cnt = 0;\n\n    while(cnt != n){\n      data d = pq.top();\n      int cost = d.f;\n      int pos  = d.s;\n\n      pq.pop();\n\n      if(memo[pos] != -1)\n        continue;\n\n      memo[pos] = cost;\n      cnt++;\n\n      REP(i,n)\n        if(g[pos][i] && memo[i] == -1)\n          pq.push(mp(cost + g[pos][i], i));\n    }\n\n    vector<pair<int,int> > v(n);\n    REP(i,n){\n      v[i].f = memo[i];\n      v[i].s = i;\n    }\n    sort(v.begin(), v.end());\n    r[0] = 1;\n\n    REP(i,n){\n      int pos = v[i].s;\n\n      REP(j,n){\n        if(g[pos][j] != 0 && memo[j] == memo[pos] + g[pos][j])\n          r[j] += r[pos];\n      }\n    }\n\n    //REP(i,n) printf(\"%d: %d,%d\\n\",i,memo[i],r[i]);\n\n#define MAX 10000000\n    REP(i,n) REP(j,n){\n      if(i == j) continue;\n      if(g[i][j] == 0) g[i][j] = MAX;\n    }\n\n    REP(k,n) REP(i,n) REP(j,n){\n      g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n    }\n\n    ll all = r[n-1];\n    REP(i,p)\n      if(g[0][c[i]] + g[c[i]][n-1] == memo[n-1])\n        printf(\"%.8f\\n\",(double)r[c[i]] / all);\n      else\n        printf(\"%.8f\\n\",0.0);\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\nif(qu.empty())return 1;\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\t\t\t\tif( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t\t\n\t\t\t\t\tif(!cnt[it->second])while(1);\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t\t\n\t\t\t\t\tif(!cnt[it->second])while(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == p.first) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (!visited2[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];\n\n                    visited2[e.to] = 1;\n                    Q2.push(pii(d[0][e.to], e.to));\n                }\n            }\n        }\n        \n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n        \n        double dp[MAX] = {};\n        dp[0] = 1;\n               \n        for (int i = 0; i < N; i++) {\n            if (dp[i] == 0) continue;\n            int mn = INF, cnt = 0;\n            for (int j = 0; j < N; j++) {\n                if (i == j || d[i][j] == INF) continue;\n                if (d[j][N-1] < mn) {\n                    mn = d[j][N-1];\n                    cnt = 1;\n                } else if (d[j][N-1] == mn) {\n                    cnt++;\n                }                    \n            }\n            if (mn == INF) continue;\n            for (int j = 0; j < N; j++) {\n                if (d[j][N-1] == mn) {\n                    dp[j] += dp[i]/cnt;\n                }\n            }\n        }\n        \n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid chmin(int& a,int b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tset<pii> edges;\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tif(!edges.emplace(u,v).second || !edges.emplace(v,u).second) continue;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) chmin(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) chmin(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tvector<__float128> cnt1(n,0); cnt1[0]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]<dp[0][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[e.src][e.dst]+dp[e.dst][n-1]==dp[e.src][n-1]) cnt1[e.dst]+=cnt1[e.src];\n\t\tvector<__float128> cnt2(n,0); cnt2[n-1]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[n-1][i]<dp[n-1][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[e.src][e.dst]+dp[e.dst][0]==dp[e.src][0]) cnt2[e.dst]+=cnt2[e.src];\n\t\t\n\t\tassert(abs(double(cnt1[n-1]-cnt2[0]))<EPS);\n\t\tfor(auto i:cs) printf(\"%.9f\\n\",double(cnt1[i]*cnt2[i]/cnt1[n-1])); puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M, C;\n\ntypedef long long ll;\n\nstruct Edge {\n  int to; ll cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nvector<int> cs;\n\n//vector<vector<int> > prev_;\nint prev_[110][110];\nint pcnt[110];\ndouble ans[110];\n\nstruct state {\n  int curr; ll cost;\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nstruct ST {\n  int curr; double prob;\n};\n\nll const INF = 1LL<<40;\n\nint main() {\n  \n  while(cin >> N >> M >> C && (N|M|C)) {\n    g.clear(); g.resize(N);\n    cs.clear(); cs.resize(C);\n    rep(i, M) {\n      int a, b; ll c; cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c});\n      g[b].push_back((Edge){a, c});\n    }\n    rep(i, C) cin >> cs[i];\n    \n    ll dist[N];\n    fill(dist, dist+N, INF);\n    dist[0] = 0;\n    \n    rep(i, N) pcnt[i] = 0;\n    \n    priority_queue<state> pq;\n    pq.push((state){0, dist[0]});\n    while(!pq.empty()) {\n      int curr = pq.top().curr;\n      ll cost = pq.top().cost;\n      pq.pop();\n      \n      rep(i, g[curr].size()) {\n        Edge& e = g[curr][i];\n        if(dist[e.to] == cost+e.cost) {\n          prev_[e.to][pcnt[e.to]++] = curr;\n        }\n        if(dist[e.to] <= cost+e.cost) { continue; }\n        pcnt[e.to] = 0;\n        prev_[e.to][pcnt[e.to]++] = curr;\n        dist[e.to] = cost+e.cost;\n        pq.push((state){e.to, dist[e.to]});\n      }\n    }\n    \n    rep(i, N) ans[i] = 0.;\n    \n    bool vis[110] = {};\n    \n    queue<ST> q;\n    q.push((ST){N-1, 1.0});\n    while(!q.empty()) {\n      int curr = q.front().curr;\n      double prob = q.front().prob;\n      q.pop();\n      vis[curr] = 1;\n      \n      rep(i, pcnt[curr]) {\n        int to = prev_[curr][i];\n        double nprob = prob/pcnt[curr];\n        ans[to] += nprob;\n        if(vis[to]) { continue; }\n        q.push((ST){to, nprob});\n      }\n    }\n    \n    rep(i, C) {\n      printf(\"%.10f\\n\", ans[cs[i]]);\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\ndouble ans[100];\nvector<int> froms[100];\n\nvoid calc( int pos, double prob ){\n\tvector<int>::iterator it;\n\tfor( it = froms[pos].begin(); it != froms[pos].end(); ++it ){\n\t\tif( *it != 0 ){\n\t\t\tans[*it] += prob;\n\t\t\tcalc( *it, prob );\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tfor( int i = 100; i--; )\tfroms[i].clear();\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill( ans, ans + 100, 0.0 );\n\n\t\tans[ n - 1 ] = ans[0] = 1.0;\n\t\tcalc( n - 1, 1.0 / cnt[ n - 1 ] );\n\t\t\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", ans[a] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\ndouble ans[100];\nvector<int> froms[100];\n\nvoid calc( int pos, double prob ){\n\tvector<int>::iterator it;\n\tfor( it = froms[pos].begin(); it != froms[pos].end(); ++it ){\n\t\tif( *it != 0 ){\n\t\t\tans[*it] += prob;\n\t\t\tcalc( *it, prob );\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tfor( int i = 100; i--; )\tfroms[i].clear();\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 29;\n\n\nint N, M, P;\nint v1[100], v2[100];\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, int *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(10);\n\n  while(cin >> N >> M >> P, N) {\n    g = vector< vector< edge > >(N, vector< int >());\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int INF=1000000000;\nint d[101][101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint n;\nint m;\nint p;\n\nstruct edge{\n    int to;\n    int cost;\n};\nvector<edge> G[101];\nll dp[101][101];\n//  éêðÊéÅZ[gÌæèûð¦ã°\nll dfs(int a,int b){\n    if(a==b)return 1;\n    else if(dp[a][b]!=-1)return dp[a][b];\n    ll res=0;\n    // ×ÖÚ®\n    for(int i=0;i<G[a].size();i++){\n        edge &e=G[a][i];\n        if(d[e.to][b]+e.cost==d[a][b]){\n            res+=dfs(e.to,b);\n        }\n    }\n    return dp[a][b]=res;\n}\nint main(){\n    bool first=true;\n    while(cin>>n>>m>>p&&(n|m|p)){\n        if(first){\n            first=false;\n        }\n        else cout<<endl;\n        for(int i=0;i<101;i++)G[i].clear();\n        for(int i=0;i<101;i++){\n            for(int j=0;j<101;j++){\n                if(i==j)d[i][j]==0;\n                else d[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;i++){\n            int a,b,ct;\n            cin>>a>>b>>ct;\n            edge e;\n            e.to=b;\n            e.cost=ct;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[b][a]=d[a][b]=ct;\n        }\n        warshall_floyd(n);\n        memset(dp,-1,sizeof(dp));\n        for(int i=0;i<p;i++){\n            int a;\n            cin>>a;\n            ll res=dfs(0,a)*dfs(a,n-1);\n            printf(\"%.10f\\n\",(double)res/(dfs(0,n-1)));\n        }\n        //cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint g[100][100];\nint h[100][100];\nint c[100];\ndouble r[100][100];\n\nint main(){\n  while(true){\n    int n = getInt();\n    int m = getInt();\n    int p = getInt();\n\n    if(n+m+p == 0) break;\n\n#define MAX 10000000\n    REP(i,n) REP(j,n){\n      g[i][j] = 0;\n      h[i][j] = (i == j ? 0 : MAX);\n    }\n\n    REP(i,m){\n      int a = getInt();\n      int b = getInt();\n      int c = getInt();\n\n      h[a][b] = h[b][a] = g[a][b] = g[b][a] = c;\n    }\n\n    REP(i,p) c[i] = getInt();\n\n    REP(k,n) REP(i,n) REP(j,n){\n      h[i][j] = min(h[i][j], h[i][k] + h[k][j]);\n    }\n\n    REP(i,n) REP(j,n){\n      if(g[i][j] == 0)\n        r[i][j] = 0.0;\n      else if(h[0][i] + g[i][j] + h[j][n-1] != h[0][n-1])\n        r[i][j] = 0.0;\n      else\n        r[i][j] = 1.0;\n    }\n\n    REP(k,n) REP(i,n) REP(j,n){\n      r[i][j] = r[i][j] + r[i][k] * r[k][j];\n    }\n\n    REP(i,p)\n      printf(\"%.8f\\n\",r[0][c[i]]*r[c[i]][n-1]/r[0][n-1]);\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n \nusing ll = long long int;\nusing ull = unsigned long long int;\nusing P = pair<int, int>;\nusing P3 = pair<ll,P>;\nusing PP = pair<P ,P>;\nconstexpr ll MOD = 998244353;\nconstexpr int IINF = INT_MAX;\nconstexpr ll LLINF = LLONG_MAX;\nconstexpr int MAX_N = int(1e6) + 5;\nconstexpr double EPS = 1e-8;\nconstexpr int di[] = {0, 1, 0, -1}, dj[] = {1, 0, -1, 0};\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define REPR(i, n) for (int i = n; i >= 0; i--)\n#define SORT(v) sort((v).begin(), (v).end())\n#define SORTR(v) sort((v).rbegin(), (v).rend())\n#define ALL(v) (v).begin(), (v).end()\n\nvector<vector<P> > g;\nvector<int> d;\n\nvoid dijkstra(){\n    fill(d.begin(), d.end(), IINF);\n    d[0] = 0;\n    priority_queue<P, vector<P>, greater<P> > que;\n    que.push(P(0,0));\n    while(!que.empty()){\n        auto p = que.top();\n        que.pop();\n        int now = p.second;\n        if(d[now] < p.first) continue;\n        for(auto &e : g[now]){\n            int nxt = e.first, c = e.second;\n            if(d[nxt] > d[now] + c){\n                d[nxt] = d[now] + c;\n                que.push(P(d[nxt], nxt));\n            }\n        }\n    }\n}\n\nint main(){\n    int n, m, p;\n    while(cin >> n >> m >> p, n){\n        vector<int> a(p);\n        g.clear();\n        g.resize(n);\n        d.resize(n);\n        for(int i=0;i<m;i++){\n            int u, v, c;\n            cin >> u >> v >> c;\n            g[u].push_back(P(v,c));\n            g[v].push_back(P(u,c));\n        }\n        for(int i=0;i<p;i++){\n            cin >> a[i];\n        }\n        dijkstra();\n        vector<int> ord;\n        vector<bool> used(n);\n        vector<vector<double> > dp(2, vector<double>(n)); \n        priority_queue<P, vector<P>, greater<P> > que;\n        que.push(P(0,0));\n        dp[0][0] = 1.0;\n        while(!que.empty()){\n            auto p = que.top();\n            que.pop();\n            int now = p.second;\n            if(used[now]) continue;\n            ord.push_back(now);\n            used[now] = true;\n            for(auto e : g[now]){\n                int nxt = e.first , c = e.second;\n                if(d[nxt] == d[now] + c){\n                    que.push(P(d[nxt], nxt));\n                    dp[0][nxt] += dp[0][now];\n                }\n            }\n        }\n        reverse(ord.begin(), ord.end());\n        dp[1][n-1] = 1.0;\n        for(auto now : ord){\n            for(auto e : g[now]){\n                int nxt = e.first, c = e.second;\n                if(d[nxt]+c == d[now]){\n                    dp[1][nxt] += dp[1][now];\n                }\n            }\n        }\n        for(int i=0;i<p;i++){\n            printf(\"%.8lf\\n\", dp[0][a[i]]*dp[1][a[i]]/dp[0][n-1]);\n        }\n        cout << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int>> P;\n\nstruct E{\n\tint t, c;\n};\n\nint n, m, p;\nvector<E> g[100];\nint d[100];\ndouble c[100];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d%d\", &n, &m, &p);\n\t\tif(n == 0 && m == 0 && p ==0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tg[a].push_back(E{b, c});\n\t\t\tg[b].push_back(E{a, c});\n\t\t}\n\n\t\tfill(d, d + n, 2e8);\n\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\td[0] = 0;\n\t\tq.push(P(0, {0, 1}));\n\t\twhile(!q.empty()){\n\t\t\tP v = q.top();\n\t\t\tq.pop();\n\t\t\tif(v.first > d[v.second.first]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool f = c[v.second.first] != 0;\n\t\t\tc[v.second.first] += v.second.second;\n\t\t\tif(f){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(auto& x: g[v.second.first]){\n\t\t\t\tif(d[x.t] >= d[v.second.first] + x.c){\n\t\t\t\t\td[x.t] = d[v.second.first] + x.c;\n\t\t\t\t\tq.push(P(d[x.t], {x.t, c[v.second.first]}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(i, p){\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\tprintf(\"%.8f\\n\", c[z] / c[n - 1]);\n\t\t}\n\n\t\trep(i, n){\n\t\t\tg[i].clear();\n\t\t}\n\t\tfill(c, c + n, 0);\n\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 100000000 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//if(!cnt[n-1])return 0;\nif(froms[n-1].empty())return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,k;cin>>n>>m>>k && n|m|k;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(k);\n\t\trep(i,k) cin>>cs[i];\n\t\t\n\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\t\tpq.emplace(-1,0,0);\n\t\tvi dist(n,INF);\n\t\tvvi prev(n);\n\t\twhile(pq.size()){\n\t\t\tEdge cur=pq.top(); pq.pop();\n\t\t\tif(dist[cur.dst]<cur.weight) continue;\n\t\t\tdist[cur.dst]=cur.weight;\n\t\t\tprev[cur.dst].push_back(cur.src);\n\t\t\tfor(auto e:g[cur.dst])\n\t\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t\t}\n\t\t\n\t\tvd ps(n,0); ps[n-1]=1;\n\t\t//vi is(n); iota(all(is),0);\n\t\t//sort(all(is),[&](int i,int j){return dist[i]>dist[j];});\n\t\t//for(auto u:is) for(auto v:prev[u]) if(v!=-1)\n\t\t//\tps[v]+=ps[u]/prev[u].size();\n\t\t\n\t\trep(i,k) printf(\"%.8f\\n\",ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100]; double pb[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28,pb[i]=0;\n\t\td[0]=0; pb[0]=1;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(d[c]<-cc)continue;\n\t\t\t\n\t\t\tint cnt=0;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,pb[i->first]=0,Q.push(mp(cc-i->second,i->first));\n\t\t\tfr(i,e[c])if(d[i->first]==-cc+i->second)cnt++;\n\t\t\tfr(i,e[c])if(d[i->first]==-cc+i->second)pb[i->first]+=pb[c]/cnt;\n\t\t}\n\t\trep(i,p)printf(\"%.7f\\n\",pb[C[i]]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) D[u].push_back(v);\n\t\t}\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\t// rep(u,n){\n\t\t\t// bool vis[100]={}; vis[u]=true;\n\t\t\t// dp[u][u]=1;\n\t\t\t// queue<int> Q; Q.push(u);\n\t\t\t// while(!Q.empty()){\n\t\t\t\t// int v=Q.front(); Q.pop();\n\t\t\t\t// rep(i,D[v].size()){\n\t\t\t\t\t// int w=D[v][i];\n\t\t\t\t\t// if(!vis[w]){\n\t\t\t\t\t\t// vis[w]=true;\n\t\t\t\t\t\t// Q.push(w);\n\t\t\t\t\t// }\n\t\t\t\t\t// dp[u][w]+=dp[u][v];\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) dp[u][v]=1;\n\t\t}\n\t\trep(w,n) rep(u,n) rep(v,n) dp[u][v]+=dp[u][w]*dp[w][v];\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tassert(c!=0 && c!=n-1);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tlong long int cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\t\t\t\tif( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t\t\n\t\t\t\t\tif(!cnt[it->second])while(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vector<int> c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vector<int> d(n,1e9);\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    graph dag(n);\n    queue<int> q;\n    q.push(n-1);\n    while(q.size()){\n      int v = q.front(); q.pop();\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis){\n\t  dag[u].push_back(edge(dis,v));\n\t  q.push(u);\n\t}\n      }\n    }\n\n    vector<int> deg(n,0), order;\n    for(int v=0;v<n;v++){\n      for(edge e : dag[v])deg[e.second]++;\n    }\n\n    for(int v=0;v<n;v++){\n      if(deg[v]==0)q.push(v);\n    }\n\n    while(q.size()){\n      int v = q.front(); q.pop();\n      order.push_back(v);\n      for(edge e : dag[v]){\n\tint u = e.second;\n\tdeg[u]--;\n\tif(deg[u] == 0)q.push(u);\n      }\n    }\n\n    vector<long double> prob(n);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(edge e : dag[v]){\n\tint u = e.second;\n\tprob[u] += prob[v]/dag[v].size();\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\nlong double dp[MAX];\nlong double cnt[MAX];\nvector<Edge> G[MAX];\nbool visited[MAX];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n        dp[i] = cnt[i] = 0;\n        visited[i] = 0;\n    }\n}\n\nvector<int> dijkstra(int n){\n    vector<int> d(n, INF); d[0] = 0;\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,0));\n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost < d[e.to]){\n                d[e.to] = d[v] + e.cost;\n                Q.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n    return d;\n}\n\nvoid dijkstra2(int s,int n,vector<int> &d2){\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,s));\n    vector<int> d(n,INF); d[s] = 0;\n    if(s == n-1) cnt[s] = 1;\n    else dp[s] = 1;\n    \n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost <= d[e.to]){\n                if(s == n-1){\n                    if(d2[v]-d2[e.to] == e.cost){\n                        cnt[e.to] += cnt[v];\n                    }\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }else{\n                    dp[e.to] += dp[v]*cnt[e.to]/cnt[v];\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        vector<int> d = dijkstra(n);\n\n        dijkstra2(n-1,n,d);\n        dijkstra2(0,n,d);\n        \n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.12Lf\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define INF (1<<26)\n#define MAX 105\nstruct edge{int to,cost;};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<edge> G[MAX];\nint T[MAX][MAX];\nint n,m,p;\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n    for(int j=0;j<MAX;j++){\n      T[i][j]=(i==j?0:INF);\n    }\n  }\n}\n\nint d[MAX],cnt[MAX];\nvoid dijkstra(){\n  for(int i=0;i<MAX;i++)d[i]=INF,cnt[i]=0;\n  priority_queue<state> Q;\n  d[0]=0;\n  cnt[0]=1;\n  Q.push((state){0,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(d[e.to]<s.cost+e.cost)continue;\n      else if(d[e.to]==s.cost+e.cost){\n\tcnt[e.to]+=cnt[s.pos];\n      }else{\n\tcnt[e.to]=cnt[s.pos];\n\td[e.to]=s.cost+e.cost;\n\tQ.push((state){e.to,d[e.to]});\n      }\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>p;\n    if(n==0&&m==0&&p==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n      T[a][b]=c;\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  T[i][j]=min(T[i][j],T[i][k]+T[k][j]);\n    dijkstra();\n    for(int i=0;i<p;i++){\n      int a;\n      scanf(\"%d\",&a);\n      if(d[a]+T[a][n-1]!=d[n-1]){\n\tcout<<\"0.0\"<<endl;\n      }else{\n\tdouble x=cnt[a],y=cnt[n-1];\n\tprintf(\"%.8f\\n\",x/y);\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<climits>\nusing namespace std;\nconst long long mod=10000000000LL;\nstruct edge \n{\n\tint u,v,w,next;\n}a[120000];\nint start[120],tot=0,n,m;\nvoid addedge(int u,int v,int w)\n{\n\ta[tot].u=u;\n\ta[tot].v=v;\n\ta[tot].w=w;\n\ta[tot].next=start[u];\n\tstart[u]=tot++;\n}\nint d[120],que[120];\ndouble dp[120],dp1[120];\nvector<int>g[120];\nvector<int>g1[120];\nint outd[120];\ndouble getdp(int u,int st)\n{\n\tif (u==st)return dp[u]=1;\n\tif (dp[u]!=-1)return dp[u];\n\tint i;\n\tdouble sum=0;\n\tfor (i=0;i<g[u].size();i++)\n\t{\n\t\tsum+=getdp(g[u][i],st);\n\t}\n\treturn dp[u]=sum;\n}\ndouble fz[120],fz1[120],tt;\nvoid spfa(int st)\n{\n\tint i,j,k;\n\tmemset(d,100,sizeof(d));\n\tmemset(que,0,sizeof(que));\n\td[st]=0;que[st]=1;\n\tqueue<int>q;\n\tq.push(st);\n\twhile (!q.empty())\n\t{\n\t\tint tmp=q.front();\n\t\tq.pop();\n\t\tque[tmp]=0;\n\t\tfor (i=start[tmp];~i;i=a[i].next)\n\t\t{\n\t\t\tif (d[a[i].v]>d[tmp]+a[i].w)\n\t\t\t{\n\t\t\t\td[a[i].v]=d[tmp]+a[i].w;\n\t\t\t\tif (!que[a[i].v])\n\t\t\t\t{\n\t\t\t\t\tque[a[i].v]=1;\n\t\t\t\t\tq.push(a[i].v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0;i<n+10;i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t}\n\t\t\n\tfor (i=0;i<m;i++)\n\t{\n\t\tif (d[a[i].v]==a[i].w+d[a[i].u])\n\t\t{\n\t\t\tg[a[i].v].push_back(a[i].u);\n\t\t}\n\t}\n\tif (st==0)\n\t{\n\t\tfor (i=0;i<n+10;i++)\n\t\t{\n\t\t\tdp[i]=-1;\n\t\t}\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tgetdp(i,st);\n\t\t}\n\t\ttt=dp[n-1];\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tfz[i]=dp[i];\n\t\t}\n\t\treturn;\n\t}\n\tfor (i=0;i<n+10;i++)\n\t\t{\n\t\t\tdp[i]=-1;\n\t\t}\n\tfor (i=n-1;i<n;i++)\n\t{\n\t\tgetdp(i,st);\n\t}\n\t//if (st==1)cout<<dp[n-1]<<endl;\n\tfz1[st]=dp[n-1];\n}\nint main()\n{\n\tint i,j,k,q;\n\twhile (scanf(\"%d%d%d\",&n,&m,&q)!=EOF,n*n+m*m+q*q)\n\t{\n\t\tfor (i=0;i<n+10;i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tg1[i].clear();\n\t\t\toutd[i]=0;\n\t\t\tstart[i]=-1;\n\t\t}\n\t\ttot=0;\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\taddedge(x,y,z);\n\t\t}\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tspfa(i);\n\t\t}\n\t\t//cout<<fz[1]<<endl;\n\t\twhile (q--)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%.14lf\\n\",fz[x]*fz1[x]/tt);\n\t\t}\n\t}\n\treturn 0;\n}\n\t\t\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tif(!cnt[p.second])while(1);\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//if(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int INF=1000000000;\nint d[101][101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint n;\nint m;\nint p;\n\nstruct edge{\n    int to;\n    int cost;\n};\nvector<edge> G[101];\nll dp[101][101];\n//  éæÔðÊéÅZ[gÌæèûð¦ã°\nll dfs(int a,int b){\n    if(a==b)return 1;\n    else if(dp[a][b]!=-1)return dp[a][b];\n    ll res=0;\n    // ×ÖÚ®\n    for(int i=0;i<G[a].size();i++){\n        edge &e=G[a][i];\n        if(d[e.to][b]+e.cost==d[a][b])res+=dfs(e.to,b);\n    }\n    return dp[a][b]=res;\n}\nint main(){\n    while(cin>>n>>m>>p&&(n|m|p)){\n        for(int i=0;i<101;i++)G[i].clear();\n        for(int i=0;i<101;i++){\n            for(int j=0;j<101;j++){\n                if(i==j)d[i][j]=0;\n                else d[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;i++){\n            int a,b,ct;\n            cin>>a>>b>>ct;\n            edge e;\n            e.to=b;\n            e.cost=ct;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[b][a]=d[a][b]=ct;\n        }\n        warshall_floyd(n);\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dp[i][j]=-1;\n        for(int i=0;i<p;i++){\n            int a;\n            cin>>a;\n            ll res=dfs(0,a)*dfs(a,n-1);\n            // àµaðoR·éÅZoHª¶ÝµÈ¢ê\n            if((d[0][a]+d[a][n-1])!=d[0][n-1])res=0;\n            printf(\"%.10f\\n\",(double)res/(dfs(0,n-1)));\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int>> P;\n\nstruct E{\n\tint t, c;\n};\n\nint n, m, p;\nvector<E> g[100];\nint d[100];\ndouble c[100];\n\nint main(){\n\tbool f = false;\n\twhile(1){\n\t\tscanf(\"%d%d%d\", &n, &m, &p);\n\t\tif(n == 0 && m == 0 && p ==0){\n\t\t\tbreak;\n\t\t}\n\n\t\tif(f){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse{\n\t\t\tf = true;\n\t\t}\n\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tg[a].push_back(E{b, c});\n\t\t\tg[b].push_back(E{a, c});\n\t\t}\n\n\t\tfill(d, d + n, 2e8);\n\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\td[0] = 0;\n\t\tq.push(P(0, {0, -1}));\n\t\twhile(!q.empty()){\n\t\t\tP v = q.top();\n\t\t\tq.pop();\n\t\t\tif(v.first > d[v.second.first]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool f = c[v.second.first] != 0;\n\t\t\tc[v.second.first] += v.second.second != -1 ? c[v.second.second] : 1;\n\t\t\tif(f){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(auto& x: g[v.second.first]){\n\t\t\t\tif(d[x.t] >= d[v.second.first] + x.c){\n\t\t\t\t\td[x.t] = d[v.second.first] + x.c;\n\t\t\t\t\tq.push(P(d[x.t], {x.t, v.second.first}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t\tprintf(\"\\n\");\n\t\t\trep(i, n){\n\t\t\t\tprintf(\"%.8f\\n\", c[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t*/\n\n\t\trep(i, p){\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\tprintf(\"%.8f\\n\", c[z] / c[n - 1]);\n\t\t}\n\n\t\trep(i, n){\n\t\t\tg[i].clear();\n\t\t}\n\t\tfill(c, c + n, 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint g[100][100];\nint c[100];\nint memo[100];\nint r[100];\n\nint main(){\n  while(true){\n    int n = getInt();\n    int m = getInt();\n    int p = getInt();\n\n    if(n+m+p == 0) break;\n\n    REP(i,n) REP(j,n) g[i][j] = 0;\n    REP(i,n){\n      memo[i] = -1;\n      r[i] = 0;\n    }\n\n    REP(i,m){\n      int a = getInt();\n      int b = getInt();\n      int c = getInt();\n\n      g[a][b] = g[b][a] = c;\n    }\n\n    REP(i,p) c[i] = getInt();\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    pq.push(mp(0,0));\n    int cnt = 0;\n\n    while(cnt != n){\n      data d = pq.top();\n      int cost = d.f;\n      int pos  = d.s;\n\n      pq.pop();\n\n      if(memo[pos] != -1)\n        continue;\n\n      memo[pos] = cost;\n      cnt++;\n\n      REP(i,n)\n        if(g[pos][i] && memo[i] == -1)\n          pq.push(mp(cost + g[pos][i], i));\n    }\n\n    vector<pair<int,int> > v(n);\n    REP(i,n){\n      v[i].f = memo[i];\n      v[i].s = i;\n    }\n    sort(v.begin(), v.end());\n    r[0] = 1;\n\n    REP(i,n){\n      int pos = v[i].s;\n\n      REP(j,n){\n        if(g[pos][j] != 0 && memo[j] == memo[pos] + g[pos][j])\n          r[j] += r[pos];\n      }\n    }\n\n    //REP(i,n) printf(\"%d: %d,%d\\n\",i,memo[i],r[i]);\n\n    int all = r[n-1];\n    REP(i,p)\n      printf(\"%.8f\\n\",(double)r[c[i]] / all);\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist, vector<vector<bool> >& from)\n{\n    int n = edges.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    from.assign(n, vector<bool>(n, false));\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n                from[e.to].assign(n, false);\n            }\n            if(dist[v] + e.cost <= dist[e.to]){\n                from[e.to][v] = true;\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid solve(vector<vector<Edge> >& edges, vector<double>& p)\n{\n    int n = edges.size();\n    vector<int> dist;\n    vector<vector<bool> > from;\n    shortestPath(edges, 0, dist, from);\n\n    map<int, int> m;\n    m.insert(make_pair(0, 0));\n    p.resize(n, 0.0);\n    p[0] = 1.0;\n    vector<bool> check(n, false);\n    while(!m.empty()){\n        int cost = m.begin()->first;\n        int pos = m.begin()->second;\n        double prob = p[pos];\n        m.erase(m.begin());\n        if(check[pos])\n            continue;\n        check[pos] = true;\n\n        int num = 0;\n        for(unsigned i=0; i<edges[pos].size(); ++i){\n            int to = edges[pos][i].to;\n            if(from[to][pos]){\n                ++ num;\n                m.insert(make_pair(dist[to], to));\n            }\n        }\n        for(unsigned i=0; i<edges[pos].size(); ++i){\n            int to = edges[pos][i].to;\n            if(from[to][pos]){\n                p[to] += prob / num;\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            edges[a].push_back(Edge(b, c));\n        }\n\n        vector<double> prob;\n        solve(edges, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint g[110][110];\nvector<int>g2[110];\nint p[11000];\nint q[11000];\nint r[11000];\npair<int,int> pt[110];\ndouble dp[110];\nint main(){\n\tint a,b,c;\n\twhile(scanf(\"%d%d%d\",&a,&b,&c),a){\n\t\tfor(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=999999999;\n\t\tfor(int i=0;i<a;i++)g[i][i]=0;\n\t\tfor(int i=0;i<a;i++){g2[i].clear();}\n\t\tfor(int i=0;i<b;i++){\n\t\t\tscanf(\"%d%d%d\",p+i,q+i,r+i);\n\t\t\tg[p[i]][q[i]]=g[q[i]][p[i]]=r[i];\n\t\t}\n\t\tfor(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n\t\t\tg[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint P=p[i];\n\t\t\tint Q=q[i];\n\t\t\tint R=r[i];\n\t\t\tif(g[0][P]+R==g[0][Q]&&g[Q][a-1]+R==g[P][a-1]){\n\t\t\t\tg2[P].push_back(Q);\n\t\t\t}\n\t\t\tswap(P,Q);\n\t\t\tif(g[0][P]+R==g[0][Q]&&g[Q][a-1]+R==g[P][a-1]){\n\t\t\t\tg2[P].push_back(Q);\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<110;i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(int i=0;i<a;i++)pt[i]=make_pair(g[0][i],i);\n\t\tstd::sort(pt,pt+a);\n\t\tfor(int i=0;i<a;i++){\n\t\t\tint at=pt[i].second;\n\t\t\tfor(int j=0;j<g2[at].size();j++){\n\t\t\t\tdp[g2[at][j]]+=dp[at]/(g2[at].size());\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<c;i++){\n\t\t\tint t;scanf(\"%d\",&t);\n\t\t\tprintf(\"%.12f\\n\",dp[t]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint N, M, P;\ndouble A[500][500],b[500];\n\nvoid givens_makerot(double x,double y,double &c,double &s){\n    double r = hypot(x,y);\n    if(r<1e-9) exit(1);\n    c = x / r; s = y / r;\n}\n\nvoid givens_rot(double &x,double &y,double c,double s){\n    double u = c*x + s*y;\n    double v = -s*x + c*y;\n    x = u; y = v;\n}\n\nvoid givens_elimination(){\n    for(int i = 0; i < N ; i++){\n        for(int j = i+1; j < N; j++){\n            double _c,_s;\n            givens_makerot(A[i][i],A[j][i],_c,_s);\n            givens_rot(b[i],b[j],_c,_s);\n            for(int k = i; k < N; k++) givens_rot(A[i][k],A[j][k],_c,_s);\n        }\n    }\n\n    for(int i = N-1; i >= 0; i--){\n        b[i] /= A[i][i];\n        for(int j = i-1; j >= 0; j--){\n            b[j] -= A[j][i] * b[i];\n        }\n    }\n}\nint main(){\n  bool first = true;\n  while(cin >> N >> M >> P && N){\n    if(first) first = false;\n    else cout << endl;\n    int d[100][100];\n    REP(i, N) REP(j, N) d[i][j] = i != j ? INF : 0;\n    int edge[100][100] = {};\n    memset(edge, -1, sizeof(edge));\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      d[a][b] = d[b][a] = c;\n      edge[a][b] = edge[b][a] = c;\n    }\n    vector<int> child(P);\n    REP(i, P) cin >> child[i];\n    REP(k, N) REP(i, N) REP(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    REP(i, N) REP(j, N) A[i][j] = i == j ? 1.0 : 0.0;\n    REP(i, N) b[i] = 0.0;\n    b[0] = 1.0;\n    REP(i, N){\n      vector<int> to;\n      REP(j, N) if(i != j) {\n        if(edge[i][j] != -1 && edge[i][j] + d[j][N - 1] == d[i][N - 1]){\n          // i -> j\n          to.push_back(j);\n        }\n      }\n      REP(l, to.size()){\n        int v = to[l], u = i;\n        A[v][u] = -1.0 / to.size();\n      }\n    }\n    givens_elimination();\n    REP(i, P) printf(\"%.12lf\\n\", b[child[i]]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<long long>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nint dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<long long>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<long long> num1(n, -1), num2(n, -1);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n, 0.0);\n    for(int i=0; i<n; ++i){\n        if(num1[i] != -1 && num2[i] != -1)\n            p[i] = 1.0 * num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//if(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Data {\n  int cur;\n  ll w;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w < data.w;\n    return cur < data.cur;\n  }\n};\n\nconst ll LLINF = LLONG_MAX;\nconst int MAX_V = 110;\nint n,m,p;\nll fw[110][110];\nll dp[MAX_V];\nvector<Data> G[MAX_V];\n\nint main(){\n  while( cin >> n >> m >> p, n|m|p ){\n    rep(i,n) G[i].clear();\n    rep(i,n) rep(j,n) fw[i][j] = ((i==j)?0:LLINF);\n    rep(i,m) {\n      int s,t;\n      ll c;\n      cin >> s >> t >> c;\n      G[s].push_back((Data){t,c});\n      G[t].push_back((Data){s,c});\n      fw[s][t] = fw[t][s] = c;\n    }\n    rep(k,n) rep(i,n) rep(j,n) if( fw[i][k] != LLINF && fw[k][j] != LLINF ) fw[i][j] = min(fw[i][j],\n\t\t\t\t\t\t\t\t\t\t\t   fw[i][k]+fw[k][j]);\n\n    vector<Data> vec;\n    rep(i,n) vec.push_back((Data){i,fw[0][i]});\n    sort(vec.begin(),vec.end());  \n    rep(i,n) dp[i] = 0;\n    dp[0] = 1;\n    rep(i,vec.size()) {\n      int cur = vec[i].cur;\n      if( fw[0][cur] == LLINF || fw[cur][n-1] == LLINF ) continue;\n      ll weight = vec[i].w;\n      rep(i,G[cur].size()) if( cur != G[cur][i].cur ){\n\tint next = G[cur][i].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][next] == fw[0][cur] + G[cur][i].w ) {\n\t  dp[next] += dp[cur];\n\t}\n      }\n    }\n\n    rep(i,p){\n      int pos;\n      cin >> pos;\n      printf(\"%.10f\\n\",dp[pos]/(double)dp[n-1]);\n    } puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<double> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint cnt[100] = {0};\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 100000000 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == p.first) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];\n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n        \n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[1000] = {0};\n\tint cnt[1000] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 1000, 1e9 );\n\t\tfill( cnt, cnt + 1000, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\nif(cnt[p.second]<0)return 1;\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100];\nbool v[100],u[100]; double cnt[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28;\n\t\td[0]=0;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(c==n-1)break;\n\t\t\tif(d[c]<-cc)continue;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,Q.push(mp(cc-i->second,i->first));\n\t\t}\n\t\t\n\t\trep(i,n)u[i]=v[i]=0,cnt[i]=0;\n\t\tqueue<int> q; q.push(n-1);\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tv[c]=1;\n\t\t\tfr(i,e[c])if(!v[i->first]&&d[i->first]+i->second==d[c])q.push(i->first);\n\t\t}\n\t\tq=queue<int>(); q.push(0);\n\t\tcnt[0]=1;\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tu[c]=1;\n\t\t\tfr(i,e[c])if(v[i->first]&&d[i->first]==d[c]+i->second)\n\t\t\t{\n\t\t\t\tcnt[i->first]+=cnt[c];\n\t\t\t\tif(!u[i->first])q.push(i->first);\n\t\t\t}\n\t\t}\n\t\trep(i,p)printf(\"%.7f\\n\",cnt[C[i]]/cnt[n-1]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <string>\n#include <queue>\nusing namespace std;\n#define SZ(v) ((int)(v).size())\nconst int maxint = -1u>>1;\nconst int maxn = 100 + 5;\nconst int inf = 1000000;\n\nint n, m, q;\nint d[maxn];\ndouble cnt[maxn];\nbool used[maxn];\nint g[maxn][maxn];\ndouble p[maxn];\n\nvoid spfa() {\n    fill(d, d + n, inf);\n    fill(used, used + n, false);\n    queue<int> que;\n    que.push(0);\n    used[0] = true;\n    d[0] = 0;\n    while (!que.empty()) {\n        int top = que.front();\n        que.pop();\n        used[top] = false;\n        for (int i = 0; i < n; ++i) {\n            if (d[i] > g[top][i] + d[top]) {\n                d[i] = g[top][i] + d[top];\n                if (!used[i]) {\n                    used[i] = true;\n                    que.push(i);\n                }\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (i == j) continue;\n            if (d[i] + g[i][j] != d[j]) g[i][j] = inf;\n        }\n    }\n}\n\nvoid dfs(int x) {\n    if (x == n - 1) cnt[x] = 1;\n    if (cnt[x] >= 0) return;\n    cnt[x] = 0;\n    for (int i = 0; i < n; ++i) {\n        if (g[x][i] < inf) {\n            dfs(i);\n            cnt[x] += cnt[i];\n        }\n    }\n    if (cnt[x] == 0) return;\n    for (int i = 0; i < n; ++i) {\n        if (g[x][i] < inf) {\n            p[i] += (double)cnt[i] / cnt[x];\n        }\n    }\n}\n\nint main() {\n    //freopen (\"H.in\", \"w\", stdout);\n    //printf (\"%d %d %d\\n\", 100, 50 * 99, 1);\n    //for (int i = 0; i < 100; ++i) {\n        //for (int j = i + 1; j < 100; ++j) {\n            //printf (\"%d %d %d\\n\", i, j, j - i);\n        //}\n    //}\n    //printf (\"1\\n\");\n    \n    while (scanf(\"%d%d%d\", &n, &m, &q) == 3 && (n + m + q)) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                g[i][j] = inf;\n            }\n        }\n        for (int i = 0; i < m; ++i) {\n            int x1, x2, x;\n            scanf(\"%d%d%d\", &x1, &x2, &x);\n            g[x1][x2] = g[x2][x1] = x;\n        }\n        spfa();\n        fill(cnt, cnt + n, -1);\n        memset(p, 0, sizeof(p));\n        dfs(0);\n        while (q--) {\n            int x;\n            scanf(\"%d\", &x);\n            printf(\"%.10lf\\n\", p[x]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\t\t\t\tif( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t\t\n\t\t\t\t\tif(!cnt[it->second])while(1);\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            dp[e.to] += dp[v]*(1./cnt); \n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,false,sizeof(visited));\n        memset(dp,0,sizeof(dp));\n        dp[n-1] = 1;\n        dfs(n-1,d);\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.8f\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 29;\n\n\nint N, M, P;\nint v1[100], v2[100];\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, int *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(10);\n\n  while(cin >> N >> M >> P, N) {\n    g.clear();\n    g.resize(N);\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tfor(int i=0;i<n;i++)if(cnt[n]<0)return 1;\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost && cnt != 0){\n            dp[e.to] += dp[v]*(1./cnt); \n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,false,sizeof(visited));\n        memset(dp,0,sizeof(dp));\n        dp[n-1] = 1;\n        dfs(n-1,d);\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.8f\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//RE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct route{\n\tint w;\n\tbitset<100> b;\n\n\troute(int w_, int p_, const bitset<100> &b_):\n\t\tw(w_), b(b_)\n\t{\n\t\tb.set(p_);\n\t}\n\t\n\tbool operator() (const route &r1, const route &r2){\n\t\treturn r1.w > r2.w;\n\t}\n} first( 0, 0, bitset<100>() );\n\nint main(){\n\tint n, m, p, a, b, w;\n\tvector<route>::iterator it1;\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<route> > rts(n);\n\t\trts[0].push_back( first );\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n\tEdge() { Edge(-1, -1); }\n};\n\nint n, m, p;\nvector<vector<Edge> > edges;\nvector<vector<int> > prevv;\nvoid prev_nodes()\n{\n\tconst int INF = 1e7;\n\tvector<int> dis(n, INF);\n\tprevv = vector<vector<int> >(n);\n\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\tdis[0] = 0;\n\tq.push(pint(0, 0));\n\twhile (!q.empty())\n\t{\n\t\tpint tt = q.top(); q.pop();\n\t\tint cur = tt.second, cost = tt.first;\n\n\t\tif (cost > dis[cur])\n\t\t\tcontinue;\n\n\t\tforeach (e, edges[cur])\n\t\t{\n\t\t\tint to = e->to, nc = cost + e->cost;\n\t\t\tif (nc < dis[to])\n\t\t\t{\n\t\t\t\tdis[to] = nc;\n\t\t\t\tprevv[to].clear();\n\t\t\t\tprevv[to].push_back(cur);\n\t\t\t\tq.push(pint(nc, to));\n\t\t\t}\n\t\t\telse if (nc == dis[to])\n\t\t\t\tprevv[to].push_back(cur);\n\t\t}\n\t}\n}\n\nvector<ll> paths;\nll recur(int v)\n{\n\tif (prevv[v].empty())\n\t\treturn 1;\n\telse if (paths[v] != -1)\n\t\treturn paths[v];\n\n\tll res = 0;\n\tfor (int i = 0; i < prevv[v].size(); ++i)\n\t\tres += recur(prevv[v][i]);\n\n\treturn paths[v] = res;\n}\nint main()\n{\n\twhile (cin >> n >> m >> p, n)\n\t{\n\t\tedges = vector<vector<Edge> >(n);\n\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedges[a].push_back(Edge(b, c));\n\t\t\tedges[b].push_back(Edge(a, c));\n\t\t}\n\n\t\tprev_nodes();\n\t\tpaths = vector<ll>(n, -1);\n\t\tpaths[0] = recur(n - 1);\n\n\t\twhile (p--)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\t\n\t\t\tdouble res = (double)paths[c] / paths[n - 1];\n\t\t\tprintf(\"%.8f\\n\", res);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int>> P;\n\nstruct E{\n\tint t, c;\n};\n\nint n, m, p;\nvector<E> g[100];\nint d[2][100];\ndouble c[2][100];\n\nint main(){\n\twhile(1){\n\t\tscanf(\"%d%d%d\", &n, &m, &p);\n\t\tif(n == 0 && m == 0 && p ==0){\n\t\t\tbreak;\n\t\t}\n\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tg[a].push_back(E{b, c});\n\t\t\tg[b].push_back(E{a, c});\n\t\t}\n\n\t\trep(i, 2){\n\t\t\tfill(d[i], d[i] + n, 2e8);\n\t\t\tfill(c[i], c[i] + n, 0);\n\n\t\t\tpriority_queue<P, vector<P>, greater<P>> q;\n            int s = i == 0 ? 0 : n - 1;\n\t\t\td[i][s] = 0;\n\t\t\tq.push(P(0, {s, -1}));\n\t\t\twhile(!q.empty()){\n\t\t\t\tP v = q.top();\n\t\t\t\tq.pop();\n\t\t\t\tif(v.first > d[i][v.second.first]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tbool f = c[i][v.second.first] != 0;\n\t\t\t\tc[i][v.second.first] += v.second.second != -1 ? c[i][v.second.second] : 1;\n\t\t\t\tif(f){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor(auto& x: g[v.second.first]){\n\t\t\t\t\tif(d[i][x.t] >= d[i][v.second.first] + x.c){\n\t\t\t\t\t\td[i][x.t] = d[i][v.second.first] + x.c;\n\t\t\t\t\t\tq.push(P(d[i][x.t], {x.t, v.second.first}));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n        /*\n        rep(i, 2){\n            printf(\"\\n\");\n            rep(j, n){\n                printf(\"%.8f, %d\\n\", c[i][j], d[i][j]);\n            }\n            printf(\"\\n\");\n        }\n        */\n\n        rep(i, p){\n            int z;\n            scanf(\"%d\", &z);\n\n            if(d[0][z] + d[1][z] == d[0][n - 1]){\n                printf(\"%.8f\\n\", c[0][z] * c[1][z] / c[0][n - 1]);\n            }\n            else{\n                printf(\"%.8f\\n\", 0.0);\n            }\n        }\n\n\t\trep(i, n){\n\t\t\tg[i].clear();\n\t\t}\n        printf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += (dp[v] * cnt[e.to]) / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/*************************************************************************\nAuthor: zjut_polym\nCreated Time:   2012-8-11 16:25:37\nFile Name: H.cpp\n************************************************************************/\n#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <algorithm>\n#include <vector>\n#include <set>\n#include <map>\n#include <string>\n#include <climits>\n#include <queue>\nusing namespace std;\n#define ll long long\n#define NMAX 100005\n#define MOD 1000000007\nint dis[105][105],n,m,k;\nint w[105][105];\nvoid floyd(){\n\tfor(int i=0;i<n;i++){\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\tdis[j][k]=min(dis[j][k],dis[j][i]+dis[i][k]);\n\t\t\t\tdis[k][j]=dis[j][k];\n\t\t\t}\n\t\t}\n\t}\n}\nint vis[105];\nint num[105];\nstruct node{\n\tint dis,v;\n\tnode(int _v,int _dis):v(_v),dis(_dis){}\n\tnode(){}\n\tfriend bool operator < (node a,node b){\n\t\treturn a.dis > b.dis ;\n\t}\n};\nvoid spfa(int src){\n\tmemset(vis,0,sizeof(vis));\n\tmemset(num,0,sizeof(num));\n\tpriority_queue<node>Q;\n\tQ.push(node(src,0));\n\tnum[src]=1;\n\twhile(!Q.empty()){\n\t\tnode Node=Q.top();\n\t\tQ.pop();\n\t\tint u=Node.v;\n\t\tif(vis[u])\n\t\t   continue;\n\t\tvis[u]=1;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(i==u)\n\t\t\t\tcontinue;\n\t\t\tif(dis[0][u]+dis[i][n-1]+w[u][i]==dis[0][n-1]){\n\t\t\t\tnum[i]+=num[u];\n\t\t\t}\n\t\t\tQ.push(node(i,dis[0][u]+w[u][i]));\n\t\t}\n\t}\n}\nint main() {\n\tint u,v,W,val;\n\twhile(scanf(\"%d%d%d\",&n,&m,&k)&&(n||m||k)){\n\t\tmemset(dis,63,sizeof(dis));\t\t\n\t\tfor(int i=0;i<n;i++)\n\t\t\tdis[i][i]=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d%d%d\",&u,&v,&W);\n\t\t\tw[u][v]=w[v][u]=dis[u][v]=dis[v][u]=W;\n\t\t}\n\t\tfloyd();\n\t\tspfa(0);\n\t\twhile(k--){\n\t\t\tscanf(\"%d\",&val);\n\t\t\t//cout<<num[n-1]<<endl;\n\t\t\tprintf(\"%.9lf\\n\",num[val]*1.0/num[n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) dp[e.src][e.dst]=min(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tvi dist=dp[0];\n\t\t\n\t\tvector<__float128> ps(n,0); ps[n-1]=1;\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return dist[i]>dist[j];});\n\t\tfor(auto u:is){\n\t\t\tint cnt=0;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) cnt++;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) ps[e.dst]+=ps[e.src]/cnt;\n\t\t}\n\t\t\n\t\trep(i,s) printf(\"%.8f\\n\",(double)ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[1000] = {0};\n\tint cnt[1000] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 1000, 1e9 );\n\t\tfill( cnt, cnt + 1000, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t\tif(cnt[p.second]<0)return 1;\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\tassert(cost>0 && (d[u][v]==0 || d[u][v]==INF) && u!=v);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) dp[u][v]=1;\n\t\t}\n\t\trep(w,n) rep(u,n) rep(v,n) dp[u][v]+=dp[u][w]*dp[w][v];\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 99999999\n\nint n,m,p;\nint t[100][100],s[100][100],dag[100][100];\nint in[100],out[100];\ndouble dp[100];\n\ndouble countRoute(int id){\n\tif(id == n-1) return 1;\n\tif(dp[id] != -1) return dp[id];\n\tdouble res = 0.0;\n\n\trep(i,n) if(dag[id][i] > 0) {\n\t\tres += countRoute(i);\n\t}\n\treturn dp[id] = res;\n}\n\nint main(void){\n\twhile(cin>>n>>m>>p, n){\n\t\tmemset(t,0,sizeof(t));\n\t\trep(i,n) rep(j,n) s[i][j] = INF;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tt[a][b] = t[b][a] = s[a][b] = s[b][a] = c;\n\t\t}\n\n\t\t//ツδ渉ーツシツδδδ仰フツδ債イツド\n\t\trep(k,n) rep(i,n) rep(j,n) {\n\t\t\tif(i == j) s[i][j] = 0;\n\t\t\telse s[i][j] = min(s[i][j],s[i][k]+s[k][j]);\n\t\t}\n\n\t\t//DAGツ青カツ青ャ\n\t\tmemset(dag,0,sizeof(dag));\n\t\trep(i,n) rep(j,n) if(i != j && s[0][i] + t[i][j] + s[j][n-1] == s[0][n-1]) {\n\t\t\tdag[i][j] = s[i][j];\n\t\t}\n\n\t\t//ツ禿シツ篠淞青板づ出ツ篠淞青板づ個カツウツδ督ト\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(out,0,sizeof(out));\n\t\trep(i,n) rep(j,n) if(dag[i][j] > 0) out[i]++;\n\t\trep(j,n) rep(i,n) if(dag[i][j] > 0) in[j]++;\n\n\t\trep(i,n) dp[i] = -1;\n\t\tdouble routes = countRoute(0);\n\n\t\trep(i,p){\n\t\t\tint id;\n\t\t\tcin>>id;\n\t\t\tprintf(\"%.8lf\\n\",in[id]*out[id]/routes);\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost==d[0][v]) D[u].push_back(v);\n\t\t}\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\trep(u,n){\n\t\t\tbool vis[100]={}; vis[u]=true;\n\t\t\tdp[u][u]=1;\n\t\t\tqueue<int> Q; Q.push(u);\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint v=Q.front(); Q.pop();\n\t\t\t\trep(i,D[v].size()){\n\t\t\t\t\tint w=D[v][i];\n\t\t\t\t\tif(!vis[w]){\n\t\t\t\t\t\tvis[w]=true;\n\t\t\t\t\t\tQ.push(w);\n\t\t\t\t\t}\n\t\t\t\t\tdp[u][w]+=dp[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint dfs(vector<vector<Edge> >& edges, vector<int>& dist, vector<int>& check, int pos)\n{\n    int n = edges.size();\n    if(pos == n-1)\n        return check[n-1] = 1;\n\n    for(unsigned i=0; i<edges[pos].size(); ++i){\n        if(check[edges[pos][i].to] == 1)\n            check[pos] = 1;\n        else if(dist[edges[pos][i].to] == dist[pos] + edges[pos][i].cost)\n            check[pos] = dfs(edges, dist, check, edges[pos][i].to);\n    }\n\n    if(check[pos] == -1)\n        check[pos] = 0;\n    return check[pos];\n}\n\nvoid solve(vector<vector<Edge> >& edges, vector<double>& p)\n{\n    int n = edges.size();\n    vector<int> dist;\n    shortestPath(edges, 0, dist);\n    \n    vector<int> check(n, -1);\n    dfs(edges, dist, check, 0);\n\n    map<int, int> m;\n    m.insert(make_pair(0, 0));\n    p.resize(n, 0.0);\n    p[0] = 1.0;\n    while(!m.empty()){\n        int cost = m.begin()->first;\n        int pos = m.begin()->second;\n        double prob = p[pos];\n        m.erase(m.begin());\n        if(check[pos] == 0)\n            continue;\n        check[pos] = 0;\n\n        int num = 0;\n        for(unsigned i=0; i<edges[pos].size(); ++i){\n            int to = edges[pos][i].to;\n            if(check[to] == 1 && dist[to] == dist[pos] + edges[pos][i].cost){\n                ++ num;\n                m.insert(make_pair(dist[to], to));\n            }\n        }\n        for(unsigned i=0; i<edges[pos].size(); ++i){\n            int to = edges[pos][i].to;\n            if(check[to] == 1 && dist[to] == dist[pos] + edges[pos][i].cost){\n                p[to] += prob / num;\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            edges[a].push_back(Edge(b, c));\n        }\n\n        vector<double> prob;\n        solve(edges, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid chmin(int& a,int b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tset<pii> edges;\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tif(!edges.insert(mp(u,v)).second || !edges.insert(mp(v,u)).second) continue;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) chmin(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) chmin(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tvector<__float128> cnt1(n,0); cnt1[0]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]<dp[0][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[e.src][e.dst]+dp[e.dst][n-1]==dp[e.src][n-1]) cnt1[e.dst]+=cnt1[e.src];\n\t\tvector<__float128> cnt2(n,0); cnt2[n-1]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[n-1][i]<dp[n-1][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[e.src][e.dst]+dp[e.dst][0]==dp[e.src][0]) cnt2[e.dst]+=cnt2[e.src];\n\t\t\n\t\tassert(abs(double(cnt1[n-1]-cnt2[0]))<EPS);\n\t\tfor(auto i:cs) printf(\"%.9f\\n\",double(cnt1[i]*cnt2[i]/cnt1[n-1])); puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint done[110] = {};\nint dp[110] = {};\nint ok[110] = {};\n\nvector<NODE> g[100];\nint n,m,p;\n\nint dfs(int x,int cst){\n\tif( done[x] != cst ) return 0;\n\tif( x == n - 1 ) return ok[x] = 1;\n\tif( ok[x] != -1 ) return ok[x];\n\tint use = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tif( dfs(g[x][i].to,cst+g[x][i].cost) ){\n\t\t\tuse = 1;\n\t\t}\n\treturn ok[x] = use;\n}\nint main(){\n\twhile(cin >> n >> m >> p && (n||m||p) ){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a].push_back( NODE(b,c) );\n\t\t\tg[b].push_back( NODE(a,c) );\n\t\t}\n\t\tfor(int i = 0 ; i < 110 ; i++) done[i] = -1;\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\t\tok[i] = -1;\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to] != -1 ) continue;\n\t\t\telse done[q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t\tdfs(0,0);\n\t\tdouble dp2[110][110] = {};\n\t\tdouble res[100]={};\n\t\tdp2[0][0] = 1.0;\n\t\tfor(int i = 0 ; i <= n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tint C = 0;\n\t\t\t\tfor(int k = 0 ; k < g[j].size() ; k++){\n\t\t\t\t\tif( done[j] + g[j][k].cost == done[g[j][k].to] && ok[g[j][k].to] == 1 ){\n\t\t\t\t\t\tC++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < g[j].size() ; k++){\n\t\t\t\t\tif( done[j] + g[j][k].cost == done[g[j][k].to] && ok[g[j][k].to] == 1 ){\n\t\t\t\t\t\tdp2[i+1][g[j][k].to] += dp2[i][j] / C;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i <= n; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tres[j] += dp2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < p ; i++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.10lf\\n\",res[a]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == p.first) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];\n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n        \n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\tint d[100],dp[100];\n\t\trep(u,n){\n\t\t\td[u]=(u==0?0:INF);\n\t\t\tdp[u]=(u==0?1:0);\n\t\t}\n\t\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,0));\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\twhile(!Q.empty()){\n\t\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\t\tif(d[u]<d_now) continue;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\t\tif(d[v]>d[u]+cost){\n\t\t\t\t\td[v]=d[u]+cost;\n\t\t\t\t\tdp[v]=dp[u];\n\t\t\t\t\tQ.push(make_pair(-d[v],v));\n\n\t\t\t\t\tD[v].clear();\n\t\t\t\t\tD[v].push_back(u); // まずは辺の向きを逆にして保存しておいて、あとで直す\n\t\t\t\t}\n\t\t\t\telse if(d[v]==d[u]+cost){\n\t\t\t\t\tdp[v]+=dp[u];\n\t\t\t\t\tD[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint N=dp[n-1]; // 0 - n-1 間の最短経路の個数\n\n\t\tvector<int> tmp[100];\n\t\trep(u,n) tmp[u]=D[u], D[u].clear();\n\t\trep(u,n) rep(i,tmp[u].size()) D[tmp[u][i]].push_back(u);\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\n\t\t\tint dp2[100];\n\t\t\trep(u,n) dp2[u]=0;\n\t\t\tdp2[c]=1;\n\t\t\tqueue<int> Q; Q.push(c);\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint u=Q.front(); Q.pop();\n\t\t\t\trep(i,D[u].size()){\n\t\t\t\t\tint v=D[u][i];\n\t\t\t\t\tif(dp2[v]==0) Q.push(v);\n\t\t\t\t\tdp2[v]+=dp2[u];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%.9f\\n\",(double)dp[c]*dp2[n-1]/N);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\nusing ld = long double;\nconst ld eps = 1e-9;\nstruct aa {\n\tint now;\n\tint time;\n};\nstruct edge {\n\tint from;\n\tint to;\n\tint w;\n};\nclass Compare {\npublic:\n\tbool operator()(const aa&l, const aa&r) {\n\t\treturn l.time> r.time;\n\t}\n};\t//aa?????????????????¶\n\nvector<int>topo_sort(const vector<vector<int>>&edges) {\n\tint size_ = edges.size();\n\tvector<int>nums(size_);\n\tfor (const auto& es : edges) {\n\t\tfor (auto e : es) {\n\t\t\tnums[e]++;\n\t\t}\n\t}\n\tqueue<int>que;\n\tfor (int i = 0; i < size_; ++i) {\n\t\tif (!nums[i]) {\n\t\t\tque.push(i);\n\t\t}\n\t}\n\tvector<int>topo;\n\twhile (!que.empty()) {\n\t\tint ver(que.front());\n\t\ttopo.push_back(ver);\n\t\tque.pop();\n\t\tfor (auto e : edges[ver]) {\n\t\t\tnums[e]--;\n\t\t\tif (!nums[e])que.push(e);\n\t\t}\n\t}\n\tif (topo.size() == size_)return topo;\n\telse return vector<int>();\n}\n\nint main() {\n\twhile (1) {\n\t\tint N, M, P; cin >> N >> M >> P;\n\t\tif (!N)break;\n\t\tvector<vector<int>>edges(N),revedges(N);\n\t\t{\n\t\t\tvector<vector<edge>>dummyedges(N);\n\t\t\tfor (int i = 0; i < M; ++i) {\n\t\t\t\tint a, b, w; cin >> a >> b >> w;\n\t\t\t\tdummyedges[a].push_back(edge{ a,b,w });\n\t\t\t\tdummyedges[b].push_back(edge{ b,a,w });\n\t\t\t}\n\t\t\tvector<int>memo(N,1e9);\n\t\t\tvector<vector<edge>>tos(N);\n\t\t\tmemo[0] = 0;\n\t\t\tpriority_queue<aa, vector<aa>, Compare>que;\n\t\t\tque.push(aa{ 0,0 });\n\t\t\twhile (!que.empty()) {\n\t\t\t\taa atop(que.top());\n\t\t\t\tque.pop();\n\t\t\t\tfor (auto e : dummyedges[atop.now]) {\n\t\t\t\t\tconst int nexttime = atop.time + e.w;\n\t\t\t\t\tif (memo[e.to] > nexttime) {\n\t\t\t\t\t\tmemo[e.to] = nexttime;\n\t\t\t\t\t\ttos[e.to].clear();\n\t\t\t\t\t\ttos[e.to].push_back(e);\n\t\t\t\t\t\tque.push(aa{ e.to,nexttime });\n\t\t\t\t\t}\n\t\t\t\t\telse if (memo[e.to] == nexttime) {\n\t\t\t\t\t\ttos[e.to].push_back(e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (auto atos : tos) {\n\t\t\t\tfor (auto e:atos) {\n\t\t\t\t\tedges[e.from].push_back(e.to);\n\t\t\t\t\trevedges[e.to].push_back(e.from);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int>topo(topo_sort(edges));\n\t\tld total;\n\t\t{\n\t\t\tvector<ld>fs(N, 0);\n\t\t\tfs[0] = 1;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint from = topo[i];\n\t\t\t\tfor (auto to : edges[from]) {\n\t\t\t\t\tfs[to] += fs[from];\n\t\t\t\t}\n\t\t\t}\n\t\t\ttotal = fs[N - 1];\n\t\t}\n\t\t\n\t\t\n\t\twhile (P--) {\n\t\t\tint a; cin >> a;\n\t\t\tvector<ld>fs(N);\n\t\t\tfs[0] = 1;\n\t\t\tfor (int i = 0; i < N; ++i) {\n\t\t\t\tint from = topo[i];\n\t\t\t\tfor (auto to : edges[from]) {\n\t\t\t\t\tif (from == a || to == a)continue;\n\t\t\t\t\tfs[to] += fs[from];\n\t\t\t\t}\n\t\t\t}\n\t\t\tld ans = 1-fs[N - 1] / total;\n\t\t\tcout << fixed << setprecision(12) << ans << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nlong long dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<long long>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     long long tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nlong long dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<long long>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     long long tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<long long> num1(n, -1), num2(n, -1);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n, 0.0);\n    for(int i=0; i<n; ++i){\n        if(num1[i] != -1 && num2[i] != -1)\n            p[i] = 1.0 * num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = graph[b][a] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n\t    dfs(e.to,d);\n            dp[e.to] *= dp[v]*(1./cnt); \n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,0,sizeof(visited));\n\tfill(dp,dp+MAX,1);\n        dfs(n-1,d);\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.8f\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N, M, P;\n  bool first = true;\n  while(cin >> N >> M >> P && N){\n    if(first) first = false;\n    else cout << endl;\n    int d[100][100];\n    REP(i, N) REP(j, N) d[i][j] = i != j ? INF : 0;\n    int edge[100][100] = {};\n    memset(edge, -1, sizeof(edge));\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      d[a][b] = d[b][a] = c;\n      edge[a][b] = edge[b][a] = c;\n    }\n    vector<int> child(P);\n    REP(i, P) cin >> child[i];\n    REP(k, N) REP(i, N) REP(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    double k[100][100] = {}; // p[i] += k[i][j] * p[j]\n    REP(i, N){\n      vector<int> to;\n      REP(j, N) if(i != j) {\n        if(edge[i][j] != -1 && edge[i][j] + d[j][N - 1] == d[i][N - 1]){\n          // i -> j\n          to.push_back(j);\n        }\n      }\n      REP(l, to.size()){\n        k[to[l]][i] = 1.0 / to.size();\n      }\n    }\n    //REP(i, N) REP(j, N) printf(\"k[%d][%d] = %lf\\n\", i, j, k[i][j]);\n    double p[100];\n    REP(i, N) p[i] = 1.0;\n    REP(iter, 100000){\n      FOR(i, 1, N){\n        p[i] = 0;\n        REP(j, N) p[i] += k[i][j] * p[j];\n      }\n    }\n    REP(i, P) printf(\"%.12lf\\n\", p[child[i]]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid chmin(int& a,int b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) chmin(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) chmin(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvd cnt1(n,0); cnt1[0]=1;\n\t\t{\n\t\t\tGraph gg(n);\n\t\t\trep(i,n) for(auto e:g[i]) if(dp[0][e.src]+e.weight+dp[e.dst][n-1]==dp[0][n-1])\n\t\t\t\tgg[e.src].push_back(e);\n\t\t\tvi is(n); iota(all(is),0);\n\t\t\tsort(all(is),[&](int i,int j){return dp[0][i]<dp[0][j];});\n\t\t\tfor(auto u:is) for(auto e:gg[u]) cnt1[e.dst]+=cnt1[u];\n\t\t}\n\t\tvd cnt2(n,0); cnt2[n-1]=1;\n\t\t{\n\t\t\tGraph gg(n);\n\t\t\trep(i,n) for(auto e:g[i]) if(dp[0][e.src]+e.weight+dp[e.dst][n-1]==dp[0][n-1])\n\t\t\t\tgg[e.dst].emplace_back(e.dst,e.src,e.weight);\n\t\t\tvi is(n); iota(all(is),0);\n\t\t\tsort(all(is),[&](int i,int j){return dp[n-1][i]<dp[n-1][j];});\n\t\t\tfor(auto u:is) for(auto e:gg[u]) cnt2[e.dst]+=cnt2[u];\n\t\t}\n\t\t\n\t\tfor(auto i:cs) printf(\"%.9f\\n\",cnt1[i]*cnt2[i]/cnt1[n-1]); puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100];\nbool v[100],u[100];\ndouble togoal[100],prob[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28; d[0]=0;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(c==n-1)break;\n\t\t\tif(d[c]<-cc)continue;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,Q.push(mp(cc-i->second,i->first));\n\t\t}\n\t\t\n\t\trep(i,n)u[i]=v[i]=0;\n\t\trep(i,n)prob[i]=0,togoal[i]=0;\n\t\ttogoal[n-1]=1; v[n-1]=1;\n\t\tQ=priority_queue<pair<int,int> >(); Q.push(mp(d[n-1],n-1));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second; Q.pop();\n\t\t\tfr(i,e[c])if(d[i->first]+i->second==d[c]){\n\t\t\t\ttogoal[i->first]+=togoal[c];\n\t\t\t\tif(!v[i->first])v[i->first]=1,Q.push(mp(d[i->first],i->first));\n\t\t\t}\n\t\t}\n\t\tQ=priority_queue<pair<int,int> >(); Q.push(mp(0,0));\n\t\tprob[0]=1; u[0]=1;\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second; Q.pop();\n\t\t\tfr(i,e[c])if(v[i->first]&&d[i->first]==d[c]+i->second)\n\t\t\t{\n\t\t\t\tprob[i->first]+=prob[c]*togoal[i->first]/togoal[c];\n\t\t\t\tif(!u[i->first])u[i->first]=1,Q.push(mp(-d[i->first],i->first));\n\t\t\t}\n\t\t}\n\t\trep(i,p)printf(\"%.7f\\n\",prob[C[i]]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 30;\n\nint N, M, P;\nint v1[100], v2[100];\ndouble dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, int *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(10);\n\n  while(cin >> N >> M >> P, N) {\n    g.resize(N);\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n\n    g.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <cstring>\n#include <map>\nusing namespace std;\n\n#define rep(i,n) for(int i=0; i<n; ++i)\n\nconst int inf = 1<<29;\nint adj[101][101];\nint c_e[101],c_s[101];\nint d[101],p[101];\nint dist[101][101];\n\ntypedef pair<int, int> node;\n\nint main() {\n    int n,m,pk,f,t,ck;\n    while(cin>>n>>m>>pk, n|m|pk) {\n        rep(i,n) {\n            rep(j,n) adj[i][j] = dist[i][j] = inf,c_s[i] = c_e[i] = 0;\n            adj[i][i] = dist[i][i] = 0;\n        }\n\n        rep(i,m) {\n            cin>>f>>t>>ck;\n            adj[f][t] = adj[t][f] = dist[f][t] = dist[t][f] = ck;\n        }\n\n        rep(k,n) rep(i,n) rep(j,n)\n            dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);\n\n        priority_queue<node, vector<node>, greater<node> > q;\n        q.push(node(0,0));\n        memset(p, -1, sizeof(p));\n        memset(d, 0x3f, sizeof(d));\n\n        while(!q.empty()) {\n            int di = q.top().first;\n            int now = q.top().second;\n            q.pop();\n            if(p[now] != -1) continue;\n            p[now] = 0;\n            rep(i,n) {\n                if(adj[now][i] + di < d[i]) {\n                    d[i] = di + adj[now][i];\n                    q.push(node(d[i],i));\n                }\n            }\n        }\n\n        q.push(node(d[n-1], n-1));\n        c_e[n-1] = 1;\n        while(!q.empty()) {\n            int di = q.top().first;\n            int now = q.top().second;\n            q.pop();\n            rep(i,n) {\n                if(i != now && d[i] == di - adj[now][i]) {\n                    c_e[i] += c_e[now];\n                    q.push(node(d[i],i));\n                }\n            }\n        }\n\n        q.push(node(0,0));\n        c_s[0] = 1;\n        while(!q.empty()) {\n            int di = q.top().first;\n            int now = q.top().second;\n            q.pop();\n            rep(i,n) {\n                if(i != now && d[i] == adj[now][i] + di) {\n                    c_s[i] += c_s[now];\n                    q.push(node(d[i],i));\n                }\n            }\n        }\n\n\n        // rep(i,n) cout<<i<<\" , \"<<c_s[i]<<\" : \"<<c_e[i]<<endl;\n        int ci;\n        rep(i,pk) {\n            cin>>ci;\n            // cout<<dist[0][n-1]<<\" == \"<<dist[0][ci]<<\"+\"<<dist[ci][n-1]<<endl;\n            if(dist[0][ci] + dist[ci][n-1] != dist[0][n-1]) cout<<\"0.00000000\"<<endl;\n            else printf(\"%.8f\\n\",(double)(c_s[ci]*c_e[ci])/(double)c_s[n-1]);\n        }\n\n        printf(\"\\n\");\n\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<int>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nint dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<int>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<int> num1(n, -1), num2(n, -1);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n);\n    for(int i=0; i<n; ++i){\n        p[i] = 1.0 * num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint done[110] = {};\nlong long dp[110] = {} , rdp[110] = {};\n\nvector<NODE> g[100];\nint n,m,p;\n\nlong long dfs(int x,int cst){\n\tif( done[x] != cst ) return 0;\n\tif( x == n - 1 ) return 1;\n\tif( dp[x] != -1 ) return dp[x];\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tans += dfs(g[x][i].to,cst+g[x][i].cost);\n\treturn dp[x] = ans;\n}\n\nlong long rdfs(int x,int cst){\n\tif( done[n-1] - done[x] != cst ) return 0;\n\tif( x == 0 ) return 1;\n\tif( rdp[x] != -1 ) return rdp[x];\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tans += rdfs(g[x][i].to,cst+g[x][i].cost);\n\treturn rdp[x] = ans;\n}\nint main(){\n\twhile(cin >> n >> m >> p && (n||m||p) ){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a].push_back( NODE(b,c) );\n\t\t\tg[b].push_back( NODE(a,c) );\n\t\t}\n\t\tfor(int i = 0 ; i < 110 ; i++) done[i] = -1;\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\t\tdp[i] = rdp[i] = -1;\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to] != -1 ) continue;\n\t\t\telse done[q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t\tlong long all = dfs(0,0);\n\t\t//cout << all << endl;\n\t\tfor(int i = 0 ; i < p ; i++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif( done[a] == -1 ){\n\t\t\t\tprintf(\"%.8lf\\n\",0.0);\n\t\t\t}else{\n\t\t\t\tlong long A = dfs(a,done[a]);\n\t\t\t\tlong long B = rdfs(a,done[n-1] - done[a]);\n\t\t\t\tprintf(\"%.8lf\\n\",1.0 * A*B / all);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1058 Winter Bells\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nvoid visit(graph &g, vector<int> &order, vector<bool> &mark, int pos){\n\tfor(int i=0;i<g[pos].size();i++){\n\t\tint next = g[pos][i];\n\t\tif(mark[next]) continue;\n\t\tvisit(g, order, mark, next);\n\t}\n\tmark[pos] = true;\n\torder.push_back(pos);\n}\n\nvector<int> topologicalSort(graph &g){\n\tvector<int> res;\n\tvector<bool> mark(g.size(), false);\n\tfor(int i=0;i<g.size();i++){\n\t\tif(mark[i]) continue;\n\t\tvisit(g, res, mark, i);\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\nint main(){\n\tint n, m, r;\n\tint cost[100][100];\n\twhile(cin >> n >> m >> r, n){\n\t\tvector< vector< pair<int, int> > > g(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j] = i==j ? 0 : 100000000;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint p, q, c; cin >> p >> q >> c;\n\t\t\tcost[p][q] = cost[q][p] = c;\n\t\t\tg[p].push_back(make_pair(q,c));\n\t\t\tg[q].push_back(make_pair(p,c));\n\t\t}\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\tgraph h(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\t\tif(cost[i][n-1]==cost[g[i][j].first][n-1]+g[i][j].second){\n\t\t\t\t\th[i].push_back(g[i][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> ord = topologicalSort(h);\n\t\tvector<double> prob(n, 0.0);\n\t\tprob[0] = 1.0;\n\t\tfor(int i=0;i<ord.size();i++){\n\t\t\tfor(int j=0;j<h[ord[i]].size();j++)\n\t\t\t\tprob[h[ord[i]][j]] += (double)prob[ord[i]]/h[ord[i]].size();\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint t; cin >> t;\n\t\t\tprintf(\"%.8lf\\n\", prob[t]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N, M, P;\n  bool first = true;\n  while(cin >> N >> M >> P && N){\n    if(first) first = false;\n    else cout << endl;\n    int d[100][100];\n    REP(i, N) REP(j, N) d[i][j] = i != j ? INF : 0;\n    int edge[100][100] = {};\n    memset(edge, -1, sizeof(edge));\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      d[a][b] = d[b][a] = c;\n      edge[a][b] = edge[b][a] = c;\n    }\n    vector<int> child(P);\n    REP(i, P) cin >> child[i];\n    REP(k, N) REP(i, N) REP(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    double k[100][100] = {}; // p[i] += k[i][j] * p[j]\n    REP(i, N){\n      vector<int> to;\n      REP(j, N) if(i != j) {\n        if(edge[i][j] != -1 && edge[i][j] + d[j][N - 1] == d[i][N - 1]){\n          // i -> j\n          to.push_back(j);\n        }\n      }\n      REP(l, to.size()){\n        k[to[l]][i] = 1.0 / to.size();\n      }\n    }\n    //REP(i, N) REP(j, N) printf(\"k[%d][%d] = %lf\\n\", i, j, k[i][j]);\n    double p[100];\n    REP(i, N) p[i] = 1.0;\n    REP(iter, 50000){\n      FOR(i, 1, N){\n        p[i] = 0;\n        REP(j, N) p[i] += k[i][j] * p[j];\n      }\n    }\n    REP(i, P) printf(\"%.12lf\\n\", p[child[i]]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M, C;\n\ntypedef long long ll;\n\nstruct Edge {\n  int to; ll cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nvector<int> cs;\n\n//vector<vector<int> > prev_;\nint prev_[110][110];\nint pcnt[110];\ndouble ans[110];\n\nstruct state {\n  int curr; ll cost;\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nstruct ST {\n  int curr; double prob;\n};\n\nll const INF = 1LL<<40;\n\nint main() {\n  \n  while(cin >> N >> M >> C && (N|M|C)) {\n    g.clear(); g.resize(N);\n    cs.clear(); cs.resize(C);\n    rep(i, M) {\n      int a, b; ll c; cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c});\n      g[b].push_back((Edge){a, c});\n    }\n    rep(i, C) cin >> cs[i];\n    \n    ll dist[N];\n    fill(dist, dist+N, INF);\n    dist[0] = 0;\n    \n    rep(i, N) pcnt[i] = 0;\n    \n    priority_queue<state> pq;\n    pq.push((state){0, dist[0]});\n    while(!pq.empty()) {\n      int curr = pq.top().curr;\n      ll cost = pq.top().cost;\n      pq.pop();\n      \n      rep(i, g[curr].size()) {\n        Edge& e = g[curr][i];\n        if(dist[e.to] == cost+e.cost) {\n          prev_[e.to][pcnt[e.to]++] = curr;\n        }\n        if(dist[e.to] <= cost+e.cost) { continue; }\n        pcnt[e.to] = 0;\n        prev_[e.to][pcnt[e.to]++] = curr;\n        dist[e.to] = cost+e.cost;\n        pq.push((state){e.to, dist[e.to]});\n      }\n    }\n    \n    rep(i, N) ans[i] = 0.;\n    ans[N-1] = 1.;\n    for(int i=N-1; i>=1; i--) {\n      rep(j, pcnt[i]) {\n        int to = prev_[i][j];\n        ans[to] += ans[i] / pcnt[i];\n      }\n    }\n    \n    rep(i, C) {\n      printf(\"%.10f\\n\", ans[cs[i]]);\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <climits>\n#include <cstdlib>\n#include <functional>\n#include <iostream>\n#include <queue>\n#include <vector>\nusing namespace std;\n \nstruct edge {\n    int to, cost;\n    edge(int to_, int cost_):to(to_), cost(cost_) {}\n};\n \ntypedef pair<int, int> P;\n \nvector<int> dijkstra(int s, const vector<vector<edge>> &G) {\n    const int n = G.size();\n \n    vector<int> dist(n, INT_MAX);\n    priority_queue<P, vector<P>, greater<P>> que;\n    dist[s] = 0;\n    que.push({0, s});\n \n    while(!que.empty()) {\n        const int d = que.top().first;\n        const int v = que.top().second;\n        que.pop();\n \n        if(dist[v] < d) continue;\n \n        for(const auto &e : G[v]) {\n            const int next_dist = d + e.cost;\n            if(dist[e.to] > next_dist) {\n                dist[e.to] = next_dist;\n                que.push({next_dist, e.to});\n            }\n        }\n    }\n \n    return dist;\n}\n \nint main() {\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n    cout.precision(8);\n    cout.setf(ios::fixed);\n \n    for(int n, m, p; cin >> n >> m >> p && n;) {\n        vector<vector<edge>> G(n);\n        for(int i = 0; i < m; ++i) {\n            int a, b, cost;\n            cin >> a >> b >> cost;\n            G[a].emplace_back(b, cost);\n            G[b].emplace_back(a, cost);\n        }\n \n        const auto dist = dijkstra(n - 1, G);\n        vector<double> probability(n, 0.0);\n        priority_queue<P> que;\n        probability[0] = 1.0;\n \n        for(int i = 0; i < n; ++i) {\n            que.push({dist[i], i});\n        }\n \n        while(!que.empty()) {\n            const int d = que.top().first;\n            const int v = que.top().second;\n            que.pop();\n \n            vector<int> next_nodes;\n \n            for(const auto &e : G[v]) {\n                if(d - e.cost == dist[e.to]) {\n                    next_nodes.emplace_back(e.to);\n                }\n            }\n \n            for(const auto &u : next_nodes) {\n                probability[u] += probability[v] / next_nodes.size();\n            }\n        }\n \n        while(p--) {\n            int v;\n            cin >> v;\n            cout << probability[v] << endl;\n        }\n        cout << endl;\n    }\n \n    return EXIT_SUCCESS;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid chmin(int& a,int b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) chmin(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) chmin(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tvector<__float128> cnt1(n,0); cnt1[0]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]<dp[0][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[e.src][e.dst]+dp[e.dst][n-1]==dp[e.src][n-1]) cnt1[e.dst]+=cnt1[e.src];\n\t\tvector<__float128> cnt2(n,0); cnt2[n-1]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]>dp[0][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[0][e.dst]+dp[e.dst][e.src]==dp[0][e.src]) cnt2[e.dst]+=cnt2[e.src];\n\t\t\n\t\tfor(auto i:cs) printf(\"%.10f\\n\",double(cnt1[i]*cnt2[i]/cnt1[n-1])); puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int N=100;\nint main()\n{\n\tint n,m,p,x,y,w,i,j,k,dist[N][N],X=0x3f3f3f3f;\n\tint vertex[N];\n\tvector<int>edge[N];\n\twhile(scanf(\"%d%d%d\",&n,&m,&p),n)\n\t{\n\t\tmemset(dist,X,sizeof(dist));\n\t\tmemset(vertex,X,sizeof(vertex));\n\t\tfor(i=0;i<n;++i)edge[i].clear();\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\t\tdist[y][x]=dist[x][y]=w;\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> >q;\n\t\tq.push(P(0,0));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p(q.top());q.pop();\n\t\t\tif(vertex[p.second]<=p.first)continue;\n\t\t\tvertex[p.second]=p.first;\n\t\t\tfor(i=0;i<n;++i)if((w=dist[p.second][i])!=X)q.push(P(p.first+w,i));\n\t\t}\n\t\tbool flag[N]={};\n\t\tq.push(P(0,n-1));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p(q.top());q.pop();\n\t\t\tfor(i=0;i<n;++i)\n\t\t\t\tif(w=dist[i][p.second],vertex[i]+w==vertex[p.second])\n\t\t\t\t{\n\t\t\t\t\tedge[i].push_back(p.second);\n\t\t\t\t\tif(!flag[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(P(0,i));\n\t\t\t\t\t\tflag[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tdouble dp[N]={1};\n\t\tvector<P>v;\n\t\tfor(i=0;i<n;++i)v.push_back(P(vertex[i],i));\n\t\tsort(v.begin(),v.end());\n\t\tfor(i=0;i<v.size();++i)\n\t\t{\n\t\t\tj=v[i].second;\n\t\t\tfor(k=0;k<edge[j].size();++k)dp[edge[j][k]]+=dp[j]/edge[j].size();\n\t\t}\n\t\twhile(p--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%.9f\\n\",dp[x]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int INF=1000000000;\nint d[101][101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint n;\nint m;\nint p;\n\nstruct edge{\n    int to;\n    int cost;\n};\nvector<edge> G[101];\nll dp[101][101];\n//  éêðÊéÅZ[gÌæèûð¦ã°\nll dfs(int a,int b){\n    if(a==b)return 1;\n    else if(dp[a][b]!=-1)return dp[a][b];\n    ll res=0;\n    // ×ÖÚ®\n    for(int i=0;i<G[a].size();i++){\n        edge &e=G[a][i];\n        if(d[e.to][b]+e.cost==d[a][b]){\n            res+=dfs(e.to,b);\n        }\n    }\n    return dp[a][b]=res;\n}\nint main(){\n    while(cin>>n>>m>>p&&(n|m|p)){\n        for(int i=0;i<101;i++)G[i].clear();\n        for(int i=0;i<101;i++){\n            for(int j=0;j<101;j++){\n                if(i==j)d[i][j]==0;\n                else d[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;i++){\n            int a,b,ct;\n            cin>>a>>b>>ct;\n            edge e;\n            e.to=b;\n            e.cost=ct;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[b][a]=d[a][b]=ct;\n        }\n        warshall_floyd(n);\n        memset(dp,-1,sizeof(dp));\n        //dfs(0,n-1);\n        for(int i=0;i<p;i++){\n            int a;\n            cin>>a;\n            ll res=dfs(0,a)*dfs(a,n-1);\n            printf(\"%.10f\\n\",(double)res/(dfs(0,n-1)));\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//29\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint d[100][100];\n\nbool cmp(int a,int b){\n  return d[0][a]<d[0][b];\n}\n\nint main(){\n  for(int n,m,pp;cin>>n>>m>>pp,n|m|pp;){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\td[i][j]=(i==j)?0:1<<29;\n      }\n    }\n    int cn[100][100]={};\n    while(m--){\n      int s,t,w;\n      cin>>s>>t>>w;\n      d[s][t]=d[t][s]=w;\n      cn[s][t]=cn[t][s]=w;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    long double p[100]={1};\n    int o[100];\n    for(int i=0;i<n;i++){\n      o[i]=i;\n    }\n    sort(o,o+n,cmp);\n    for(int i=0;o[i]!=n-1;i++){\n      int nb=0;\n      for(int j=0;j<n;j++){\n\tnb+=o[i]!=j&&d[0][o[i]]+cn[o[i]][j]+d[j][n-1]==d[0][n-1];\n      }\n      for(int j=0;j<n;j++){\n\tif(o[i]!=j&&d[0][o[i]]+cn[o[i]][j]+d[j][n-1]==d[0][n-1]){\n\t  p[j]+=p[o[i]]/nb;\n\t}\n      }\n    }\n    while(pp--){\n      int c;\n      cin>>c;\n      cout<<fixed<<p[c]<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,k;cin>>n>>m>>k && n|m|k;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(k);\n\t\trep(i,k) cin>>cs[i];\n\t\t\n\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\t\tpq.emplace(-1,0,0);\n\t\tvi dist(n,INF);\n\t\tvvi prev(n);\n\t\twhile(pq.size()){\n\t\t\tEdge cur=pq.top(); pq.pop();\n\t\t\tif(dist[cur.dst]<cur.weight) continue;\n\t\t\tdist[cur.dst]=cur.weight;\n\t\t\tprev[cur.dst].push_back(cur.src);\n\t\t\tfor(auto e:g[cur.dst])\n\t\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t\t}\n\t\t\n\t\tvd ps(n,0);\n\t\tqueue<tuple<int,double>> q; q.emplace(n-1,1);\n\t\twhile(q.size()){\n\t\t\tint u; double p; tie(u,p)=q.front(); q.pop();\n\t\t\tif(u==-1) continue;\n\t\t\tps[u]+=p;\n\t\t\tfor(auto v:prev[u])\n\t\t\t\tq.emplace(v,p/prev[u].size());\n\t\t}\n\t\trep(i,k) printf(\"%.8f\\n\",ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\tint d[100],dp[100];\n\t\trep(u,n){\n\t\t\td[u]=(u==0?0:INF);\n\t\t\tdp[u]=(u==0?1:0);\n\t\t}\n\t\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,0));\n\t\tvector<int> D[100]; // 最短経路 DAG の辺の向きを逆転したもの\n\t\twhile(!Q.empty()){\n\t\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\t\tif(d[u]<d_now) continue;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\t\tif(d[v]>d[u]+cost){\n\t\t\t\t\td[v]=d[u]+cost;\n\t\t\t\t\tdp[v]=dp[u];\n\t\t\t\t\tQ.push(make_pair(-d[v],v));\n\n\t\t\t\t\tD[v].clear();\n\t\t\t\t\tD[v].push_back(u);\n\t\t\t\t}\n\t\t\t\telse if(d[v]==d[u]+cost){\n\t\t\t\t\tdp[v]+=dp[u];\n\t\t\t\t\tD[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool cl[100][100]={}; // 推移閉包\n\t\tcl[n-1][n-1]=true;\n\t\trep(u,n) rep(i,D[u].size()) {\n\t\t\tint v=D[u][i];\n\t\t\tcl[u][v]=true;\n\t\t}\n\t\trep(w,n) rep(u,n) rep(v,n) cl[u][v]|=cl[u][w]&cl[w][v];\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tif(cl[n-1][c]) printf(\"%.9f\\n\",(double)dp[c]/dp[n-1]);\n\t\t\telse           puts(\"0\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 110;\nconst int M = 1000010;\nconst int inf = 1000000000;\n\nstruct Edge\n{\n    int f, t, d;\n}e[M];\n\nint point[N], next[M], ne;\nint dis[2][N], q[N];\nbool u[N];\n\nvoid add_edge(int f, int t, int d)\n{\n    e[ne].f = f, e[ne].t = t, e[ne].d = d;\n    next[ne] = point[f], point[f] = ne++;\n}\n\nvoid spfa(int s, int n, int k)\n{\n    int i, tmp, f, r;\n    for(i = 0; i < n; ++i) {\n        dis[k][i] = inf;\n        u[i] = false;\n    }\n    dis[k][s] = 0;\n    u[s] = true;\n    f = 0, r = 1;\n    q[f] = s;\n    while(f != r) {\n        tmp = q[f];\n        f = (f + 1) % n;\n        u[tmp] = false;\n        for(i = point[tmp]; i != -1; i = next[i]) {\n            if(dis[k][e[i].t] > dis[k][tmp] + e[i].d) {\n                dis[k][e[i].t] = dis[k][tmp] + e[i].d;\n                if(!u[e[i].t]) {\n                    u[e[i].t] = true;\n                    q[r] = e[i].t;\n                    r = (r + 1) % n;\n                }\n            }\n        }\n    }\n}\n\nstruct Node\n{\n    int d, id;\n    long long cnt;\n    bool operator < (const Node &x) const {\n        return d < x.d;\n    }\n    double p;\n}qi[N];\n\nbool cmp(const Node &x, const Node &y)\n{\n    return x.id < y.id;\n}\n\nint qid[N];\nlong long cnt[N];\n\nvoid update(int s, int n)\n{\n    for(int i = 0; i < n; ++i)\n        qid[qi[i].id] = i;\n    qi[0].cnt = 1;\n    qi[0].p = 1.0;\n    for(int i = 0; i < n; ++i) {\n        int f = qi[i].id;\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                qi[qid[t]].cnt += qi[i].cnt;\n            if (qi[qid[t]].cnt < 0) while(1);\n        }\n    }\n    qi[0].cnt = qi[qid[n - 1]].cnt;\n\n    for(int k = 1; k < n; ++k) {\n        memset(cnt, 0, sizeof(cnt));\n        cnt[0] = 1;\n        for(int i = 0; i < n; ++i) {\n            if(i == k)  continue;\n            int f = qi[i].id;\n            for(int j = point[f]; j != -1; j = next[j]) {\n                int t = e[j].t;\n                if(!u[t])   continue;\n                if(dis[0][f] + e[j].d == dis[0][t])\n                    cnt[qid[t]] += cnt[i];\n            }\n        }\n        if(k != qid[n - 1])\n            qi[k].cnt = qi[qid[n - 1]].cnt - cnt[qid[n - 1]];\n    }/*\n    for(int i = 0; i < n; ++i) {\n        int tot = 0;\n        int f = qi[i].id;\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                ++tot;\n        }\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                qi[qid[t]].p += qi[i].p / tot;\n        }\n    }*/\n}\n\nint main()\n{\n    int i, n, m, p, a, b, d, iid;\n    while(scanf(\"%d%d%d\", &n, &m, &p) && n + m + p) {\n        ne = 0;\n        memset(point, -1, sizeof(point));\n        for(i = 0; i < m; ++i) {\n            scanf(\"%d%d%d\", &a, &b, &d);\n            add_edge(a, b, d);\n            add_edge(b, a, d);\n        }\n        spfa(0, n, 0);\n        spfa(n - 1, n, 1);\n        /*for(int j = 0; j < 2; ++j) {\n            printf(\"********\\n\");\n            for(i = 0; i < n; ++i) {\n                printf(\"%d: %d\\n\", i, dis[j][i]);\n            }\n        }*/\n        memset(u, false, sizeof(u));\n        for(i = 0; i < n; ++i) {\n            qi[i].d = dis[0][i];\n            qi[i].cnt = 0, qi[i].id = i;\n            qi[i].p = 0;\n            if(dis[0][i] + dis[1][i] == dis[0][n - 1])\n                u[i] = true;\n        }\n        sort(qi, qi + n);\n        update(0, n);\n        sort(qi, qi + n, cmp);\n        while(p--) {\n            scanf(\"%d\", &iid);\n            if(qi[n - 1].cnt == 0) {\n                printf(\"0.00000000\\n\");\n            }\n            else {\n                printf(\"%.8f\\n\", qi[iid].cnt * 1.0 / qi[n - 1].cnt);\n            }/*\n            if(qi[n - 1].p < 1e-8) {\n                printf(\"0.00000000\\n\");\n            }\n            else {\n                printf(\"%.14f\\n\", qi[iid].p);\n            }*/\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tdouble cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n \n#include<queue>\n#include<cstdio>\n \n#define rep(i,n) for(int i=0;i<(n);i++)\n \nusing namespace std;\n \nconst int INF=1<<29;\n \nclass edge{\npublic:\n    int v,cost;\n    edge(int v,int cost):v(v),cost(cost){}\n};\n \nint main(){\n    for(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n        vector<edge> G[100];\n        rep(_,m){\n            int u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n            G[u].push_back(edge(v,cost));\n            G[v].push_back(edge(u,cost));\n        }\n \n        int d[100],dp[100];\n        rep(u,n){\n            d[u]=(u==0?0:INF);\n            dp[u]=(u==0?1:0);\n        }\n        priority_queue< pair<int,int> > Q; Q.push(make_pair(0,0));\n        vector<int> D[100]; // 最短経路 DAG\n        while(!Q.empty()){\n            int d_now=-Q.top().first,u=Q.top().second; Q.pop();\n            if(d[u]<d_now) continue;\n \n            rep(i,G[u].size()){\n                int v=G[u][i].v,cost=G[u][i].cost;\n                if(d[v]>d[u]+cost){\n                    d[v]=d[u]+cost;\n                    dp[v]=dp[u];\n                    Q.push(make_pair(-d[v],v));\n \n                    D[v].clear();\n                    D[v].push_back(u); // まずは辺の向きを逆にして保存しておいて、あとで直す\n                }\n                else if(d[v]==d[u]+cost){\n                    dp[v]+=dp[u];\n                    D[v].push_back(u);\n                }\n            }\n        }\n        int N=dp[n-1]; // 0 - n-1 間の最短経路の個数\n \n        vector<int> tmp[100];\n        rep(u,n) tmp[u]=D[u], D[u].clear();\n        rep(u,n) rep(i,tmp[u].size()) D[tmp[u][i]].push_back(u);\n \n        rep(_,k){\n            int c; scanf(\"%d\",&c);\n\n\t\t\tbool vis[100]={}; vis[c]=true;\n            int dp2[100];\n            rep(u,n) dp2[u]=0;\n            dp2[c]=1;\n            queue<int> Q; Q.push(c);\n            while(!Q.empty()){\n                int u=Q.front(); Q.pop();\n                rep(i,D[u].size()){\n                    int v=D[u][i];\n                    if(!vis[v]) Q.push(v), vis[v]=true;\n                    dp2[v]+=dp2[u];\n                }\n            }\n \n            printf(\"%.9f\\n\",(double)dp[c]*dp2[n-1]/N);\n        }\n        puts(\"\");\n    }\n \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) dp[e.src][e.dst]=min(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi dist=dp[0];\n\t\t\n\t\tvd ps(n,0); ps[n-1]=1;\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return dist[i]>dist[j];});\n\t\tfor(auto u:is){\n\t\t\tint cnt=0;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) cnt++;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) ps[e.dst]+=ps[e.src]/cnt;\n\t\t}\n\t\t\n\t\trep(i,s) printf(\"%.8f\\n\",ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 99999999\n\nint n,m,p;\nint t[100][100],s[100][100],dag[100][100];\nint in[100],out[100];\ndouble dp[100];\n\ndouble countRoute(int id){\n\tif(id == n-1) return 1;\n\tif(dp[id] != -1) return dp[id];\n\tdouble res = 0.0;\n\n\trep(i,n) if(dag[id][i] > 0) {\n\t\tres += countRoute(i);\n\t}\n\treturn dp[id] = res;\n}\n\nint main(void){\n\twhile(cin>>n>>m>>p, n){\n\t\trep(i,n) rep(j,n) s[i][j] = INF;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tt[a][b] = t[b][a] = s[a][b] = s[b][a] = c;\n\t\t}\n\n\t\t//ツδ渉ーツシツδδδ仰フツδ債イツド\n\t\trep(k,n) rep(i,n) rep(j,n) {\n\t\t\tif(i == j) s[i][j] = 0;\n\t\t\telse s[i][j] = min(s[i][j],s[i][k]+s[k][j]);\n\t\t}\n\n\t\t//DAGツ青カツ青ャ\n\t\tmemset(dag,0,sizeof(dag));\n\t\trep(i,n) rep(j,n) if(i != j && s[0][i] + t[i][j] + s[j][n-1] == s[0][n-1]) {\n\t\t\tdag[i][j] = s[i][j];\n\t\t}\n\n\t\t//ツ禿シツ篠淞青板づ出ツ篠淞青板づ個カツウツδ督ト\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(out,0,sizeof(out));\n\t\trep(i,n) rep(j,n) if(dag[i][j] > 0) out[i]++;\n\t\trep(j,n) rep(i,n) if(dag[i][j] > 0) in[j]++;\n\n\t\trep(i,n) dp[i] = -1;\n\t\tdouble routes = countRoute(0);\n\n\t\trep(i,p){\n\t\t\tint id;\n\t\t\tcin>>id;\n\t\t\tprintf(\"%.8lf\\n\",routes==0?0:in[id]*out[id]/routes);\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vector<int> c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vector<int> d(n,1e9);\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<vi> dag(n);\n    vector<long double> cnt(n,0);\n    cnt[n-1] = 1;\n    vi vis(n,0);\n    queue<int> q;\n    q.push(n-1);\n\n    while(q.size()){\n      int v = q.front(); q.pop();\n      if(vis[v])continue;\n      vis[v] = 1;\n\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis){\n\t  cnt[u] += cnt[v];\n\t  dag[u].push_back(v);\n\t  if(vis[u]==0)q.push(u);\n\t}\n      }\n    }\n\n    vi deg(n,0), order;\n    for(int v=0;v<n;v++){\n      for(int u : dag[v])deg[u]++;\n    }\n    for(int v=0;v<n;v++){\n      if(deg[v]==0)q.push(v);\n    }\n\n    while(q.size()){\n      int v = q.front(); q.pop();\n      order.push_back(v);\n      for(int u : dag[v]){\n\tdeg[u]--;\n\tif(deg[u] == 0)q.push(u);\n      }\n    }\n\n    vector<long double> prob(n,0);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(int u : dag[v]){\n\tprob[u] += cnt[u] / cnt[v] * prob[v];\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vi c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vi d(n,1e9), order;\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n      order.push_back(v);\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<long double> cnt(n,0);\n    cnt[n-1] = 1;\n    for(int i=order.size()-1;i>=0;i--){\n      int v = order[i];\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis)cnt[u] += cnt[v];\n      }\n    }\n\n    vector<long double> prob(n,0);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(edge e : g[v]){\n\tint nxtd = d[v] + e.first, u = e.second;\n\tif(d[u] == nxtd){\n\t  prob[u] += cnt[u] / cnt[v] * prob[v];\n\t}\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// 20:47~\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,p;cin>>n>>m>>p && n|m|p;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\t\n\t\tvvi d(n,vi(n,INF));\n\t\trep(i,n) d[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) d[e.src][e.dst]=e.weight;\n\t\trep(k,n) rep(i,n) rep(j,n) d[i][j]=min(d[i][j],d[i][k]+d[k][j]);\n\t\t\n\t\tvvd cnt(n,vd(n));\n\t\trep(i,n) for(auto e:g[i])\n\t\t\tif(d[0][e.src]+e.weight+d[e.dst][n-1]==d[0][n-1])\n\t\t\t\tcnt[e.src][e.dst]=1;\n\t\trep(k,n) rep(i,n) rep(j,n)\n\t\t\tcnt[i][j]+=cnt[i][k]*cnt[k][j];\n\t\t\n\t\trep(_,p){\n\t\t\tint c; cin>>c;\n\t\t\tprintf(\"%.9f\\n\",cnt[0][c]*cnt[c][n-1]/cnt[0][n-1]);\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\tint d[100];\n\t\tdouble dp[100]; // dp[u] := ( 0->u 間の最短経路の個数 ) ( 大きくなるので double で )\n\t\trep(u,n){\n\t\t\td[u]=(u==0?0:INF);\n\t\t\tdp[u]=(u==0?1:0);\n\t\t}\n\t\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,0));\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\twhile(!Q.empty()){\n\t\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\t\tif(d[u]<d_now) continue;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\t\tif(d[v]>d[u]+cost){\n\t\t\t\t\td[v]=d[u]+cost;\n\t\t\t\t\tdp[v]=dp[u];\n\t\t\t\t\tQ.push(make_pair(-d[v],v));\n\n\t\t\t\t\tD[v].clear();\n\t\t\t\t\tD[v].push_back(u); // まずは辺の向きを逆にして保存しておいて、あとで直す\n\t\t\t\t}\n\t\t\t\telse if(d[v]==d[u]+cost){\n\t\t\t\t\tdp[v]+=dp[u];\n\t\t\t\t\tD[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble N=dp[n-1];\n\n\t\tvector<int> tmp[100];\n\t\trep(u,n) tmp[u]=D[u], D[u].clear();\n\t\trep(u,n) rep(i,tmp[u].size()) D[tmp[u][i]].push_back(u);\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\n\t\t\tdouble dp2[100]; // dp2[u] := ( c->u 間の最短経路の個数 )\n\t\t\trep(u,n) dp2[u]=(u==c?1:0);\n\t\t\tqueue<int> Q; Q.push(c);\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint u=Q.front(); Q.pop();\n\t\t\t\trep(i,D[u].size()){\n\t\t\t\t\tint v=D[u][i];\n\t\t\t\t\tif(dp2[v]==0) Q.push(v);\n\t\t\t\t\tdp2[v]+=dp2[u];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%.9f\\n\",dp[c]*dp2[n-1]/N);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t\t\n\t\t\t\t\tif( cnt[p.second] < 0 )return 1;\n\t\t\t\t\tif(!cnt[it->second])while(1);\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define INF (1<<28)\n#define MAX 105\nstruct edge{int to,cost;};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n \nvector<edge> G[MAX];\nint n,m,p;\n \nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n  }\n}\n \nlong long d[MAX][MAX];\ndouble cnt[MAX][MAX];\nvoid dijkstra(int si){\n  for(int i=0;i<MAX;i++)d[si][i]=INF,cnt[si][i]=0;\n  priority_queue<state> Q;\n  d[si][si]=0;\n  cnt[si][si]=1;\n  Q.push((state){si,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[si][s.pos])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(d[si][e.to]<s.cost+e.cost)continue;\n      else if(d[si][e.to]==s.cost+e.cost){\n    cnt[si][e.to]+=cnt[si][s.pos];\n      }else{\n    cnt[si][e.to]=cnt[si][s.pos];\n    d[si][e.to]=s.cost+e.cost;\n    Q.push((state){e.to,d[si][e.to]});\n      }\n    }\n  }\n}\n \nint main(){\n  while(1){\n    cin>>n>>m>>p;\n    if(n==0&&m==0&&p==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    for(int i=0;i<n;i++)\n      dijkstra(i);\n \n    for(int i=0;i<p;i++){\n      int a;\n      scanf(\"%d\",&a);\n      if(d[0][a]+d[a][n-1]!=d[0][n-1]){\n    cout<<\"0.0\"<<endl;\n      }else{\n    double x=cnt[0][a],x2=cnt[a][n-1],y=cnt[0][n-1];\n    printf(\"%.8f\\n\",x/y*x2);\n      }\n \n \n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<vector<bool> > pass(n, vector<bool>(n, false));\n    queue<int> q;\n    q.push(n-1);\n    vector<bool> check(n, false);\n    while(!q.empty()){\n        int pos = q.front();\n        q.pop();\n\n        for(int i=0; i<n; ++i){\n            if(graph[i][pos] != -1 && dist[i] + graph[i][pos] == dist[pos]){\n                if(!check[i]){\n                    q.push(i);\n                    check[i] = true;\n                    pass[i][pos] = true;\n                }\n            }\n        }\n    }\n\n    multimap<int, int> m;\n    m.insert(make_pair(0, 0));\n    p.resize(n, 0.0);\n    p[0] = 1.0;\n    check.assign(n, false);\n    while(!m.empty()){\n        int cost = m.begin()->first;\n        int pos = m.begin()->second;\n        double prob = p[pos];\n        m.erase(m.begin());\n        if(check[pos])\n            continue;\n        check[pos] = true;\n\n        int num = 0;\n        for(int i=0; i<n; ++i){\n            if(pass[pos][i]){\n                ++ num;\n                m.insert(make_pair(dist[i], i));\n            }\n        }\n        for(int i=0; i<n; ++i){\n            if(pass[pos][i]){\n                p[i] += prob / num;\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct route{\n\tint w;\n\tbitset<100> b;\n\n\troute(int w_, int p_, const bitset<100> &b_):\n\t\tw(w_), b(b_)\n\t{\n\t\tb.set(p_);\n\t}\n\t\n\tbool operator() (route &r1, route &r2){\n\t\treturn r1.w > r2.w;\n\t}\n} first( 0, 0, bitset<100>() );\n\nint main(){\n\tint n, m, p, a, b, w;\n\tvector<route>::iterator it1;\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<route> > rts(n);\n\t\trts[0].push_back( first );\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\t\t\tif( p.first == rts[p.second].front().w ){\n\t\t\t\trts[p.second].front().w = -1;\n\t\t\t\tvector<route> &rt = rts[p.second];\n\t\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\t\tfor( it1 = rt.begin(); it1 != rt.end(); ++it1 ){\n\t\t\t\t\tvector<pii>::iterator it2;\n\t\t\t\t\tfor( it2 = wt.begin(); it2 != wt.end(); ++it2 ){\n\t\t\t\t\t\tw = p.first + it2->second;\n\t\t\t\t\t\tif(\n\t\t\t\t\t\t\trts[it2->first].empty() ||\n\t\t\t\t\t\t\trts[it2->first].front().w > w\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\trts[it2->first].clear();\n\t\t\t\t\t\t\trts[it2->first].push_back(\n\t\t\t\t\t\t\t\troute( w, it2->first, it1->b )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif( it2->first != n - 1 ){\n\t\t\t\t\t\t\t\tqu.push( pii( w, it2->first ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( rts[it2->first].front().w == w ){\n\t\t\t\t\t\t\trts[it2->first].push_back(\n\t\t\t\t\t\t\t\troute( w, it2->first, it1->b )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tdouble ans[100] = {0.0};\n\t\tdouble x = 1.0 / rts[n-1].size();\n\t\tfor( it1 = rts[n-1].begin(); it1 != rts[n-1].end(); ++it1 ){\n\t\t\tfor( int i = 0; i < n; i++ ){\n\t\t\t\tif( it1->b[i] ){\n\t\t\t\t\tans[i] += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%f\\n\", ans[a] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 110;\nconst int M = 1000010;\nconst int inf = 1000000000;\n\nstruct Edge\n{\n    int f, t, d;\n}e[M];\n\nint point[N], next[M], ne;\nint dis[2][N], q[N];\nbool u[N];\n\nvoid add_edge(int f, int t, int d)\n{\n    e[ne].f = f, e[ne].t = t, e[ne].d = d;\n    next[ne] = point[f], point[f] = ne++;\n}\n\nvoid spfa(int s, int n, int k)\n{\n    int i, tmp, f, r;\n    for(i = 0; i < n; ++i) {\n        dis[k][i] = inf;\n        u[i] = false;\n    }\n    dis[k][s] = 0;\n    u[s] = true;\n    f = 0, r = 1;\n    q[f] = s;\n    while(f != r) {\n        tmp = q[f];\n        f = (f + 1) % n;\n        u[tmp] = false;\n        for(i = point[tmp]; i != -1; i = next[i]) {\n            if(dis[k][e[i].t] > dis[k][tmp] + e[i].d) {\n                dis[k][e[i].t] = dis[k][tmp] + e[i].d;\n                if(!u[e[i].t]) {\n                    u[e[i].t] = true;\n                    q[r] = e[i].t;\n                    r = (r + 1) % n;\n                }\n            }\n        }\n    }\n}\n\nstruct Node\n{\n    int d, id;\n    double cnt;\n    bool operator < (const Node &x) const {\n        return d < x.d;\n    }\n}qi[N];\n\nbool cmp(const Node &x, const Node &y)\n{\n    return x.id < y.id;\n}\n\nint qid[N];\ndouble cnt[N];\n\nvoid update(int s, int n)\n{\n    for(int i = 0; i < n; ++i)\n        qid[qi[i].id] = i;\n    qi[0].cnt = 1;\n    for(int i = 0; i < n; ++i) {\n        int f = qi[i].id;\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                qi[qid[t]].cnt += qi[i].cnt;\n        }\n    }\n    qi[0].cnt = qi[qid[n - 1]].cnt;\n\n    for(int k = 1; k < n; ++k) {\n        memset(cnt, 0, sizeof(cnt));\n        cnt[0] = 1;\n        for(int i = 0; i < n; ++i) {\n            if(i == k)  continue;\n            int f = qi[i].id;\n            for(int j = point[f]; j != -1; j = next[j]) {\n                int t = e[j].t;\n                if(!u[t])   continue;\n                if(dis[0][f] + e[j].d == dis[0][t])\n                    cnt[qid[t]] += cnt[i];\n            }\n        }\n        if(k != qid[n - 1])\n            qi[k].cnt = qi[qid[n - 1]].cnt - cnt[qid[n - 1]];\n    }\n}\n\nint main()\n{\n    int i, n, m, p, a, b, d, iid;\n    while(scanf(\"%d%d%d\", &n, &m, &p) && n + m + p) {\n        ne = 0;\n        memset(point, -1, sizeof(point));\n        for(i = 0; i < m; ++i) {\n            scanf(\"%d%d%d\", &a, &b, &d);\n            add_edge(a, b, d);\n            add_edge(b, a, d);\n        }\n        spfa(0, n, 0);\n        spfa(n - 1, n, 1);\n        /*for(int j = 0; j < 2; ++j) {\n            printf(\"********\\n\");\n            for(i = 0; i < n; ++i) {\n                printf(\"%d: %d\\n\", i, dis[j][i]);\n            }\n        }*/\n        memset(u, false, sizeof(u));\n        for(i = 0; i < n; ++i) {\n            qi[i].d = dis[0][i];\n            qi[i].cnt = 0, qi[i].id = i;\n            if(dis[0][i] + dis[1][i] == dis[0][n - 1])\n                u[i] = true;\n        }\n        sort(qi, qi + n);\n        update(0, n);\n        sort(qi, qi + n, cmp);\n        while(p--) {\n            scanf(\"%d\", &iid);\n            if(qi[n - 1].cnt == 0) {\n                printf(\"0.00000000\\n\");\n            }\n            else {\n                printf(\"%.14f\\n\", qi[iid].cnt * 1.0 / qi[n - 1].cnt);\n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int double//long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = DBL_MAX/3;//1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost, routes;\n\nint dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0; routes[s][s] = 1;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(cost + e.cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = cost + e.cost;\n\troutes[s][e.to] = routes[s][now];\n\tque.push(P(mincost[s][e.to], e.to));\n      } else if(cost + e.cost == mincost[s][e.to]) {\n\troutes[s][e.to] += routes[s][now];\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m, p;\n  while(cin >> n >> m >> p, n) {\n    graph.clear(); graph.resize(n);\n    while(m--) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      graph[a].push_back(edge(b, c));\n      graph[b].push_back(edge(a, c));\n    }\n    mincost.clear(); mincost.resize(n, vector<int>(n, inf));\n    routes.clear(); routes.resize(n, vector<int>(n, 0));\n    rep(i, n) dijkstra(i);\n    while(p--) {\n      int c; cin >> c;\n      if(mincost[0][c] + mincost[c][n-1] == mincost[0][n-1]) {\n\tcout << (double)routes[0][c]*routes[c][n-1] / routes[0][n-1] << endl;\n      } else {\n\tcout << 0 << endl;\n      }\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            dfs(e.to,d);\n            dp[e.to] *= dp[v]*(1./cnt); \n        }\n    }\n}\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,0,sizeof(visited));\n        fill(dp,dp+MAX,1);\n        dfs(n-1,d);\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.15f\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int INF=1000000000;\nint d[101][101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint n;\nint m;\nint p;\n\nstruct edge{\n    int to;\n    int cost;\n};\nvector<edge> G[101];\nll dp[101][101];\n//  éæÔðÊéÅZ[gÌæèûð¦ã°\nll dfs(int a,int b){\n    if(a==b)return 1;\n    else if(dp[a][b]!=-1)return dp[a][b];\n    ll res=0;\n    // ×ÖÚ®\n    for(int i=0;i<G[a].size();i++){\n        edge &e=G[a][i];\n        if(d[e.to][b]+e.cost==d[a][b]){\n            res+=dfs(e.to,b);\n        }\n    }\n    return dp[a][b]=res;\n}\nint main(){\n    while(cin>>n>>m>>p&&(n|m|p)){\n        for(int i=0;i<101;i++)G[i].clear();\n        for(int i=0;i<101;i++){\n            for(int j=0;j<101;j++){\n                if(i==j)d[i][j]==0;\n                else d[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;i++){\n            int a,b,ct;\n            cin>>a>>b>>ct;\n            edge e;\n            e.to=b;\n            e.cost=ct;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[b][a]=d[a][b]=ct;\n        }\n        warshall_floyd(n);\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dp[i][j]=-1;\n        //memset(dp,-1,sizeof(dp));\n        for(int i=0;i<p;i++){\n            int a;\n            cin>>a;\n            ll res=dfs(0,a)*dfs(a,n-1);\n            if(d[0][a]+d[a][n-1]!=d[0][n-1])res=0;\n            printf(\"%.10f\\n\",(double)res/(dfs(0,n-1)));\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1058 Winter Bells\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nvoid visit(graph &g, vector<int> &order, vector<bool> &mark, int pos){\n\tfor(int i=0;i<g[pos].size();i++){\n\t\tint next = g[pos][i];\n\t\tif(mark[next]) continue;\n\t\tvisit(g, order, mark, next);\n\t}\n\tmark[pos] = true;\n\torder.push_back(pos);\n}\n\nvector<int> topologicalSort(graph &g){\n\tvector<int> res;\n\tvector<bool> mark(g.size(), false);\n\tfor(int i=0;i<g.size();i++){\n\t\tif(mark[i]) continue;\n\t\tvisit(g, res, mark, i);\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\nint main(){\n\tint n, m, r;\n\tint cost[100][100];\n\twhile(cin >> n >> m >> r, n){\n\t\tvector< vector< pair<int, int> > > g(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j] = i==j ? 0 : 100000000;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint p, q, c; cin >> p >> q >> c;\n\t\t\tcost[p][q] = cost[q][p] = c;\n\t\t\tg[p].push_back(make_pair(q,c));\n\t\t\tg[q].push_back(make_pair(p,c));\n\t\t}\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\tgraph h(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(cost[0][i]+cost[i][n-1]!=cost[0][n-1]) continue;\n\t\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\t\tif(cost[i][n-1]==cost[g[i][j].first][n-1]+g[i][j].second){\n\t\t\t\t\th[i].push_back(g[i][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> ord = topologicalSort(h);\n\t\tvector<double> prob(n, 0.0);\n\t\tprob[0] = 1.0;\n\t\tfor(int i=0;i<ord.size();i++){\n\t\t\tfor(int j=0;j<h[ord[i]].size();j++)\n\t\t\t\tprob[h[ord[i]][j]] += (double)prob[ord[i]]/h[ord[i]].size();\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint t; cin >> t;\n\t\t\tprintf(\"%.8lf\\n\", prob[t]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            dfs(e.to,d);\n            dp[e.to] *= dp[v]*(1./cnt); \n        }\n    }\n}\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,0,sizeof(visited));\n        fill(dp,dp+MAX,1);\n        dfs(n-1,d);\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.8f\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 99999999\n\nint n,m,p;\nint t[100][100],s[100][100],dag[100][100];\nint in[100],out[100];\ndouble dp[100];\n\ndouble countRoute(int id){\n\tif(id == n-1) return 1;\n\tif(dp[id] != -1) return dp[id];\n\tdouble res = 0.0;\n\n\trep(i,n) if(dag[id][i] > 0) {\n\t\tres += countRoute(i);\n\t}\n\treturn dp[id] = res;\n}\n\nint main(void){\n\twhile(cin>>n>>m>>p, n){\n\t\tmemset(t,0,sizeof(t));\n\t\trep(i,n) rep(j,n) s[i][j] = INF;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tt[a][b] = t[b][a] = s[a][b] = s[b][a] = c;\n\t\t}\n\n\t\t//ツδ渉ーツシツδδδ仰フツδ債イツド\n\t\trep(k,n) rep(i,n) rep(j,n) {\n\t\t\tif(i == j) s[i][j] = 0;\n\t\t\telse s[i][j] = min(s[i][j],s[i][k]+s[k][j]);\n\t\t}\n\n\t\t//DAGツ青カツ青ャ\n\t\tmemset(dag,0,sizeof(dag));\n\t\trep(i,n) rep(j,n) if(i != j && s[0][i] + t[i][j] + s[j][n-1] == s[0][n-1]) {\n\t\t\tdag[i][j] = s[i][j];\n\t\t}\n\n\t\t//ツ禿シツ篠淞青板づ出ツ篠淞青板づ個カツウツδ督ト\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(out,0,sizeof(out));\n\t\trep(i,n) rep(j,n) if(dag[i][j] > 0) out[i]++;\n\t\trep(j,n) rep(i,n) if(dag[i][j] > 0) in[j]++;\n\n\t\trep(i,n) dp[i] = -1;\n\t\tdouble routes = 1.0;//countRoute(0);\n\n\t\trep(i,p){\n\t\t\tint id;\n\t\t\tcin>>id;\n\t\t\tprintf(\"%.8lf\\n\",in[id]*out[id]/routes);\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <queue>\n\n#define rep(i, n) for(int i = 0; i < n; ++i)\n\nusing namespace std;\n\ntypedef pair<int, pair<int, int>> P;\n\nstruct E{\n\tint t, c;\n};\n\nint n, m, p;\nvector<E> g[100];\nint d[100];\ndouble c[100];\n\nint main(){\n\tbool f = false;\n\twhile(1){\n\t\tscanf(\"%d%d%d\", &n, &m, &p);\n\t\tif(n == 0 && m == 0 && p ==0){\n\t\t\tbreak;\n\t\t}\n\n\t\tif(f){\n\t\t\tprintf(\"\\n\");\n\t\t}\n\t\telse{\n\t\t\tf = true;\n\t\t}\n\n\t\trep(i, m){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d%d%d\", &a, &b, &c);\n\t\t\tg[a].push_back(E{b, c});\n\t\t\tg[b].push_back(E{a, c});\n\t\t}\n\n\t\tfill(d, d + n, 2e8);\n\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\td[0] = 0;\n\t\tq.push(P(0, {0, -1}));\n\t\twhile(!q.empty()){\n\t\t\tP v = q.top();\n\t\t\tq.pop();\n\t\t\tif(v.first > d[v.second.first]){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbool f = c[v.second.first] != 0;\n\t\t\tc[v.second.first] += v.second.second != -1 ? c[v.second.second] : 1;\n\t\t\tif(f){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tfor(auto& x: g[v.second.first]){\n\t\t\t\tif(d[x.t] >= d[v.second.first] + x.c){\n\t\t\t\t\td[x.t] = d[v.second.first] + x.c;\n\t\t\t\t\tq.push(P(d[x.t], {x.t, v.second.first}));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tc[0] = c[n - 1];\n\n\t\t/*\n\t\t\tprintf(\"\\n\");\n\t\t\trep(i, n){\n\t\t\t\tprintf(\"%.8f\\n\", c[i]);\n\t\t\t}\n\t\t\tprintf(\"\\n\");\n\t\t*/\n\n\t\trep(i, p){\n\t\t\tint z;\n\t\t\tscanf(\"%d\", &z);\n\t\t\tprintf(\"%.8f\\n\", c[z] / c[n - 1]);\n\t\t}\n\n\t\trep(i, n){\n\t\t\tg[i].clear();\n\t\t}\n\t\tfill(c, c + n, 0);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<queue>\n\nusing namespace std;\nconst int infty = 1<<28;\n\nstruct Node{\n  vector<int> con;\n  vector<int> in;\n  vector<int> cost;\n};\n\ntypedef vector<Node> Graph;\n\ndouble topologicalSort(const Graph &G, int n, int s, int g)\n{\n  double numPath[n];\n  int invis[n];\n  queue<int> q;\n  for(int i = 0; i < n; ++i){\n    invis[i] = 0;\n    numPath[i] = 0.0;\n  }\n  numPath[s]=1.0;\n  \n  q.push(s);\n  while(!q.empty()){\n    int now = q.front();\n    q.pop();\n    \n    for(int i = 0; i < G[now].con.size(); ++i){\n      int nid = G[now].con[i];\n      invis[nid]++;\n      numPath[nid] += numPath[now];\n      if( invis[nid] == G[nid].in.size() ){\n\tq.push( nid );\n      }\n    }\n  }\n  \n  return numPath[g];\n}\n\nint main()\n{\n  while(true){\n    int n,m,p;\n    cin >> n >> m >> p;\n    if( n == 0 && m == 0 && p == 0 ) break;\n    int c[p];\n    double cPath[n];\n    Graph G(n);\n    Graph DAG(n);\n    int d[n][n];\n    \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tif( i == j ) d[i][j] = 0;\n\telse d[i][j] = infty;\n      }\n    }\n\n    for(int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      G[a].con.push_back(b);\n      G[a].cost.push_back(c);\n      G[b].con.push_back(a);\n      G[b].cost.push_back(c);\n      d[a][b]=min(d[a][b],c);\n      d[b][a]=min(d[b][a],c);\n    }\n    for(int i = 0; i < p; ++i){\n      cin >> c[i];\n    }\n    \n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n\tfor(int j = 0; j < n; ++j){\n\t  d[i][j] = min( d[i][j], d[i][k]+d[k][j] );\n\t}\n      }\n    }\n    \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < G[i].con.size(); ++j){\n\tint u = i;\n\tint v = G[i].con[j];\n\tint w = G[i].cost[j];\n\tif( d[0][u]+w+d[v][n-1] == d[0][n-1] ){\n\t  DAG[u].con.push_back(v);\n\t  DAG[v].in.push_back(u);\n\t}\n      }\n    }\n\n    double sgPath = topologicalSort( DAG, n, 0, n-1 );\n    for(int i = 0; i < p; ++i){\n      cPath[i] = topologicalSort( DAG, n, 0, c[i] );\n      cPath[i] *= topologicalSort( DAG, n, c[i], n-1 );\n      //cout << cPath[i] << ' ' << sgPath << endl;\n      printf(\"%.12lf\\n\", cPath[i]/sgPath );\n    }\n    putchar('\\n');\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\n\t\t\t\t\tif(!cnt[it->second])while(1);\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cassert>\n#include<algorithm>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++ )\n#define MAX 100\n#define INFTY (1<<21)\n\nvoid dijkstra( int n, int G[MAX][MAX],  vector<int> p[MAX] ){\n  int d[MAX];\n  bool visited[MAX];\n\n  rep(i, n) p[i].clear();\n\n  rep(i, n){\n    d[i] = INFTY;\n    visited[i] = false;\n  }\n\n  d[0] = 0;\n\n  int cnt = 0;\n  while(1){\n    int minv = INFTY;\n    int u = -1;\n    rep(i, n){\n      if ( !visited[i] && minv > d[i] ) {\n\tu = i;\n\tminv = d[i];\n      }\n    }\n    if ( u == -1 ) break;\n    visited[u] = true;\n    cnt++;\n\n    rep(v, n){\n      if ( !visited[v] && G[u][v] != INFTY ){\n\tint cost = d[u] + G[u][v];\n\tif ( cost == d[v] ){\n\t  p[v].push_back(u);\n\t} else if ( cost < d[v] ){\n\t  p[v].clear();\n\t  p[v].push_back(u);\n\t  d[v] = cost;\n\t}\n      }\n    }\n  }\n\n  assert( cnt == n );\n}\n\nvoid tsort( int n, int u, bool T[MAX][MAX], vector<int> &order, bool visited[MAX], vector<int> p[MAX] ){\n  visited[u] = true;\n  rep(v, n) if ( T[u][v] && !visited[v]) tsort(n, v, T, order, visited, p);\n\n  if ( u == 0 || u == n-1 || p[u].size() > 0 ){\n    order.push_back(u);\n  }\n}\n\nvoid parse( int n, int u, vector<int> p[MAX], bool inpath[MAX]){\n  inpath[u] = true;\n  for ( int i = 0; i < p[u].size(); i++ ){\n    int v = p[u][i];\n       if ( !inpath[v] )parse(n, v, p, inpath);\n       // parse(n, v, p, inpath);\n  }\n}\n\nvoid makeTree(int n, bool T[MAX][MAX], vector<int> p[MAX], int q){\n  bool inpath[MAX];\n  rep(i, n) inpath[i] = false;\n  parse(n, n-1, p, inpath);\n\n  rep(i, n) rep(j, n) T[i][j] = false;\n  rep(v, n){\n    rep(i, p[v].size()){\n      int u = p[v][i];\n      if ( inpath[u] && inpath[v] ) T[u][v] = true;\n    }\n  }\n\n  vector<int> order;\n  bool visited[MAX]; \n\n  rep(i, n) visited[i] = false;\n  order.clear();\n  tsort(n, 0, T, order, visited, p);\n  reverse(order.begin(), order.end());\n\n  double forward[MAX], back[MAX];\n  rep(i, n) forward[i] = back[i] = 0.0;\n\n  //rep(i,n) cout << order[i] << \" \";\n  //cout << endl;\n\n  assert( order[0] == 0 );\n  assert( order[order.size()-1] == n-1 );\n  forward[order[0]] = 1;\n  for ( int i = 0; i < order.size(); i++ ){\n    int u = order[i];\n    rep(v, n){\n      if ( T[u][v] ) forward[v] += forward[u];\n    }\n  }\n  for ( int i = 0; i < n; i++ ){\n    if ( 0 == i ) continue;\n    forward[i] /= forward[n-1];\n  }\n  \n  rep(i, n) visited[i] = false;\n  order.clear();\n  // Tt\n  bool tmp[MAX][MAX];\n  /*\n rep(i, n){\n    rep(j, n) cout << T[i][j] << \" \";\n    cout << endl;\n    }*/\n  rep(i, n) rep(j, n) tmp[j][i] = T[i][j];\n  rep(i, n) rep(j, n) T[i][j] = tmp[i][j];\n\n  /*\n  rep(i, n){\n    rep(j, n) cout << T[i][j] << \" \";\n    cout << endl;\n  }\n    cout << endl;\n  */\n\n\n  tsort(n, n-1, T, order, visited, p);\n  reverse(order.begin(), order.end());\n\n  //  rep(i, n) cout << order[i] << \" \";\n  //  cout << endl;\n\n  assert( order[0] == n-1 );\n  assert( order[order.size()-1] == 0 );\n  back[order[0]] = 1.0;\n  for ( int i = 0; i < order.size(); i++ ){\n    int u = order[i];\n    rep(v, n){\n      if ( T[u][v] ) back[v] += back[u];\n    }\n  }\n\n  double base = 1.0; // back[0];\n  for ( int i = 0; i < n; i++ ){\n    if ( i == n-1 ) continue;\n    // back[i] = back[i]/back[0];\n    back[i] = back[i]/base;\n\n  }\n\n\n  /*\n  rep(i, n){\n    //printf(\"%.4lf %.4lf %.4lf\\n\", forward[i], back[i], forward[i]*back[i]);\n    printf(\"%.8lf\\n\", forward[i]*back[i]);\n  }\n  cout << endl;\n  */\n\n  int req;\n\n  rep(i, q){\n    cin >> req;\n    assert( 0 < req && req < n-1 );\n    printf(\"%.12lf\\n\", forward[req]*back[req]);\n    \n\t//printf(\"%.12lf * %.2lf = %.12lf\\n\", forward[req], back[req], forward[req]*back[req]);\n  }\n\n  \n  cout << endl;\n\n}\n\n\nmain(){\n  int n, m, q, G[MAX][MAX], s, t, c;\n  bool T[MAX][MAX];\n  vector<int> p[MAX];\n  while(1){\n    cin >> n >> m >> q;\n    if ( n == 0 && m == 0 && q == 0) break;\n\n    rep(i, n) rep(j, n) G[i][j] = INFTY;\n    rep(i, m){\n      cin >> s >> t >> c;\n      G[s][t] = G[t][s] = c;\n    }\n    dijkstra(n, G, p);\n    makeTree(n, T, p, q);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\ndouble dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<double>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     double tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\ndouble dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<double>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     double tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<double> num1(n, -1.0), num2(n, -1.0);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n, 0.0);\n    for(int i=0; i<n; ++i){\n        if(num2[i] > -0.5)\n            p[i] = num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = graph[b][a] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) dp[u][v]=1;\n\t\t}\n\t\trep(w,n) rep(u,n) rep(v,n) dp[u][v]+=dp[u][w]*dp[w][v];\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t\tif(a==b)return 1;\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n//\t\t\tvector<pii> &wt = wts[p.second];\n//\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\tvector<pii> *wt = &wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt->begin(); it != wt->end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nlong long dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<long long>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     long long tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nlong long dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<long long>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     long long tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<long long> num1(n, -1), num2(n, -1);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n, 0.0);\n    for(int i=0; i<n; ++i){\n        if(num1[i] != -1 && num2[i] != -1)\n            p[i] = (long double) num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    int n = 100;\n    vector<vector<int> > graph(n, vector<int>(n, -1));\n    vector<double> prob;\n    graph[0][1] = graph[1][0] = 9999;\n    graph[0][2] = graph[2][0] = 9999;\n    graph[n-1][n-2] = graph[n-2][n-1] = 9999;\n    graph[n-1][n-3] = graph[n-3][n-1] = 9999;\n    for(int i=1; i<n-3; i+=2){\n        graph[i][i+2] = graph[i+2][i] = 9999;\n        graph[i][i+3] = graph[i+3][i] = 9999;\n        graph[i+1][i+2] = graph[i+2][i+1] = 9999;\n        graph[i+1][i+3] = graph[i+3][i+1] = 9999;\n    }\n    solve(graph, prob);\n\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = graph[b][a] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\nstruct Edge {\n  int v, c;\n  Edge() {}\n  Edge(int v, int c) : v(v), c(c) {}\n};\n\nstruct State {\n  int v, c;\n  State() {}\n  State(int v, int c) : v(v), c(c) {}\n  bool operator <(const State &s) const {\n    return c < s.c;\n  }\n  bool operator >(const State &s) const {\n    return c > s.c;\n  }\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int a, int b, int c, Graph *g) {\n  if(max(a,b)+1 > g->size()) {\n    g->resize(max(a,b)+1);\n  }\n  (*g)[a].push_back(Edge(b,c));\n  (*g)[b].push_back(Edge(a,c));\n}\n\nconst int MAXN = 101;\nconst int INF = 1<<28;\nint N, M, P;\nGraph G;\nvector<int> C;\nint cost[MAXN];\nint num[MAXN];\n\nvoid dijkstra(int src, int dst, const Graph &g) {\n  priority_queue<State, vector<State>, greater<State> > que;\n  fill(cost, cost+MAXN, INF);\n  fill(num, num+MAXN, 0);\n  cost[src] = 0; \n  num[src] = 1;\n  que.push(State(src, 0));\n  while(!que.empty()) {\n    State s = que.top();\n    que.pop();\n    if(cost[s.v] < s.c) continue;\n    for(int i = 0; i < g[s.v].size(); ++i) {\n      int nv = g[s.v][i].v;\n      int nc = s.c + g[s.v][i].c;\n      if(cost[nv] == nc) {\n\tnum[nv] += num[s.v];\n      } else if(cost[nv] > nc) {\n\tnum[nv] = num[s.v];\n\tcost[nv] = nc;\n\tque.push(State(nv,nc));\n      }\n    }\n  }\n}\n\nint main() {\n  while(cin >> N >> M >> P && (N|M|P)) {\n    G.clear();\n    for(int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      addEdge(a,b,c,&G);\n    }\n    C.resize(P);\n    for(int i = 0; i < P; ++i) {\n      cin >> C[i];\n    }\n    dijkstra(0, N-1, G);\n    for(int i = 0; i < P; ++i) {\n      printf(\"%.10f\\n\", (double)num[C[i]]/(double)num[N-1]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint done[100] = {};\nint dp[100] = {};\nint ok[100][100] = {};\n\nvector<NODE> g[100];\nvector<NODE> g2[100][100];\nint n,m,p;\n\nint dfs(int x,int cst,int t){\n\tif( done[x] != cst ) return 0;\n\tif( x == n - 1 ) return 1;\n\tif( ok[x][t] != -1 ) return ok[x][t];\n\tint use = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tif( dfs(g[x][i].to,cst+g[x][i].cost,t+1) ){\n\t\t\tg2[x][t].push_back(g[x][i]);\n\t\t\tuse = 1;\n\t\t}\n\treturn ok[x][t] = use;\n}\nint main(){\n\twhile(cin >> n >> m >> p && (n||m||p) ){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a].push_back( NODE(b,c) );\n\t\t\tg[b].push_back( NODE(a,c) );\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) done[i] = -1;\n\t\tfor(int i = 0 ; i < 100 ; i++)\n\t\t\tfor(int j = 0 ; j < 100 ; j++)\n\t\t\t\tok[i][j] = -1 , g2[i][j].clear();\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to] != -1 ) continue;\n\t\t\telse done[q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t\tdfs(0,0,0);\n\t\tdouble dp2[101][101] = {};\n\t\tdouble res[100]={};\n\t\tdp2[0][0] = 1.0;\n\t\tfor(int i = 0 ; i < 100 ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tfor(int k = 0 ; k < g2[j][i].size() ; k++){\n\t\t\t\t\tdp2[i+1][g2[j][i][k].to] += dp2[i][j] / g2[j][i].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < 101 ; i++)\n\t\t\tfor(int j = 0 ; j < 101 ; j++)\n\t\t\t\tres[j] += dp2[i][j];\n\t\t\n\t\tfor(int i = 0 ; i < p ; i++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.10lf\\n\",res[a]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nenum Type{\n\tfrom_S,\n\tfrom_G,\n};\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総コストの昇順(PQ)\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nint N,M,P;\nint C[100001];\nint min_dist[100][2];\nbool calculated[100][2];\ndouble path_num[100][2],ans[100];\nvector<Edge> G[100];\nvector<int> DAG_G[100],rev_DAG_G[100];\n\nvoid dijkstra(Type type,int start){\n\n\tfor(int i = 0; i < N; i++)min_dist[i][type] = BIG_NUM;\n\tmin_dist[start][type] = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(Info(start,0));\n\n\tint next_node,next_cost;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > min_dist[Q.top().node_id][type]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\t\t\t\tnext_cost = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\n\t\t\t\tif(min_dist[next_node][type] > next_cost){\n\t\t\t\t\tmin_dist[next_node][type] = next_cost;\n\t\t\t\t\tQ.push(Info(next_node,next_cost));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\n//from_S:あるノードからゴール方向への経路数、from_G:あるノードからスタート方向への経路数\ndouble recursive(Type type,int node_id,int goal){\n\n\tif(calculated[node_id][type])return path_num[node_id][type];\n\n\tif(node_id == goal)return 1.0;\n\n\tif(type == from_S){\n\n\t\tfor(int i = 0; i < DAG_G[node_id].size(); i++){\n\t\t\tpath_num[node_id][type] += recursive(type,DAG_G[node_id][i],goal);\n\t\t}\n\n\t}else{ //type == from_G\n\n\t\tfor(int i = 0; i < rev_DAG_G[node_id].size(); i++){\n\t\t\tpath_num[node_id][type] += recursive(type,rev_DAG_G[node_id][i],goal);\n\t\t}\n\t}\n\tcalculated[node_id][type] = true;\n\n\treturn path_num[node_id][type];\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\tDAG_G[i].clear();\n\t\trev_DAG_G[i].clear();\n\t}\n\n\tint from,to,cost;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %d\",&from,&to,&cost);\n\t\tG[from].push_back(Edge(to,cost));\n\t\tG[to].push_back(Edge(from,cost));\n\t}\n\n\tfor(int i = 0; i < P; i++)scanf(\"%d\",&C[i]);\n\n\tdijkstra(from_S,0);\n\tdijkstra(from_G,N-1);\n\n\tint next_node;\n\t//最短経路DAGを作る\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tnext_node = G[i][k].to;\n\t\t\tif(min_dist[i][from_S]+G[i][k].cost+min_dist[next_node][from_G] == min_dist[N-1][from_S]){ //最短経路上の辺\n\t\t\t\tDAG_G[i].push_back(next_node);\n\t\t\t\trev_DAG_G[next_node].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 2; k++){\n\t\t\tcalculated[i][k] = false;\n\t\t\tpath_num[i][k] = 0;\n\t\t}\n\t}\n\n\t//再帰的に、そのノードを経由する経路数を計算する\n\trecursive(from_S,0,N-1);\n\trecursive(from_G,N-1,0);\n\n\tfor(int i = 0; i < N; i++){\n\t\tans[i] = path_num[i][from_G]*path_num[i][from_S]/path_num[0][from_S];\n\t}\n\n\tfor(int i = 0; i < P; i++){\n\t\tprintf(\"%.10lf\\n\",ans[C[i]]);\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&P);\n\t\tif(N == 0 && M == 0 && P == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\n\nvector<vector<int> > prev_nodes(const vector<vector<Edge> >& edges)\n{\n\tint n = edges.size();\n\n\tconst int INF = 1e7;\n\tvector<int> dis(n, INF);\n\tvector<vector<int> > prevv(n);\n\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\tdis[0] = 0;\n\tq.push(pint(0, 0));\n\twhile (!q.empty())\n\t{\n\t\tpint tt = q.top(); q.pop();\n\t\tint cur = tt.second, cost = tt.first;\n\n\t\tif (cost > dis[cur])\n\t\t\tcontinue;\n\n\t\tforeach (e, edges[cur])\n\t\t{\n\t\t\tint to = e->to, nc = cost + e->cost;\n\t\t\tif (nc < dis[to])\n\t\t\t{\n\t\t\t\tdis[to] = nc;\n\t\t\t\tprevv[to].clear();\n\t\t\t\tprevv[to].push_back(cur);\n\t\t\t\tq.push(pint(nc, to));\n\t\t\t}\n\t\t\telse if (nc == dis[to])\n\t\t\t\tprevv[to].push_back(cur);\n\t\t}\n\t}\n\n\treturn prevv;\n}\n\nvector<vector<int> > rev(const vector<vector<int> >& e)\n{\n\tvector<vector<int> > res(e.size());\n\tfor (int i = 0; i < e.size(); ++i)\n\t\tfor (int j = 0; j < e[i].size(); ++j)\n\t\t\tres[e[i][j]].push_back(i);\n\treturn res;\n}\n\ndouble in_paths(vector<double>& dp, const vector<vector<int> >& e, int v)\n{\n\tif (dp[v] != -1)\n\t\treturn dp[v];\n\telse if (e[v].empty())\n\t\treturn dp[v] = 1;\n\n\tdouble res = 0;\n\tfor (int i = 0; i < e[v].size(); ++i)\n\t\tres += in_paths(dp, e, e[v][i]);\n\treturn dp[v] = res;\n}\nint main()\n{\n\tint n, m, p;\n\twhile (cin >> n >> m >> p, n)\n\t{\n\t\tvector<vector<Edge> > edges(n);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedges[a].push_back(Edge(b, c));\n\t\t\tedges[b].push_back(Edge(a, c));\n\t\t}\n\t\tvector<vector<int> > prevv = prev_nodes(edges);\n\n\t\tvector<double> in(n, -1), out(n, -1);\n\t\tin_paths(in, prevv, n - 1);\n\t\tin_paths(out, rev(prevv), 0);\n\n\t\tvector<double> paths(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tpaths[i] = in[i] * out[i];\n\t\tdouble total_paths = paths[0];\n\n\t\twhile (p--)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\t\n\t\t\tprintf(\"%.8f\\n\", paths[c] / total_paths);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100];\nbool v[100],u[100]; double cnt[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28;\n\t\td[0]=0;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(c==n-1)break;\n\t\t\tif(d[c]<-cc)continue;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,Q.push(mp(cc-i->second,i->first));\n\t\t}\n\t\t\n\t\trep(i,n)u[i]=v[i]=0,cnt[i]=0;\n\t\tqueue<int> q; q.push(n-1);\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tv[c]=1;\n\t\t\tfr(i,e[c])if(!v[i->first]&&d[i->first]+i->second==d[c])q.push(i->first);\n\t\t}\n\t\tq=queue<int>(); q.push(0);\n\t\tcnt[0]=1;\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tu[c]=1;\n\t\t\tfr(i,e[c])if(!u[i->first]&&v[i->first]&&d[i->first]==d[c]+i->second)\n\t\t\tq.push(i->first),cnt[i->first]+=cnt[c];\n\t\t}\n\t\t\n\t\trep(i,p)printf(\"%.7f\\n\",cnt[C[i]]/cnt[n-1]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            dfs(e.to,d);\n            dp[e.to] *= dp[v]*cnt; \n        }\n    }\n}\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,0,sizeof(visited));\n        fill(dp,dp+MAX,1);\n        dfs(n-1,d);\n        for(int i = 0 ; i < n ; i++){\n            if(!visited[i]) dp[i] = 0;\n        }\n        dp[0] = dp[n-1] = 1;\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.12f\\n\",(dp[c] != 0 ? 1./dp[c] : 0));\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1058 Winter Bells\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string.h>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nvoid visit(graph &g, vector<int> &order, vector<bool> &mark, int pos){\n\tfor(int i=0;i<g[pos].size();i++){\n\t\tint next = g[pos][i];\n\t\tif(mark[next]) continue;\n\t\tvisit(g, order, mark, next);\n\t}\n\tmark[pos] = true;\n\torder.push_back(pos);\n}\n\nvector<int> topologicalSort(graph &g){\n\tvector<int> res;\n\tvector<bool> mark(g.size(), false);\n\tfor(int i=0;i<g.size();i++){\n\t\tif(mark[i]) continue;\n\t\tvisit(g, res, mark, i);\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\nint main(){\n\tint n, m, r;\n\tint cost[100][100];\n\twhile(cin >> n >> m >> r, n){\n\t\tvector< vector< pair<int, int> > > g(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j] = i==j ? 0 : 100000000;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint p, q, c; cin >> p >> q >> c;\n\t\t\tcost[p][q] = cost[q][p] = min(cost[p][q], c);\n\t\t\tg[p].push_back(make_pair(q,c));\n\t\t\tg[q].push_back(make_pair(p,c));\n\t\t}\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\tgraph h(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(cost[0][i]+cost[i][n-1]!=cost[0][n-1]) continue;\n\t\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\t\tif(cost[i][n-1]==cost[g[i][j].first][n-1]+g[i][j].second){\n\t\t\t\t\th[i].push_back(g[i][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> ord = topologicalSort(h);\n\t\tvector<double> prob(n, 0.0);\n\t\tprob[0] = 1.0;\n\t\tfor(int i=0;i<ord.size();i++){\n\t\t\tfor(int j=0;j<h[ord[i]].size();j++)\n\t\t\t\tprob[h[ord[i]][j]] += (double)prob[ord[i]]/h[ord[i]].size();\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint t; cin >> t;\n\t\t\tprintf(\"%.8lf\\n\", prob[t]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\nfor(int i=0;i<n;i++)if(cnt[n]<0)return 1;\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(scanf(\"%d%d%d\",&n,&m,&p), n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vi c(p);\n    for(int i=0;i<p;i++)scanf(\"%d\",&c[i]);\n\n    vi d(n,1e9), order;\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n      order.push_back(v);\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<double> cnt(n,0);\n    cnt[n-1] = 1;\n    for(int i=order.size()-1;i>=0;i--){\n      int v = order[i];\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis)cnt[u] += cnt[v];\n      }\n    }\n\n    vector<double> prob(n,0);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(edge e : g[v]){\n\tint nxtd = d[v] + e.first, u = e.second;\n\tif(d[u] == nxtd){\n\t  prob[u] += prob[v] * cnt[u] / cnt[v];\n\t}\n      }\n    }\n\n    for(int i=0;i<p;i++)printf(\"%.9lf\\n\", prob[c[i]]);\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\n\nvector<vector<int> > clean(const vector<vector<int> >& e)\n{\n\tint n = e.size();\n\tvector<bool> on_min_path(n);\n\tqueue<int> q;\n\ton_min_path[n - 1] = true;\n\tq.push(n - 1);\n\twhile (!q.empty())\n\t{\n\t\tint cur = q.front(); q.pop();\n\t\tfor (int i = 0; i < e[cur].size(); ++i)\n\t\t{\n\t\t\tint to = e[cur][i];\n\t\t\tif (!on_min_path[to])\n\t\t\t{\n\t\t\t\ton_min_path[to] = true;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int> > res(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < e[i].size(); ++j)\n\t\t\tif (on_min_path[i] && on_min_path[e[i][j]])\n\t\t\t\tres[i].push_back(e[i][j]);\n\treturn res;\n}\nvector<vector<int> > prev_nodes(const vector<vector<Edge> >& edges)\n{\n\tint n = edges.size();\n\n\tconst int INF = 1e7;\n\tvector<int> dis(n, INF);\n\tvector<vector<int> > prevv(n);\n\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\tdis[0] = 0;\n\tq.push(pint(0, 0));\n\twhile (!q.empty())\n\t{\n\t\tpint tt = q.top(); q.pop();\n\t\tint cur = tt.second, cost = tt.first;\n\n\t\tif (cost > dis[cur])\n\t\t\tcontinue;\n\n\t\tforeach (e, edges[cur])\n\t\t{\n\t\t\tint to = e->to, nc = cost + e->cost;\n\t\t\tif (nc < dis[to])\n\t\t\t{\n\t\t\t\tdis[to] = nc;\n\t\t\t\tprevv[to].clear();\n\t\t\t\tprevv[to].push_back(cur);\n\t\t\t\tq.push(pint(nc, to));\n\t\t\t}\n\t\t\telse if (nc == dis[to])\n\t\t\t\tprevv[to].push_back(cur);\n\t\t}\n\t}\n\n\treturn clean(prevv);\n}\n\nvector<vector<int> > rev(const vector<vector<int> >& e)\n{\n\tvector<vector<int> > res(e.size());\n\tfor (int i = 0; i < e.size(); ++i)\n\t\tfor (int j = 0; j < e[i].size(); ++j)\n\t\t\tres[e[i][j]].push_back(i);\n\treturn res;\n}\n\ndouble in_paths(vector<double>& dp, const vector<vector<int> >& e, int v)\n{\n\tif (dp[v] != -1)\n\t\treturn dp[v];\n\telse if (e[v].empty())\n\t\treturn dp[v] = 1;\n\n\tdouble res = 0;\n\tfor (int i = 0; i < e[v].size(); ++i)\n\t\tres += in_paths(dp, e, e[v][i]);\n\treturn dp[v] = res;\n}\nint main()\n{\n\tint n, m, p;\n\twhile (cin >> n >> m >> p, n)\n\t{\n\t\tvector<vector<Edge> > edges(n);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedges[a].push_back(Edge(b, c));\n\t\t\tedges[b].push_back(Edge(a, c));\n\t\t}\n\t\tvector<vector<int> > prevv = prev_nodes(edges);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//{\n\t\t//\tprintf(\"%d: \", i);\n\t\t//\tfor (int j = 0; j < prevv[i].size(); ++j)\n\t\t//\t\tprintf(\"%d \", prevv[i][j]);\n\t\t//\tputs(\"\");\n\t\t//}puts(\"\");\n\n\t\tvector<double> in(n, -1), out(n, -1);\n\t\tin_paths(in, prevv, n - 1);\n\t\tin_paths(out, rev(prevv), 0);\n\n\t\tvector<double> paths(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (in[i] != -1)\n\t\t\t\tpaths[i] = in[i] * out[i];\n\t\tdouble total_paths = paths[0];\n\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//{\n\t\t//\tprintf(\"%d: %f %f\\n\", i, in[i], out[i]);\n\t\t//}\n\n\t\twhile (p--)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\t\n\t\t\tprintf(\"%.8f\\n\", paths[c] / total_paths);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\t\t\t\tif( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])while(1);\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint done[110] = {};\nint dp[110] = {};\nint ok[110] = {};\n\nvector<NODE> g[100];\nint n,m,p;\n\nint dfs(int x,int cst){\n\tif( done[x] != cst ) return 0;\n\tif( x == n - 1 ) return ok[x] = 1;\n\tif( ok[x] != -1 ) return ok[x];\n\tint use = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tif( dfs(g[x][i].to,cst+g[x][i].cost) ){\n\t\t\tuse = 1;\n\t\t}\n\treturn ok[x] = use;\n}\nint main(){\n\twhile(cin >> n >> m >> p && (n||m||p) ){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a].push_back( NODE(b,c) );\n\t\t\tg[b].push_back( NODE(a,c) );\n\t\t}\n\t\tfor(int i = 0 ; i < 110 ; i++) done[i] = -1;\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\t\tok[i] = -1;\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to] != -1 ) continue;\n\t\t\telse done[q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t\tdfs(0,0);\n\t\tdouble dp2[110][110] = {};\n\t\tdouble res[100]={};\n\t\tdp2[0][0] = 1.0;\n\t\tfor(int i = 0 ; i <= n ; i++){\n\t\t\tfor(int j = 0 ; j < n-1 ; j++){\n\t\t\t\tint C = 0;\n\t\t\t\tfor(int k = 0 ; k < g[j].size() ; k++){\n\t\t\t\t\tif( done[j] + g[j][k].cost == done[g[j][k].to] && ok[g[j][k].to] == 1 ){\n\t\t\t\t\t\tC++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int k = 0 ; k < g[j].size() ; k++){\n\t\t\t\t\tif( done[j] + g[j][k].cost == done[g[j][k].to] && ok[g[j][k].to] == 1 ){\n\t\t\t\t\t\tdp2[i+1][g[j][k].to] += dp2[i][j] / C;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i <= n; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tres[j] += dp2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < p ; i++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.10lf\\n\",res[a]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\nlong double dp[MAX];\nint cnt[MAX];\nvector<Edge> G[MAX];\nvector<int> G2[MAX];\nbool visited[MAX];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n        G2[i].clear();\n        dp[i] = cnt[i] = 0;\n        visited[i] = 0;\n    }\n}\n\nvector<int> dijkstra(int n){\n    vector<int> d(n, INF); d[0] = 0;\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,0));\n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost < d[e.to]){\n                d[e.to] = d[v] + e.cost;\n                Q.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n    return d;\n}\n\nvoid dijkstra2(int s,int n,vector<int> &d2){\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,s));\n    vector<int> d(n,INF); d[s] = 0;\n    if(s == n-1) cnt[s] = 1;\n    else dp[s] = 1;\n    \n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost <= d[e.to]){\n                if(s == n-1){\n                    if(d2[v]-d2[e.to] == e.cost){\n                        cnt[e.to] += cnt[v];\n                        G2[e.to].push_back(v);\n                    }\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }else{\n                    dp[e.to] += dp[v]*cnt[e.to]/cnt[v];\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }\n            }\n        }\n    }\n}\n\nvoid dfs(int v){\n    if(visited[v]) return;\n    visited[v] = 1;\n    for(int i = 0 ; i < (int)G2[v].size() ; i++){\n        int to = G2[v][i];\n        dp[to] += dp[v]*cnt[to]/cnt[v];\n        dfs(to);\n    }\n}\n\nvoid bfs(int n){\n    queue<int> Q;\n    Q.push(0);\n    vector<int> d(n, INF); d[0] = 0;\n    while(!Q.empty()){\n        int v = Q.front(); Q.pop();\n        for(int i = 0 ; i < (int)G2[v].size() ; i++){\n            int to = G2[v][i];\n            if(d[v] + 1 <= d[to]){\n                d[to] = d[v] + 1;\n                dp[to] += dp[v]*cnt[to]/cnt[v];\n                Q.push(to);\n            }\n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        vector<int> d = dijkstra(n);\n\n        dijkstra2(n-1,n,d);\n        dijkstra2(0,n,d);\n        \n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.12Lf\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<map>\n#include<set>\n#include<deque>\n#include<queue>\n#include<stack>\n#include<bitset>\n#include<algorithm>\n#include<functional>\n#include<numeric>\n#include<utility>\n#include<iostream>\n#include<sstream>\n#include<iomanip>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<cctype>\n#include<string>\n#include<cstring>\n#include<cstdio>\n#include<cmath>\n#include<cstdlib>\n#include<ctime>\n#include<climits>\nusing namespace std;\nstruct edge \n{\n\tint u,v,w,next;\n}a[120000];\nint start[120],tot=0,n,m;\nvoid addedge(int u,int v,int w)\n{\n\ta[tot].u=u;\n\ta[tot].v=v;\n\ta[tot].w=w;\n\ta[tot].next=start[u];\n\tstart[u]=tot++;\n}\nint d[120],que[120];\nlong double dp[120],dp1[120];\nvector<int>g[120];\nvector<int>g1[120];\nint outd[120];\nlong double getdp(int u,int st)\n{\n\tif (u==st)return dp[u]=1;\n\tif (dp[u]!=-1)return dp[u];\n\tint i;\n\tlong double sum=0;\n\tfor (i=0;i<g[u].size();i++)\n\t{\n\t\tsum+=getdp(g[u][i],st);\n\t}\n\treturn dp[u]=sum;\n}\nlong double fz[120],fz1[120],tt;\nvoid spfa(int st)\n{\n\tint i,j,k;\n\tmemset(d,100,sizeof(d));\n\tmemset(que,0,sizeof(que));\n\td[st]=0;que[st]=1;\n\tqueue<int>q;\n\tq.push(st);\n\twhile (!q.empty())\n\t{\n\t\tint tmp=q.front();\n\t\tq.pop();\n\t\tque[tmp]=0;\n\t\tfor (i=start[tmp];~i;i=a[i].next)\n\t\t{\n\t\t\tif (d[a[i].v]>d[tmp]+a[i].w)\n\t\t\t{\n\t\t\t\td[a[i].v]=d[tmp]+a[i].w;\n\t\t\t\tif (!que[a[i].v])\n\t\t\t\t{\n\t\t\t\t\tque[a[i].v]=1;\n\t\t\t\t\tq.push(a[i].v);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tfor (i=0;i<n+10;i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t}\n\t\t\n\tfor (i=0;i<m;i++)\n\t{\n\t\tif (d[a[i].v]==a[i].w+d[a[i].u])\n\t\t{\n\t\t\tg[a[i].v].push_back(a[i].u);\n\t\t}\n\t}\n\tif (st==0)\n\t{\n\t\tfor (i=0;i<n+10;i++)\n\t\t{\n\t\t\tdp[i]=-1;\n\t\t}\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tgetdp(i,st);\n\t\t}\n\t\ttt=dp[n-1];\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tfz[i]=dp[i];\n\t\t}\n\t\tfz1[st]=dp[n-1];\n\t\treturn;\n\t}\n\tfor (i=0;i<n+10;i++)\n\t\t{\n\t\t\tdp[i]=-1;\n\t\t}\n\tfor (i=n-1;i<n;i++)\n\t{\n\t\tgetdp(i,st);\n\t}\n\t//if (st==1)cout<<dp[n-1]<<endl;\n\tfz1[st]=dp[n-1];\n}\nint main()\n{\n\tint i,j,k,q;\n\twhile (scanf(\"%d%d%d\",&n,&m,&q)!=EOF,n*n+m*m+q*q)\n\t{\n\t\tfor (i=0;i<n+10;i++)\n\t\t{\n\t\t\tg[i].clear();\n\t\t\tg1[i].clear();\n\t\t\toutd[i]=0;\n\t\t\tstart[i]=-1;\n\t\t}\n\t\ttot=0;\n\t\tfor (i=0;i<m;i++)\n\t\t{\n\t\t\tint x,y,z;\n\t\t\tscanf(\"%d%d%d\",&x,&y,&z);\n\t\t\taddedge(x,y,z);\n\t\t}\n\t\tfor (i=0;i<n;i++)\n\t\t{\n\t\t\tspfa(i);\n\t\t}\n\t\t//cout<<fz[1]<<endl;\n\t\twhile (q--)\n\t\t{\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tcout<<setprecision(14)<<fz[x]*fz1[x]/tt<<endl;\n\t\t\t//printf(\"%.14lf\\n\",(double)fz[x]*fz1[x]/tt);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\t\t\t\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<int>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nint dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<int>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<int> num1(n, -1), num2(n, -1);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n, 0.0);\n    for(int i=0; i<n; ++i){\n        if(num2[i] != -1)\n            p[i] = 1.0 * num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 29;\n\n\nint N, M, P;\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *dp)\n{\n  static int v[100];\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(10);\n\n  while(cin >> N >> M >> P, N) {\n    g.clear();\n    g.resize(N);\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, dp1);\n    Dijkstra(N - 1, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n,m,p;cin>>n>>m>>p,n;){\n    double nr[100][100]={};\n    int d[100][100];\n    const int INF=1<<29;\n    fill(d[0],d[100],INF);\n    for(int i=0;i<n;i++){\n      d[i][i]=0;\n    }\n    while(m--){\n      int s,t,u;\n      cin>>s>>t>>u;\n      d[s][t]=d[t][s]=u;\n      nr[s][t]=nr[t][s]=1;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  int nd=d[j][i]+d[i][k];\n\t  if(nd<=d[j][k]){\n\t    if(nd<d[j][k]){\n\t      nr[j][k]=0;\n\t    }\n\t    d[j][k]=nd;\n\t    nr[j][k]+=nr[j][i]*nr[i][k];\n\t  }\n\t}\n      }\n    }\n    while(p--){\n      int c;\n      cin>>c;\n      cout.precision(9);\n      cout<<fixed<<((c==0||c==n-1)?1:(d[0][c]+d[c][n-1]!=d[0][n-1])?0:nr[0][c]*nr[c][n-1]/nr[0][n-1])<<endl;\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<int>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nint dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<int>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<int> num1(n, -1), num2(n, -1);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n, 0.0);\n    for(int i=0; i<n; ++i){\n        if(num1[i] != -1 && num2[i] != -1)\n            p[i] = 1.0 * num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = graph[b][a] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Data {\n  int cur;\n  ll w;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w < data.w;\n    return cur < data.cur;\n  }\n};\n\nconst ll LLINF = LLONG_MAX;\nconst int MAX_V = 110;\nint n,m,p;\nll fw[110][110];\ndouble dp[MAX_V];\nvector<Data> G[MAX_V];\n\nint main(){\n  while( cin >> n >> m >> p, n|m|p ){\n    rep(i,n) G[i].clear();\n    rep(i,n) rep(j,n) fw[i][j] = ((i==j)?0:LLINF);\n    rep(i,m) {\n      int s,t;\n      ll c;\n      cin >> s >> t >> c;\n      G[s].push_back((Data){t,c});\n      G[t].push_back((Data){s,c});\n      fw[s][t] = fw[t][s] = c;\n    }\n\n    rep(k,n) rep(i,n) rep(j,n) if( fw[i][k] != LLINF && fw[k][j] != LLINF ) fw[i][j] = min(fw[i][j],\n\t\t\t\t\t\t\t\t\t\t\t   fw[i][k]+fw[k][j]);\n\n    vector<Data> vec;\n    rep(i,n) vec.push_back((Data){i,fw[0][i]});\n    sort(vec.begin(),vec.end());  \n    rep(i,n) dp[i] = 0;\n    dp[0] = 1;\n    rep(i,vec.size()) {\n      int cur = vec[i].cur;\n      if( fw[0][cur] == LLINF || fw[cur][n-1] == LLINF ) continue;\n      ll weight = vec[i].w;\n      double cnt = 0;\n      \n\n      rep(j,G[cur].size()) if( cur != G[cur][j].cur ){\n\tint next = G[cur][j].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][cur] + G[cur][j].w + fw[next][n-1] == fw[0][n-1] ) {\n\t  ++cnt;\n\t}\n      }\n      rep(j,G[cur].size()) if( cur != G[cur][j].cur ){\n\tint next = G[cur][j].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][cur] + G[cur][j].w + fw[next][n-1] == fw[0][n-1] ) {\n\t    dp[next] += dp[cur] * ( 1.0 / cnt );\n\t}\n      }\n      \n    }\n\n    rep(i,p){\n      int pos;\n      cin >> pos;\n      printf(\"%.10f\\n\",dp[pos]);\n    } puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\n\nvector<vector<int> > clean(const vector<vector<int> >& e)\n{\n\tint n = e.size();\n\tvector<bool> on_min_path(n);\n\tqueue<int> q;\n\ton_min_path[n - 1] = true;\n\tq.push(n - 1);\n\twhile (!q.empty())\n\t{\n\t\tint cur = q.front(); q.pop();\n\t\tfor (int i = 0; i < e[cur].size(); ++i)\n\t\t{\n\t\t\tint to = e[cur][i];\n\t\t\tif (!on_min_path[to])\n\t\t\t{\n\t\t\t\ton_min_path[to] = true;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int> > res(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < e[i].size(); ++j)\n\t\t\tif (on_min_path[i] && on_min_path[e[i][j]])\n\t\t\t\tres[i].push_back(e[i][j]);\n\treturn res;\n}\nvector<vector<int> > prev_nodes(const vector<vector<Edge> >& edges)\n{\n\tint n = edges.size();\n\n\tconst int INF = 1e7;\n\tvector<int> dis(n, INF);\n\tvector<vector<int> > prevv(n);\n\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\tdis[0] = 0;\n\tq.push(pint(0, 0));\n\twhile (!q.empty())\n\t{\n\t\tpint tt = q.top(); q.pop();\n\t\tint cur = tt.second, cost = tt.first;\n\n\t\tif (cost > dis[cur])\n\t\t\tcontinue;\n\n\t\tforeach (e, edges[cur])\n\t\t{\n\t\t\tint to = e->to, nc = cost + e->cost;\n\t\t\tif (nc < dis[to])\n\t\t\t{\n\t\t\t\tdis[to] = nc;\n\t\t\t\tprevv[to].clear();\n\t\t\t\tprevv[to].push_back(cur);\n\t\t\t\tq.push(pint(nc, to));\n\t\t\t}\n\t\t\telse if (nc == dis[to])\n\t\t\t\tprevv[to].push_back(cur);\n\t\t}\n\t}\n\n\treturn clean(prevv);\n}\n\nvector<vector<int> > rev(const vector<vector<int> >& e)\n{\n\tvector<vector<int> > res(e.size());\n\tfor (int i = 0; i < e.size(); ++i)\n\t\tfor (int j = 0; j < e[i].size(); ++j)\n\t\t\tres[e[i][j]].push_back(i);\n\treturn res;\n}\n\nll in_paths(vector<ll>& dp, const vector<vector<int> >& e, int v)\n{\n\tif (dp[v] != -1)\n\t\treturn dp[v];\n\telse if (e[v].empty())\n\t\treturn dp[v] = 1;\n\n\tll res = 0;\n\tfor (int i = 0; i < e[v].size(); ++i)\n\t\tres += in_paths(dp, e, e[v][i]);\n\treturn dp[v] = res;\n}\nint main()\n{\n\tint n, m, p;\n\twhile (cin >> n >> m >> p, n)\n\t{\n\t\tvector<vector<Edge> > edges(n);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedges[a].push_back(Edge(b, c));\n\t\t\tedges[b].push_back(Edge(a, c));\n\t\t}\n\t\tvector<vector<int> > prevv = prev_nodes(edges);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//{\n\t\t//\tprintf(\"%d: \", i);\n\t\t//\tfor (int j = 0; j < prevv[i].size(); ++j)\n\t\t//\t\tprintf(\"%d \", prevv[i][j]);\n\t\t//\tputs(\"\");\n\t\t//}puts(\"\");\n\n\t\tvector<ll> in(n, -1), out(n, -1);\n\t\tin_paths(in, prevv, n - 1);\n\t\tin_paths(out, rev(prevv), 0);\n\n\t\tvector<ll> paths(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (in[i] != -1)\n\t\t\t\tpaths[i] = in[i] * out[i];\n\t\tll total_paths = paths[0];\n\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//{\n\t\t//\tprintf(\"%d: %lld %lld\\n\", i, in[i], out[i]);\n\t\t//}\n\n\t\twhile (p--)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\t\n\t\t\tprintf(\"%.7f\\n\", (double)paths[c] / total_paths);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//29\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint d[100][100];\n\nbool cmp(int a,int b){\n  return d[0][a]<d[0][b];\n}\n\nint main(){\n  for(int n,m,pp;cin>>n>>m>>pp,n|m|pp;){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\td[i][j]=(i==j)?0:1<<29;\n      }\n    }\n    int cn[100][100]={};\n    while(m--){\n      int s,t,w;\n      cin>>s>>t>>w;\n      d[s][t]=d[t][s]=w;\n      cn[s][t]=cn[t][s]=w;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    double p[100]={1};\n    int o[100];\n    for(int i=0;i<n;i++){\n      o[i]=i;\n    }\n    sort(o,o+n,cmp);\n    for(int i=0;o[i]!=n-1;i++){\n      int nb=0;\n      for(int j=0;j<n;j++){\n\tnb+=o[i]!=j&&d[0][o[i]]+cn[o[i]][j]+d[j][n-1]==d[0][n-1];\n      }\n      for(int j=0;j<n;j++){\n\tif(o[i]!=j&&d[0][o[i]]+cn[o[i]][j]+d[j][n-1]==d[0][n-1]){\n\t  p[j]+=p[o[i]]/nb;\n\t}\n      }\n    }\n    while(pp--){\n      int c;\n      cin>>c;\ncout.precision(9);\n      cout<<fixed<<p[c]<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == p.first) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (!visited2[e.to]) {\n                    visited2[e.to] = 1;\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];\n                    Q2.push(pii(d[0][e.to], e.to));\n                }\n            }\n        }\n        \n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n//if(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,k;cin>>n>>m>>k && n|m|k;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(k);\n\t\trep(i,k) cin>>cs[i];\n\t\t\n\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\t\tpq.emplace(-1,0,0);\n\t\tvi dist(n,INF);\n\t\tvvi prev(n);\n\t\twhile(pq.size()){\n\t\t\tEdge cur=pq.top(); pq.pop();\n\t\t\tif(dist[cur.dst]<cur.weight) continue;\n\t\t\tdist[cur.dst]=cur.weight;\n\t\t\tprev[cur.dst].push_back(cur.src);\n\t\t\tfor(auto e:g[cur.dst])\n\t\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t\t}\n\t\t\n\t\tvd ps(n,0); ps[n-1]=1;\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return dist[i]>dist[j];});\n\t\tfor(auto u:is) for(auto v:prev[u]) if(v!=-1)\n\t\t\tps[v]+=ps[u]/prev[u].size();\n\t\t\n\t\trep(i,k) printf(\"%.8f\\n\",ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#include<math.h>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n#define maxn 110\nint dis[maxn],head[maxn],deg[maxn];\nstruct Edge{\n\tint st,to,next,len;\n}edge[maxn*maxn*2];\nint n,m,p,num;\ndouble hav[maxn];\nint pos[maxn],pre[maxn][maxn],cnt[maxn],mark[maxn];\ndouble ans[maxn];\nint l,h,q[maxn];\nvoid addedge(int a,int b ,int c)\n{\n\tedge[num].st=a;edge[num].to=b;edge[num].len=c;\n\tedge[num].next=head[a];head[a]=num++;\n}\nvoid dij()\n{\n\tint i,j,k;\n\tint id,now;\n\tmemset(dis,-1,sizeof(dis));\n\tmemset(mark,0,sizeof(mark));\n\tmemset(cnt,0,sizeof(cnt));\n\tdis[0]=0;\n\twhile(1){\n\t\tnow=-1;\n\t\tfor(i=0;i<n;i++){\n\t\t\tif(dis[i]==-1)continue;\n\t\t\tif((dis[i]<now||now==-1)&&!mark[i]){\n\t\t\t\tnow=dis[i];\n\t\t\t\tid=i;\n\t\t\t}\n\t\t}\n\t\tif(now==-1)break;\n\t\tmark[id]=1;\n\t\tfor(i=head[id];i!=-1;i=edge[i].next){\n\t\t\tj=edge[i].to;\n\t\t\tif(dis[j]==-1||dis[id]+edge[i].len<dis[j]){\n\t\t\t\tdis[j]=dis[id]+edge[i].len;\n\t\t\t\tcnt[j]=1;\n\t\t\t\tpre[j][cnt[j]]=id;\n\t\t\t}else if(dis[id]+edge[i].len==dis[j]){\n\t\t\t\tcnt[j]++;\n\t\t\t\tpre[j][cnt[j]]=id;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid dfs(int now)\n{\n\tif(mark[now])return;\n\tif(now==0){\n\t\tans[now]=1;\n\t\tmark[now]=1;\n\t\treturn;\n\t}\n\tint i;\n\tans[now]=0;\n\tfor(i=1;i<=cnt[now];i++){\n\t\tdfs(pre[now][i]);\n\t\tans[now]+=ans[pre[now][i]]*1.0*hav[now]/hav[pre[now][i]];\n\t}\n\tmark[now]=1;\n}\nvoid dfs1(int now)\n{\n\tif(mark[now])return;\n\tint i,j;\n\tfor(i=1;i<=cnt[now];i++){\n\t\tj=pre[now][i];\n\t\tdeg[j]++;\n\t\tdfs1(j);\n\t}\n\tmark[now]=1;\n}\nvoid work()\n{\n\tint i,j,k;\n\tmemset(hav,0,sizeof(hav));\n\thav[n-1]=1;\n\tl=h=0;\n\tq[h++]=n-1;\n\twhile(l<h){\n\t\tk=q[l++];\n\t\tfor(i=1;i<=cnt[k];i++){\n\t\t\tj=pre[k][i];\n\t\t\tdeg[j]--;\n\t\t\thav[j]+=hav[k];\n\t\t\tif(deg[j]==0){\n\t\t\t\tq[h++]=j;\n\t\t\t}\n\t\t}\n\t}\n}\n\t\t\t\nint main()\n{\n\tint i,j,k;\n\tint st,to,cost;\n\twhile(scanf(\"%d%d%d\",&n,&m,&p),n+m+p){\n\t\tnum=0;\n\t\tmemset(head,-1,sizeof(head));\n\t\twhile(m--){\n\t\t\tscanf(\"%d%d%d\",&st,&to,&cost);\n\t\t\taddedge(st,to,cost);\n\t\t\taddedge(to,st,cost);\n\t\t}\n\t\tfor(i=1;i<=p;i++){\n\t\t\tscanf(\"%d\",&pos[i]);\n\t\t}\n\t\tdij();\n\t\tif(dis[n-1]==-1)while(1);\n\t\tmemset(mark,0,sizeof(mark));\n\t\tmemset(deg,0,sizeof(deg));\n\t\tdfs1(n-1);\n\t\twork();\n\t\t/*for(i=0;i<n;i++){\n\t\t\tprintf(\"%d %d %d\\n\",i,deg[i],cnt[i]);\n\t\t}*/\n\t\tfor(i=0;i<n;i++){\n\t\t\tans[i]=0;\n\t\t}\n\t\t\n\t\tmemset(mark,0,sizeof(mark));\n\t\tdfs(n-1);\n\t\tfor(i=1;i<=p;i++){\n\t\t\tprintf(\"%.8f\\n\",ans[pos[i]]);\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n\n#define MAXN 105\n#define MAXM 20005\n\nint n,m,p;\nint totaledge,v[MAXM],w[MAXM],next[MAXM],point[MAXN];\nint dist[MAXN];\nint vis[MAXN];\nint ind[MAXN];\ndouble pp[MAXN];\n\nvoid addedge(int x,int y,int z){\n    int i;\n    i = ++totaledge;\n    v[i] = y;\n    w[i] = z;\n    next[i] = point[x];\n    point[x] = i;\n}\n\nvoid dijk(){\n    int i,j,now,md;\n    memset(dist,1,sizeof(dist));\n    memset(vis,0,sizeof(vis));\n    dist[n-1] = 0;\n    now = n - 1;\n    for(i=1;i<n;i++){\n        for (j=point[now];j;j=next[j])\n            if (dist[now]+w[j]<dist[v[j]]) dist[v[j]] = dist[now] + w[j];\n        vis[now] = 1;\n        md = dist[n];\n        for (j=0;j<n;j++)\n            if (vis[j]==0 && dist[j]<md){\n                md = dist[j];\n                now = j;\n            }\n    }\n}\n\nvoid psh(){\n    int i,j,cc,now,flag;\n    double tmp;\n    memset(pp,0,sizeof(pp));\n    memset(vis,0,sizeof(vis));\n    memset(ind,0,sizeof(ind));\n    for (i=0;i<n;i++)\n        for (j=point[i];j;j=next[j])\n            if (dist[i]+w[j]==dist[v[j]]){\n                ind[i]++;\n            }\n    pp[0] = 1;\n    now = 0;\n    flag = 1;\n    while (flag){\n        flag = 0;\n        cc = 0;\n        for (i=point[now];i;i=next[i])\n            if (dist[now]==dist[v[i]]+w[i]){\n                cc++;\n            }\n        if (cc>0){\n            tmp = pp[now] / cc;\n            for (i=point[now];i;i=next[i])\n                if (dist[now]==dist[v[i]]+w[i]){\n                    pp[v[i]] += tmp;\n                    ind[v[i]]--;\n                }\n            vis[now] = 1;\n            for (i=0;i<n;i++)\n                if (ind[i]==0 && vis[i]==0){\n                    now = i;\n                    flag = 1;\n                    break;\n                }\n        }\n    }\n}\n\nint main(){\n   // freopen(\"h.in\",\"r\",stdin);\n    int i,x,y,z;\n    while (scanf(\"%d%d%d\",&n,&m,&p)!=EOF && (n>0)){\n        memset(point,0,sizeof(point));\n        totaledge = 0;\n        for (i=1;i<=m;i++){\n            scanf(\"%d%d%d\",&x,&y,&z);\n            addedge(x,y,z);\n            addedge(y,x,z);\n        }\n        dijk();\n        psh();\n        while (p--){\n            scanf(\"%d\",&i);\n            printf(\"%.8f\\n\",pp[i]);\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t\t\n\t\t\tif(a<0||b<0||a>=n||b>=n)return 1;\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M, C;\n\ntypedef long long ll;\n\nstruct Edge {\n  int to; ll cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nvector<int> cs;\n\n//vector<vector<int> > prev_;\nint prev_[110][110];\nint pcnt[110];\ndouble ans[110];\n\nstruct state {\n  int curr; ll cost;\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nstruct ST {\n  int curr; double prob;\n};\n\nll const INF = 1LL<<40;\n\nint main() {\n  \n  while(cin >> N >> M >> C && (N|M|C)) {\n    g.clear(); g.resize(N);\n    cs.clear(); cs.resize(C);\n    rep(i, M) {\n      int a, b; ll c; cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c});\n      g[b].push_back((Edge){a, c});\n    }\n    rep(i, C) cin >> cs[i];\n    \n    ll dist[N];\n    fill(dist, dist+N, INF);\n    dist[0] = 0;\n    \n    rep(i, N) pcnt[i] = 0;\n    \n    priority_queue<state> pq;\n    pq.push((state){0, dist[0]});\n    while(!pq.empty()) {\n      int curr = pq.top().curr;\n      ll cost = pq.top().cost;\n      pq.pop();\n      \n      rep(i, g[curr].size()) {\n        Edge& e = g[curr][i];\n        if(dist[e.to] == cost+e.cost) {\n          prev_[e.to][pcnt[e.to]++] = curr;\n        }\n        if(dist[e.to] <= cost+e.cost) { continue; }\n        pcnt[e.to] = 0;\n        prev_[e.to][pcnt[e.to]++] = curr;\n        dist[e.to] = cost+e.cost;\n        pq.push((state){e.to, dist[e.to]});\n      }\n    }\n    \n    rep(i, N) ans[i] = 0.;\n    \n    bool vis[110] = {};\n    \n    queue<ST> q;\n    q.push((ST){N-1, 1.0});\n    while(!q.empty()) {\n      int curr = q.front().curr;\n      double prob = q.front().prob;\n      q.pop();\n      vis[curr] = 1;\n      \n      rep(i, pcnt[curr]) {\n        int to = prev_[curr][i];\n        double nprob = prob/pcnt[curr];\n        if(vis[to]) { continue; }\n        ans[to] += nprob;\n        q.push((ST){to, nprob});\n      }\n    }\n    \n    rep(i, C) {\n      printf(\"%.10f\\n\", ans[cs[i]]);\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\t\t\t\tif( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t\t\n\t\t\t\t\tif(!cnt[it->second])while(1);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 29;\n\n\nint N, M, P;\nint v1[100], v2[100];\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, int *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(8);\n\n  while(cin >> N >> M >> P, N) {\n    g.resize(N);\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n\n    g.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100];\nbool v[100]; double pb[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28;\n\t\td[0]=0;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(c==n-1)break;\n\t\t\tif(d[c]<-cc)continue;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,Q.push(mp(cc-i->second,i->first));\n\t\t}\n\t\t\n\t\trep(i,n)v[i]=0,pb[i]=0;\n\t\tqueue<int> q; q.push(n-1);\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tv[c]=1;\n\t\t\tfr(i,e[c])if(!v[i->first]&&d[i->first]+i->second==d[c])q.push(i->first);\n\t\t}\n\t\tq=queue<int>(); q.push(0);\n\t\tpb[0]=1;\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(),cnt=0; q.pop();\n\t\t\tfr(i,e[c])if(v[i->first]&&d[i->first]==d[c]+i->second)cnt++;\n\t\t\tfr(i,e[c])if(v[i->first]&&d[i->first]==d[c]+i->second)\n\t\t\tq.push(i->first),pb[i->first]+=pb[c]/cnt;\n\t\t}\n\t\t\n\t\trep(i,p)printf(\"%.7f\\n\",pb[C[i]]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid chmin(int& a,int b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) chmin(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) chmin(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tvector<__float128> cnt1(n,0); cnt1[0]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]<dp[0][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[e.src][e.dst]+dp[e.dst][n-1]==dp[e.src][n-1]) cnt1[e.dst]+=cnt1[e.src];\n\t\tvector<__float128> cnt2(n,0); cnt2[n-1]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[n-1][i]<dp[n-1][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[e.src][e.dst]+dp[e.dst][0]==dp[e.src][0]) cnt2[e.dst]+=cnt2[e.src];\n\t\t\n\t\tassert(abs(double(cnt1[n-1]-cnt2[0]))<EPS);\n\t\tfor(auto i:cs) printf(\"%.10f\\n\",double(cnt1[i]*cnt2[i]/cnt1[n-1])); puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\nif(w<1)return 1;\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int INF=1000000000;\nint d[101][101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint n;\nint m;\nint p;\n\nstruct edge{\n    int to;\n    int cost;\n};\nvector<edge> G[101];\nll dp[101][101];\n//  éêðÊéÅZ[gÌæèûð¦ã°\nll dfs(int a,int b){\n    if(a==b)return 1;\n    else if(dp[a][b]!=-1)return dp[a][b];\n    ll res=0;\n    // ×ÖÚ®\n    for(int i=0;i<G[a].size();i++){\n        edge &e=G[a][i];\n        if(d[e.to][b]+e.cost==d[a][b]){\n            res+=dfs(e.to,b);\n        }\n    }\n    return dp[a][b]=res;\n}\nint main(){\n    while(cin>>n>>m>>p&&(n|m|p)){\n        for(int i=0;i<101;i++)G[i].clear();\n        for(int i=0;i<101;i++){\n            for(int j=0;j<101;j++){\n                if(i==j)d[i][j]==0;\n                else d[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;i++){\n            int a,b,ct;\n            cin>>a>>b>>ct;\n            edge e;\n            e.to=b;\n            e.cost=ct;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[b][a]=d[a][b]=ct;\n        }\n        warshall_floyd(n);\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dp[i][j]=-1;\n        //memset(dp,-1,sizeof(dp));\n        for(int i=0;i<p;i++){\n            int a;\n            cin>>a;\n            ll res=dfs(0,a)*dfs(a,n-1);\n            printf(\"%.10f\\n\",(double)res/(dfs(0,n-1)));\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n\t    dfs(e.to,d);\n            dp[e.to] += dp[v]*(1./cnt); \n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,0,sizeof(visited));\n        memset(dp,0,sizeof(dp));\n        dp[n-1] = 1;\n        dfs(n-1,d);\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.8f\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\tif(!cnt[a])return 0;\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <cassert>\n#include <climits>\n#include <queue>\n#include <set>\n#include <map>\n#include <valarray>\n#include <bitset>\n#include <stack>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n#define chmax(a,b) (a<b?(a=b,1):0)\n#define chmin(a,b) (a>b?(a=b,1):0)\n#define valid(y,x,h,w) (0<=y&&y<h&&0<=x&&x<w)\ntypedef long long ll;\ntypedef pair<int,int> pii;\nconst int INF = 1<<29;\nconst double PI = acos(-1);\nconst double EPS = 1e-8;\n\nvector<pii> g[100];\nint dist[100];\nint dist1[100];\ndouble dp1[100];\ndouble dp[100];\nint c[100];\n\nint main() {\n  int n,m,p;\n  while(cin>>n>>m>>p,n||m||p) {\n    REP(i,n)g[i].clear();\n    REP(i,m) {\n      int a, b, d;\n      cin>>a>>b>>d;\n      g[a].push_back(pii(b,d));\n      g[b].push_back(pii(a,d));\n    }\n    REP(i,p) cin >> c[i];\n    priority_queue<pii> Q;\n    Q.push(pii(0,0));\n    memset(dist,0x3f,sizeof(dist));\n    dist[0] = 0;\n    vector<int> order;\n    int minDist = INF;\n    while(!Q.empty()) {\n      pii p = Q.top(); Q.pop();\n      int now = p.second;\n      int dis = -p.first;\n      if (dist[now] < dis) continue;\n      if (now == n-1) {\n        minDist = dis;\n      }\n      order.push_back(now);\n      FOR(it, g[now]) {\n        int e=it->first;\n        if (dist[e] > dis + it->second) {\n          dist[e] = dis + it->second;\n          Q.push(pii(-dist[e],e));\n        }\n      }\n    }\n    \n    memset(dist1,0x3f,sizeof(dist1));\n    memset(dp1,0,sizeof(dp1));\n    Q.push(pii(0,n-1));\n    dist1[n-1] = 0;\n    dp1[n-1] = 1;\n    while(!Q.empty()) {\n      pii p = Q.top(); Q.pop();\n      int now = p.second;\n      int dis = -p.first;\n      if (dist1[now] < dis) continue;\n      FOR(it, g[now]) {\n        int e=it->first;\n        if (dist1[e] > dis + it->second) {\n          dist1[e] = dis + it->second;\n          // cout << now << \" \" << e << \" \" << dist[e] << \" \" << dist1[e] << endl;\n          if (dist[e] + dist1[e] == minDist) {\n            dp1[e] = dp1[now];\n          }\n          Q.push(pii(-dist1[e],e));\n        } else if (dist1[e] == dis + it->second) {\n          if (dist[e] + dist1[e] == minDist) {\n            dp1[e] += dp1[now];\n          }\n        }\n      }\n    }\n\n    // REP(i,n) cout << dp1[i] << \" \"; cout << endl;\n\n    memset(dp,0,sizeof(dp));\n    dp[0] = 1;\n    FOR(it, order) {\n      int e = *it;\n      FOR(jt, g[e]) {\n        int f = jt->first;\n        if (dist[e] + dist1[f] + jt->second == minDist) {\n          dp[f] += dp[e] * dp1[f]/dp1[e];\n        }\n      }\n    }\n\n    REP(i,p) {\n      printf(\"%.10f\\n\", dp[c[i]]);\n    }\n    puts(\"\");\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int INF=1000000000;\nint d[101][101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint n;\nint m;\nint p;\n\nstruct edge{\n    int to;\n    int cost;\n};\nvector<edge> G[101];\nll dp[101][101];\n//  éæÔðÊéÅZ[gÌæèûð¦ã°\nll dfs(int a,int b){\n    if(a==b)return 1;\n    else if(dp[a][b]!=-1)return dp[a][b];\n    ll res=0;\n    // ×ÖÚ®\n    for(int i=0;i<G[a].size();i++){\n        edge &e=G[a][i];\n        if(d[e.to][b]+e.cost==d[a][b])res+=dfs(e.to,b);\n    }\n    return dp[a][b]=res;\n}\nint main(){\n    while(cin>>n>>m>>p&&(n|m|p)){\n        for(int i=0;i<101;i++)G[i].clear();\n        for(int i=0;i<101;i++){\n            for(int j=0;j<101;j++){\n                if(i==j)d[i][j]=0;\n                else d[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;i++){\n            int a,b,ct;\n            cin>>a>>b>>ct;\n            edge e;\n            e.to=b;\n            e.cost=ct;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[b][a]=d[a][b]=ct;\n        }\n        warshall_floyd(n);\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dp[i][j]=-1;\n        for(int i=0;i<p;i++){\n            int a;\n            cin>>a;\n            double res=dfs(0,a)*dfs(a,n-1);\n            // àµaðoR·éÅZoHª¶ÝµÈ¢ê\n            if((d[0][a]+d[a][n-1])!=d[0][n-1])res=0;\n            printf(\"%.10f\\n\",res/(dfs(0,n-1)));\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 29;\n\n\nint N, M, P;\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *dp)\n{\n  static int v[100];\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(10);\n\n  while(cin >> N >> M >> P, N) {\n    g.clear();\n    g.resize(N);\n\n    for(int i = 0; i < M; i++) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, dp1);\n    Dijkstra(N - 1, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(dp1[N - 1] == 0) cout << 0 << endl;\n      else cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nint cnt[MAX];\nvector<Edge> G[MAX];\nbool visited[MAX];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n        dp[i] = cnt[i] = 0;\n        visited[i] = 0;\n    }\n}\n\nvector<int> dijkstra(int n){\n    vector<int> d(n, INF); d[0] = 0;\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,0));\n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost < d[e.to]){\n                d[e.to] = d[v] + e.cost;\n                Q.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n    return d;\n}\n\nvoid dijkstra2(int s,int n,vector<int> &d2){\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,s));\n    vector<int> d(n,INF); d[s] = 0;\n    if(s == n-1) cnt[s] = 1;\n    else dp[s] = 1;\n    \n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost <= d[e.to]){\n                if(s == n-1){\n                    if(d2[v]-d2[e.to] == e.cost){\n                        cnt[e.to] += cnt[v];\n                    }\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }else{\n                    dp[e.to] += dp[v]*cnt[e.to]/cnt[v];\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        vector<int> d = dijkstra(n);\n\n        dijkstra2(n-1,n,d);\n        dijkstra2(0,n,d);\n        \n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.12f\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//29\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint d[100][100];\n\nbool cmp(int a,int b){\n  return d[0][a]<d[0][b];\n}\n\nint main(){\n  for(int n,m,pp;cin>>n>>m>>pp,n|m|pp;){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\td[i][j]=(i==j)?0:1<<29;\n      }\n    }\n    int cn[100][100]={};\n    while(m--){\n      int s,t,w;\n      cin>>s>>t>>w;\n      d[s][t]=d[t][s]=w;\n      cn[s][t]=cn[t][s]=w;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    double p[100]={1};\n    int o[100];\n    for(int i=0;i<n;i++){\n      o[i]=i;\n    }\n    sort(o,o+n,cmp);\n    for(int i=0;o[i]!=n-1;i++){\n      int nb=0;\n      for(int j=0;j<n;j++){\n\tnb+=o[i]!=j&&d[o[i]][j]==cn[o[i]][j]&&d[0][o[i]]+d[o[i]][j]+d[j][n-1]==d[0][n-1];\n      }\n      for(int j=0;j<n;j++){\n\tif(o[i]!=j&&d[o[i]][j]==cn[o[i]][j]&&d[0][o[i]]+d[o[i]][j]+d[j][n-1]==d[0][n-1]){\n\t  p[j]+=p[o[i]]/nb;\n\t}\n      }\n    }\n    while(pp--){\n      int c;\n      cin>>c;\n      cout<<fixed<<p[c]<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<vector<bool> > pass(n, vector<bool>(n, false));\n    queue<int> q;\n    q.push(n-1);\n    vector<bool> check(n, false);\n    while(!q.empty()){\n        int pos = q.front();\n        q.pop();\n\n        for(int i=0; i<n; ++i){\n            if(graph[i][pos] != -1 && dist[i] + graph[i][pos] == dist[pos]){\n                pass[i][pos] = true;\n                if(!check[i]){\n                    q.push(i);\n                    check[i] = true;\n                }\n            }\n        }\n    }\n\n    multimap<int, int> m;\n    m.insert(make_pair(0, 0));\n    p.resize(n, 0.0);\n    p[0] = 1.0;\n    check.assign(n, false);\n    while(!m.empty()){\n        int cost = m.begin()->first;\n        int pos = m.begin()->second;\n        double prob = p[pos];\n        m.erase(m.begin());\n        if(check[pos])\n            continue;\n        check[pos] = true;\n\n        int num = 0;\n        for(int i=0; i<n; ++i){\n            if(pass[pos][i]){\n                ++ num;\n                m.insert(make_pair(dist[i], i));\n            }\n        }\n        for(int i=0; i<n; ++i){\n            if(pass[pos][i]){\n                p[i] += prob / num;\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint done[100] = {};\nint dp[100] = {};\nint ok[100][100] = {};\n\nvector<NODE> g[100];\nvector<NODE> g2[100][100];\nint n,m,p;\n\nint dfs(int x,int cst,int t){\n\tif( done[x] != cst ) return 0;\n\tif( x == n - 1 ) return 1;\n\tif( ok[x][t] != -1 ) return ok[x][t];\n\tint use = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tif( dfs(g[x][i].to,cst+g[x][i].cost,t+1) ){\n\t\t\tg2[x][t].push_back(g[x][i]);\n\t\t\tuse = 1;\n\t\t}\n\treturn ok[x][t] = use;\n}\nint main(){\n\twhile(cin >> n >> m >> p && (n||m||p) ){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a].push_back( NODE(b,c) );\n\t\t\tg[b].push_back( NODE(a,c) );\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) done[i] = -1;\n\t\tfor(int i = 0 ; i < 100 ; i++)\n\t\t\tfor(int j = 0 ; j < 100 ; j++)\n\t\t\t\tok[i][j] = -1 , g2[i][j].clear();\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to] != -1 ) continue;\n\t\t\telse done[q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t\tdfs(0,0,0);\n\t\tdouble dp2[101][101] = {};\n\t\tdouble res[100]={};\n\t\tdp2[0][0] = 1.0;\n\t\tfor(int i = 0 ; i < 100 ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tfor(int k = 0 ; k < g2[j][i].size() ; k++){\n\t\t\t\t\tdp2[i+1][g2[j][i][k].to] += dp2[i][j] / g2[j][i].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i < 101 ; i++)\n\t\t\tfor(int j = 0 ; j < n ; j++)\n\t\t\t\tres[j] += dp2[i][j];\n\t\t\n\t\tfor(int i = 0 ; i < p ; i++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.10lf\\n\",res[a]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "//RE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct route{\n\tint w;\n\tbitset<100> b;\n\n\troute(int w_, int p_, const bitset<100> &b_):\n\t\tw(w_), b(b_)\n\t{\n\t\tb.set(p_);\n\t}\n\t\n\tbool operator() (const route &r1, const route &r2){\n\t\treturn r1.w > r2.w;\n\t}\n} first( 0, 0, bitset<100>() );\n\nint main(){\n\tint n, m, p, a, b, w;\n\tvector<route>::iterator it1;\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<route> > rts(n);\n\t\trts[0].push_back( first );\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100];\nbool v[100],u[100];\ndouble togoal[100],prob[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28; d[0]=0;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(c==n-1)break;\n\t\t\tif(d[c]<-cc)continue;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,Q.push(mp(cc-i->second,i->first));\n\t\t}\n\t\t\n\t\trep(i,n)u[i]=v[i]=0;\n\t\trep(i,n)prob[i]=0,togoal[i]=0; togoal[n-1]=1;\n\t\tqueue<int> q; q.push(n-1);\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tif(v[c])continue; v[c]=1;\n\t\t\tfr(i,e[c])if(d[i->first]+i->second==d[c]){\n\t\t\t\ttogoal[i->first]+=togoal[c];\n\t\t\t\tif(!v[i->first])q.push(i->first);\n\t\t\t}\n\t\t}\n\t\tq=queue<int>(); q.push(0);\n\t\tprob[0]=1;\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tif(u[c])continue; u[c]=1;\n\t\t\tfr(i,e[c])if(v[i->first]&&d[i->first]==d[c]+i->second)\n\t\t\t{\n\t\t\t\tprob[i->first]+=prob[c]*togoal[i->first]/togoal[c];\n\t\t\t\tif(!u[i->first])q.push(i->first);\n\t\t\t}\n\t\t}\n\t\trep(i,p)printf(\"%.7f\\n\",prob[C[i]]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <vector>\n#include <cstring>\nusing namespace std;\n\n#define REP(i,n,m) for(int i=n;i<m;i++)\n#define rep(i,n) REP(i,0,n)\n#define INF 99999999\n\nint n,m,p;\nint t[100][100],s[100][100],dag[100][100];\nint in[100],out[100];\ndouble dp[100];\n\ndouble countRoute(int id){\n\tif(id == n-1) return 1;\n\tif(dp[id] != -1) return dp[id];\n\tdouble res = 0.0;\n\n\trep(i,n) if(dag[id][i] > 0) {\n\t\tres += countRoute(i);\n\t}\n\treturn dp[id] = res;\n}\n\nint main(void){\n\twhile(cin>>n>>m>>p, n){\n\t\trep(i,n) rep(j,n) s[i][j] = INF;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tcin>>a>>b>>c;\n\t\t\tt[a][b] = t[b][a] = s[a][b] = s[b][a] = c;\n\t\t}\n\n\t\t//ツδ渉ーツシツδδδ仰フツδ債イツド\n\t\trep(k,n) rep(i,n) rep(j,n) {\n\t\t\tif(i == j) s[i][j] = 0;\n\t\t\telse s[i][j] = min(s[i][j],s[i][k]+s[k][j]);\n\t\t}\n\n\t\t//DAGツ青カツ青ャ\n\t\tmemset(dag,0,sizeof(dag));\n\t\trep(i,n) rep(j,n) if(i != j && s[0][i] + t[i][j] + s[j][n-1] == s[0][n-1]) {\n\t\t\tdag[i][j] = s[i][j];\n\t\t}\n\n\t\t//ツ禿シツ篠淞青板づ出ツ篠淞青板づ個カツウツδ督ト\n\t\tmemset(in,0,sizeof(in));\n\t\tmemset(out,0,sizeof(out));\n\t\trep(i,n) rep(j,n) if(dag[i][j] > 0) out[i]++;\n\t\trep(j,n) rep(i,n) if(dag[i][j] > 0) in[j]++;\n\n\t\trep(i,n) dp[i] = -1;\n\t\tdouble routes = countRoute(0);\n\n\t\trep(i,p){\n\t\t\tint id;\n\t\t\tcin>>id;\n\t\t\tprintf(\"%.8lf\\n\",in[id]*out[id]/routes);\n\t\t}\n\t\tcout<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\ndouble ans[100];\nvector<int> froms[100];\n\nvoid calc( int pos, double prob ){\n\tvector<int>::iterator it;\n\tfor( it = froms[pos].begin(); it != froms[pos].end(); ++it ){\n\t\tif( *it != 0 ){\n\t\t\tans[*it] += prob;\n\t\t\tcalc( *it, prob );\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\t\tfor(;p--;)cin>>a;\n\n\t\tfor( int i = 100; i--; )\tfroms[i].clear();\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) dp[e.src][e.dst]=min(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]<dp[0][j];});\n\t\tvd ps(n); ps[0]=1;\n\t\tfor(int u:is){\n\t\t\tint cnt=0;\n\t\t\tfor(auto e:g[u]) if(dp[u][e.dst]+dp[e.dst][n-1]==dp[u][n-1]) cnt++;\n\t\t\tfor(auto e:g[u]) if(dp[u][e.dst]+dp[e.dst][n-1]==dp[u][n-1]) ps[e.dst]+=ps[u]/cnt;\n\t\t}\n\t\t\n\t\trep(i,s) printf(\"%.8f\\n\",ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vector<int> c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vector<int> d(n,1e9);\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<vi> dag(n);\n    vi vis(n,0);\n    queue<int> q;\n    q.push(n-1);\n\n    while(q.size()){\n      int v = q.front(); q.pop();\n      if(vis[v])continue;\n      vis[v] = 1;\n\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis){\n\t  dag[u].push_back(v);\n\t  if(vis[u]==0)q.push(u);\n\t}\n      }\n    }\n\n    vi deg(n,0), order;\n    for(int v=0;v<n;v++){\n      for(int u : dag[v])deg[u]++;\n    }\n    for(int v=0;v<n;v++){\n      if(deg[v]==0)q.push(v);\n    }\n\n    while(q.size()){\n      int v = q.front(); q.pop();\n      order.push_back(v);\n      for(int u : dag[v]){\n\tdeg[u]--;\n\tif(deg[u] == 0)q.push(u);\n      }\n    }\n\n    vector<long double> prob(n);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(int u : dag[v]){\n\tprob[u] += prob[v] / dag[v].size();\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n,m,p;cin>>n>>m>>p,n;){\n    double nr[100][100]={};\n    int d[100][100];\n    const int INF=1<<29;\n    fill(d[0],d[100],INF);\n    for(int i=0;i<n;i++){\n      d[i][i]=0;\n    }\n    while(m--){\n      int s,t,u;\n      cin>>s>>t>>u;\n      d[s][t]=d[t][s]=u;\n      nr[s][t]=nr[t][s]=1;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  int nd=d[j][i]+d[i][k];\n\t  if(nd<=d[j][k]){\n\t    if(nd<d[j][k]){\n\t      nr[j][k]=0;\n\t    }\n\t    d[j][k]=nd;\n\t    nr[j][k]+=nr[j][i]*nr[i][k];\n\t  }\n\t}\n      }\n    }\n    while(p--){\n      int c;\n      cin>>c;\n      cout.precision(9);\n      cout<<fixed<<((c==0||c==n-1)?1:nr[0][c]*nr[c][n-1]/nr[0][n-1])<<endl;\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<double> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid printMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\ndouble check[110];\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n  MEMSET(check, 0);\n  const int n = g.size();\n  vector<bool> visit(n, false);\n  Array dist(n, 1000000000LL);\n  priority_queue<Edge> que;\n  que.push(Edge(s, s, 0));\n  Weight ans = -1;\n  while (!que.empty()) {\n    Edge edge = que.top();\n    que.pop();\n    int from = edge.dest;\n    if (edge.weight == dist[from]) {\n      check[from] += check[edge.src];\n    }\n    check[s] = 1;\n    if (visit[from]) { continue; }\n    visit[from] = true;\n    for (int i = 0; i < (int)g[from].size(); i++) {\n      int to = g[from][i].dest;\n      Weight ncost = edge.weight + g[from][i].weight;\n      if (ncost > dist[to]) { continue; }\n      dist[to] = ncost;\n      que.push(Edge(from, to, ncost));\n    }\n  }\n  return ans;\n}\n\nstruct Point {\n  int x;\n  int y;\n  Weight cost;\n  Point() {;}\n  Point(int x, int y, Weight c) : x(x), y(y), cost(c) {;}\n  bool operator<(const Point &rhs) const { return cost > rhs.cost; }\n};\nWeight DijkstraMatrix(const Matrix &field, Point s, Point t) {\n  const int h = field.size();\n  assert(h > 0);\n  const int w = field[0].size();\n  vector<vector<bool> > visit(h, vector<bool>(w, false));\n  Matrix dist(h, Array(w, 1000000000LL));\n  priority_queue<Point> que;\n  que.push(Point(s.x, s.y, 0));\n  Weight ans = -1;\n  while (!que.empty()) {\n    Point p = que.top();\n    que.pop();\n    if (visit[p.y][p.x]) { continue; }\n    visit[p.y][p.x] = true;\n    if (p.x == t.x && p.y == t.y) {\n      ans = p.cost;\n      break;\n    }\n    for (int i = 0; i < 4; i++) {\n      const int dx[4] = { 1, 0, -1, 0 };\n      const int dy[4] = { 0, 1, 0, -1 };\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      if (nx < 0 || nx >= w || ny < 0 || ny >= h || visit[ny][nx]) { continue; }\n      Weight ncost = p.cost + field[ny][nx];\n      if (ncost >= dist[ny][nx]) { continue; }\n      que.push(Point(nx, ny, ncost));\n    }\n  }\n  return ans;\n}\n\ndouble cnt[2][110];\n\nint n, m, p;\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &p), n|m|p) {\n    Graph g(n);\n    REP(i, m) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      g[f].push_back(Edge(f, t, c));\n      g[t].push_back(Edge(t, f, c));\n    }\n    priority_queue<Edge> que;\n    Dijkstra(g, 0, n - 1);\n    memcpy(cnt[0], check, sizeof(check));\n    Dijkstra(g, n - 1, 0);\n    memcpy(cnt[1], check, sizeof(check));\n    REP(i, p) {\n      int index;\n      scanf(\"%d\", &index);\n      printf(\"%.8lf\\n\", cnt[0][index] * cnt[1][index] / cnt[0][n - 1]);\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == p.first) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    visited[e.to] = 0;\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];\n                    Q2.push(pii(d[0][e.to], e.to));\n                }\n            }\n        }\n        \n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//29\n#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint d[100][100];\n\nbool cmp(int a,int b){\n  return d[0][a]<d[0][b];\n}\n\nint main(){\n  for(int n,m,pp;cin>>n>>m>>pp,n|m|pp;){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\td[i][j]=(i==j)?0:1<<29;\n      }\n    }\n    int cn[100][100]={};\n    while(m--){\n      int s,t,w;\n      cin>>s>>t>>w;\n      d[s][t]=d[t][s]=w;\n      cn[s][t]=cn[t][s]=w;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    double p[100]={1};\n    int o[100];\n    for(int i=0;i<n;i++){\n      o[i]=i;\n    }\n    sort(o,o+n,cmp);\n    for(int i=0;o[i]!=n-1;i++){\n      int nb=0;\n      for(int j=0;j<n;j++){\n\tnb+=o[i]!=j&&d[0][o[i]]+cn[o[i]][j]+d[j][n-1]==d[0][n-1];\n      }\n      for(int j=0;j<n;j++){\n\tif(o[i]!=j&&d[0][o[i]]+cn[o[i]][j]+d[j][n-1]==d[0][n-1]){\n\t  p[j]+=p[o[i]]/nb;\n\t}\n      }\n    }\n    while(pp--){\n      int c;\n      cin>>c;\n      cout<<fixed<<p[c]<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += (dp[v] * cnt[e.to]) / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n//if(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += (dp[v] * cnt[e.to]) / (double)cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n||m||k;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) D[u].push_back(v);\n\t\t}\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\trep(u,n){\n\t\t\tbool vis[100]={}; vis[u]=true;\n\t\t\tdp[u][u]=1;\n\t\t\tqueue<int> Q; Q.push(u);\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint v=Q.front(); Q.pop();\n\t\t\t\trep(i,D[v].size()){\n\t\t\t\t\tint w=D[v][i];\n\t\t\t\t\tif(!vis[w]){\n\t\t\t\t\t\tvis[w]=true;\n\t\t\t\t\t\tQ.push(w);\n\t\t\t\t\t}\n\t\t\t\t\tdp[u][w]+=dp[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M, C;\n\ntypedef long long ll;\n\nstruct Edge {\n  int to; ll cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nvector<int> cs;\n\n//vector<vector<int> > prev_;\nint prev_[110][110];\nint pcnt[110];\ndouble ans[110];\n\nstruct state {\n  int curr; ll cost;\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nstruct ST {\n  int curr; double prob;\n};\n\nll const INF = 1LL<<40;\n\nint main() {\n  \n  while(cin >> N >> M >> C && (N|M|C)) {\n    g.clear(); g.resize(N);\n    cs.clear(); cs.resize(C);\n    rep(i, M) {\n      int a, b; ll c; cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c});\n      g[b].push_back((Edge){a, c});\n    }\n    rep(i, C) cin >> cs[i];\n    \n    ll dist[N];\n    fill(dist, dist+N, INF);\n    dist[0] = 0;\n    \n    rep(i, N) pcnt[i] = 0;\n    \n    priority_queue<state> pq;\n    pq.push((state){0, dist[0]});\n    while(!pq.empty()) {\n      int curr = pq.top().curr;\n      ll cost = pq.top().cost;\n      pq.pop();\n      \n      rep(i, g[curr].size()) {\n        Edge& e = g[curr][i];\n        if(dist[e.to] == cost+e.cost) {\n          prev_[e.to][pcnt[e.to]++] = curr;\n        }\n        if(dist[e.to] <= cost+e.cost) { continue; }\n        pcnt[e.to] = 0;\n        prev_[e.to][pcnt[e.to]++] = curr;\n        dist[e.to] = cost+e.cost;\n        pq.push((state){e.to, dist[e.to]});\n      }\n    }\n    \n    rep(i, N) ans[i] = 0.;\n    \n    queue<ST> q;\n    q.push((ST){N-1, 1.0});\n    while(!q.empty()) {\n      int curr = q.front().curr;\n      double prob = q.front().prob;\n      q.pop();\n      \n      ans[curr] += prob;\n      \n      rep(i, pcnt[curr]) {\n        q.push((ST){prev_[curr][i], prob/pcnt[curr]});\n      }\n    }\n    \n    rep(i, C) {\n      printf(\"%.10f\\n\", ans[cs[i]]);\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\n#include <iostream>\n#include <math.h>\n#include <assert.h>\n#include <vector>\n#include <queue>\n\nusing namespace std;\ntypedef long long ll;\nstatic const double EPS = 1e-9;\nstatic const double PI = acos(-1.0);\n\n#define REP(i, n) for (int i = 0; i < (int)(n); i++)\n#define FOR(i, s, n) for (int i = (s); i < (int)(n); i++)\n#define FOREQ(i, s, n) for (int i = (s); i <= (int)(n); i++)\n#define FORIT(it, c) for (__typeof((c).begin())it = (c).begin(); it != (c).end(); it++)\n#define DEC(i, s) for (int i = (s); i >= 0; i--)\n\n#define SIZE(v) (int)((v).size())\n#define MEMSET(v, h) memset((v), h, sizeof(v))\n#define FIND(m, w) ((m).find(w) != (m).end())\n\n\ntypedef int Weight;\nstruct Edge {\n  int src;\n  int dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight) : src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    if (weight != rhs.weight) { return weight > rhs.weight; }\n    if (src != rhs.src) { return src < rhs.src; }\n    return dest < rhs.dest;\n  }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nvoid printMatrix(const Matrix &matrix) {\n  for (int y = 0; y < (int)matrix.size(); y++) {\n    for (int x = 0; x < (int)matrix[y].size(); x++) {\n      printf(\"%d \", matrix[y][x]);\n    }\n    puts(\"\");\n  }\n}\n\ndouble check[110];\n\nWeight Dijkstra(const Graph &g, int s, int t) {\n  MEMSET(check, 0);\n  const int n = g.size();\n  vector<bool> visit(n, false);\n  Array dist(n, 1000000000LL);\n  priority_queue<Edge> que;\n  que.push(Edge(s, s, 0));\n  Weight ans = -1;\n  while (!que.empty()) {\n    Edge edge = que.top();\n    que.pop();\n    int from = edge.dest;\n    if (edge.weight == dist[from]) {\n      check[from] += check[edge.src];\n    }\n    check[s] = 1;\n    if (visit[from]) { continue; }\n    visit[from] = true;\n    for (int i = 0; i < (int)g[from].size(); i++) {\n      int to = g[from][i].dest;\n      Weight ncost = edge.weight + g[from][i].weight;\n      if (ncost > dist[to]) { continue; }\n      dist[to] = ncost;\n      que.push(Edge(from, to, ncost));\n    }\n  }\n  return ans;\n}\n\nstruct Point {\n  int x;\n  int y;\n  Weight cost;\n  Point() {;}\n  Point(int x, int y, Weight c) : x(x), y(y), cost(c) {;}\n  bool operator<(const Point &rhs) const { return cost > rhs.cost; }\n};\nWeight DijkstraMatrix(const Matrix &field, Point s, Point t) {\n  const int h = field.size();\n  assert(h > 0);\n  const int w = field[0].size();\n  vector<vector<bool> > visit(h, vector<bool>(w, false));\n  Matrix dist(h, Array(w, 1000000000LL));\n  priority_queue<Point> que;\n  que.push(Point(s.x, s.y, 0));\n  Weight ans = -1;\n  while (!que.empty()) {\n    Point p = que.top();\n    que.pop();\n    if (visit[p.y][p.x]) { continue; }\n    visit[p.y][p.x] = true;\n    if (p.x == t.x && p.y == t.y) {\n      ans = p.cost;\n      break;\n    }\n    for (int i = 0; i < 4; i++) {\n      const int dx[4] = { 1, 0, -1, 0 };\n      const int dy[4] = { 0, 1, 0, -1 };\n      int nx = p.x + dx[i];\n      int ny = p.y + dy[i];\n      if (nx < 0 || nx >= w || ny < 0 || ny >= h || visit[ny][nx]) { continue; }\n      Weight ncost = p.cost + field[ny][nx];\n      if (ncost >= dist[ny][nx]) { continue; }\n      que.push(Point(nx, ny, ncost));\n    }\n  }\n  return ans;\n}\n\ndouble cnt[2][110];\n\nint n, m, p;\nint main() {\n  while (scanf(\"%d %d %d\", &n, &m, &p), n|m|p) {\n    Graph g(n);\n    REP(i, m) {\n      int f, t, c;\n      scanf(\"%d %d %d\", &f, &t, &c);\n      g[f].push_back(Edge(f, t, c));\n      g[t].push_back(Edge(t, f, c));\n    }\n    priority_queue<Edge> que;\n    Dijkstra(g, 0, n - 1);\n    memcpy(cnt[0], check, sizeof(check));\n    Dijkstra(g, n - 1, 0);\n    memcpy(cnt[1], check, sizeof(check));\n    REP(i, p) {\n      int index;\n      scanf(\"%d\", &index);\n      double q = cnt[0][index] * cnt[1][index] / cnt[0][n - 1];\n      printf(\"%.8lf\\n\", q);\n      assert(0.0 <= q && q <= 1.0);\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nint main(){\n  for(int n,m,p;cin>>n>>m>>p,n;){\n    double nr[100][100]={};\n    int d[100][100];\n    const int INF=1<<29;\n    fill(d[0],d[100],INF);\n    for(int i=0;i<n;i++){\n      d[i][i]=0;\n    }\n    while(m--){\n      int s,t,u;\n      cin>>s>>t>>u;\n      d[s][t]=d[t][s]=u;\n      nr[s][t]=nr[t][s]=1;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  int nd=d[j][i]+d[i][k];\n\t  if(nd<=d[j][k]){\n\t    if(nd<d[j][k]){\n\t      nr[j][k]=0;\n\t    }\n\t    d[j][k]=nd;\n\t    nr[j][k]+=nr[j][i]*nr[i][k];\n\t  }\n\t}\n      }\n    }\n    while(p--){\n      int c;\n      cin>>c;\n      cout.precision(9);\n      cout<<fixed<<nr[0][c]*nr[c][n-1]/nr[0][n-1]<<endl;\n    }\n    cout<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 30;\n\nint N, M, P;\nint v1[100], v2[100];\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, int *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(8);\n\n  while(cin >> N >> M >> P, N) {\n    g.resize(N);\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n\n    g.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int INF = 100000000;\ntypedef pair<int, int> PI;\n\nint main(){\n    int N, M, P;\n    while(cin >> N >> M >> P && N){\n        int d[100][100] = {};\n        int edge[100][100] = {};\n        REP(i, N) REP(j, N) d[i][j] = (i == j ? 0 : INF);\n        REP(i, N) REP(j, N) edge[i][j] = INF;\n        REP(i, M){\n            int a, b, c;\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            edge[a][b] = edge[b][a] = c;\n        }\n        REP(k, N) REP(i, N) REP(j, N) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        priority_queue<PI> que;\n        REP(i, N){\n            que.push(PI(d[i][N - 1], i));\n        }\n        vector<double> prob(N, 0);\n        prob[0] = 1;\n        while(!que.empty()){\n            int i = que.top().second;\n            que.pop();\n            if(prob[i] == 0) continue;\n            vector<int> next;\n            REP(j, N) if(d[i][N - 1] == edge[i][j] + d[j][N - 1]){\n                next.push_back(j);\n            }\n            for(int j : next){\n                prob[j] += prob[i] / next.size();\n            }\n        }\n        REP(i, P){\n            int a;\n            cin >> a;\n            printf(\"%.8f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) D[u].push_back(v);\n\t\t}\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\t// rep(u,n){\n\t\t\t// bool vis[100]={}; vis[u]=true;\n\t\t\t// dp[u][u]=1;\n\t\t\t// queue<int> Q; Q.push(u);\n\t\t\t// while(!Q.empty()){\n\t\t\t\t// int v=Q.front(); Q.pop();\n\t\t\t\t// rep(i,D[v].size()){\n\t\t\t\t\t// int w=D[v][i];\n\t\t\t\t\t// if(!vis[w]){\n\t\t\t\t\t\t// vis[w]=true;\n\t\t\t\t\t\t// Q.push(w);\n\t\t\t\t\t// }\n\t\t\t\t\t// dp[u][w]+=dp[u][v];\n\t\t\t\t// }\n\t\t\t// }\n\t\t// }\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) dp[u][v]=1;\n\t\t}\n\t\trep(w,n) rep(u,n) rep(v,n) dp[u][v]+=dp[u][w]*dp[w][v];\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <vector>\n#include <list>\n#include <cmath>\n#include <fstream>\n#include <algorithm>\n#include <string>\n#include <queue>\n#include <set>\n#include <map>\n#include <complex>\n#include <iterator>\n#include <cstdlib>\n#include <cstring>\n#include <sstream>\n\nusing namespace std;\n\nconst double EPS=(1e-10);\ntypedef long long ll;\ntypedef pair<int,int> pii;\nbool EQ(double a,double b){\n  return abs((a)-(b))<EPS;\n}\nvoid fast_stream(){\n\tstd::ios_base::sync_with_stdio(0);\n}\nconst int INF=1000000000;\nint d[101][101];\nvoid warshall_floyd(int V){\n    for(int i=0;i<V;i++)\n        for(int j=0;j<V;j++)\n            for(int k=0;k<V;k++)\n                d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n}\n\nint n;\nint m;\nint p;\n\nstruct edge{\n    int to;\n    int cost;\n};\nvector<edge> G[101];\nll dp[101][101];\n//  éæÔðÊéÅZ[gÌæèûð¦ã°\nll dfs(int a,int b){\n    if(a==b)return 1;\n    else if(dp[a][b]!=-1)return dp[a][b];\n    ll res=0;\n    // ×ÖÚ®\n    for(int i=0;i<G[a].size();i++){\n        edge &e=G[a][i];\n        if(d[e.to][b]+e.cost==d[a][b]){\n            res+=dfs(e.to,b);\n        }\n    }\n    return dp[a][b]=res;\n}\nint main(){\n    while(cin>>n>>m>>p&&(n|m|p)){\n        for(int i=0;i<101;i++)G[i].clear();\n        for(int i=0;i<101;i++){\n            for(int j=0;j<101;j++){\n                if(i==j)d[i][j]=0;\n                else d[i][j]=INF;\n            }\n        }\n        for(int i=0;i<m;i++){\n            int a,b,ct;\n            cin>>a>>b>>ct;\n            edge e;\n            e.to=b;\n            e.cost=ct;\n            G[a].push_back(e);\n            e.to=a;\n            G[b].push_back(e);\n            d[b][a]=d[a][b]=ct;\n        }\n        warshall_floyd(n);\n        for(int i=0;i<101;i++)for(int j=0;j<101;j++)dp[i][j]=-1;\n        //memset(dp,-1,sizeof(dp));\n        for(int i=0;i<p;i++){\n            int a;\n            cin>>a;\n            ll res=dfs(0,a)*dfs(a,n-1);\n            if(d[0][a]+d[a][n-1]!=d[0][n-1])res=0;\n            printf(\"%.10f\\n\",(double)res/(dfs(0,n-1)));\n        }\n        cout<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Overflow\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tlong double cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 100000000 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tlong double cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n\t\t\tlong double r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)(cnt2[a] / cnt2[n-1]) );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\nlong double dp[MAX];\nlong double cnt[MAX];\nvector<Edge> G[MAX];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n        dp[i] = cnt[i] = 0;\n    }\n}\n\nvector<int> dijkstra(int n){\n    vector<int> d(n, INF); d[0] = 0;\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,0));\n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost < d[e.to]){\n                d[e.to] = d[v] + e.cost;\n                Q.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n    return d;\n}\n\nvoid dijkstra2(int s,int n,vector<int> &d2){\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,s));\n    vector<int> d(n,INF); d[s] = 0;\n    if(s == n-1) cnt[s] = 1;\n    else dp[s] = 1;\n\n    bool used[MAX][MAX] = {{}};\n    \n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost <= d[e.to]){\n                if(s == n-1){\n                    if(d2[v]-d2[e.to] == e.cost){\n                        cnt[e.to] += cnt[v];\n                    }\n                }else{\n                    if(!used[v][e.to]){\n                        used[v][e.to] = used[e.to][v] = 1;\n                        dp[e.to] += dp[v]*cnt[e.to]/cnt[v];\n                    }\n                }\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        vector<int> d = dijkstra(n);\n\n        dijkstra2(n-1,n,d);\n        dijkstra2(0,n,d);\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.12Lf\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define INF (1<<28)\n#define MAX 105\nstruct edge{int to,cost;};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<edge> G[MAX];\nint n,m,p;\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n  }\n}\n\nlong long d[MAX][MAX];\ndouble cnt[MAX][MAX];\nvoid dijkstra(int si){\n  for(int i=0;i<MAX;i++)d[si][i]=INF,cnt[si][i]=0;\n  priority_queue<state> Q;\n  d[si][si]=0;\n  cnt[si][si]=1;\n  Q.push((state){si,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[si][s.pos])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(d[si][e.to]<s.cost+e.cost)continue;\n      else if(d[si][e.to]==s.cost+e.cost){\n\tcnt[si][e.to]+=cnt[si][s.pos];\n      }else{\n\tcnt[si][e.to]=cnt[si][s.pos];\n\td[si][e.to]=s.cost+e.cost;\n\tQ.push((state){e.to,d[si][e.to]});\n      }\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>p;\n    if(n==0&&m==0&&p==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    for(int i=0;i<n;i++)\n      dijkstra(i);\n\n    for(int i=0;i<p;i++){\n      int a;\n      scanf(\"%d\",&a);\n      if(d[0][a]+d[a][n-1]!=d[0][n-1]){\n\tcout<<\"0.0\"<<endl;\n      }else{\n\tdouble x=cnt[0][a],x2=cnt[a][n-1],y=cnt[0][n-1];\n\tprintf(\"%.8f\\n\",x/y*x2);\n      }\n\n\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int INF = 100000000;\ntypedef pair<int, int> PI;\n\nint main(){\n    int N, M, P;\n    while(cin >> N >> M >> P && N){\n        int d[100][100] = {};\n        int edge[100][100] = {};\n        REP(i, N) REP(j, N) d[i][j] = (i == j ? 0 : INF);\n        REP(i, N) REP(j, N) edge[i][j] = INF;\n        REP(i, M){\n            int a, b, c;\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            edge[a][b] = edge[b][a] = c;\n            assert(c > 0);\n        }\n        REP(k, N) REP(i, N) REP(j, N) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        priority_queue<PI> que;\n        REP(i, N){\n            que.push(PI(d[i][N - 1], i));\n        }\n        vector<double> prob(N, 0);\n        prob[0] = 1;\n        while(!que.empty()){\n            int i = que.top().second;\n            que.pop();\n            if(prob[i] == 0) continue;\n            vector<int> next;\n            REP(j, N) if(d[i][N - 1] == edge[i][j] + d[j][N - 1]){\n                next.push_back(j);\n            }\n            for(int j : next){\n                prob[j] += prob[i] / next.size();\n            }\n        }\n        REP(i, P){\n            int a;\n            cin >> a;\n            printf(\"%.8f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//MLE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct route{\n\tint w;\n\tbitset<100> b;\n\n\troute(int w_, int p_, const bitset<100> &b_):\n\t\tw(w_), b(b_)\n\t{\n\t\tb.set(p_);\n\t}\n\t\n\tbool operator() (const route &r1, const route &r2){\n\t\treturn r1.w > r2.w;\n\t}\n};\n\nint main(){\n\tint n, m, p, a, b, w;\n\tvector<route>::iterator it1;\n\t\n\tvector<route> dummy;\n\tdummy.push_back( route( -1, 0, bitset<100>() ) );\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<route> > rts(n);\n\t\trts[0].push_back( route( 0, 0, bitset<100>() ) );\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\n\t\t\tif( p.first != rts[p.second].front().w ){\tcontinue;\t}\n\n\t\t\trts[p.second].front().w = -1;\n\t\t\tvector<route> &rt = rts[p.second];\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( it1 = rt.begin(); it1 != rt.end(); ++it1 ){\n\t\t\t\tvector<pii>::iterator it2;\n\t\t\t\tfor( it2 = wt.begin(); it2 != wt.end(); ++it2 ){\n\t\t\t\t\tw = p.first + it2->second;\n\t\t\t\t\tif(\n\t\t\t\t\t\trts[it2->first].empty() ||\n\t\t\t\t\t\trts[it2->first].front().w > w\n\t\t\t\t\t){\n\t\t\t\t\t\trts[it2->first].clear();\n\t\t\t\t\t\trts[it2->first].push_back(\n\t\t\t\t\t\t\troute( w, it2->first, it1->b )\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tqu.push( pii( w, it2->first ) );\n\n\t\t\t\t\t}\n\t\t\t\t\telse if( rts[it2->first].front().w == w ){\n\t\t\t\t\t\trts[it2->first].push_back(\n\t\t\t\t\t\t\troute( w, it2->first, it1->b )\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\trt = dummy;\n\t\t}\n\n\t\tvector<double> ans(n);\n\t\tdouble x = 1.0 / rts[n-1].size();\n\t\tfor( it1 = rts[n-1].begin(); it1 != rts[n-1].end(); ++it1 ){\n\t\t\tfor( int i = 0; i < n; i++ ){\n\t\t\t\tif( it1->b[i] ){\n\t\t\t\t\tans[i] += x;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%f\\n\", ans[a] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100];\nbool v[100],u[100]; double cnt[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28;\n\t\td[0]=0;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(c==n-1)break;\n\t\t\tif(d[c]<-cc)continue;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,Q.push(mp(cc-i->second,i->first));\n\t\t}\n\t\t\n\t\trep(i,n)u[i]=v[i]=0,cnt[i]=0;\n\t\tqueue<int> q; q.push(n-1);\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tv[c]=1;\n\t\t\tfr(i,e[c])if(!v[i->first]&&d[i->first]+i->second==d[c])q.push(i->first);\n\t\t}\n\t\tq=queue<int>(); q.push(0);\n\t\tcnt[0]=1;\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tif(u[c])continue; u[c]=1;\n\t\t\tfr(i,e[c])if(v[i->first]&&d[i->first]==d[c]+i->second)\n\t\t\t{\n\t\t\t\tcnt[i->first]+=cnt[c];\n\t\t\t\tif(!u[i->first])q.push(i->first);\n\t\t\t}\n\t\t}\n\t\trep(i,p)printf(\"%.7f\\n\",cnt[C[i]]/cnt[n-1]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint done[110] = {};\ndouble dp[110] = {} , rdp[110] = {};\n\nvector<NODE> g[100];\nint n,m,p;\n\ndouble dfs(int x,int cst){\n\tif( done[x] != cst ) return 0;\n\tif( x == n - 1 ) return 1;\n\tif( dp[x] != -1 ) return dp[x];\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tans += dfs(g[x][i].to,cst+g[x][i].cost);\n\treturn dp[x] = ans;\n}\n\ndouble rdfs(int x,int cst){\n\tif( done[n-1] - done[x] != cst ) return 0;\n\tif( x == 0 ) return 1;\n\tif( rdp[x] != -1 ) return rdp[x];\n\tdouble ans = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tans += rdfs(g[x][i].to,cst+g[x][i].cost);\n\treturn rdp[x] = ans;\n}\nint main(){\n\twhile(cin >> n >> m >> p && (n||m||p) ){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a].push_back( NODE(b,c) );\n\t\t\tg[b].push_back( NODE(a,c) );\n\t\t}\n\t\tfor(int i = 0 ; i < 110 ; i++) done[i] = -1;\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\t\tdp[i] = rdp[i] = -1;\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to] != -1 ) continue;\n\t\t\telse done[q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t\tdouble all = dfs(0,0);\n\t\t//cout << all << endl;\n\t\tfor(int i = 0 ; i < p ; i++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif( done[a] == -1 ){\n\t\t\t\tprintf(\"%.8lf\\n\",0.0);\n\t\t\t}else{\n\t\t\t\tdouble A = dfs(a,done[a]);\n\t\t\t\tdouble B = rdfs(a,done[n-1] - done[a]);\n\t\t\t\tprintf(\"%.8lf\\n\",1.0 * A*B / all);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) dp[e.src][e.dst]=min(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\tvi dist=dp[0];\n\t\t\n\t\tvector<long double> ps(n,0); ps[n-1]=1;\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return dist[i]>dist[j];});\n\t\tfor(auto u:is){\n\t\t\tint cnt=0;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) cnt++;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) ps[e.dst]+=ps[e.src]/cnt;\n\t\t}\n\t\t\n\t\trep(i,s) printf(\"%.8f\\n\",(double)ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == p.first) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n        dp[N-1] = 1;\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint done[110] = {};\nlong long dp[110] = {} , rdp[110] = {};\n\nvector<NODE> g[100];\nint n,m,p;\n\nlong long dfs(int x,int cst){\n\tif( done[x] != cst ) return 0;\n\tif( x == n - 1 ) return 1;\n\tif( dp[x] != -1 ) return dp[x];\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tans += dfs(g[x][i].to,cst+g[x][i].cost);\n\treturn dp[x] = ans;\n}\n\nlong long rdfs(int x,int cst){\n\tif( done[n-1] - done[x] != cst ) return 0;\n\tif( x == 0 ) return 1;\n\tif( rdp[x] != -1 ) return rdp[x];\n\tlong long ans = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tans += rdfs(g[x][i].to,cst+g[x][i].cost);\n\treturn rdp[x] = ans;\n}\nint main(){\n\twhile(cin >> n >> m >> p && (n||m||p) ){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a].push_back( NODE(b,c) );\n\t\t\tg[b].push_back( NODE(a,c) );\n\t\t}\n\t\tfor(int i = 0 ; i < 110 ; i++) done[i] = -1;\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\t\tdp[i] = rdp[i] = -1;\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to] != -1 ) continue;\n\t\t\telse done[q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t\tlong long all = dfs(0,0);\n\t\t//cout << all << endl;\n\t\tfor(int i = 0 ; i < p ; i++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tif( done[a] == -1 ){\n\t\t\t\tprintf(\"%.10lf\\n\",0.0);\n\t\t\t}else{\n\t\t\t\tlong long A = dfs(a,done[a]);\n\t\t\t\tlong long B = rdfs(a,done[n-1] - done[a]);\n\t\t\t\tprintf(\"%.10lf\\n\",1.0 * A*B / all);\n\t\t\t}\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "// AOJ1058 Winter Bells\n\n#include <iostream>\n#include <vector>\n#include <string.h>\n\nusing namespace std;\n\ntypedef vector< vector<int> > graph;\n\nvoid visit(graph &g, vector<int> &order, vector<bool> &mark, int pos){\n\tfor(int i=0;i<g[pos].size();i++){\n\t\tint next = g[pos][i];\n\t\tif(mark[next]) continue;\n\t\tvisit(g, order, mark, next);\n\t}\n\tmark[pos] = true;\n\torder.push_back(pos);\n}\n\nvector<int> topologicalSort(graph &g){\n\tvector<int> res;\n\tvector<bool> mark(g.size(), false);\n\tfor(int i=0;i<g.size();i++){\n\t\tif(mark[i]) continue;\n\t\tvisit(g, res, mark, i);\n\t}\n\treverse(res.begin(), res.end());\n\treturn res;\n}\n\nint main(){\n\tint n, m, r;\n\tint cost[100][100];\n\twhile(cin >> n >> m >> r, n){\n\t\tvector< vector< pair<int, int> > > g(n);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j] = i==j ? 0 : 100000000;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint p, q, c; cin >> p >> q >> c;\n\t\t\tcost[p][q] = cost[q][p] = min(cost[p][q], c);\n\t\t\tg[p].push_back(make_pair(q,c));\n\t\t\tg[q].push_back(make_pair(p,c));\n\t\t}\n\t\tfor(int k=0;k<n;k++)\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\t\tcost[i][j] = min(cost[i][j], cost[i][k]+cost[k][j]);\n\t\tgraph h(n);\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(cost[0][i]+cost[i][n-1]!=cost[0][n-1]) continue;\n\t\t\tfor(int j=0;j<g[i].size();j++){\n\t\t\t\tif(cost[i][n-1]==cost[g[i][j].first][n-1]+g[i][j].second){\n\t\t\t\t\th[i].push_back(g[i][j].first);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvector<int> ord = topologicalSort(h);\n\t\tvector<double> prob(n, 0.0);\n\t\tprob[0] = 1.0;\n\t\tfor(int i=0;i<ord.size();i++){\n\t\t\tfor(int j=0;j<h[ord[i]].size();j++)\n\t\t\t\tprob[h[ord[i]][j]] += (double)prob[ord[i]]/h[ord[i]].size();\n\t\t}\n\t\tfor(int i=0;i<r;i++){\n\t\t\tint t; cin >> t;\n\t\t\tprintf(\"%.8lf\\n\", prob[t]);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//RE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nstruct route{\n\tint w;\n\tbitset<100> b;\n\n\troute(int w_, int p_, const bitset<100> &b_):\n\t\tw(w_), b(b_)\n\t{\n\t\tb.set(p_);\n\t}\n\t\n\tbool operator() (const route &r1, const route &r2){\n\t\treturn r1.w > r2.w;\n\t}\n} first( 0, 0, bitset<100>() );\n\nint main(){\n\tint n, m, p, a, b, w;\n\tvector<route>::iterator it1;\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<route> > rts(n);\n\t\trts[0].push_back( first );\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\t\t\tif( p.first == rts[p.second].front().w ){\n\t\t\t\trts[p.second].front().w = -1;\n\t\t\t\tvector<route> &rt = rts[p.second];\n\t\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\t\tfor( it1 = rt.begin(); it1 != rt.end(); ++it1 ){\n\t\t\t\t\tvector<pii>::iterator it2;\n\t\t\t\t\tfor( it2 = wt.begin(); it2 != wt.end(); ++it2 ){\n\t\t\t\t\t\tw = p.first + it2->second;\n\t\t\t\t\t\tif(\n\t\t\t\t\t\t\trts[it2->first].empty() ||\n\t\t\t\t\t\t\trts[it2->first].front().w > w\n\t\t\t\t\t\t){\n\t\t\t\t\t\t\trts[it2->first].clear();\n\t\t\t\t\t\t\trts[it2->first].push_back(\n\t\t\t\t\t\t\t\troute( w, it2->first, it1->b )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif( it2->first != n - 1 ){\n\t\t\t\t\t\t\t\tqu.push( pii( w, it2->first ) );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if( rts[it2->first].front().w == w ){\n\t\t\t\t\t\t\trts[it2->first].push_back(\n\t\t\t\t\t\t\t\troute( w, it2->first, it1->b )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\tint d[100],dp[100];\n\t\trep(u,n){\n\t\t\td[u]=(u==0?0:INF);\n\t\t\tdp[u]=(u==0?1:0);\n\t\t}\n\t\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,0));\n\t\tvector<int> D[100]; // 最短経路 DAG の辺の向きを逆転したもの\n\t\twhile(!Q.empty()){\n\t\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\t\tif(d[u]<d_now) continue;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\t\tif(d[v]>d[u]+cost){\n\t\t\t\t\td[v]=d[u]+cost;\n\t\t\t\t\tdp[v]=dp[u];\n\t\t\t\t\tQ.push(make_pair(-d[v],v));\n\n\t\t\t\t\tD[v].clear();\n\t\t\t\t\tD[v].push_back(u);\n\t\t\t\t}\n\t\t\t\telse if(d[v]==d[u]+cost){\n\t\t\t\t\tdp[v]+=dp[u];\n\t\t\t\t\tD[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tbool cl[100][100]={}; // 推移閉包\n\t\trep(u,n) rep(i,D[u].size()) {\n\t\t\tint v=D[u][i];\n\t\t\tcl[u][v]=true;\n\t\t}\n\t\trep(w,n) rep(u,n) rep(v,n) cl[u][v]|=cl[u][w]&cl[w][v];\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tif(cl[n-1][c]) printf(\"%.9f\\n\",(double)dp[c]/dp[n-1]);\n\t\t\telse           puts(\"0\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 150\n#define INF INT_MAX/2\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\nlong double dp[MAX];\nlong double cnt[MAX];\nvector<Edge> G[MAX];\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n        dp[i] = cnt[i] = 0;\n    }\n}\n\nvector<int> dijkstra(int n){\n    vector<int> d(n, INF); d[0] = 0;\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,0));\n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost < d[e.to]){\n                d[e.to] = d[v] + e.cost;\n                Q.push(pii(d[e.to],e.to));\n            }\n        }\n    }\n    return d;\n}\n\nvoid dijkstra2(int s,int n,vector<int> &d2){\n    priority_queue<pii,vector<pii>,greater<pii> > Q;\n    Q.push(pii(0,s));\n    vector<int> d(n,INF); d[s] = 0;\n    if(s == n-1) cnt[s] = 1;\n    else dp[s] = 1;\n    \n    while(!Q.empty()){\n        pii p = Q.top(); Q.pop();\n        int v = p.second;\n        if(d[v] < p.first) continue;\n        for(int i = 0 ; i < (int)G[v].size() ; i++){\n            Edge e = G[v][i];\n            if(d[v] + e.cost <= d[e.to]){\n                if(s == n-1){\n                    if(d2[v]-d2[e.to] == e.cost){\n                        cnt[e.to] += cnt[v];\n                    }\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }else{\n                    dp[e.to] += dp[v]*cnt[e.to]/cnt[v];\n                    if(d[v] + e.cost < d[e.to]){\n                        d[e.to] = d[v] + e.cost;\n                        Q.push(pii(d[e.to],e.to));\n                    }\n                }\n            }\n        }\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        vector<int> d = dijkstra(n);\n\n        dijkstra2(n-1,n,d);\n        dijkstra2(0,n,d);\n        \n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.12Lf\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 29;\n\n\nint N, M, P;\nint v1[100], v2[100];\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, int *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(10);\n\n  while(cin >> N >> M >> P, N) {\n    g.resize(N);\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n\n    g.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<map>\n#include<set>\n#include<queue>\n#include<cstdio>\n#include<climits>\n#include<cmath>\n#include<cstring>\n#include<string>\n#include<sstream>\n#include<numeric>\n#include<cassert>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define rep(i,s,n) for(int i=(s); i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n#define IN(x,s,g) ((x) >= (s) && (x) < (g))\n#define ISIN(x,y,w,h) (IN((x),0,(w)) && IN((y),0,(h)))\n#define print(x) printf(\"%d\\n\",x)\n\nusing namespace std;\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nconst int _dx[] = {0,1,0,-1};\nconst int _dy[] = {-1,0,1,0};\n\nint getInt(){\n  int ret = 0,c;\n  c = getchar();\n  while(!isdigit(c)) c = getchar();\n  while(isdigit(c)){\n    ret *= 10;\n    ret += c - '0';\n    c = getchar();\n  }\n  return ret;\n}\n\nint g[100][100];\nint c[100];\nint memo[100];\nint r[100];\n\nint main(){\n  while(true){\n    int n = getInt();\n    int m = getInt();\n    int p = getInt();\n\n    if(n+m+p == 0) break;\n\n    REP(i,n) REP(j,n) g[i][j] = 0;\n    REP(i,n){\n      memo[i] = -1;\n      r[i] = 0;\n    }\n\n    REP(i,m){\n      int a = getInt();\n      int b = getInt();\n      int c = getInt();\n\n      g[a][b] = g[b][a] = c;\n    }\n\n    REP(i,p) c[i] = getInt();\n\n    typedef pair<int,int> data;\n    priority_queue<data,vector<data>,greater<data> > pq;\n\n    pq.push(mp(0,0));\n    int cnt = 0;\n\n    while(cnt != n){\n      data d = pq.top();\n      int cost = d.f;\n      int pos  = d.s;\n\n      pq.pop();\n\n      if(memo[pos] != -1)\n        continue;\n\n      memo[pos] = cost;\n      cnt++;\n\n      REP(i,n)\n        if(g[pos][i] && memo[i] == -1)\n          pq.push(mp(cost + g[pos][i], i));\n    }\n\n    vector<pair<int,int> > v(n);\n    REP(i,n){\n      v[i].f = memo[i];\n      v[i].s = i;\n    }\n    sort(v.begin(), v.end());\n    r[0] = 1;\n\n    REP(i,n){\n      int pos = v[i].s;\n\n      REP(j,n){\n        if(g[pos][j] != 0 && memo[j] == memo[pos] + g[pos][j])\n          r[j] += r[pos];\n      }\n    }\n\n    //REP(i,n) printf(\"%d: %d,%d\\n\",i,memo[i],r[i]);\n\n#define MAX 10000000\n    REP(i,n) REP(j,n){\n      if(i == j) continue;\n      if(g[i][j] == 0) g[i][j] = MAX;\n    }\n\n    REP(k,n) REP(i,n) REP(j,n){\n      g[i][j] = min(g[i][j], g[i][k] + g[k][j]);\n    }\n\n    int all = r[n-1];\n    REP(i,p)\n      if(g[0][c[i]] + g[c[i]][n-1] == memo[n-1])\n        printf(\"%.8f\\n\",(double)r[c[i]] / all);\n      else\n        printf(\"%.8f\\n\",0.0);\n    puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M, C;\n\ntypedef long long ll;\n\nstruct Edge {\n  int to; ll cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\n\ndouble cntpath[110][110];\n\nstruct state {\n  int curr; ll cost;\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nstruct ST {\n  int curr; double prob;\n};\n\nll const INF = 1LL<<40;\n\nint main() {\n  \n  while(cin >> N >> M >> C && (N|M|C)) {\n    g.clear(); g.resize(N);\n    \n    rep(i, M) {\n      int a, b; ll c; cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c});\n      g[b].push_back((Edge){a, c});\n    }\n    \n    ll dist[N][N];\n    fill(dist[0], dist[0]+N*N, INF);\n    \n    rep(S, N) {\n      dist[S][S] = 0;\n      cntpath[S][S] = 1;\n      priority_queue<state> pq;\n      pq.push((state){S, dist[S][S]});\n      while(!pq.empty()) {\n        int curr = pq.top().curr;\n        ll cost = pq.top().cost;\n        pq.pop();\n      \n        rep(i, g[curr].size()) {\n          Edge& e = g[curr][i];\n          if(dist[S][e.to] == cost+e.cost) {\n            cntpath[S][e.to] += cntpath[S][curr];\n          }\n          if(dist[S][e.to] <= cost+e.cost) { continue; }\n          cntpath[S][e.to] = cntpath[S][curr];\n          dist[S][e.to] = cost+e.cost;\n          pq.push((state){e.to, dist[S][e.to]});\n        }\n      }\n    }\n    \n    rep(i, C) {\n      int q; cin >> q;\n      if(dist[0][q]+dist[q][N-1] == dist[0][N-1]) {\n        printf(\"%.10f\\n\", cntpath[0][q]/cntpath[0][N-1]*cntpath[q][N-1]);\n      }\n      else {\n        printf(\"%.10f\\n\", 0.);\n      }\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vector<int> c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vector<int> d(n,1e9);\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<int> deg(n,0), order;\n    for(int v=0;v<n;v++){\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[u] == d[v] + dis)deg[u]++;\n      }\n    }\n\n    queue<int> q;\n    for(int v=0;v<n;v++){\n      if(deg[v]==0)q.push(v);\n    }\n\n    while(q.size()){\n      int v = q.front(); q.pop();\n      order.push_back(v);\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[u] == d[v] + dis){\n\t  deg[u]--;\n\t  if(deg[u] == 0)q.push(u);\n\t}\n      }\n    }\n\n    vector<long double> prob(n);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      int k = 0;\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[u] == d[v] + dis)k++;\n      }\n\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[u] == d[v] + dis)prob[u] += prob[v]/k;\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,k;cin>>n>>m>>k && n|m|k;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(k);\n\t\trep(i,k) cin>>cs[i];\n\t\t\n\t\tvi dist(n,INF);\n\t\t{\n\t\t\tpriority_queue<Edge,vector<Edge>,greater<Edge>> pq;\n\t\t\tpq.emplace(-1,0,0);\n\t\t\twhile(pq.size()){\n\t\t\t\tEdge cur=pq.top(); pq.pop();\n\t\t\t\tif(dist[cur.dst]!=INF) continue;\n\t\t\t\tdist[cur.dst]=cur.weight;\n\t\t\t\tfor(auto e:g[cur.dst])\n\t\t\t\t\tpq.emplace(e.src,e.dst,cur.weight+e.weight);\n\t\t\t}\n\t\t}\n\t\tvd ps(n,0); ps[n-1]=1;\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return dist[i]>dist[j];});\n\t\tfor(auto u:is){\n\t\t\tint cnt=0;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) cnt++;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) ps[e.dst]+=ps[e.src]/cnt;\n\t\t}\n\t\t\n\t\trep(i,k) printf(\"%.8f\\n\",ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vi c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vi d(n,1e9), order;\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n      order.push_back(v);\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<int> cnt(n,0);\n    cnt[n-1] = 1;\n    for(int i=order.size()-1;i>=0;i--){\n      int v = order[i];\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis)cnt[u] += cnt[v];\n      }\n    }\n\n    vector<double> prob(n,0);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(edge e : g[v]){\n\tint nxtd = d[v] + e.first, u = e.second;\n\tif(d[u] == nxtd){\n\t  prob[u] += prob[v] * cnt[u] / cnt[v];\n\t}\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "//29\n#include<iostream>\n#include<queue>\n#include<algorithm>\n\nusing namespace std;\n\nstruct S{\n  int v,d;\n  double p;\n  bool operator<(S a)const{\n    return d>a.d;\n  }\n};\n\nint main(){\n  for(int n,m,pp;cin>>n>>m>>pp,n|m|pp;){\n    int d[100][100];\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\td[i][j]=(i==j)?0:1<<29;\n      }\n    }\n    bool cn[100][100];\n    while(m--){\n      int s,t,w;\n      cin>>s>>t>>w;\n      d[s][t]=d[t][s]=w;\n      cn[s][t]=cn[t][s]=true;\n    }\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tfor(int k=0;k<n;k++){\n\t  d[j][k]=min(d[j][k],d[j][i]+d[i][k]);\n\t}\n      }\n    }\n    priority_queue<S> que;\n    S is={0,0,1};\n    que.push(is);\n    double p[100]={};\n    while(!que.empty()){\n      S c=que.top();\n      que.pop();\n      p[c.v]+=c.p;\n      int nb=0;\n      for(int i=0;i<n;i++){\n\tnb+=c.d+d[c.v][i]==d[0][i]&&cn[c.v][i];\n      }\n      for(int i=0;i<n;i++){\n\tif(c.d+d[c.v][i]==d[0][i]&&cn[c.v][i]){\n\t  S n={i,d[0][i],c.p/nb};\n\t  que.push(n);\n\t}\n      }\n    }\n    while(pp--){\n      int c;\n      cin>>c;\n      cout<<fixed<<p[c]<<endl;\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\tint d[100];\n\t\tlong double dp[100]; // dp[u] := ( 0->u 間の最短経路の個数 ) ( 大きくなるので実数で )\n\t\trep(u,n){\n\t\t\td[u]=(u==0?0:INF);\n\t\t\tdp[u]=(u==0?1:0);\n\t\t}\n\t\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\t\tif(d[u]<d_now) continue;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\t\tif(d[v]>d[u]+cost){\n\t\t\t\t\td[v]=d[u]+cost;\n\t\t\t\t\tdp[v]=dp[u];\n\t\t\t\t\tQ.push(make_pair(-d[v],v));\n\n\t\t\t\t\tD[v].clear();\n\t\t\t\t\tD[v].push_back(u); // 辺の向きを逆にして保存しておいて、あとで直す\n\t\t\t\t}\n\t\t\t\telse if(d[v]==d[u]+cost){\n\t\t\t\t\tdp[v]+=dp[u];\n\t\t\t\t\tD[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvector<int> tmp[100];\n\t\trep(u,n) tmp[u]=D[u], D[u].clear();\n\t\trep(u,n) rep(i,tmp[u].size()) D[tmp[u][i]].push_back(u);\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\n\t\t\tlong double dp2[100]; // dp2[u] := ( c->u 間の最短経路の個数 )\n\t\t\trep(u,n) dp2[u]=(u==c?1:0);\n\t\t\tqueue<int> Q; Q.push(c);\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint u=Q.front(); Q.pop();\n\t\t\t\trep(i,D[u].size()){\n\t\t\t\t\tint v=D[u][i];\n\t\t\t\t\tif(dp2[v]==0) Q.push(v);\n\t\t\t\t\tdp2[v]+=dp2[u];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%.9Lf\\n\",dp[c]*dp2[n-1]/dp[n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M, C;\n\ntypedef long long ll;\n\nstruct Edge {\n  int to; ll cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nvector<int> cs;\n\nvector<vector<int> > prev_;\ndouble ans[510];\n\nstruct state {\n  int curr; ll cost;\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nstruct ST {\n  int curr; double prob;\n};\n\nll const INF = 1LL<<40;\n\nint main() {\n  \n  while(cin >> N >> M >> C && (N|M|C)) {\n    g.clear(); g.resize(N);\n    cs.clear(); cs.resize(C);\n    rep(i, M) {\n      int a, b; ll c; cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c});\n      g[b].push_back((Edge){a, c});\n    }\n    rep(i, C) cin >> cs[i];\n    \n    ll dist[N];\n    fill(dist, dist+N, INF);\n    dist[0] = 0;\n    \n    prev_.clear(); prev_.resize(N);\n    \n    priority_queue<state> pq;\n    pq.push((state){0, dist[0]});\n    while(!pq.empty()) {\n      int curr = pq.top().curr;\n      ll cost = pq.top().cost;\n      pq.pop();\n      \n      rep(i, g[curr].size()) {\n        Edge& e = g[curr][i];\n        if(dist[e.to] == cost+e.cost) {\n          prev_[e.to].push_back(curr);\n        }\n        if(dist[e.to] <= cost+e.cost) { continue; }\n        prev_[e.to].clear();\n        prev_[e.to].push_back(curr);\n        dist[e.to] = cost+e.cost;\n        pq.push((state){e.to, dist[e.to]});\n      }\n    }\n    \n    rep(i, 200) ans[i] = 0.;\n    \n    queue<ST> q;\n    q.push((ST){N-1, 1.0});\n    while(!q.empty()) {\n      int curr = q.front().curr;\n      double prob = q.front().prob;\n      q.pop();\n      \n      ans[curr] += prob;\n      \n      rep(i, prev_[curr].size()) {\n        q.push((ST){prev_[curr][i], prob/prev_[curr].size()});\n      }\n    }\n    \n    rep(i, C) {\n      printf(\"%.10f\\n\", ans[cs[i]]);\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Data {\n  int cur;\n  ll w;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w < data.w;\n    return cur < data.cur;\n  }\n};\n\n\nconst ll LLINF = LLONG_MAX;\nconst int MAX_V = 110;\nint n,m,p;\nll fw[110][110];\ndouble dp[MAX_V];\nvector<Data> G[MAX_V];\n\nint main(){\n  bool F = true;\n  while( cin >> n >> m >> p, n|m|p ){\n    if( !F ) puts(\"\");\n    F = false;\n    rep(i,n) G[i].clear();\n    rep(i,n) rep(j,n) fw[i][j] = ((i==j)?0:LLINF);\n    rep(i,m) {\n      int s,t;\n      ll c;\n      cin >> s >> t >> c;\n      G[s].push_back((Data){t,c});\n      G[t].push_back((Data){s,c});\n      fw[s][t] = fw[t][s] = c;\n    }\n\n    rep(k,n) rep(i,n) rep(j,n) if( fw[i][k] != LLINF && fw[k][j] != LLINF ) fw[i][j] = min(fw[i][j],\n\t\t\t\t\t\t\t\t\t\t\t   fw[i][k]+fw[k][j]);\n\n    vector<Data> vec;\n    rep(i,n) vec.push_back((Data){i,fw[0][i]});\n    sort(vec.begin(),vec.end());  \n    rep(i,n) dp[i] = 0;\n    dp[0] = 1;\n    rep(i,vec.size()) {\n      int cur = vec[i].cur;\n      if( fw[0][cur] == LLINF || fw[cur][n-1] == LLINF ) continue;\n      ll weight = vec[i].w;\n      double cnt = 0;\n      \n\n      rep(j,G[cur].size()) if( cur != G[cur][j].cur ){\n\tint next = G[cur][j].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][cur] + G[cur][j].w + fw[next][n-1] == fw[0][n-1] ) {\n\t  ++cnt;\n\t}\n      }\n\n      rep(j,G[cur].size()) if( cur != G[cur][j].cur ){\n\tint next = G[cur][j].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][cur] + G[cur][j].w + fw[next][n-1] == fw[0][n-1] ) {\n\t    dp[next] += dp[cur] * ( 1.0 / cnt );\n\t}\n      }\n      \n    }\n\n    rep(i,p){\n      int pos;\n      cin >> pos;\n      printf(\"%.10f\\n\",dp[pos]);\n    } //puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\ndouble dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<double>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     double tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\ndouble dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<double>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     double tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<double> num1(n, -1), num2(n, -1);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n, 0.0);\n    for(int i=0; i<n; ++i){\n        if(num1[i] != -1 && num2[i] != -1)\n            p[i] = num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = graph[b][a] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\nlong double dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            dfs(e.to,d);\n            dp[e.to] *= dp[v]*(1./cnt); \n        }\n    }\n}\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,0,sizeof(visited));\n        fill(dp,dp+MAX,1);\n        dfs(n-1,d);\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            printf(\"%.15Lf\\n\",dp[c]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int N=100;\n\nint vertex[N];\nvector<vector<int> >edge(N);\nvector<P> v(N);\n\n//ツ陳クツ点xツつゥツづァツ陳クツ点yツづ鳴行ツつュツ本ツ青板づ個古つ青板づーツ仰づ淞づゥ\nvoid F(int x,int y,int n,double(&dp)[N])\n{\n\tint i,j,k;\n\tfill(dp,dp+N,0.);\n\tdp[x]=1;\n\tvector<P>::iterator ite1,ite2;\n\tite1=lower_bound(v.begin(),v.end(),P(vertex[x],0));\n\tite2=lower_bound(v.begin(),v.end(),P(vertex[y]+1,-1));\n\tfor(;ite1!=ite2;++ite1)\n\t{\n\t\tj=ite1->second;\n\t\tfor(k=0;k<edge[j].size();++k)dp[edge[j][k]]+=dp[j];\n\t}\n}\nint main()\n{\n\tint n,m,p,x,y,w,i,dist[N][N],X=0x3f3f3f3f;\n\twhile(scanf(\"%d%d%d\",&n,&m,&p),n)\n\t{\n\t\tmemset(dist,X,sizeof(dist));\n\t\tmemset(vertex,X,sizeof(vertex));\n\t\tfor(i=0;i<n;++i)edge[i].clear();\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\t\tdist[y][x]=dist[x][y]=w;\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> >q;\n\t\tq.push(P(0,0));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p(q.top());q.pop();\n\t\t\tif(vertex[p.second]<=p.first)continue;\n\t\t\tvertex[p.second]=p.first;\n\t\t\tfor(i=0;i<n;++i)if((w=dist[p.second][i])!=X)q.push(P(p.first+w,i));\n\t\t}\n\t\tbool flag[N]={};\n\t\tq.push(P(0,n-1));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p(q.top());q.pop();\n\t\t\tfor(i=0;i<n;++i)\n\t\t\t\tif(w=dist[i][p.second],vertex[i]+w==vertex[p.second])\n\t\t\t\t{\n\t\t\t\t\tedge[i].push_back(p.second);\n\t\t\t\t\tif(!flag[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(P(0,i));\n\t\t\t\t\t\tflag[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tdouble dp[N];\n\t\tfor(i=0;i<n;++i)v[i]=P(vertex[i],i);\n\t\tfor(i=n;i<N;++i)v[i]=P(X,X);\n\t\tsort(v.begin(),v.end());\n\t\tF(0,n-1,n,dp);\n\t\twhile(p--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tif(x!=n-1&&edge[x].empty())printf(\"%.9f\\n\",0.);\n\t\t\telse\n\t\t\t{\n\t\t\t\tdouble dp2[N]={},dp3[N]={};\n\t\t\t\tF(x,n-1,n,dp2);\n\t\t\t\tF(0,x,n,dp3);\n\t\t\t\tprintf(\"%.9f\\n\",dp2[n-1]*dp3[x]/dp[n-1]);\n\t\t\t}\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define REP(i,a,b) for(int i=a;i<(int)b;i++)\n#define rep(i,n) REP(i,0,n)\n\nint N, M, C;\n\ntypedef long long ll;\n\nstruct Edge {\n  int to; ll cost;\n};\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nGraph g;\nvector<int> cs;\n\nvector<vector<int> > prev_;\ndouble ans[110];\n\nstruct state {\n  int curr; ll cost;\n  bool operator < (state const& s) const {\n    return cost > s.cost;\n  }\n};\n\nstruct ST {\n  int curr; double prob;\n};\n\nint const INF = 1<<29;\n\nint main() {\n  \n  while(cin >> N >> M >> C && (N|M|C)) {\n    g.clear(); g.resize(N);\n    cs.clear(); cs.resize(C);\n    rep(i, M) {\n      int a, b; ll c; cin >> a >> b >> c;\n      g[a].push_back((Edge){b, c});\n      g[b].push_back((Edge){a, c});\n    }\n    rep(i, C) cin >> cs[i];\n    \n    ll dist[N];\n    fill(dist, dist+N, INF);\n    dist[0] = 0;\n    \n    prev_.clear(); prev_.resize(N);\n    \n    priority_queue<state> pq;\n    pq.push((state){0, dist[0]});\n    while(!pq.empty()) {\n      int curr = pq.top().curr;\n      ll cost = pq.top().cost;\n      pq.pop();\n      \n      rep(i, g[curr].size()) {\n        Edge& e = g[curr][i];\n        if(dist[e.to] == cost+e.cost) {\n          prev_[e.to].push_back(curr);\n        }\n        if(dist[e.to] <= cost+e.cost) { continue; }\n        prev_[e.to].clear();\n        prev_[e.to].push_back(curr);\n        dist[e.to] = cost+e.cost;\n        pq.push((state){e.to, dist[e.to]});\n      }\n    }\n    \n    rep(i, N) ans[i] = 0.;\n    \n    queue<ST> q;\n    q.push((ST){N-1, 1.0});\n    while(!q.empty()) {\n      int curr = q.front().curr;\n      double prob = q.front().prob;\n      q.pop();\n      \n      ans[curr] += prob;\n      \n      rep(i, prev_[curr].size()) {\n        q.push((ST){prev_[curr][i], prob/prev_[curr].size()});\n      }\n    }\n    \n    rep(i, C) {\n      printf(\"%.10f\\n\", ans[cs[i]]);\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\nstruct Edge{\n\tEdge(int arg_to,int arg_cost){\n\t\tto = arg_to;\n\t\tcost = arg_cost;\n\t}\n\tint to,cost;\n};\n\nenum Type{\n\tfrom_S,\n\tfrom_G,\n};\n\nstruct Info{\n\tInfo(int arg_node_id,int arg_sum_cost){\n\t\tnode_id = arg_node_id;\n\t\tsum_cost = arg_sum_cost;\n\t}\n\tbool operator<(const struct Info &arg) const{ //総コストの昇順(PQ)\n\t\treturn sum_cost > arg.sum_cost;\n\t}\n\tint node_id,sum_cost;\n};\n\nint N,M,P;\nint C[100001];\nint min_dist[100][2];\nbool calculated[100][2];\ndouble path_num[100][2],ans[100];\nvector<Edge> G[100],rev_G[100];\nvector<int> DAG_G[100],rev_DAG_G[100];\n\nvoid dijkstra(Type type,int start){\n\n\tfor(int i = 0; i < N; i++)min_dist[i][type] = BIG_NUM;\n\tmin_dist[start][type] = 0;\n\n\tpriority_queue<Info> Q;\n\tQ.push(Info(start,0));\n\n\tint next_node,next_cost;\n\n\twhile(!Q.empty()){\n\n\t\tif(Q.top().sum_cost > min_dist[Q.top().node_id][type]){\n\t\t\tQ.pop();\n\t\t}else{\n\n\t\t\tif(type == from_S){\n\t\t\t\tfor(int i = 0; i < G[Q.top().node_id].size(); i++){\n\t\t\t\t\tnext_node = G[Q.top().node_id][i].to;\n\t\t\t\t\tnext_cost = Q.top().sum_cost+G[Q.top().node_id][i].cost;\n\n\t\t\t\t\tif(min_dist[next_node][type] > next_cost){\n\t\t\t\t\t\tmin_dist[next_node][type] = next_cost;\n\t\t\t\t\t\tQ.push(Info(next_node,next_cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}else{ //type == from_G\n\n\t\t\t\tfor(int i = 0; i < rev_G[Q.top().node_id].size(); i++){\n\t\t\t\t\tnext_node = rev_G[Q.top().node_id][i].to;\n\t\t\t\t\tnext_cost = Q.top().sum_cost+rev_G[Q.top().node_id][i].cost;\n\n\t\t\t\t\tif(min_dist[next_node][type] > next_cost){\n\t\t\t\t\t\tmin_dist[next_node][type] = next_cost;\n\t\t\t\t\t\tQ.push(Info(next_node,next_cost));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tQ.pop();\n\t\t}\n\t}\n}\n\n//from_S:あるノードからゴール方向への経路数、from_G:あるノードからスタート方向への経路数\ndouble recursive(Type type,int node_id,int goal){\n\n\tif(calculated[node_id][type])return path_num[node_id][type];\n\n\tif(node_id == goal)return 1.0;\n\n\tif(type == from_S){\n\n\t\tfor(int i = 0; i < DAG_G[node_id].size(); i++){\n\t\t\tpath_num[node_id][type] += recursive(type,DAG_G[node_id][i],goal);\n\t\t}\n\n\t}else{ //type == from_G\n\n\t\tfor(int i = 0; i < rev_DAG_G[node_id].size(); i++){\n\t\t\tpath_num[node_id][type] += recursive(type,rev_DAG_G[node_id][i],goal);\n\t\t}\n\t}\n\tcalculated[node_id][type] = true;\n\n\treturn path_num[node_id][type];\n}\n\nvoid func(){\n\n\tfor(int i = 0; i < N; i++){\n\t\tG[i].clear();\n\t\trev_G[i].clear();\n\t\tDAG_G[i].clear();\n\t\trev_DAG_G[i].clear();\n\t}\n\n\tint from,to,cost;\n\tfor(int loop = 0; loop < M; loop++){\n\t\tscanf(\"%d %d %d\",&from,&to,&cost);\n\t\tG[from].push_back(Edge(to,cost));\n\t\trev_G[to].push_back(Edge(from,cost));\n\t}\n\n\tfor(int i = 0; i < P; i++)scanf(\"%d\",&C[i]);\n\n\tdijkstra(from_S,0);\n\tdijkstra(from_G,N-1);\n\n\tint next_node;\n\t//最短経路DAGを作る\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < G[i].size(); k++){\n\t\t\tnext_node = G[i][k].to;\n\t\t\tif(min_dist[i][from_S]+G[i][k].cost+min_dist[next_node][from_G] == min_dist[N-1][from_S]){ //最短経路上の辺\n\t\t\t\tDAG_G[i].push_back(next_node);\n\t\t\t\trev_DAG_G[next_node].push_back(i);\n\t\t\t}\n\t\t}\n\t}\n\n\tfor(int i = 0; i < N; i++){\n\t\tfor(int k = 0; k < 2; k++){\n\t\t\tcalculated[i][k] = false;\n\t\t\tpath_num[i][k] = 0;\n\t\t}\n\t}\n\n\t//再帰的に、そのノードを経由する経路数を計算する\n\trecursive(from_S,0,N-1);\n\trecursive(from_G,N-1,0);\n\n\tfor(int i = 0; i < N; i++){\n\t\tans[i] = path_num[i][from_G]*path_num[i][from_S]/path_num[0][from_S];\n\t}\n\n\tfor(int i = 0; i < P; i++){\n\t\tprintf(\"%.10lf\\n\",ans[C[i]]);\n\t}\n\tprintf(\"\\n\");\n}\n\nint main(){\n\n\twhile(true){\n\t\tscanf(\"%d %d %d\",&N,&M,&P);\n\t\tif(N == 0 && M == 0 && P == 0)break;\n\n\t\tfunc();\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\nif(p.second<0||p.second>=n||it->second<0||it->second>=n)return 1;\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint g[110][110];\nvector<int>g2[110];\nint p[11000];\nint q[11000];\nint r[11000];\npair<int,int> pt[110];\ndouble dp[110];\ndouble dp2[110];\nint main(){\n    int a,b,c;\n    while(scanf(\"%d%d%d\",&a,&b,&c),a){\n        for(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=999999999;\n        for(int i=0;i<a;i++)g[i][i]=0;\n        for(int i=0;i<a;i++){g2[i].clear();}\n        for(int i=0;i<b;i++){\n            scanf(\"%d%d%d\",p+i,q+i,r+i);\n            g[p[i]][q[i]]=g[q[i]][p[i]]=r[i];\n        }\n        for(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        for(int i=0;i<b;i++){\n            int P=p[i];\n            int Q=q[i];\n            int R=r[i];\n            if(g[0][P]+R==g[0][Q]&&g[Q][a-1]+R==g[P][a-1]){\n                g2[P].push_back(Q);\n            }\n            swap(P,Q);\n            if(g[0][P]+R==g[0][Q]&&g[Q][a-1]+R==g[P][a-1]){\n                g2[P].push_back(Q);\n            }\n        }\n        for(int i=0;i<110;i++)dp[i]=0;\n        dp[0]=1;\n        for(int i=0;i<a;i++)pt[i]=make_pair(g[0][i],i);\n        std::sort(pt,pt+a);\n        for(int i=0;i<a;i++){\n            int at=pt[i].second;\n            for(int j=0;j<g2[at].size();j++){\n                dp[g2[at][j]]+=dp[at];\n            }\n        }\n\t\tdouble tot=dp[a-1];\n\t\t\n        for(int i=0;i<c;i++){\n            int t;scanf(\"%d\",&t);\n\t\t\tfor(int j=0;j<a;j++)dp2[j]=0;\n\t\t\tdp2[t]=1;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint at=pt[j].second;\n\t\t\t\tfor(int k=0;k<g2[at].size();k++){\n\t\t\t\t\tdp2[g2[at][k]]+=dp2[at];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%.12f\\n\",dp2[a-1]/tot*dp[t]);\n        }\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vi c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vi d(n,1e9), order;\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n      order.push_back(v);\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<double> cnt(n,0);\n    cnt[n-1] = 1;\n    for(int i=order.size()-1;i>=0;i--){\n      int v = order[i];\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis)cnt[u] += cnt[v];\n      }\n    }\n\n    vector<double> prob(n,0);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(edge e : g[v]){\n\tint nxtd = d[v] + e.first, u = e.second;\n\tif(d[u] == nxtd){\n\t  prob[u] += prob[v] * cnt[u] / cnt[v];\n\t}\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define INF (1<<28)\n#define MAX 105\nstruct edge{int to,cost;};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<edge> G[MAX];\nint T[MAX][MAX];\nint n,m,p;\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n    for(int j=0;j<MAX;j++){\n      T[i][j]=(i==j?0:INF);\n    }\n  }\n}\n\nlong long d[MAX],cnt[MAX];\nvoid dijkstra(){\n  for(int i=0;i<MAX;i++)d[i]=INF,cnt[i]=0;\n  priority_queue<state> Q;\n  d[0]=0;\n  cnt[0]=1;\n  Q.push((state){0,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[s.pos])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(d[e.to]<s.cost+e.cost)continue;\n      else if(d[e.to]==s.cost+e.cost){\n\tcnt[e.to]+=cnt[s.pos];\n      }else{\n\tcnt[e.to]=cnt[s.pos];\n\td[e.to]=s.cost+e.cost;\n\tQ.push((state){e.to,d[e.to]});\n      }\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>p;\n    if(n==0&&m==0&&p==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n      T[a][b]=min(T[a][b],c);\n    }\n    for(int k=0;k<n;k++)\n      for(int i=0;i<n;i++)\n\tfor(int j=0;j<n;j++)\n\t  T[i][j]=min(T[i][j],T[i][k]+T[k][j]);\n    dijkstra();\n    for(int i=0;i<p;i++){\n      int a;\n      scanf(\"%d\",&a);\n      if(T[0][a]+T[a][n-1]!=T[0][n-1]){\n\tcout<<\"0.0\"<<endl;\n      }else{\n\tdouble x=cnt[a],y=cnt[n-1];\n\tprintf(\"%.8f\\n\",x/y);\n      }\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Edge {\n  int v, c;\n  Edge() {}\n  Edge(int v, int c) : v(v), c(c) {}\n};\n\nstruct State {\n  int v, c;\n  State() {}\n  State(int v, int c) : v(v), c(c) {}\n  bool operator <(const State &s) const {\n    return c < s.c;\n  }\n  bool operator >(const State &s) const {\n    return c > s.c;\n  }\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int a, int b, int c, Graph *g) {\n  if(max(a,b)+1 > g->size()) {\n    g->resize(max(a,b)+1);\n  }\n  (*g)[a].push_back(Edge(b,c));\n  (*g)[b].push_back(Edge(a,c));\n}\n\nconst int MAXN = 101;\nconst int INF = 1<<28;\nint N, M, P;\nGraph G;\nvector<int> C;\nvector<int> pre[MAXN];\nint cost[MAXN];\nlli num[MAXN];\nbool flag[MAXN];\n\nvoid dijkstra(int src, const Graph &g) {\n  priority_queue<State, vector<State>, greater<State> > que;\n  fill(cost, cost+MAXN, INF);\n  fill(num, num+MAXN, 0LL);\n  fill(pre, pre+MAXN, vector<int>());\n  cost[src] = 0;\n  num[src] = 1;\n  que.push(State(src, 0));\n  while(!que.empty()) {\n    State s = que.top();\n    que.pop();\n    if(cost[s.v] < s.c) continue;\n    for(int i = 0; i < g[s.v].size(); ++i) {\n      int nv = g[s.v][i].v;\n      int nc = s.c + g[s.v][i].c;\n      if(cost[nv] == nc) {\n\tnum[nv] += num[s.v];\n\tpre[nv].push_back(s.v);\n      } else if(cost[nv] > nc) {\n\tnum[nv] = num[s.v];\n\tcost[nv] = nc;\n\tpre[nv].clear();\n\tpre[nv].push_back(s.v);\n\tque.push(State(nv,nc));\n      }\n    }\n  }\n}\n\nvoid rec(int v) {\n  flag[v] = true;\n  for(int i = 0; i < pre[v].size(); ++i) {\n    if(!flag[pre[v][i]]) {\n      rec(pre[v][i]);\n    }\n  }\n}\n\nint main() {\n  while(cin >> N >> M >> P && (N|M|P)) {\n    G.clear();\n    for(int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      addEdge(a,b,c,&G);\n    }\n    C.resize(P);\n    for(int i = 0; i < P; ++i) {\n      cin >> C[i];\n    }\n    dijkstra(0, G);\n    fill(flag, flag+MAXN, false);\n    rec(N-1);\n    for(int i = 0; i < P; ++i) {\n      double res = 0;\n      if(flag[C[i]]) {\n\tres = (double)num[C[i]]/(double)num[N-1];\n      }\n      printf(\"%.10f\\n\", res);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Edge {\n  int v, c;\n  Edge() {}\n  Edge(int v, int c) : v(v), c(c) {}\n};\n\nstruct State {\n  int v, c;\n  State() {}\n  State(int v, int c) : v(v), c(c) {}\n  bool operator <(const State &s) const {\n    return c < s.c;\n  }\n  bool operator >(const State &s) const {\n    return c > s.c;\n  }\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int a, int b, int c, Graph *g) {\n  if(max(a,b)+1 > g->size()) {\n    g->resize(max(a,b)+1);\n  }\n  (*g)[a].push_back(Edge(b,c));\n  (*g)[b].push_back(Edge(a,c));\n}\n\nconst int MAXN = 101;\nconst int INF = 1<<28;\nint N, M, P;\nGraph G;\nvector<int> C;\nvector<int> pre[MAXN];\nint cost[MAXN];\nlli num[MAXN];\nbool flag[MAXN];\n\nvoid dijkstra(int src, const Graph &g) {\n  priority_queue<State, vector<State>, greater<State> > que;\n  fill(cost, cost+MAXN, INF);\n  fill(num, num+MAXN, 0LL);\n  fill(pre, pre+MAXN, vector<int>());\n  cost[src] = 0;\n  num[src] = 1;\n  que.push(State(src, 0));\n  while(!que.empty()) {\n    State s = que.top();\n    que.pop();\n    if(cost[s.v] < s.c) continue;\n    for(int i = 0; i < g[s.v].size(); ++i) {\n      int nv = g[s.v][i].v;\n      int nc = s.c + g[s.v][i].c;\n      if(cost[nv] == nc) {\n\tnum[nv] += num[s.v];\n\tpre[nv].push_back(s.v);\n      } else if(cost[nv] > nc) {\n\tnum[nv] = num[s.v];\n\tcost[nv] = nc;\n\tpre[nv].clear();\n\tpre[nv].push_back(s.v);\n\tque.push(State(nv,nc));\n      }\n    }\n  }\n}\n\nvoid rec(int v) {\n  flag[v] = true;\n  for(int i = 0; i < pre[v].size(); ++i) {\n    rec(pre[v][i]);\n  }\n}\n\nint main() {\n  while(cin >> N >> M >> P && (N|M|P)) {\n    G.clear();\n    for(int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      addEdge(a,b,c,&G);\n    }\n    C.resize(P);\n    for(int i = 0; i < P; ++i) {\n      cin >> C[i];\n    }\n    dijkstra(0, G);\n    fill(flag, flag+MAXN, false);\n    rec(N-1);\n    for(int i = 0; i < P; ++i) {\n      double res = 0;\n      if(flag[C[i]]) {\n\tres = (double)num[C[i]]/(double)num[N-1];\n      }\n      printf(\"%.10f\\n\", res);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\n\t\t\t\t\tif(!cnt[it->second])while(1);\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vector<int> c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vector<int> d(n,1e9);\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<vi> dag(n);\n    vector<long long> cnt(n,0);\n    cnt[n-1] = 1;\n    vi vis(n,0);\n    queue<int> q;\n    q.push(n-1);\n\n    while(q.size()){\n      int v = q.front(); q.pop();\n      if(vis[v])continue;\n      vis[v] = 1;\n\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis){\n\t  cnt[u] += cnt[v];\n\t  dag[u].push_back(v);\n\t  if(vis[u]==0)q.push(u);\n\t}\n      }\n    }\n\n    vi deg(n,0), order;\n    for(int v=0;v<n;v++){\n      for(int u : dag[v])deg[u]++;\n    }\n    for(int v=0;v<n;v++){\n      if(deg[v]==0)q.push(v);\n    }\n\n    while(q.size()){\n      int v = q.front(); q.pop();\n      order.push_back(v);\n      for(int u : dag[v]){\n\tdeg[u]--;\n\tif(deg[u] == 0)q.push(u);\n      }\n    }\n\n    vector<long double> prob(n,0);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(int u : dag[v]){\n\tprob[u] += prob[v] * cnt[u] / cnt[v];\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114\n#define INF 1e9\ntypedef pair<int,int> pii;\n\nstruct Edge{\n    int to,cost;\n    Edge(int to,int cost) :\n        to(to),cost(cost) {}\n};\n\ndouble dp[MAX];\nbool visited[MAX];\nvector<Edge> G[MAX];\n\nvoid dfs(int v,vector<int> &d){\n    if(visited[v]) return;\n    visited[v] = 1;\n    int cnt = 0;\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            cnt++;\n        }\n    }\n    for(int i = 0 ; i < (int)G[v].size() ; i++){\n        Edge e = G[v][i];\n        if(d[v]-d[e.to] == e.cost){\n            dfs(e.to,d);\n            dp[e.to] *= dp[v]*cnt; \n        }\n    }\n}\n\nvoid init(){\n    for(int i = 0 ; i < MAX ; i++){\n        G[i].clear();\n    }\n}\n\nint main(){\n    int n,m,p,a,b,c;\n    while(cin >> n >> m >> p, n){\n        init();\n        for(int i = 0 ; i < m ; i++){\n            cin >> a >> b >> c;\n            G[a].push_back(Edge(b,c));\n            G[b].push_back(Edge(a,c));\n        }\n        priority_queue<pii,vector<pii>,greater<pii> > Q;\n        Q.push(pii(0,0));\n        vector<int> d(n,INF); d[0] = 0;\n        while(!Q.empty()){\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            if(d[v] < p.first) continue;\n            for(int i = 0 ; i < (int)G[v].size() ; i++){\n                Edge e = G[v][i];\n                if(d[v] + e.cost < d[e.to]){\n                    d[e.to] = d[v] + e.cost;\n                    Q.push(pii(d[e.to],e.to));\n                }\n            }\n        }\n        memset(visited,0,sizeof(visited));\n        fill(dp,dp+MAX,1);\n        dfs(n-1,d);\n        for(int i = 0 ; i < n ; i++){\n            if(!visited[i]) dp[i] = 0;\n        }\n        for(int i = 0 ; i < p ; i++){\n            cin >> c;\n            if(dp[c] == 0){\n                printf(\"%.12f\\n\",0.0);\n            }else{\n                printf(\"%.12f\\n\",1./dp[c]);\n            }\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Data {\n  int cur;\n  ll w;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w < data.w;\n    return cur < data.cur;\n  }\n};\n\nconst ll LLINF = LLONG_MAX;\nconst int MAX_V = 110;\nint n,m,p;\nll fw[110][110];\ndouble dp[MAX_V];\nvector<Data> G[MAX_V];\n\nint main(){\n  while( cin >> n >> m >> p, n|m|p ){\n    rep(i,n) G[i].clear();\n    rep(i,n) rep(j,n) fw[i][j] = ((i==j)?0:LLINF);\n    rep(i,m) {\n      int s,t;\n      ll c;\n      cin >> s >> t >> c;\n      G[s].push_back((Data){t,c});\n      G[t].push_back((Data){s,c});\n      fw[s][t] = fw[t][s] = c;\n    }\n\n    rep(k,n) rep(i,n) rep(j,n) if( fw[i][k] != LLINF && fw[k][j] != LLINF ) fw[i][j] = min(fw[i][j],\n\t\t\t\t\t\t\t\t\t\t\t   fw[i][k]+fw[k][j]);\n\n    vector<Data> vec;\n    rep(i,n) vec.push_back((Data){i,fw[0][i]});\n    sort(vec.begin(),vec.end());  \n    rep(i,n) dp[i] = 0;\n    dp[0] = 1;\n    rep(i,vec.size()) {\n      int cur = vec[i].cur;\n      if( fw[0][cur] == LLINF || fw[cur][n-1] == LLINF ) continue;\n      ll weight = vec[i].w;\n      double cnt = 0;\n      \n      rep(j,G[cur].size()) if( cur != G[cur][j].cur ){\n\tint next = G[cur][j].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][cur] + fw[cur][next] + fw[next][n-1] == fw[0][n-1] ) {\n\t    ++cnt;\n\t}\n      }\n\n      rep(j,G[cur].size()) if( cur != G[cur][j].cur ){\n\tint next = G[cur][j].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][cur] + fw[cur][next] + fw[next][n-1] == fw[0][n-1] ) {\n\t    dp[next] += dp[cur] * ( 1.0 / cnt );\n\t}\n      }\n      \n    }\n\n    rep(i,p){\n      int pos;\n      cin >> pos;\n      printf(\"%.10f\\n\",dp[pos]/(double)dp[n-1]);\n    } puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstring>\n#include<vector>\n#include<map>\n#include<algorithm>\n#include<functional>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int>P;\nconst int N=100;\nvoid F(const vector<int>(&edge)[N],const vector<P>&v,int x,double*dp)\n{\n\tint i,j,k;\n\tfor(i=x;i<v.size();++i)\n\t{\n\t\tj=v[i].second;\n\t\tfor(k=0;k<edge[j].size();++k)dp[edge[j][k]]+=dp[j];\n\t}\n}\nint main()\n{\n\tint n,m,p,x,y,w,i,dist[N][N],X=0x3f3f3f3f;\n\tint vertex[N];\n\tvector<int>edge[N];\n\twhile(scanf(\"%d%d%d\",&n,&m,&p),n)\n\t{\n\t\tmemset(dist,X,sizeof(dist));\n\t\tmemset(vertex,X,sizeof(vertex));\n\t\tfor(i=0;i<n;++i)edge[i].clear();\n\t\twhile(m--)\n\t\t{\n\t\t\tscanf(\"%d%d%d\",&x,&y,&w);\n\t\t\tdist[y][x]=dist[x][y]=w;\n\t\t}\n\t\tpriority_queue<P,vector<P>,greater<P> >q;\t//<totalDistance, toIndex>\n\t\tq.push(P(0,0));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p(q.top());q.pop();\n\t\t\tif(vertex[p.second]<=p.first)continue;\n\t\t\tvertex[p.second]=p.first;\n\t\t\tfor(i=0;i<n;++i)if((w=dist[p.second][i])!=X)q.push(P(p.first+w,i));\n\t\t}\n\t\tbool flag[N]={};\n\t\tq.push(P(0,n-1));\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p(q.top());q.pop();\n\t\t\tfor(i=0;i<n;++i)\n\t\t\t\tif(w=dist[i][p.second],vertex[i]+w==vertex[p.second])\n\t\t\t\t{\n\t\t\t\t\tedge[i].push_back(p.second);\n\t\t\t\t\tif(!flag[i])\n\t\t\t\t\t{\n\t\t\t\t\t\tq.push(P(0,i));\n\t\t\t\t\t\tflag[i]=1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t}\n\t\tdouble dp[N]={1};\n\t\tvector<P>v;\n\t\tfor(i=0;i<n;++i)v.push_back(P(vertex[i],i));\n\t\tsort(v.begin(),v.end());\n\t\tF(edge,v,0,dp);\n\t\twhile(p--)\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tdouble dp2[N]={};\n\t\t\tdp2[x]=1;\n\t\t\tF(edge,v,x,dp2);\n\t\t\tprintf(\"%.9f\\n\",dp2[n-1]/dp[n-1]);\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for(int i=0; i<(int)(n); ++i)\n\nusing namespace std;\n\nconst int INF = 100000000;\ntypedef pair<int, int> PI;\n\nint main(){\n    int N, M, P;\n    while(cin >> N >> M >> P && N){\n        int d[100][100] = {};\n        int edge[100][100] = {};\n        REP(i, N) REP(j, N) d[i][j] = (i == j ? 0 : INF);\n        REP(i, N) REP(j, N) edge[i][j] = INF;\n        REP(i, M){\n            int a, b, c;\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            edge[a][b] = edge[b][a] = c;\n            assert(c > 0);\n        }\n        REP(k, N) REP(i, N) REP(j, N) {\n            d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n        }\n        priority_queue<PI> que;\n        REP(i, N){\n            que.push(PI(d[i][N - 1], i));\n        }\n        vector<long double> prob(N, 0);\n        prob[0] = 1;\n        while(!que.empty()){\n            int i = que.top().second;\n            que.pop();\n            if(prob[i] == 0) continue;\n            if(d[i][N - 1] >= INF) continue;\n            vector<int> next;\n            REP(j, N) if(edge[i][j] < INF && d[i][N - 1] == edge[i][j] + d[j][N - 1]){\n                next.push_back(j);\n            }\n            for(int j : next){\n                prob[j] += prob[i] / next.size();\n            }\n        }\n        REP(i, P){\n            int a;\n            cin >> a;\n            printf(\"%.8Lf\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == p.first) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<double> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += dp[v] * cnt[e.to] / cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t\tif(cnt[p.second]<0)return 1;\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\n\t\t\t\t\tif( cnt[p.second] < 0 ) return 1;\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n \n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n \nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge {\n  int src,dst;\n  ll w;\n};\n\nstruct Data {\n  int cur;\n  ll w;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w < data.w;\n    return cur < data.cur;\n  }\n};\n\nconst ll LLINF = LLONG_MAX;\nconst int MAX_V = 110;\nint V,E,Q;\nvector<Edge> G[MAX_V];\nll fw[MAX_V][MAX_V];\ndouble dp[MAX_V][2];\n\nvoid compute(int type,int sp,int ep){\n  vector<Data> vec;\n  rep(i,V) vec.push_back((Data){i,fw[sp][i]});\n  sort(vec.begin(),vec.end());\n  rep(i,(int)vec.size()){\n    int cur = vec[i].cur;\n    rep(j,(int)G[cur].size()){\n      int next = G[cur][j].dst;\n      if( fw[sp][cur] + G[cur][j].w + fw[next][ep] == fw[sp][ep] ) {\n        dp[next][type] += dp[cur][type];\n      }\n    }\n  }\n}\n\nint main(){\n  while( cin >> V >> E >> Q, V|E|Q ){\n    rep(i,V) G[i].clear();\n    rep(i,V) rep(j,V) fw[i][j] = ((i==j)?0:LLINF);\n    rep(i,E) {\n      int src,dst;\n      ll w;\n      cin >> src >> dst >> w;\n      fw[src][dst] = fw[dst][src] = w;\n      G[src].push_back((Edge){src,dst,w});\n      G[dst].push_back((Edge){dst,src,w});\n    }\n\n    rep(k,V) rep(i,V) rep(j,V) if( fw[i][k] != LLINF && fw[k][j] != LLINF ) fw[i][j] = min(fw[i][j],\n                                                                                           fw[i][k]+fw[k][j]);\n    \n    rep(i,MAX_V) rep(j,2) dp[i][j] = 0;\n    dp[0][0] = dp[V-1][1] = 1;\n    compute(0,0,V-1);\n    compute(1,V-1,0);\n    rep(i,Q){\n      int pos;\n      cin >> pos;\n      printf(\"%.10f\\n\",dp[pos][0]*dp[pos][1]/dp[V-1][0]);\n    } puts(\"\");\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <queue>\n#include <vector>\n#include <cstdio>\nusing namespace std;\n\nstruct NODE{\n\tint to,cost;\n\tNODE(int to,int cost) : to(to) , cost(cost) {}\n\tNODE(){}\n};\nbool operator < (const NODE &a,const NODE &b){\n\treturn a.cost > b.cost;\n}\nint done[110] = {};\nint ok[110][110] = {};\n\nvector<NODE> g[100];\nvector<NODE> g2[110][110];\nint n,m,p;\n\nint dfs(int x,int cst,int t){\n\tif( done[x] != cst ) return 0;\n\tif( x == n - 1 ) return 1;\n\tif( ok[x][t] != -1 ) return ok[x][t];\n\tint use = 0;\n\tfor(int i = 0 ; i < g[x].size() ; i++)\n\t\tif( dfs(g[x][i].to,cst+g[x][i].cost,t+1) ){\n\t\t\tg2[x][t].push_back(g[x][i]);\n\t\t\tuse = 1;\n\t\t}\n\treturn ok[x][t] = use;\n}\nint main(){\n\twhile(cin >> n >> m >> p && (n||m||p) ){\n\t\tfor(int i = 0 ; i < n ; i++) g[i].clear();\n\t\tfor(int i = 0 ; i < m ; i++){\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tg[a].push_back( NODE(b,c) );\n\t\t\tg[b].push_back( NODE(a,c) );\n\t\t}\n\t\tfor(int i = 0 ; i < 100 ; i++) done[i] = -1;\n\t\tfor(int i = 0 ; i < 110 ; i++)\n\t\t\tfor(int j = 0 ; j < 110 ; j++)\n\t\t\t\tok[i][j] = -1 , g2[i][j].clear();\n\t\tpriority_queue<NODE> Q;\n\t\tQ.push(NODE(0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif( done[q.to] != -1 ) continue;\n\t\t\telse done[q.to] = q.cost;\n\t\t\tfor(int i = 0 ; i < g[q.to].size() ; i++)\n\t\t\t\tQ.push(NODE(g[q.to][i].to,q.cost+g[q.to][i].cost));\n\t\t}\n\t\tdfs(0,0,0);\n\t\tdouble dp2[110][110] = {};\n\t\tdouble res[100]={};\n\t\tdp2[0][0] = 1.0;\n\t\tfor(int i = 0 ; i <= n ; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tfor(int k = 0 ; k < g2[j][i].size() ; k++){\n\t\t\t\t\tdp2[i+1][g2[j][i][k].to] += dp2[i][j] / g2[j][i].size();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int i = 0 ; i <= n; i++){\n\t\t\tfor(int j = 0 ; j < n ; j++){\n\t\t\t\tres[j] += dp2[i][j];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 0 ; i < p ; i++){\n\t\t\tint a;\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.10lf\\n\",res[a]);\n\t\t}\n\t\tcout << endl;\n\t}\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\nusing namespace std;\n\ntypedef long long lli;\n\nstruct Edge {\n  int v, c;\n  Edge() {}\n  Edge(int v, int c) : v(v), c(c) {}\n};\n\nstruct State {\n  int v, c;\n  State() {}\n  State(int v, int c) : v(v), c(c) {}\n  bool operator <(const State &s) const {\n    return c < s.c;\n  }\n  bool operator >(const State &s) const {\n    return c > s.c;\n  }\n};\n\ntypedef vector<vector<Edge> > Graph;\n\nvoid addEdge(int a, int b, int c, Graph *g) {\n  if(max(a,b)+1 > g->size()) {\n    g->resize(max(a,b)+1);\n  }\n  (*g)[a].push_back(Edge(b,c));\n  (*g)[b].push_back(Edge(a,c));\n}\n\nconst int MAXN = 101;\nconst int INF = 1<<28;\nint N, M, P;\nGraph G;\nvector<int> C;\nint cost[MAXN];\nlli num[MAXN];\n\nvoid dijkstra(int src, const Graph &g) {\n  priority_queue<State, vector<State>, greater<State> > que;\n  fill(cost, cost+MAXN, INF);\n  fill(num, num+MAXN, 0LL);\n  cost[src] = 0; \n  num[src] = 1;\n  que.push(State(src, 0));\n  while(!que.empty()) {\n    State s = que.top();\n    que.pop();\n    if(cost[s.v] < s.c) continue;\n    for(int i = 0; i < g[s.v].size(); ++i) {\n      int nv = g[s.v][i].v;\n      int nc = s.c + g[s.v][i].c;\n      if(cost[nv] == nc) {\n\tnum[nv] += num[s.v];\n      } else if(cost[nv] > nc) {\n\tnum[nv] = num[s.v];\n\tcost[nv] = nc;\n\tque.push(State(nv,nc));\n      }\n    }\n  }\n}\n\nint main() {\n  while(cin >> N >> M >> P && (N|M|P)) {\n    G.clear();\n    for(int i = 0; i < M; ++i) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      addEdge(a,b,c,&G);\n    }\n    C.resize(P);\n    for(int i = 0; i < P; ++i) {\n      cin >> C[i];\n    }\n    dijkstra(0, G);\n    for(int i = 0; i < P; ++i) {\n      printf(\"%.10f\\n\", (double)num[C[i]]/(double)num[N-1]);\n    }\n    printf(\"\\n\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\ntypedef pair<int,int> edge;\ntypedef vector<edge> ve;\ntypedef vector<ve> graph;\n\nint main(){\n  int n,m,p;\n  while(cin >> n >> m >> p, n){\n    graph g(n);\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      cin >> a >> b >> c;\n      g[a].push_back(edge(c,b));\n      g[b].push_back(edge(c,a));\n    }\n\n    vi c(p);\n    for(int i=0;i<p;i++)cin >> c[i];\n\n    vi d(n,1e9), order;\n    d[0] = 0;\n    priority_queue< edge,vector<edge>,greater<edge> > pq;\n    pq.push(edge(0,0));\n\n    while(pq.size()){\n      int dis = pq.top().first, v = pq.top().second; pq.pop();\n      if(d[v] < dis)continue;\n      order.push_back(v);\n\n      for(edge e : g[v]){\n\tint nxtd = dis + e.first, u = e.second;\n\tif(d[u] > nxtd){\n\t  d[u] = nxtd;\n\t  pq.push(edge(nxtd,u));\n\t}\n      }\n    }\n\n    vector<long long> cnt(n,0);\n    cnt[n-1] = 1;\n    for(int i=order.size()-1;i>=0;i--){\n      int v = order[i];\n      for(edge e : g[v]){\n\tint dis = e.first, u = e.second;\n\tif(d[v] == d[u] + dis)cnt[u] += cnt[v];\n      }\n    }\n\n    vector<double> prob(n,0);\n    prob[0] = 1;\n    for(int i=0;i<n;i++){\n      int v = order[i];\n\n      for(edge e : g[v]){\n\tint nxtd = d[v] + e.first, u = e.second;\n\tif(d[u] == nxtd){\n\t  prob[u] += prob[v] * cnt[u] / cnt[v];\n\t}\n      }\n    }\n\n    for(int i=0;i<p;i++){\n      cout << fixed << setprecision(9) << prob[c[i]] << endl;\n    }\n    cout << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n\tEdge() { Edge(-1, -1); }\n};\n\nint n, m, p;\nvector<vector<Edge> > edges;\nvector<vector<int> > prev_nodes()\n{\n\tconst int INF = 1e7;\n\tvector<int> dis(n, INF);\n\tvector<vector<int> > prev(n);\n\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\tdis[0] = 0;\n\tq.push(pint(0, 0));\n\twhile (!q.empty())\n\t{\n\t\tpint tt = q.top(); q.pop();\n\t\tint cur = tt.second, cost = tt.first;\n\n\t\tif (cost > dis[cur])\n\t\t\tcontinue;\n\n\t\tforeach (e, edges[cur])\n\t\t{\n\t\t\tint to = e->to, nc = cost + e->cost;\n\t\t\tif (nc < dis[to])\n\t\t\t{\n\t\t\t\tdis[to] = nc;\n\t\t\t\tprev[to].clear();\n\t\t\t\tprev[to].push_back(cur);\n\t\t\t\tq.push(pint(nc, to));\n\t\t\t}\n\t\t\telse if (nc == dis[to])\n\t\t\t\tprev[to].push_back(cur);\n\t\t}\n\t}\n\n\treturn prev;\n}\nvector<bool> mark(const vector<vector<int> >& prev)\n{\n\tvector<bool> on_min_path(n, false);\n\n\tqueue<int> q;\n\ton_min_path[n - 1] = true;\n\tq.push(n - 1);\n\twhile (!q.empty())\n\t{\n\t\tint cur = q.front(); q.pop();\n\t\tif (cur == 0)\n\t\t\tcontinue;\n\n\t\tfor (int i = 0; i < prev[cur].size(); ++i)\n\t\t{\n\t\t\tint to = prev[cur][i];\n\t\t\tif (!on_min_path[to])\n\t\t\t{\n\t\t\t\ton_min_path[to] = true;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn on_min_path;\n}\nint main()\n{\n\twhile (cin >> n >> m >> p, n)\n\t{\n\t\tedges = vector<vector<Edge> >(n);\n\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedges[a].push_back(Edge(b, c));\n\t\t\tedges[b].push_back(Edge(a, c));\n\t\t}\n\n\t\tvector<vector<int> > prev = prev_nodes();\n\t\tvector<bool> on_min_path = mark(prev);\n\n\t\twhile (p--)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\t\n\t\t\tdouble res = 0;\n\t\t\tif (on_min_path[c])\n\t\t\t\tres = (double)prev[c].size() / prev[n - 1].size();\n\t\t\tprintf(\"%.8f\\n\", res);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <cassert>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\n#define FORIT(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate<class T> void debug(T begin, T end){ for(T i = begin; i != end; ++i) cerr<<*i<<\" \"; cerr<<endl; }\ninline bool valid(int x, int y, int W, int H){ return (x >= 0 && y >= 0 && x < W && y < H); }\n\ntypedef long long ll;\nconst int INF = 100000000;\nconst double EPS = 1e-8;\nconst int MOD = 1000000007;\nint dx[8] = {1, 0, -1, 0, 1, -1, -1, 1};\nint dy[8] = {0, 1, 0, -1, 1, 1, -1, -1};\n\nint main(){\n  int N, M, P;\n  bool first = true;\n  while(cin >> N >> M >> P && N){\n    if(first) first = false;\n    else cout << endl;\n    int d[100][100];\n    REP(i, N) REP(j, N) d[i][j] = i != j ? INF : 0;\n    int edge[100][100] = {};\n    memset(edge, -1, sizeof(edge));\n    REP(i, M){\n      int a, b, c;\n      cin >> a >> b >> c;\n      d[a][b] = d[b][a] = c;\n      edge[a][b] = edge[b][a] = c;\n    }\n    vector<int> child(P);\n    REP(i, P) cin >> child[i];\n    REP(k, N) REP(i, N) REP(j, N) d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n    double k[100][100] = {}; // p[i] += k[i][j] * p[j]\n    REP(i, N){\n      vector<int> to;\n      REP(j, N) if(i != j) {\n        if(edge[i][j] != -1 && edge[i][j] + d[j][N - 1] == d[i][N - 1]){\n          // i -> j\n          to.push_back(j);\n        }\n      }\n      REP(l, to.size()){\n        k[to[l]][i] = 1.0 / to.size();\n      }\n    }\n    //REP(i, N) REP(j, N) printf(\"k[%d][%d] = %lf\\n\", i, j, k[i][j]);\n    double p[100];\n    REP(i, N) p[i] = 1.0;\n    REP(iter, 1000){\n      FOR(i, 1, N){\n        p[i] = 0;\n        REP(j, N) p[i] += k[i][j] * p[j];\n      }\n    }\n    REP(i, P) printf(\"%.12lf\\n\", p[child[i]]);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tdouble cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 100000000 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(cnt[n-1] <= 0)while(1);\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nvoid shortestPath(const vector<vector<int> >& graph, int start, vector<int>& dist)\n{\n    int n = graph.size();\n    dist.assign(n, INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(int i=0; i<n; ++i){\n            if(graph[v][i] >= 0 && dist[v] + graph[v][i] < dist[i]){\n                dist[i] = dist[v] + graph[v][i];\n                q.push(make_pair(dist[i], i));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint dfs1(vector<vector<int> >& graph, vector<int>& dist, vector<int>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == n-1)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[pos][i] != -1 && dist[pos] + graph[pos][i] == dist[i])\n             tmp += dfs1(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nint dfs2(vector<vector<int> >& graph, vector<int>& dist, vector<int>& num, int pos){\n     if(num[pos] != -1)\n         return num[pos];\n\n     int n = graph.size();\n     if(pos == 0)\n         return num[pos] = 1;\n\n     int tmp = 0;\n     for(int i=0; i<n; ++i){\n         if(graph[i][pos] != -1 && dist[pos] == dist[i] + graph[i][pos])\n             tmp += dfs2(graph, dist, num, i);\n     }\n     return num[pos] = tmp;\n}\n\nvoid solve(vector<vector<int> >& graph, vector<double>& p)\n{\n    int n = graph.size();\n    vector<int> dist;\n    shortestPath(graph, 0, dist);\n\n    vector<int> num1(n, -1), num2(n, -1);\n    dfs1(graph, dist, num1, 0);\n    dfs2(graph, dist, num2, n-1);\n\n    p.resize(n, 0.0);\n    for(int i=0; i<n; ++i){\n        if(num1[i] != -1 && num2[i] != -1)\n            p[i] = 1.0 * num1[i] * num2[i] / num1[0];\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<int> > graph(n, vector<int>(n, -1));\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            graph[a][b] = c;\n        }\n\n        vector<double> prob;\n        solve(graph, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 30;\n\nint N, M, P;\nint v1[100], v2[100];\nint dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, int *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(8);\n\n  while(cin >> N >> M >> P, N) {\n    for(int i = 0; i < g.size(); i++) g.clear();\n    g.resize(N);\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n\n    g.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Data {\n  int cur;\n  ll w;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w < data.w;\n    return cur < data.cur;\n  }\n};\n\nconst ll LLINF = LLONG_MAX;\nconst int MAX_V = 110;\nint n,m,p;\nll fw[110][110];\ndouble dp[MAX_V];\nvector<Data> G[MAX_V];\n\nint main(){\n  while( cin >> n >> m >> p, n|m|p ){\n    rep(i,n) G[i].clear();\n    rep(i,n) rep(j,n) fw[i][j] = ((i==j)?0:LLINF);\n    rep(i,m) {\n      int s,t;\n      ll c;\n      cin >> s >> t >> c;\n      G[s].push_back((Data){t,c});\n      G[t].push_back((Data){s,c});\n      fw[s][t] = fw[t][s] = c;\n    }\n    rep(k,n) rep(i,n) rep(j,n) if( fw[i][k] != LLINF && fw[k][j] != LLINF ) fw[i][j] = min(fw[i][j],\n\t\t\t\t\t\t\t\t\t\t\t   fw[i][k]+fw[k][j]);\n\n    vector<Data> vec;\n    rep(i,n) vec.push_back((Data){i,fw[0][i]});\n    sort(vec.begin(),vec.end());  \n    rep(i,n) dp[i] = 0;\n    dp[0] = 1;\n    rep(i,vec.size()) {\n      int cur = vec[i].cur;\n      if( fw[0][cur] == LLINF || fw[cur][n-1] == LLINF ) continue;\n      ll weight = vec[i].w;\n      double cnt = 0;\n\n      rep(i,G[cur].size()) if( cur != G[cur][i].cur ){\n\tint next = G[cur][i].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][next] + fw[next][n-1] == fw[0][n-1] ) {\n\t  if( fw[0][next] == fw[0][cur] + G[cur][i].w ) {\n\t    ++cnt;\n\t  }\n\t}\n      }\n\n\n      rep(i,G[cur].size()) if( cur != G[cur][i].cur ){\n\tint next = G[cur][i].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][next] + fw[next][n-1] == fw[0][n-1] ) {\n\t  if( fw[0][next] == fw[0][cur] + G[cur][i].w ) {\n\t    dp[next] += dp[cur] * ( 1.0 / cnt );\n\t  }\n\t}\n      }\n      \n    }\n\n    rep(i,p){\n      int pos;\n      cin >> pos;\n      if( pos == 0 || pos == n-1 ) { puts(\"1.0000000000000\"); }\n      else {\n\tprintf(\"%.10f\\n\",dp[pos]/(double)dp[n-1]);\n      }\n    } puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Overflow\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tdouble cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 100000000 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\n\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tdouble cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n\t\t\tdouble r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,k;cin>>n>>m>>k && n|m|k;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(k);\n\t\trep(i,k) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) dp[e.src][e.dst]=min(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi dist=dp[0];\n\t\t\n\t\tvd ps(n,0); ps[n-1]=1;\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return dist[i]>dist[j];});\n\t\tfor(auto u:is){\n\t\t\tint cnt=0;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) cnt++;\n\t\t\tfor(auto e:g[u]) if(dist[e.dst]+e.weight==dist[e.src]) ps[e.dst]+=ps[e.src]/cnt;\n\t\t}\n\t\t\n\t\trep(i,k) printf(\"%.8f\\n\",ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\nbool operator<(const Edge& a,const Edge& b){return a.weight<b.weight;}\nbool operator>(const Edge& a,const Edge& b){return a.weight>b.weight;}\ntypedef vector<vector<Edge>> Graph;\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) dp[e.src][e.dst]=min(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) dp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]<dp[0][j];});\n\t\tvector<__float128> ps(n); ps[0]=1;\n\t\tfor(int u:is){\n\t\t\tint cnt=0;\n\t\t\tfor(auto e:g[u]) if(dp[u][e.dst]+dp[e.dst][n-1]==dp[u][n-1]) cnt++;\n\t\t\tfor(auto e:g[u]) if(dp[u][e.dst]+dp[e.dst][n-1]==dp[u][n-1]) ps[e.dst]+=ps[u]/cnt;\n\t\t}\n\t\t\n\t\trep(i,s) printf(\"%.8f\\n\",(double)ps[cs[i]]);\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <cstdlib>\n#include <climits>\n#include <algorithm>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <numeric>\n#include <sstream>\n#include <string>\nusing namespace std;\n#define out(X) cerr << #X << \": \" << (X) << endl\n#define SZ(X) ((int)(X.size()))\n#define REP(I,N) for (int I = 0; I < (N); ++I)\n#define FOR(I,L,H) for (int I = (L); I < (H); ++I)\n#define MP(X,Y) make_pair((X),(Y))\n#define PB push_back\n#define ALL(X) X.begin(), X.end()\ntemplate <typename T> inline bool checkmin(T &a, const T &b) { return a > b ? a = b, 1 : 0; }\ntemplate <typename T> inline bool checkmax(T &a, const T &b) { return a < b ? a = b, 1 : 0; }\ntypedef long long lint;\n\nconst int MAXINT = -1u >> 1;\nconst int MAXN = 100 + 5;\n\nbool vis[MAXN];\nint dist[MAXN];\ndouble up[MAXN];\n\nstruct Node {\n    int u,c;\n    Node() {};\n    Node(const int &_u,const int &_c) :\n        u(_u),c(_c) {};\n};\n\nvector<Node> adj[MAXN];\nqueue<int> Q;\n\nconst double EPS = 1e-8;\n\nint sgn(const double &x) {return (int)((x > EPS) - (x < - EPS));}\n\nint main() {\n    int N,M,P;\n    while(scanf(\"%d%d%d\",&N,&M,&P) == 3) {\n        if (N == 0 && M == 0 && P == 0) break;\n        for(int i = 0 ; i < N ; i++) {\n            adj[i].clear();\n        }\n        for(int i = 0 ; i < M ; i++) {\n            int u,v,c;\n            scanf(\"%d%d%d\",&u,&v,&c);\n            adj[u].PB(Node(v,c));\n            adj[v].PB(Node(u,c));\n        }\n        memset(vis,false,sizeof(vis));\n        memset(dist,-1,sizeof(dist));\n        dist[0] = 0;\n        for(int n = 0 ; n < N ; n++) {\n            int next = -1,minm = MAXINT;\n            for(int i = 0 ; i < N ; i++) {\n                if (!vis[i] && dist[i] != -1 && dist[i] < minm) {\n                    next = i;\n                    minm = dist[i];\n                }\n            }\n            if (next == -1) break;\n            vis[next] = true;\n            for(int j = 0 ; j < SZ(adj[next]) ; j++) {\n                int u = adj[next][j].u;\n                int c = adj[next][j].c;\n                if (!vis[u] && dist[u] == -1 || dist[u] > dist[next] + c) {\n                    dist[u] = dist[next] + c;\n                }\n            }\n        }\n        memset(vis,false,sizeof(vis));\n        memset(up,0,sizeof(up));\n        up[0] = 1.0;\n        for(int n = 0 ; n < N ; n++) {\n            int next = -1,minm = MAXINT;\n            for(int i = 0 ; i < N ; i++) {\n                if (!vis[i] && dist[i] != -1 && dist[i] < minm) {\n                    next = i;\n                    minm = dist[i];\n                }\n            }\n            if (next == -1) break;\n            vis[next] = true;\n            for(int j = 0 ; j < SZ(adj[next]) ; j++) {\n                int u = adj[next][j].u;\n                int c = adj[next][j].c;\n                if (!vis[u] && dist[u] == dist[next] + c) {\n                    up[u] += up[next];\n                }\n            }\n        }\n        //for(int i = 0 ; i < N ; i++) {\n            //printf(\"%lf\\n\",up[i]);\n        //}\n        memset(vis,false,sizeof(vis));\n        Q.push(N - 1);\n        vis[N - 1] = true;\n        while(!Q.empty()) {\n            int now = Q.front(),aft;\n            Q.pop();\n            for(int j = 0 ; j < SZ(adj[now]) ; j++) {\n                aft = adj[now][j].u;\n                int c = adj[now][j].c;\n                if (!vis[aft] && dist[now] == dist[aft] + c) {\n                    vis[aft] = true;\n                    Q.push(aft);\n                }\n            }\n        }\n        //for(int i = 0 ; i < N ; i++) {\n            //printf(\"%d\\n\",vis[i]);\n        //}\n        if (sgn(up[N - 1]) == 0) while(1);\n        for(int i = 0 ; i < P ; i++) {\n            int c;\n            scanf(\"%d\",&c);\n            //if (!vis[c]) {\n                //printf(\"%0.10f\\n\",0.0);\n            //}\n            //else {\n                //if (c == 0) {\n                    //printf(\"%0.10f\\n\",1.0);\n                //}\n                //else {\n                    //printf(\"%0.10f\\n\",up[c] / up[N - 1]);\n                //}\n            //}\n            if (c == 0) {\n                printf(\"%0.10f\\n\",1.0);\n            }\n            else {\n                if (!vis[c]) {\n                    printf(\"%0.10f\\n\",0.0);\n                }\n                else {\n                    printf(\"%0.10f\\n\",up[c] / up[N - 1]);\n                }\n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\tint d[100];\n\t\tdouble dp[100]; // dp[u] := ( 0->u 間の最短経路の個数 ) ( 大きくなるので double で )\n\t\trep(u,n){\n\t\t\td[u]=(u==0?0:INF);\n\t\t\tdp[u]=(u==0?1:0);\n\t\t}\n\t\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint d_now=-Q.top().first,u=Q.top().second; Q.pop();\n\t\t\tif(d[u]<d_now) continue;\n\n\t\t\trep(i,G[u].size()){\n\t\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\t\tif(d[v]>d[u]+cost){\n\t\t\t\t\td[v]=d[u]+cost;\n\t\t\t\t\tdp[v]=dp[u];\n\t\t\t\t\tQ.push(make_pair(-d[v],v));\n\n\t\t\t\t\tD[v].clear();\n\t\t\t\t\tD[v].push_back(u); // まずは辺の向きを逆にして保存しておいて、あとで直す\n\t\t\t\t}\n\t\t\t\telse if(d[v]==d[u]+cost){\n\t\t\t\t\tdp[v]+=dp[u];\n\t\t\t\t\tD[v].push_back(u);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tdouble N=dp[n-1];\n\n\t\tvector<int> tmp[100];\n\t\trep(u,n) tmp[u]=D[u], D[u].clear();\n\t\trep(u,n) rep(i,tmp[u].size()) D[tmp[u][i]].push_back(u);\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\n\t\t\tdouble dp2[100]; // dp2[u] := ( c->u 間の最短経路の個数 )\n\t\t\trep(u,n) dp2[u]=(u==c?1:0);\n\t\t\tqueue<int> Q; Q.push(c);\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint u=Q.front(); Q.pop();\n\t\t\t\tassert(dp2[u]!=0);\n\t\t\t\trep(i,D[u].size()){\n\t\t\t\t\tint v=D[u][i];\n\t\t\t\t\tif(dp2[v]==0) Q.push(v);\n\t\t\t\t\tdp2[v]+=dp2[u];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprintf(\"%.9f\\n\",dp[c]*dp2[n-1]/N);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\ndouble ans[100];\nvector<vector<int> > froms;\n\nvoid calc( int pos, double prob ){\n\tvector<int>::iterator it;\n\tfor( it = froms[pos].begin(); it != froms[pos].end(); ++it ){\n\t\tif( *it != 0 ){\n\t\t\tans[*it] += prob;\n\t\t\tcalc( *it, prob );\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tfroms = vector<vector<int> >(n);\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill( ans, ans + 100, 0.0 );\n\n\t\tans[ n - 1 ] = ans[0] = 1.0;\n\t\tcalc( n - 1, 1.0 / cnt[ n - 1 ] );\n\t\t\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", ans[a] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n#include<vector>\nusing namespace std;\n#define INF (1<<28)\n#define MAX 105\nstruct edge{int to,cost;};\nstruct state{\n  int pos,cost;\n  bool operator < (const state &p)const{\n    return cost > p.cost;\n  }\n};\n\nvector<edge> G[MAX];\nint n,m,p;\n\nvoid init(){\n  for(int i=0;i<MAX;i++){\n    G[i].clear();\n  }\n}\n\nlong long d[MAX][MAX],cnt[MAX][MAX];\nvoid dijkstra(int si){\n  for(int i=0;i<MAX;i++)d[si][i]=INF,cnt[si][i]=0;\n  priority_queue<state> Q;\n  d[si][si]=0;\n  cnt[si][si]=1;\n  Q.push((state){si,0});\n  while(!Q.empty()){\n    state s=Q.top();Q.pop();\n    if(s.cost>d[si][s.pos])continue;\n    for(int i=0;i<(int)G[s.pos].size();i++){\n      edge e=G[s.pos][i];\n      if(d[si][e.to]<s.cost+e.cost)continue;\n      else if(d[si][e.to]==s.cost+e.cost){\n\tcnt[si][e.to]+=cnt[si][s.pos];\n      }else{\n\tcnt[si][e.to]=cnt[si][s.pos];\n\td[si][e.to]=s.cost+e.cost;\n\tQ.push((state){e.to,d[si][e.to]});\n      }\n    }\n  }\n}\n\nint main(){\n  while(1){\n    cin>>n>>m>>p;\n    if(n==0&&m==0&&p==0)break;\n    init();\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d%d%d\",&a,&b,&c);\n      G[a].push_back((edge){b,c});\n      G[b].push_back((edge){a,c});\n    }\n    for(int i=0;i<n;i++)\n      dijkstra(i);\n\n    for(int i=0;i<p;i++){\n      int a;\n      scanf(\"%d\",&a);\n      if(d[0][a]+d[a][n-1]!=d[0][n-1]){\n\tcout<<\"0.0\"<<endl;\n      }else{\n\tdouble x=cnt[0][a],x2=cnt[a][n-1],y=cnt[0][n-1];\n\tprintf(\"%.8f\\n\",x/y*x2);\n      }\n\n\n    }\n    cout<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nvoid shortestPath(const vector<vector<Edge> >& edges, int start, vector<int>& dist)\n{\n    dist.assign(edges.size(), INT_MAX);\n    dist[start] = 0;\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, start));\n\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(dist[v] < p.first)\n            continue;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(dist[v] + e.cost < dist[e.to]){\n                dist[e.to] = dist[v] + e.cost;\n                q.push(make_pair(dist[e.to], e.to));\n            }\n        }\n    }\n\n    replace(dist.begin(), dist.end(), INT_MAX, -1);\n}\n\nint dfs(vector<vector<Edge> >& edges, vector<int>& dist, vector<int>& check, int pos)\n{\n    int n = edges.size();\n    if(pos == n-1)\n        return check[n-1] = 1;\n\n    for(unsigned i=0; i<edges[pos].size(); ++i){\n        if(check[edges[pos][i].to] == 1)\n            check[pos] = 1;\n        else if(dist[edges[pos][i].to] == dist[pos] + edges[pos][i].cost)\n            check[pos] = dfs(edges, dist, check, edges[pos][i].to);\n    }\n\n    if(check[pos] == -1)\n        check[pos] = 0;\n    return check[pos];\n}\n\nvoid solve(vector<vector<Edge> >& edges, vector<double>& p)\n{\n    int n = edges.size();\n    vector<int> dist;\n    shortestPath(edges, 0, dist);\n    \n    vector<int> check(n, -1);\n    dfs(edges, dist, check, 0);\n\n    queue<int> q;\n    q.push(0);\n    p.resize(n, 0.0);\n    p[0] = 1.0;\n    while(!q.empty()){\n        int pos = q.front();\n        double prob = p[pos];\n        q.pop();\n        if(check[pos] == 0)\n            continue;\n        check[pos] = 0;\n\n        int num = 0;\n        for(unsigned i=0; i<edges[pos].size(); ++i){\n            if(check[edges[pos][i].to] == 1 && dist[edges[pos][i].to] == dist[pos] + edges[pos][i].cost){\n                ++ num;\n                q.push(edges[pos][i].to);\n            }\n        }\n        for(unsigned i=0; i<edges[pos].size(); ++i){\n            if(check[edges[pos][i].to] == 1 && dist[edges[pos][i].to] == dist[pos] + edges[pos][i].cost){\n                p[edges[pos][i].to] += prob / num;\n            }\n        }\n    }\n}\n\nint main()\n{\n    for(;;){\n        int n, m, p;\n        cin >> n >> m >> p;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, c;\n            cin >> a >> b >> c;\n            edges[a].push_back(Edge(b, c));\n        }\n\n        vector<double> prob;\n        solve(edges, prob);\n        for(int i=0; i<p; ++i){\n            int a;\n            cin >> a;\n            printf(\"%.10f\\n\", prob[a]);\n        }\n        cout << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <utility>\n\nconst int inf = 1000000000;\n\nstruct edge{\n\tint to, cost;\n};\ntypedef std::pair<int, int> P;\n\nint n, m, p;\nint c[100];\nstd::vector<edge> g[100];\nint d[100];\n\nint count[100];\n\nvoid back(int cur){\n\t++count[cur];\n\tfor(int i = 0; i < g[cur].size(); ++i){\n\t\tedge e = g[cur][i];\n\t\tif(d[cur] == d[e.to] + e.cost) back(e.to);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tfor(int i = 0; i < 100; ++i) g[i].clear();\n\t\tscanf(\"%d%d%d\", &n, &m, &p);\n\t\tif(n == 0 && m == 0 && p ==0) break;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint e1, e2, dist;\n\t\t\tscanf(\"%d%d%d\", &e1, &e2, &dist);\n\t\t\tg[e1].push_back({e2, dist});\n\t\t\tg[e2].push_back({e1, dist});\n\t\t}\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tscanf(\"%d\", c + i);\n\t\t}\n\n\t\tstd::fill(d, d + n, inf);\n\n\t\tstd::priority_queue<P, std::vector<P>, std::greater<P> > que;\n\t\td[0] = 0;\n\t\tque.push(P(0, 0));\n\t\twhile(!que.empty()){\n\t\t\tP v = que.top();\n\t\t\tque.pop();\n\t\t\tif(v.first > d[v.second]) continue;\n\t\t\tfor(int i = 0; i < g[v.second].size(); ++i){\n\t\t\t\tedge e = g[v.second][i];\n\t\t\t\tif(d[e.to] > d[v.second] + e.cost){\n\t\t\t\t\td[e.to] = d[v.second] + e.cost;\n\t\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 100; ++i) count[i] = 0;\n\t\tback(n - 1);\n\t\tcount[n - 1] = count[0];\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tprintf(\"%.8f\\n\", (double)count[c[i]] / count[0]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2:00~\n\n#include<queue>\n#include<cstdio>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tvector<int> D[100]; // 最短経路 DAG\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) D[u].push_back(v);\n\t\t}\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\trep(u,n){\n\t\t\tbool vis[100]={}; vis[u]=true;\n\t\t\tdp[u][u]=1;\n\t\t\tqueue<int> Q; Q.push(u);\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint v=Q.front(); Q.pop();\n\t\t\t\trep(i,D[v].size()){\n\t\t\t\t\tint w=D[v][i];\n\t\t\t\t\tif(!vis[w]){\n\t\t\t\t\t\tvis[w]=true;\n\t\t\t\t\t\tQ.push(w);\n\t\t\t\t\t}\n\t\t\t\t\tdp[u][w]+=dp[u][v];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\t// rep(u,n) rep(i,G[u].size()) {\n\t\t\t// int v=G[u][i].v,cost=G[u][i].cost;\n\t\t\t// if(d[0][u]+cost+d[v][n-1]==d[0][n-1]) dp[u][v]=1; // 最初は dp には最短経路 DAG の隣接行列が入っている\n\t\t// }\n\t\t// rep(w,n) rep(u,n) rep(v,n) dp[u][v]+=dp[u][w]*dp[w][v];\n\t\trep(u,n){\n\t\t\tbool vis[100]={}; vis[u]=true;\n\t\t\tdp[u][u]=1;\n\t\t\tqueue<int> Q; Q.push(u);\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint v=Q.front(); Q.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tint w=G[v][i].v,cost=G[v][i].cost;\n\t\t\t\t\tif(d[0][v]+cost+d[w][n-1]==d[0][n-1]){\n\t\t\t\t\t\tif(!vis[w]){\n\t\t\t\t\t\t\tvis[w]=true;\n\t\t\t\t\t\t\tQ.push(w);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tdp[u][w]+=dp[u][v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 110\n#define INF (1<<29)\ntypedef pair<int, int> pii;\n\nstruct Edge {\n    int to, cost;\n    Edge (int to, int cost) : to(to), cost(cost) {}\n};\n\nint main()\n{\n    int N, M, P;\n    while (cin >> N >> M >> P, N) {\n        int d[MAX][MAX];\n        for (int i = 0; i < N; i++) {\n            for (int j = 0; j < N; j++) {\n                d[i][j] = INF;\n            }\n            d[i][i] = 0;\n        }\n        \n        vector<Edge> G[MAX];\n        \n        int a, b, c;\n        for (int i = 0; i < M; i++) {\n            cin >> a >> b >> c;\n            d[a][b] = d[b][a] = c;\n            G[a].push_back(Edge(b, c));\n            G[b].push_back(Edge(a, c));\n        }\n\n        for (int k = 0; k < N; k++) {\n            for (int i = 0; i < N; i++) {\n                for (int j = 0; j < N; j++) {\n                    d[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n                }\n            }\n        }\n\n        priority_queue<pii> Q;\n        Q.push(pii(d[0][N-1], N-1));\n        \n        vector<bool> visited(MAX, 0);\n        visited[N-1] = 1;\n\n        vector<int> cnt(MAX, 0);\n        cnt[N-1] = 1;\n        \n        while (!Q.empty()) {\n            pii p = Q.top(); Q.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (d[0][e.to] + e.cost == d[0][v]) {\n                    cnt[e.to] += cnt[v];\n                    if (!visited[e.to]) {\n                        visited[e.to] = 1;\n                        Q.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        priority_queue<pii, vector<pii>, greater<pii>> Q2;\n        Q2.push(pii(0, 0));\n\n        vector<bool> visited2(MAX, 0);\n        visited2[0] = 1;\n\n        double dp[MAX] = {};\n        dp[0] = 1;\n        \n        while (!Q2.empty()) {\n            pii p = Q2.top(); Q2.pop();\n            int v = p.second;\n            for (int i = 0; i < (int)G[v].size(); i++) {\n                Edge &e = G[v][i];\n                if (visited[e.to] && d[0][v] + e.cost == d[0][e.to]) {\n                    dp[e.to] += (dp[v] * (double)cnt[e.to]) / (double)cnt[v];                    \n                    if (!visited2[e.to]) {\n                        visited2[e.to] = 1;\n                        Q2.push(pii(d[0][e.to], e.to));\n                    }\n                }\n            }\n        }\n\n        int child;\n        for (int i = 0; i < P; i++) {\n            cin >> child;\n            printf(\"%.10f\\n\", dp[child]);            \n        }\n        cout << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\n\nvector<vector<int> > clean(const vector<vector<int> >& e)\n{\n\tint n = e.size();\n\tvector<bool> on_min_path(n);\n\tqueue<int> q;\n\ton_min_path[n - 1] = true;\n\tq.push(n - 1);\n\twhile (!q.empty())\n\t{\n\t\tint cur = q.front(); q.pop();\n\t\tfor (int i = 0; i < e[cur].size(); ++i)\n\t\t{\n\t\t\tint to = e[cur][i];\n\t\t\tif (!on_min_path[to])\n\t\t\t{\n\t\t\t\ton_min_path[to] = true;\n\t\t\t\tq.push(to);\n\t\t\t}\n\t\t}\n\t}\n\n\tvector<vector<int> > res(n);\n\tfor (int i = 0; i < n; ++i)\n\t\tfor (int j = 0; j < e[i].size(); ++j)\n\t\t\tif (on_min_path[i] && on_min_path[e[i][j]])\n\t\t\t\tres[i].push_back(e[i][j]);\n\treturn res;\n}\nvector<vector<int> > prev_nodes(const vector<vector<Edge> >& edges)\n{\n\tint n = edges.size();\n\n\tconst int INF = 1e7;\n\tvector<int> dis(n, INF);\n\tvector<vector<int> > prevv(n);\n\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\tdis[0] = 0;\n\tq.push(pint(0, 0));\n\twhile (!q.empty())\n\t{\n\t\tpint tt = q.top(); q.pop();\n\t\tint cur = tt.second, cost = tt.first;\n\n\t\tif (cost > dis[cur])\n\t\t\tcontinue;\n\n\t\tforeach (e, edges[cur])\n\t\t{\n\t\t\tint to = e->to, nc = cost + e->cost;\n\t\t\tif (nc < dis[to])\n\t\t\t{\n\t\t\t\tdis[to] = nc;\n\t\t\t\tprevv[to].clear();\n\t\t\t\tprevv[to].push_back(cur);\n\t\t\t\tq.push(pint(nc, to));\n\t\t\t}\n\t\t\telse if (nc == dis[to])\n\t\t\t\tprevv[to].push_back(cur);\n\t\t}\n\t}\n\n\treturn clean(prevv);\n}\n\nvector<vector<int> > rev(const vector<vector<int> >& e)\n{\n\tvector<vector<int> > res(e.size());\n\tfor (int i = 0; i < e.size(); ++i)\n\t\tfor (int j = 0; j < e[i].size(); ++j)\n\t\t\tres[e[i][j]].push_back(i);\n\treturn res;\n}\n\nll in_paths(vector<ll>& dp, const vector<vector<int> >& e, int v)\n{\n\tif (dp[v] != -1)\n\t\treturn dp[v];\n\telse if (e[v].empty())\n\t\treturn dp[v] = 1;\n\n\tll res = 0;\n\tfor (int i = 0; i < e[v].size(); ++i)\n\t\tres += in_paths(dp, e, e[v][i]);\n\treturn dp[v] = res;\n}\nint main()\n{\n\tint n, m, p;\n\twhile (cin >> n >> m >> p, n)\n\t{\n\t\tvector<vector<Edge> > edges(n);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedges[a].push_back(Edge(b, c));\n\t\t\tedges[b].push_back(Edge(a, c));\n\t\t}\n\t\tvector<vector<int> > prevv = prev_nodes(edges);\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//{\n\t\t//\tprintf(\"%d: \", i);\n\t\t//\tfor (int j = 0; j < prevv[i].size(); ++j)\n\t\t//\t\tprintf(\"%d \", prevv[i][j]);\n\t\t//\tputs(\"\");\n\t\t//}puts(\"\");\n\n\t\tvector<ll> in(n, -1), out(n, -1);\n\t\tin_paths(in, prevv, n - 1);\n\t\tin_paths(out, rev(prevv), 0);\n\n\t\tvector<ll> paths(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tif (in[i] != -1)\n\t\t\t\tpaths[i] = in[i] * out[i];\n\t\tll total_paths = paths[0];\n\n\t\t//for (int i = 0; i < n; ++i)\n\t\t//{\n\t\t//\tprintf(\"%d: %lld %lld\\n\", i, in[i], out[i]);\n\t\t//}\n\n\t\twhile (p--)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\t\n\t\t\tprintf(\"%.8f\\n\", (double)paths[c] / total_paths);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100];\nbool v[100],u[100]; double cnt[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28;\n\t\td[0]=0;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(c==n-1)break;\n\t\t\tif(d[c]<-cc)continue;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,Q.push(mp(cc-i->second,i->first));\n\t\t}\n\t\t\n\t\trep(i,n)u[i]=v[i]=0,cnt[i]=0;\n\t\tqueue<int> q; q.push(n-1);\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tv[c]=1;\n\t\t\tfr(i,e[c])if(!v[i->first]&&d[i->first]+i->second==d[c])q.push(i->first);\n\t\t}\n\t\tq=queue<int>(); q.push(0);\n\t\tcnt[0]=1;\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tif(u[c])continue; u[c]=1;\n\t\t\tfr(i,e[c])if(v[i->first]&&d[i->first]==d[c]+i->second)\n\t\t\t{\n\t\t\t\tcnt[i->first]+=cnt[c];\n\t\t\t\tif(!u[i->first])q.push(i->first);\n\t\t\t}\n\t\t}\n\t\tcnt[0]=cnt[n-1];\n\t\trep(i,p)printf(\"%.7f\\n\",cnt[C[i]]/cnt[n-1]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<vector>\n#include<sstream>\n#include<set>\n#include<queue>\n#include<algorithm>\n#include<cassert>\n\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define fr(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();i++)\n#define pb push_back\n#define mp make_pair\n\nint n,m,p,C[100];\nvector<vector<pair<int,int> > > e;\nint d[100];\nbool v[100],u[100]; double pb[100];\n\nint main(){\n\twhile(cin>>n>>m>>p,n){\n\t\te.clear(); e.resize(n);\n\t\trep(i,m){\n\t\t\tint a,b,c; cin>>a>>b>>c;\n\t\t\te[a].pb(mp(b,c)); e[b].pb(mp(a,c));\n\t\t}\n\t\trep(i,p)cin>>C[i];\n\t\t\n\t\trep(i,n)d[i]=1<<28;\n\t\td[0]=0;\n\t\tpriority_queue<pair<int,int> > Q; Q.push(mp(0,0));\n\t\twhile(!Q.empty()){\n\t\t\tint c=Q.top().second,cc=Q.top().first; Q.pop();\n\t\t\tif(c==n-1)break;\n\t\t\tif(d[c]<-cc)continue;\n\t\t\tfr(i,e[c])if(d[i->first]>-cc+i->second)\n\t\t\td[i->first]=-cc+i->second,Q.push(mp(cc-i->second,i->first));\n\t\t}\n\t\t\n\t\trep(i,n)u[i]=v[i]=0,pb[i]=0;\n\t\tqueue<int> q; q.push(n-1);\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(); q.pop();\n\t\t\tv[c]=1;\n\t\t\tfr(i,e[c])if(!v[i->first]&&d[i->first]+i->second==d[c])q.push(i->first);\n\t\t}\n\t\tq=queue<int>(); q.push(0);\n\t\tpb[0]=1;\n\t\twhile(!q.empty()){\n\t\t\tint c=q.front(),cnt=0; q.pop();\n\t\t\tu[c]=1;\n\t\t\tfr(i,e[c])if(!u[i->first]&&v[i->first]&&d[i->first]==d[c]+i->second)cnt++;\n\t\t\tfr(i,e[c])if(!u[i->first]&&v[i->first]&&d[i->first]==d[c]+i->second)\n\t\t\tq.push(i->first),pb[i->first]+=pb[c]/cnt;\n\t\t}\n\t\t\n\t\trep(i,p)printf(\"%.7f\\n\",pb[C[i]]); puts(\"\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//TLE\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <bitset>\n#include <queue>\n#include <utility>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\ndouble ans[100];\nvector<int> froms[100];\n\nvoid calc( int pos, double prob ){\n\tvector<int>::iterator it;\n\tfor( it = froms[pos].begin(); it != froms[pos].end(); ++it ){\n\t\tif( *it != 0 ){\n\t\t\tans[*it] += prob;\n\t\t\tcalc( *it, prob );\n\t\t}\n\t}\n}\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100];\n\tint cnt[100];\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( b, w ) );\n\t\t\twts[b].push_back( pii( a, w ) );\n\t\t}\n\n\t\tfor( int i = 100; i--; )\tfroms[i].clear();\n\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); !qu.empty(); ){\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->second;\n\t\t\t\tif( minw[it->first] > w ){\n\t\t\t\t\tfroms[it->first].clear();\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tminw[it->first] = w;\n\t\t\t\t\tcnt[it->first] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->first ) );\n\t\t\t\t}\n\t\t\t\telse if( minw[it->first] == w ){\n\t\t\t\t\tfroms[it->first].push_back( p.second );\n\t\t\t\t\tcnt[it->first] += cnt[p.second];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfill( ans, ans + 100, 0.0 );\n\n\t\tans[ n - 1 ] = ans[0] = 1.0;\n//\t\tcalc( n - 1, 1.0 / cnt[ n - 1 ] );\n\t\t\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", ans[a] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\tint cnt[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 1e9 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\nfor(int j=0;j<n;j++)if(cnt[j]<0)while(1);\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\nif(cnt[p.second]<0)return 1;\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <functional>\n#include <algorithm>\n#include <utility>\n\nconst int inf = 1000000000;\n\nstruct edge{\n\tint to, cost;\n};\ntypedef std::pair<int, int> P;\n\nint n, m, p;\nint c[100];\nstd::vector<edge> g[100];\nint d[100];\n\nint count[100];\n\nvoid back(int cur){\n\t++count[cur];\n\tif(cur == 0) return;\n\tfor(int i = 0; i < g[cur].size(); ++i){\n\t\tedge e = g[cur][i];\n\t\tif(d[cur] == d[e.to] + e.cost) back(e.to);\n\t}\n}\n\nint main(){\n\twhile(1){\n\t\tfor(int i = 0; i < 100; ++i) g[i].clear();\n\t\tscanf(\"%d%d%d\", &n, &m, &p);\n\t\tif(n == 0 && m == 0 && p ==0) break;\n\t\tfor(int i = 0; i < m; ++i){\n\t\t\tint e1, e2, dist;\n\t\t\tscanf(\"%d%d%d\", &e1, &e2, &dist);\n\t\t\tg[e1].push_back({e2, dist});\n\t\t\tg[e2].push_back({e1, dist});\n\t\t}\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tscanf(\"%d\", c + i);\n\t\t}\n\n\t\tstd::fill(d, d + n, inf);\n\n\t\tstd::priority_queue<P, std::vector<P>, std::greater<P> > que;\n\t\td[0] = 0;\n\t\tque.push(P(0, 0));\n\t\twhile(!que.empty()){\n\t\t\tP v = que.top();\n\t\t\tque.pop();\n\t\t\tif(v.first > d[v.second]) continue;\n\t\t\tfor(int i = 0; i < g[v.second].size(); ++i){\n\t\t\t\tedge e = g[v.second][i];\n\t\t\t\tif(d[e.to] > d[v.second] + e.cost){\n\t\t\t\t\td[e.to] = d[v.second] + e.cost;\n\t\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < 100; ++i) count[i] = 0;\n\t\tback(n - 1);\n\t\tcount[n - 1] = count[0];\n\t\tfor(int i = 0; i < p; ++i){\n\t\t\tprintf(\"%.8f\\n\", (double)count[c[i]] / count[0]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define FR first\n#define SC second\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define rep(i, n) for(int i = 0; i < (int)(n); i++)\n#define reps(i, f, n) for(int i = (int)(f); i < (int)(n); i++)\n#define each(a, b) for(auto& a : b)\n\ntypedef pair<int, int> P;\n\nconst int inf = 1LL << 55;\nconst int mod = 1e9 + 7;\n\nstruct edge\n{\n  int to, cost;\n  edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n};\n\nvector< vector<edge> > graph;\nvector< vector<int> > mincost, routes;\n\nint dijkstra(int s)\n{\n  priority_queue<P, vector<P>, greater<P> > que;\n  que.push(P(0, s));\n  mincost[s][s] = 0; routes[s][s] = 1;\n  while(!que.empty()) {\n    int cost, now;\n    tie(cost, now) = que.top(); que.pop();\n    if(mincost[s][now] < cost) continue;\n    for(edge& e : graph[now]) {\n      if(cost + e.cost < mincost[s][e.to]) {\n\tmincost[s][e.to] = cost + e.cost;\n\troutes[s][e.to] = routes[s][now];\n\tque.push(P(mincost[s][e.to], e.to));\n      } else if(cost + e.cost == mincost[s][e.to]) {\n\troutes[s][e.to] += routes[s][now];\n      }\n    }\n  }\n}\n\nsigned main()\n{\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n, m, p;\n  while(cin >> n >> m >> p, n) {\n    graph.clear(); graph.resize(n);\n    while(m--) {\n      int a, b, c;\n      cin >> a >> b >> c;\n      graph[a].push_back(edge(b, c));\n      graph[b].push_back(edge(a, c));\n    }\n    mincost.clear(); mincost.resize(n, vector<int>(n, inf));\n    routes.clear(); routes.resize(n, vector<int>(n, 0));\n    rep(i, n) dijkstra(i);\n    while(p--) {\n      int c; cin >> c;\n      if(mincost[0][c] + mincost[c][n-1] == mincost[0][n-1]) {\n\tcout << (double)routes[0][c]*routes[c][n-1] / routes[0][n-1] << endl;\n      } else {\n\tcout << 0 << endl;\n      }\n    }\n    cout << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<cassert>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\tassert(d[u][v]==0 || d[u][v]==INF);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\trep(u,n) rep(i,G[u].size()) {\n\t\t\tint v=G[u][i].v,cost=G[u][i].cost;\n\t\t\tif(d[0][u]+cost+d[v][n-1]==d[0][n-1]) dp[u][v]=1;\n\t\t}\n\t\trep(w,n) rep(u,n) rep(v,n) dp[u][v]+=dp[u][w]*dp[w][v];\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 110;\nconst int M = 1000010;\nconst int inf = 1000000000;\n\nstruct Edge\n{\n    int f, t, d;\n}e[M];\n\nint point[N], next[M], ne;\nint dis[2][N], q[N];\nbool u[N];\n\nvoid add_edge(int f, int t, int d)\n{\n    e[ne].f = f, e[ne].t = t, e[ne].d = d;\n    next[ne] = point[f], point[f] = ne++;\n}\n\nvoid spfa(int s, int n, int k)\n{\n    int i, tmp, f, r;\n    for(i = 0; i < n; ++i) {\n        dis[k][i] = inf;\n        u[i] = false;\n    }\n    dis[k][s] = 0;\n    u[s] = true;\n    f = 0, r = 1;\n    q[f] = s;\n    while(f != r) {\n        tmp = q[f];\n        f = (f + 1) % n;\n        u[tmp] = false;\n        for(i = point[tmp]; i != -1; i = next[i]) {\n            if(dis[k][e[i].t] > dis[k][tmp] + e[i].d) {\n                dis[k][e[i].t] = dis[k][tmp] + e[i].d;\n                if(!u[e[i].t]) {\n                    u[e[i].t] = true;\n                    q[r] = e[i].t;\n                    r = (r + 1) % n;\n                }\n            }\n        }\n    }\n}\n\nstruct Node\n{\n    int d, cnt, id;\n    bool operator < (const Node &x) const {\n        return d < x.d;\n    }\n    double p;\n}qi[N];\n\nbool cmp(const Node &x, const Node &y)\n{\n    return x.id < y.id;\n}\n\nint qid[N], cnt[N];\n\nvoid update(int s, int n)\n{\n    for(int i = 0; i < n; ++i)\n        qid[qi[i].id] = i;\n    qi[0].cnt = 1;\n    qi[0].p = 1.0;\n    /*for(int i = 0; i < n; ++i) {\n        int f = qi[i].id;\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                qi[qid[t]].cnt += qi[i].cnt;\n        }\n    }\n    qi[0].cnt = qi[qid[n - 1]].cnt;\n\n    for(int k = 1; k < n; ++k) {\n        memset(cnt, 0, sizeof(cnt));\n        cnt[0] = 1;\n        for(int i = 0; i < n; ++i) {\n            if(i == k)  continue;\n            int f = qi[i].id;\n            for(int j = point[f]; j != -1; j = next[j]) {\n                int t = e[j].t;\n                if(!u[t])   continue;\n                if(dis[0][f] + e[j].d == dis[0][t])\n                    cnt[qid[t]] += cnt[i];\n            }\n        }\n        if(k != qid[n - 1])\n            qi[k].cnt = qi[qid[n - 1]].cnt - cnt[qid[n - 1]];\n    }*/\n    for(int i = 0; i < n; ++i) {\n        int tot = 0;\n        int f = qi[i].id;\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                ++tot;\n        }\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                qi[qid[t]].p += qi[i].p / tot;\n        }\n    }\n}\n\nint main()\n{\n    int i, n, m, p, a, b, d, iid;\n    while(scanf(\"%d%d%d\", &n, &m, &p) && n + m + p) {\n        ne = 0;\n        memset(point, -1, sizeof(point));\n        for(i = 0; i < m; ++i) {\n            scanf(\"%d%d%d\", &a, &b, &d);\n            add_edge(a, b, d);\n            add_edge(b, a, d);\n        }\n        spfa(0, n, 0);\n        spfa(n - 1, n, 1);\n        /*for(int j = 0; j < 2; ++j) {\n            printf(\"********\\n\");\n            for(i = 0; i < n; ++i) {\n                printf(\"%d: %d\\n\", i, dis[j][i]);\n            }\n        }*/\n        memset(u, false, sizeof(u));\n        for(i = 0; i < n; ++i) {\n            qi[i].d = dis[0][i];\n            qi[i].cnt = 0, qi[i].id = i;\n            qi[i].p = 0;\n            if(dis[0][i] + dis[1][i] == dis[0][n - 1])\n                u[i] = true;\n        }\n        sort(qi, qi + n);\n        update(0, n);\n        sort(qi, qi + n, cmp);\n        while(p--) {\n            scanf(\"%d\", &iid);\n            /*if(qi[n - 1].cnt == 0) {\n                printf(\"0.00000000\\n\");\n            }\n            else {\n                printf(\"%.8f\\n\", qi[iid].cnt * 1.0 / qi[n - 1].cnt);\n            }*/\n            if(qi[n - 1].p < 1e-8) {\n                printf(\"0.00000000\\n\");\n            }\n            else {\n                printf(\"%.8f\\n\", qi[iid].p);\n            }\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n#include<vector>\n#include<queue>\n\nusing namespace std;\nconst int infty = 1<<28;\n\nstruct Node{\n  vector<int> con;\n  vector<int> in;\n  vector<int> cost;\n};\n\ntypedef vector<Node> Graph;\n\ndouble topologicalSort(const Graph &G, int n, int s, int g)\n{\n  double numPath[n];\n  int invis[n];\n  bool vis[n];\n  queue<int> q;\n  for(int i = 0; i < n; ++i){\n    invis[i] = 0;\n    numPath[i] = 0.0;\n    vis[i] = false;\n  }\n  numPath[s]=1.0;\n  \n  q.push(s);\n  vis[s]=true;\n  while(!q.empty()){\n    int now = q.front();\n    q.pop();\n    \n    for(int i = 0; i < G[now].con.size(); ++i){\n      int nid = G[now].con[i];\n      invis[nid]++;\n      numPath[nid] += numPath[now];\n      if( invis[nid] == G[nid].in.size() ){\n\tif( !vis[nid] ){\n\t  vis[nid]=true;\n\t  q.push( nid );\n\t}\n      }\n    }\n  }\n  \n  return numPath[g];\n}\n\nint main()\n{\n  while(true){\n    int n,m,p;\n    cin >> n >> m >> p;\n    if( n == 0 && m == 0 && p == 0 ) break;\n    int c[p];\n    double cPath[n];\n    Graph G(n);\n    Graph DAG(n);\n    Graph rDAG(n);\n    int d[n][n];\n    \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < n; ++j){\n\tif( i == j ) d[i][j] = 0;\n\telse d[i][j] = infty;\n      }\n    }\n\n    for(int i = 0; i < m; ++i){\n      int a,b,c;\n      cin >> a >> b >> c;\n      G[a].con.push_back(b);\n      G[a].cost.push_back(c);\n      G[b].con.push_back(a);\n      G[b].cost.push_back(c);\n      d[a][b]=min(d[a][b],c);\n      d[b][a]=min(d[b][a],c);\n    }\n    for(int i = 0; i < p; ++i){\n      cin >> c[i];\n    }\n    \n    for(int k = 0; k < n; ++k){\n      for(int i = 0; i < n; ++i){\n\tfor(int j = 0; j < n; ++j){\n\t  d[i][j] = min( d[i][j], d[i][k]+d[k][j] );\n\t}\n      }\n    }\n    \n    for(int i = 0; i < n; ++i){\n      for(int j = 0; j < G[i].con.size(); ++j){\n\tint u = i;\n\tint v = G[i].con[j];\n\tint w = G[i].cost[j];\n\tif( d[0][u]+w+d[v][n-1] == d[0][n-1] ){\n\t  DAG[u].con.push_back(v);\n\t  rDAG[v].con.push_back(u);\n\t  DAG[v].in.push_back(u);\n\t  rDAG[u].in.push_back(v);\n\t}\n      }\n    }\n\n    double sgPath = topologicalSort( DAG, n, 0, n-1 );\n    for(int i = 0; i < p; ++i){\n      cPath[i] = topologicalSort( DAG, n, 0, c[i] );\n      //cout << cPath[i] << ' ';\n      cPath[i] *= topologicalSort( rDAG, n, n-1, c[i] );\n      //cout << cPath[i] << endl;\n      printf(\"%.12lf\\n\", cPath[i]/sgPath );\n    }\n    putchar('\\n');\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\nint cnt[100] = {0};\n\nint main(){\n\tint n, m, p, a, b, w;\n\tint minw[100] = {0};\n\t\n\tfor( ; cin >> n >> m >> p, n; ){\n\t\tfill( minw, minw + 100, 100000000 );\n\t\tfill( cnt, cnt + 100, 0 );\n\t\tminw[0] = 0;\n\t\tcnt[0] = 1;\n\n\t\tvector<vector<pii> > wts(n);\n\t\tfor( ; m--; ){\n\t\t\tcin >> a >> b >> w;\n\t\t\twts[a].push_back( pii( w, b ) );\n\t\t\twts[b].push_back( pii( w, a ) );\n\t\t}\n\n\t\tvector<vector<int> > froms(n);\n\t\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tfor( qu.push( pii( 0, 0 ) ); ; ){\n\n\t\t\tpii p = qu.top();\n\t\t\tqu.pop();\n\n\t\t\tif( p.second == n - 1 ){\tbreak;\t}\n\t\t\tif( p.first != minw[p.second] ){\tcontinue;\t}\n\n\t\t\tminw[p.second] = -1;\n\t\t\tvector<pii> &wt = wts[p.second];\n\t\t\tfor( vector<pii>::iterator it = wt.begin(); it != wt.end(); ++it ){\n\t\t\t\tw = p.first + it->first;\nif(cnt[p.second]<0)return 1;\n\t\t\t\tif( minw[it->second] == w ){\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tcnt[it->second] += cnt[p.second];\n\t\t\t\t}\n\t\t\t\telse if( minw[it->second] > w ){\n\t\t\t\t\tfroms[it->second].clear();\n\t\t\t\t\tfroms[it->second].push_back( p.second );\n\t\t\t\t\tminw[it->second] = w;\n\t\t\t\t\tcnt[it->second] = cnt[p.second];\n\t\t\t\t\tqu.push( pii( w, it->second ) );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\nif(!cnt[n-1])return 0;\n\t\tint to_cnt[100] = {0};\n\t\tvector<vector<int> >::iterator it1;\n\t\tfor( it1 = froms.begin(); it1 != froms.end(); ++it1 ){\n\t\t\tvector<int>::iterator it2;\n\t\t\tfor( it2 = it1->begin(); it2 != it1->end(); ++it2 ){\n\t\t\t\t++to_cnt[*it2];\n\t\t\t}\n\t\t}\n\t\t\n\t\tint cnt2[100] = {0};\n\t\tcnt2[n-1] = cnt[n-1];\n\t\tstack<int> stk;\n\t\tfor( stk.push( n - 1 ); !stk.empty(); ){\n\t\t\ta = stk.top();\n\t\t\tstk.pop();\n\t\t\t\n//\t\t\tif(!cnt[a])return 0;\n\t\t\t\n\t\t\tint r = cnt2[a] / cnt[a];\n\t\t\tvector<int>::iterator it;\n\t\t\tfor( it = froms[a].begin(); it != froms[a].end(); ++it ){\n\t\t\t\tcnt2[*it] += r * cnt[*it];\n\t\t\t\tif( !--to_cnt[*it] ){\tstk.push(*it);\t}\n\t\t\t}\n\t\t}\n\n\t\tfor( ; p--; ){\n\t\t\tcin >> a;\n\t\t\tprintf(\"%.9f\\n\", (double)cnt2[a] / cnt2[n-1] );\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\nint g[110][110];\nvector<int>g2[110];\nint p[11000];\nint q[11000];\nint r[11000];\npair<int,int> pt[110];\ndouble dp[110];\ndouble dp2[110];\nint main(){\n    int a,b,c;\n    while(scanf(\"%d%d%d\",&a,&b,&c),a){\n        for(int i=0;i<a;i++)for(int j=0;j<a;j++)g[i][j]=999999999;\n        for(int i=0;i<a;i++)g[i][i]=0;\n        for(int i=0;i<a;i++){g2[i].clear();}\n        for(int i=0;i<b;i++){\n            scanf(\"%d%d%d\",p+i,q+i,r+i);\n            g[p[i]][q[i]]=g[q[i]][p[i]]=r[i];\n        }\n        for(int k=0;k<a;k++)for(int i=0;i<a;i++)for(int j=0;j<a;j++)\n            g[i][j]=min(g[i][j],g[i][k]+g[k][j]);\n        for(int i=0;i<b;i++){\n            int P=p[i];\n            int Q=q[i];\n            int R=r[i];\n            if(g[0][P]+R==g[0][Q]&&g[Q][a-1]+R==g[P][a-1]){\n                g2[P].push_back(Q);\n            }\n            swap(P,Q);\n            if(g[0][P]+R==g[0][Q]&&g[Q][a-1]+R==g[P][a-1]){\n                g2[P].push_back(Q);\n            }\n        }\n        for(int i=0;i<110;i++)dp[i]=0;\n        dp[0]=1;\n        for(int i=0;i<a;i++)pt[i]=make_pair(g[0][i],i);\n        std::sort(pt,pt+a);\n        for(int i=0;i<a;i++){\n            int at=pt[i].second;\n            for(int j=0;j<g2[at].size();j++){\n                dp[g2[at][j]]+=dp[at];\n            }\n        }\n\t\tlong long tot=dp[a-1];\n\t\t\n        for(int i=0;i<c;i++){\n            int t;scanf(\"%d\",&t);\n\t\t\tfor(int j=0;j<a;j++)dp2[j]=0;\n\t\t\tdp2[t]=1;\n\t\t\tfor(int j=0;j<a;j++){\n\t\t\t\tint at=pt[j].second;\n\t\t\t\tfor(int k=0;k<g2[at].size();k++){\n\t\t\t\t\tdp2[g2[at][k]]+=dp2[at];\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintf(\"%.12f\\n\",dp2[a-1]*dp[t]/tot);\n        }\n        printf(\"\\n\");\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <algorithm>\nusing namespace std;\n\nconst int N = 110;\nconst int M = 1000010;\nconst int inf = 1000000000;\n\nstruct Edge\n{\n    int f, t, d;\n}e[M];\n\nint point[N], next[M], ne;\nint dis[2][N], q[N];\nbool u[N];\n\nvoid add_edge(int f, int t, int d)\n{\n    e[ne].f = f, e[ne].t = t, e[ne].d = d;\n    next[ne] = point[f], point[f] = ne++;\n}\n\nvoid spfa(int s, int n, int k)\n{\n    int i, tmp, f, r;\n    for(i = 0; i < n; ++i) {\n        dis[k][i] = inf;\n        u[i] = false;\n    }\n    dis[k][s] = 0;\n    u[s] = true;\n    f = 0, r = 1;\n    q[f] = s;\n    while(f != r) {\n        tmp = q[f];\n        f = (f + 1) % n;\n        u[tmp] = false;\n        for(i = point[tmp]; i != -1; i = next[i]) {\n            if(dis[k][e[i].t] > dis[k][tmp] + e[i].d) {\n                dis[k][e[i].t] = dis[k][tmp] + e[i].d;\n                if(!u[e[i].t]) {\n                    u[e[i].t] = true;\n                    q[r] = e[i].t;\n                    r = (r + 1) % n;\n                }\n            }\n        }\n    }\n}\n\nstruct Node\n{\n    int d, id;\n    long long cnt;\n    bool operator < (const Node &x) const {\n        return d < x.d;\n    }\n    double p;\n}qi[N];\n\nbool cmp(const Node &x, const Node &y)\n{\n    return x.id < y.id;\n}\n\nint qid[N];\nlong long cnt[N];\n\nvoid update(int s, int n)\n{\n    for(int i = 0; i < n; ++i)\n        qid[qi[i].id] = i;\n    qi[0].cnt = 1;\n    qi[0].p = 1.0;\n    for(int i = 0; i < n; ++i) {\n        int f = qi[i].id;\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                qi[qid[t]].cnt += qi[i].cnt;\n        }\n    }\n    qi[0].cnt = qi[qid[n - 1]].cnt;\n\n    for(int k = 1; k < n; ++k) {\n        memset(cnt, 0, sizeof(cnt));\n        cnt[0] = 1;\n        for(int i = 0; i < n; ++i) {\n            if(i == k)  continue;\n            int f = qi[i].id;\n            for(int j = point[f]; j != -1; j = next[j]) {\n                int t = e[j].t;\n                if(!u[t])   continue;\n                if(dis[0][f] + e[j].d == dis[0][t])\n                    cnt[qid[t]] += cnt[i];\n            }\n        }\n        if(k != qid[n - 1])\n            qi[k].cnt = qi[qid[n - 1]].cnt - cnt[qid[n - 1]];\n    }/*\n    for(int i = 0; i < n; ++i) {\n        int tot = 0;\n        int f = qi[i].id;\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                ++tot;\n        }\n        for(int j = point[f]; j != -1; j = next[j]) {\n            int t = e[j].t;\n            if(!u[t])   continue;\n            if(dis[0][f] + e[j].d == dis[0][t])\n                qi[qid[t]].p += qi[i].p / tot;\n        }\n    }*/\n}\n\nint main()\n{\n    int i, n, m, p, a, b, d, iid;\n    while(scanf(\"%d%d%d\", &n, &m, &p) && n + m + p) {\n        ne = 0;\n        memset(point, -1, sizeof(point));\n        for(i = 0; i < m; ++i) {\n            scanf(\"%d%d%d\", &a, &b, &d);\n            add_edge(a, b, d);\n            add_edge(b, a, d);\n        }\n        spfa(0, n, 0);\n        spfa(n - 1, n, 1);\n        /*for(int j = 0; j < 2; ++j) {\n            printf(\"********\\n\");\n            for(i = 0; i < n; ++i) {\n                printf(\"%d: %d\\n\", i, dis[j][i]);\n            }\n        }*/\n        memset(u, false, sizeof(u));\n        for(i = 0; i < n; ++i) {\n            qi[i].d = dis[0][i];\n            qi[i].cnt = 0, qi[i].id = i;\n            qi[i].p = 0;\n            if(dis[0][i] + dis[1][i] == dis[0][n - 1])\n                u[i] = true;\n        }\n        sort(qi, qi + n);\n        update(0, n);\n        sort(qi, qi + n, cmp);\n        while(p--) {\n            scanf(\"%d\", &iid);\n            if(qi[n - 1].cnt == 0) {\n                printf(\"0.00000000\\n\");\n            }\n            else {\n                printf(\"%.8f\\n\", qi[iid].cnt * 1.0 / qi[n - 1].cnt);\n            }/*\n            if(qi[n - 1].p < 1e-8) {\n                printf(\"0.00000000\\n\");\n            }\n            else {\n                printf(\"%.8f\\n\", qi[iid].p);\n            }*/\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define dump(...) cout<<\"# \"<<#__VA_ARGS__<<'='<<(__VA_ARGS__)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define peri(i,a,b) for(int i=int(b);i-->int(a);)\n#define rep(i,n) repi(i,0,n)\n#define per(i,n) peri(i,0,n)\n#define all(c) begin(c),end(c)\n#define mp make_pair\n#define mt make_tuple\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int,int> pii;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<ll> vl;\ntypedef vector<vl> vvl;\ntypedef vector<double> vd;\ntypedef vector<vd> vvd;\ntypedef vector<string> vs;\n\ntemplate<typename T1,typename T2>\nostream& operator<<(ostream& os,const pair<T1,T2>& p){\n\treturn os<<'('<<p.first<<','<<p.second<<')';\n}\n\ntemplate<typename Tuple>\nvoid print_tuple(ostream&,const Tuple&){}\ntemplate<typename Car,typename... Cdr,typename Tuple>\nvoid print_tuple(ostream& os,const Tuple& t){\n\tprint_tuple<Cdr...>(os,t);\n\tos<<(sizeof...(Cdr)?\",\":\"\")<<get<sizeof...(Cdr)>(t);\n}\ntemplate<typename... Args>\nostream& operator<<(ostream& os,const tuple<Args...>& t){\n\tprint_tuple<Args...>(os<<'(',t);\n\treturn os<<')';\n}\n\ntemplate<typename Ch,typename Tr,typename C,typename=decltype(begin(C()))>\nbasic_ostream<Ch,Tr>& operator<<(basic_ostream<Ch,Tr>& os,const C& c){\n\tos<<'[';\n\tfor(auto i=begin(c);i!=end(c);++i)\n\t\tos<<(i==begin(c)?\"\":\" \")<<*i;\n\treturn os<<']';\n}\n\nconstexpr int INF=1e9;\nconstexpr int MOD=1e9+7;\nconstexpr double EPS=1e-9;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\ntypedef vector<vector<Edge>> Graph;\n\nvoid chmin(int& a,int b)\n{\n\ta=min(a,b);\n}\n\nint main()\n{\n\tfor(int n,m,s;cin>>n>>m>>s && n|m|s;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint u,v,w; cin>>u>>v>>w;\n\t\t\tg[u].emplace_back(u,v,w);\n\t\t\tg[v].emplace_back(v,u,w);\n\t\t}\n\t\tvi cs(s);\n\t\trep(i,s) cin>>cs[i];\n\t\t\n\t\tvvi dp(n,vi(n,INF));\n\t\trep(i,n) dp[i][i]=0;\n\t\trep(i,n) for(auto e:g[i]) chmin(dp[e.src][e.dst],e.weight);\n\t\trep(k,n) rep(i,n) rep(j,n) chmin(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\n\t\tvi is(n); iota(all(is),0);\n\t\tvd cnt1(n,0); cnt1[0]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]<dp[0][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[e.src][e.dst]+dp[e.dst][n-1]==dp[e.src][n-1]) cnt1[e.dst]+=cnt1[e.src];\n\t\tvd cnt2(n,0); cnt2[n-1]=1;\n\t\tsort(all(is),[&](int i,int j){return dp[0][i]>dp[0][j];});\n\t\tfor(auto i:is) for(auto e:g[i]) if(dp[0][e.dst]+dp[e.dst][e.src]==dp[0][e.src]) cnt2[e.dst]+=cnt2[e.src];\n\t\t\n\t\tfor(auto i:cs) printf(\"%.8f\\n\",cnt1[i]*cnt2[i]/cnt1[n-1]); puts(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\nconst int INF=1<<29;\n\nclass edge{\npublic:\n\tint v,cost;\n\tedge(int v,int cost):v(v),cost(cost){}\n};\n\nint main(){\n\tfor(int n,m,k;scanf(\"%d%d%d\",&n,&m,&k),n;){\n\t\tvector<edge> G[100];\n\t\tint d[100][100];\n\t\trep(u,n) rep(v,n) d[u][v]=(u==v?0:INF);\n\t\trep(_,m){\n\t\t\tint u,v,cost; scanf(\"%d%d%d\",&u,&v,&cost);\n\t\t\td[u][v]=d[v][u]=cost;\n\t\t\tG[u].push_back(edge(v,cost));\n\t\t\tG[v].push_back(edge(u,cost));\n\t\t}\n\n\t\trep(w,n) rep(u,n) rep(v,n) d[u][v]=min(d[u][v],d[u][w]+d[w][v]);\n\n\t\tdouble dp[100][100]={}; // dp[u][v] := ( u->v 間の最短経路の個数 )\n\t\t// 謎の魔法によって Floyd で最短経路の個数が計算できる\n\t\t// rep(u,n) rep(i,G[u].size()) {\n\t\t\t// int v=G[u][i].v,cost=G[u][i].cost;\n\t\t\t// if(d[0][u]+cost+d[v][n-1]==d[0][n-1]) dp[u][v]=1; // 最初は dp には最短経路 DAG の隣接行列が入っている\n\t\t// }\n\t\t// rep(w,n) rep(u,n) rep(v,n) dp[u][v]+=dp[u][w]*dp[w][v];\n\n\t\t// まじめに Dijkstra してもよい\n\t\trep(u,n){\n\t\t\tdp[u][u]=1;\n\t\t\tint d2[100];\n\t\t\trep(v,n) d2[v]=(v==u?0:INF);\n\t\t\tpriority_queue< pair<int,int> > Q; Q.push(make_pair(0,u));\n\t\t\twhile(!Q.empty()){\n\t\t\t\tint d_now=-Q.top().first,v=Q.top().second; Q.pop();\n\t\t\t\trep(i,G[v].size()){\n\t\t\t\t\tint w=G[v][i].v,cost=G[v][i].cost;\n\t\t\t\t\tif(d[0][v]+cost+d[w][n-1]==d[0][n-1]){ // 最短経路 DAG の辺であるかどうか\n\t\t\t\t\t\tif(d2[w]>=d2[v]+cost){\n\t\t\t\t\t\t\tif(d2[w]>d2[v]+cost){\n\t\t\t\t\t\t\t\td2[w]=d2[v]+cost;\n\t\t\t\t\t\t\t\tQ.push(make_pair(-d2[w],w));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tdp[u][w]+=dp[u][v];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\trep(_,k){\n\t\t\tint c; scanf(\"%d\",&c);\n\t\t\tprintf(\"%.9f\\n\",dp[0][c]*dp[c][n-1]/dp[0][n-1]);\n\t\t}\n\t\tputs(\"\");\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nstruct edge\n{\n  int to, cost;\n};\n\ntypedef pair< int, int > Pi;\nconst int INF = 1LL << 30;\n\nint N, M, P;\nint v1[100], v2[100];\ndouble dp1[100], dp2[100];\nvector< vector< edge > > g;\n\nvoid Dijkstra(int s, int *v, double *dp)\n{\n  priority_queue< Pi, vector< Pi >, greater< Pi > > que;\n  fill_n(v, N, INF);\n  fill_n(dp, N, 0);\n\n  que.emplace(0, s);\n  v[s] = 0;\n  dp[s] = 1;\n\n  while(!que.empty()) {\n    auto p = que.top();\n    que.pop();\n    if(p.first > v[p.second]) continue;\n    for(auto &e : g[p.second]) {\n      if(p.first + e.cost < v[e.to]) {\n        v[e.to] = p.first + e.cost;\n        dp[e.to] = dp[p.second];\n        que.emplace(v[e.to], e.to);\n      } else if(p.first + e.cost == v[e.to]) {\n        dp[e.to] += dp[p.second];\n      }\n    }\n  }\n}\n\nint main()\n{\n  cout << fixed << setprecision(10);\n\n  while(cin >> N >> M >> P, N) {\n    g.resize(N);\n\n    while(M--) {\n      int X, Y, Z;\n      cin >> X >> Y >> Z;\n      g[X].emplace_back((edge) {Y, Z});\n      g[Y].emplace_back((edge) {X, Z});\n    }\n    Dijkstra(0, v1, dp1);\n    Dijkstra(N - 1, v2, dp2);\n\n    while(P--) {\n      int A;\n      cin >> A;\n      if(v1[A] + v2[A] == v1[N - 1])\n        cout << (double) dp1[A] * dp2[A] / dp1[N - 1] << endl;\n      else\n        cout << 0 << endl;\n    }\n    cout << endl;\n\n    g.clear();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n#endif\n\n#define foreach(it, c) for (__typeof__((c).begin()) it=(c).begin(); it != (c).end(); ++it)\n#define all(c) (c).begin(), (c).end()\n#define rall(c) (c).rbegin(), (c).rend()\n#define CLEAR(arr, val) memset(arr, val, sizeof(arr))\n\n#define rep(i, n) for (int i = 0; i < n; ++i)\n\ntemplate <class T> void max_swap(T& a, const T& b) { a = max(a, b); }\ntemplate <class T> void min_swap(T& a, const T& b) { a = min(a, b); }\n\ntypedef long long ll;\ntypedef pair<int, int> pint;\n\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nconst int dx[] = { 0, 1, 0, -1 };\nconst int dy[] = { 1, 0, -1, 0 };\n\n\nstruct Edge\n{\n\tint to, cost;\n\tEdge(int to, int cost)\n\t\t: to(to), cost(cost) {}\n};\n\nvector<vector<int> > prev_nodes(const vector<vector<Edge> >& edges)\n{\n\tint n = edges.size();\n\n\tconst int INF = 1e7;\n\tvector<int> dis(n, INF);\n\tvector<vector<int> > prevv(n);\n\tpriority_queue<pint, vector<pint>, greater<pint> > q;\n\tdis[0] = 0;\n\tq.push(pint(0, 0));\n\twhile (!q.empty())\n\t{\n\t\tpint tt = q.top(); q.pop();\n\t\tint cur = tt.second, cost = tt.first;\n\n\t\tif (cost > dis[cur])\n\t\t\tcontinue;\n\n\t\tforeach (e, edges[cur])\n\t\t{\n\t\t\tint to = e->to, nc = cost + e->cost;\n\t\t\tif (nc < dis[to])\n\t\t\t{\n\t\t\t\tdis[to] = nc;\n\t\t\t\tprevv[to].clear();\n\t\t\t\tprevv[to].push_back(cur);\n\t\t\t\tq.push(pint(nc, to));\n\t\t\t}\n\t\t\telse if (nc == dis[to])\n\t\t\t\tprevv[to].push_back(cur);\n\t\t}\n\t}\n\n\treturn prevv;\n}\n\nvector<vector<int> > rev(const vector<vector<int> >& e)\n{\n\tvector<vector<int> > res(e.size());\n\tfor (int i = 0; i < e.size(); ++i)\n\t\tfor (int j = 0; j < e[i].size(); ++j)\n\t\t\tres[e[i][j]].push_back(i);\n\treturn res;\n}\n\n\nll in_paths(vector<ll>& dp, const vector<vector<int> >& e, int v)\n{\n\tif (dp[v] != -1)\n\t\treturn dp[v];\n\telse if (e[v].empty())\n\t\treturn dp[v] = 1;\n\n\tll res = 0;\n\tfor (int i = 0; i < e[v].size(); ++i)\n\t\tres += in_paths(dp, e, e[v][i]);\n\treturn dp[v] = res;\n}\nint main()\n{\n\tint n, m, p;\n\twhile (cin >> n >> m >> p, n)\n\t{\n\t\tvector<vector<Edge> > edges(n);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> b >> c;\n\t\t\tedges[a].push_back(Edge(b, c));\n\t\t\tedges[b].push_back(Edge(a, c));\n\t\t}\n\t\tvector<vector<int> > prevv = prev_nodes(edges);\n\n\t\tvector<ll> in(n, -1), out(n, -1);\n\t\tin_paths(in, prevv, n - 1);\n\t\tin_paths(out, rev(prevv), 0);\n\n\t\tvector<ll> paths(n);\n\t\tfor (int i = 0; i < n; ++i)\n\t\t\tpaths[i] = in[i] * out[i];\n\t\tll total_paths = paths[0];\n\n\t\twhile (p--)\n\t\t{\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\t\n\t\t\tprintf(\"%.8f\\n\", (double)paths[c] / total_paths);\n\t\t}\n\t\tputs(\"\");\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Data {\n  int cur;\n  ll w;\n  bool operator < ( const Data &data ) const {\n    if( w != data.w ) return w < data.w;\n    return cur < data.cur;\n  }\n};\n\nconst ll LLINF = LLONG_MAX;\nconst int MAX_V = 110;\nint n,m,p;\nll fw[110][110];\nll dp[MAX_V];\nvector<Data> G[MAX_V];\n\nint main(){\n  while( cin >> n >> m >> p, n|m|p ){\n    rep(i,n) G[i].clear();\n    rep(i,n) rep(j,n) fw[i][j] = ((i==j)?0:LLINF);\n    rep(i,m) {\n      int s,t;\n      ll c;\n      cin >> s >> t >> c;\n      G[s].push_back((Data){t,c});\n      G[t].push_back((Data){s,c});\n      fw[s][t] = fw[t][s] = c;\n    }\n    rep(k,n) rep(i,n) rep(j,n) if( fw[i][k] != LLINF && fw[k][j] != LLINF ) fw[i][j] = min(fw[i][j],\n\t\t\t\t\t\t\t\t\t\t\t   fw[i][k]+fw[k][j]);\n\n    vector<Data> vec;\n    rep(i,n) vec.push_back((Data){i,fw[0][i]});\n    sort(vec.begin(),vec.end());  \n    rep(i,n) dp[i] = 0;\n    dp[0] = 1;\n    rep(i,vec.size()) {\n      int cur = vec[i].cur;\n      if( fw[0][cur] == LLINF || fw[cur][n-1] == LLINF ) continue;\n      ll weight = vec[i].w;\n      rep(i,G[cur].size()) if( cur != G[cur][i].cur ){\n\tint next = G[cur][i].cur;\n\tif( fw[0][next] == LLINF || fw[next][n-1] == LLINF ) continue;\n\tif( fw[0][next] == fw[0][cur] + G[cur][i].w ) {\n\t  dp[next] += dp[cur];\n\t}\n      }\n    }\n\n    rep(i,p){\n      int pos;\n      cin >> pos;\n      if( pos == 0 || pos == n-1 ) { puts(\"1.0000000000000\"); }\n      else {\n\tprintf(\"%.10f\\n\",dp[pos]/(double)dp[n-1]);\n      }\n    } puts(\"\");\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long int\n\ntypedef struct tag_pair{\n\tint Pos;\n\tint Cost;\n}Pair;\t\n\nPair nP(int p,int c){Pair P;P.Pos=p;P.Cost=c;return P;}\n\nint cmp(const void *a,const void *b);\nint WF[102][102];\n\nPair E[102][102];\nint Ec[102];\nint From[102],To[102],Cost[102];\n\nll dp[102];\nll dp2[102];\n\n\nint Min(int x,int y){return x>y?y:x;}\n\nint main(){\n\tint N,M,P;\n\tint i,j,k;\n\tint c;\n\tint now;\n\twhile(1){\n\t\tscanf(\"%d %d %d\\n\",&N,&M,&P);\n\t\tif(N==0&&M==0&&P==0)break;\n\t\tint Inf=(int)1e9;\n\t\tfor(i=0;i<N;i++)for(j=0;j<N;j++)WF[i][j]=(i==j)?0:Inf;\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tscanf(\"%d %d %d\\n\",&From[i],&To[i],&Cost[i]);\n\t\t\tWF[From[i]][To[i]]=WF[To[i]][From[i]]=Cost[i];\n\t\t}\n\t\t\n\t\tfor(k=0;k<N;k++){\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//0->N-1????????????????????????edge????????????\n\t\tfor(i=0;i<N;i++)Ec[i]=0;\n\t\tfor(i=0;i<M;i++){\n\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i]){\n\t\t\t\tE[From[i]][Ec[From[i]]]=nP(To[i],Cost[i]);\n\t\t\t\tEc[From[i]]++;\n\t\t\t}\n\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i]){\n\t\t\t\tE[To[i]][Ec[To[i]]]=nP(From[i],Cost[i]);\n\t\t\t\tEc[To[i]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPair tmp[N];\n\t\tfor(i=0;i<N;i++){\n\t\t\ttmp[i]=nP(i,WF[i][N-1]);//???->N-1??????????????¢\n\t\t}\n\t\tqsort(tmp,N,sizeof(Pair),cmp);\n\t\t\n\t\tfor(i=0;i<N;i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(i=0;i<N;i++){\n\t\t\tnow=tmp[i].Pos;\n\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\tdp[E[now][j].Pos]+=dp[now];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(;P>0;P--){\n\t\t\tscanf(\"%d\\n\",&c);\n\t\t\tfor(i=0;i<N;i++)dp2[i]=0;//dp2[i]:c??????i???????????????????????°\n\t\t\tdp2[c]=1;\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tnow=tmp[i].Pos;\n\t\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\t\tdp2[E[now][j].Pos]+=dp2[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble prob=(double)dp[c];\n\t\t\tprob/=(double)dp[N-1];\n\t\t\tprob*=(double)dp2[N-1];\n\t\t\t//printf(\"%.12f\\n\",prob);\n\t\t\tprintf(\"0.123456\\n\");\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n\nint cmp(const void *x,const void *y){//???????????????\n\tPair X=*(Pair *)x;\n\tPair Y=*(Pair *)y;\n\t\n\treturn X.Cost>Y.Cost?-1:X.Cost<Y.Cost?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long int\n\ntypedef struct tag_pair{\n\tint Pos;\n\tint Cost;\n}Pair;\t\n\nPair nP(int p,int c){Pair P;P.Pos=p;P.Cost=c;return P;}\n\nint cmp(const void *a,const void *b);\nint WF[102][102];\n\nPair E[102][102];\nint Ec[102];\nint From[102],To[102],Cost[102];\n\nll dp[102];\nll dp2[102];\n\n\nint Min(int x,int y){return x>y?y:x;}\n\nint main(){\n\tint N,M,P;\n\tint i,j,k;\n\tint c;\n\tint now;\n\twhile(1){\n\t\tscanf(\"%d %d %d\\n\",&N,&M,&P);\n\t\tif(N==0&&M==0&&P==0)break;\n\t\tint Inf=(int)1e9;\n\t\tfor(i=0;i<N;i++)for(j=0;j<N;j++)WF[i][j]=(i==j)?0:Inf;\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tscanf(\"%d %d %d\\n\",&From[i],&To[i],&Cost[i]);\n\t\t\tWF[From[i]][To[i]]=WF[To[i]][From[i]]=Cost[i];\n\t\t}\n\t\t\n\t\tfor(k=0;k<N;k++){\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//0->N-1????????????????????????edge????????????\n\t\tfor(i=0;i<N;i++)Ec[i]=0;\n\t\tfor(i=0;i<M;i++){\n\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i]){\n\t\t\t\tE[From[i]][Ec[From[i]]]=nP(To[i],Cost[i]);\n\t\t\t\tEc[From[i]]++;\n\t\t\t}\n\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i]){\n\t\t\t\tE[To[i]][Ec[To[i]]]=nP(From[i],Cost[i]);\n\t\t\t\tEc[To[i]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPair tmp[N];\n\t\tfor(i=0;i<N;i++){\n\t\t\ttmp[i]=nP(i,WF[i][N-1]);//???->N-1??????????????¢\n\t\t}\n\t\tqsort(tmp,N,sizeof(Pair),cmp);\n\t\t\n\t\tfor(i=0;i<N;i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(i=0;i<N;i++){\n\t\t\tnow=tmp[i].Pos;\n\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\tdp[E[now][j].Pos]+=dp[now];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(;P>0;P--){\n\t\t\tscanf(\"%d\",&c);\n\t\t\tfor(i=0;i<N;i++)dp2[i]=0;//dp2[i]:c??????i???????????????????????°\n\t\t\tdp2[c]=1;\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tnow=tmp[i].Pos;\n\t\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\t\tdp2[E[now][j].Pos]+=dp2[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble prob=(double)dp[c];\n\t\t\tprob/=(double)dp[N-1];\n\t\t\tprob*=(double)dp2[N-1];\n\t\t\tprintf(\"%.12f\\n\",prob);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n\nint cmp(const void *x,const void *y){//???????????????\n\tPair X=*(Pair *)x;\n\tPair Y=*(Pair *)y;\n\t\n\treturn X.Cost>Y.Cost?-1:X.Cost<Y.Cost?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll double\n\ntypedef struct tag_pair{\n\tint Pos;\n\tint Cost;\n}Pair;\t\n\nPair nP(int p,int c){Pair P;P.Pos=p;P.Cost=c;return P;}\n\nint cmp(const void *a,const void *b);\nint WF[102][102];\n\nPair E[102][102];\nint Ec[102];\nint From[6000],To[6000],Cost[6000];\n\nll dp[102];\nll dp2[102];\n\n\nint Min(int x,int y){return x>y?y:x;}\n\nint main(){\n\tint N,M,P;\n\tint i,j,k;\n\tint c;\n\tint now;\n\twhile(1){\n\t\tscanf(\"%d %d %d\\n\",&N,&M,&P);\n\t\tif(N==0&&M==0&&P==0)break;\n\t\tint Inf=(int)1e9;\n\t\tfor(i=0;i<N;i++)for(j=0;j<N;j++)WF[i][j]=(i==j)?0:Inf;\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tscanf(\"%d %d %d\\n\",&From[i],&To[i],&Cost[i]);\n\t\t\tWF[From[i]][To[i]]=WF[To[i]][From[i]]=Cost[i];\n\t\t}\n\t\t\n\t\tfor(k=0;k<N;k++){\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//0->N-1????????????????????????edge????????????\n\t\tfor(i=0;i<N;i++)Ec[i]=0;\n\t\tfor(i=0;i<M;i++){\n\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i]){\n\t\t\t\tE[From[i]][Ec[From[i]]]=nP(To[i],Cost[i]);\n\t\t\t\tEc[From[i]]++;\n\t\t\t}\n\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i]){\n\t\t\t\tE[To[i]][Ec[To[i]]]=nP(From[i],Cost[i]);\n\t\t\t\tEc[To[i]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPair tmp[N];\n\t\tfor(i=0;i<N;i++){\n\t\t\ttmp[i]=nP(i,WF[i][N-1]);//???->N-1??????????????¢\n\t\t}\n\t\tqsort(tmp,N,sizeof(Pair),cmp);\n\t\t\n\t\tfor(i=0;i<N;i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(i=0;i<N;i++){\n\t\t\tnow=tmp[i].Pos;\n\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\tdp[E[now][j].Pos]+=dp[now];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(;P>0;P--){\n\t\t\tscanf(\"%d\",&c);\n\t\t\tfor(i=0;i<N;i++)dp2[i]=0;//dp2[i]:c??????i???????????????????????°\n\t\t\tdp2[c]=1;\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tnow=tmp[i].Pos;\n\t\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\t\tdp2[E[now][j].Pos]+=dp2[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble prob=(double)dp[c];\n\t\t\tprob/=(double)dp[N-1];\n\t\t\tprob*=(double)dp2[N-1];\n\t\t\tprintf(\"%.12f\\n\",prob);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n\nint cmp(const void *x,const void *y){//???????????????\n\tPair X=*(Pair *)x;\n\tPair Y=*(Pair *)y;\n\t\n\treturn X.Cost>Y.Cost?-1:X.Cost<Y.Cost?1:0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ 1058 Winter Bells\n// 2018.3.1 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 500\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\nint hi[101], to[101][101], w[101][101];\nint dist1[101], dist2[101];\ndouble path1[101], path2[101];  \n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int n, int start, int *dist, double *path)\n{\n\tint i, s, e, d, nd;\n\n\tmemset(dist, INF, n << 2);\n\tmemset(path, 0, sizeof(double)*n);\n\tqsize = 0;\n\tdist[start] = 0, path[start] = 1, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, d = que[0].t, deq();\n\t\tif (dist[s] < d) continue;\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], nd = d + w[s][i];\n\t\t\tif (dist[e] < nd) continue;\n\t\t\tif (dist[e] > nd) path[e] = 0, dist[e] = nd, enq(e, nd);\n\t\t\tpath[e] += path[s];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, m, p, k, a, b, c;\n\n\twhile (n = in()) {\n\t\tm = in(), p = in();\n\n\t\tmemset(hi, 0, n << 2);\n\t\twhile (m--) {\n\t\t\ta = in(), b = in(), c = in();\n\t\t\tk = hi[a]++, to[a][k] = b, w[a][k] = c;\n\t\t\tk = hi[b]++, to[b][k] = a, w[b][k] = c;\n\t\t}\n\n\t\tdijkstra(n,   0, dist1, path1);\n\t\tdijkstra(n, n-1, dist2, path2);\n\n\t\twhile (p--) {\n\t\t\tc = in();\n\t\t\tif (dist1[c] + dist2[c] == dist2[0])\n\t\t\t\tprintf(\"%.12lf\\n\", (path1[c] * path2[c]) / path2[0]);\n\t\t\telse puts(\"0.000000000000\");\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "// AOJ 1058 Winter Bells\n// 2018.3.1 bal4u\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define QMAX 15000\ntypedef struct { int t, s; } QUE;\nQUE que[QMAX]; int qsize;\n\n#define PARENT(i) ((i)>>1)\n#define LEFT(i)   ((i)<<1)\n#define RIGHT(i)  (((i)<<1)+1)\n\nvoid min_heapify(int i)\n{\n\tint l, r, min;\n\tQUE qt;\n\n\tl = LEFT(i), r = RIGHT(i);\n\tif (l < qsize && que[l].t < que[i].t) min = l; else min = i;\n\tif (r < qsize && que[r].t < que[min].t) min = r;\n\tif (min != i) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\tmin_heapify(min);\n\t}\n}\n\nvoid deq()\n{\n\tque[0] = que[--qsize];\n\tmin_heapify(0);\n}\n\nvoid enq(int s, int t)\n{\n\tint i, min;\n\tQUE qt;\n\n\ti = qsize++;\n\tque[i].s = s, que[i].t = t;\n\twhile (i > 0 && que[min = PARENT(i)].t > que[i].t) {\n\t\tqt = que[i], que[i] = que[min], que[min] = qt;\n\t\ti = min;\n\t}\n}\n\n#define INF 0x10101010\nint hi[101], to[101][101], w[101][101];\nint dist1[101], dist2[101];\nint shot1[101], shot2[101];  \n\n//#define getchar_unlocked()  getchar()\nint in()\n{\n\tint n = 0;\n\tint c = getchar_unlocked();\n\tdo n = 10*n + (c & 0xf), c = getchar_unlocked();\n\twhile (c >= '0');\n\treturn n;\n}\n\nvoid dijkstra(int n, int start, int *dist, int *shot)\n{\n\tint i, s, d, e;\n\n\tmemset(dist, INF, n << 2);\n\tmemset(shot, 0, n << 2);\n\tqsize = 0;\n\tdist[start] = 0, shot[start] = 1, enq(start, 0);\n\twhile (qsize) {\n\t\ts = que[0].s, deq();\n\t\tfor (i = 0; i < hi[s]; i++) {\n\t\t\te = to[s][i], d = dist[s] + w[s][i];\n\t\t\tif (dist[e] < d) continue;\n\t\t\tif (dist[e] > d) shot[e] = shot[s], dist[e] = d, enq(e, d);\n\t\t\telse shot[e] += shot[s];\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint n, m, p, k, a, b, c;\n\n\twhile (n = in()) {\n\t\tm = in(), p = in();\n\n\t\tmemset(hi, 0, n << 2);\n\t\twhile (m--) {\n\t\t\ta = in(), b = in(), c = in();\n\t\t\tk = hi[a]++, to[a][k] = b, w[a][k] = c;\n\t\t\tk = hi[b]++, to[b][k] = a, w[b][k] = c;\n\t\t}\n\n\t\tdijkstra(n,   0, dist1, shot1);\n\t\tdijkstra(n, n-1, dist2, shot2);\n\n\t\twhile (p--) {\n\t\t\tc = in();\n\t\t\tif (dist1[c] + dist2[c] == dist1[n-1])\n\t\t\t\tprintf(\"%.8lf\\n\", ((double)shot1[c] * shot2[c]) / (double)shot1[n-1]);\n\t\t\telse puts(\"0.00000000\");\n\t\t}\n\t\tputchar('\\n');\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n//#define ll long long int\n#define ll double\n\ntypedef struct tag_pair{\n\tint Pos;\n\tint Cost;\n}Pair;\t\n\nPair nP(int p,int c){Pair P;P.Pos=p;P.Cost=c;return P;}\n\nint cmp(const void *a,const void *b);\nint cmp0(const void *a,const void *b);\nint WF[102][102];\n\nPair E[102][102];\nint Ec[102];\nint From[6000],To[6000],Cost[6000];\n\nll dp[102];\nll dp2[102];\n\n\nint Min(int x,int y){return x>y?y:x;}\n\nint main(){\n\tint N,M,P;\n\tint i,j,k;\n\tint c;\n\tint now;\n\twhile(1){\n\t\tscanf(\"%d %d %d\\n\",&N,&M,&P);\n\t\tif(N==0&&M==0&&P==0)break;\n\t\tint Inf=(int)1e9;\n\t\tfor(i=0;i<N;i++)for(j=0;j<N;j++)WF[i][j]=(i==j)?0:Inf;\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tscanf(\"%d %d %d\\n\",&From[i],&To[i],&Cost[i]);\n\t\t\tWF[From[i]][To[i]]=WF[To[i]][From[i]]=Cost[i];\n\t\t}\n\t\t\n\t\tfor(k=0;k<N;k++){\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=WF[j][i]=Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//0->N-1????????????????????????edge????????????\n\t\tfor(i=0;i<N;i++)Ec[i]=0;\n\t\tfor(i=0;i<M;i++){\n\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i] && WF[From[i]][0]+Cost[i]==WF[To[i]][0] ){\n\t\t\t\tE[From[i]][Ec[From[i]]]=nP(To[i],Cost[i]);\n\t\t\t\tEc[From[i]]++;\n\t\t\t}\n\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i] && WF[To[i]][0]+Cost[i]==WF[From[i]][0] ){\n\t\t\t\tE[To[i]][Ec[To[i]]]=nP(From[i],Cost[i]);\n\t\t\t\tEc[To[i]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPair tmp[N];\n\t\tfor(i=0;i<N;i++){\n\t\t\ttmp[i]=nP(i,WF[i][0]);//???->N-1??????????????¢\n\t\t}\n\t\tqsort(tmp,N,sizeof(Pair),cmp0);\n\t\t\n\t\tfor(i=0;i<N;i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(i=0;i<N;i++){\n\t\t\tnow=tmp[i].Pos;\n\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\tdp[E[now][j].Pos]+=dp[now];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(;P>0;P--){\n\t\t\tscanf(\"%d\",&c);\n\t\t\tfor(i=0;i<N;i++)dp2[i]=0;//dp2[i]:c??????i???????????????????????°\n\t\t\tdp2[c]=1;\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tnow=tmp[i].Pos;\n\t\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\t\tdp2[E[now][j].Pos]+=dp2[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble prob=(double)dp[c];\n\t\t\tprob/=(double)dp[N-1];\n\t\t\tprob*=(double)dp2[N-1];\n\t\t\tprintf(\"%.12f\\n\",prob);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n\nint cmp(const void *x,const void *y){//???????????????\n\tPair X=*(Pair *)x;\n\tPair Y=*(Pair *)y;\n\t\n\treturn X.Cost>Y.Cost?-1:X.Cost<Y.Cost?1:0;\n}\nint cmp0(const void *x,const void *y){//????????????\n\tPair X=*(Pair *)x;\n\tPair Y=*(Pair *)y;\n\t\n\treturn X.Cost>Y.Cost?1:X.Cost<Y.Cost?-1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long int\n\ntypedef struct tag_pair{\n\tint Pos;\n\tint Cost;\n}Pair;\t\n\nPair nP(int p,int c){Pair P;P.Pos=p;P.Cost=c;return P;}\n\nint cmp(const void *a,const void *b);\nint WF[102][102];\n\nPair E[102][102];\nint Ec[102];\nint From[6000],To[6000],Cost[6000];\n\nll dp[102];\nll dp2[102];\n\n\nint Min(int x,int y){return x>y?y:x;}\n\nint main(){\n\tint N,M,P;\n\tint i,j,k;\n\tint c;\n\tint now;\n\twhile(1){\n\t\tscanf(\"%d %d %d\\n\",&N,&M,&P);\n\t\tif(N==0&&M==0&&P==0)break;\n\t\tint Inf=(int)1e9;\n\t\tfor(i=0;i<N;i++)for(j=0;j<N;j++)WF[i][j]=(i==j)?0:Inf;\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tscanf(\"%d %d %d\\n\",&From[i],&To[i],&Cost[i]);\n\t\t\tWF[From[i]][To[i]]=WF[To[i]][From[i]]=Cost[i];\n\t\t}\n\t\t\n\t\tfor(k=0;k<N;k++){\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//0->N-1????????????????????????edge????????????\n\t\tfor(i=0;i<N;i++)Ec[i]=0;\n\t\tfor(i=0;i<M;i++){\n\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i]){\n\t\t\t\tE[From[i]][Ec[From[i]]]=nP(To[i],Cost[i]);\n\t\t\t\tEc[From[i]]++;\n\t\t\t}\n\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i]){\n\t\t\t\tE[To[i]][Ec[To[i]]]=nP(From[i],Cost[i]);\n\t\t\t\tEc[To[i]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPair tmp[N];\n\t\tfor(i=0;i<N;i++){\n\t\t\ttmp[i]=nP(i,WF[i][N-1]);//???->N-1??????????????¢\n\t\t}\n\t\tqsort(tmp,N,sizeof(Pair),cmp);\n\t\t\n\t\tfor(i=0;i<N;i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(i=0;i<N;i++){\n\t\t\tnow=tmp[i].Pos;\n\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\tdp[E[now][j].Pos]+=dp[now];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(;P>0;P--){\n\t\t\tscanf(\"%d\",&c);\n\t\t\tfor(i=0;i<N;i++)dp2[i]=0;//dp2[i]:c??????i???????????????????????°\n\t\t\tdp2[c]=1;\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tnow=tmp[i].Pos;\n\t\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\t\tdp2[E[now][j].Pos]+=dp2[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble prob=(double)dp[c];\n\t\t\tprob/=(double)dp[N-1];\n\t\t\tprob*=(double)dp2[N-1];\n\t\t\tprintf(\"%.12f\\n\",prob);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n\nint cmp(const void *x,const void *y){//???????????????\n\tPair X=*(Pair *)x;\n\tPair Y=*(Pair *)y;\n\t\n\treturn X.Cost>Y.Cost?-1:X.Cost<Y.Cost?1:0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long int\n\ntypedef struct tag_pair{\n\tint Pos;\n\tint Cost;\n}Pair;\t\n\nPair nP(int p,int c){Pair P;P.Pos=p;P.Cost=c;return P;}\n\nint cmp(const void *a,const void *b);\nint cmp0(const void *a,const void *b);\nint WF[102][102];\n\nPair E[102][102];\nint Ec[102];\nint From[6000],To[6000],Cost[6000];\n\nll dp[102];\nll dp2[102];\n\n\nint Min(int x,int y){return x>y?y:x;}\n\nint main(){\n\tint N,M,P;\n\tint i,j,k;\n\tint c;\n\tint now;\n\twhile(1){\n\t\tscanf(\"%d %d %d\\n\",&N,&M,&P);\n\t\tif(N==0&&M==0&&P==0)break;\n\t\tint Inf=(int)1e9;\n\t\tfor(i=0;i<N;i++)for(j=0;j<N;j++)WF[i][j]=(i==j)?0:Inf;\n\t\t\n\t\tfor(i=0;i<M;i++){\n\t\t\tscanf(\"%d %d %d\\n\",&From[i],&To[i],&Cost[i]);\n\t\t\tWF[From[i]][To[i]]=WF[To[i]][From[i]]=Cost[i];\n\t\t}\n\t\t\n\t\tfor(k=0;k<N;k++){\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tfor(j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t//0->N-1????????????????????????edge????????????\n\t\tfor(i=0;i<N;i++)Ec[i]=0;\n\t\tfor(i=0;i<M;i++){\n\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i] && WF[From[i]][0]+Cost[i]==WF[To[i]][0] ){\n\t\t\t\tE[From[i]][Ec[From[i]]]=nP(To[i],Cost[i]);\n\t\t\t\tEc[From[i]]++;\n\t\t\t}\n\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i] && WF[To[i]][0]+Cost[i]==WF[From[i]][0] ){\n\t\t\t\tE[To[i]][Ec[To[i]]]=nP(From[i],Cost[i]);\n\t\t\t\tEc[To[i]]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\tPair tmp[N];\n\t\tfor(i=0;i<N;i++){\n\t\t\ttmp[i]=nP(i,WF[i][0]);//???->N-1??????????????¢\n\t\t}\n\t\tqsort(tmp,N,sizeof(Pair),cmp0);\n\t\t\n\t\tfor(i=0;i<N;i++)dp[i]=0;\n\t\tdp[0]=1;\n\t\tfor(i=0;i<N;i++){\n\t\t\tnow=tmp[i].Pos;\n\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\tdp[E[now][j].Pos]+=dp[now];\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(;P>0;P--){\n\t\t\tscanf(\"%d\",&c);\n\t\t\tfor(i=0;i<N;i++)dp2[i]=0;//dp2[i]:c??????i???????????????????????°\n\t\t\tdp2[c]=1;\n\t\t\tfor(i=0;i<N;i++){\n\t\t\t\tnow=tmp[i].Pos;\n\t\t\t\tfor(j=0;j<Ec[now];j++){\n\t\t\t\t\tdp2[E[now][j].Pos]+=dp2[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble prob=(double)dp[c];\n\t\t\tprob/=(double)dp[N-1];\n\t\t\tprob*=(double)dp2[N-1];\n\t\t\tprintf(\"%.12f\\n\",prob);\n\t\t}\n\t\tputs(\"\");\n\t}\n\treturn 0;\n}\n\n\nint cmp(const void *x,const void *y){//???????????????\n\tPair X=*(Pair *)x;\n\tPair Y=*(Pair *)y;\n\t\n\treturn X.Cost>Y.Cost?-1:X.Cost<Y.Cost?1:0;\n}\nint cmp0(const void *x,const void *y){//????????????\n\tPair X=*(Pair *)x;\n\tPair Y=*(Pair *)y;\n\t\n\treturn X.Cost>Y.Cost?1:X.Cost<Y.Cost?-1:0;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tsc.nextInt(); sc.nextInt(); sc.nextInt();\n\t\t\t}\n\t\t\tfor(int i=0;i<p;i++){\n\t\t\t\tsc.nextInt();\n\t\t\t\tSystem.out.printf(\"%.8f\\n\", 0);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n//\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n//\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n//\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n//\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n//\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tsc.nextInt(); sc.nextInt(); sc.nextInt();\n//\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n//\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\twhile(p--!=0){\n\t\t\t\tsc.nextInt();\n\t\t\t}\n//\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n//\t\t\td = new int[n];\n//\t\t\tfor(int i=0;i<n;i++)d[i]=wf[0][i];\n//\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n//\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n//\t\t\t\t\treturn d[o1]-d[o2];\n//\t\t\t\t}\n//\t\t\t});\n//\t\t\tq.add(0);\n//\t\t\tdouble[] r = new double[n];\n//\t\t\tr[0] = 1;\n//\t\t\tboolean[] u = new boolean[n];\n//\t\t\tu[0] = true;\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tif(v==n-1)break;\n//\t\t\t\tint c = 0;\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n//\t\t\t\t}\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n//\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n//\t\t\t\t\t\tif(!u[i]){\n//\t\t\t\t\t\t\tu[i] = true; q.add(i);\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n//\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tn = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint p = sc.nextInt();\n\t\t\tif(n == 0) break;\n\n\t\t\tint[][] t = new int[n][n];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tt[a][b] = t[b][a] = c;\n\t\t\t}\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\tint[] closed = new int[n];\n\t\t\tArrays.fill(closed,Integer.MAX_VALUE);\n\t\t\topen.add(new State(0,0,0));\n\n\t\t\tdag = new boolean[n][n];\n\t\t\tint[] in = new int[n];\n\t\t\tint[] out = new int[n];\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState st = open.poll();\n\t\t\t\tif(st.id != st.before && closed[st.id] >= st.cost){\n\t\t\t\t\tdag[st.before][st.id] = true;\n\t\t\t\t\tout[st.before]++;\n\t\t\t\t\tin[st.id]++;\n\t\t\t\t}\n\t\t\t\tif(closed[st.id] != Integer.MAX_VALUE) continue;\n\t\t\t\tclosed[st.id] = st.cost;\n\n\t\t\t\tif(st.id == n-1) continue;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(t[st.id][i] > 0){\n\t\t\t\t\t\topen.add(new State(i,st.id,st.cost+t[st.id][i]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdp = new double[n];\n\t\t\tArrays.fill(dp,-1);\n\n\t\t\tdouble route = countRoute(0);\n\t\t\tfor(int i=0;i<p;i++){\n\t\t\t\tint id = sc.nextInt();\n\t\t\t\tSystem.out.printf(\"%.8f\\n\",in[id]*out[id]/route);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tstatic int n;\n\tstatic boolean[][] dag;\n\tstatic double[] dp;\n\n\tstatic double countRoute(int id){\n\t\tif(id == n-1) return 1;\n\t\tif(dp[id] != -1) return dp[id];\n\t\tdouble res = 0.0;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tif(dag[id][i]) {\n\t\t\t\tres += countRoute(i);\n\t\t\t}\n\t\t}\n\t\treturn dp[id] = res;\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint id,before,cost;\n\n\tState(int id,int before,int cost){\n\t\tthis.id = id;\n\t\tthis.before = before;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn cost - st.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tint m = sc.nextInt();\n\t\t\tint p = sc.nextInt();\n\t\t\tif(n==0) break;\n\n\t\t\tint[][] t = new int[n][n];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint c = sc.nextInt();\n\t\t\t\tt[a][b] = t[b][a] = c;\n\t\t\t}\n\n\t\t\tPriorityQueue<State> open = new PriorityQueue<State>();\n\t\t\tint[] closed = new int[n];\n\t\t\tArrays.fill(closed,Integer.MAX_VALUE);\n\t\t\topen.add(new State(0,0,new ArrayList<Integer>()));\n\t\t\tArrayList<ArrayList<Integer>> passes = new ArrayList<ArrayList<Integer>>();\n\n\t\t\twhile(!open.isEmpty()){\n\t\t\t\tState st = open.poll();\n\t\t\t\tif(closed[st.id] < st.cost) continue;\n\t\t\t\tclosed[st.id] = st.cost;\n\n\t\t\t\tif(st.id == n-1){\n\t\t\t\t\tpasses.add(st.pass);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(t[st.id][i] > 0){\n\t\t\t\t\t\tArrayList<Integer> tmp = new ArrayList<Integer>(st.pass);\n\t\t\t\t\t\ttmp.add(i);\n\t\t\t\t\t\topen.add(new State(i,st.cost+t[st.id][i],tmp));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tdouble per = 1.0 / passes.size();\n\t\t\tdouble[] ans = new double[n];\n\t\t\tans[0] = 1.0;\n\t\t\tfor(ArrayList<Integer> al : passes){\n\t\t\t\tfor(int id : al){\n\t\t\t\t\tans[id] += per;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor(int i=0;i<p;i++){\n\t\t\t\tSystem.out.printf(\"%.8f\\n\",ans[sc.nextInt()]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n}\n\nclass State implements Comparable<State>{\n\tint id,cost;\n\tArrayList<Integer> pass;\n\n\tState(int id,int cost,ArrayList<Integer> pass){\n\t\tthis.id = id;\n\t\tthis.cost = cost;\n\t\tthis.pass = pass;\n\t}\n\n\tpublic int compareTo(State st){\n\t\treturn cost - st.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<29;\n\tint[][] wf;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\twf = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(e[i][j]==INF)continue;\n\t\t\t\t\tif(wf[0][i]+e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int x:adj[i])System.out.print(x+\" \");\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn wf[0][o1]-wf[0][o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++)q.add(i);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v]){\n\t\t\t\t\tres[x]+=res[v]/adj[v].size();\n\t\t\t\t}\n\t\t\t}\n//\t\t\tq.add(0);\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tfor(int x:adj[v]){\n//\t\t\t\t\tres[x] += res[v]/adj[v].size();\n//\t\t\t\t\tq.remove(x);\n//\t\t\t\t\tq.add(x);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\twhile(p--!=0){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(!(0<=x&&x<n))System.out.printf(\"%.8f\\n\", 0.0);\n\t\t\t\telse System.out.printf(\"%.8f\\n\", res[x]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\tint[] c = new int[n], K = new int[n];\n\t\t\tc[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tc[i]+=c[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tK[n-1] = c[n-1];\n\t\t\tq.clear();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tK[v]+=c[v]*K[i]/c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", K[sc.nextInt()]*1./K[n-1]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\td = new int[100];\n\t\tint[][] wf = new int[100][100], e = new int[100][100];\n\t\tdouble[] K = new double[100], R = new double[100];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tArrays.fill(K, 0);\n\t\t\tK[n-1] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[i][v]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][i]+e[i][v]+wf[v][n-1]){\n\t\t\t\t\t\tK[i]+=K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(R, 0);\n\t\t\tR[0] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tR[i]+=R[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0){\n\t\t\t\tint k = sc.nextInt();\n\t\t\t\tSystem.out.printf(\"%.8f\\n\", K[k]*R[k]/R[n-1]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n//\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif(n==0&&m==0&&p==0)break;\n//\t\t\tif((n|m|p)==0)break;\n//\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n//\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n//\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n//\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tsc.nextInt(); sc.nextInt(); sc.nextInt();\n//\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n//\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int i=0;i<p;i++){\n\t\t\t\tsc.nextInt();\n\t\t\t}\n//\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n//\t\t\td = new int[n];\n//\t\t\tfor(int i=0;i<n;i++)d[i]=wf[0][i];\n//\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n//\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n//\t\t\t\t\treturn d[o1]-d[o2];\n//\t\t\t\t}\n//\t\t\t});\n//\t\t\tq.add(0);\n//\t\t\tdouble[] r = new double[n];\n//\t\t\tr[0] = 1;\n//\t\t\tboolean[] u = new boolean[n];\n//\t\t\tu[0] = true;\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tif(v==n-1)break;\n//\t\t\t\tint c = 0;\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n//\t\t\t\t}\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n//\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n//\t\t\t\t\t\tif(!u[i]){\n//\t\t\t\t\t\t\tu[i] = true; q.add(i);\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n//\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.math.*;\nimport java.util.*;\n\nimport static java.math.BigDecimal.*;\nimport static java.util.Arrays.*;\npublic class Main\n{\n\tint [][]a;\n\tArrayList<Integer>[]g;\n\tint []x;\n\tint []y;\n\tint []z;\n\tint st;\n\tBigDecimal []dp;\n\tBigDecimal []fz;\n\tBigDecimal []fz1;\n\tBigDecimal getdp(int u,int st)\n\t{\n\t\tif (u==st)return dp[u]=ONE;\n\t\tif (dp[u].compareTo(ONE.negate())>0)return dp[u];\n\t\tBigDecimal sum=ZERO;\n\t\tfor (Integer i:g[u])\n\t\t{\n\t\t\tsum=sum.add(getdp(i,st));\n\t\t}\t\n\t\treturn dp[u]=sum;\n\t}\n    @SuppressWarnings(\"unchecked\")\n\tvoid run()\n    {\n    \tScanner cin=new Scanner(System.in);\n    \tint i,j,k;\n    \twhile (cin.hasNext())\n    \t{\n    \t\tint n=cin.nextInt(),m=cin.nextInt(),q=cin.nextInt();\n    \t\tif (n==0)break; \n    \t\ta=new int[n][n];\n    \t\tx=new int[m];\n    \t\ty=new int[m];\n    \t\tz=new int[m];\n    \t\tfor (i=0;i<n;i++)\n    \t\t{\n    \t\t\tfill(a[i],-1);\n    \t\t}\n    \t\tfor (i=0;i<n;i++)a[i][i]=0;\n    \t\tfor (i=0;i<m;i++)\n    \t\t{\n    \t\t\tx[i]=cin.nextInt();\n    \t\t\ty[i]=cin.nextInt();\n    \t\t\tz[i]=cin.nextInt();\n    \t\t\ta[x[i]][y[i]]=z[i];\n    \t\t}\n    \t\tfor (k=0;k<n;k++)\n    \t\t{\n    \t\t\tfor (i=0;i<n;i++)\n    \t\t\t{\n    \t\t\t\tfor (j=0;j<n;j++)\n    \t\t\t\t{\n    \t\t\t\t\tif (a[i][k]==-1||a[k][j]==-1)continue;\n    \t\t\t\t\tif (a[i][j]==-1||a[i][j]>a[i][k]+a[k][j])\n    \t\t\t\t\t{\n    \t\t\t\t\t\ta[i][j]=a[i][k]+a[k][j];\n    \t\t\t\t\t}\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tBigDecimal tot=ZERO;\n    \t\tg=new ArrayList[n];\n    \t\tfor (i=0;i<n;i++)\n    \t\t{\n    \t\t\tg[i]=new ArrayList<Integer>();\n    \t\t}\n    \t\tdp=new BigDecimal[n];\n    \t\tfz=new BigDecimal[n];\n    \t\tfz1=new BigDecimal[n];\n    \t\tfor (i=0;i<n;i++)\n    \t\t{\n    \t\t\tst=i;\n    \t\t\tfor (j=0;j<n;j++)\n        \t\t{\n    \t\t\t\tg[j].clear();\n        \t\t}\n    \t\t\tfor (j=0;j<m;j++)\n        \t\t{\n        \t\t\tif (a[st][x[j]]+z[j]==a[st][y[j]])\n        \t\t\t{\n        \t\t\t\tg[y[j]].add(x[j]);\n        \t\t\t}\n        \t\t}\n    \t\t\tfill(dp,ONE.negate());\n    \t\t\tfor (j=0;j<n;j++)\n    \t\t\t{\n    \t\t\t\tgetdp(j,st);\n    \t\t\t}\n    \t\t\tfz1[st]=dp[n-1];\n    \t\t\tif (i==0)\n    \t\t\t{\n    \t\t\t\ttot=dp[n-1];\n    \t\t\t\tfor (j=0;j<n;j++)\n    \t\t\t\t{\n    \t\t\t\t\tfz[j]=dp[j];\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tfor (i=0;i<q;i++)\n    \t\t{\n    \t\t\tint x=cin.nextInt();\n    \t\t\tSystem.out.println(fz[x].multiply(fz1[x]).divide(tot,16,ROUND_HALF_UP));\n    \t\t}\n    \t}\n    }\n    public static void main(String args[])\n    {\n    \tnew Main().run();\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<29;\n\tint[][] wf;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\twf = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(wf[0][i]+e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int x:adj[i])System.out.print(x+\" \");\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn wf[0][o1]-wf[0][o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++)q.add(i);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v])res[x]+=res[v]/adj[v].size();\n\t\t\t}\n//\t\t\tq.add(0);\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tfor(int x:adj[v]){\n//\t\t\t\t\tres[x] += res[v]/adj[v].size();\n//\t\t\t\t\tq.remove(x);\n//\t\t\t\t\tq.add(x);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n//\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n//\t\t\td = new int[n];\n//\t\t\tfor(int i=0;i<n;i++)d[i]=wf[0][i];\n//\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n//\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n//\t\t\t\t\treturn d[o1]-d[o2];\n//\t\t\t\t}\n//\t\t\t});\n//\t\t\tq.add(0);\n\t\t\tdouble[] r = new double[n];\n\t\t\tr[0] = 1;\n//\t\t\tboolean[] u = new boolean[n];\n//\t\t\tu[0] = true;\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tif(v==n-1)break;\n//\t\t\t\tint c = 0;\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n//\t\t\t\t}\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n//\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n//\t\t\t\t\t\tif(!u[i]){\n//\t\t\t\t\t\t\tu[i] = true; q.add(i);\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint pos;\n\t\tint cost;\n\t\tWalk prev;\n\t\t\n\t\tpublic Walk(int pos, int cost, Walk prev) {\n\t\t\tsuper();\n\t\t\tthis.pos = pos;\n\t\t\tthis.cost = cost;\n\t\t\tthis.prev = prev;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && p == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] adj = new int[n][n];\n\t\t\tint[] min_cost = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tadj[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tmin_cost[i] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int from = sc.nextInt();\n\t\t\t\tfinal int to = sc.nextInt();\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\t\n\t\t\t\tadj[from][to] = adj[to][from] = cost;\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\t\tqueue.add(new Walk(0,0,null));\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tLinkedList<Walk> shortest_paths = new LinkedList<Walk>();\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tif(min_cost[walk.pos] == -1){\n\t\t\t\t\tmin_cost[walk.pos] = walk.cost;\n\t\t\t\t}else if(min_cost[walk.pos] < walk.cost){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.pos == n-1){\n\t\t\t\t\tshortest_paths.add(walk);\n\t\t\t\t\tcount++;\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(adj[walk.pos][i] > 0 && (min_cost[i] == -1 || min_cost[i] >= walk.cost + adj[walk.pos][i])){\n\t\t\t\t\t\tqueue.add(new Walk(i, walk.cost + adj[walk.pos][i], walk));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble inc = 1.0 / count;\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor(Walk w : shortest_paths){\n\t\t\t\twhile(w != null){\n\t\t\t\t\tarray[w.pos] += inc;\n\t\t\t\t\tw = w.prev;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < p; i++){\n\t\t\t\tSystem.out.println(array[sc.nextInt()]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<28;\n\tint[][] wf;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;sc.hasNext();){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\twf = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(e[i][j]==INF)continue;\n\t\t\t\t\tif(wf[0][i]+e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn wf[0][o1]-wf[0][o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++)q.add(i);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v]){\n\t\t\t\t\tif(adj[v].size()==0)continue;\n\t\t\t\t\tres[x]+=res[v]/adj[v].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tdouble[] K = new double[n];\n\t\t\tK[n-1] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[i][v]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][i]+e[i][v]+wf[v][n-1]){\n\t\t\t\t\t\tK[i]+=K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tres[i]+=res[v]*K[i]/K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\td = new int[100];\n\t\tint[][] wf = new int[100][100], e = new int[100][100];\n\t\tdouble[] K = new double[100], res = new double[100];\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tArrays.fill(K, 0);\n\t\t\tK[n-1] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[i][v]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][i]+e[i][v]+wf[v][n-1]){\n\t\t\t\t\t\tK[i]+=K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tArrays.fill(res, 0);\n\t\t\tres[0] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tres[i]+=res[v]*K[i]/K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint pos;\n\t\tint cost;\n\t\tWalk prev;\n\t\t\n\t\tpublic Walk(int pos, int cost, Walk prev) {\n\t\t\tsuper();\n\t\t\tthis.pos = pos;\n\t\t\tthis.cost = cost;\n\t\t\tthis.prev = prev;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && p == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.gc();\n\t\t\t\n\t\t\tint[][] adj = new int[n][n];\n\t\t\tint[] min_cost = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tadj[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tmin_cost[i] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int from = sc.nextInt();\n\t\t\t\tfinal int to = sc.nextInt();\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\t\n\t\t\t\tadj[from][to] = adj[to][from] = cost;\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\t\tqueue.add(new Walk(0,0,null));\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tLinkedList<Walk> shortest_paths = new LinkedList<Walk>();\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tif(min_cost[walk.pos] == -1){\n\t\t\t\t\tmin_cost[walk.pos] = walk.cost;\n\t\t\t\t}else if(min_cost[walk.pos] > walk.cost){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.pos == n-1){\n\t\t\t\t\tshortest_paths.add(walk);\n\t\t\t\t\tcount++;\t\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(adj[walk.pos][i] > 0 && (min_cost[i] == -1 || min_cost[i] >= walk.cost + adj[walk.pos][i])){\n\t\t\t\t\t\tqueue.add(new Walk(i, walk.cost + adj[walk.pos][i], walk));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble inc = 1.0 / count;\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor(Walk w : shortest_paths){\n\t\t\t\twhile(w != null){\n\t\t\t\t\tarray[w.pos] += inc;\n\t\t\t\t\tw = w.prev;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < p; i++){\n\t\t\t\tSystem.out.println(array[sc.nextInt()]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<29;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tint[] C = new int[p];\n\t\t\tfor(int i=0;i<p;i++)C[i]=sc.nextInt();\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tfor(int i=0;i<n;i++)d[i]=wf[0][i];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(0);\n\t\t\tdouble[] r = new double[n];\n\t\t\tr[0] = 1;\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tu[0] = true;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n\t\t\t\t\t\tif(!u[i]){\n\t\t\t\t\t\t\tu[i] = true; q.add(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i=0;i<p;i++)System.out.printf(\"%.8f\\n\", r[C[i]]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<29;\n\tint[][] wf;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\twf = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(e[i][j]==INF)continue;\n\t\t\t\t\tif(wf[0][i]+e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int x:adj[i])System.out.print(x+\" \");\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn wf[0][o1]-wf[0][o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++)q.add(i);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v])res[x]+=res[v]/adj[v].size();\n\t\t\t}\n//\t\t\tq.add(0);\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tfor(int x:adj[v]){\n//\t\t\t\t\tres[x] += res[v]/adj[v].size();\n//\t\t\t\t\tq.remove(x);\n//\t\t\t\t\tq.add(x);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\twhile(p--!=0){\n\t\t\t\tint x = sc.nextInt();\n\t\t\t\tif(!(0<=x&&x<n))for(;;);\n\t\t\t\tSystem.out.printf(\"%.8f\\n\", res[x]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\tdouble[] r = new double[n];\n\t\t\tr[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tdouble[] K = new double[n];\n\t\t\tK[n-1] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[i][v]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][i]+e[i][v]+wf[v][n-1]){\n\t\t\t\t\t\tK[i]+=K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tres[i]+=res[v]*K[i]/K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<29;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tfor(int i=0;i<n;i++)d[i]=wf[0][i];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(0);\n\t\t\tdouble[] r = new double[n];\n\t\t\tr[0] = 1;\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tu[0] = true;\n\t\t\t/*\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n\t\t\t\t\t\tif(!u[i]){\n\t\t\t\t\t\t\tu[i] = true; q.add(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\tlong[] c = new long[n], K = new long[n];\n\t\t\tc[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tc[i]+=c[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tK[n-1] = c[n-1];\n\t\t\tq.clear();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF || c[i]==0)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tK[v]+=c[v]*K[i]/c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", K[sc.nextInt()]*1./K[n-1]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<29;\n\tint[][] wf;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run() throws Exception{\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\twf = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(e[i][j]==INF)continue;\n\t\t\t\t\tif(wf[0][i]+e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn wf[0][o1]-wf[0][o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++)q.add(i);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v]){\n\t\t\t\t\tres[x]+=res[v]/adj[v].size();\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tnew Main().run();\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"ERROR\");\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tfor(int i=0;i<n;i++)d[i]=wf[0][i];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(0);\n\t\t\tdouble[] r = new double[n];\n\t\t\tr[0] = 1;\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tu[0] = true;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n\t\t\t\t\t\tif(!u[i]){\n\t\t\t\t\t\t\tu[i] = true; q.add(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n  // constant\n\n  static final int MAX_INT = 1 << 30;\n  static final int MAX_N = 100;\n\n  // inner classes\n\n  static class QComp implements Comparator<Integer> {\n    public int compare(Integer i0, Integer i1) {\n      return dists[i0.intValue()] - dists[i1.intValue()];\n    }\n  }\n\n  // global variables\n\n  static int[] dists;\n\n  // main\n\n  public static final void main(String[] args) throws Exception {\n    Scanner sc = new Scanner(System.in);\n\n    for (;;) {\n      int n = sc.nextInt();\n      int m = sc.nextInt();\n      int pn = sc.nextInt();\n      if ((n | m | pn) == 0) break;\n\n      int[][] edges = new int[n][n];\n      for (int i = 0; i < n; i++)\n\tfor (int j = 0; j < n; j++) edges[i][j] = 0;\n\n      ArrayList<ArrayList<Integer>> nbrs = new ArrayList<ArrayList<Integer>>();\n      for (int i = 0; i < n; i++)\n\tnbrs.add(new ArrayList<Integer>());\n\n      for (int k = 0; k < m; k++) {\n\tint i = sc.nextInt();\n\tint j = sc.nextInt();\n\tint w = sc.nextInt();\n\n\tnbrs.get(i).add(j);\n\tnbrs.get(j).add(i);\n\tedges[i][j] = edges[j][i] = w;\n      }\n\n      int[] cis = new int[pn];\n      for (int i = 0; i < pn; i++)\n\tcis[i] = sc.nextInt();\n\n      dists = new int[n];\n      Arrays.fill(dists, MAX_INT);\n      dists[0] = 0;\n\n      ArrayList<ArrayList<Integer>> prevs = new ArrayList<ArrayList<Integer>>();\n      for (int i = 0; i < n; i++)\n\tprevs.add(new ArrayList<Integer>());\n\n      PriorityQueue<Integer> pq = new PriorityQueue<Integer>(n, new QComp());\n      pq.add(0);\n\n      while (! pq.isEmpty()) {\n\tInteger ui = pq.poll();\n\tint u = ui.intValue();\n\tif (u == n - 1) continue;\n\n\tint du = dists[u];\n\n\tfor (Integer vi: nbrs.get(u)) {\n\t  int v = vi.intValue();\n\t  int dv = dists[v];\n\t  int ndv = du + edges[u][v];\n\t  ArrayList<Integer> prvv = prevs.get(v);\n\t  \n\t  if (dv > ndv) {\n\t    dists[v] = ndv;\n\t    prvv.clear();\n\t    prvv.add(u);\n\n\t    if (dv < MAX_INT) pq.remove(new Integer(v));\n\t    pq.add(v);\n\t  }\n\t  else if (dv == ndv)\n\t    prvv.add(u);\n\t}\n      }\n      if (1 == 0) {\n\tfor (int i = 0; i < n; i++)\n\t  System.out.println(dists[i]);\n\tbreak;\n      }\n      if (1 == 0) {\n\tfor (int i = 0; i < n; i++) {\n\t  System.out.print(\"[\");\n\t  for (int j: prevs.get(i))\n\t    System.out.print(\" \" + j);\n\t  System.out.print(\"]\");\n\t}\n\tSystem.out.println();\n\tbreak;\n      }\n\n      ArrayList<ArrayList<Integer>> nexts = new ArrayList<ArrayList<Integer>>();\n      for (int i = 0; i < n; i++)\n\tnexts.add(new ArrayList<Integer>());\n\n      for (int i = 0; i < n; i++)\n\tfor (int j: prevs.get(i))\n\t  nexts.get(j).add(i);\n\n      if (1 == 0) {\n\tfor (int i = 0; i < n; i++) {\n\t  System.out.print(\"[\");\n\t  for (int j: nexts.get(i))\n\t    System.out.print(\" \" + j);\n\t  System.out.print(\"]\");\n\t}\n\tSystem.out.println();\n\tbreak;\n      }\n\n      int[] counts = new int[n];\n      Arrays.fill(counts, 0);\n      counts[0] = 1;\n\n      int[] ncounts = new int[n];\n      Arrays.fill(ncounts, 0);\n\n      ArrayList<Integer> q = new ArrayList<Integer>();\n      q.add(0);\n\n      while (! q.isEmpty()) {\n\tint u = q.remove(0);\n\n\tif (prevs.get(u).size() > ncounts[u]) {\n\t  q.add(u);\n\t  continue;\n\t}\n\n\tint cu = counts[u];\n\n\tfor (int v: nexts.get(u)) {\n\t  int cv = counts[v];\n\t  counts[v] += cu;\n\t  ncounts[v]++;\n\n\t  if (cv == 0)\n\t    q.add(v);\n\t}\n      }\n      if (1 == 0) {\n\tfor (int i = 0; i < n; i++)\n\t  System.out.println(counts[i]);\n\tbreak;\n      }\n\n      double[] pbs = new double[n];\n      Arrays.fill(pbs, 0.0);\n      pbs[n - 1] = 1.0;\n\n      int[] npbs = new int[n];\n      Arrays.fill(npbs, 0);\n\n      q.add(n - 1);\n\n      while (! q.isEmpty()) {\n\tint u = q.remove(0);\n\n\tif (nexts.get(u).size() > npbs[u]) {\n\t  q.add(u);\n\t  continue;\n\t}\n\n\tdouble pu = pbs[u];\n\tint cu = counts[u];\n\n\tfor (int v: prevs.get(u)) {\n\t  double pv = pbs[v];\n\t  pbs[v] += pu * counts[v] / cu;\n\t  npbs[v]++;\n\n\t  if (pv == 0.0)\n\t    q.add(v);\n\t}\n      }\n\n      for (int i = 0; i < pn; i++)\n\tSystem.out.printf(\"%.8f\\n\", pbs[cis[i]]);\n      System.out.println();\n    }\n  }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\tint[] c = new int[n], K = new int[n];\n\t\t\tc[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tc[i]+=c[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tK[n-1] = c[n-1];\n\t\t\tq.clear();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF || c[i]==0)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tK[v]+=c[v]*K[i]/c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", K[sc.nextInt()]*1./K[n-1]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<29;\n\tint[] d;\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[n][n], wf = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(i==j)continue;\n\t\t\t\t\tif(e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n\t\t\t}\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, INF);\n\t\t\td[0] = 0;\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(0);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v]){\n\t\t\t\t\tif(d[v]+e[v][x]<d[x]){\n\t\t\t\t\t\tres[x] += res[v]/adj[v].size();\n\t\t\t\t\t\tq.remove(x); d[x] = d[v]+e[v][x]; q.add(x);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.util.Arrays;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.ListIterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static class Walk implements Comparable<Walk>{\n\t\tint pos;\n\t\tint cost;\n\t\tWalk prev;\n\t\t\n\t\tpublic Walk(int pos, int cost, Walk prev) {\n\t\t\tsuper();\n\t\t\tthis.pos = pos;\n\t\t\tthis.cost = cost;\n\t\t\tthis.prev = prev;\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Walk arg0) {\n\t\t\treturn this.cost - arg0.cost;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tfinal Scanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tfinal int n = sc.nextInt();\n\t\t\tfinal int m = sc.nextInt();\n\t\t\tfinal int p = sc.nextInt();\n\t\t\t\n\t\t\tif(n == 0 && m == 0 && p == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint[][] adj = new int[n][n];\n\t\t\tint[] min_cost = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\t\tadj[i][j] = -1;\n\t\t\t\t}\n\t\t\t\tmin_cost[i] = -1;\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tfinal int from = sc.nextInt();\n\t\t\t\tfinal int to = sc.nextInt();\n\t\t\t\tfinal int cost = sc.nextInt();\n\t\t\t\t\n\t\t\t\tadj[from][to] = adj[to][from] = cost;\n\t\t\t}\n\t\t\t\n\t\t\tPriorityQueue<Walk> queue = new PriorityQueue<Walk>();\n\t\t\tqueue.add(new Walk(0,0,null));\n\t\t\t\n\t\t\tint count = 0;\n\t\t\tLinkedList<Walk> shortest_paths = new LinkedList<Walk>();\n\t\t\t\n\t\t\twhile(!queue.isEmpty()){\n\t\t\t\tWalk walk = queue.poll();\n\t\t\t\t\n\t\t\t\tif(min_cost[walk.pos] == -1){\n\t\t\t\t\tmin_cost[walk.pos] = walk.cost;\n\t\t\t\t}else if(min_cost[walk.pos] > walk.cost){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(walk.pos == n-1){\n\t\t\t\t\tshortest_paths.add(walk);\n\t\t\t\t\tcount++;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(adj[walk.pos][i] > 0 && (min_cost[i] == -1 || min_cost[i] >= walk.cost + adj[walk.pos][i])){\n\t\t\t\t\t\tqueue.add(new Walk(i, walk.cost + adj[walk.pos][i], walk));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tdouble inc = 1.0 / count;\n\t\t\tdouble[] array = new double[n];\n\t\t\tfor(Walk w : shortest_paths){\n\t\t\t\twhile(w != null){\n\t\t\t\t\tarray[w.pos] += inc;\n\t\t\t\t\tw = w.prev;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < p; i++){\n\t\t\t\tSystem.out.println(array[sc.nextInt()]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\td[i]=wf[0][i];\n//\t\t\t\tq.add(i);\n//\t\t\t}\n//\t\t\tlong[] C = new long[n];\n\t\t\tdouble[] K = new double[n];\n//\t\t\tC[0] = 1;\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n//\t\t\t\t\t\tC[i]+=C[v];\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tq.clear();\n\t\t\tK[n-1] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[i][v]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][i]+e[i][v]+wf[v][n-1]){\n\t\t\t\t\t\tK[i]+=K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdebug(K);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\tq.clear();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tres[i]+=res[v]*K[i]/K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\tint[] c = new int[n];\n\t\t\tc[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tc[i]+=c[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", c[sc.nextInt()]*1./c[n-1]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<29, N = 120;\n\tint[][] wf;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[N][N];\n\t\t\twf = new int[N][N];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[N];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(e[i][j]==INF)continue;\n\t\t\t\t\tif(wf[0][i]+e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int x:adj[i])System.out.print(x+\" \");\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(N, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn wf[0][o1]-wf[0][o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++)q.add(i);\n\t\t\tdouble[] res = new double[N];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v]){\n\t\t\t\t\tres[x]+=res[v]/adj[v].size();\n\t\t\t\t}\n\t\t\t}\n//\t\t\tq.add(0);\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tfor(int x:adj[v]){\n//\t\t\t\t\tres[x] += res[v]/adj[v].size();\n//\t\t\t\t\tq.remove(x);\n//\t\t\t\t\tq.add(x);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n//\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\td[i]=wf[0][i];\n//\t\t\t\tq.add(i);\n//\t\t\t}\n//\t\t\tlong[] C = new long[n];\n\t\t\tlong[] K = new long[n];\n//\t\t\tC[0] = 1;\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n//\t\t\t\t\t\tC[i]+=C[v];\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n//\t\t\tq.clear();\n\t\t\tK[n-1] = 1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[i][v]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][i]+e[i][v]+wf[v][n-1]){\n\t\t\t\t\t\tK[i]+=K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//\t\t\tdebug(K);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\tq.clear();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tres[i]+=res[v]*K[i]/K[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tvoid debug(Object...o){\n\t\tSystem.out.println(Arrays.deepToString(o));\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<29;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tArrays.fill(d, INF);\n\t\t\td[0] = 0;\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(0);\n\t\t\tdouble[] r = new double[n];\n\t\t\tr[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n\t\t\t\t\t\tq.remove(i); d[i] = wf[0][i]; q.add(i);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n//\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n//\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n//\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n//\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n//\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n//\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tsc.nextInt(); sc.nextInt(); sc.nextInt();\n//\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n//\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n//\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n//\t\t\td = new int[n];\n//\t\t\tfor(int i=0;i<n;i++)d[i]=wf[0][i];\n//\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n//\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n//\t\t\t\t\treturn d[o1]-d[o2];\n//\t\t\t\t}\n//\t\t\t});\n//\t\t\tq.add(0);\n\t\t\tdouble[] r = new double[n];\n\t\t\tr[0] = 1;\n//\t\t\tboolean[] u = new boolean[n];\n//\t\t\tu[0] = true;\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tif(v==n-1)break;\n//\t\t\t\tint c = 0;\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n//\t\t\t\t}\n//\t\t\t\tfor(int i=0;i<n;i++){\n//\t\t\t\t\tif(i==v)continue;\n//\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n//\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n//\t\t\t\t\t\tif(!u[i]){\n//\t\t\t\t\t\t\tu[i] = true; q.add(i);\n//\t\t\t\t\t\t}\n//\t\t\t\t\t}\n//\t\t\t\t}\n//\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<29;\n\tint[][] wf;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\twf = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(e[i][j]==INF)continue;\n\t\t\t\t\tif(wf[0][i]+e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int x:adj[i])System.out.print(x+\" \");\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn wf[0][o1]-wf[0][o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++)q.add(i);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v])res[x]+=res[v]/adj[v].size();\n\t\t\t}\n//\t\t\tq.add(0);\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tfor(int x:adj[v]){\n//\t\t\t\t\tres[x] += res[v]/adj[v].size();\n//\t\t\t\t\tq.remove(x);\n//\t\t\t\t\tq.add(x);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint INF = 1<<29;\n\tint[][] wf;\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] e = new int[n][n];\n\t\t\twf = new int[n][n];\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\tList<Integer>[] adj = new List[n];\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tadj[i] = new ArrayList<Integer>();\n\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\tif(e[i][j]==INF)continue;\n\t\t\t\t\tif(wf[0][i]+e[i][j]+wf[j][n-1]==wf[0][n-1])adj[i].add(j);\n\t\t\t\t}\n//\t\t\t\tSystem.out.println(\"V:\"+i);\n//\t\t\t\tfor(int x:adj[i])System.out.print(x+\" \");\n//\t\t\t\tSystem.out.println();\n\t\t\t}\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn wf[0][o1]-wf[0][o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++)q.add(i);\n\t\t\tdouble[] res = new double[n];\n\t\t\tres[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int x:adj[v]){\n\t\t\t\t\tif(adj[v].isEmpty())for(;;);\n\t\t\t\t\tres[x]+=res[v]/adj[v].size();\n\t\t\t\t}\n\t\t\t}\n//\t\t\tq.add(0);\n//\t\t\twhile(!q.isEmpty()){\n//\t\t\t\tint v = q.poll();\n//\t\t\t\tfor(int x:adj[v]){\n//\t\t\t\t\tres[x] += res[v]/adj[v].size();\n//\t\t\t\t\tq.remove(x);\n//\t\t\t\t\tq.add(x);\n//\t\t\t\t}\n//\t\t\t}\n\t\t\twhile(p--!=0){\n\t\t\t\tSystem.out.printf(\"%.8f\\n\", res[sc.nextInt()]);\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<27;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i]=wf[0][i];\n\t\t\t\tq.add(i);\n\t\t\t}\n\t\t\tint[] c = new int[n], K = new int[n];\n\t\t\tc[0] = 1;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tc[i]+=c[v];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tK[n-1] = c[n-1];\n\t\t\tq.clear();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\td[i] = -wf[0][i]; q.add(i);\n\t\t\t}\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v || e[v][i]==INF || c[i]==0)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tK[v]+=1L*c[v]*K[i]/c[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", K[sc.nextInt()]*1./K[n-1]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Winter Bells\npublic class Main{\n\n\tint[] d;\n\tvoid run(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint INF = 1<<29;\n\t\tfor(;;){\n\t\t\tint n = sc.nextInt(), m = sc.nextInt(), p = sc.nextInt();\n\t\t\tif((n|m|p)==0)break;\n\t\t\tint[][] wf = new int[n][n], e = new int[n][n];\n\t\t\tfor(int[]a:wf)Arrays.fill(a, INF);\n\t\t\tfor(int[]a:e)Arrays.fill(a, INF);\n\t\t\tfor(int i=0;i<n;i++)wf[i][i]=0;\n\t\t\twhile(m--!=0){\n\t\t\t\tint s = sc.nextInt(), t = sc.nextInt(), c = sc.nextInt();\n\t\t\t\te[s][t] = e[t][s] = wf[s][t] = wf[t][s] = c;\n\t\t\t}\n\t\t\tfor(int k=0;k<n;k++)for(int i=0;i<n;i++)for(int j=0;j<n;j++)wf[i][j]=Math.min(wf[i][j], wf[i][k]+wf[k][j]);\n\t\t\td = new int[n];\n\t\t\tfor(int i=0;i<n;i++)d[i]=wf[0][i];\n\t\t\tPriorityQueue<Integer> q = new PriorityQueue<Integer>(n, new Comparator<Integer>() {\n\t\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\t\treturn d[o1]-d[o2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tq.add(0);\n\t\t\tdouble[] r = new double[n];\n\t\t\tr[0] = 1;\n\t\t\tboolean[] u = new boolean[n];\n\t\t\tu[0] = true;\n\t\t\twhile(!q.isEmpty()){\n\t\t\t\tint v = q.poll();\n\t\t\t\tif(v==n-1)break;\n\t\t\t\tint c = 0;\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1])c++;\n\t\t\t\t}\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tif(i==v)continue;\n\t\t\t\t\tif(wf[0][n-1]==wf[0][v]+e[v][i]+wf[i][n-1]){\n\t\t\t\t\t\tr[i]+=r[v]*1.0/c;\n\t\t\t\t\t\tif(!u[i]){\n\t\t\t\t\t\t\tu[i] = true; q.add(i);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twhile(p--!=0)System.out.printf(\"%.8f\\n\", r[sc.nextInt()]);\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0 && d[2]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tint INF=(int)1e9;\n\t\t\n\t\tint[][] WF=new int[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tWF[i]=new int[N];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tWF[i][j]=i==j?0:INF;\n\t\t\t}\n\t\t\tfor(int j=0;j<E[i].Count;j++){\n\t\t\t\tWF[i][E[i][j].To]=E[i][j].Cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Math.Min(WF[i][k]+WF[k][j],WF[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost0=new int[N];\n\t\tlong[] Count0=new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost0[i]=INF;\n\t\t\tCount0[i]=0;\n\t\t}\n\t\tCost0[0]=0;\n\t\tCount0[0]=1;\n\t\tbool[] used=new bool[N];\n\t\tbool finished=false;\n\t\t\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost0[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost0[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost0[trgt];\n\t\t\tlong cnt=Count0[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost0[E[n][j].To]){\n\t\t\t\t\tCost0[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount0[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost0[E[n][j].To]){\n\t\t\t\t\tCount0[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost=new int[N];\n\t\tlong[] Count=new long[N];\n\t\t\n\t\tfinished=false;\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost[i]=INF;\n\t\t\tCount[i]=0;\n\t\t\tused[i]=false;\n\t\t}\n\t\tCost[N-1]=0;\n\t\tCount[N-1]=1;\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost[trgt];\n\t\t\tlong cnt=Count[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost[E[n][j].To]){\n\t\t\t\t\tCost[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost[E[n][j].To]){\n\t\t\t\t\tCount[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\n\n\n\t\tfor(int q=0;q<Children.Count;q++){\n\t\t\tif(WF[0][Children[q]]+WF[Children[q]][N-1]>WF[0][N-1]){\n\t\t\t\tConsole.WriteLine(\"0.000000\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\n\t\t\tdouble p=(double)Count0[Children[q]]*(double)Count[Children[q]]/(double)Count0[N-1];\n\t\t\tConsole.WriteLine(\"{0:F}\",p);\n\t\t}\n\t\t\n\t}\n\t\n\tint N;\n\tint M;\n\tint P;\n\tList<Edge>[] E;\n\tList<int> Children;\n\tpublic Sol(int[] d_){\n\t\tN=d_[0];M=d_[1];P=d_[2];\n\t\tE=new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tE[i]=new List<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tvar d=ria();\n\t\t\tE[d[0]].Add(new Edge(d[1],d[2]));\n\t\t\tE[d[1]].Add(new Edge(d[0],d[2]));\n\t\t}\n\t\t\n\t\tChildren=new List<int>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tChildren.Add(ri());\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tpublic int To;\n\t\tpublic int Cost;\n\t\tpublic Edge(int t_,int c_){\n\t\t\tTo=t_;Cost=c_;\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0 && d[2]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tint INF=(int)1e9;\n\t\t\n\t\tint[][] WF=new int[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tWF[i]=new int[N];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tWF[i][j]=i==j?0:INF;\n\t\t\t}\n\t\t\tfor(int j=0;j<E[i].Count;j++){\n\t\t\t\tWF[i][E[i][j].To]=E[i][j].Cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Math.Min(WF[i][k]+WF[k][j],WF[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost0=new int[N];\n\t\tdouble[] Count0=new double[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost0[i]=INF;\n\t\t\tCount0[i]=0;\n\t\t}\n\t\tCost0[0]=0;\n\t\tCount0[0]=1;\n\t\tbool[] used=new bool[N];\n\t\tbool finished=false;\n\t\t\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost0[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost0[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost0[trgt];\n\t\t\tdouble cnt=Count0[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost0[E[n][j].To]){\n\t\t\t\t\tCost0[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount0[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost0[E[n][j].To]){\n\t\t\t\t\tCount0[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(int q=0;q<Children.Count;q++){\n\n\n\t\t\t\n\t\t\tint[] Cost=new int[N];\n\t\t\tdouble[] Count=new double[N];\n\t\t\t\n\t\t\tfinished=false;\n\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tCost[i]=INF;\n\t\t\t\tCount[i]=0;\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t\tCost[Children[q]]=0;\n\t\t\tCount[Children[q]]=1;\n\t\t\twhile(!finished){\n\t\t\t\tfinished=true;\n\t\t\t\tint trgt=-1;\n\t\t\t\tint mincost=INF+1;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tfinished=finished&used[j];\n\t\t\t\t\tif(!used[j] && Cost[j]<mincost){\n\t\t\t\t\t\ttrgt=j;\n\t\t\t\t\t\tmincost=Cost[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(finished)break;\n\t\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\t\n\t\t\t\tint n=trgt;\n\t\t\t\tint c=Cost[trgt];\n\t\t\t\tdouble cnt=Count[trgt];\n\t\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\t\tif(c+E[n][j].Cost<Cost[E[n][j].To]){\n\t\t\t\t\t\tCost[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\t\tCount[E[n][j].To]=cnt;\n\t\t\t\t\t}else if(c+E[n][j].Cost==Cost[E[n][j].To]){\n\t\t\t\t\t\tCount[E[n][j].To]+=cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\n\n\n\n\n\n\n\t\t\tif(WF[0][Children[q]]+WF[Children[q]][N-1]>WF[0][N-1]){\n\t\t\t\tConsole.WriteLine(\"0.0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\n\t\t\tdouble p=(double)Count0[Children[q]]*(double)Count[N-1]/(double)Count0[N-1];\n\t\t\tConsole.WriteLine(\"{0:F}\",p);\n\t\t}\n\t\t\n\t}\n\t\n\tint N;\n\tint M;\n\tint P;\n\tList<Edge>[] E;\n\tList<int> Children;\n\tpublic Sol(int[] d_){\n\t\tN=d_[0];M=d_[1];P=d_[2];\n\t\tE=new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tE[i]=new List<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tvar d=ria();\n\t\t\tE[d[0]].Add(new Edge(d[1],d[2]));\n\t\t\tE[d[1]].Add(new Edge(d[0],d[2]));\n\t\t}\n\t\t\n\t\tChildren=new List<int>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tChildren.Add(ri());\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tpublic int To;\n\t\tpublic int Cost;\n\t\tpublic Edge(int t_,int c_){\n\t\t\tTo=t_;Cost=c_;\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\tint[] From=new int[M],To=new int[M],Cost=new int[M];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t\tFrom[i]=d[0];To[i]=d[1];Cost[i]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i] && WF[From[i]][0]+Cost[i]==WF[To[i]][0] )E[From[i]].Add(new Pair(To[i],Cost[i]));\n\t\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i] && WF[To[i]][0]+Cost[i]==WF[From[i]][0] )E[To[i]].Add(new Pair(From[i],Cost[i]));\n\t\t\t}\n\t\t\t\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tlong[] dp=new long[N];\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tlong[] dp2=new long[N];\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0 && d[2]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tint INF=(int)1e9;\n\t\t\n\t\tint[][] WF=new int[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tWF[i]=new int[N];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tWF[i][j]=i==j?0:INF;\n\t\t\t}\n\t\t\tfor(int j=0;j<E[i].Count;j++){\n\t\t\t\tWF[i][E[i][j].To]=E[i][j].Cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Math.Min(WF[i][k]+WF[k][j],WF[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost0=new int[N];\n\t\tlong[] Count0=new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost0[i]=INF;\n\t\t\tCount0[i]=0;\n\t\t}\n\t\tCost0[0]=0;\n\t\tCount0[0]=1;\n\t\tbool[] used=new bool[N];\n\t\tbool finished=false;\n\t\t\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost0[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost0[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost0[trgt];\n\t\t\tlong cnt=Count0[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost0[E[n][j].To]){\n\t\t\t\t\tCost0[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount0[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost0[E[n][j].To]){\n\t\t\t\t\tCount0[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost=new int[N];\n\t\tlong[] Count=new long[N];\n\t\t\n\t\tfinished=false;\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost[i]=INF;\n\t\t\tCount[i]=0;\n\t\t\tused[i]=false;\n\t\t}\n\t\tCost[N-1]=0;\n\t\tCount[N-1]=1;\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost[trgt];\n\t\t\tlong cnt=Count[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost[E[n][j].To]){\n\t\t\t\t\tCost[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost[E[n][j].To]){\n\t\t\t\t\tCount[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\tfor(int q=0;q<Children.Count;q++){\n\t\t\tif(WF[0][q]+WF[q][N-1]>WF[0][N-1]){\n\t\t\t\tConsole.WriteLine(\"0.0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\n\t\t\tdouble p=(double)Count0[Children[q]]*(double)Count[Children[q]]/(double)Count0[N-1];\n\t\t\tConsole.WriteLine(\"{0:F}\",p);\n\t\t}\n\t\t\n\t}\n\t\n\tint N;\n\tint M;\n\tint P;\n\tList<Edge>[] E;\n\tList<int> Children;\n\tpublic Sol(int[] d_){\n\t\tN=d_[0];M=d_[1];P=d_[2];\n\t\tE=new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tE[i]=new List<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tvar d=ria();\n\t\t\tE[d[0]].Add(new Edge(d[1],d[2]));\n\t\t\tE[d[1]].Add(new Edge(d[0],d[2]));\n\t\t}\n\t\t\n\t\tChildren=new List<int>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tChildren.Add(ri());\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tpublic int To;\n\t\tpublic int Cost;\n\t\tpublic Edge(int t_,int c_){\n\t\t\tTo=t_;Cost=c_;\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\tint[] From=new int[M],To=new int[M],Cost=new int[M];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t\tFrom[i]=d[0];To[i]=d[1];Cost[i]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1????????????????????????edge????????????\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i])E[From[i]].Add(new Pair(To[i],Cost[i]));\n\t\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i])E[To[i]].Add(new Pair(From[i],Cost[i]));\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1???????????????????????????????????§??????????????????\n\t\t\t//???????????????\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);//???->N-1??????????????¢\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tlong[] dp=new long[N];//dp[i]:0??????i???????????????????????°\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t}\n\t\t\t}\n//for(int i=0;i<N;i++)Console.WriteLine(\"{0}-{1}\",tmp[i].Pos,tmp[i].Cost);\t\t\t\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tlong[] dp2=new long[N];//dp2[i]:c??????i???????????????????????°\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n//Console.WriteLine(\"now={0},0->now:{1} +now->next;{2} +next->N-1:{3},next={4},C:{5}\",now,WF[0][now],next.Cost,WF[next.Pos][N-1],next.Pos,WF[0][N-1]);\n\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"0->{0}:{1},->N-1:{2},tot={3}\",c,dp[c],dp2[N-1],dp[N-1]);\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\tint[] From=new int[M],To=new int[M],Cost=new int[M];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t\tFrom[i]=d[0];To[i]=d[1];Cost[i]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i])E[From[i]].Add(new Pair(To[i],Cost[i]));\n\t\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i])E[To[i]].Add(new Pair(From[i],Cost[i]));\n\t\t\t}\n\t\t\t\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tlong[] dp=new long[N];\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tlong[] dp2=new long[N];\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0 && d[2]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tint INF=(int)1e9;\n\t\t\n\t\tint[][] WF=new int[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tWF[i]=new int[N];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tWF[i][j]=i==j?0:INF;\n\t\t\t}\n\t\t\tfor(int j=0;j<E[i].Count;j++){\n\t\t\t\tWF[i][E[i][j].To]=E[i][j].Cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Math.Min(WF[i][k]+WF[k][j],WF[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost0=new int[N];\n\t\tlong[] Count0=new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost0[i]=INF;\n\t\t\tCount0[i]=0;\n\t\t}\n\t\tCost0[0]=0;\n\t\tCount0[0]=1;\n\t\t\n\t\tPriorityQueue<State> PQ=new PriorityQueue<State>();\n\t\tPQ.Push(new State(0,0,1));\n\t\twhile(!PQ.IsEmpty){\n\t\t\tState S=PQ.Top;PQ.Pop();\n\t\t\tint n=S.V;\n\t\t\tint c=S.C;\n\t\t\tlong cnt=S.Count;\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost0[E[n][j].To]){\n\t\t\t\t\tCost0[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount0[E[n][j].To]=cnt;\n\t\t\t\t\tPQ.Push(new State(E[n][j].To, Cost0[E[n][j].To], Count0[E[n][j].To] ) );\n\t\t\t\t}else if(c+E[n][j].Cost==Cost0[E[n][j].To]){\n\t\t\t\t\tCount0[E[n][j].To]+=cnt;\n\t\t\t\t\tPQ.Push(new State(E[n][j].To,Cost0[E[n][j].To],Count0[E[n][j].To]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost=new int[N];\n\t\tlong[] Count=new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost[i]=INF;\n\t\t\tCount[i]=0;\n\t\t}\n\t\tCost[N-1]=0;\n\t\tCount[N-1]=1;\n\t\tPQ.Push(new State(N-1,0,1));\n\t\twhile(!PQ.IsEmpty){\n\t\t\tState S=PQ.Top;PQ.Pop();\n\t\t\tint n=S.V;\n\t\t\tint c=S.C;\n\t\t\tlong cnt=S.Count;\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost[E[n][j].To]){\n\t\t\t\t\tCost[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount[E[n][j].To]=cnt;\n\t\t\t\t\tPQ.Push(new State(E[n][j].To,Cost[E[n][j].To],Count[E[n][j].To]));\n\t\t\t\t}else if(c+E[n][j].Cost==Cost[E[n][j].To]){\n\t\t\t\t\tCount[E[n][j].To]+=cnt;\n\t\t\t\t\tPQ.Push(new State(E[n][j].To,Cost[E[n][j].To],Count[E[n][j].To]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\tfor(int q=0;q<Children.Count;q++){\n\t\t\tif(WF[0][q]+WF[q][0]>WF[0][N-1]){\n\t\t\t\tConsole.WriteLine(\"0.0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\n\t\t\tdouble p=(double)Count0[Children[q]]*(double)Count[Children[q]]/(double)Count0[N-1];\n\t\t\tConsole.WriteLine(\"{0:F}\",p);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tint N;\n\tint M;\n\tint P;\n\tList<Edge>[] E;\n\tList<int> Children;\n\tpublic Sol(int[] d_){\n\t\tN=d_[0];M=d_[1];P=d_[2];\n\t\tE=new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tE[i]=new List<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tvar d=ria();\n\t\t\tE[d[0]].Add(new Edge(d[1],d[2]));\n\t\t\tE[d[1]].Add(new Edge(d[0],d[2]));\n\t\t}\n\t\t\n\t\tChildren=new List<int>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tChildren.Add(ri());\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tpublic int To;\n\t\tpublic int Cost;\n\t\tpublic Edge(int t_,int c_){\n\t\t\tTo=t_;Cost=c_;\n\t\t}\n\t}\n\tclass State:IComparable<State>{\n\t\tpublic int V;\n\t\tpublic int C;\n\t\tpublic long Count;\n\t\tpublic State(int v_,int c_,long cnt_){\n\t\t\tV=v_;C=c_;Count=cnt_;\n\t\t}\n\t\tpublic int CompareTo(State other){\n\t\t\t//逆順\n\t\t\treturn this.C>other.C?-1:this.C<other.C?1:0;\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}\n\n\n\n\n\nclass PriorityQueue<T> where T:IComparable<T>{\n\n\t//T:IComparable\n\t//IComparerかComparisonを指定してインスタンス化する事も可\n\t//引数なしインスタンス化⇒ComparedToで比較\n\t//大きいものほどTopへ\n\n\tenum typeCompare{\n\t\tisIComparerable=1,\n\t\tuseIComparer=2,\n\t\tuseDComparison=3\n\t}\n\n\tList<T> buffer;\n\ttypeCompare tComp;\n\tIComparer<T> Cmper;\n\tComparison<T> Cmp;\n\t\n\tpublic PriorityQueue(IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t\tCmp=null;\n\t}\n\tpublic PriorityQueue(){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t\tCmper=null;\n\t}\n\tpublic PriorityQueue(int capacity,IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t}\n\tpublic PriorityQueue(int capacity){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(int capacity,Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t}\n\t\n\n\tvoid PushHeap(List<T> arr,T elem){\n\t\tint n=arr.Count;\n\t\tbuffer.Add(elem);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(arr[n].CompareTo(arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmper.Compare(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmp(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid PopHeap(List<T> arr){\n\t\tint n=arr.Count - 1;\n\t\tarr[0] = arr[n];\n\t\tarr.RemoveAt(n);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(arr[j].CompareTo(arr[j+1])<0))j++;\n\t\t\t\tif (arr[i].CompareTo(arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n      \t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmper.Compare(arr[j],arr[j+1])<0))j++;\n\t\t\t\tif (Cmper.Compare(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmp(arr[i],arr[j])<0))j++;\n\t\t\t\tif (Cmp(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Push(T elem){\n\t\tPushHeap(this.buffer, elem);\n\t}\n\t\n\tpublic void Pop(){\n\t\tPopHeap(this.buffer);\n\t}\n\t\n\tpublic bool Contains(T elem){\n\t\treturn this.buffer.Contains(elem);\n\t}\n\tpublic T Top{\n\t\tget{return this.buffer[0];}\n\t}\n\t\n\tpublic int Count{\n\t\tget{return this.buffer.Count;}\n\t}\n\t\n\tpublic T this[int i]{\n\t\tget{return this.buffer[i];}\n\t}\n\t\n\tpublic bool IsEmpty{\n\t\tget{return this.buffer.Count==0;}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\tint[] From=new int[M],To=new int[M],Cost=new int[M];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t\tFrom[i]=d[0];To[i]=d[1];Cost[i]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1????????????????????????edge????????????\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i])E[From[i]].Add(new Pair(To[i],Cost[i]));\n\t\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i])E[To[i]].Add(new Pair(From[i],Cost[i]));\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1???????????????????????????????????§??????????????????\n\t\t\t//???????????????\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);//???->N-1??????????????¢\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tdouble[] dp=new double[N];//dp[i]:0??????i???????????????????????°\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t}\n\t\t\t}\n//for(int i=0;i<N;i++)Console.WriteLine(\"{0}-{1}\",tmp[i].Pos,tmp[i].Cost);\t\t\t\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tdouble[] dp2=new double[N];//dp2[i]:c??????i???????????????????????°\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n//Console.WriteLine(\"now={0},0->now:{1} +now->next;{2} +next->N-1:{3},next={4},C:{5}\",now,WF[0][now],next.Cost,WF[next.Pos][N-1],next.Pos,WF[0][N-1]);\n\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"0->{0}:{1},->N-1:{2},tot={3}\",c,dp[c],dp2[N-1],dp[N-1]);\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",dp[c]/dp[N-1]*dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0 && d[2]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tint INF=(int)1e9;\n\t\t\n\t\tint[][] WF=new int[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tWF[i]=new int[N];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tWF[i][j]=i==j?0:INF;\n\t\t\t}\n\t\t\tfor(int j=0;j<E[i].Count;j++){\n\t\t\t\tWF[i][E[i][j].To]=E[i][j].Cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Math.Min(WF[i][k]+WF[k][j],WF[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost0=new int[N];\n\t\tlong[] Count0=new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost0[i]=INF;\n\t\t\tCount0[i]=0;\n\t\t}\n\t\tCost0[0]=0;\n\t\tCount0[0]=1;\n\t\tbool[] used=new bool[N];\n\t\tbool finished=false;\n\t\t\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost0[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost0[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost0[trgt];\n\t\t\tlong cnt=Count0[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost0[E[n][j].To]){\n\t\t\t\t\tCost0[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount0[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost0[E[n][j].To]){\n\t\t\t\t\tCount0[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost=new int[N];\n\t\tlong[] Count=new long[N];\n\t\t\n\t\tfinished=false;\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost[i]=INF;\n\t\t\tCount[i]=0;\n\t\t\tused[i]=false;\n\t\t}\n\t\tCost[N-1]=0;\n\t\tCount[N-1]=1;\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost[trgt];\n\t\t\tlong cnt=Count[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost[E[n][j].To]){\n\t\t\t\t\tCost[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost[E[n][j].To]){\n\t\t\t\t\tCount[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\tfor(int q=0;q<Children.Count;q++){\n\t\t\t//if(WF[0][q]+WF[q][N-1]>WF[0][N-1]){\n\t\t\t//\tConsole.WriteLine(\"0.0\");\n\t\t\t//\tcontinue;\n\t\t\t//}\n\t\t\t\n\n\t\t\tdouble p=(double)Count0[Children[q]]*(double)Count[Children[q]]/(double)Count0[N-1];\n\t\t\tConsole.WriteLine(\"{0:F}\",p);\n\t\t}\n\t\t\n\t}\n\t\n\tint N;\n\tint M;\n\tint P;\n\tList<Edge>[] E;\n\tList<int> Children;\n\tpublic Sol(int[] d_){\n\t\tN=d_[0];M=d_[1];P=d_[2];\n\t\tE=new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tE[i]=new List<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tvar d=ria();\n\t\t\tE[d[0]].Add(new Edge(d[1],d[2]));\n\t\t\tE[d[1]].Add(new Edge(d[0],d[2]));\n\t\t}\n\t\t\n\t\tChildren=new List<int>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tChildren.Add(ri());\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tpublic int To;\n\t\tpublic int Cost;\n\t\tpublic Edge(int t_,int c_){\n\t\t\tTo=t_;Cost=c_;\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0 && d[2]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tint INF=(int)1e9;\n\t\t\n\t\tint[][] WF=new int[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tWF[i]=new int[N];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tWF[i][j]=i==j?0:INF;\n\t\t\t}\n\t\t\tfor(int j=0;j<E[i].Count;j++){\n\t\t\t\tWF[i][E[i][j].To]=E[i][j].Cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Math.Min(WF[i][k]+WF[k][j],WF[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost0=new int[N];\n\t\tlong[] Count0=new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost0[i]=INF;\n\t\t\tCount0[i]=0;\n\t\t}\n\t\tCost0[0]=0;\n\t\tCount0[0]=1;\n\t\tbool[] used=new bool[N];\n\t\tbool finished=false;\n\t\t\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost0[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost0[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost0[trgt];\n\t\t\tlong cnt=Count0[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost0[E[n][j].To]){\n\t\t\t\t\tCost0[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount0[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost0[E[n][j].To]){\n\t\t\t\t\tCount0[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n\t\tfor(int q=0;q<Children.Count;q++){\n\n\n\t\t\t\n\t\t\tint[] Cost=new int[N];\n\t\t\tlong[] Count=new long[N];\n\t\t\t\n\t\t\tfinished=false;\n\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tCost[i]=INF;\n\t\t\t\tCount[i]=0;\n\t\t\t\tused[i]=false;\n\t\t\t}\n\t\t\tCost[Children[q]]=0;\n\t\t\tCount[Children[q]]=1;\n\t\t\twhile(!finished){\n\t\t\t\tfinished=true;\n\t\t\t\tint trgt=-1;\n\t\t\t\tint mincost=INF+1;\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tfinished=finished&used[j];\n\t\t\t\t\tif(!used[j] && Cost[j]<mincost){\n\t\t\t\t\t\ttrgt=j;\n\t\t\t\t\t\tmincost=Cost[j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(finished)break;\n\t\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\t\n\t\t\t\tint n=trgt;\n\t\t\t\tint c=Cost[trgt];\n\t\t\t\tlong cnt=Count[trgt];\n\t\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\t\tif(c+E[n][j].Cost<Cost[E[n][j].To]){\n\t\t\t\t\t\tCost[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\t\tCount[E[n][j].To]=cnt;\n\t\t\t\t\t}else if(c+E[n][j].Cost==Cost[E[n][j].To]){\n\t\t\t\t\t\tCount[E[n][j].To]+=cnt;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\t\t\n\n\n\n\n\n\n\n\t\t\tif(WF[0][Children[q]]+WF[Children[q]][N-1]>WF[0][N-1]){\n\t\t\t\tConsole.WriteLine(\"0.0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\n\t\t\tdouble p=(double)Count0[Children[q]]*(double)Count[N-1]/(double)Count0[N-1];\n\t\t\tConsole.WriteLine(\"{0:F}\",p);\n\t\t}\n\t\t\n\t}\n\t\n\tint N;\n\tint M;\n\tint P;\n\tList<Edge>[] E;\n\tList<int> Children;\n\tpublic Sol(int[] d_){\n\t\tN=d_[0];M=d_[1];P=d_[2];\n\t\tE=new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tE[i]=new List<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tvar d=ria();\n\t\t\tE[d[0]].Add(new Edge(d[1],d[2]));\n\t\t\tE[d[1]].Add(new Edge(d[0],d[2]));\n\t\t}\n\t\t\n\t\tChildren=new List<int>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tChildren.Add(ri());\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tpublic int To;\n\t\tpublic int Cost;\n\t\tpublic Edge(int t_,int c_){\n\t\t\tTo=t_;Cost=c_;\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tE[d[0]].Add(new Pair(d[1],d[2]));\n\t\t\t\tE[d[1]].Add(new Pair(d[0],d[2]));\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1の最短経路にだけこれまでの経路を配る\n\t\t\t//遠い順から\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][0]);//ｉ->N-1の最短距離\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?1:x.Cost<y.Cost?-1:0);\n\t\t\t\n\t\t\tlong[] dp=new long[N];//dp[i]:0からiへのの最短経路数\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1] && WF[now][0]+next.Cost==WF[next.Pos][0]){\n\t\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//for(int i=0;i<N;i++)Console.WriteLine(\"{0}-{1}\",tmp[i].Pos,tmp[i].Cost);\t\t\t\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tlong[] dp2=new long[N];//dp2[i]:cからiへのの最短経路数\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n//Console.WriteLine(\"now={0},0->now:{1} +now->next;{2} +next->N-1:{3},next={4},C:{5}\",now,WF[0][now],next.Cost,WF[next.Pos][N-1],next.Pos,WF[0][N-1]);\n\t\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1] && WF[now][0]+next.Cost==WF[next.Pos][0]){\n\t\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"0->{0}:{1},->N-1:{2},tot={3}\",c,dp[c],dp2[N-1],dp[N-1]);\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tE[d[0]].Add(new Pair(d[1],d[2]));\n\t\t\t\tE[d[1]].Add(new Pair(d[0],d[2]));\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1の最短経路にだけこれまでの経路を配る\n\t\t\t//遠い順から\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);//ｉ->N-1の最短距離\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tlong[] dp=new long[N];//dp[i]:0からiへのの最短経路数\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1] && WF[now][0]+next.Cost==WF[next.Pos][0]){\n\t\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//for(int i=0;i<N;i++)Console.WriteLine(\"{0}-{1}\",tmp[i].Pos,tmp[i].Cost);\t\t\t\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tint idx=-1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tif(tmp[i].Pos==c){\n\t\t\t\t\t\tidx=i;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong[] dp2=new long[N];//dp2[i]:cからiへのの最短経路数\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=idx;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n//Console.WriteLine(\"now={0},0->now:{1} +now->next;{2} +next->N-1:{3},next={4},C:{5}\",now,WF[0][now],next.Cost,WF[next.Pos][N-1],next.Pos,WF[0][N-1]);\n\t\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1] && WF[now][0]+next.Cost==WF[next.Pos][0]){\n\t\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"0->{0}:{1},->N-1:{2},tot={3}\",c,dp[c],dp2[N-1],dp[N-1]);\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tE[d[0]].Add(new Pair(d[1],d[2]));\n\t\t\t\tE[d[1]].Add(new Pair(d[0],d[2]));\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1???????????????????????????????????§??????????????????\n\t\t\t//???????????????\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);//???->N-1??????????????¢\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tdouble[] dp=new double[N];//dp[i]:0??????i???????????????????????°\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1] && WF[now][0]+next.Cost==WF[next.Pos][0]){\n\t\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//for(int i=0;i<N;i++)Console.WriteLine(\"{0}-{1}\",tmp[i].Pos,tmp[i].Cost);\t\t\t\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tdouble[] dp2=new double[N];//dp2[i]:c??????i???????????????????????°\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n//Console.WriteLine(\"now={0},0->now:{1} +now->next;{2} +next->N-1:{3},next={4},C:{5}\",now,WF[0][now],next.Cost,WF[next.Pos][N-1],next.Pos,WF[0][N-1]);\n\t\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1] && WF[now][0]+next.Cost==WF[next.Pos][0]){\n\t\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"0->{0}:{1},->N-1:{2},tot={3}\",c,dp[c],dp2[N-1],dp[N-1]);\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tE[d[0]].Add(new Pair(d[1],d[2]));\n\t\t\t\tE[d[1]].Add(new Pair(d[0],d[2]));\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1の最短経路にだけこれまでの経路を配る\n\t\t\t//遠い順から\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);//ｉ->N-1の最短距離\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tlong[] dp=new long[N];//dp[i]:0からiへのの最短経路数\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1]){\n\t\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//for(int i=0;i<N;i++)Console.WriteLine(\"{0}-{1}\",tmp[i].Pos,tmp[i].Cost);\t\t\t\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tint idx=-1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tif(tmp[i].Pos==c){\n\t\t\t\t\t\tidx=i;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong[] dp2=new long[N];//dp2[i]:cからiへのの最短経路数\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=idx;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n//Console.WriteLine(\"now={0},0->now:{1} +now->next;{2} +next->N-1:{3},next={4},C:{5}\",now,WF[0][now],next.Cost,WF[next.Pos][N-1],next.Pos,WF[0][N-1]);\n\t\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1]){\n\t\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"0->{0}:{1},->N-1:{2},tot={3}\",c,dp[c],dp2[N-1],dp[N-1]);\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\tint[] From=new int[M],To=new int[M],Cost=new int[M];\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t\tFrom[i]=d[0];To[i]=d[1];Cost[i]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tif(WF[From[i]][N-1]==WF[To[i]][N-1]+Cost[i] && WF[From[i]][0]+Cost[i]==WF[To[i]][0] )E[From[i]].Add(new Pair(To[i],Cost[i]));\n\t\t\t\tif(WF[To[i]][N-1]==WF[From[i]][N-1]+Cost[i] && WF[To[i]][0]+Cost[i]==WF[From[i]][0] )E[To[i]].Add(new Pair(From[i],Cost[i]));\n\t\t\t}\n\t\t\t\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][0]);\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?1:x.Cost<y.Cost?-1:0);\n\t\t\t\n\t\t\tlong[] dp=new long[N];\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tlong[] dp2=new long[N];\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0 && d[2]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tint INF=(int)1e9;\n\t\t\n\t\tint[][] WF=new int[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tWF[i]=new int[N];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tWF[i][j]=i==j?0:INF;\n\t\t\t}\n\t\t\tfor(int j=0;j<E[i].Count;j++){\n\t\t\t\tWF[i][E[i][j].To]=E[i][j].Cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Math.Min(WF[i][k]+WF[k][j],WF[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost0=new int[N];\n\t\tlong[] Count0=new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost0[i]=INF;\n\t\t\tCount0[i]=0;\n\t\t}\n\t\tCost0[0]=0;\n\t\tCount0[0]=1;\n\t\tbool[] used=new bool[N];\n\t\tbool finished=false;\n\t\t\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost0[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost0[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost0[trgt];\n\t\t\tlong cnt=Count0[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost0[E[n][j].To]){\n\t\t\t\t\tCost0[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount0[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost0[E[n][j].To]){\n\t\t\t\t\tCount0[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost=new int[N];\n\t\tlong[] Count=new long[N];\n\t\t\n\t\tfinished=false;\n\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost[i]=INF;\n\t\t\tCount[i]=0;\n\t\t\tused[i]=false;\n\t\t}\n\t\tCost[N-1]=0;\n\t\tCount[N-1]=1;\n\t\twhile(!finished){\n\t\t\tfinished=true;\n\t\t\tint trgt=-1;\n\t\t\tint mincost=INF+1;\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tfinished=finished&used[j];\n\t\t\t\tif(!used[j] && Cost[j]<mincost){\n\t\t\t\t\ttrgt=j;\n\t\t\t\t\tmincost=Cost[j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(finished)break;\n\t\t\tif(trgt!=-1)used[trgt]=true;\n\t\t\t\n\t\t\tint n=trgt;\n\t\t\tint c=Cost[trgt];\n\t\t\tlong cnt=Count[trgt];\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost[E[n][j].To]){\n\t\t\t\t\tCost[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount[E[n][j].To]=cnt;\n\t\t\t\t}else if(c+E[n][j].Cost==Cost[E[n][j].To]){\n\t\t\t\t\tCount[E[n][j].To]+=cnt;\n\t\t\t\t}\n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\tfor(int q=0;q<Children.Count;q++){\n\t\t\tif(WF[0][q]+WF[q][0]>WF[0][N-1]){\n\t\t\t\tConsole.WriteLine(\"0.0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\n\t\t\tdouble p=(double)Count0[Children[q]]*(double)Count[Children[q]]/(double)Count0[N-1];\n\t\t\tConsole.WriteLine(\"{0:F}\",p);\n\t\t}\n\t\t\n\t}\n\t\n\tint N;\n\tint M;\n\tint P;\n\tList<Edge>[] E;\n\tList<int> Children;\n\tpublic Sol(int[] d_){\n\t\tN=d_[0];M=d_[1];P=d_[2];\n\t\tE=new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tE[i]=new List<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tvar d=ria();\n\t\t\tE[d[0]].Add(new Edge(d[1],d[2]));\n\t\t\tE[d[1]].Add(new Edge(d[0],d[2]));\n\t\t}\n\t\t\n\t\tChildren=new List<int>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tChildren.Add(ri());\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tpublic int To;\n\t\tpublic int Cost;\n\t\tpublic Edge(int t_,int c_){\n\t\t\tTo=t_;Cost=c_;\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tE[d[0]].Add(new Pair(d[1],d[2]));\n\t\t\t\tE[d[1]].Add(new Pair(d[0],d[2]));\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1の最短経路にだけこれまでの経路を配る\n\t\t\t//遠い順から\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);//ｉ->N-1の最短距離\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tlong[] dp=new long[N];//dp[i]:0からiへのの最短経路数\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tif(WF[0][now]+next.Cost+WF[next.Pos][N-1]==WF[0][N-1]){\n\t\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n//for(int i=0;i<N;i++)Console.WriteLine(\"{0}-{1}\",tmp[i].Pos,tmp[i].Cost);\t\t\t\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tint idx=-1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tif(tmp[i].Pos==c){\n\t\t\t\t\t\tidx=i;break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlong[] dp2=new long[N];//dp2[i]:cからiへのの最短経路数\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=idx;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n//Console.WriteLine(\"now={0},0->now:{1} +now->next;{2} +next->N-1:{3},next={4},C:{5}\",now,WF[0][now],next.Cost,WF[next.Pos][N-1],next.Pos,WF[0][N-1]);\n\t\t\t\t\t\tif(WF[0][now]+next.Cost+WF[next.Pos][N-1]==WF[0][N-1]){\n\t\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n//Console.WriteLine(\"0->{0}:{1},->N-1:{2},tot={3}\",c,dp[c],dp2[N-1],dp[N-1]);\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\twhile(true){\n\t\t\tString s=\"\";\n\t\t\twhile(String.IsNullOrEmpty(s))s=Console.ReadLine();\n\t\t\tvar d=Array.ConvertAll(s.Split(' '),e=>int.Parse(e));\n\t\t\tif(d[0]==0 && d[1]==0 && d[2]==0)break;\n\t\t\tSol mySol =new Sol(d);\n\t\t\tmySol.Solve();\n\t\t\tConsole.WriteLine(\"\");\n\t\t}\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\tint INF=(int)1e9;\n\t\t\n\t\tint[][] WF=new int[N][];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tWF[i]=new int[N];\n\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\tWF[i][j]=i==j?0:INF;\n\t\t\t}\n\t\t\tfor(int j=0;j<E[i].Count;j++){\n\t\t\t\tWF[i][E[i][j].To]=E[i][j].Cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int k=0;k<N;k++){\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=Math.Min(WF[i][k]+WF[k][j],WF[i][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tint[] Cost0=new int[N];\n\t\tlong[] Count0=new long[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tCost0[i]=INF;\n\t\t\tCount0[i]=0;\n\t\t}\n\t\tCost0[0]=0;\n\t\tCount0[0]=1;\n\t\t\n\t\tPriorityQueue<State> PQ=new PriorityQueue<State>();\n\t\tPQ.Push(new State(0,0,1));\n\t\twhile(!PQ.IsEmpty){\n\t\t\tState S=PQ.Top;PQ.Pop();\n\t\t\tint n=S.V;\n\t\t\tint c=S.C;\n\t\t\tlong cnt=S.Count;\n\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\tif(c+E[n][j].Cost<Cost0[E[n][j].To]){\n\t\t\t\t\tCost0[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\tCount0[E[n][j].To]=cnt;\n\t\t\t\t\tPQ.Push(new State(E[n][j].To, Cost0[E[n][j].To], Count0[E[n][j].To] ) );\n\t\t\t\t}else if(c+E[n][j].Cost==Cost0[E[n][j].To]){\n\t\t\t\t\tCount0[E[n][j].To]+=cnt;\n\t\t\t\t\tPQ.Push(new State(E[n][j].To,Cost0[E[n][j].To],Count0[E[n][j].To]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tfor(int q=0;q<Children.Count;q++){\n\t\t\tif(WF[0][q]+WF[q][0]>WF[0][N-1]){\n\t\t\t\tConsole.WriteLine(\"0.0\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t\n\t\t\tint[] Cost=new int[N];\n\t\t\tlong[] Count=new long[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tCost[i]=INF;\n\t\t\t\tCount[i]=0;\n\t\t\t}\n\t\t\tCost[Children[q]]=0;\n\t\t\tCount[Children[q]]=1;\n\t\t\tPQ.Push(new State(Children[q],0,1));\n\t\t\twhile(!PQ.IsEmpty){\n\t\t\t\tState S=PQ.Top;PQ.Pop();\n\t\t\t\tint n=S.V;\n\t\t\t\tint c=S.C;\n\t\t\t\tlong cnt=S.Count;\n\t\t\t\tfor(int j=0;j<E[n].Count;j++){\n\t\t\t\t\tif(c+E[n][j].Cost<Cost[E[n][j].To]){\n\t\t\t\t\t\tCost[E[n][j].To]=c+E[n][j].Cost;\n\t\t\t\t\t\tCount[E[n][j].To]=cnt;\n\t\t\t\t\t\tPQ.Push(new State(E[n][j].To,Cost[E[n][j].To],Count[E[n][j].To]));\n\t\t\t\t\t}else if(c+E[n][j].Cost==Cost[E[n][j].To]){\n\t\t\t\t\t\tCount[E[n][j].To]+=cnt;\n\t\t\t\t\t\tPQ.Push(new State(E[n][j].To,Cost[E[n][j].To],Count[E[n][j].To]));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tdouble p=(double)Count0[Children[q]]*(double)Count[N-1]/(double)Count0[N-1];\n\t\t\tConsole.WriteLine(\"{0:F}\",p);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t\n\t}\n\t\n\tint N;\n\tint M;\n\tint P;\n\tList<Edge>[] E;\n\tList<int> Children;\n\tpublic Sol(int[] d_){\n\t\tN=d_[0];M=d_[1];P=d_[2];\n\t\tE=new List<Edge>[N];\n\t\tfor(int i=0;i<N;i++){\n\t\t\tE[i]=new List<Edge>();\n\t\t}\n\t\t\n\t\tfor(int i=0;i<M;i++){\n\t\t\tvar d=ria();\n\t\t\tE[d[0]].Add(new Edge(d[1],d[2]));\n\t\t\tE[d[1]].Add(new Edge(d[0],d[2]));\n\t\t}\n\t\t\n\t\tChildren=new List<int>();\n\t\tfor(int i=0;i<P;i++){\n\t\t\tChildren.Add(ri());\n\t\t}\n\t}\n\n\tclass Edge{\n\t\tpublic int To;\n\t\tpublic int Cost;\n\t\tpublic Edge(int t_,int c_){\n\t\t\tTo=t_;Cost=c_;\n\t\t}\n\t}\n\tclass State:IComparable<State>{\n\t\tpublic int V;\n\t\tpublic int C;\n\t\tpublic long Count;\n\t\tpublic State(int v_,int c_,long cnt_){\n\t\t\tV=v_;C=c_;Count=cnt_;\n\t\t}\n\t\tpublic int CompareTo(State other){\n\t\t\t//逆順\n\t\t\treturn this.C>other.C?-1:this.C<other.C?1:0;\n\t\t}\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}\n\n\n\n\n\nclass PriorityQueue<T> where T:IComparable<T>{\n\n\t//T:IComparable\n\t//IComparerかComparisonを指定してインスタンス化する事も可\n\t//引数なしインスタンス化⇒ComparedToで比較\n\t//大きいものほどTopへ\n\n\tenum typeCompare{\n\t\tisIComparerable=1,\n\t\tuseIComparer=2,\n\t\tuseDComparison=3\n\t}\n\n\tList<T> buffer;\n\ttypeCompare tComp;\n\tIComparer<T> Cmper;\n\tComparison<T> Cmp;\n\t\n\tpublic PriorityQueue(IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t\tCmp=null;\n\t}\n\tpublic PriorityQueue(){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>();\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t\tCmper=null;\n\t}\n\tpublic PriorityQueue(int capacity,IComparer<T> comparer_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useIComparer;\n\t\tCmper=comparer_;\n\t}\n\tpublic PriorityQueue(int capacity){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.isIComparerable;\n\t}\n\tpublic PriorityQueue(int capacity,Comparison<T> cmp_){\n\t\tthis.buffer=new List<T>(capacity);\n\t\ttComp=typeCompare.useDComparison;\n\t\tCmp=cmp_;\n\t}\n\t\n\n\tvoid PushHeap(List<T> arr,T elem){\n\t\tint n=arr.Count;\n\t\tbuffer.Add(elem);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(arr[n].CompareTo(arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\ttry{\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmper.Compare(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t\t}\n\t\t        catch (Exception e){\n\t\t\t\tConsole.WriteLine(\"{0} Exception caught.\", e);\n\t\t        }\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\twhile(n!=0){\n\t\t\t\tint i=(n-1)/2;\n\t\t\t\tif(Cmp(arr[n],arr[i]) > 0){\n\t\t\t\t\tT tmp=arr[n];arr[n]=arr[i];arr[i]=tmp;\n\t\t\t\t}\n\t\t\t\tn=i;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tvoid PopHeap(List<T> arr){\n\t\tint n=arr.Count - 1;\n\t\tarr[0] = arr[n];\n\t\tarr.RemoveAt(n);\n\t\t\n\t\tif(tComp==typeCompare.isIComparerable){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(arr[j].CompareTo(arr[j+1])<0))j++;\n\t\t\t\tif (arr[i].CompareTo(arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n      \t\t}else if(tComp==typeCompare.useIComparer){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmper.Compare(arr[j],arr[j+1])<0))j++;\n\t\t\t\tif (Cmper.Compare(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}else if(tComp==typeCompare.useDComparison){\n\t\t\tfor (int i=0,j;(j = 2*i +1)<n;){\n\t\t\t\tif((j!=n - 1)&&(Cmp(arr[i],arr[j])<0))j++;\n\t\t\t\tif (Cmp(arr[i],arr[j])<0){\n\t\t\t\t\tT tmp = arr[j]; arr[j] = arr[i]; arr[i] = tmp;\n\t\t\t\t}\n\t\t\t\ti=j;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic void Push(T elem){\n\t\tPushHeap(this.buffer, elem);\n\t}\n\t\n\tpublic void Pop(){\n\t\tPopHeap(this.buffer);\n\t}\n\t\n\tpublic bool Contains(T elem){\n\t\treturn this.buffer.Contains(elem);\n\t}\n\tpublic T Top{\n\t\tget{return this.buffer[0];}\n\t}\n\t\n\tpublic int Count{\n\t\tget{return this.buffer.Count;}\n\t}\n\t\n\tpublic T this[int i]{\n\t\tget{return this.buffer[i];}\n\t}\n\t\n\tpublic bool IsEmpty{\n\t\tget{return this.buffer.Count==0;}\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections;\nusing System.Collections.Generic;\n \nclass TEST{\n\tstatic void Main(){\n\t\tnew Sol().Solve();\n\t}\n}\n\nclass Sol{\n\tpublic void Solve(){\n\t\t\n\t\twhile(true){\n\t\t\tvar d=ria();\n\t\t\tN=d[0];M=d[1];P=d[2];\n\t\t\tif(N==0&&M==0&&P==0)return;\n\t\t\tint Inf=(int)1e9;\n\t\t\tint[][] WF=new int[N][];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tWF[i]=new int[N];\n\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\tWF[i][j]=(i==j)?0:Inf;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tE=new List<Pair>[N];\n\t\t\tfor(int i=0;i<N;i++)E[i]=new List<Pair>();\n\t\t\t\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\td=ria();\n\t\t\t\tE[d[0]].Add(new Pair(d[1],d[2]));\n\t\t\t\tE[d[1]].Add(new Pair(d[0],d[2]));\n\t\t\t\tWF[d[0]][d[1]]=WF[d[1]][d[0]]=d[2];\n\t\t\t}\n\t\t\t\n\t\t\tfor(int k=0;k<N;k++){\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tfor(int j=0;j<N;j++){\n\t\t\t\t\t\tWF[i][j]=Math.Min(WF[i][j],WF[i][k]+WF[k][j]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t//0->N-1???????????????????????????????????§??????????????????\n\t\t\t//???????????????\n\t\t\tPair[] tmp=new Pair[N];\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\ttmp[i]=new Pair(i,WF[i][N-1]);//???->N-1??????????????¢\n\t\t\t}\n\t\t\tArray.Sort(tmp,(x,y)=>x.Cost>y.Cost?-1:x.Cost<y.Cost?1:0);\n\t\t\t\n\t\t\tdouble[] dp=new double[N];//dp[i]:0??????i???????????????????????°\n\t\t\tdp[0]=1;\n\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1]){\n\t\t\t\t\t\tdp[next.Pos]+=dp[now];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(;P>0;P--){\n\t\t\t\tint c=ri();\n\t\t\t\tdouble[] dp2=new double[N];//dp2[i]:c??????i???????????????????????°\n\t\t\t\tdp2[c]=1;\n\t\t\t\tfor(int i=0;i<N;i++){\n\t\t\t\t\tint now=tmp[i].Pos;\n\t\t\t\t\tforeach(var next in E[now]){\n\t\t\t\t\t\tif(WF[now][N-1]==next.Cost+WF[next.Pos][N-1]){\n\t\t\t\t\t\t\tdp2[next.Pos]+=dp2[now];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tConsole.WriteLine(\"{0:F12}\",((double)dp[c]/(double)dp[N-1])*(double)dp2[N-1]);\n\t\t\t}\n\t\t\tConsole.WriteLine();\n\t\t\n\t\t}\n\t}\n\t\n\tint N,M,P;\n\tList<Pair>[] E;\n\t\n\tclass Pair{\n\t\tpublic int Pos,Cost;\n\t\tpublic Pair(int p,int c){\n\t\t\tPos=p;Cost=c;\n\t\t}\n\t}\n\t\n\t\n\t\n\n\tpublic Sol(){\n\t}\n\n\tstatic String rs(){return Console.ReadLine();}\n\tstatic int ri(){return int.Parse(Console.ReadLine());}\n\tstatic long rl(){return long.Parse(Console.ReadLine());}\n\tstatic double rd(){return double.Parse(Console.ReadLine());}\n\tstatic String[] rsa(){return Console.ReadLine().Split(' ');}\n\tstatic int[] ria(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>int.Parse(e));}\n\tstatic long[] rla(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>long.Parse(e));}\n\tstatic double[] rda(){return Array.ConvertAll(Console.ReadLine().Split(' '),e=>double.Parse(e));}\n}"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### subroutines\n\ndef count_routes(k, prevs)\n  return $counts[k] if ! $counts[k].nil?\n\n  count = 0\n\n  for prv in prevs[k]\n    count += count_routes(prv, prevs)\n  end\n\n  $counts[k] = count\nend\n\n### main\n\nloop do\n  n, m, pn = gets.split.map(&:to_i)\n  break if (n | m | pn) == 0\n\n  nbrs = n.times.map{[]}\n  edges = n.times.map{[]}\n\n  m.times do\n    i, j, w = gets.split.map(&:to_i)\n    nbrs[i] << j\n    nbrs[j] << i\n    edges[i][j] = edges[j][i] = w\n  end\n  #p nbrs\n  #p edges\n\n  cis = pn.times.map{gets.to_i}\n  #p cis\n\n  dists = n.times.map{MAX_INT}\n  prevs = n.times.map{[]}\n\n  dists[0] = 0\n  q = [0]\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a] <=> dists[b]}\n    q.delete(u)\n\n    next if u == n - 1\n\n    du = dists[u]\n\n    for v in nbrs[u]\n      dv = dists[v]\n      ndv = du + edges[u][v]\n\n      if dv > ndv\n        dists[v] = ndv\n        prevs[v] = [u]\n        if dv >= MAX_INT\n          q << v\n        end\n      elsif dv == ndv\n        prevs[v] << u\n      end\n    end\n  end\n  #p prevs\n\n  $counts = n.times.map{nil}\n  $counts[0] = 1\n\n  total = count_routes(n - 1, prevs)\n  #p $counts\n\n  for ci in cis\n    puts \"%.8f\" % ($counts[ci].to_f / total)\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### subroutines\n\ndef count_routes(k, prevs, rts)\n  if k == 0\n    for i in rts\n      $counts[i] += 1\n    end\n    return\n  end\n\n  for prv in prevs[k]\n    count_routes(prv, prevs, rts + [prv])\n  end\nend\n\n### main\n\nloop do\n  n, m, pn = gets.split.map(&:to_i)\n  break if (n | m | pn) == 0\n\n  nbrs = n.times.map{[]}\n  edges = n.times.map{[]}\n\n  m.times do\n    i, j, w = gets.split.map(&:to_i)\n    nbrs[i] << j\n    nbrs[j] << i\n    edges[i][j] = edges[j][i] = w\n  end\n  #p nbrs\n  #p edges\n\n  cis = pn.times.map{gets.to_i}\n  #p cis\n\n  dists = n.times.map{MAX_INT}\n  prevs = n.times.map{[]}\n\n  dists[0] = 0\n  q = [0]\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a] <=> dists[b]}\n    q.delete(u)\n\n    next if u == n - 1\n\n    du = dists[u]\n\n    for v in nbrs[u]\n      dv = dists[v]\n      ndv = du + edges[u][v]\n\n      if dv > ndv\n        dists[v] = ndv\n        prevs[v] = [u]\n        if dv >= MAX_INT\n          q << v\n        end\n      elsif dv == ndv\n        prevs[v] << u\n      end\n    end\n  end\n  #p prevs\n\n  $counts = n.times.map{0}\n\n  count_routes(n - 1, prevs, [n - 1])\n  #p $counts\n  total = $counts[n - 1]\n\n  for ci in cis\n    puts \"%.8f\" % ($counts[ci].to_f / total)\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### subroutines\n\ndef count_routes(k, prevs)\n  return $counts[k] if ! $counts[k].nil?\n\n  count = 0\n\n  for prv in prevs[k]\n    count += count_routes(prv, prevs)\n  end\n\n  $counts[k] = count\nend\n\ndef calc_pbs(k, nexts)\n  return $pbs[k] if ! $pbs[k].nil?\n\n  pb = 0.0\n\n  for nxt in nexts[k]\n    pb += calc_pbs(nxt, nexts) * $counts[k] / $counts[nxt]\n  end\n\n  $pbs[k] = pb\nend\n\n### main\n\nloop do\n  n, m, pn = gets.split.map(&:to_i)\n  break if (n | m | pn) == 0\n\n  nbrs = n.times.map{[]}\n  edges = n.times.map{[]}\n\n  m.times do\n    i, j, w = gets.split.map(&:to_i)\n    nbrs[i] << j\n    nbrs[j] << i\n    edges[i][j] = edges[j][i] = w\n  end\n  #p nbrs\n  #p edges\n\n  cis = pn.times.map{gets.to_i}\n  #p cis\n\n  dists = n.times.map{MAX_INT}\n  prevs = n.times.map{[]}\n\n  dists[0] = 0\n  q = [0]\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a] <=> dists[b]}\n    q.delete(u)\n\n    next if u == n - 1\n\n    du = dists[u]\n\n    for v in nbrs[u]\n      dv = dists[v]\n      ndv = du + edges[u][v]\n\n      if dv > ndv\n        dists[v] = ndv\n        prevs[v] = [u]\n        if dv >= MAX_INT\n          q << v\n        end\n      elsif dv == ndv\n        prevs[v] << u\n      end\n    end\n  end\n  #p prevs\n\n  nexts = n.times.map{[]}\n  for i in (0...n)\n    for j in prevs[i]\n      nexts[j] << i\n    end\n  end\n  #p nexts\n\n  $counts = n.times.map{nil}\n  $counts[0] = 1\n\n  count_routes(n - 1, prevs)\n  #p $counts\n\n  $pbs = n.times.map{nil}\n  $pbs[n - 1] = 1.0\n\n  calc_pbs(0, nexts)\n  #p $pbs\n\n  for ci in cis\n    puts \"%.8f\" % $pbs[ci]\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### subroutines\n\ndef count_routes(k, prevs)\n  return $counts[k] if ! $counts[k].nil?\n\n  count = 0\n\n  for prv in prevs[k]\n    count += count_routes(prv, prevs)\n  end\n\n  $counts[k] = count\nend\n\n### main\n\nloop do\n  n, m, pn = gets.split.map(&:to_i)\n  break if (n | m | pn) == 0\n\n  nbrs = n.times.map{[]}\n  edges = n.times.map{[]}\n\n  m.times do\n    i, j, w = gets.split.map(&:to_i)\n    nbrs[i] << j\n    nbrs[j] << i\n    edges[i][j] = edges[j][i] = w\n  end\n  #p nbrs\n  #p edges\n\n  cis = pn.times.map{gets.to_i}\n  #p cis\n\n  dists = n.times.map{MAX_INT}\n  prevs = n.times.map{[]}\n\n  dists[0] = 0\n  q = [0]\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a] <=> dists[b]}\n    q.delete(u)\n\n    next if u == n - 1\n\n    du = dists[u]\n\n    for v in nbrs[u]\n      dv = dists[v]\n      ndv = du + edges[u][v]\n\n      if dv > ndv\n        dists[v] = ndv\n        prevs[v] = [u]\n        if dv >= MAX_INT\n          q << v\n        end\n      elsif dv == ndv\n        prevs[v] << u\n      end\n    end\n  end\n  #p prevs\n\n  $counts = n.times.map{nil}\n  $counts[0] = 1\n\n  total = count_routes(n - 1, prevs)\n  $counts[0] = total\n  #p $counts\n\n  for ci in cis\n    puts \"%.8f\" % ($counts[ci].to_f / total)\n  end\n  puts\nend"
  },
  {
    "language": "Ruby",
    "code": "### constant\n\nMAX_INT = 1 << 30\n\n### main\n\nloop do\n  n, m, pn = gets.split.map(&:to_i)\n  break if (n | m | pn) == 0\n\n  nbrs = n.times.map{[]}\n  edges = n.times.map{[]}\n\n  m.times do\n    i, j, w = gets.split.map(&:to_i)\n    nbrs[i] << j\n    nbrs[j] << i\n    edges[i][j] = edges[j][i] = w\n  end\n  #p nbrs\n  #p edges\n\n  cis = pn.times.map{gets.to_i}\n  #p cis\n\n  dists = n.times.map{MAX_INT}\n  prevs = n.times.map{[]}\n\n  dists[0] = 0\n  q = [0]\n\n  while ! q.empty?\n    u = q.min{|a, b| dists[a] <=> dists[b]}\n    q.delete(u)\n\n    next if u == n - 1\n\n    du = dists[u]\n\n    for v in nbrs[u]\n      dv = dists[v]\n      ndv = du + edges[u][v]\n\n      if dv > ndv\n        dists[v] = ndv\n        prevs[v] = [u]\n        if dv >= MAX_INT\n          q << v\n        end\n      elsif dv == ndv\n        prevs[v] << u\n      end\n    end\n  end\n  #p prevs\n\n  nexts = n.times.map{[]}\n  for i in (0...n)\n    for j in prevs[i]\n      nexts[j] << i\n    end\n  end\n  #p nexts\n\n  $counts = n.times.map{0}\n  $ncounts = n.times.map{0}\n  $counts[0] = 1\n  q = [0]\n\n  while ! q.empty?\n    u = q.shift\n\n    if prevs[u].length > $ncounts[u]\n      q << u\n      next\n    end\n\n    cu = $counts[u]\n\n    for v in nexts[u]\n      cv = $counts[v]\n      $counts[v] += cu\n      $ncounts[v] += 1\n      if cv == 0\n        q << v\n      end\n    end\n  end\n  #p $counts\n\n  $pbs = n.times.map{0.0}\n  $npbs = n.times.map{0}\n  $pbs[n - 1] = 1.0\n  q = [n - 1]\n\n  while ! q.empty?\n    u = q.shift\n\n    if nexts[u].length > $npbs[u]\n      q << u\n      next\n    end\n\n    pu = $pbs[u]\n    cu = $counts[u]\n\n    for v in prevs[u]\n      pv = $pbs[v]\n      $pbs[v] += pu * $counts[v] / cu\n      $npbs[v] += 1\n      if pv == 0.0\n        q << v\n      end\n    end\n  end\n  #p $pbs\n\n  for ci in cis\n    puts \"%.8f\" % $pbs[ci]\n  end\n  puts\nend"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0) return false;\n    G.destroy;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    struct S { int v, cost; }\n    auto D = dijkstra;\n    BinaryHeap!(Array!S, \"a.cost < b.cost\") Q;\n    Q.insert(S(N - 1, D[N - 1]));\n    auto X = new int[][](N, N); X[N - 1][N - 1] = 1;\n    auto inQ = new bool[N];\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        inQ[s.v] = false;\n        foreach (e; G[s.v]) {\n            if (D[e.to] == D[s.v] - e.cost) {\n                X[e.to][s.v] += X[s.v].reduce!\"a + b\";\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    Q.insert(S(e.to, D[e.to]));\n                }\n            }\n        }\n    }\n    //writeln(D);\n    //foreach (L; X) writeln(L);\n\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new real[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    inQ[] = false;\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        inQ[s.v] = false;\n        auto x = X[s.v].reduce!\"a + b\";\n        foreach (e; G[s.v]) {\n            if (X[s.v][e.to] == 0) continue;\n            if (!inQ[e.to]) {\n                assert(s.cost + e.cost == D[e.to]);\n                Qs.insert(S(e.to, D[e.to]));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] / x * X[s.v][e.to];\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.12f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0 && M == 0 && P == 0) return false;\n    G.destroy;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    struct S { int v, cost; }\n    auto D = dijkstra;\n    BinaryHeap!(Array!S, \"a.cost < b.cost\") Q;\n    Q.insert(S(N - 1, D[N - 1]));\n    auto X = new int[N]; X[N - 1] = 1;\n    auto inQ = new bool[N];\n    inQ[N - 1] = true;\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] == D[s.v] - e.cost) {\n                X[e.to] += X[s.v];\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    Q.insert(S(e.to, D[e.to]));\n                }\n            }\n        }\n    }\n    //writeln(D);\n    //writeln(X);\n\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new real[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    inQ[] = false;\n    inQ[0] = true;\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        auto x = X[s.v];\n        foreach (e; G[s.v]) {\n            if (s.cost + e.cost != D[e.to]) continue;\n            if (!inQ[e.to]) {\n                Qs.insert(S(e.to, D[e.to]));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] * X[e.to] / x;\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.8f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0 && M == 0 && P == 0) return false;\n    G.destroy;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    struct S { int v, cost; }\n    auto D = dijkstra;\n    BinaryHeap!(Array!S, \"a.cost < b.cost\") Q;\n    Q.insert(S(N - 1, D[N - 1]));\n    auto X = new int[][](N, N); X[N - 1][N - 1] = 1;\n    auto inQ = new bool[N];\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        inQ[s.v] = false;\n        foreach (e; G[s.v]) {\n            if (D[e.to] == D[s.v] - e.cost) {\n                X[e.to][s.v] += X[s.v].reduce!\"a + b\";\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    Q.insert(S(e.to, D[e.to]));\n                }\n            }\n        }\n    }\n    //writeln(D);\n    //foreach (L; X) writeln(L);\n\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new real[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    inQ[] = false;\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        inQ[s.v] = false;\n        auto x = X[s.v].reduce!\"a + b\";\n        foreach (e; G[s.v]) {\n            if (X[s.v][e.to] == 0) continue;\n            if (!inQ[e.to]) {\n                assert(s.cost + e.cost == D[e.to]);\n                Qs.insert(S(e.to, D[e.to]));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] * X[s.v][e.to] / x;\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.12f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0) return false;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S {\n        int v, cost;\n    }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    auto D = dijkstra;\n    DList!int Q;\n    Q.insert(N - 1);\n    auto X = new bool[][](N, N);\n    while (!Q.empty) {\n        auto v = Q.front; Q.removeFront;\n        foreach (e; G[v]) {\n            if (D[e.to] == D[v] - e.cost) {\n                X[e.to][v] = true;\n                Q.insert(e.to);\n            }\n        }\n    }\n    //writeln(D);\n    //foreach (L; X) writeln(L);\n\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new double[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    auto inQ = new bool[N];\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        inQ[s.v] = false;\n        auto x = X[s.v].count!\"a\";\n        foreach (e; G[s.v]) {\n            if (!X[s.v][e.to]) continue;\n            if (!inQ[e.to]) {\n                assert(s.cost + e.cost == D[e.to]);\n                Qs.insert(S(e.to, s.cost + e.cost));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] / x;\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.8f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0) return false;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    auto D = dijkstra;\n    DList!int Q;\n    Q.insert(N - 1);\n    auto X = new bool[][](N, N);\n    auto inQ = new bool[N];\n    while (!Q.empty) {\n        auto v = Q.front; Q.removeFront;\n        inQ[v] = false;\n        foreach (e; G[v]) {\n            if (D[e.to] == D[v] - e.cost) {\n                X[e.to][v] = true;\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    Q.insert(e.to);\n                }\n            }\n        }\n    }\n    //writeln(D);\n    //foreach (L; X) writeln(L);\n\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new double[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    inQ[] = false;\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        inQ[s.v] = false;\n        auto x = X[s.v].count!\"a\";\n        foreach (e; G[s.v]) {\n            if (!X[s.v][e.to]) continue;\n            if (!inQ[e.to]) {\n                assert(s.cost + e.cost == D[e.to]);\n                Qs.insert(S(e.to, s.cost + e.cost));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] / x;\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.8f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0) return false;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S {\n        int v, cost;\n    }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    auto D = dijkstra;\n    DList!int Q;\n    Q.insert(N - 1);\n    auto X = new bool[][](N, N);\n    while (!Q.empty) {\n        auto v = Q.front; Q.removeFront;\n        foreach (e; G[v]) {\n            if (D[e.to] == D[v] - e.cost) {\n                X[e.to][v] = true;\n                Q.insert(e.to);\n            }\n        }\n    }\n    //writeln(D);\n    //foreach (L; X) writeln(L);\n\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new double[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    auto inQ = new bool[N];\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        auto x = X[s.v].count!\"a\";\n        foreach (e; G[s.v]) {\n            if (!X[s.v][e.to]) continue;\n            if (!inQ[e.to]) {\n                Qs.insert(S(e.to, s.cost + e.cost));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] / x;\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.8f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0 && M == 0 && P == 0) return false;\n    G.destroy;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    struct S { int v, cost; }\n    auto D = dijkstra;\n    BinaryHeap!(Array!S, \"a.cost < b.cost\") Q;\n    Q.insert(S(N - 1, D[N - 1]));\n    auto X = new int[N]; X[N - 1] = 1;\n    auto inQ = new bool[N];\n    inQ[N - 1] = true;\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] == D[s.v] - e.cost) {\n                X[e.to] += X[s.v];\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    Q.insert(S(e.to, D[e.to]));\n                }\n            }\n        }\n    }\n    //writeln(D);\n    //writeln(X);\n\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new real[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    inQ[] = false;\n    inQ[0] = true;\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        auto x = X[s.v];\n        foreach (e; G[s.v]) {\n            if (X[e.to] == 0) continue;\n            if (s.cost + e.cost != D[e.to]) continue;\n            if (!inQ[e.to]) {\n                Qs.insert(S(e.to, D[e.to]));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] * X[e.to] / x;\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.12f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0) return false;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    struct S { int v, cost; }\n    auto D = dijkstra;\n    BinaryHeap!(Array!S, \"a.cost < b.cost\") Q;\n    Q.insert(S(N - 1, D[N - 1]));\n    auto X = new int[][](N, N); X[N - 1][N - 1] = 1;\n    auto inQ = new bool[N];\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        inQ[s.v] = false;\n        foreach (e; G[s.v]) {\n            if (D[e.to] == D[s.v] - e.cost) {\n                X[e.to][s.v] += X[s.v].reduce!\"a + b\";\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    Q.insert(S(e.to, D[e.to]));\n                }\n            }\n        }\n    }\n    //writeln(D);\n    //foreach (L; X) writeln(L);\n\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new double[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    inQ[] = false;\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        inQ[s.v] = false;\n        auto x = X[s.v].reduce!\"a + b\";\n        foreach (e; G[s.v]) {\n            if (X[s.v][e.to] == 0) continue;\n            if (!inQ[e.to]) {\n                assert(s.cost + e.cost == D[e.to]);\n                Qs.insert(S(e.to, D[e.to]));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] / x * X[s.v][e.to];\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.8f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0 && M == 0 && P == 0) return false;\n    G.destroy;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    struct S { int v, cost; }\n    auto D = dijkstra;\n    BinaryHeap!(Array!S, \"a.cost < b.cost\") Q;\n    Q.insert(S(N - 1, D[N - 1]));\n    auto X = new int[][](N, N); X[N - 1][N - 1] = 1;\n    auto inQ = new bool[N];\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] == D[s.v] - e.cost) {\n                X[e.to][s.v] += X[s.v].reduce!\"a + b\";\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    Q.insert(S(e.to, D[e.to]));\n                }\n            }\n        }\n    }\n    //writeln(D);\n    //foreach (L; X) writeln(L);\n\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new real[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    inQ[] = false;\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        auto x = X[s.v].reduce!\"a + b\";\n        foreach (e; G[s.v]) {\n            if (X[s.v][e.to] == 0) continue;\n            if (!inQ[e.to]) {\n                assert(s.cost + e.cost == D[e.to]);\n                Qs.insert(S(e.to, D[e.to]));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] * X[s.v][e.to] / x;\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.12f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio;\nimport std.ascii;\nimport std.range;\nimport std.array;\nimport std.functional;\nimport std.algorithm;\nimport std.conv;\nimport std.container;\nimport std.math;\nimport std.numeric;\nimport std.string;\nimport std.c.string;\nimport std.random;\nimport std.regex;\nimport std.typecons;\n\nstruct Edge {\n    int from, to, cost;\n}\n\nconst INF = int.max / 4;\n\nint N, M, P;\nint[] C;\nEdge[][] G;\n\nbool input() {\n    scanf(\"%d %d %d\\n\", &N, &M, &P);\n    if (N == 0 && M == 0 && P == 0) return false;\n    G.destroy;\n    G = new Edge[][N];\n    foreach (i; 0 .. M) {\n        int a, b, cost;\n        scanf(\"%d %d %d\\n\", &a, &b, &cost);\n        G[a] ~= Edge(a, b, cost);\n        G[b] ~= Edge(b, a, cost);\n    }\n    C = new int[P];\n    foreach (i; 0 .. P) {\n        scanf(\"%d\\n\", &C[i]);\n    }\n    return true;\n}\n\nint[] dijkstra() {\n    struct S { int v, cost; }\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") PQ;\n    PQ.insert(S(0, 0));\n    auto D = new int[N]; D[] = INF; D[0] = 0;\n    while (!PQ.empty) {\n        auto s = PQ.front; PQ.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] <= s.cost + e.cost) continue;\n            D[e.to] = s.cost + e.cost;\n            PQ.insert(S(e.to, D[e.to]));\n        }\n    }\n    return D;\n}\n\nvoid solve() {\n    struct S { int v, cost; }\n    auto D = dijkstra;\n    BinaryHeap!(Array!S, \"a.cost < b.cost\") Q;\n    Q.insert(S(N - 1, D[N - 1]));\n    auto X = new int[][](N, N); X[N - 1][N - 1] = 1;\n    auto inQ = new bool[N];\n    inQ[N - 1] = true;\n    while (!Q.empty) {\n        auto s = Q.front; Q.removeFront;\n        foreach (e; G[s.v]) {\n            if (D[e.to] == D[s.v] - e.cost) {\n                X[e.to][s.v] += X[s.v].reduce!\"a + b\";\n                if (!inQ[e.to]) {\n                    inQ[e.to] = true;\n                    Q.insert(S(e.to, D[e.to]));\n                }\n            }\n        }\n    }\n    //writeln(D);\n    //foreach (L; X) writeln(L);\n\n    BinaryHeap!(Array!S, \"a.cost > b.cost\") Qs;\n    Qs.insert(S(0, 0));\n    auto Prob = new real[N]; Prob[] = 0.0;\n    Prob[0] = 1.0;\n    inQ[] = false;\n    inQ[0] = true;\n    while (!Qs.empty) {\n        auto s = Qs.front; Qs.removeFront;\n        auto x = X[s.v].reduce!\"a + b\";\n        foreach (e; G[s.v]) {\n            if (X[s.v][e.to] == 0) continue;\n            if (!inQ[e.to]) {\n                assert(s.cost + e.cost == D[e.to]);\n                Qs.insert(S(e.to, D[e.to]));\n                inQ[e.to] = true;\n            }\n            Prob[e.to] += Prob[s.v] * X[s.v][e.to] / x;\n        }\n    }\n\n    foreach (c; C) {\n        writefln(\"%.12f\", Prob[c]);\n    }\n    writeln;\n}\n\nvoid main() {\n    while (input) solve;\n}"
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    if children == 0:\n        print(0)\n        vertex,edge,children = (int(n) for n in input().split(' '))\n        if vertex == 0 and edge == 0 and children == 0:\n            break\n        else:\n            continue\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    destnum = 0\n    childnum = {}\n    while len(stack) > 0:\n        #print(stack,destination,root)\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        #?????????????????????\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        elif mindist.get(vertex-1) != None and stack[0][1] > mindist[vertex - 1]:\n            break\n            \n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif gr[0] == start and mindist.get(gr[0]) != None and weight == mindist[gr[0]]:\n                if gr[1] in child:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n                else:\n                    stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n            destnum += 1\n            for c in range(len(stack[0][2])):\n                if childnum.get(stack[0][2][c]) == None:\n                    childnum[stack[0][2][c]] = 1\n                else:\n                    childnum[stack[0][2][c]] += 1\n        stack.pop(0)\n    for c in child:\n        if c == 0:\n            print(1)\n        else:\n            if childnum.get(c) == None:\n                print(0)\n            else:\n                print(childnum[c] / destnum)"
  },
  {
    "language": "Python",
    "code": "while 1:\n  n,m,p=map(int,input().split())\n  if (n,m,p)==(0,0,0): break\n  es=[]\n  for i in range(m):\n    u,v,w=map(int,input().split())\n    es.extend([(u,v,w),(v,u,w)])\n  \n  d=[[float(\"inf\")]*n for _ in range(n)]\n  for i in range(n): d[i][i]=0\n  for e in es: d[e[0]][e[1]]=e[2]\n  for k in range(n):\n    d=[[min(d[i][j],d[i][k]+d[k][j]) for j in range(n)] for i in range(n)]\n  \n  dp=[[0]*n for _ in range(n)]\n  for e in es:\n    if d[0][e[0]]+e[2]+d[e[1]][-1]==d[0][-1]:\n      dp[e[0]][e[1]]=1\n  for k in range(n):\n    dp=[[dp[i][j]+dp[i][k]*dp[k][j] for j in range(n)] for i in range(n)]\n  \n  for _ in range(p):\n    c=int(input())\n    print(dp[0][c]*dp[c][-1]/dp[0][-1])"
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    destnum = 0\n    childnum = {}\n    while len(stack) > 0:\n        #print(stack,destination,root)\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        #?????????????????????\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    if mindist.get(gr[0]) == None:\n                        childnum[gr[1]] = 1\n                    else:\n                        childnum[gr[1]] += 1\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif mindist.get(gr[0]) != None:\n                if weight + gr[2] == mindist[gr[0]]:\n                    if gr[1] in child:\n                        if mindist.get(gr[0]) == None:\n                            childnum[gr[1]] = 1\n                        else:\n                            childnum[gr[1]] += 1\n                        disp = dream.copy()\n                        disp.append(gr[1])\n                        stack.append([gr[1],weight + gr[2],disp])\n                    else:\n                        stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n            destnum += 1\n        stack.pop(0)\n    for c in child:\n        if c == 0:\n            print(1)\n        else:\n            print(childnum[c] / destnum)\n    vertex,edge,children = (int(n) for n in input().split(' '))\n    if vertex == 0 and edge == 0 and children == 0:\n        break\n            "
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    destnum = 0\n    childnum = {}\n    while len(stack) > 0:\n        #print(stack,destination,root)\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        #?????????????????????\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        elif mindist.get(vertex-1) != None and stack[0][1] > mindist[vertex - 1]:\n            break\n            \n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif gr[0] == start and mindist.get(gr[0]) != None and weight == mindist[gr[0]]:\n                if gr[1] in child:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n                else:\n                    stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n            destnum += 1\n            for c in range(len(stack[0][2])):\n                if childnum.get(stack[0][2][c]) == None:\n                    childnum[stack[0][2][c]] = 1\n                else:\n                    childnum[stack[0][2][c]] += 1\n        stack.pop(0)\n    for c in child:\n        if c == 0:\n            print(1)\n        else:\n            if childnum[c] == 0:\n                print(0)\n            else:\n                print(childnum[c] / destnum)\n    vertex,edge,children = (int(n) for n in input().split(' '))\n    if vertex == 0 and edge == 0 and children == 0:\n        break"
  },
  {
    "language": "Python",
    "code": "print(a)"
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    if children == 0:\n        print(0)\n        vertex,edge,children = (int(n) for n in input().split(' '))\n        if vertex == 0 and edge == 0 and children == 0:\n            break\n        else:\n            continue\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    destnum = 0\n    childnum = {}\n    while len(stack) > 0:\n        #print(stack,destination,root)\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        #?????????????????????\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        elif mindist.get(vertex-1) != None and stack[0][1] > mindist[vertex - 1]:\n            break\n            \n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif gr[0] == start and mindist.get(gr[0]) != None and weight == mindist[gr[0]]:\n                if gr[1] in child:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n                else:\n                    stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n            destnum += 1\n            for c in range(len(stack[0][2])):\n                if childnum.get(stack[0][2][c]) == None:\n                    childnum[stack[0][2][c]] = 1\n                else:\n                    childnum[stack[0][2][c]] += 1\n        stack.pop(0)\n    for c in child:\n        if c == 0:\n            print(1)\n        else:\n            if childnum[c] == 0:\n                print(0)\n            else:\n                print(childnum[c] / destnum)\n    vertex,edge,children = (int(n) for n in input().split(' '))\n    if vertex == 0 and edge == 0 and children == 0:\n        break"
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    destnum = 0\n    childnum = {}\n    while len(stack) > 0:\n        #print(stack,destination,root)\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        #?????????????????????\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        elif mindist.get(vertex-1) != None and stack[0][1] > mindist[vertex - 1]:\n            break\n            \n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif gr[0] == start and mindist.get(gr[0]) != None and weight == mindist[gr[0]]:\n                if gr[1] in child:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n                else:\n                    stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n            destnum += 1\n            for c in range(len(stack[0][2])):\n                if childnum.get(stack[0][2][c]) == None:\n                    childnum[stack[0][2][c]] = 1\n                else:\n                    childnum[stack[0][2][c]] += 1\n        stack.pop(0)\n    for c in child:\n        if c == 0:\n            print(1)\n        else:\n            if childnum[c] == 0:\n                print(0)\n            else:\n                print(childnum[c] / destnum)\n    vertex,edge,children = (int(n) for n in input().split(' '))\n    if vertex == 0 and edge == 0 and children == 0:\n        break"
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    while len(stack) > 0:\n        #print(stack,destination,root)\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        #?????????????????????\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif mindist.get(gr[0]) != None:\n                if weight + gr[2] == mindist[gr[0]]:\n                    if gr[1] in child:\n                        disp = dream.copy()\n                        disp.append(gr[1])\n                        stack.append([gr[1],weight + gr[2],disp])\n                    else:\n                        stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n        stack.pop(0)\n    for c in child:\n        childnum = 0\n        for dis in destination:\n            if c in dis[2]:\n                childnum += 1\n        print(childnum / len(destination))\n    vertex,edge,children = (int(n) for n in input().split(' '))\n    if vertex == 0 and edge == 0 and children == 0:\n        break\n            "
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    if children == 0:\n        print(0)\n        vertex,edge,children = (int(n) for n in input().split(' '))\n        if vertex == 0 and edge == 0 and children == 0:\n            break\n        else:\n            continue\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    destnum = 0\n    childnum = {}\n    while len(stack) > 0:\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        elif mindist.get(vertex-1) != None and stack[0][1] > mindist[vertex - 1]:\n            break\n            \n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif gr[0] == start and mindist.get(gr[0]) != None and weight == mindist[gr[0]]:\n                if gr[1] in child:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n                else:\n                    stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n            destnum += 1\n            for c in range(len(stack[0][2])):\n                if childnum.get(stack[0][2][c]) == None:\n                    childnum[stack[0][2][c]] = 1\n                else:\n                    childnum[stack[0][2][c]] += 1\n        stack.pop(0)\n    for c in child:\n        if c == 0:\n            print(1)\n        else:\n            if childnum.get(c) == None:\n                print(0)\n            else:\n                print(childnum[c] / destnum)\n    print(\"\")\n    vertex,edge,children = (int(n) for n in input().split(' '))\n    if vertex == 0 and edge == 0 and children == 0:\n        break"
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\ngraph = []\nchild = []\nfor e in range(edge):\n    graph.append([int(n) for n in input().split(' ')])\nfor c in range(children):\n    child.append(int(input()))\nprint(1)"
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    while len(stack) > 0:\n        #print(stack,destination,root)\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        #?????????????????????\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif mindist.get(gr[0]) != None:\n                if weight + gr[1] == mindist[gr[0]]:\n                    if gr[1] in child and dream != 1:\n                        stack.append([gr[1],weight + gr[2],gr[1]])\n                    else:\n                        stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n        stack.pop(0)\n    for c in child:\n        childnum = 0\n        for dis in destination:\n            if c in dis[2]:\n                childnum += 1\n        print(childnum / len(destination))\n    vertex,edge,children = (int(n) for n in input().split(' '))\n    if vertex == 0 and edge == 0 and children == 0:\n        break\n            "
  },
  {
    "language": "Python",
    "code": "vertex,edge,children = (int(n) for n in input().split(' '))\nwhile True:\n    if children == 0:\n        print(0)\n        vertex,edge,children = (int(n) for n in input().split(' '))\n        if vertex == 0 and edge == 0 and children == 0:\n            break\n        else:\n            continue\n    graph = []\n    child = []\n    for e in range(edge):\n        graph.append([int(n) for n in input().split(' ')])\n    for c in range(children):\n        child.append(int(input()))\n    stack = [[0,0,[]]]\n    root = []\n    destination = []\n    mindist = {}\n    destnum = 0\n    childnum = {}\n    while len(stack) > 0:\n        stack = sorted(stack,key = lambda x:x[1])\n        start,weight,dream = stack[0][0],stack[0][1],stack[0][2]\n        if stack[0][0] in root and weight > mindist[stack[0][0]]:\n            stack.pop(0)\n            continue\n        elif mindist.get(vertex-1) != None and stack[0][1] > mindist[vertex - 1]:\n            break\n            \n        for gr in graph:\n            if gr[0] == start and gr[0] not in root:\n                if gr[1] not in child:\n                    stack.append([gr[1],weight + gr[2],dream])\n                elif gr[1] in child and gr[1] not in dream:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n            elif gr[0] == start and mindist.get(gr[0]) != None and weight == mindist[gr[0]]:\n                if gr[1] in child:\n                    disp = dream.copy()\n                    disp.append(gr[1])\n                    stack.append([gr[1],weight + gr[2],disp])\n                else:\n                    stack.append([gr[1],weight + gr[2],dream])\n\n        if stack[0][0] not in root:\n            root.append(stack[0][0])\n            mindist[stack[0][0]] = stack[0][1]\n        if stack[0][0] == vertex - 1 :\n            destination.append(stack[0])\n            destnum += 1\n            for c in range(len(stack[0][2])):\n                if childnum.get(stack[0][2][c]) == None:\n                    childnum[stack[0][2][c]] = 1\n                else:\n                    childnum[stack[0][2][c]] += 1\n        stack.pop(0)\n    for c in child:\n        if c == 0:\n            print(1)\n        else:\n            if childnum.get(c) == None:\n                print(0)\n            else:\n                print(childnum[c] / destnum)\n    print(\"\")\n    vertex,edge,children = (int(n) for n in input().split(' '))\n    if vertex == 0 and edge == 0 and children == 0:\n        break"
  },
  {
    "language": "Python",
    "code": "INF=int(1e9)\n\nwhile 1:\n  n,m,p=map(int,input().split())\n  if (n,m,p)==(0,0,0): break\n  es=[]\n  for i in range(m):\n    u,v,w=map(int,input().split())\n    es.extend([(u,v,w),(v,u,w)])\n  \n  d=[[INF]*n for _ in range(n)]\n  for i in range(n): d[i][i]=0\n  for e in es: d[e[0]][e[1]]=e[2]\n  for k in range(n):\n    for i in range(n):\n      for j in range(n):\n        d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n  \n  dp=[[0]*n for _ in range(n)]\n  for e in es:\n    if d[0][e[0]]+e[2]+d[e[1]][-1]==d[0][-1]:\n      dp[e[0]][e[1]]=1\n  for k in range(n):\n    for i in range(n):\n      for j in range(n):\n        dp[i][j]+=dp[i][k]*dp[k][j];\n  \n  for _ in range(p):\n    c=int(input())\n    print(\"{:.9f}\".format(dp[0][c]*dp[c][-1]/dp[0][-1]))"
  },
  {
    "language": "Python",
    "code": "from heapq import heappush, heappop\nINF = 10 ** 20\nwhile True:\n  n, m, p = map(int, input().split())\n  if n == 0:\n    break\n  edges = [[] for _ in range(n)]\n  for _ in range(m):\n    x, y, w = map(int, input().split())\n    edges[x].append((y, w))\n    edges[y].append((x, w))\n  que = []\n  heappush(que, (0, 0))\n  shortest_counter = [[0] * n for _ in range(n)]\n  shortest_counter[0][0] = 1\n  dist = [INF] * n\n  dist[0] = 0\n  path_counter = [0] * n\n  path_counter[0] = 1\n  while que:\n    total, node = heappop(que)\n    count = shortest_counter[node]\n    for to, w in edges[node]:\n      new_total = total + w\n      new_count = [i for i in count]\n      new_count[to] += path_counter[node]\n      if dist[to] > new_total:\n        dist[to] = new_total\n        shortest_counter[to] = [i for i in new_count]\n        path_counter[to] = path_counter[node]\n        heappush(que, (new_total, to))\n      elif dist[to] == new_total:\n        shortest_counter[to] = [i + j for i, j in zip(shortest_counter[to], new_count)]\n        path_counter[to] += path_counter[node]\n  for _ in range(p):\n    print(shortest_counter[n - 1][int(input())] / path_counter[n - 1])\n  print()\n \n"
  },
  {
    "language": "Python",
    "code": "# AOJ 1058 Winter Bells\n# Python3 2018.7.7 bal4u\n\nimport heapq\nINF = 0x7fffffff\n\ndef dijkstra(V, to, start):\n\tdist, path = [INF]*V, [0]*V\n\tQ = []\n\tdist[start], path[start] = 0, 1\n\theapq.heappush(Q, (0, start))\n\twhile Q:\n\t\tt, s = heapq.heappop(Q)\n\t\tif dist[s] < t: continue\n\t\tfor e, cost in to[s]:\n\t\t\tnt = t + cost\n\t\t\tif dist[e] < nt: continue\n\t\t\tif dist[e] > nt:\n\t\t\t\tpath[e] = 0\n\t\t\t\tdist[e] = nt\n\t\t\t\theapq.heappush(Q, (nt, e))\n\t\t\tpath[e] += path[s]\n\treturn [dist, path]\n\t\nwhile True:\n\tn, m, p = map(int, input().split())\n\tif n == 0: break\n\tto = [[] for i in range(n)]\n\tfor i in range(m):\n\t\ta, b, c = map(int, input().split())\n\t\tto[a].append((b, c))\n\t\tto[b].append((a, c))\n\tdist1, path1 = dijkstra(n, to, 0)\n\tdist2, path2 = dijkstra(n, to, n-1)\n\tfor i in range(p):\n\t\tc = int(input())\n\t\tif dist1[c]+dist2[c] == dist2[0]:\n\t\t\tprint((path1[c]*path2[c])/path2[0])\n\t\telse: print(0)\n\tprint()\n"
  }
]