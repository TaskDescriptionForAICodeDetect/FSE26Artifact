[
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <math.h>\n\n#define EPS 1e-9\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross_product(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nbool on_segment(Point p, Point q, Point r) {\n    return (fabs(cross_product(p, q, r)) < EPS) &&\n           (q.x >= fmin(p.x, r.x) && q.x <= fmax(p.x, r.x)) &&\n           (q.y >= fmin(p.y, r.y) && q.y <= fmax(p.y, r.y));\n}\n\nint point_in_polygon(Point* polygon, int n, Point p) {\n    bool inside = false;\n    for (int i = 0; i < n; i++) {\n        Point curr = polygon[i];\n        Point next = polygon[(i + 1) % n];\n        \n        if (on_segment(curr, p, next)) return 1;\n        \n        if (((curr.y > p.y) != (next.y > p.y)) &&\n            (p.x < (next.x - curr.x) * (p.y - curr.y) / (next.y - curr.y) + curr.x)) {\n            inside = !inside;\n        }\n    }\n    \n    return inside ? 2 : 0;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d\", &n);\n    Point* polygon = malloc(n * sizeof(Point));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &polygon[i].x, &polygon[i].y);\n    }\n    \n    scanf(\"%d\", &m);\n    \n    for (int i = 0; i < m; i++) {\n        Point target;\n        scanf(\"%lf %lf\", &target.x, &target.y);\n        printf(\"%d\\n\", point_in_polygon(polygon, n, target));\n    }\n    \n    free(polygon);\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:29"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdbool.h>\n\ntypedef struct {\n    double x, y;\n} Point;\n\ndouble cross(Point a, Point b, Point c) {\n    return (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n}\n\nbool onSegment(Point p, Point q, Point r) {\n    if (q.x <= fmax(p.x, r.x) && q.x >= fmin(p.x, r.x) &&\n        q.y <= fmax(p.y, r.y) && q.y >= fmin(p.y, r.y)) {\n        double cross_val = cross(p, q, r);\n        return cross_val == 0;\n    }\n    return false;\n}\n\nint orientation(Point p, Point q, Point r) {\n    double val = cross(p, q, r);\n    if (val == 0) return 0;\n    return (val > 0) ? 1 : 2;\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4) return true;\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n    return false;\n}\n\nint isInside(Point polygon[], int n, Point p) {\n    if (n < 3) return 0;\n\n    for (int i = 0; i < n; i++) {\n        int next = (i + 1) % n;\n        if (onSegment(polygon[i], p, polygon[next])) {\n            return 1;\n        }\n    }\n\n    Point extreme = {1e9, p.y};\n    int count = 0, i = 0;\n    do {\n        int next = (i + 1) % n;\n        if (doIntersect(polygon[i], polygon[next], p, extreme)) {\n            if (orientation(polygon[i], p, polygon[next]) == 0)\n                return onSegment(polygon[i], p, polygon[next]) ? 1 : 0;\n            count++;\n        }\n        i = next;\n    } while (i != 0);\n\n    return (count % 2 == 1) ? 2 : 0;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d\", &n);\n    Point polygon[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%lf %lf\", &polygon[i].x, &polygon[i].y);\n    }\n    scanf(\"%d\", &m);\n    while (m--) {\n        Point p;\n        scanf(\"%lf %lf\", &p.x, &p.y);\n        int res = isInside(polygon, n, p);\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}",
    "timestamp": "2025-08-05 22:14:58"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Point {\n    int x, y;\n    Point(int x = 0, int y = 0) : x(x), y(y) {}\n};\n\nint cross(const Point &O, const Point &A, const Point &B) {\n    return (A.x - O.x) * (B.y - O.y) - (A.y - O.y) * (B.x - O.x);\n}\n\nbool onSegment(const Point &p, const Point &q, const Point &r) {\n    if (q.x <= max(p.x, r.x) && q.x >= min(p.x, r.x) &&\n        q.y <= max(p.y, r.y) && q.y >= min(p.y, r.y)) {\n        return cross(p, q, r) == 0;\n    }\n    return false;\n}\n\nbool isInsidePolygon(const vector<Point> &polygon, const Point &p) {\n    int n = polygon.size();\n    if (n < 3) return false;\n\n    bool onEdge = false;\n    for (int i = 0; i < n; ++i) {\n        Point p1 = polygon[i];\n        Point p2 = polygon[(i + 1) % n];\n        if (onSegment(p1, p, p2)) {\n            onEdge = true;\n            break;\n        }\n    }\n    if (onEdge) return true;\n\n    int cnt = 0;\n    for (int i = 0, j = n - 1; i < n; j = i++) {\n        Point p1 = polygon[i];\n        Point p2 = polygon[j];\n        if (((p1.y > p.y) != (p2.y > p.y)) &&\n            (p.x < (p2.x - p1.x) * (p.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n            cnt++;\n        }\n    }\n    return cnt % 2 == 1;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<Point> polygon(n);\n    for (int i = 0; i < n; ++i) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n\n    Point t;\n    cin >> t.x >> t.y;\n\n    bool onEdge = false;\n    for (int i = 0; i < n; ++i) {\n        Point p1 = polygon[i];\n        Point p2 = polygon[(i + 1) % n];\n        if (onSegment(p1, t, p2)) {\n            onEdge = true;\n            break;\n        }\n    }\n\n    if (onEdge) {\n        cout << \"1\" << endl;\n    } else if (isInsidePolygon(polygon, t)) {\n        cout << \"2\" << endl;\n    } else {\n        cout << \"0\" << endl;\n    }\n\n    return 0;\n}",
    "timestamp": "2025-08-05 22:15:32"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.awt.geom.Point2D;\nimport java.util.List;\nimport java.util.ArrayList;\n\npublic class PolygonPointLocation {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        List<Point> polygon = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            double x = scanner.nextDouble();\n            double y = scanner.nextDouble();\n            polygon.add(new Point(x, y));\n        }\n        double tx = scanner.nextDouble();\n        double ty = scanner.nextDouble();\n        Point target = new Point(tx, ty);\n\n        int result = 0;\n        if (isOnSegment(polygon, target)) {\n            result = 1;\n        } else if (isInside(polygon, target)) {\n            result = 2;\n        }\n        System.out.println(result);\n    }\n\n    private static boolean isOnSegment(List<Point> polygon, Point target) {\n        int n = polygon.size();\n        for (int i = 0; i < n; i++) {\n            Point p1 = polygon.get(i);\n            Point p2 = polygon.get((i + 1) % n);\n            if (isPointOnLineSegment(p1, p2, target)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean isPointOnLineSegment(Point p1, Point p2, Point target) {\n        double cross = (target.x - p1.x) * (p2.y - p1.y) - (target.y - p1.y) * (p2.x - p1.x);\n        if (Math.abs(cross) > 1e-9) {\n            return false;\n        }\n        double minX = Math.min(p1.x, p2.x);\n        double maxX = Math.max(p1.x, p2.x);\n        double minY = Math.min(p1.y, p2.y);\n        double maxY = Math.max(p1.y, p2.y);\n        return target.x >= minX - 1e-9 && target.x <= maxX + 1e-9 &&\n               target.y >= minY - 1e-9 && target.y <= maxY + 1e-9;\n    }\n\n    private static boolean isInside(List<Point> polygon, Point target) {\n        int n = polygon.size();\n        boolean inside = false;\n        for (int i = 0, j = n - 1; i < n; j = i++) {\n            Point p1 = polygon.get(i);\n            Point p2 = polygon.get(j);\n            if (((p1.y > target.y) != (p2.y > target.y)) &&\n                (target.x < (p2.x - p1.x) * (target.y - p1.y) / (p2.y - p1.y) + p1.x)) {\n                inside = !inside;\n            }\n        }\n        return inside;\n    }\n}",
    "timestamp": "2025-08-05 22:16:27"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class PolygonPointLocation {\n    static class Point {\n        double x, y;\n        Point(double x, double y) {\n            this.x = x;\n            this.y = y;\n        }\n    }\n\n    static int pointLocation(Point[] polygon, Point target) {\n        int n = polygon.length;\n        boolean inside = false;\n        \n        for (int i = 0; i < n; i++) {\n            Point a = polygon[i];\n            Point b = polygon[(i + 1) % n];\n            \n            // Check if point is on a segment\n            if (onSegment(a, b, target)) {\n                return 1;\n            }\n            \n            // Ray casting algorithm\n            if (((a.y > target.y) != (b.y > target.y)) &&\n                (target.x < (b.x - a.x) * (target.y - a.y) / (b.y - a.y) + a.x)) {\n                inside = !inside;\n            }\n        }\n        \n        return inside ? 2 : 0;\n    }\n    \n    static boolean onSegment(Point a, Point b, Point p) {\n        return Math.abs((b.x - a.x) * (p.y - a.y) - (p.x - a.x) * (b.y - a.y)) < 1e-9 &&\n               p.x >= Math.min(a.x, b.x) && p.x <= Math.max(a.x, b.x) &&\n               p.y >= Math.min(a.y, b.y) && p.y <= Math.max(a.y, b.y);\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        \n        // Read polygon points\n        int n = sc.nextInt();\n        Point[] polygon = new Point[n];\n        for (int i = 0; i < n; i++) {\n            polygon[i] = new Point(sc.nextDouble(), sc.nextDouble());\n        }\n        \n        // Read target points\n        int m = sc.nextInt();\n        for (int i = 0; i < m; i++) {\n            Point target = new Point(sc.nextDouble(), sc.nextDouble());\n            System.out.println(pointLocation(polygon, target));\n        }\n        \n        sc.close();\n    }\n}",
    "timestamp": "2025-08-05 22:16:35"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cmath>\n#include <algorithm>\n\nusing namespace std;\n\nconst double EPS = 1e-9;\n\nstruct Point {\n    double x, y;\n    Point(double x = 0, double y = 0) : x(x), y(y) {}\n    \n    Point operator-(const Point& p) const {\n        return Point(x - p.x, y - p.y);\n    }\n};\n\ndouble cross(const Point& a, const Point& b) {\n    return a.x * b.y - a.y * b.x;\n}\n\nbool onSegment(const Point& p, const Point& a, const Point& b) {\n    return abs(cross(b - a, p - a)) < EPS &&\n           min(a.x, b.x) - EPS <= p.x && p.x <= max(a.x, b.x) + EPS &&\n           min(a.y, b.y) - EPS <= p.y && p.y <= max(a.y, b.y) + EPS;\n}\n\nbool intersect(const Point& p1, const Point& p2, const Point& p3, const Point& p4) {\n    double c1 = cross(p2 - p1, p3 - p1);\n    double c2 = cross(p2 - p1, p4 - p1);\n    double c3 = cross(p4 - p3, p1 - p3);\n    double c4 = cross(p4 - p3, p2 - p3);\n    \n    if (abs(c1) < EPS && onSegment(p3, p1, p2)) return true;\n    if (abs(c2) < EPS && onSegment(p4, p1, p2)) return true;\n    if (abs(c3) < EPS && onSegment(p1, p3, p4)) return true;\n    if (abs(c4) < EPS && onSegment(p2, p3, p4)) return true;\n    \n    return (c1 * c2 < 0) && (c3 * c4 < 0);\n}\n\nint pointInPolygon(const vector<Point>& polygon, const Point& point) {\n    int n = polygon.size();\n    bool inside = false;\n    \n    for (int i = 0; i < n; i++) {\n        Point a = polygon[i];\n        Point b = polygon[(i + 1) % n];\n        \n        if (onSegment(point, a, b)) return 1;\n        \n        if (((a.y > point.y) != (b.y > point.y)) &&\n            (point.x < (b.x - a.x) * (point.y - a.y) / (b.y - a.y) + a.x)) {\n            inside = !inside;\n        }\n    }\n    \n    return inside ? 2 : 0;\n}\n\nint main() {\n    int n, m;\n    cin >> n >> m;\n    \n    vector<Point> polygon(n);\n    for (int i = 0; i < n; i++) {\n        cin >> polygon[i].x >> polygon[i].y;\n    }\n    \n    for (int i = 0; i < m; i++) {\n        Point point;\n        cin >> point.x >> point.y;\n        cout << pointInPolygon(polygon, point) << endl;\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 22:16:46"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def is_point_on_segment(p, q, r):\n    if (q[0] <= max(p[0], r[0]) and q[0] >= min(p[0], r[0]) and\n        q[1] <= max(p[1], r[1]) and q[1] >= min(p[1], r[1])):\n        return True\n    return False\n\ndef orientation(p, q, r):\n    val = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n    if val == 0: \n        return 0\n    elif val > 0:\n        return 1\n    else:\n        return 2\n\ndef do_intersect(p1, q1, p2, q2):\n    o1 = orientation(p1, q1, p2)\n    o2 = orientation(p1, q1, q2)\n    o3 = orientation(p2, q2, p1)\n    o4 = orientation(p2, q2, q1)\n\n    if o1 != o2 and o3 != o4:\n        return True\n\n    if o1 == 0 and is_point_on_segment(p1, p2, q1):\n        return True\n\n    if o2 == 0 and is_point_on_segment(p1, q2, q1):\n        return True\n\n    if o3 == 0 and is_point_on_segment(p2, p1, q2):\n        return True\n\n    if o4 == 0 and is_point_on_segment(p2, q1, q2):\n        return True\n\n    return False\n\ndef is_point_in_polygon(points, t):\n    n = len(points)\n    if n < 3:\n        return 0\n\n    extreme = (float('inf'), t[1])\n    count = 0\n    i = 0\n\n    while True:\n        next_i = (i + 1) % n\n\n        if do_intersect(points[i], points[next_i], t, extreme):\n            if orientation(points[i], t, points[next_i]) == 0:\n                if is_point_on_segment(points[i], t, points[next_i]):\n                    return 1\n            count += 1\n\n        i = next_i\n\n        if i == 0:\n            break\n\n    return 2 if count % 2 == 1 else 0\n\n# Example usage:\ng = [(0, 0), (10, 0), (10, 10), (0, 10)]\nt = (5, 5)\nprint(is_point_in_polygon(g, t))",
    "timestamp": "2025-08-13 09:41:27"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.awt.geom.*;\nimport java.util.*;\n\npublic class PolygonContainment {\n\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        \n        int gSize = scanner.nextInt();\n        int[] gX = new int[gSize];\n        int[] gY = new int[gSize];\n        \n        for (int i = 0; i < gSize; i++) {\n            gX[i] = scanner.nextInt();\n            gY[i] = scanner.nextInt();\n        }\n        \n        int tX = scanner.nextInt();\n        int tY = scanner.nextInt();\n        \n        System.out.println(checkPointInPolygon(gX, gY, tX, tY));\n    }\n\n    private static int checkPointInPolygon(int[] gX, int[] gY, int tX, int tY) {\n        Point2D target = new Point2D.Double(tX, tY);\n        \n        if (PointOnPolygonEdge(gX, gY, target)) {\n            return 1;\n        }\n\n        Polygon polygon = new Polygon(gX, gY, gX.length);\n        if (polygon.contains(target)) {\n            return 2;\n        }\n\n        return 0;\n    }\n\n    private static boolean PointOnPolygonEdge(int[] gX, int[] gY, Point2D target) {\n        for (int i = 0; i < gX.length; i++) {\n            Point2D p1 = new Point2D.Double(gX[i], gY[i]);\n            Point2D p2 = new Point2D.Double(gX[(i + 1) % gX.length], gY[(i + 1) % gY.length]);\n            \n            if (pointOnSegment(p1, p2, target)) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static boolean pointOnSegment(Point2D p1, Point2D p2, Point2D target) {\n        double crossProduct = (target.getY() - p1.getY()) * (p2.getX() - p1.getX()) - (target.getX() - p1.getX()) * (p2.getY() - p1.getY());\n        if (Math.abs(crossProduct) > 1e-7) return false;\n\n        double dotProduct = (target.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (target.getY() - p1.getY()) * (p2.getY() - p1.getY());\n        if (dotProduct < 0) return false;\n\n        double squaredLengthBA = (p2.getX() - p1.getX()) * (p2.getX() - p1.getX()) + (p2.getY() - p1.getY()) * (p2.getY() - p1.getY());\n        if (dotProduct > squaredLengthBA) return false;\n\n        return true;\n    }\n}",
    "timestamp": "2025-08-13 09:41:38"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n\ntypedef struct {\n    int x, y;\n} Point;\n\n// Calculate cross product of vectors OA and OB\nint cross(Point O, Point A, Point B) {\n    int x1 = A.x - O.x, y1 = A.y - O.y;\n    int x2 = B.x - O.x, y2 = B.y - O.y;\n    return x1 * y2 - y1 * x2;\n}\n\n// Check if point P is on segment AB\nint onSegment(Point A, Point B, Point P) {\n    if (P.x >= fmin(A.x, B.x) && P.x <= fmax(A.x, B.x) &&\n        P.y >= fmin(A.y, B.y) && P.y <= fmax(A.y, B.y) &&\n        cross(A, B, P) == 0)\n        return 1;\n    return 0;\n}\n\n// Check if point P is strictly inside the polygon\nint insidePolygon(Point* g, int n, Point P) {\n    int count = 0;\n    Point extreme = {1000000, P.y};\n    Point last = g[n - 1];\n    \n    for (int i = 0; i < n; i++) {\n        Point current = g[i];\n        if (onSegment(last, current, P)) return 0;\n\n        int c1 = cross(last, current, P);\n        int c2 = cross(last, current, extreme);\n\n        if (c1 == 0 && c2 == 0 && onSegment(last, current, extreme)) return 0;\n\n        if (c1 != 0 && c2 != 0) {\n            int o1 = cross(last, P, extreme);\n            int o2 = cross(current, P, extreme);\n\n            if ((o1 != 0 && o2 != 0) && (o1 != o2) && (c1 != c2))\n                count++;\n        }\n        last = current;\n    }\n    \n    return count % 2 == 1 ? 2 : 0;\n}\n\nint main() {\n    int n, m;\n    scanf(\"%d\", &n);\n    Point g[n];\n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d\", &g[i].x, &g[i].y);\n    }\n    \n    scanf(\"%d\", &m);\n    Point t[m];\n    for (int i = 0; i < m; i++) {\n        scanf(\"%d %d\", &t[i].x, &t[i].y);\n    }\n    \n    for (int i = 0; i < m; i++) {\n        int result = insidePolygon(g, n, t[i]);\n        if (result == 0) {\n            for (int j = 0; j < n; j++) {\n                if (onSegment(g[j], g[(j + 1) % n], t[i])) {\n                    result = 1;\n                    break;\n                }\n            }\n        }\n        printf(\"%d\\n\", result);\n    }\n    \n    return 0;\n}",
    "timestamp": "2025-08-13 09:41:44"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def sign(x):\n    return 1 if x > 0 else -1 if x < 0 else 0\n\ndef cross_product(p1, p2, p3):\n    return (p2[0] - p1[0]) * (p3[1] - p1[1]) - (p2[1] - p1[1]) * (p3[0] - p1[0])\n\ndef on_segment(p1, p2, p):\n    return (min(p1[0], p2[0]) <= p[0] <= max(p1[0], p2[0]) and \n            min(p1[1], p2[1]) <= p[1] <= max(p1[1], p2[1]))\n\ndef is_intersect(p1, p2, p3, p4):\n    s1 = sign(cross_product(p1, p2, p3))\n    s2 = sign(cross_product(p1, p2, p4))\n    s3 = sign(cross_product(p3, p4, p1))\n    s4 = sign(cross_product(p3, p4, p2))\n    \n    if s1 == 0 and on_segment(p1, p2, p3):\n        return True\n    if s2 == 0 and on_segment(p1, p2, p4):\n        return True\n    if s3 == 0 and on_segment(p3, p4, p1):\n        return True\n    if s4 == 0 and on_segment(p3, p4, p2):\n        return True\n    \n    return s1 * s2 <= 0 and s3 * s4 <= 0\n\ndef point_in_polygon(polygon, point):\n    n = len(polygon)\n    count = 0\n    \n    for i in range(n):\n        p1 = polygon[i]\n        p2 = polygon[(i + 1) % n]\n        \n        if on_segment(p1, p2, point):\n            return 1\n        \n        if ((p1[1] > point[1]) != (p2[1] > point[1]) and \n            point[0] < (p2[0] - p1[0]) * (point[1] - p1[1]) / (p2[1] - p1[1]) + p1[0]):\n            count += 1\n    \n    return 2 if count % 2 == 1 else 0\n\ndef main():\n    # Read polygon points\n    n = int(input())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, input().split())\n        polygon.append((x, y))\n    \n    # Read target points\n    m = int(input())\n    for _ in range(m):\n        x, y = map(int, input().split())\n        point = (x, y)\n        print(point_in_polygon(polygon, point))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:42:20"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "import sys\n\ndef readints():\n    return list(map(int, sys.stdin.readline().split()))\n\ndef point_on_segment(a, b, c):\n    cross = (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0])\n    if abs(cross) != 0:\n        return False\n    min_x = min(a[0], b[0])\n    max_x = max(a[0], b[0])\n    min_y = min(a[1], b[1])\n    max_y = max(a[1], b[1])\n    return (c[0] >= min_x - 1e-12 and c[0] <= max_x + 1e-12 and\n            c[1] >= min_y - 1e-12 and c[1] <= max_y + 1e-12)\n\ndef is_point_in_polygon(polygon, point):\n    x, y = point\n    n = len(polygon)\n    inside = False\n    for i in range(n):\n        p1 = polygon[i]\n        p2 = polygon[(i + 1) % n]\n        if point_on_segment(p1, p2, point):\n            return 1\n        if ((p1[1] > y) != (p2[1] > y)):\n            x_intersect = (y - p1[1]) * (p2[0] - p1[0]) / (p2[1] - p1[1]) + p1[0]\n            if x <= x_intersect + 1e-12:\n                inside = not inside\n    return 2 if inside else 0\n\ndef main():\n    n = int(sys.stdin.readline())\n    polygon = []\n    for _ in range(n):\n        x, y = map(int, sys.stdin.readline().split())\n        polygon.append((x, y))\n    m = int(sys.stdin.readline())\n    for _ in range(m):\n        x, y = map(int, sys.stdin.readline().split())\n        print(is_point_in_polygon(polygon, (x, y)))\n\nif __name__ == \"__main__\":\n    main()",
    "timestamp": "2025-08-13 09:42:40"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n\nstruct Point {\n    int x, y;\n};\n\nint orientation(Point p, Point q, Point r) {\n    int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n    if (val == 0) return 0; // collinear\n    return (val > 0) ? 1 : 2; // clock or counter-clock wise\n}\n\nbool onSegment(Point p, Point q, Point r) {\n    if (q.x <= std::max(p.x, r.x) && q.x >= std::min(p.x, r.x) &&\n        q.y <= std::max(p.y, r.y) && q.y >= std::min(p.y, r.y))\n        return true;\n    return false;\n}\n\nbool doIntersect(Point p1, Point q1, Point p2, Point q2) {\n    int o1 = orientation(p1, q1, p2);\n    int o2 = orientation(p1, q1, q2);\n    int o3 = orientation(p2, q2, p1);\n    int o4 = orientation(p2, q2, q1);\n\n    if (o1 != o2 && o3 != o4)\n        return true;\n\n    if (o1 == 0 && onSegment(p1, p2, q1)) return true;\n    if (o2 == 0 && onSegment(p1, q2, q1)) return true;\n    if (o3 == 0 && onSegment(p2, p1, q2)) return true;\n    if (o4 == 0 && onSegment(p2, q1, q2)) return true;\n\n    return false;\n}\n\nbool isPointOnPolygon(Point point, const std::vector<Point>& polygon) {\n    int n = polygon.size();\n    for (int i = 0; i < n; i++) {\n        if (onSegment(polygon[i], point, polygon[(i + 1) % n])) {\n            return true;\n        }\n    }\n    return false;\n}\n\nbool isPointInsidePolygon(Point point, const std::vector<Point>& polygon) {\n    int n = polygon.size();\n    if (n < 3) return false; \n\n    Point extreme = {10000, point.y};\n\n    int count = 0, i = 0;\n    do {\n        int next = (i + 1) % n;\n\n        if (doIntersect(polygon[i], polygon[next], point, extreme)) {\n            if (orientation(polygon[i], point, polygon[next]) == 0)\n                return onSegment(polygon[i], point, polygon[next]);\n\n            count++;\n        }\n        i = next;\n    } while (i != 0);\n\n    return count & 1;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<Point> polygon(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> polygon[i].x >> polygon[i].y;\n    }\n    Point target;\n    std::cin >> target.x >> target.y;\n\n    if (isPointOnPolygon(target, polygon)) {\n        std::cout << \"1\\n\";\n    } else if (isPointInsidePolygon(target, polygon)) {\n        std::cout << \"2\\n\";\n    } else {\n        std::cout << \"0\\n\";\n    }\n    return 0;\n}",
    "timestamp": "2025-08-13 11:53:52"
  }
]