[
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int breakfast_start;\n    int breakfast_end;\n    int lunch_start;\n    int lunch_end;\n    int supper_start;\n    int supper_end;\n} Customer;\n\nint compare(const void *a, const void *b) {\n    Customer *c1 = (Customer *)a;\n    Customer *c2 = (Customer *)b;\n    if (c1->breakfast_end != c2->breakfast_end) {\n        return c1->breakfast_end - c2->breakfast_end;\n    } else if (c1->lunch_end != c2->lunch_end) {\n        return c1->lunch_end - c2->lunch_end;\n    } else {\n        return c1->supper_end - c2->supper_end;\n    }\n}\n\nint max_customers_served(Customer customers[], int n) {\n    if (n == 0) return 0;\n    \n    qsort(customers, n, sizeof(Customer), compare);\n    \n    int count = 1;\n    int last_breakfast = customers[0].breakfast_end;\n    int last_lunch = customers[0].lunch_end;\n    int last_supper = customers[0].supper_end;\n    \n    for (int i = 1; i < n; i++) {\n        if (customers[i].breakfast_start >= last_breakfast &&\n            customers[i].lunch_start >= last_lunch &&\n            customers[i].supper_start >= last_supper) {\n            count++;\n            last_breakfast = customers[i].breakfast_end;\n            last_lunch = customers[i].lunch_end;\n            last_supper = customers[i].supper_end;\n        }\n    }\n    \n    return count;\n}\n\nint main() {\n    int n;\n    scanf(\"%d\", &n);\n    Customer *customers = (Customer *)malloc(n * sizeof(Customer));\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d %d %d\", \n              &customers[i].breakfast_start, &customers[i].breakfast_end,\n              &customers[i].lunch_start, &customers[i].lunch_end,\n              &customers[i].supper_start, &customers[i].supper_end);\n    }\n    \n    printf(\"%d\\n\", max_customers_served(customers, n));\n    free(customers);\n    return 0;\n}",
    "timestamp": "2025-08-05 18:44:38"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\nclass Solution {\n    public int maxCustomersMeals(int[][] customers) {\n        Map<Integer, Integer> breakfastTimes = new HashMap<>();\n        Map<Integer, Integer> lunchTimes = new HashMap<>();\n        Map<Integer, Integer> supperTimes = new HashMap<>();\n\n        for (int[] customer : customers) {\n            breakfastTimes.put(customer[0], breakfastTimes.getOrDefault(customer[0], 0) + 1);\n            lunchTimes.put(customer[1], lunchTimes.getOrDefault(customer[1], 0) + 1);\n            supperTimes.put(customer[2], supperTimes.getOrDefault(customer[2], 0) + 1);\n        }\n\n        int maxCustomers = 0;\n        for (int breakfastZone : breakfastTimes.keySet()) {\n            for (int lunchZone : lunchTimes.keySet()) {\n                for (int supperZone : supperTimes.keySet()) {\n                    int currentCustomers = 0;\n                    for (int[] customer : customers) {\n                        if (customer[0] == breakfastZone && \n                            customer[1] == lunchZone && \n                            customer[2] == supperZone) {\n                            currentCustomers++;\n                        }\n                    }\n                    maxCustomers = Math.max(maxCustomers, currentCustomers);\n                }\n            }\n        }\n\n        return maxCustomers;\n    }\n}",
    "timestamp": "2025-08-05 18:44:43"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct TimeZone {\n    int breakfastStart, breakfastEnd;\n    int lunchStart, lunchEnd;\n    int supperStart, supperEnd;\n};\n\nbool canServe(const TimeZone &customer, int b, int l, int s) {\n    return (b >= customer.breakfastStart && b <= customer.breakfastEnd) &&\n           (l >= customer.lunchStart && l <= customer.lunchEnd) &&\n           (s >= customer.supperStart && s <= customer.supperEnd);\n}\n\nint maxCustomersServed(vector<TimeZone> &customers) {\n    vector<int> breakfastTimes, lunchTimes, supperTimes;\n    \n    for (const auto &customer : customers) {\n        breakfastTimes.push_back(customer.breakfastStart);\n        breakfastTimes.push_back(customer.breakfastEnd);\n        lunchTimes.push_back(customer.lunchStart);\n        lunchTimes.push_back(customer.lunchEnd);\n        supperTimes.push_back(customer.supperStart);\n        supperTimes.push_back(customer.supperEnd);\n    }\n    \n    sort(breakfastTimes.begin(), breakfastTimes.end());\n    sort(lunchTimes.begin(), lunchTimes.end());\n    sort(supperTimes.begin(), supperTimes.end());\n    \n    breakfastTimes.erase(unique(breakfastTimes.begin(), breakfastTimes.end()), breakfastTimes.end());\n    lunchTimes.erase(unique(lunchTimes.begin(), lunchTimes.end()), lunchTimes.end());\n    supperTimes.erase(unique(supperTimes.begin(), supperTimes.end()), supperTimes.end());\n    \n    int maxCustomers = 0;\n    \n    for (int b : breakfastTimes) {\n        for (int l : lunchTimes) {\n            for (int s : supperTimes) {\n                int count = 0;\n                for (const auto &customer : customers) {\n                    if (canServe(customer, b, l, s)) {\n                        count++;\n                    }\n                }\n                maxCustomers = max(maxCustomers, count);\n            }\n        }\n    }\n    \n    return maxCustomers;\n}\n\nint main() {\n    int N;\n    cin >> N;\n    vector<TimeZone> customers(N);\n    \n    for (int i = 0; i < N; ++i) {\n        cin >> customers[i].breakfastStart >> customers[i].breakfastEnd;\n        cin >> customers[i].lunchStart >> customers[i].lunchEnd;\n        cin >> customers[i].supperStart >> customers[i].supperEnd;\n    }\n    \n    cout << maxCustomersServed(customers) << endl;\n    return 0;\n}",
    "timestamp": "2025-08-05 18:45:04"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdbool.h>\n\n#define MAX_CUSTOMERS 100\n\ntypedef struct {\n    int breakfast_start;\n    int breakfast_end;\n    int lunch_start;\n    int lunch_end;\n    int supper_start;\n    int supper_end;\n} MealTimes;\n\nint max_served_customers(MealTimes customers[], int n) {\n    int max_served = 0;\n    \n    for (int breakfast_time = 0; breakfast_time <= 24; breakfast_time++) {\n        for (int lunch_time = 0; lunch_time <= 24; lunch_time++) {\n            for (int supper_time = 0; supper_time <= 24; supper_time++) {\n                int served_count = 0;\n                \n                for (int i = 0; i < n; i++) {\n                    bool breakfast_ok = (breakfast_time >= customers[i].breakfast_start && \n                                         breakfast_time <= customers[i].breakfast_end);\n                    bool lunch_ok = (lunch_time >= customers[i].lunch_start && \n                                     lunch_time <= customers[i].lunch_end);\n                    bool supper_ok = (supper_time >= customers[i].supper_start && \n                                      supper_time <= customers[i].supper_end);\n                    \n                    if (breakfast_ok && lunch_ok && supper_ok) {\n                        served_count++;\n                    }\n                }\n                \n                max_served = (served_count > max_served) ? served_count : max_served;\n            }\n        }\n    }\n    \n    return max_served;\n}\n\nint main() {\n    int n;\n    MealTimes customers[MAX_CUSTOMERS];\n    \n    scanf(\"%d\", &n);\n    \n    for (int i = 0; i < n; i++) {\n        scanf(\"%d %d %d %d %d %d\", \n              &customers[i].breakfast_start, &customers[i].breakfast_end,\n              &customers[i].lunch_start, &customers[i].lunch_end,\n              &customers[i].supper_start, &customers[i].supper_end);\n    }\n    \n    int result = max_served_customers(customers, n);\n    printf(\"%d\\n\", result);\n    \n    return 0;\n}",
    "timestamp": "2025-08-05 18:45:12"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint maxCustomersServed(vector<vector<int>>& customers) {\n    int n = customers.size();\n    if (n == 0) return 0;\n\n    // Sort customers based on breakfast times\n    sort(customers.begin(), customers.end(), [](const vector<int>& a, const vector<int>& b) {\n        return a[0] < b[0];\n    });\n\n    int maxServed = 0;\n    vector<int> dp(n, 1);\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (customers[j][1] <= customers[i][0] && \n                customers[j][2] <= customers[i][1]) {\n                dp[i] = max(dp[i], dp[j] + 1);\n            }\n        }\n        maxServed = max(maxServed, dp[i]);\n    }\n\n    return maxServed;\n}\n\nint main() {\n    int n;\n    cin >> n;\n    vector<vector<int>> customers(n, vector<int>(3));\n\n    for (int i = 0; i < n; i++) {\n        cin >> customers[i][0] >> customers[i][1] >> customers[i][2];\n    }\n\n    cout << maxCustomersServed(customers) << endl;\n\n    return 0;\n}",
    "timestamp": "2025-08-05 18:46:16"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "Java",
    "code": "import java.util.*;\n\npublic class RestaurantServingTime {\n    public static void main(String[] args) {\n        Scanner scanner = new Scanner(System.in);\n        int n = scanner.nextInt();\n        int[][] customers = new int[n][3];\n        \n        for (int i = 0; i < n; i++) {\n            customers[i][0] = scanner.nextInt();\n            customers[i][1] = scanner.nextInt();\n            customers[i][2] = scanner.nextInt();\n        }\n        \n        Arrays.sort(customers, (a, b) -> Integer.compare(a[1], b[1]));\n        \n        int maxCustomers = 0;\n        for (int i = 0; i < n; i++) {\n            int count = 1;\n            int lastEnd = customers[i][1];\n            for (int j = i + 1; j < n; j++) {\n                if (customers[j][0] >= lastEnd) {\n                    count++;\n                    lastEnd = customers[j][1];\n                }\n            }\n            if (count > maxCustomers) {\n                maxCustomers = count;\n            }\n        }\n        \n        System.out.println(maxCustomers);\n    }\n}",
    "timestamp": "2025-08-05 18:46:28"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_customers_for_meals(customers):\n    def overlap_time(time1, time2):\n        return max(time1[0], time2[0]) <= min(time1[1], time2[1])\n\n    def sort_time_by_end(time):\n        return time[1]\n\n    if not customers:\n        return 0\n\n    # Split the list of customers into three lists based on meal times\n    breakfast_times = [customer[0] for customer in customers]\n    lunch_times = [customer[1] for customer in customers]\n    supper_times = [customer[2] for customer in customers]\n    \n    # Sort each list by the end time of time zones\n    breakfast_times.sort(key=sort_time_by_end)\n    lunch_times.sort(key=sort_time_by_end)\n    supper_times.sort(key=sort_time_by_end)\n\n    count = 0\n    breakfast_pointer, lunch_pointer, supper_pointer = 0, 0, 0\n\n    # Iterate through each meal time zones ensuring overlap for all three meals\n    while breakfast_pointer < len(breakfast_times) and lunch_pointer < len(lunch_times) and supper_pointer < len(supper_times):\n        if overlap_time(breakfast_times[breakfast_pointer], lunch_times[lunch_pointer]) and overlap_time(lunch_times[lunch_pointer], supper_times[supper_pointer]):\n            count += 1\n            breakfast_pointer += 1\n            lunch_pointer += 1\n            supper_pointer += 1\n        else:\n            # Move the pointer with the earliest end time to find the next possible overlap\n            if breakfast_times[breakfast_pointer][1] <= lunch_times[lunch_pointer][1] and breakfast_times[breakfast_pointer][1] <= supper_times[supper_pointer][1]:\n                breakfast_pointer += 1\n            elif lunch_times[lunch_pointer][1] <= breakfast_times[breakfast_pointer][1] and lunch_times[lunch_pointer][1] <= supper_times[supper_pointer][1]:\n                lunch_pointer += 1\n            else:\n                supper_pointer += 1\n\n    return count\n\n# Example usage:\ncustomers = [\n    [(1, 4), (5, 8), (9, 12)],\n    [(2, 3), (5, 7), (6, 10)],\n    [(0, 5), (3, 8), (6, 11)],\n    [(2, 4), (6, 9), (10, 12)]\n]\n\nprint(max_customers_for_meals(customers))  # Example output for 2 customers",
    "timestamp": "2025-08-13 00:47:47"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "java",
    "code": "import java.util.*;\n\npublic class MealScheduler {\n    \n    static class CustomerTimeZone {\n        int breakfastStart, breakfastEnd;\n        int lunchStart, lunchEnd;\n        int supperStart, supperEnd;\n        \n        public CustomerTimeZone(int bs, int be, int ls, int le, int ss, int se) {\n            this.breakfastStart = bs;\n            this.breakfastEnd = be;\n            this.lunchStart = ls;\n            this.lunchEnd = le;\n            this.supperStart = ss;\n            this.supperEnd = se;\n        }\n    }\n\n    public static int maxCustomers(List<CustomerTimeZone> timeZones) {\n        Collections.sort(timeZones, Comparator.comparingInt(a -> a.breakfastEnd));\n        int maxCustomers = 0;\n\n        for (CustomerTimeZone bTimeZone : timeZones) {\n            List<CustomerTimeZone> lunchCandidates = new ArrayList<>();\n            for (CustomerTimeZone c : timeZones) {\n                if (c.breakfastStart <= bTimeZone.breakfastEnd) \n                    lunchCandidates.add(c);\n            }\n            \n            Collections.sort(lunchCandidates, Comparator.comparingInt(a -> a.lunchEnd));\n            for (CustomerTimeZone lTimeZone : lunchCandidates) {\n                List<CustomerTimeZone> supperCandidates = new ArrayList<>();\n                for (CustomerTimeZone c : lunchCandidates) {\n                    if (c.lunchStart <= lTimeZone.lunchEnd)\n                        supperCandidates.add(c);\n                }\n                \n                Collections.sort(supperCandidates, Comparator.comparingInt(a -> a.supperEnd));\n                for (CustomerTimeZone sTimeZone : supperCandidates) {\n                    if (sTimeZone.supperStart <= sTimeZone.supperEnd) {\n                        maxCustomers++;\n                        break;\n                    }\n                }\n            }\n        }\n        \n        return maxCustomers;\n    }\n    \n    public static void main(String[] args) {\n        List<CustomerTimeZone> timeZones = new ArrayList<>();\n        timeZones.add(new CustomerTimeZone(1, 3, 4, 6, 7, 8));\n        timeZones.add(new CustomerTimeZone(2, 3, 5, 6, 8, 9));\n        timeZones.add(new CustomerTimeZone(1, 2, 3, 5, 6, 8));\n        \n        System.out.println(\"Maximum customers served: \" + maxCustomers(timeZones));\n    }\n}",
    "timestamp": "2025-08-13 00:48:07"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int breakfast_start;\n    int breakfast_end;\n    int lunch_start;\n    int lunch_end;\n    int supper_start;\n    int supper_end;\n} Customer;\n\nint overlap(int start1, int end1, int start2, int end2) {\n    return (start1 <= end2 && end1 >= start2);\n}\n\nint max_customers(Customer* customers, int n) {\n    int dp[n];\n    for (int i = 0; i < n; i++)\n        dp[i] = 1;\n\n    for (int i = 1; i < n; i++) {\n        for (int j = 0; j < i; j++) {\n            if (overlap(customers[j].breakfast_start, customers[j].breakfast_end, \n                        customers[i].breakfast_start, customers[i].breakfast_end) && \n                overlap(customers[j].lunch_start, customers[j].lunch_end, \n                        customers[i].lunch_start, customers[i].lunch_end) && \n                overlap(customers[j].supper_start, customers[j].supper_end, \n                        customers[i].supper_start, customers[i].supper_end)) \n            {\n                dp[i] = dp[i] > (dp[j] + 1) ? dp[i] : (dp[j] + 1);\n            }\n        }\n    }\n\n    int max_customers = 0;\n    for (int i = 0; i < n; i++) {\n        if (dp[i] > max_customers)\n            max_customers = dp[i];\n    }\n\n    return max_customers;\n}\n\nint main() {\n    int n;\n    printf(\"Enter the number of customers: \");\n    scanf(\"%d\", &n);\n\n    Customer* customers = malloc(n * sizeof(Customer));\n    for (int i = 0; i < n; i++) {\n        printf(\"Enter the breakfast, lunch, and supper time zones for customer %d (start-end): \", i + 1);\n        scanf(\"%d %d %d %d %d %d\",\n              &customers[i].breakfast_start, &customers[i].breakfast_end,\n              &customers[i].lunch_start, &customers[i].lunch_end,\n              &customers[i].supper_start, &customers[i].supper_end);\n    }\n\n    int result = max_customers(customers, n);\n    printf(\"Maximum number of customers that can be served all three meals: %d\\n\", result);\n\n    free(customers);\n    return 0;\n}",
    "timestamp": "2025-08-13 00:48:17"
  },
  {
    "model": "claude-3-5-haiku-20241022",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_served_customers(meal_times):\n    # Convert times to minutes for easier comparison\n    def to_minutes(time_str):\n        hours, minutes = map(int, time_str.split(':'))\n        return hours * 60 + minutes\n\n    # Group customers by their meal times\n    breakfast = []\n    lunch = []\n    supper = []\n    \n    for customer in meal_times:\n        breakfast.append(to_minutes(customer[0]))\n        lunch.append(to_minutes(customer[1]))\n        supper.append(to_minutes(customer[2]))\n    \n    # Sort times for each meal\n    breakfast.sort()\n    lunch.sort()\n    supper.sort()\n    \n    # Two-pointer technique to find maximum overlap\n    max_served = 0\n    b = l = s = 0\n    \n    while b < len(breakfast) and l < len(lunch) and s < len(supper):\n        # Check if current times are within reasonable range (within 2 hours)\n        if (max(breakfast[b], lunch[l], supper[s]) - \n            min(breakfast[b], lunch[l], supper[s])) <= 120:\n            max_served += 1\n            b += 1\n            l += 1\n            s += 1\n        # Move the pointer of the minimum time\n        elif breakfast[b] <= lunch[l] and breakfast[b] <= supper[s]:\n            b += 1\n        elif lunch[l] <= breakfast[b] and lunch[l] <= supper[s]:\n            l += 1\n        else:\n            s += 1\n    \n    return max_served",
    "timestamp": "2025-08-13 00:48:27"
  },
  {
    "model": "deepseek-v3",
    "prompt_type": "zero_shot",
    "language": "python",
    "code": "def max_customers_served_all_meals(customers):\n    breakfast_starts = []\n    lunch_starts = []\n    supper_starts = []\n    breakfast_ends = []\n    lunch_ends = []\n    supper_ends = []\n    \n    for customer in customers:\n        b, l, s = customer\n        breakfast_starts.append(b[0])\n        breakfast_ends.append(b[1])\n        lunch_starts.append(l[0])\n        lunch_ends.append(l[1])\n        supper_starts.append(s[0])\n        supper_ends.append(s[1])\n    \n    max_breakfast_start = max(breakfast_starts)\n    min_breakfast_end = min(breakfast_ends)\n    \n    max_lunch_start = max(lunch_starts)\n    min_lunch_end = min(lunch_ends)\n    \n    max_supper_start = max(supper_starts)\n    min_supper_end = min(supper_ends)\n    \n    count = 0\n    for i in range(len(customers)):\n        b_start, b_end = customers[i][0]\n        l_start, l_end = customers[i][1]\n        s_start, s_end = customers[i][2]\n        \n        if (b_start <= max_breakfast_start and b_end >= min_breakfast_end and\n            l_start <= max_lunch_start and l_end >= min_lunch_end and\n            s_start <= max_supper_start and s_end >= min_supper_end):\n            count += 1\n    \n    return count",
    "timestamp": "2025-08-13 00:48:41"
  },
  {
    "model": "gpt-4o",
    "prompt_type": "zero_shot",
    "language": "c++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Customer {\n    int breakfastStart, breakfastEnd;\n    int lunchStart, lunchEnd;\n    int supperStart, supperEnd;\n};\n\nbool canServeAllThree(Customer &customer, int breakfastTime, int lunchTime, int supperTime) {\n    return customer.breakfastStart <= breakfastTime && customer.breakfastEnd >= breakfastTime &&\n           customer.lunchStart <= lunchTime && customer.lunchEnd >= lunchTime &&\n           customer.supperStart <= supperTime && customer.supperEnd >= supperTime;\n}\n\nint maxCustomers(std::vector<Customer> &customers) {\n    int maxServed = 0;\n    int n = customers.size();\n    \n    std::sort(customers.begin(), customers.end(), [](const Customer &a, const Customer &b) {\n        return a.breakfastStart < b.breakfastStart;\n    });\n\n    for (int breakfastTime = 0; breakfastTime <= 24; ++breakfastTime) {\n        for (int lunchTime = 0; lunchTime <= 24; ++lunchTime) {\n            for (int supperTime = 0; supperTime <= 24; ++supperTime) {\n                int served = 0;\n                for (int i = 0; i < n; ++i) {\n                    if (canServeAllThree(customers[i], breakfastTime, lunchTime, supperTime)) {\n                        served++;\n                    }\n                }\n                maxServed = std::max(maxServed, served);\n            }\n        }\n    }\n\n    return maxServed;\n}\n\nint main() {\n    int n;\n    std::cin >> n;\n    std::vector<Customer> customers(n);\n    for (int i = 0; i < n; ++i) {\n        std::cin >> customers[i].breakfastStart >> customers[i].breakfastEnd\n                 >> customers[i].lunchStart >> customers[i].lunchEnd\n                 >> customers[i].supperStart >> customers[i].supperEnd;\n    }\n\n    std::cout << maxCustomers(customers) << std::endl;\n    return 0;\n}",
    "timestamp": "2025-08-13 10:56:09"
  }
]