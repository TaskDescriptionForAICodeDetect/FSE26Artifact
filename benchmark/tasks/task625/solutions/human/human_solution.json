[
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef vector<ll> vl;\ntypedef pair<ll, ll> PP;\n#define rep(i, n) for(ll i = 0; i < ll(n); i++)\ntemplate <class T> void corner(bool flg, T hoge) {\n    if(flg) {\n        cout << hoge << endl;\n        exit(0);\n    }\n}\n#define all(v) v.begin(), v.end()\n#define inputv(v, n)                                                           \\\n    vl v;                                                                      \\\n    rep(i, n) {                                                                \\\n        ll x;                                                                  \\\n        cin >> x;                                                              \\\n        v.push_back(x);                                                        \\\n    }\nconst ll INF = 999999999999999;\nconst ll MOD = 1000000007;\nconst ll MAX_N = 500010;\nll a, b, c, d, e, f, p, t, x, y, z, q, m, n, r, h, k, w, l, ans;\nstruct edge {\n    ll to, cost;\n};\nvector<edge> G[MAX_N];\nvl visited;\nvl Euler_tour,Euler_tour_cost;\n\nvoid add(ll a, ll b, ll c = 1) { G[a].push_back((edge) { b, c }); }\n\nvoid resetv(void) { visited = vl(n, 0); }\n\nvl par(MAX_N, -1), toposo, ko(MAX_N, 0), cost(MAX_N, 0),L(MAX_N,-1),R(MAX_N,0);\n\nvoid dfs_tree(ll x, ll a){\n    visited[x] = 1;\n    for (edge i : G[x]) {\n        if (visited[i.to] == 0) {\n            Euler_tour.push_back(i.to);\n            Euler_tour_cost.push_back(i.cost);\n            dfs_tree(i.to, a + i.cost);\n            Euler_tour_cost.push_back(-i.cost);\n            Euler_tour.push_back(x);\n            par[i.to] = x;\n        }\n    }\n}\n\nvoid root(ll x) {\n    Euler_tour.push_back(x);\n    dfs_tree(x, 0);\n}\n\nstruct segtree {\n    ll N;\n    vl dat;\n    void init(ll n) {\n        N = 1;\n        while (N < n) N *= 2;\n        dat = vl(N * 2 + 1);\n        for (ll i = 0; i < 2 * N - 1; i++)\n            dat[i] = 0;\n    }\n    // update k th element\n    void add(ll k, ll a) {\n        k += N - 1; // leaf\n        dat[k] += a;\n        while (k > 0) {\n            k = (k - 1) / 2;\n            dat[k] = dat[k * 2 + 1] + dat[k * 2 + 2];\n        }\n    }\n    // sum of [a, b)\n    ll query(ll a, ll b) { return query(a, b, 0, 0, N); }\n    ll query(ll a, ll b, ll k, ll l, ll r) {\n        if (r <= a or b <= l) return 0;\n        if (a <= l and r <= b) return dat[k];\n        ll m = (l + r) / 2;\n        return (query(a, b, k * 2 + 1, l, m) + query(a, b, k * 2 + 2, m, r));\n    }\n};\n\nint main() {\n    cin >> n;\n    rep(i, n) {\n        cin >> x;\n        rep(j, x) {\n            cin >> a;\n            add(a, i, 0);\n            add(i, a, 0);\n        }\n    }\n\n    resetv();\n    root(0);\n\n   rep(i,Euler_tour.size()) {\n       a = Euler_tour[i];\n       if (L[a] == -1)L[a] = i;\n       R[a] = i;\n    }\n\n   segtree SEG;\n   SEG.init(n * 2);\n\n   rep(i, Euler_tour_cost.size()) {\n       SEG.add(i, Euler_tour_cost[i]);\n   }\n\n   cin >> q;\n   rep(i, q) {\n       cin >> a;\n       if (a == 0) {\n           cin >> x >> y;\n           SEG.add(L[x] - 1, y);\n           SEG.add(R[x], -y);\n       }\n       else {\n           cin >> x;\n           cout << SEG.query(0, R[x])<<endl;\n       }\n   }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n\nusing namespace std;\nconst int INIVAL = 0;\n\nstruct WRTree{ // Weighted Rooted Tree\n    vector<vector<int>> adj; // adjacent list\n    vector<int> listOfNode; // list of nodes in order of appearance with depth-first search\n    vector<int> left; // save the position of a node in the vector listOfNode\n    vector<int> right; // save the position of the right-most child of a node in the vector listOfNode\n    //\n    WRTree(int n); // constructor function\n    void addEdge(int u, int v); // node v is a children node of node u\n    void dfs(int node); // DFS: update vectors \"listOfNode\", \"left\" and \"right\"\n    void print();\n};\n\nstruct SegmentTree{\n    int n; //array size\n    vector<int> tree; // store the segment tree\n    vector<int> lazy; // store pending updates\n    //\n    void initRMQ(int arrSize);\n    void lazy_evaluate(int iNode, int sStart, int sEnd);\n    int readUtil(int iNode, int sStart, int sEnd, int idx);\n    int read(int idx);\n    void updateRangeUtil(int iNode, int sStart, int sEnd, int uStart, int uEnd, int val);\n    void updateRange(int uStart, int uEnd, int val);\n    //\n    void printTree();\n};\n\nint main()\n{\n    // get the weighted rooted tree\n    int n; // number of nodes\n    cin >> n;\n    WRTree T(n);\n    int x, y, z;\n    for (int i = 0; i < n; i++) {\n        cin >> x; // x = k_i\n        for (int j = 0; j < x; j++) {\n            cin >> y; // y = c_j\n            T.addEdge(i, y); // add a new edge\n        }\n    }\n\n    // convert the input tree to an array\n    T.dfs(0); // start from the root (node 0)\n    //T.print();\n\n    // create a segment tree for the array\n    SegmentTree ST; // each node saves the distance from the root to a node\n    ST.initRMQ(n);\n    //ST.printTree();\n\n    // process queries\n    int q; // no. of queries\n    cin >> q;\n    for (int i=0; i<q; i++) {\n        cin >> x;\n        if (x==1) { // getSum() query\n            cin >> y; // y = u (a vertex)\n            cout << ST.read(T.left[y]) << \"\\n\";\n        }\n        else if (x==0) { // add() query\n            cin >> y >> z; // y = v (vertex), z = w (weight)\n            ST.updateRange(T.left[y], T.right[y], z); // add z to records indexed from T.left[y] to T.right[y]\n        }\n    }\n\n    return 0;\n}\n\nWRTree::WRTree(int n) {\n    adj.resize(n);\n    left.resize(n);\n    right.resize(n);\n}\n\nvoid WRTree::addEdge(int u, int v) {\n    adj[u].push_back(v);\n}\n\nvoid WRTree::dfs(int node) {\n    listOfNode.push_back(node);\n    left[node] = listOfNode.size()-1; // index of the already-visited node in the array listOfNode\n    for (int i=0; i<adj[node].size(); i++) {\n        int v = adj[node][i];\n        dfs(v);\n    }\n    right[node] = listOfNode.size()-1;\n}\n\nvoid WRTree::print() {\n    cout << \"---------------\\n\";\n    int n = adj.size();\n    cout << \"adj:\\n\";\n    for (int i=0; i<n; i++) {\n        if (adj[i].size()>0) {\n            for (int j=0; j<adj[i].size(); j++) {\n                cout << adj[i][j] << \" \";\n            }\n        } else{\n            cout << \"x\";\n        }\n        cout << endl;\n    }\n    cout << \"list of node:\\n\";\n    for (int i=0; i<n; i++) {\n        cout << listOfNode[i] << \" \";\n    }\n    cout << \"\\nleft:\\n\";\n    for (int i=0; i<n; i++) {\n        cout << left[i] << \" \";\n    }\n    cout << \"\\n\";\n    cout << \"right:\\n\";\n    for (int i=0; i<n; i++) {\n        cout << right[i] << \" \";\n    }\n    cout << \"\\n\";\n}\n\nvoid SegmentTree::initRMQ(int arrSize) {\n    n = 1;\n    while (n<arrSize) {n *= 2;}\n    tree = vector<int>(2*n-1, INIVAL);\n    lazy = vector<int>(2*n-1, INIVAL);\n}\n\nvoid SegmentTree::printTree() {\n    cout << \"tree[]: \" << \"\\t\";\n    for (int i = 0; i < tree.size(); i++) {cout << fixed << this->tree[i] << \"\\t\";}\n    cout << \"\\n\" << \"lazy[]: \" << \"\\t\";\n    for (int i = 0; i < lazy.size(); i++) {cout << fixed << this->lazy[i] << \"\\t\";}\n    cout << endl;\n}\n\nvoid SegmentTree::lazy_evaluate(int iNode, int sStart, int sEnd) {\n    if (lazy[iNode] != 0) {\n        // apply the pending update stored in the corresponding lazy node\n        tree[iNode] += (sStart-sEnd+1)*lazy[iNode];\n        // not a leaf node\n        if (sStart!=sEnd) {\n            lazy[iNode*2+1] += lazy[iNode];\n            lazy[iNode*2+2] += lazy[iNode];\n        }\n        // erase the mark for the pending update of this node\n        lazy[iNode] = 0;\n    }\n}\n\nint SegmentTree::readUtil(int iNode, int sStart, int sEnd, int idx) {\n    // check pending update\n    lazy_evaluate(iNode, sStart, sEnd);\n\n    // leaf node\n    if (sStart==sEnd){return tree[iNode];}\n\n    // not a leaf node\n    int mid = (sStart+sEnd)/2;\n    if (sStart <= idx && idx <= mid) {return readUtil(iNode*2+1, sStart, mid, idx);}\n    else {return readUtil(iNode*2+2, mid+1, sEnd, idx);}\n}\n\nint SegmentTree::read(int idx) {\n    return readUtil(0, 0, n-1, idx);\n}\n\nvoid SegmentTree::updateRangeUtil(int iNode, int sStart, int sEnd, int uStart, int uEnd, int val) {\n    // apply pending updates (if any)\n    lazy_evaluate(iNode, sStart, sEnd);\n\n    // out of range\n    if (sStart > uEnd || sEnd < uStart || sStart > sEnd) {return;}\n\n    // current segment is fully in range\n    if (sStart >= uStart && sEnd <= uEnd) {\n        // update the current node\n        tree[iNode] += (sStart-sEnd+1)*val;\n        // in case not a leaf node -> postpone the update for children nodes\n        if (sStart != sEnd) {\n            lazy[iNode*2+1] += val;\n            lazy[iNode*2+2] += val;\n        }\n        return;\n    }\n\n    // not completely in range, but overlapped -> recur throughout children nodes\n    int mid = (sStart + sEnd)/2;\n    updateRangeUtil(iNode*2+1, sStart, mid, uStart, uEnd, val);\n    updateRangeUtil(iNode*2+2, mid+1, sEnd, uStart, uEnd, val);\n    // then, use the result of children calls to update the current node\n    tree[iNode] = tree[iNode*2+1] + tree[iNode*2+2];\n}\n\nvoid SegmentTree::updateRange(int uStart, int uEnd, int val) {\n    updateRangeUtil(0, 0, n-1, uStart, uEnd, val);\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#line 1 \"hld.test.cpp\"\n#include <cstdio>\n#include <vector>\n#include <functional>\nusing namespace std;\nusing ll = long long int;\n\n#define call_from_test\n#line 1 \"/mnt/hdd1/cpp_library/graph/graph_020_HLDecomposition.cpp\"\n// HL 分解 (Heavy-Light Decomposition)\n// 頂点 v を根とする部分木: [ in[v], out[v] )\n// 頂点 v から見た heavy edge chain の頭: head[v]\nstruct HLD {\n    vector< vector<int> > G;\n    vector<int> sub, par, depth, in, out, rev, head;\n    \n    void dfs_sub(int cur) {\n        for(auto& to : G[cur]) {\n            if(par[cur] == to) continue;\n            par[to] = cur;\n            depth[to] = depth[cur] + 1;\n            dfs_sub(to);\n            sub[cur] += sub[to];\n            if(sub[to] > sub[ G[cur][0] ]) swap(to, G[cur][0]);\n        }\n    }\n    void dfs_hld(int cur, int& ptr) {\n        in[cur] = ptr; rev[ptr++] = cur;\n        for(auto to : G[cur]) {\n            if(par[cur] == to) continue;\n            head[to] = (to == G[cur][0] ? head[cur] : to);\n            dfs_hld(to, ptr);\n        }\n        out[cur] = ptr;\n    }\n\n    HLD(int N) : G(N), sub(N, 1), par(N, -1), depth(N),\n                 in(N), out(N), rev(N), head(N) {}\n    void add_edge(int u, int v) {\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    void build(int root=0) {\n        int ptr = 0; dfs_sub(root); dfs_hld(root, ptr);\n    }\n    int lca(int u, int v) {\n        while(1) {\n            if(in[u] > in[v]) swap(u, v);\n            if(head[u] == head[v]) return u;\n            v = par[ head[v] ];\n        }\n    }\n    int distance(int u, int v) {\n        return depth[u] + depth[v] - 2 * depth[lca(u, v)];\n    }\n\n    template <typename F>\n    void proceed(int u, int v, const F& f, bool b) {\n        for(; head[u] != head[v]; v = par[ head[v] ]) {\n            if(in[u] > in[v]) swap(u, v);\n            f(in[ head[v] ], in[v] + 1);\n        }\n        if(in[u] > in[v]) swap(u, v);\n        f(in[u] + b, in[v] + 1);\n    }\n\n    // u - v パス上に存在する「頂点」or「辺」全体に f(l, r) を作用\n    // l, r は SegmentTree とかのデータ構造上のインデックス\n    template <typename F>\n    void query_vertices(int u, int v, const F& f) {\n        proceed(u, v, f, false);\n    }\n\n    template <typename F>\n    void query_edges(int u, int v, const F& f) {\n        proceed(u, v, f, true);\n    }\n\n    template <typename T, typename F, typename M>\n    T proceed(int u, int v, T E, const F& f, const M& m, bool b) {\n        T vl(E), vr(E);\n        for(; head[u] != head[v]; v = par[ head[v] ]) {\n            if(in[u] > in[v]) swap(u, v), swap(vl, vr);\n            vr = m(f(in[ head[v] ], in[v] + 1), vr);\n        }\n        if(in[u] > in[v]) swap(u, v), swap(vl, vr);\n        vr = m(f(in[u] + b, in[v] + 1), vr);\n        return m(vl, vr);\n    }\n\n    // u - v パス上に存在する「頂点」or「辺」全体に割り当てられた値を\n    // 各 chunk に対して f(l, r) で得て、それらを m(vl, vr) で merge したものを得る\n    // 単位元 E も渡そう\n    template <typename T, typename F, typename M>\n    T query_vertices(int u, int v, T E, const F& f, const M& m) {\n        return proceed(u, v, E, f, m, false);\n    }\n\n    template <typename T, typename F, typename M>\n    T query_edges(int u, int v, T E, const F& f, const M& m) {\n        return proceed(u, v, E, f, m, true);\n    }\n};\n#line 1 \"/mnt/hdd1/cpp_library/structure/strc_009_abst_lazy_segtree.cpp\"\n// @category セグメント木 (Segment Tree)\n// @title 遅延伝播セグメント木 (Lazy Segment Tree)\ntemplate <typename MonoidType, typename OperatorType>\nstruct LazySegmentTree {\n    using MMtoM = function< MonoidType(MonoidType, MonoidType) >;\n    using OOtoO = function< OperatorType(OperatorType, OperatorType) >;\n    using MOtoM = function< MonoidType(MonoidType, OperatorType) >;\n    using OItoO = function< OperatorType(OperatorType, int) >;\n\n    // node, lazy, update flag (for lazy), identity element\n    int n;\n    vector<MonoidType> node;\n    vector<OperatorType> lazy;\n    vector<bool> need_update;\n    MonoidType E0;\n    OperatorType E1;\n\n    // update / combine / lazy / accumulate function\n    MOtoM upd_f;\n    MMtoM cmb_f;\n    OOtoO lzy_f;\n    OItoO acc_f;\n\n    void build(int m, vector<MonoidType> v = vector<MonoidType>()) {\n        if(v != vector<MonoidType>()) m = v.size();\n        n = 1; while(n < m) n *= 2;\n\n        node = vector<MonoidType>(2*n-1, E0);\n        lazy = vector<OperatorType>(2*n-1, E1);\n        need_update = vector<bool>(2*n-1, false);\n        if(v != vector<MonoidType>()) {\n            for(int i=0; i<m; i++) {\n                node[n-1+i] = v[i];\n            }\n            for(int i=n-2; i>=0; i--) {\n                node[i] = cmb_f(node[2*i+1], node[2*i+2]);\n            }\n        }\n    }\n\n    // initialize\n    LazySegmentTree() {}\n    LazySegmentTree(int n_, MonoidType E0_, OperatorType E1_,\n                    MOtoM upd_f_, MMtoM cmb_f_, OOtoO lzy_f_, OItoO acc_f_,\n                    vector<MonoidType> v = vector<MonoidType>()) :\n        E0(E0_), E1(E1_),\n        upd_f(upd_f_), cmb_f(cmb_f_), lzy_f(lzy_f_), acc_f(acc_f_) {\n        build(n_, v);\n    }\n\n    void eval(int k, int l, int r) {\n        if(!need_update[k]) return;\n        node[k] = upd_f(node[k], acc_f(lazy[k], r - l));\n        if(r - l > 1) {\n            lazy[2*k+1] = lzy_f(lazy[2*k+1], lazy[k]);\n            lazy[2*k+2] = lzy_f(lazy[2*k+2], lazy[k]);\n            need_update[2*k+1] = need_update[2*k+2] = true;\n        }\n        lazy[k] = E1;\n        need_update[k] = false;\n    }\n\n    void update(int a, int b, OperatorType x, int l, int r, int k) {\n        eval(k, l, r);\n        if(b <= l or  r <= a) return;\n        if(a <= l and r <= b) {\n            lazy[k] = lzy_f(lazy[k], x);\n            need_update[k] = true;\n            eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, x, l, mid, 2*k+1);\n            update(a, b, x, mid, r, 2*k+2);\n            node[k] = cmb_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    MonoidType query(int a, int b, int l, int r, int k) {\n        if(b <= l or  r <= a) return E0;\n        eval(k, l, r);\n        if(a <= l and r <= b) return node[k];\n        int mid = (l + r) / 2;\n        MonoidType vl = query(a, b, l, mid, 2*k+1);\n        MonoidType vr = query(a, b, mid, r, 2*k+2);\n        return cmb_f(vl, vr);\n    }\n\n    // update [a, b)-th element (applied value, x)\n    void update(int a, int b, OperatorType x) {\n        update(a, b, x, 0, n, 0);\n    }\n\n    // range query for [a, b)\n    MonoidType query(int a, int b) {\n        return query(a, b, 0, n, 0);\n    }\n\n    void dump() {\n        fprintf(stderr, \"[lazy]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(lazy[i] == E1) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", lazy[i]);\n        }\n        fprintf(stderr, \"\\n\");\n\n        fprintf(stderr, \"[node]\\n\");\n        for(int i=0; i<2*n-1; i++) {\n            if(i == n-1) fprintf(stderr, \"xxx \");\n            if(node[i] == E0) fprintf(stderr, \"  E \");\n            else fprintf(stderr, \"%3d \", node[i]);\n        }\n        fprintf(stderr, \"\\n\");\n    }\n};\n#line 10 \"hld.test.cpp\"\n#undef call_from_test\n\nint main() {\n    int N; scanf(\"%d\", &N);\n    HLD hld(N);\n    for(int i=0; i<N; i++) {\n        int K; scanf(\"%d\", &K);\n        for(int j=0; j<K; j++) {\n            int v; scanf(\"%d\", &v);\n            hld.add_edge(i, v);\n        }\n    }\n    hld.build();\n\n    LazySegmentTree<ll, ll> seg(N, 0, 0,\n                                [](ll a, ll b) { return a + b; },\n                                [](ll a, ll b) { return a + b; },\n                                [](ll a, ll b) { return a + b; },\n                                [](ll a, int x) { return a * x; });\n    int Q; scanf(\"%d\", &Q);\n    while(Q--) {\n        int t; scanf(\"%d\", &t);\n        if(t == 0) {\n            int v, w; scanf(\"%d%d\", &v, &w);\n            int u = hld.par[v];\n            hld.query_edges(u, v, [&](int l, int r) {\n                    seg.update(l, r, w);\n                });\n        }\n        if(t == 1) {\n            int u; scanf(\"%d\", &u);\n            auto f = [&](int l, int r) {\n                return seg.query(l, r);\n            };\n            auto m = [&](ll v0, ll v1) {\n                return v0 + v1;\n            };\n            ll ans = hld.query_edges(0, u, 0, f, m);\n            printf(\"%lld\\n\", ans);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=1e5+9;\nint in[MAX],out[MAX];\nint vis[MAX],bit[MAX];\nvector<int>adj[MAX];\nint tim=0;\nint n;\nvoid init(int n ){\n\tfor(int i=0;i<n+1;i++){\n\t\tbit[i]=0;\n\t\tvis[i]=0;\n\t}\n}\nvoid update(int x,  int w){\n\tfor(int i=x;i<=n;i+=i&(-i)){\n\t\tbit[i]=bit[i]+w;\n\t//\tcout<<i<<\" \";\n\t}\n\t//cout<<\"\\n\";\n}\nint query(int x){\n\tint sum=0;\n\tfor(int i=x;i>0;i-=i&(-i)){\n\t\tsum=sum+bit[i];\n\t}\n\treturn sum;\n}\nvoid dfs(int s){\n\tvis[s]=1;\n\tin[s]=tim++;\n\tfor(int i=0;i<adj[s].size();i++){\n\t\tif(!vis[adj[s][i]]){\n\t\t\tdfs(adj[s][i]);\n\t\t}\n\t}\n\tout[s]=tim++;\n\n}\nint main(){\n\tcin>>n;\n\tinit(n);\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tadj[i].push_back(a);\n\t\t\tadj[a].push_back(i);\n\t\t}\n\t}\n\tdfs(0);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint u,w,t;\n\t\tcin>>t;\n\t\t//cout<<13234;\n\t\tif(t==0){\n\t\t\tcin>>u>>w;\n\t\t\t//cout<<in[u]<<\" \"<<out[u]<<\"\\n\";\n\t\t\tupdate(in[u],w);\n\t\t\tupdate(out[u],-w);\n\t\t}\n\t\telse {\n\t\t\tcin>>u;\n\t\t\tint p=query(in[u]);\n\t//\t\tcout<<in[u]<<\" \";\n\t\t\tcout<<p<<\"\\n\";\n\t\t}\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> G[100010];\n\n#define MAX_N 1<<17\nint n,dat[2*(MAX_N)-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nint find(int k){\n  k+=n-1;\n  int ans=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    ans+=dat[k];\n  }\n  return ans;\n}\n\n\nvoid update(int a,int b,int x,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l)return;\n  if(a<=l&&r<=b){\n    dat[k]+=x;\n  }else{\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n}\n\nint num[2][200010];\nint a;\nvoid dfs(int k=0){\n  num[0][k]=a;\n  a++;\n  for(int i=0;i<G[k].size();i++){\n    dfs(G[k][i]);\n  }\n  num[1][k]=a;\n}\n\nint main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int a;\n      cin>>a;\n      G[i].push_back(a);\n    }\n  }\n  dfs();\n  init(a);\n  // cout<<num[1][0]<<\" happy\"<<endl;\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int x;\n    cin>>x;\n    if(x==0){\n      int w,v;\n      cin>>v>>w;\n      update(num[0][v],num[1][v],w);\n    }else{\n      int u;\n      cin>>u;\n      cout<<find(num[0][u])<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct RSQ{\n  ll n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 1 index\n  /*void add(int i,int v){\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }*/\n  // 0 index\n  void add(int i,ll v){\n    i+=1;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  ll sum(int i){\n    ll res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) 1 index\n  /*int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }*/\n  //[a,b) 0 index\n  int sum(int x,int y){\n    x++;y++;\n    return sum(y-1)-sum(x-1);\n  }\n};\n \nstruct HLD {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  RSQ rsq;\n\n  HLD(){}\n  HLD(int sz):n(sz),pos(0),G(n),vid(n,-1),head(n),sub(n,1),hvy(n,-1),par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int i=0;i<rs.size();i++){\n        int r=rs[i];\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int, int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n        int v=st.top().first;\n        int &i=st.top().second;\n        if(i<(int)G[v].size()){\n            int u=G[v][i++];\n            if(u==par[v]) continue;\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            st.emplace(u,0);\n        }else{\n            st.pop();\n            int res=0;\n            for(int i=0;i<G[v].size();i++){\n                int u=G[v][i];\n                if(u==par[v]) continue;\n                sub[v]+=sub[u];\n                if(res<sub[u]) res=sub[u],hvy[v]=u;\n            }\n        }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n        type[i]=c;\n        vid[i]=k++;\n        inv[vid[i]]=i;\n        head[i]=h;\n        for(int J=0;J<G[i].size();J++){\n            int j=G[i][J];\n            if(j!=par[i]&&j!=hvy[i]) q.push(j);\n        }\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  int for_each(int u, int v) {\n    int ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      //f(max(vid[head[v]],vid[u]),vid[v]);\n      //ans = max(ans,rmq.query(l, r + 1));\n      if(head[u]!=head[v]) v=par[head[v]];\n      else {return ans;}\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  ll for_each_edge(int u, int v) {\n    ll ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n        //f(vid[head[v]],vid[v]);\n        ans += rsq.sum(vid[head[v]],vid[v]+1);\n        v=par[head[v]];\n      } else{\n        //if(u!=v) f(vid[u]+1,vid[v]);\n        if(u!=v) ans += rsq.sum(vid[u]+1,vid[v]+1);\n        return ans;\n      }\n    }\n  }\n\n  void update(int u,int w){\n    rsq.add(vid[u],w);\n  }\n\n  void range_update(){\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\nint main(){\n    int n,m,x,w;\n    scanf(\"%d\",&n);\n    HLD Tree(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&x);\n            Tree.add_edge(i,x);\n        }\n    }\n    Tree.build();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        if(m==0){\n            scanf(\"%d%d\",&x,&w);\n            Tree.update(x,w);\n        }\n        else{\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",Tree.for_each_edge(0,x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define all(x) (x).begin(),(x).end()\nconst int mod=1000000007,MAX=1<<19;\nconst ll INF=1LL<<40;\nstruct edge{\n    int to;\n    ll dis;\n};\n\nvector<edge> G[MAX];\nint n;\nint fi[MAX],la[MAX],vs[MAX],depth[MAX];\nll bit[MAX+1];\n\nll sum(int i){\n    int s=0;\n    while(i>0){\n        s+=bit[i];\n        i-=i&-i;\n    }\n    return s;\n}\n\n//sからtの和=sum(t)-sum(s-1)\n\nvoid add(int i,ll x){\n    while(i<=n){\n        bit[i]+=x;\n        i+=i&-i;\n    }\n}\n\nvoid DFS(int v,int p,int d,int &k){\n    fi[v]=k;\n    la[v]=k;\n    vs[k+n-1]=v;\n    depth[k+n-1]=d;\n    k++;\n    \n    for(int i=0;i<G[v].size();i++){\n        edge E=G[v][i];\n        if(E.to!=p){\n            add(k-1,E.dis);\n            \n            DFS(G[v][i].to,v,d+1,k);\n            \n            add(k-1,-E.dis);\n            \n            la[v]=k;\n            vs[k+n-1]=v;\n            depth[k+n-1]=d;\n            k++;\n        }\n    }\n}//1が最初...fi[root]=1になる\n\nvoid rmq_init(){\n    for(int i=n-2;i>=0;i--){\n        if(depth[i*2+1]<depth[i*2+2]){\n            depth[i]=depth[i*2+1];\n            vs[i]=vs[i*2+1];\n        }else{\n            depth[i]=depth[i*2+2];\n            vs[i]=vs[i*2+2];\n        }\n    }\n}\n\nvoid init(int n_){\n    n=1;\n    while(n<n_) n*=2;\n    int k=1;\n    DFS(0,-1,0,k);\n    rmq_init();\n}//2*N+1ぐらいやっとくとよい、配列サイズも2倍とる\n\nint query(int a,int b,int k,int l,int r){\n    \n    if(r<=a||b<=l) return -1;\n    if(a<=l&&r<=b) return k;\n    else{\n        int vl=query(a,b,2*k+1,l,(l+r)/2);\n        int vr=query(a,b,2*k+2,(l+r)/2,r);\n        if(vl==-1) return vr;\n        if(vr==-1) return vl;\n        if(depth[vl]<depth[vr]) return vl;\n        return vr;\n    }\n}\n\nint lca(int u,int v){\n    int a=min(fi[u],fi[v]),b=max(fi[u],fi[v]);\n    return vs[query(a,b+1,0,0,n)];\n}\n\nint main(){\n\n    int N;cin>>N;\n    for(int i=0;i<N;i++){\n        int k;cin>>k;\n        for(int j=0;j<k;j++){\n            int c;cin>>c;\n            G[i].push_back({c,0});\n            G[c].push_back({i,0});\n        }\n    }\n    \n    init(2*N+1);\n    \n    int Q;cin>>Q;\n    \n    while(Q){\n        int k;cin>>k;\n        if(k==0){\n            int a,b;cin>>a>>b;\n            add(fi[a],b);\n            add(la[a]+1,-b);\n        }else{\n            int a;cin>>a;\n            cout<<sum(fi[a])+sum(fi[0])-2*sum(fi[lca(a,0)])<<endl;\n        }\n        \n        Q--;\n    }\n    \n    \n}\n\n//sum(fi[a]-1)+sum(fi[b]-1)-2*sum(fi[lca(a,b)]-1)が長さ変更前の長さ\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define FOR(I,A,B) for(ll I = ll(A); I < ll(B); ++I)\n\n\n// 区間加算　一点取得 RAQ 平方分割で実装\ntemplate <typename T>\nstruct RAQ{// 0-index\n\tint n,rn,bn; // rn個のかたまりをbn個\n\tvector<T> data,bucket;\n\tRAQ(int n_){init(n_);}\n\tvoid init(int n_){\n\t\tn = n_;\n\t\trn = sqrt(n);\n\t\tbn = ceil((double)n/rn);\n\t\tdata.resize(n,0);\n\t\tbucket.resize(bn,0);\n\t}\n\tT get(int i){\n\t\treturn data[i]+bucket[i/rn];\n\t}\n\tvoid add(int s,int t,T x){ // s~tにxを加算\n\t\tfor(int i=s;i<=t;++i){\n\t\t\tif(i%rn==0 && (i+rn-1)<=t){\n\t\t\t\tbucket[i/rn] += x;\n\t\t\t\ti += rn-1;\n\t\t\t}else{\n\t\t\t\tdata[i] += x;\n\t\t\t}\n\t\t}\n\t}\n};\n\n\nvector<int> child[100001];\n\n// 頂点iの部分木にあるの頂点のRAQ上の番号が\n// (data1[i],data2[i])になるようにするdfs\nvector<int> data1(100001),data2(100001);\nint a=0;\nvoid dfs(int i = 0){\n\tdata1[i] = a++;\n\tfor(auto c:child[i]){\n\t\tdfs(c);\n\t}\n\tdata2[i] = a-1;\n}\n\n\nint main(){\n\tint n,k,c,q;\n\tcin >> n;\n\tFOR(i,0,n){\n\t\tcin >> k;\n\t\tFOR(j,0,k){\n\t\t\tcin >> c;\n\t\t\tchild[i].push_back(c);\n\t\t}\n\t}\n\tdfs();\n\tcin >> q;\n\n\tRAQ<ll> raq(100003);\n\tFOR(qq,0,q){\n\t\tint qu,u,v;\n\t\tll w;\n\t\tcin >> qu;\n\t\tif(qu){//getsum\n\t\t\tcin >> u;\n\t\t\tcout << raq.get(data1[u]) << \"\\n\";\n\t\t}else{\n\t\t\tcin >> v >> w;\n\t\t\traq.add(data1[v],data2[v],w);\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "using namespace std;\nvector<int> G[100010];\n\n#define MAX_N 1<<17\nint n,dat[2*(MAX_N)-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nint find(int k){\n  k+=n-1;\n  int ans=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    ans+=dat[k];\n  }\n  return ans;\n}\n\n\nvoid update(int a,int b,int x,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l)return;\n  if(a<=l&&r<=b){\n    dat[k]+=x;\n  }else{\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n}\n\nint num[2][200010];\nint dfs(int k=0,int a=0){\n  num[0][k]=a;\n  for(int i=0;i<G[k].size();i++){\n    a=dfs(G[k][i],a+1);\n  }\n  num[1][k]=a;\n  return a+1;\n}\n\nint main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int a;\n      cin>>a;\n      G[i].push_back(a);\n    }\n  }\n  n=dfs();\n  init(n);\n  //cout<<n<<\" happy\"<<endl;\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int x;\n    cin>>x;\n    if(x==0){\n      int w,v;\n      cin>>v>>w;\n      update(num[0][v],num[1][v]+1,w);\n    }else{\n      int u;\n      cin>>u;\n      cout<<find(num[0][u])<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nclass BIT{\npublic:\n  typedef long long ll;\n  ll n;\n  vector<ll> bit0, bit1;\n  BIT(){n=-1;}\n  BIT(ll n_){\n    n=1;\n    while(n<n_)n*=2;\n    bit0.resize(n+1,0);\n    bit1.resize(n+1,0);\n  }\n  \n  ll sum(vector<ll> &b,ll i){\n    ll s=0;\n    while(i>0){\n      s=(s+b[i]);\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(vector<ll> &b,ll i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v);\n      i+=i&-i;\n    }\n  }\n\n  //[a,b]にxを加算(1<=a)\n  void add (ll a,ll b,ll x){\n    assert(a > 0 && n >= 0);\n\n    add(bit0,a,-x*(a-1));\n    add(bit1,a,x);\n    add(bit0,b+1,x*b);\n    add(bit1,b+1,-x);\n  }\n\n  //[a,b]のsumを得る(1<=a)\n  ll sum(ll a,ll b){\n    assert(a > 0 && n >= 0);\n    ll res=0;\n    res+=sum(bit0,b)+sum(bit1,b)*b;\n    res-=sum(bit0,a-1)+sum(bit1,a-1)*(a-1);\n    return res;\n  }\n};\n\nvector<int> G[100005];\nvector<int> order;\nint s[100005], t[100005];\n\nvoid dfs(int x){\n  \n  s[x]=(int)order.size()+1;\n  \n  order.push_back(x);\n  \n  for(int i=0;i<G[x].size();i++) dfs(G[x][i]);\n\n  t[x]=(int)order.size();\n}\n\nsigned main(){\n  \n  int n;  \n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      G[i].push_back(c);\n  \n    }\n  }\n\n  dfs(0);\n\n  BIT bit=BIT(n);\n  \n  int q;\n  cin>>q;\n  \n  while(q--){\n    \n    int a;\n    cin>>a;\n\n    if(a==0){\n      int v, w;\n      cin>>v>>w;\n      bit.add(s[v], t[v], w);\n    }\n    else{\n      int u;\n      cin>>u;\n      cout<<bit.sum(s[u], s[u])<<endl;\n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \nusing namespace std;\nusing ll = long long;\n// #define int ll\nusing PII = pair<ll, ll>;\n \n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n \ntemplate<typename T> T &chmin(T &a, const T &b) { return a = min(a, b); }\ntemplate<typename T> T &chmax(T &a, const T &b) { return a = max(a, b); }\ntemplate<typename T> bool IN(T a, T b, T x) { return a<=x&&x<b; }\ntemplate<typename T> T ceil(T a, T b) { return a/b + !!(a%b); }\n\ntemplate<typename T> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T,typename... Ts>\nauto make_v(size_t a,Ts... ts) { \n    return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...));\n}\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value==0>::type\nfill_v(T &t, const V &v) { t=v; }\ntemplate<typename T,typename V> typename enable_if<is_class<T>::value!=0>::type\nfill_v(T &t, const V &v ) { for(auto &e:t) fill_v(e,v); }\n\ntemplate<class S,class T>\nostream &operator <<(ostream& out,const pair<S,T>& a){\n    out<<'('<<a.first<<','<<a.second<<')'; return out;\n}\ntemplate<class T>\nostream &operator <<(ostream& out,const vector<T>& a){\n    out<<'['; for(T i: a) {out<<i<<',';} out<<']'; return out;\n}\n\nint dx[] = {0, 1, 0, -1}, dy[] = {1, 0, -1, 0}; // DRUL\nconst int INF = 1<<30;\nconst ll LLINF = 1LL<<60;\nconst ll MOD = 1000000007;\n\nstruct HLDecomposition {\n    int n, pos;\n    vector<vector<ll>> g;\n    vector<ll> vid,   // HL分解後のグラフでのid\n        head,  // 頂点が属するheavy-pathのheadのid\n        sub,   // 部分木のサイズ\n        hvy,   // heavy-path上での次の頂点のid\n        par,   // 親のid\n        depth, // 深さ\n        inv,   // HL分解前のグラフのid（添え字が分解後のid）\n        type,  // 森をHL分解するときの属する木の番号\n        ps,    // 行きがけ順\n        pt;    // 帰りがけ順\n\n    // 根rtからdfsして部分木の大きさ、heavy-edgeの判定などをする\n    void dfs1(ll rt) {\n        stack<PII> st;\n        par[rt] = -1;\n        depth[rt] = 0;\n        st.emplace(rt, 0);\n        while(st.size()) {\n            ll v = st.top().first;\n            ll &i = st.top().second;\n            if(i < (ll)g[v].size()) {\n                ll u = g[v][i++];\n                if(u == par[v]) continue;\n                par[u] = v;\n                depth[u] = depth[v]+1;\n                st.emplace(u, 0);\n            } else {\n                st.pop();\n                for(ll &u: g[v]){\n                    if(u == par[v]) swap(u, g[v].back());\n                    if(u == par[v]) continue;\n                    sub[v] += sub[u];\n                    if(sub[u]>sub[g[v].front()]) swap(u, g[v].front());\n                }\n            }\n        }\n    }\n    // 根r、c番目の木についてchainについての情報をまとめる\n    void dfs2(ll r, ll c) {\n        using T = tuple<ll, ll, ll>;\n        stack<T> st;\n        st.emplace(r,r,0);\n        while(!st.empty()) {\n            ll v,h;\n            tie(v,h,ignore)=st.top();\n            ll &i=get<2>(st.top());\n            if(!i) {\n                type[v]=c;\n                ps[v]=vid[v]=pos++;\n                inv[vid[v]]=v;\n                head[v]=h;\n                hvy[v]=(g[v].empty()?-1:g[v][0]);\n                if(hvy[v]==par[v]) hvy[v]=-1;\n            }\n            if(i<(ll)g[v].size()) {\n                ll u=g[v][i++];\n                if(u==par[v]) continue;\n                st.emplace(u,(hvy[v]==u?h:u),0);\n            } else {\n                st.pop();\n                pt[v]=pos;\n            }\n        }\n    }\n\n    HLDecomposition(){}\n    HLDecomposition(ll sz):\n        n(sz), pos(0), g(n),\n        vid(n,-1), head(n), sub(n,1), hvy(n,-1),\n        par(n), depth(n), inv(n), type(n), ps(n), pt(n) {}\n\n    void add_edge(ll u, ll v) {\n        g[u].push_back(v);\n        g[v].push_back(u);\n    }\n    void build(vector<ll> rs=vector<ll>(1,0)) {\n        ll c=0;\n        for(ll r: rs) {\n            dfs1(r);\n            dfs2(r, c++);\n        }\n    }\n\n    // 頂点に対する処理 [u,v] 開区間なので注意!!!\n    void for_each(ll u, ll v, const function<void(ll,ll)>& f) {\n        while(1){\n            if(vid[u]>vid[v]) swap(u,v);\n            // [max(vid[head[v]],vid[u]), vid[v]] の区間についての操作を行う\n            f(max(vid[head[v]], vid[u]), vid[v]);\n            if(head[u]!=head[v]) v = par[head[v]];\n            else break;\n        }\n    }\n    // 辺に対する処理 [u,v] 開区間なので注意!!!\n    void for_each_edge(ll u, ll v, const function<void(ll,ll)>& f) {\n        while(1) {\n            if(vid[u]>vid[v]) swap(u,v);\n            if(head[u]!=head[v]) {\n                f(vid[head[v]], vid[v]);\n                v = par[head[v]];\n            } else {\n                if(u!=v) f(vid[u]+1, vid[v]);\n                break;\n            }\n        }\n    }\n    ll lca(ll u, ll v) {\n        while(1) {\n            if(vid[u]>vid[v]) swap(u,v);\n            if(head[u]==head[v]) return u;\n            v = par[head[v]];\n        }\n    }\n    ll distance(ll u, ll v) {\n        return depth[u] + depth[v] - 2*depth[lca(u,v)];\n    }\n};\n/*\nパスu-vの頂点属性クエリ → hld.for_each(u, v, f)\nパスu-vの辺属性クエリ → hld.for_each_edge(u, v, f)\n頂点vの部分木に対するクエリ → 区間[hld.vid[u]+1, hld.vid[u] + hld.sub[u]) に操作\n*/\n\ntemplate <typename Monoid>\nstruct lazysegtree {\n    using T = typename Monoid::T;\n    using E = typename Monoid::E;\n    int n, height;\n    vector<T> dat;\n    vector<E> lazy;\n\n    lazysegtree() {}\n    lazysegtree(int n_) {\n        n = 1, height = 0;\n        while(n < n_) { n *= 2; height++; }\n        dat.assign(n*2, Monoid::dt());\n        lazy.assign(n*2, Monoid::de());\n    }\n    void build(vector<T> v) {\n        REP(i, v.size()) dat[i+n] = v[i];\n        for(int i=n-1; i>0; --i) dat[i] = Monoid::f(dat[i*2], dat[i*2+1]);\n    }\n\n    inline T reflect(int k) { return lazy[k]==Monoid::de()?dat[k]:Monoid::g(dat[k], lazy[k]); }\n    inline void eval(int k) {\n        if(lazy[k] == Monoid::de()) return;\n        lazy[2*k]   = Monoid::h(lazy[k*2],   lazy[k]);\n        lazy[2*k+1] = Monoid::h(lazy[k*2+1], lazy[k]);\n        dat[k] = reflect(k);\n        lazy[k] = Monoid::de();\n    }\n    inline void thrust(int k) { for(int i=height;i;--i) eval(k>>i); }\n    inline void recalc(int k) { while(k>>=1) dat[k] = Monoid::f(reflect(k*2), reflect(k*2+1)); }\n\n    void update(int a, int b, E x) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) lazy[l] = Monoid::h(lazy[l], x), ++l;\n            if(r&1) --r, lazy[r] = Monoid::h(lazy[r], x);\n        }\n        recalc(a);\n        recalc(b);\n    }\n    T query(int a, int b) {\n        thrust(a+=n);\n        thrust(b+=n-1);\n        T vl=Monoid::dt(), vr=Monoid::dt();\n        for(int l=a, r=b+1; l<r; l>>=1,r>>=1) {\n            if(l&1) vl=Monoid::f(vl, reflect(l++));\n            if(r&1) vr=Monoid::f(reflect(--r), vr);\n        }\n        return Monoid::f(vl, vr);\n    }\n\n    friend ostream &operator <<(ostream& out,const lazysegtree<Monoid>& seg) {\n        out << \"---------------------\" << endl;\n        int cnt = 1;\n        for(int i=1; i<=seg.n; i*=2) {\n            REP(j, i) {\n                out << \"(\" << seg.dat[cnt] << \",\" << seg.lazy[cnt] << \") \";\n                cnt++;\n            }\n            out << endl;\n        }\n        out << \"---------------------\" << endl;\n        return out;\n    }\n};\n\nstruct node {\n    ll sum, max, min, len;\n    node() : sum(0), max(-LLINF), min(LLINF), len(0) {}\n    node(ll a, ll b, ll c, ll d) : sum(a), max(b), min(c), len(d) {}\n};\nstruct linear_exp {\n    using T = node;\n    using E = PII;\n    static T dt() { return node(); }\n    static constexpr E de() { return PII(1, 0); }\n    static T f(const T &a, const T &b) {\n        node ret;\n        ret.sum = a.sum + b.sum;\n        ret.min = min(a.min, b.min);\n        ret.max = max(a.max, b.max);\n        ret.len = a.len + b.len;\n        return ret;\n    }\n    static T g(const T &a, const E &b) {\n        node ret;\n        ret.sum = b.first*a.sum+b.second*a.len;\n        ret.min = b.first*a.min+b.second;\n        ret.max = b.first*a.max+b.second;\n        ret.len = a.len;\n        return ret;\n    }\n    static E h(const E &a, const E &b) {\n        return PII(b.first*a.first, b.first*a.second+b.second);\n    }\n};\n\nsigned main(void)\n{\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    ll n;\n    cin >> n;\n    HLDecomposition hld(n);\n    vector<ll> p(n, -1);\n    REP(i, n) {\n        ll k;\n        cin >> k;\n        REP(j, k) {\n            ll c;\n            cin >> c;\n            hld.add_edge(i, c);\n            p[c] = i;\n        }\n    }\n    hld.build();\n\n    lazysegtree<linear_exp> seg(n);\n    vector<node> init(n);\n    REP(i, n) init[i] = node(0, 0, 0, 1);\n    seg.build(init);\n\n    ll q;\n    cin >> q;\n    while(q--) {\n        ll type;\n        cin >> type;\n        if(type == 0) {\n            ll v, w;\n            cin >> v >> w;\n            hld.for_each_edge(v, p[v], [&](ll a, ll b){\n                seg.update(a, b+1, PII(1, w));\n            });\n        } else {\n            ll v;\n            cin >> v;\n            ll ans = 0;\n            hld.for_each_edge(v, 0, [&](ll a, ll b){\n                ans += seg.query(a, b+1).sum;\n            });\n            cout << ans << endl;\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstring>\n#include <iostream>\n#include <cassert>\nusing std::cin;\nusing std::cout;\nusing std::endl;\nusing ll = long long;\n\ntemplate <typename T> T max(T a, T b) { return (a > b) ? a : b; }\n\ntemplate <typename T> T min(T a, T b) { return (a < b) ? a : b; }\n\ntemplate <typename T> class Vector {\nprivate:\n  unsigned int end;\n  unsigned int alloc;\n\npublic:\n  T *A;\n  Vector() : end(0), alloc(1), A((T *)malloc(sizeof(T))) {}\n  // Vector(){\n  //   end = 0;\n  //   alloc = 1;\n  //   A = (T *)malloc(sizeof(T));\n  // }\n  Vector(const unsigned int initial_size) {\n    end = initial_size;\n    alloc = max((unsigned int)1, initial_size);\n    A = (T *)malloc(sizeof(T) * initial_size);\n  }\n  Vector(const Vector &other) {\n    end = other.end;\n    alloc = other.alloc;\n    A = (T *)malloc(sizeof(T) * alloc);\n    memcpy(A, other.A, sizeof(T) * alloc);\n  }\n  Vector &operator=(const Vector &other) {\n    if (this != &other) {\n      end = other.end;\n      alloc = other.alloc;\n      A = (T *)malloc(sizeof(T) * alloc);\n      memcpy(A, other.A, sizeof(T) * alloc);\n    }\n    return *this;\n  }\n  unsigned int size() const { return end; }\n  void push_back(T v) {\n    if (end < alloc) {\n    } else {\n      if (alloc == 0 || A == NULL) {\n        A = (T *)malloc(sizeof(T));\n        alloc++;\n      } else {\n        unsigned int nalloc = alloc * 2;\n        T *nA = (T *)malloc(sizeof(T) * nalloc);\n        memcpy(nA, A, sizeof(T) * end);\n        free(A);\n        A = nA;\n        alloc = nalloc;\n      }\n    }\n    A[end] = v;\n    end++;\n  }\n  void pop_back() {\n    if (end == 0)\n      return;\n    end--;\n  }\n  T &operator[](unsigned int idx) { return A[idx]; }\n  ~Vector() { free(A); }\n};\n\ntemplate <typename T> class SegTree {\n  static const int MAXN = 1000010;\n  T *A;\n  int n;\n\npublic:\n  SegTree(int size) {\n    n = 1;\n    while (n < size) {\n      n *= 2;\n    }\n    n *= 2;\n    A = new T[MAXN * 4];\n    for (int i = 0; i < MAXN * 4; i++)\n      A[i] = 0;\n  }\n\n  T query(int a, int b) { return _query(a, b, 0, 0, n); }\n\n  T _query(int a, int b, int k, int l, int r) {\n    if (a >= r || b <= l) {\n      return 0;\n    }\n    if (l >= a && r <= b) {\n      return A[k];\n    }\n    T v1 = _query(a, b, 2 * k + 1, l, (l + r) / 2);\n    T v2 = _query(a, b, 2 * k + 2, (l + r) / 2, r);\n    return (v1 + v2);\n  }\n\n  void update(int _idx, int value) {\n    int offset = n - 1;\n    int idx = _idx + offset;\n    A[idx] = value;\n    while (idx > 0) {\n      idx = (idx - 1) / 2;\n      A[idx] = (A[idx * 2 + 1] + A[idx * 2 + 2]);\n    }\n  }\n};\n\nvoid euler_tour(int v, int prev, Vector<Vector<int>> &G, Vector<int> &e_rev, Vector<int> &e_in, Vector<int> &e_out) {\n  e_in[v] = e_rev.size()-1;\n  e_rev.push_back(v);\n  for (int i = 0; i < (int)G[v].size(); i++) {\n    if (G[v][i] != prev) {\n      euler_tour(G[v][i], v, G, e_rev, e_in, e_out);\n    }\n  }\n  e_out[v] = e_rev.size()-1;\n  e_rev.push_back(-v);\n}\n\nVector<int> calc_e(Vector<int> &e_rev, int n) {\n  Vector<int> res(n);\n  for (int i = 0; i < n; i++)\n    res[i] = -1;\n  for (int i = 0; i < (int)e_rev.size(); i++) {\n    int v = abs(e_rev[i]);\n    if (res[v] == -1) {\n      res[v] = i;\n    }\n  }\n  return res;\n}\n\nint main(void) {\n  int n;\n  cin >> n;\n  Vector<Vector<int>> G(n);\n  for (int i = 0; i < n; i++) {\n    int k;\n    cin >> k;\n    Vector<int> c(k);\n    for (int j = 0; j < k; j++) {\n      cin >> c[j];\n    }\n    G[i] = c;\n  }\n\n  Vector<int> e_rev;\n  Vector<int> e_in(n), e_out(n);\n  euler_tour(0, -1, G, e_rev, e_in, e_out);\n  Vector<int> e = calc_e(e_rev, n);\n  Vector<int> weight(n);\n  for (int i = 0; i < n; i++) {\n    weight[i] = 0;\n  }\n\n  SegTree<int> rsq(n);\n  for (int i = 0; i < (int)e_rev.size(); i++) {\n    rsq.update(i, 0);\n  }\n\n  int q;\n  cin >> q;\n  for (int loop = 0; loop < q; loop++) {\n    int op;\n    cin >> op;\n    if (op == 0) {\n      int v, w;\n      cin >> v >> w;\n      // weight[v] += w;\n      int idx_in = e_in[v];\n      {\n      int prev = rsq.query(idx_in, idx_in+1);\n      rsq.update(idx_in, prev + w);\n      }\n\n      int idx_out = e_out[v];\n      {\n        int prev = rsq.query(idx_out, idx_out+1);\n        rsq.update(idx_out, prev - w);\n      }\n    } else if (op == 1) {\n      int u;\n      cin >> u;\n      cout << rsq.query(0, e_in[u]+1) << '\\n';\n    } else {\n      assert(false);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n \nint ver[100000], cost[100000];\n \nvoid add(int v, int w){\n    cost[v] += w;\n}\n\nint getSum(int u){\n    int sum=0;\n     \n    while(ver[u] != u){\n        sum += cost[u];\n        u = ver[u];\n    }\n  \n    return sum;\n}\n\nint main(){\n    int n;\n    cin >> n;\n \n    for(int i=0; i<n; i++){\n        ver[i] = i;\n        cost[i] = 0;\n    }\n  \n    for(int i=0; i<n; i++){\n        int k;\n        cin >> k;\n        for(int j=0; j<k; j++){\n            int c;\n            cin >> c;\n            ver[c] = i;\n        }\n    }\n    \n    int q, sum=0;\n    cin >> q;\n    for(int i=0; i<q; i++){\n       int k;\n       cin >> k;\n       if(k == 0){\n             int v, w;\n               cin >> v >> w;\n               add(v, w);\n       } else if(k == 1){\n           int u;\n           cin >> u;\n           cout << getSum(u) << endl;\n       }       \n    }\n \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define ENABLE_DEBUG 1\n// Kana's kitchen {{{\n#include<bits/stdc++.h>\n#define ALL(v) std::begin(v),std::end(v)\n#define LOOP(k) for(lint ngtkana_is_a_genius=0; ngtkana_is_a_genius<(lint)k; ngtkana_is_a_genius++)\nusing lint=long long;\nusing ld=long double;\ntemplate<class T> using numr=std::numeric_limits<T>;\nstruct input_t {\n    template<class T> operator T() {\n        T t;\n        std::cin>>t;\n        return t;\n    }\n} input;\n#ifdef NGTKANA\n#include<debug.hpp>\n#else\n#define DEBUG(...)(void)0\n#endif\n/*}}}*/\n// segtree {{{\n/* APIs\n * - segtree(sz)\n * - size()\n * - fold(l, r)\n * - set(i, x)\n * - lazy_set(i, x)\n * - build()\n * - to_vec()\n */\ntemplate <class Monoid> struct segtree{/*{{{*/\n    // a type alias\n    using value_type = typename Monoid::value_type;\n\n    // member variables\n    std::vector<value_type>table;\n\n    // trivial constructors\n    segtree()=default;\n    segtree(segtree const&)=default;\n    segtree(segtree&&)=default;\n    segtree&operator=(segtree const&)=default;\n    segtree&operator=(segtree&&)=default;\n\n    // a non-trivial constructor\n    segtree(std::size_t n) : table(2*n, Monoid::id) {}\n\n    // resize\n    void resize(std::size_t n) {\n        assert(table.empty());\n        table.resize(2*n);\n    }\n\n    // size\n    std::size_t size() const { return table.size() / 2; }\n\n    // fold\n    value_type fold(std::size_t l, std::size_t r) const {\n        value_type fl = Monoid::id;\n        value_type fr = Monoid::id;\n\n        for(l+=size(),r+=size();l<r;l>>=1,r>>=1){\n            if(l&1u) fl=Monoid::op(fl, table.at(l++));\n            if(r&1u) fr=Monoid::op(fr, table.at(--r));\n        }\n\n        return Monoid::op(fl, fr);\n    }\n\n    // set\n    void set(std::size_t i, value_type x) {\n        assert(0 <= i);\n        assert(i < size());\n\n        i+=size();\n        table.at(i) = x;\n\n        for(i>>=1;i;i>>=1){ table.at(i) = Monoid::op(table.at(2*i), table.at(2*i+1)); }\n    }\n\n    // lazy_set\n    void lazy_set(std::size_t i, value_type x) {\n        assert(0 <= i);\n        assert(i < size());\n\n        i+=size();\n        table.at(i) = x;\n    }\n\n    // map\n    template <class F>\n        void map(std::size_t i, F const& f) { set(i, f(at(i))); }\n\n    // build\n    void build() {\n        for(std::size_t i=size()-1;i;i--){ table.at(i) = Monoid::op(table.at(2*i), table.at(2*i+1)); }\n    }\n\n    // at\n    value_type at(std::size_t i) const { return table.at(size() + i); }\n\n    // to_vec\n    std::vector<value_type> to_vec() const {\n        std::vector<value_type> ret(size());\n        std::copy(table.begin()+size(), table.end(), ret.begin());\n        return ret;\n    }\n\n};/*}}}*/\n/*}}}*/\n// add-monoid{{{\ntemplate <class Value> struct add_monoid_t {\n    using value_type = Value;\n    static value_type op(value_type l, value_type r) { return l + r; }\n    static const value_type id;\n};\ntemplate <class Value> const typename add_monoid_t<Value>::value_type\nadd_monoid_t<Value>::id = 0;\n/*}}}*/\n\nclass hl_decomposition {\n\nprivate:\n    bool built = false;\n    std::size_t time;\n\n    void erase_prt_dfs(std::size_t x, std::size_t p)\n    {\n        auto&& v = g.at(x);\n        auto p_found = std::find(v.begin(), v.end(), p);\n        if (p_found!= v.end()) v.erase(p_found);\n        for (std::size_t& y : v) {\n            erase_prt_dfs(y, x);\n        }\n    }\n\n    void size_dfs(std::size_t x)\n    {\n        auto&& v = g.at(x);\n        for (std::size_t& y : v) {\n            size_dfs(y);\n            sz.at(x) += sz.at(y);\n            if (sz.at(v.front()) < sz.at(y)) {\n                std::swap(v.front(), y);\n            }\n        }\n    }\n\n    void head_dfs(std::size_t x)\n    {\n        vid.at(x) = time++;\n        auto&& v = g.at(x);\n\n        for (std::size_t y : v) {\n            head.at(y) = y==v.front()\n                ? head.at(x)\n                : y\n                ;\n            head_dfs(y);\n        }\n    }\n\npublic:\n    std::vector<std::size_t> sz, head, vid;\n    std::vector<std::vector<std::size_t>> g;\n\n    hl_decomposition()=default;\n    hl_decomposition(hl_decomposition const&)=default;\n    hl_decomposition(hl_decomposition&&)=default;\n    hl_decomposition& operator=(hl_decomposition const&)=default;\n    hl_decomposition& operator=(hl_decomposition&&)=default;\n    ~hl_decomposition()=default;\n\n    hl_decomposition(std::vector<std::vector<std::size_t>> const& g_, std::size_t root)\n        : g(g_)\n    {\n        assert(root < size());\n        build(root);\n    }\n\n    hl_decomposition(std::size_t n) : g(n) {}\n\n    void insert(std::size_t u, std::size_t v) {\n        assert(u < size() && v < size());\n        g.at(u).push_back(v);\n        // g.at(v).push_back(u);\n    }\n\n    void build(std::size_t root)\n    {\n        assert(!std::exchange(built, true));\n        assert(root < size());\n\n        time = 0;\n        sz.assign(size(), 1u);\n        head.resize(size());\n        vid.resize(size());\n\n        head.at(root) = root;\n\n        erase_prt_dfs(root, root);\n        size_dfs(root);\n        head_dfs(root);\n    }\n\n    std::size_t size() const { return g.size(); }\n};\n\nint main(){\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n    std::cout << std::setprecision(15) << std::fixed;\n\n    std::size_t n;\n    std::cin >> n;\n\n    std::size_t root = 0;\n\n    std::vector<std::size_t> prt(n);\n    hl_decomposition hld(n);\n    for (std::size_t i=0; i<n ;i++) {\n        std::size_t k;\n        std::cin >> k;\n        while (k--) {\n            std::size_t j;\n            std::cin >> j;\n            hld.insert(i, j);\n            prt.at(j) = i;\n        }\n    }\n    hld.build(0);\n\n    std::size_t q;\n    std::cin >> q;\n    auto seg = segtree<add_monoid_t<unsigned long long>>(n);\n    while (q--) {\n        int c;\n        std::cin >> c;\n\n        if (c==0) {\n            std::size_t u;\n            unsigned long long w;\n            std::cin >> u >> w;\n\n            seg.set(hld.vid.at(u), seg.at(hld.vid.at(u)) + w);\n        }\n\n        if (c==1) {\n            std::size_t u, v;\n            std::cin >> u;\n            v = root;\n\n            unsigned long long ans = 0;\n\n            while (u!=v) {\n                if (hld.vid.at(u) > hld.vid.at(v)) {\n                    std::swap(u, v);\n                }\n                if (hld.head.at(u) == hld.head.at(v)) {\n                    ans += seg.fold(hld.vid.at(u)+1, hld.vid.at(v)+1);\n                    break;\n                }\n                ans += seg.fold(hld.vid.at(hld.head.at(v)), hld.vid.at(v)+1);\n                v = prt.at(hld.head.at(v));\n            }\n\n            std::cout << ans << '\\n';\n        }\n    }\n}\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename G >\nstruct CentroidPathDecomposition {\n  struct Centroid {\n    int ParIndex, ParDepth, Deep;\n    vector< int > node;\n\n    Centroid(int idx, int dep, int deep) : ParIndex(idx), ParDepth(dep), Deep(deep) {}\n\n    inline size_t size() {\n      return (node.size());\n    }\n\n    inline int &operator[](int k) {\n      return (node[k]);\n    }\n\n    inline pair< int, int > Up() {\n      return (make_pair(ParIndex, ParDepth));\n    }\n  };\n\n  const G &graph;\n  vector< int > SubTreeSize, NextPath;\n  vector< int > TreeIndex, TreeDepth;\n  vector< Centroid > Centroids;\n\n  void BuildSubTreeSize() {\n    stack< pair< int, int > > s;\n    s.emplace(0, -1);\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      if(~SubTreeSize[p.first]) {\n        NextPath[p.first] = -1;\n        for(auto &to : graph[p.first]) {\n          if(p.second == to) continue;\n          SubTreeSize[p.first] += SubTreeSize[to];\n          if(NextPath[p.first] == -1 || SubTreeSize[NextPath[p.first]] < SubTreeSize[to]) {\n            NextPath[p.first] = to;\n          }\n        }\n      } else {\n        s.push(p);\n        SubTreeSize[p.first] = 1;\n        for(auto &to : graph[p.first]) {\n          if(p.second != to) s.emplace(to, p.first);\n        }\n      }\n    }\n  }\n\n  void BuildPath() {\n    stack< pair< int, int > > s;\n    Centroids.emplace_back(-1, -1, 0);\n    s.emplace(0, -1);\n    TreeIndex[0] = 0;\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      TreeDepth[p.first] = (int) Centroids[TreeIndex[p.first]].size();\n      for(auto &to : graph[p.first]) {\n        if(p.second == to) continue;\n        if(to == NextPath[p.first]) { // Centroid-Path\n          TreeIndex[to] = TreeIndex[p.first];\n        } else {                  // Not Centroid-Path\n          TreeIndex[to] = (int) Centroids.size();\n          Centroids.emplace_back(TreeIndex[p.first], TreeDepth[p.first], Centroids[TreeIndex[p.first]].Deep + 1);\n        }\n        s.emplace(to, p.first);\n      }\n      Centroids[TreeIndex[p.first]].node.emplace_back(p.first);\n    }\n  }\n\n\n  virtual void Build() {\n    BuildSubTreeSize();\n    BuildPath();\n  }\n\n  inline size_t size() {\n    return (Centroids.size());\n  }\n\n  inline pair< int, int > Information(int idx) {\n    return (make_pair(TreeIndex[idx], TreeDepth[idx]));\n  }\n\n  inline Centroid &operator[](int k) {\n    return (Centroids[k]);\n  }\n\n  inline int LCA(int a, int b) {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    return (Centroids[TreeIdxA][TreeDepthA]);\n  }\n\n  inline virtual void query(int a, int b, const function< void(int, int, int) > &f) {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        f(TreeIdxA, 0, TreeDepthA + 1);\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        f(TreeIdxB, 0, TreeDepthB + 1);\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    f(TreeIdxA, TreeDepthA, TreeDepthB + 1);\n  }\n\n  CentroidPathDecomposition(const G &g) : graph(g) {\n    int SZ = g.size();\n    SubTreeSize.assign(SZ, -1);\n    NextPath.resize(SZ);\n    TreeIndex.resize(SZ);\n    TreeDepth.resize(SZ);\n  }\n};\n\ntemplate< typename G >\nstruct TreeArray : CentroidPathDecomposition< G > {\n  using CPD = CentroidPathDecomposition< G >;\n\n  TreeArray(const G &g) : CPD(g) {}\n\n  vector< int > index;\n\n  void Build() {\n    CPD::Build();\n    int ptr = 0;\n    for(auto &centroid : CPD::Centroids) {\n      index.emplace_back(ptr);\n      ptr += centroid.size();\n    }\n  }\n\n  inline int get(int a) {\n    auto p = CPD::Information(a);\n    return (index[p.first] + p.second);\n  }\n\n  inline void query(int a, int b, const function< void(int, int) > &f) {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = CPD::Information(a);\n    tie(TreeIdxB, TreeDepthB) = CPD::Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(CPD::Centroids[TreeIdxA].Deep > CPD::Centroids[TreeIdxB].Deep) {\n        f(index[TreeIdxA], index[TreeIdxA] + TreeDepthA + 1);\n        tie(TreeIdxA, TreeDepthA) = CPD::Centroids[TreeIdxA].Up();\n      } else {\n        f(index[TreeIdxB], index[TreeIdxB] + TreeDepthB + 1);\n        tie(TreeIdxB, TreeDepthB) = CPD::Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    f(index[TreeIdxA] + TreeDepthA + 1, index[TreeIdxA] + TreeDepthB + 1);\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree {\n  vector< T > data;\n\n  BinaryIndexedTree(int sz) {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k) {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret += data[k];\n    return (ret);\n  }\n\n  void add(int k, T x) {\n    for(++k; k < data.size(); k += k & -k) data[k] += x;\n  }\n};\n\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  UnWeightedGraph g(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      g[i].emplace_back(x);\n    }\n  }\n  TreeArray< UnWeightedGraph > tree(g);\n  tree.Build();\n  scanf(\"%d\", &Q);\n  BinaryIndexedTree< int > bit(N);\n  while(Q--) {\n    int T;\n    scanf(\"%d\", &T);\n    if(T == 0) {\n      int V, W;\n      scanf(\"%d %d\", &V, &W);\n      bit.add(tree.get(V), W);\n    } else {\n      int U;\n      scanf(\"%d\", &U);\n      int ret = 0;\n      tree.query(0, U, [&](int x, int y) {\n        ret += bit.sum(y - 1) - bit.sum(x - 1);\n      });\n      printf(\"%d\\n\", ret);\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<bits/stdc++.h>\nusing namespace std;\nconst int MAX=1e5+9;\nint in[MAX],out[MAX];\nint vis[MAX],bit[MAX];\nvector<int>adj[MAX];\nint tim=0;\nvoid init(int n ){\n\tfor(int i=0;i<n+1;i++){\n\t\tbit[i]=0;\n\t\tvis[i]=0;\n\t}\n}\nvoid update(int x,  int y, int w){\n\tfor(int i=x;i<=y;i+=i&(-i)){\n\t\tbit[i]=bit[i]+w;\n\t//\tcout<<i<<\" \";\n\t}\n\t//cout<<\"\\n\";\n}\nint query(int x){\n\tint sum=0;\n\tfor(int i=x;i>0;i-=i&(-i)){\n\t\tsum=sum+bit[i];\n\t}\n\treturn sum;\n}\nvoid dfs(int s){\n\tvis[s]=1;\n\tin[s]=tim++;\n\tfor(int i=0;i<adj[s].size();i++){\n\t\tif(!vis[adj[s][i]]){\n\t\t\tdfs(adj[s][i]);\n\t\t}\n\t}\n\tout[s]=tim++;\n\n}\nint main(){\n\tint n;\n\tcin>>n;\n\tinit(n);\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\tfor(int j=0;j<k;j++){\n\t\t\tint a;\n\t\t\tcin>>a;\n\t\t\tadj[i].push_back(a);\n\t\t\tadj[a].push_back(i);\n\t\t}\n\t}\n\tdfs(0);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tint u,w,t;\n\t\tcin>>t;\n\t\t//cout<<13234;\n\t\tif(t==0){\n\t\t\tcin>>u>>w;\n\t\t\t//cout<<in[u]<<\" \"<<out[u]<<\"\\n\";\n\t\t\tupdate(in[u],out[u],w);\n\t\t}\n\t\telse {\n\t\t\tcin>>u;\n\t\t\tint p=query(in[u]);\n\t//\t\tcout<<in[u]<<\" \";\n\t\t\tcout<<p<<\"\\n\";\n\t\t}\n\t}\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cassert>\n#include<ctime>\n#include<utility>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 1000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\n#define P_TYPE int\ntypedef pair<P_TYPE, P_TYPE> P;\ntypedef pair<P, P_TYPE> PI;\ntypedef pair<P_TYPE, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n#define N 100003\n\nclass LinkCutTree {\n  int n;\n  int prt[N], left[N], right[N], sz[N], rev[N];\n  ll key[N], val[N];\n\n  void update(int i, int l, int r) {\n    sz[i] = 1 + sz[l] + sz[r];\n    val[i] = key[i] + val[l] + val[r];\n  }\n\n  void node_swap(int i) {\n    if(i) {\n      swap(left[i], right[i]);\n      rev[i] ^= 1;\n    }\n  }\n\n  bool prop(int i) {\n    if(rev[i]) {\n      node_swap(left[i]); node_swap(right[i]);\n      rev[i] = 0;\n      return true;\n    }\n    return false;\n  }\n\n  void splay(int i) {\n    int x = prt[i];\n    prop(i);\n\n    int li = left[i], ri = right[i];\n    while(x && (left[x] == i || right[x] == i)) {\n      int y = prt[x];\n      if(!y || (left[y] != x && right[y] != x)) {\n        if(prop(x)) {\n          swap(li, ri);\n          node_swap(li); node_swap(ri);\n        }\n\n        if(left[x] == i) {\n          left[x] = ri;\n          prt[ri] = x;\n          update(x, ri, right[x]);\n          ri = x;\n        } else {\n          right[x] = li;\n          prt[li] = x;\n          update(x, left[x], li);\n          li = x;\n        }\n        x = y;\n        break;\n      }\n\n      prop(y);\n      if(prop(x)) {\n        swap(li, ri);\n        node_swap(li); node_swap(ri);\n      }\n\n      int z = prt[y];\n      if(left[y] == x) {\n        if(left[x] == i) {\n          int v = left[y] = right[x];\n          prt[v] = y;\n          update(y, v, right[y]);\n\n          left[x] = ri; right[x] = y;\n          prt[ri] = x;\n          update(x, ri, y);\n\n          prt[y] = ri = x;\n        } else {\n          left[y] = ri;\n          prt[ri] = y;\n          update(y, ri, right[y]);\n\n          right[x] = li;\n          prt[li] = x;\n          update(x, left[x], li);\n\n          li = x; ri = y;\n        }\n      } else {\n        if(right[x] == i) {\n          int v = right[y] = left[x];\n          prt[v] = y;\n          update(y, left[y], v);\n\n          left[x] = y; right[x] = li;\n          prt[li] = x;\n          update(x, y, li);\n\n          prt[y] = li = x;\n        } else {\n          right[y] = li;\n          prt[li] = y;\n          update(y, left[y], li);\n\n          left[x] = ri;\n          prt[ri] = x;\n          update(x, ri, right[x]);\n\n          li = y; ri = x;\n        }\n      }\n      x = z;\n      if(left[x] == y) {\n        left[z] = i;\n        update(z, i, right[z]);\n      } else if(right[z] == y) {\n        right[z] = i;\n        update(z, left[z], i);\n      } else break;\n    }\n\n    update(i, li, ri);\n    left[i] = li; right[i] = ri;\n    prt[li] = prt[ri] = i;\n    prt[i] = x;\n\n    rev[i] = prt[0] = 0;\n  }\n\npublic:\n  int expose(int i) {\n    int p = 0, cur = i;\n    while(cur) {\n      splay(cur);\n      right[cur] = p;\n      update(cur, left[cur], p);\n      p = cur;\n      cur = prt[cur];\n    }\n    splay(i);\n    return i;\n  }\n\n  int cut(int i) {\n    expose(i);\n    int p = left[i];\n    left[i] = prt[p] = 0;\n    return p;\n  }\n\n  int link(int i, int p) {\n    expose(i);\n    expose(p);\n    prt[i] = p;\n    right[p] = i;\n  }\n\n  int evert(int i) {\n    expose(i);\n    node_swap(i);\n    prop(i);\n  }\n\n  LinkCutTree(int n) {\n    rep(i, n+1) prt[i] = left[i] = right[i] = rev[i] = 0, sz[i] = 1;\n    sz[0] = 0; left[0] = right[0] = -1;\n  }\n\n  ll query(int v) {\n    int r = expose(v+1);\n    return val[r];\n  }\n\n  void query_add(int v, int w) {\n    key[v+1] += w;\n    expose(v+1);\n  }\n};\n\nint main() {\n  int n; cin >> n;\n  LinkCutTree lct(n);\n  rep(i, n) {\n    int k; cin >> k;\n    rep(j, k) {\n      int c; cin >> c;\n      lct.link(c+1, i+1);\n    }\n  }\n  int q; cin >> q;\n  rep(i, q) {\n    int t; cin >> t;\n    if(t) {\n      int u; cin >> u;\n\n      cout << lct.query(u) << endl;\n    } else {\n      int v, w; cin >> v >> w;\n      lct.query_add(v, w);\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n\nvector<int> euler;\nvector<pair<int, int>> r;\nvector<vector<int>> G;\n\nvoid dfs(int v, int p = -1) {\n    euler.push_back(v);\n    r[v].first = euler.size() - 1;\n    for (int u : G[v]) {\n        if (u == p) continue;\n        dfs(u, v);\n        euler.push_back(v);\n    }\n    r[v].second = euler.size() - 1;\n}\n\n// RAQ and RSQ\n// varify : https://onlinejudge.u-aizu.ac.jp/courses/library/3/DSL/2/DSL_2_G\ntemplate<typename Monoid>\nstruct LazySegmentTree {\nprivate:\n    using Func = std::function<Monoid(Monoid, Monoid)>;\n    Func F = [](Monoid a, Monoid b) { return a + b; };\n    Monoid UNITY = 0;\n    int n;\n    std::vector<Monoid> node, lazy;\n\n    // propagation\n    void eval(int k, int l, int r) {\n        if (lazy[k] != 0) {\n            node[k] += lazy[k];\n            if (r - l > 1) {\n                lazy[2 * k + 1] += lazy[k] / 2;\n                lazy[2 * k + 2] += lazy[k] / 2;\n            }\n            lazy[k] = 0;\n        }\n    }\npublic:\n    LazySegmentTree() {}\n\n    LazySegmentTree(int m) {\n        build(m);\n    }\n\n    LazySegmentTree(const std::vector<Monoid>& v) {\n        build(v);\n    }\n\n    void build(int m) {\n        n = 1; while (n < m) n <<= 1;\n        node.resize(n * 2 - 1, UNITY);\n        lazy.resize(n * 2 - 1, 0);\n    }\n\n    void build(const std::vector<Monoid>& v) {\n        int sz = v.size();\n        n = 1; while (n < sz) n <<= 1;\n        node.resize(n * 2 - 1, UNITY);\n        lazy.resize(n * 2 - 1, 0);\n        for (int i = 0; i < sz; i++) node[i + n - 1] = v[i];\n        for (int i = n - 2; i >= 0; i--) node[i] = F(node[2 * i + 1], node[2 * i + 2]);\n    }\n\n    // [a,b)\n    void add(int a, int b, Monoid x, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        eval(k, l, r);\n\n        // out of range\n        if (b <= l || r <= a) return;\n\n        if (a <= l && r <= b) {\n            lazy[k] += (r - l) * x;\n            eval(k, l, r);\n        }\n        else {\n            add(a, b, x, 2 * k + 1, l, (r - l) / 2 + l);\n            add(a, b, x, 2 * k + 2, (r - l) / 2 + l, r);\n            node[k] = F(node[2 * k + 1], node[2 * k + 2]);\n        }\n    }\n\n    // [a,b)\n    Monoid query(int a, int b, int k = 0, int l = 0, int r = -1) {\n        if (r < 0) r = n;\n        if (r <= a || b <= l) return UNITY;\n        eval(k, l, r);\n        if (a <= l && r <= b) return node[k];\n        Monoid vl = query(a, b, 2 * k + 1, l, (r - l) / 2 + l);\n        Monoid vr = query(a, b, 2 * k + 2, (r - l) / 2 + l, r);\n        return F(vl, vr);\n    }\n\n    Monoid operator[](int x) {\n        return query(x, x + 1);\n    }\n\n    void print() {\n        for (int i = 0; i < n; i++) {\n            std::cout << i << \"\\t: \" << query(i, i + 1) << std::endl;\n        }\n    }\n};\n\nint main() {\n    int n; cin >> n;\n    r.resize(n);\n    G.resize(n);\n    for (int i = 0; i < n; i++) {\n        int k; cin >> k;\n        for (int j = 0; j < k; j++) {\n            int c; cin >> c;\n            G[i].push_back(c);\n            G[c].push_back(i);\n        }\n    }\n    dfs(0);\n    LazySegmentTree<ll> seg(euler.size());\n    int q; cin >> q;\n    for (int _ = 0; _ < q; _++) {\n        int c; cin >> c;\n        if (c == 0) {\n            int v, w; cin >> v >> w;\n            seg.add(r[v].first, r[v].second + 1, w);\n        }\n        else {\n            int u; cin >> u;\n            cout << seg[r[u].first] << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\nstatic const int MAX_N = 100000;\n\nint n, q;\nvector<int> G[MAX_N];\n\nint id[MAX_N];\nint es[2 * (MAX_N - 1)];\n\nll bit[MAX_N + 1];\n\nvoid dfs(int v, int p, int &k){\n\tid[v] = k;\n\tk++;\n\tfor(int i = 0; i < G[v].size(); i++){\n\t\tint to = G[v][i];\n\t\tif(to != p){\n\t\t\tes[2 * to] = k;\n\t\t\tdfs(to, v, k);\n\t\t\tes[2 * to + 1] = k;\n\t\t}\n\t}\n}\nvoid init(){\n\tint k = 0;\n\tdfs(0, -1, k);\n}\n\nll sum(int i){\n\tll s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\nvoid add(int i, ll x){\n\twhile(i <= n){\n\t\tbit[i] += x;\n\t\ti += i & -i;\n\t}\n}\nint main(){\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n; i++){\n\t\tint k;\n\t\tscanf(\"%d\", &k);\n\t\tfor(int j = 0; j < k; j++){\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tinit();\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q; i++){\n\t\tint op;\n\t\tscanf(\"%d\", &op);\n\t\tif(op == 0){\n\t\t\tint v;\n\t\t\tll w;\n\t\t\tscanf(\"%d %lld\", &v, &w);\n\t\t\tadd(es[2 * v], w);\n\t\t\tadd(es[2 * v + 1], -w);\n\t\t}else{\n\t\t\tint u;\n\t\t\tscanf(\"%d\", &u);\n\t\t\tprintf(\"%lld\\n\", sum(id[u]));\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma region Macro\n#pragma region Basic\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef vector<vi> vvi;\ntypedef vector<vl> vvl;\n#define REP(i, n) for (int i = 0, i##_len = (n); i < i##_len; ++i)\n#define FOR(i, a, b) for (int i = (a), i##_len = (b); i < i##_len; i++)\n#define FORD(i, a, b) for (int i = (a), i##_len = (b); i > i##_len; i--)\n#define FORR(t, a) for (auto t : a)\n#define ALL(x) (x).begin(), (x).end()  // sortなどの引数を省略したい\n#define GET(i, j) get<j>(i)\n#define MT(x, ...) make_tuple(x, __VA_ARGS__)\n#define SZ(x) ((int)(x).size())\n//#define ZERO(x) memset(x, 0, sizeof(x))\n//#define FILL(x, y) memset(x, y, sizeof(x))\n#define UNUSED(x) (void(x));\n#define PB push_back\n#define EB emplace_back\n#ifdef _DEBUG\n#define PRE_COMMAND             \\\n    std::cin.rdbuf(in.rdbuf()); \\\n    cout << fixed << setprecision(15);\n#else\n#define PRE_COMMAND cout << fixed << setprecision(15);\n#endif\nconst double EPS = 1e-10;\nconst double PI = acos(-1.0);\ntemplate <class T>\nauto MAX(T& seq) {\n    return *max_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto MIN(T& seq) {\n    return *min_element(seq.begin(), seq.end());\n}\ntemplate <class T>\nauto SUM(T& seq) {\n    T temp{0};\n    auto& temp2 = temp[0];\n    return accumulate(seq.begin(), seq.end(), temp2);\n}\ntemplate <class T>\nvoid SORT(T& seq) {\n    sort(seq.begin(), seq.end());\n}\ntemplate <class T, class S>\nvoid SORT(T& seq, S& sort_order) {\n    sort(seq.begin(), seq.end(), sort_order);\n}\ntemplate <class T>\nvoid SORTR(vector<T>& seq) {\n    sort(seq.begin(), seq.end(), greater<T>());\n}\ntemplate <class T>\nvoid CHMAX(T& a, const T& b) {\n    if (a < b) { a = b; }\n}\ntemplate <class T>\nvoid CHMIN(T& a, const T& b) {\n    if (b < a) { a = b; }\n}\ntemplate <class T>\nset<T> VECTOR_2_SET(vector<T>& v) {\n    set<T> s;\n    for (auto ele : v) { s.insert(ele); }\n    return s;\n}\ntemplate <class T>\nvector<T> SET_2_VECTOR(set<T>& s) {\n    vector<T> v;\n    for (auto ele : s) { v.push_back(ele); }\n    return v;\n}\n#pragma endregion Basic\n#pragma region overload\ntemplate <class T, class S>\nvoid operator+=(vector<T>& l, S& r) {\n    for (auto i : r) { l.push_back(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(set<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvoid operator+=(multiset<T>& l, S& r) {\n    for (auto i : r) { l.insert(i); }\n}\ntemplate <class T, class S>\nvector<T> operator+(vector<T>& l, S& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T>\nvector<T> operator+(const vector<T> l, const vector<T>& r) {\n    vector<T> l_copy = l;\n    for (auto i : r) { l_copy.push_back(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nset<T> operator+(set<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nset<T> operator+(const set<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T, class S>\nmultiset<T> operator+(multiset<T>& l, S& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\ntemplate <class T>\nmultiset<T> operator+(const multiset<T> l, const set<T>& r) {\n    set<T> l_copy = l;\n    for (auto i : r) { l_copy.insert(i); }\n    return l_copy;\n}\nstring operator+(const string l, const string& r) {\n    string str = l;\n    str += r;\n    return str;\n}\nstring operator*(const string l, const size_t& r) {\n    string str = l;\n    for (size_t i = 0; i < r; i++) { str += l; }\n    return str;\n}\n#pragma endregion overload\n#pragma region Input\ntemplate <class Head>\nvoid INPUT(vector<Head>& head);\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head);\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t);\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t);\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t);\ntemplate <class Head>\nvoid INPUT(Head& head);\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail);\n//本体\ntemplate <class Head>\nvoid INPUT(vector<Head>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <size_t N, class Head>\nvoid INPUT(array<Head, N>& head) {\n    for (size_t i = 0; i < head.size(); i++) { INPUT(head[i]); }\n}\ntemplate <class T1>\nvoid INPUT(tuple<T1>& t) {\n    cin >> get<0>(t);\n}\ntemplate <class T1, class T2>\nvoid INPUT(tuple<T1, T2>& t) {\n    cin >> get<0>(t) >> get<1>(t);\n}\ntemplate <class T1, class T2, class T3>\nvoid INPUT(tuple<T1, T2, T3>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t);\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid INPUT(tuple<T1, T2, T3, T4>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t);\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid INPUT(tuple<T1, T2, T3, T4, T5>& t) {\n    cin >> get<0>(t) >> get<1>(t) >> get<2>(t) >> get<3>(t) >> get<4>(t);\n}\ntemplate <class Head>\nvoid INPUT(Head& head) {\n    cin >> head;\n}\ntemplate <class Head, class... Tail>\nvoid INPUT(Head& head, Tail&... tail) {\n    INPUT(head);\n    INPUT((tail)...);\n}\n#pragma endregion Input\n#pragma region Print\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t);\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t);\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t);\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t);\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t);\ntemplate <class Head>\nvoid PRINT2(vector<Head> head);\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head);\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head);\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head);\ntemplate <class Head>\nvoid PRINT2(Head head);\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail);\ntemplate <class Head>\nvoid PRINT(Head head);\ntemplate <class... Head>\nvoid PRINT(Head... head);\ntemplate <int N, class Head>\nvoid PRINT(Head head);\ntemplate <class T1>\nvoid PRINT2(tuple<T1> t) {\n    PRINT2(get<0>(t));\n}\ntemplate <class T1, class T2>\nvoid PRINT2(tuple<T1, T2> t) {\n    PRINT2(get<0>(t), get<1>(t));\n}\ntemplate <class T1, class T2, class T3>\nvoid PRINT2(tuple<T1, T2, T3> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t));\n}\ntemplate <class T1, class T2, class T3, class T4>\nvoid PRINT2(tuple<T1, T2, T3, T4> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t));\n}\ntemplate <class T1, class T2, class T3, class T4, class T5>\nvoid PRINT2(tuple<T1, T2, T3, T4, T5> t) {\n    PRINT2(get<0>(t), get<1>(t), get<2>(t), get<3>(t), get<4>(t));\n}\ntemplate <class Head>\nvoid PRINT2(vector<Head> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(vector<vector<Head>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(vector<array<Head, N>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <class... Head>\nvoid PRINT2(vector<tuple<Head...>> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << endl; }\n    }\n}\ntemplate <size_t N, class Head>\nvoid PRINT2(array<Head, N> head) {\n    for (auto i = head.begin(); i != head.end(); i++) {\n        PRINT2(*i);\n        if (i != head.end() - 1) { cout << \" \"; }\n    }\n}\ntemplate <class Head>\nvoid PRINT2(Head head) {\n    cout << head;\n}\ntemplate <class Head, class... Tail>\nvoid PRINT2(Head head, Tail... tail) {\n    PRINT2(head);\n    cout << \" \";\n    PRINT2((tail)...);\n}\ntemplate <class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\ntemplate <class... Head>\nvoid PRINT(Head... head) {\n    PRINT2((head)...);\n    cout << endl;\n}\ntemplate <int N, class Head>\nvoid PRINT(Head head) {\n    PRINT2(head);\n    cout << endl;\n}\n#pragma endregion Print\n#pragma endregion Macro\n\n// ini：上限（下限）,base：元の配列,monoid：モノイド,tree：セグ木,depth：treeの深さ,\n// basesize：baseの要素数,treesize：treeの要素数,num：treesize-basesize\n// 初期値（上限とか下限）を決定\ntemplate <class num_type>\nstruct segtree {\n    int num, depth, basesize, treesize;\n    vector<num_type> base, tree;\n    using func_type = num_type(num_type&, num_type&);\n    num_type (*monoid)(num_type& a, num_type& b);\n    num_type ini;\n    // 元の配列, モノイド, 初期値\n    segtree(vector<num_type> tmp1, func_type tmp2, num_type tmp3)\n        : base(tmp1), monoid(tmp2), ini(tmp3) {\n        basesize = (int)base.size();\n        num = 1;\n        depth = 1;\n        while (num < basesize) {\n            num *= 2;\n            depth++;\n        }\n        num -= 1;\n        treesize = num * 2 + 1;\n        tree.assign(treesize, ini);\n        for (int i = num; i < num + basesize; i++) { tree[i] = base[i - num]; }\n        for (int i = num + basesize; i < treesize; i++) { tree[i] = ini; }\n        for (int i = num - 1; i > -1; i--) {\n            tree[i] = monoid(tree[2 * i + 1], tree[2 * i + 2]);\n        }\n    }\n    // 条件を満たす(サンプルの条件はs以下になること)最大のインデックスを返す関数\n    template <class func_type2>\n    int max_index(func_type2 index_func) {\n        int i = 0;\n        while (i < num) {\n            int k = 2 * i + 1;\n            if (index_func(tree[k + 1])) {\n                i = k + 1;\n                continue;\n            }\n            if (index_func(tree[k])) {\n                i = k;\n                continue;\n            }\n            return -1;\n        }\n        return i - num;\n    }\n    template <class func_type2>\n    int min_index(func_type2 index_func) {\n        int i = 0;\n        while (i < num) {\n            int k = 2 * i + 1;\n            if (index_func(tree[k])) {\n                i = k;\n                continue;\n            }\n            if (index_func(tree[k + 1])) {\n                i = k + 1;\n                continue;\n            }\n            return -1;\n        }\n        return i - num;\n    }\n\n    // 半開区間[lower,upper)の最小値（とか）を探す関数\n    num_type search(int lower, int upper) {\n        num_type ret = ini;\n        int l = lower + num;\n        int r = upper + num;\n        while (l < r) {\n            if (r % 2 == 0) {\n                r--;\n                ret = monoid(ret, tree[r]);\n            }\n            if (l % 2 == 0) {\n                ret = monoid(ret, tree[l]);\n                l++;\n            }\n            l /= 2;\n            r /= 2;\n        }\n        return ret;\n    }\n\n    // base[i]をsに更新してセグ木全体を更新する関数\n    void update(int index, num_type new_value) {\n        int i = index + num;\n        tree[i] = new_value;\n        while (i) {\n            i = (i - 1) / 2;\n            num_type temp = monoid(tree[2 * i + 1], tree[2 * i + 2]);\n            if (tree[i] != temp) {\n                tree[i] = temp;\n                continue;\n            }\n            break;\n        }\n    }\n\n    // 和がw以上となる最小のインデックスを求める\n    int lowerbound(num_type w) {\n        if (w <= 0) { return 0; }\n        if (w > tree[0]) { return basesize; }\n        int x = 0;\n        for (int i = 0; i < depth - 1; i++) {\n            if (tree[2 * x + 1] < w) {\n                w -= tree[2 * x + 1];\n                x = 2 * x + 2;\n            } else {\n                x = 2 * x + 1;\n            }\n        }\n        return x - num;\n    }\n};\n\nstruct euler_tour_vertex {\n    using value_type = int;\n    int n, start;\n    vector<vector<int>> g;\n    vector<int> in_, out;\n    euler_tour_vertex(vector<vector<int>>& tmp1, int tmp2) {\n        g = tmp1;\n        start = tmp2;\n        n = (int)g.size();\n        int i, u, v, cnt = 0;\n        vector<int> count(n, 0), stack = {-1, start};\n        in_.assign(n, -1);\n        out.assign(n, -1);\n        while (stack.size() > 1) {\n            u = stack.back();\n            i = count[u];\n            if (i == 0) { in_[u] = cnt; }\n            if (i >= (int)g[u].size()) {\n                stack.pop_back();\n                out[u] = cnt++;\n                continue;\n            }\n            v = g[u][count[u]++];\n            if (v == stack[(int)stack.size() - 2]) { continue; }\n            cnt++;\n            stack.push_back(v);\n        }\n    }\n    // idxとidxの親を結ぶ辺の重みを取得\n    template <class T>\n    value_type get_in(T& seg, int& idx) {\n        return seg.search(in_[idx], in_[idx] + 1);\n    }\n    // idxとidxの親を結ぶ辺の重みの逆元を取得\n    template <class T>\n    value_type get_out(T& seg, int& idx) {\n        return seg.search(out[idx] + 1, out[idx] + 2);\n    }\n    // 根からidxまでのパスの重みの総和を出力\n    template <class T>\n    value_type search(T& seg, int& idx) {\n        return seg.search(0, in_[idx] + 1);\n    }\n    // idxの親からidxへの辺に重みwを加算\n    template <class T>\n    void add(T& seg, int& idx, value_type& w) {\n        seg.update(in_[idx], w + get_in(seg, idx));\n        seg.update(out[idx] + 1, -w + get_out(seg, idx));\n    }\n};\n\nint main() {\n    PRE_COMMAND\n    int n, x, y, k, q;\n    INPUT(n);\n    vector<int> temp(2 * n + 1, 0);\n    vector<vector<int>> g(n);\n    vector<int> parent(n, -1);\n    for (int i = 0; i < n; i++) {\n        cin >> k;\n        for (int j = 0; j < k; j++) {\n            cin >> x;\n            g[i].push_back(x);\n            parent[x] = i;\n        }\n    }\n    euler_tour_vertex et(g, 0);\n    segtree<int> seg(\n        temp, [](auto& a, auto& b) { return a + b; }, 0);\n    INPUT(q);\n    for (int i = 0; i < q; i++) {\n        INPUT(k, x);\n        if (k == 0) {\n            INPUT(y);\n            et.add(seg, x, y);\n        } else {\n            PRINT(et.search(seg, x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n\n#define lson l, m, o<<1\n#define rson m + 1, r, o<<1|1\n\ntypedef long long LL;\n\nconst int N = 1e5 + 1;\n\nint n;\nint cnt;\nstd::vector<int> G[N];\nint id[N << 1];\nLL sum[N << 3];\n\nvoid dfs(int u, int p) {\n  id[u] = cnt;\n  cnt ++;\n  for (int &to : G[u]) {\n    if (to != p) {\n      dfs(to, u);\n    }\n  }\n  id[u + n] = cnt;\n  cnt ++;\n}\n\nvoid up(int o) {\n  sum[o] = sum[o << 1] + sum[o << 1 | 1];\n}\n\nvoid modify(int x, int v, int l, int r, int o) {\n  if (l == r) {\n    sum[o] += v;\n    return ;\n  }\n  int m = (l + r) >> 1;\n  if (x <= m) modify(x, v, lson);\n  else if (x > m) modify(x, v, rson);\n  up(o);\n}\n\nLL get(int L, int R, int l, int r, int o) {\n  if (L <= l && R >= r) return sum[o];\n  int m = (l + r) >> 1;\n  LL res = 0;\n  if (L <= m) res += get(L, R, lson);\n  if (R > m) res += get(L, R, rson);\n  return res;\n}\n\nint main() {\n  std::cin >> n;\n  for (int i = 0; i < n; ++i) {\n    int k;\n    std::cin >> k;\n    for (int j = 0; j < k; ++j) {\n      int x;\n      std::cin >> x;\n      G[i].emplace_back(x);\n    }\n  }\n  cnt = 1;\n  dfs(0, 0);\n  memset(sum, 0, sizeof(sum));\n  int q;\n  std::cin >> q;\n  while (q --) {\n    int op;\n    std::cin >> op;\n    if (op == 0) {\n      int v, c;\n      std::cin >> v >> c;\n      modify(id[v], c, 1, 2 * n,  1);\n      modify(id[v + n], -c, 1, 2 * n, 1);\n    } else {\n      int v;\n      std::cin >> v;\n      std::cout << get(1, id[v], 1, 2 * n, 1) << std::endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nclass BIT{\npublic:\n  typedef long long ll;\n  ll n;\n  vector<ll> bit0, bit1;\n  BIT(){n=-1;}\n  BIT(ll n_){\n    n=1;\n    while(n<n_)n*=2;\n    bit0.resize(n+1,0);\n    bit1.resize(n+1,0);\n  }\n  \n  ll sum(vector<ll> &b,ll i){\n    ll s=0;\n    while(i>0){\n      s=(s+b[i]);\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(vector<ll> &b,ll i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v);\n      i+=i&-i;\n    }\n  }\n\n  //[a,b]にxを加算(1<=a)\n  void add (ll a,ll b,ll x){\n    assert(a > 0 && n >= 0);\n\n    add(bit0,a,-x*(a-1));\n    add(bit1,a,x);\n    add(bit0,b+1,x*b);\n    add(bit1,b+1,-x);\n  }\n\n  //[a,b]のsumを得る(1<=a)\n  ll sum(ll a,ll b){\n    assert(a > 0 && n >= 0);\n    ll res=0;\n    res+=sum(bit0,b)+sum(bit1,b)*b;\n    res-=sum(bit0,a-1)+sum(bit1,a-1)*(a-1);\n    return res;\n  }\n};\n\nvector<int> G[100005];\nvector<int> order;\nint s[100005], t[100005];\n\nvoid dfs(int x){\n  \n  s[x]=(int)order.size()+1;\n  \n  order.push_back(x);\n  \n  for(int i=0;i<G[x].size();i++) dfs(G[x][i]);\n\n  t[x]=(int)order.size()+1;\n}\n\nsigned main(){\n  \n  int n;  \n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      G[i].push_back(c);\n  \n    }\n  }\n\n  dfs(0);\n\n  BIT bit=BIT(n);\n  \n  int q;\n  cin>>q;\n  \n  while(q--){\n    \n    int a;\n    cin>>a;\n\n    if(a==0){\n      int v, w;\n      cin>>v>>w;\n      bit.add(s[v], t[v], w);\n    }\n    else{\n      int u;\n      cin>>u;\n      cout<<bit.sum(s[u], s[u])<<endl;\n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef double db;\ntypedef vector<ll> VLL;\ntypedef vector<VLL> VVLL;\ntypedef pair<ll,ll> PLL;\n\n#define REP(x,l,u) for(ll x = l; x < u; x++)\n#define RREP(x,l,u) for(ll x = l; x >= u; x--)\n#define all(x) x.begin(), x.end()\n#define rall(x) x.rbegin(), x.rend()\n#define mst(x,v) memset(x, v, sizeof(x))\n#define sz(x) (ll)x.size()\n\nstring to_string(string s) {return s;}\nstring to_string(char c) {string s = string(1, c);return s;}\ntemplate <typename A, typename B> string to_string(pair<A,B> p) { return \"(\" + to_string(p.first) + \", \" + to_string(p.second) + \")\"; }\ntemplate <typename A> string to_string(vector<A> v) { string s = \"(\"; int first = 1; for (A a : v) { if (!first) { s += \", \"; } first = 0; s += to_string(a); } s += \")\"; return s; }\ntemplate <typename A> string to_string(set<A> v) { string s = \"(\"; int first = 1; for (A a : v) { if (!first) { s += \", \"; } first = 0; s += to_string(a); } s += \")\"; return s; }\n\nvoid debug_out() {cerr << endl;}\ntemplate <typename Head, typename... Tail> void debug_out(Head H, Tail... T) { cerr << \" \" << to_string(H); debug_out(T...); }\n\nvoid in() {}\ntemplate <typename A> void in(A & x) { cin >> x; }\ntemplate <typename A, typename B> void in(pair<A,B> & x) { in(x.first); in(x.second); }\ntemplate <typename A> void in(vector<A> & x) { REP(i,0,(ll)x.size()) in(x[i]); }\ntemplate <typename Head, typename... Tail> void in(Head & H, Tail & ... T) {in(H); in(T...); }\n\n#ifndef ONLINE_JUDGE\n#define debug(...) do { cerr << \"[\" << #__VA_ARGS__ << \"]:\", debug_out(__VA_ARGS__); } while (false)\n#else\n#define debug(...) do { } while (false)\n#endif\n\nconst ll inf = (ll)1e18 + 5;\nconst ll mod = 1e9+7;\n\n#define lsb(i) ((i)&-(i))\n\nll nax = 2e5 + 5;\nVLL arr(nax);\n\nvoid add(ll i, ll k) {\n    while (i < nax) {\n        arr[i] += k;\n        i += lsb(i);\n    }\n}\n\nll sum(ll i) {\n    ll total = 0;\n    while (i > 0) {\n        total += arr[i];\n        i -= lsb(i);\n    }\n    return total;\n}\n\nvoid init(VVLL & E, ll s, VLL & timein, VLL & timeout, ll & time) {\n    time++;\n    timein[s] = time;\n\n    for (ll to : E[s]) init(E, to, timein, timeout, time);\n\n    time++;\n    timeout[s] = time;\n}\n\nvoid solve() {\n\tll n;\n    cin >> n;\n    VVLL E(n);\n\n    REP(i,0,n) {\n        ll k;\n        cin >> k;\n        E[i].resize(k);\n        REP(j,0,k) {\n            cin >> E[i][j];\n        }\n    }\n\n    // do a preorder traversal\n    VLL timein(n), timeout(n);\n    ll time = 1;\n    init(E, 0, timein, timeout, time);\n\n    ll q;\n    in(q);\n    REP(i,0,q) {\n        ll t;\n        cin >> t;\n        if (t == 0) {\n            ll a, b;\n            cin >> a >> b;\n            add(timein[a], b);\n            add(timeout[a], -b);\n        } else {\n            ll a;\n            cin >> a;\n            cout << sum(timein[a]) << endl;\n        }\n    }\n\n\n}\n\nsigned main() {\n\tll t = 1;\n\tREP(i,0,t) solve();\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct euler_tour{\n  int r;\n  int n;\n  vector<vector<int>> adj;\n  vector<int> dep;\n  vector<int> tour;\n  vector<int> Lid,Rid;\n  euler_tour(){}\n  euler_tour(vector<vector<int>> const& adjacent_list,int root=0){\n    init(adjacent_list,root);\n  }\n  void init(vector<vector<int>> const& adjacent_list,int root=0){\n    adj = adjacent_list;\n    r = root;\n    n = adjacent_list.size();\n    dep.reserve(2*n-1);\n    tour.reserve(2*n-1);\n    Lid.resize(n);\n    Rid.resize(n);\n    int k = 0;\n    dfs(r,-1,0,k);\n  }\n  void dfs(int cur,int prv,int depth,int& idx){\n    Lid[cur] = idx++;\n    dep.emplace_back(depth);\n    tour.emplace_back(cur);\n    for(auto const& nxt:adj[cur]){\n      if(nxt==prv)continue;\n      dfs(nxt,cur,depth+1,idx);\n      dep.emplace_back(depth);\n      tour.emplace_back(cur);\n    }\n    Rid[cur] = idx++;\n  }\n  void dump(){\n    cout<<\" Lid : \"<<endl;\n    for(auto x:Lid){\n      cout<<x<<\" \";\n    }cout<<endl;\n    cout<<\" Rid : \"<<endl;\n    for(auto x:Rid){\n      cout<<x<<\" \";\n    }cout<<endl;\n    cout<<\"tour : \"<<endl;\n    for(auto x:tour){\n      cout<<x<<\" \";\n    }cout<<endl;\n    cout<<\" dep : \"<<endl;\n    for(auto x:dep){\n      cout<<x<<\" \";\n    }cout<<endl;\n  }\n};\n\ntemplate<class T,class F>\nstruct segtree{\n  int n;\n  T e;\n  F f;\n  std::vector<T> dat;\n\n  segtree(){}\n  segtree(int sz,T _e,F _f):e(_e),f(_f){\n    n = 1;\n    while(n<=sz)n<<=1;\n    dat.resize(2*n,e);\n  }\n  segtree(std::vector<T> const& v,T _e,F _f):e(_e),f(_f){\n    build(v);\n  }\n  void build(std::vector<T> const& v){\n    n = 1;\n    int sz = v.size();\n    while(n<=sz)n<<=1;\n    dat.resize(2*n,e);\n    for(int i=0;i<sz;++i){\n      dat[i+n] = v[i];\n    }\n    for(int i=n-1;i>0;--i){\n      dat[i] = f(dat[i<<1],dat[i<<1|1]);\n    }\n  }\n  void set(int p,T v){\n    for(dat[p+=n]=v;p>1;p>>=1){\n      dat[p>>1] = f(dat[p],dat[p^1]);\n    }\n  }\n  T query(int l,int r){\n    T res = e;\n    for(l+=n,r+=n;l<r;l>>=1,r>>=1){\n      if(l&1){\n        res = f(res,dat[l]);\n        l++;\n      }\n      if(r&1){\n        r--;\n        res = f(res,dat[r]);\n      }\n    }\n    return res;\n  }\n  T operator[](int k){\n    return query(k,k+1);\n  }\n};\n\ntemplate<class T,class U>\nvector<pair<T,U>> paired(vector<T> const& t,vector<U> const& u){\n  size_t n = t.size();\n  size_t m = u.size();\n  assert(n==m);\n  vector<pair<T,U>> res(n);\n  for(int i=0;i<n;++i){\n    res[i] = {t[i],u[i]};\n  }\n  return res;\n}\n\nsigned main(){\n\n  int n;\n  cin>>n;\n  vector<vector<int>> adj(n);\n  for(int i=0;i<n;++i){\n    int k;cin>>k;\n    adj[i].resize(k);\n    for(auto& a:adj[i])cin>>a;\n  }\n  euler_tour et(adj);\n  auto sum = [](int a,int b){return a+b;};\n  segtree<int,decltype(sum)> tree(2*n,0,sum);\n\n  int q;\n  cin>>q;\n  while(q--){\n    int c;cin>>c;\n    if(c==0){\n      int v,w;cin>>v>>w;\n      int lv = et.Lid[v];\n      int rv = et.Rid[v];\n      tree.set(lv,tree[lv]+w);\n      tree.set(rv,tree[rv]-w);\n    }\n    if(c==1){\n      int u;cin>>u;\n      u = et.Lid[u];\n      cout<< tree.query(0,u+1) <<endl;\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n  struct Node{\n    Node *l,*r,*p;\n    size_t cnt;\n    int idx;\n    bool rev;\n    T val,dat;\n    E laz;\n    Node():cnt(0){}\n    Node(int idx,T val,E laz):\n      cnt(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n    bool is_root(){\n      return !p||(p->l!=this&&p->r!=this);\n    }\n  };\n  \n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using S = function<T(T)>;\n  F f;\n  G g;\n  H h;\n  S s;\n  T ti;\n  E ei;\n  \n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n  \n  \n  LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n    s=[](T a){return a;};\n  }\n  \n  LinkCutTree(F f,G g,H h,S s,T ti,E ei):\n    f(f),g(g),h(h),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(int idx,T v){\n    return &(pool[ptr++]=Node(idx,v,ei));\n  }\n\n  void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,v);\n    t->dat=g(t->dat,v);\n  }\n\n  void toggle(Node *t){\n    swap(t->l,t->r);\n    t->dat=s(t->dat);\n    t->rev^=1;\n  }\n\n  void eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n  }\n\n  void update(Node *t){\n    t->cnt=1;\n    t->dat=t->val;\n    if(t->l) t->cnt+=t->l->cnt,t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->cnt+=t->r->cnt,t->dat=f(t->dat,t->r->dat);\n  }\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n  \n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t){\n    eval(t);\n    while(!t->is_root()){\n      Node *q=t->p;\n      if(q->is_root()){\n\teval(q);eval(t);\n\tif(q->l==t) rotR(t);\n\telse rotL(t);\n      }else{\n\tauto *r=q->p;\n\teval(r);eval(q);eval(t);\n\tif(r->l==q){\n\t  if(q->l==t) rotR(q),rotR(t);\n\t  else rotL(t),rotR(t);\n\t}else{\t\n\t  if(q->r==t) rotL(q),rotL(t);\n\t  else rotR(t),rotL(t);\n\t}\n      }\n    }\n  }\n\n  Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      update(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(c);\n    expose(par);\n    c->p=par;\n    par->r=c;\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=nullptr;\n    par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  bool is_connected(Node *a,Node *b){\n    expose(a);\n    while(a->l) a=a->l;\n    expose(b);\n    while(b->l) b=b->l;\n    return a==b;\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n\n  void set_propagate(Node *t,E v){\n    expose(t);\n    propagate(t,v);\n    eval(t);\n  }\n};\n\n//END CUT HERE\n//INSERT ABOVE HERE\n\nsigned GRL_5_C(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return min(a,b);};\n  LCT lc(f,f,f,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int a,b;\n    cin>>a>>b;\n    cout<<lc.lca(v[a],v[b])->idx<<endl;\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_C\n*/\n\nsigned GRL_5_D(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return a+b;};\n  LCT lc(f,f,f,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.expose(v[a]);\n      v[a]->val=f(v[a]->val,b);\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_D\n*/\n\n\nsigned GRL_5_E(){\n  int n;\n  cin>>n;\n  using P = pair<int, int>;\n  using LCT = LinkCutTree<P, Int>;\n  auto f=[](P a,P b){return P(a.first+b.first,a.second+b.second);};\n  auto g=[](P a,int b){return P(a.first+b*a.second,a.second);};\n  auto h=[](Int a,Int b){return a+b;};\n  \n  LCT lc(f,g,h,P(0,0),0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,P(0,0));\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  Int c=0;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.set_propagate(v[a],b);\n      c+=b;\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat.first-c<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_E\n*/\n\nsigned JOISC2013_DAY4_3(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  \n  using LCT = LinkCutTree<int, int>;\n  auto f=[](int a,int b){return a+b;};\n  LCT lct(f,f,f,0,0);\n  vector<LCT::Node*> vs(n);\n  for(int i=0;i<n;i++) vs[i]=lct.create(i,0);\n\n  for(int i=0;i<q;i++){\n    int t,a,b=0;\n    scanf(\"%d %d\",&t,&a);\n    if(t!=2) scanf(\"%d\",&b);\n    a--;b--;\n    if(t==1) lct.link(vs[b],vs[a]);\n    if(t==2) lct.cut(vs[a]);\n    if(t==3){\n      if(!lct.is_connected(vs[a],vs[b])) puts(\"-1\");\n      else printf(\"%d\\n\",lct.lca(vs[a],vs[b])->idx+1);\n    }\n  }\n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  https://beta.atcoder.jp/contests/joisc2013-day4/tasks/joisc2013_spaceships\n*/\n\nsigned AOJ_2450(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n\n  using T = tuple<int,int,int,int,int,int,int>;\n  using P = pair<int,int>;\n  using LCT = LinkCutTree<T, P>;\n\n  vector<vector<int> > G(n); \n  T d1(-1,-1,-1,-1,-1,-1,-1);\n  P d0(-1,-114514);\n  \n  vector<LCT::Node* > vs(n);\n  vector<int> ps(n,-1);\n  \n  auto f=[&](T a,T b){\n    int al,ar,as,ava,avi,avl,avr;\n    tie(al,ar,as,ava,avi,avl,avr)=a;\n    int bl,br,bs,bva,bvi,bvl,bvr;\n    tie(bl,br,bs,bva,bvi,bvl,bvr)=b;\n    int cl=al,cr=br,cs=as+bs;\n    int cva=ava+bva,cvi=max(avi,bvi),cvl=avl,cvr=bvr;\n    cvi=max(cvi,avr+bvl);\n    cvl=max(cvl,ava+bvl);\n    cvr=max(cvr,avr+bva);\n    return T(cl,cr,cs,cva,cvi,cvl,cvr);\n  };\n  \n  auto g=[&](T a,P p){\n    if(p==d0) return a;\n    int al,ar,as,ava,avi,avl,avr;\n    tie(al,ar,as,ava,avi,avl,avr)=a;\n    int v=p.first,b=p.second;\n    if(~v) al=ar=v,as=1;\n    if(b>=0) return T(al,ar,as,b*as,b*as,b*as,b*as);\n    return T(al,ar,as,b*as,b,b,b);\n  };\n  \n  auto h=[&](P a,P b){a.first++;return b;};\n  auto s=\n    [&](T a){      \n      int al,ar,as,ava,avi,avl,avr;\n      tie(al,ar,as,ava,avi,avl,avr)=a;\n      swap(al,ar);\n      swap(avl,avr);\n      return T(al,ar,as,ava,avi,avl,avr);\n    };\n  \n  LCT lct(f,g,h,s,d1,d0);\n  \n  vector<int> w(n);\n  for(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n  for(int i=0;i<n;i++) vs[i]=lct.create(i,g(d1,P(i,w[i])));\n  \n  for(int i=0;i<n-1;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n\n  for(int i=0;i<n;i++)\n    sort(G[i].begin(),G[i].end());\n\n  {\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p) lct.link(vs[p],vs[v]);\n      ps[v]=p;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tq.emplace(u,v);\n      }\n    }\n  }\n  \n  while(q--){\n    int t,a,b,c;\n    scanf(\"%d %d %d %d\",&t,&a,&b,&c);\n    a--;b--;\n    if(t==1){\n      lct.evert(vs[a]);\n      lct.set_propagate(vs[b],P(-1,c));      \n    }\n    if(t==2){\n      lct.evert(vs[a]);\n      lct.expose(vs[b]);\n      int vva,vvi,vvl,vvr;\n      tie(ignore,ignore,ignore,vva,vvi,vvl,vvr)=vs[b]->dat;\n      printf(\"%d\\n\",max({vva,vvi,vvl,vvr}));\n    }\n  }\n  \n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2450\n*/\n\nsigned AOJ_0367(){\n  int n,k;\n  cin>>n>>k;\n  \n  vector<vector<int> > G(n); \n  vector<map<Int, Int> > m(n);\n  for(Int i=0;i<n-1;i++){\n    Int a,b,c;\n    cin>>a>>b>>c;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n    m[a][b]=m[b][a]=c;\n  }\n  \n  vector<Int> w(n,0);\n  vector<int> ps(n,-1);\n  using T = tuple<Int, Int, Int>;\n  auto mget=[&](Int a,Int b){\n\t      if(ps[a]!=b&&ps[b]!=a) return 0LL;\n\t      Int res=w[a]+w[b]+m[a][b];\n\t      if(res%k) return res;\n\t      return 0LL;\n\t    };\n  \n  auto f=[&](T a,T b){\n\t   if(a>b) swap(a,b);\n\t   Int al,ar,av;\n\t   tie(al,ar,av)=a;\n\t   Int bl,br,bv;\n\t   tie(bl,br,bv)=b;\n\t   if(al<0||ar<0) return b;\n\t   Int cl,cr,cv=av+bv;\n\t   if(m[al].count(bl)){\n\t     cl=ar;cr=br;\n\t     cv+=mget(al,bl);\n\t   }else if(m[al].count(br)){\n\t     cl=ar;cr=bl;\n\t     cv+=mget(al,br);\n\t   }else if(m[ar].count(bl)){\n\t     cl=al;cr=br;\n\t     cv+=mget(ar,bl);\n\t   }else if(m[ar].count(br)){\n\t     cl=al;cr=bl;\n\t     cv+=mget(ar,br);\n\t   }else{\n\t     cl=cr=cv=-1;\n\t   }\n\t   return T(cl,cr,cv);\n\t };\n  \n  auto g=[&](T a,Int b){b++;return a;};\n  auto h=[&](Int a,Int b){b++;return a;};\n  \n  using LCT = LinkCutTree<T, Int>;\n  LCT lct(f,g,h,T(-1,-1,0),0);  \n  vector<LCT::Node* > vs(n);\n  for(Int i=0;i<n;i++) vs[i]=lct.create(i,T(i,i,0));\n  \n  {\n    using P = pair<Int, Int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p) lct.link(vs[p],vs[v]);\n      ps[v]=p;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tq.emplace(u,v);\n      }\n    } \n  }\n  \n  Int q;\n  cin>>q;\n  while(q--){\n    string op;\n    cin>>op;\n    if(op==\"add\"){\n      Int x,d;\n      cin>>x>>d;\n      lct.expose(vs[x]);\n      w[x]+=d;\n      lct.update(vs[x]);\n    }\n    if(op==\"send\"){\n      Int s,t;\n      cin>>s>>t;\n      lct.evert(vs[s]);\n      lct.expose(vs[t]);\n      cout<<get<2>(vs[t]->dat)<<endl;\n    }\n  }  \n  \n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0367\n*/\n\n\n\nstruct M{\n  Int a,b,c,d;\n  M():a(1),b(0),c(0),d(1){}\n  M(Int a,Int b,Int c,Int d):a(a),b(b),c(c),d(d){}\n  //M(const M &v):a(v.a),b(v.b),c(v.c),d(v.d){}\n  bool operator!=(const M &x)const{\n    return a!=x.a||b!=x.b||c!=x.c||d!=x.d;\n  }\n  bool operator==(const M &x)const{\n    return !(*this!=x);\n  }\n};\n\nsigned YUKI_650(){\n  const int MOD=1e9+7;\n  using M2 = pair<M, M>;\n  using LCT = LinkCutTree<M2, M2>;\n  auto f=[MOD](M x,M y){\n\t   M r(0,0,0,0);\n\t   r.a=x.a*y.a+x.b*y.c;\n\t   r.b=x.a*y.b+x.b*y.d;\n\t   r.c=x.c*y.a+x.d*y.c;\n\t   r.d=x.c*y.b+x.d*y.d;\t   \n\t   r.a%=MOD;r.b%=MOD;r.c%=MOD;r.d%=MOD;\n\t   return r;\n\t };\n  auto f2=[&](M2 x,M2 y){\n\t    return M2(f(x.first,y.first),f(y.second,x.second));\n\t  };\n  auto g=[](M2 x,M2 y){x.first.a++;return y;};\n  auto s=[](M2 x){swap(x.first,x.second);return x;};\n  \n  int n;\n  cin>>n;\n  vector<vector<int> > G(n);\n  vector<int> X,Y;\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    X.emplace_back(a);\n    Y.emplace_back(b);\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  M ti=M();\n  M ei(-1,-1,-1,-1);\n  LCT lct(f2,g,g,s,M2(ti,ti),M2(ei,ei));\n\n  \n  vector<LCT::Node*> vs(n*2-1);\n  for(int i=0;i<(int)vs.size();i++) vs[i]=lct.create(i,M2(ti,ti));\n  \n  vector<map<int, int> > rev(n);\n  int idx=n;\n  {\n    using P = pair<int, int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p){\n\tlct.link(vs[p],vs[idx]);\n\tlct.link(vs[idx],vs[v]);\n\trev[p][v]=rev[v][p]=idx++;\n      }\n      for(int u:G[v])\n\tif(u!=p) q.emplace(u,v);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    char c;\n    cin>>c;\n    if(c=='x'){\n      Int v,a,b,c,d;\n      cin>>v>>a>>b>>c>>d;\n      int z=rev[X[v]][Y[v]];\n      lct.expose(vs[z]);\n      vs[z]->val=M2(M(a,b,c,d),M(a,b,c,d));      \n      lct.expose(vs[z]);\n    }\n    if(c=='g'){\n      Int x,y;\n      cin>>x>>y;\n      lct.evert(vs[x]);\n      lct.expose(vs[y]);\n      M ans=vs[y]->dat.first;\n      cout<<ans.a<<\" \"<<ans.b<<\" \"<<ans.c<<\" \"<<ans.d<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://yukicoder.me/problems/no/650\n*/\n\n\nsigned main(){\n  //GRL_5_C();\n  GRL_5_D();\n  //GRL_5_E();\n  //JOISC2013_DAY4_3();\n  //AOJ_2450();\n  //AOJ_0367();\n  //YUKI_650();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = int64_t;\nusing vi = vector<i64>;\nusing vvi = vector<vi>;\n\ntemplate <class T, class T2 = T>\nstruct LinkCutTree {\n    using F = function<T(T, T)>;\n    using G = function<T(T, T2, int)>;\n    using H = function<T2(T2, T2)>;\n\n    struct Node {\n        Node *l, *r, *p;\n        int idx;\n        T key, sum;\n        T2 lazy;\n\n        bool rev;\n        int sz;\n\n        bool is_root() {\n            return !p || (p->l != this && p->r != this);\n        }\n\n        Node(int idx, const T &key, const T2 &v) : idx(idx), key(key), sum(key), lazy(v), sz(1), l(nullptr), r(nullptr), p(nullptr), rev(false) {}\n    };\n\n    const T e;\n    const T2 e2;\n    const F f;\n    const G g;\n    const H h;\n\n    LinkCutTree(const F &f, const T &e) : LinkCutTree(f, G(), H(), e, T2()) {}\n    LinkCutTree(const F &f, const G &g, const H &h, const T &e, const T2 &e2) : f(f), g(g), h(h), e(e), e2(e2) {}\n\n    Node *make_node(int idx, const T &v = T()) {\n        return new Node(idx, v, e2);\n    }\n\n    void propagate(Node *t, const T2 &x) {\n        t->lazy = h(t->lazy, x);\n        t->key = g(t->key, x, 1);\n        t->sum = g(t->sum, x, t->sz);\n    }\n\n    void toggle(Node *t) {\n        swap(t->l, t->r);    \n        t->rev ^= true;\n    }\n\n    void push(Node *t) {\n        if (t->lazy != e2) {\n            if (t->l) propagate(t->l, t->lazy);\n            if (t->r) propagate(t->r, t->lazy);\n            t->lazy = e2;\n        }\n        if (t->rev) {\n            if (t->l) toggle(t->l);\n            if (t->r) toggle(t->r);\n            t->rev = false;\n        }\n    }\n\n    void update(Node *t) {\n        t->sz = 1;\n        t->sum = t->key;\n        if (t->l) t->sz += t->l->sz, t->sum = f(t->l->sum, t->sum);\n        if (t->r) t->sz += t->r->sz, t->sum = f(t->sum, t->r->sum);\n    }\n\n    void rotr(Node *t) {\n        auto *x = t->p, *y = x->p;\n        if (x->l = t->r) t->r->p = x;\n        t->r = x, x->p = t;\n        update(x), update(t);\n        if (t->p = y) {\n            if (y->l == x) y->l = t;\n            if (y->r == x) y->r = t;\n            update(y);\n        }\n    }\n\n    void rotl(Node *t) {\n        auto *x = t->p, *y = x->p;\n        if (x->r = t->l) t->l->p = x;\n        t->l = x, x->p = t;\n        update(x), update(t);\n        if (t->p = y) {\n            if (y->l == x) y->l = t;\n            if (y->r == x) y->r = t;\n            update(y);\n        }\n    }\n\n    void splay(Node *t) {\n        push(t);\n        while (!t->is_root()) {\n            auto *q = t->p;\n            if (q->is_root()) {\n                push(q), push(t);\n                if (q->l == t) rotr(t);\n                else rotl(t);\n            } else {\n                auto *r = q->p;\n                push(r), push(q), push(t);\n                if (r->l == q) {\n                    if (q->l == t) rotr(q), rotr(t);\n                    else rotl(t), rotr(t);\n                } else {\n                    if (q->r == t) rotl(q), rotl(t);\n                    else rotr(t), rotl(t);\n                }\n            }\n        }\n    }\n\n    Node *expose(Node *t) {\n        Node *rp = nullptr;\n        for (Node *cur = t; cur; cur = cur->p) {\n            splay(cur);\n            cur->r = rp;\n            update(cur);\n            rp = cur;\n        }\n        splay(t);\n        return rp;\n    }\n\n    void link(Node *child, Node *parent) {\n        expose(child);\n        expose(parent);\n        child->p = parent;\n        parent->r = child;\n    }\n\n    void cut(Node *child) {\n        expose(child);\n        auto *parent = child->l;\n        child->l = nullptr;\n        parent->p = nullptr;\n    }\n\n    void evert(Node *t) {\n        expose(t);\n        toggle(t);\n        push(t);\n    }\n\n    Node *lca(Node *u, Node *v) {\n        expose(u);\n        return expose(v);\n    }\n\n    vi getpath(Node *x) {\n        vi vs;\n        function<void(Node *)> dfs = [&](Node *cur) {\n            if (!cur) return;\n            push(cur);\n            dfs(cur->r);\n            vs.push_back(cur->idx);\n            dfs(cur->l);\n        };\n        expose(x);\n        dfs(x);\n        return vs;\n    }\n\n    void set_propagate(Node *t, const T2 &x) {\n        expose(t);\n        propagate(t, x);\n        push(t);\n    }\n};\n\nint main() {\n    int n;\n    cin >> n;\n    LinkCutTree<i64> lct([](i64 a, i64 b) {return a + b;}, 0);\n    vector<LinkCutTree<i64>::Node*> nodes(n);\n    for (int i = 0; i < n; i++) {\n        nodes[i] = lct.make_node(i);\n    }\n    for (int i = 0; i < n; i++) {\n        int d;\n        cin >> d;\n        for (int j = 0; j < d; j++) {\n            int k;\n            cin >> k;\n            lct.link(nodes[k], nodes[i]);\n        }\n    }\n\n    int q;\n    cin >> q;\n    while (q--) {\n        int t;\n        cin >> t;\n        if (t == 0) {\n            int v, w;\n            cin >> v >> w;\n            lct.expose(nodes[v]);\n            nodes[v]->key += w;\n        } else {\n            int u;\n            cin >> u;\n            lct.expose(nodes[u]);\n            cout << nodes[u]->sum << endl;\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\n#define pii pair<int,int>\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define ZERO(a) memset(a,0,sizeof(a))\n#define MINUS(a) memset(a,0xff,sizeof(a))\n#define MINF(a) memset(a,0x3f,sizeof(a))\n#define POW(n) (1LL<<(n))\n#define IN(i,a,b) (a <= i && i <= b)\nusing namespace std;\ntemplate <typename T> inline bool CHMIN(T& a,T b) { if(a>b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline bool CHMAX(T& a,T b) { if(a<b) { a=b; return 1; } return 0; }\ntemplate <typename T> inline void SORT(T& a) { sort(ALL(a)); }\ntemplate <typename T> inline void REV(T& a) { reverse(ALL(a)); }\ntemplate <typename T> inline void UNI(T& a) { sort(ALL(a)); a.erase(unique(ALL(a)),a.end()); }\ntemplate <typename T> inline void LB(vector<T>& v, T& a) { return *lower_bound(ALL(v),a); }\ntemplate <typename T> inline void LBP(vector<T>& v, T& a) { return lower_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T> inline void UB(vector<T>& v, T& a) { return *upper_bound(ALL(v),a); }\ntemplate <typename T> inline void UBP(vector<T>& v, T& a) { return upper_bound(ALL(v),a) - v.begin(); }\ntemplate <typename T1, typename T2> ostream& operator<< (ostream& os, const pair<T1,T2>& p) { os << p.first << \" \" << p.second; return os; }\ntemplate <typename T1, typename T2> istream& operator>> (istream& is, pair<T1,T2>& p) { is >> p.first >> p.second; return is; }\ntemplate <typename T> ostream& operator<< (ostream& os, const vector<T>& v) { REP(i,v.size()) { if (i) os << \" \"; os << v[i]; } return os; }\ntemplate <typename T> istream& operator>> (istream& is, vector<T>& v) { for(T& in : v) is >> in; return is; }\ntemplate <typename T = int> vector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate <typename T, typename... Ts> auto make_v(size_t a, Ts... ts) { return vector<decltype(make_v<T>(ts...))>(a,make_v<T>(ts...)); }\ntemplate< typename T, typename V > typename enable_if< is_class< T >::value == 0 >::type fill_v(T &t, const V &v) { t = v; }\ntemplate< typename T, typename V > typename enable_if< is_class< T >::value != 0 >::type fill_v(T &t, const V &v) { for(auto &e : t) fill_v(e, v); }\nconst int MOD = 1000000007;\nconst int INF = 0x3f3f3f3f3f3f3f3f;\nconst double EPS = 1e-10;\n\ntemplate <typename T>\nstruct edge {\n  int s, t;\n  T c;\n  edge() {}\n  edge(int t, T c) : s(-1), t(t), c(c) {}\n  edge(int s, int t, T c) : s(s), t(t), c(c) {}\n};\n\ntemplate <typename T> using Edges = vector<edge<T>>;\ntemplate <typename T> using WeightedGraph = vector<Edges<T>>;\nusing UnWeightedGraph = vector<vector<int>>;\ntemplate <typename T> using Matrix = vector<vector<T>>;\n\nclass HeavyLightDecomposition {\nprivate:\n  void dfs_sz(int v) {\n    for (int& nv: g[v]) if (nv != par[v]) {\n      par[nv] = v;\n      dep[nv] = dep[v] + 1;\n      dfs_sz(nv);\n      sub[v] += sub[nv];\n      if (sub[nv] > sub[g[v][0]]) swap(nv, g[v][0]);\n    }\n  }\n  void dfs_hld(int v, int c, int& pos) {\n    vid[v] = pos++;\n    inv[vid[v]] = v;\n    type[v] = c;\n    for (int nv : g[v]) if (nv != par[v]) {\n      head[nv] = (nv == g[v][0] ? head[v] : nv);\n      dfs_hld(nv, c, pos);\n    }\n  }\npublic:\n  UnWeightedGraph g;\n  vector<int> vid, head, sub, par, dep, inv, type;\n  HeavyLightDecomposition(UnWeightedGraph& g) :\n    g(g), vid(g.size(), -1), head(g.size()), sub(g.size(), 1),\n    par(g.size(), -1), dep(g.size(), 0), inv(g.size()), type(g.size()) {}\n  \n  void build(vector<int> rs = {0}) {\n    int c = 0, pos = 0;\n    for (int r : rs) {\n      dfs_sz(r);\n      head[r] = r;\n      dfs_hld(r, c++, pos);\n    }\n  }\n  int lca(int u, int v) {\n    while (1) {\n      if (vid[u] > vid[v]) swap(u, v);\n      if (head[u] == head[v]) return u;\n      v = par[head[v]];\n    }\n  }\n  int distance(int u, int v) {\n    return dep[u] + dep[v] - 2 * dep[lca(u, v)];\n  }\n  template <typename F>\n  void for_each(int u, int v, const F& f) {\n    while (1) {\n      if (vid[u] > vid[v]) swap(u, v);\n      f(max(vid[head[v]], vid[u]), vid[v] + 1);\n      if (head[u] != head[v]) v = par[head[v]];\n      else break;\n    }\n  }\n  template <typename F>\n  void for_each_edge(int u, int v, const F& f) {\n    while (1) {\n      if (vid[u] > vid[v]) swap(u, v);\n      if (head[u] != head[v]) {\n        f(vid[head[v]], vid[v] + 1);\n        v = par[head[v]];\n      } else {\n        if (u != v) f(vid[u] + 1, vid[v] + 1);\n        break;\n      }\n    }\n  }\n};\n\ntemplate <typename M, typename OM = M>\nstruct LazySegmentTree {\n  using F = function<M(M,M)>;\n  using G = function<M(M,OM)>;\n  using H = function<OM(OM,OM)>;\n  using P = function<OM(OM,int)>;\n  int n,lev;\n  F f;\n  G g;\n  H h;\n  P p;\n  M M1;\n  OM OM0;\n  vector<M> d;\n  vector<OM> lz;\n  LazySegmentTree() {}\n  LazySegmentTree(F f, G g, H h, M M1, OM OM0, P p = [](OM a, int b) { return a; }) : f(f), g(g), h(h), M1(M1), OM0(OM0), p(p) {}\n  void init(int n_) {\n    for (n = 1, lev = 0; n < n_; n <<= 1, lev++);\n    d.assign(n << 1, M1);\n    lz.assign(n << 1, OM0);\n  }\n  void build(const vector<M>& v) {\n    int n_ = v.size();\n    init(n_);\n    for (int i = 0; i < n_; i++) d[n + i] = v[i];\n    for (int i = n - 1; i > 0; i--) {\n      d[i] = f(d[(i << 1) | 0], d[(i << 1) | 1]);\n    }\n  }\n  inline M reflect(int k, int len) {\n    return lz[k] == OM0 ? d[k] : g(d[k], p(lz[k], len));\n  }\n  inline void eval(int k, int len) {\n    if (lz[k] == OM0) return;\n    lz[(k << 1) | 0] = h(lz[(k << 1) | 0], lz[k]);\n    lz[(k << 1) | 1] = h(lz[(k << 1) | 1], lz[k]);\n    d[k] = reflect(k, len);\n    lz[k] = OM0;\n  }\n  inline void thrust(int k) {\n    for (int i = lev; i > 0; i--) eval(k >> i, n >> (lev - i));\n  }\n  inline void recalc(int k) {\n    int len = 1;\n    while (k >>= 1, len <<= 1) {\n      d[k] = f(reflect((k << 1) | 0, len >> 1), reflect((k << 1) | 1, len >> 1));\n    }\n  }\n  void update(int a, int b, OM x) {\n    thrust(a += n);\n    thrust(b += n - 1);\n    for (int l = a, r = b + 1; l < r; l >>= 1, r >>= 1) {\n      if (l & 1) lz[l] = h(lz[l], x), l++;\n      if (r & 1) --r, lz[r] = h(lz[r], x);\n    }\n    recalc(a);\n    recalc(b);\n  }\n  M query(int a, int b) {\n    thrust(a += n);\n    thrust(b += n - 1);\n    M L = M1, R = M1;\n    for (int l = a, r = b + 1, len = 1; l < r; l >>= 1, r >>= 1, len <<= 1) {\n      if (l & 1) L = f(L, reflect(l++, len));\n      if (r & 1) R = f(reflect(--r, len), R);\n    }\n    return f(L, R);\n  }\n  void set(int k, M x) {\n    thrust(k += n);\n    d[k] = x;\n    lz[k] = OM0;\n    recalc(k);\n  }\n  M operator[] (int k) {\n    thrust(k += n);\n    return d[k];\n  }\n};\n\nsigned main() {\n  cin.tie(nullptr);\n  ios::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n\n  int n;\n  cin >> n;\n  UnWeightedGraph G(n);\n  REP(i,n) {\n    int k;\n    cin >> k;\n    REP(j,k) {\n      int c;\n      cin >> c;\n      G[i].push_back(c);\n    }\n  }\n\n  HeavyLightDecomposition HLD(G);\n  HLD.build();\n\n  auto f = [](int a, int b) { return a+b; };\n  auto g = [](int a, int b) { return a+b; };\n  auto h = [](int a, int b) { return a+b; };\n  auto p = [](int a, int b) { return a*b; };\n  LazySegmentTree<int> LST(f,g,h,0,0,p);\n  LST.build(vector<int>(n,0));\n\n  int q;\n  cin >> q;\n  REP(i,q) {\n    int c;\n    cin >> c;\n    if (c == 0) {\n      int v,w;\n      cin >> v >> w;\n      LST.update(HLD.vid[v],HLD.vid[v]+1,w);\n    } else {\n      int u;\n      cin >> u;\n      int ans = 0;\n      HLD.for_each_edge(0,u,[&](int l, int r){ ans += LST.query(l,r); });\n      cout << ans << endl;\n    }\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long lint;\n\nstruct edge{\n    int from, to;\n    bool operator < (const edge &e) const {\n        if(from==e.from) return to < e.to;\n        return from < e.from;\n    }\n};\n\nconst int MAX_N = (int)2e5 + 5;\nint cnt = 1, par[MAX_N];\nlint bit[MAX_N];\nvector<int> G[MAX_N];\nauto cmp = [](const edge &e1, const edge &e2){return e1.from<e2.from;};\nmap<edge, int> start, fin;\n\nlint sum(int i){\n    lint res = 0;\n    while(i) {res += bit[i]; i -= i & -i;}\n    return res;\n}\n\nvoid add(int i, lint x){\n    while(i<MAX_N) {bit[i] += x; i += i & -i;}\n}\n\nvoid dfs(int s, int p){\n    for(auto u : G[s]){\n        if(u != p){\n            par[u] = s;\n            start[{s, u}] = cnt++;\n            //cout<<s<<' '<<u<<' '<<start[{s, u}]<<endl;\n            dfs(u, s);\n            fin[{s, u}] = cnt++;\n            //cout<<s<<' '<<u<<' '<<fin[{s, u}]<<endl;\n        }\n    }\n}\n\nint main(){\n    ios::sync_with_stdio(false), cin.tie(nullptr);\n    int N;\n    cin>>N;\n    for(int i=0;i<N;i++){\n        int K;\n        cin>>K;\n        for(int j=0;j<K;j++){\n            int c;\n            cin>>c;\n            G[i].push_back(c);\n        }\n    }\n    dfs(0, -1);\n    int Q;\n    cin>>Q;\n    for(int i=0;i<Q;i++){\n        int t;\n        cin>>t;\n        if(t==0){\n            int v, w;\n            cin>>v>>w;\n            edge e = {par[v], v};\n            int id1 = start[e], id2 = fin[e];\n            add(id1, w), add(id2, -w);\n        } else {\n            int u;\n            cin>>u;\n            edge e = {par[u], u};\n            int id = start[e];\n            printf(\"%lld\\n\", sum(id));\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <cmath>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <limits>\n#include <map>\n#include <queue>\n#include <set>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\n#define rep(i, n) for (int64_t i = 0; i < (n); i++)\n#define irep(i, n) for (int64_t i = 0; i <= (n); i++)\n#define rrep(i, n) for (int64_t i = (n)-1; i >= 0; i--)\n#define rirep(i, n) for (int64_t i = n; i >= 0; i--)\n\nclass BinaryIndexedTree {\n    vector<int64_t> container;\n\npublic:\n    BinaryIndexedTree(size_t size)\n        : container(size + 1)\n    {\n        fill(container.begin(), container.end(), 0);\n    }\n    void add(size_t i, int64_t v)\n    {\n        size_t idx = i + 1;\n        while (idx < container.size()) {\n            container[idx] += v;\n            idx += idx & -idx;\n        }\n    }\n    int64_t find(size_t i)\n    {\n        size_t idx = i;\n\n        int64_t result = 0;\n        while (idx != 0) {\n            result = container[idx] + result;\n            idx -= idx & -idx;\n        }\n        return result;\n    }\n    size_t lower_bound(int64_t v)\n    {\n        if (v == 0) {\n            return 0;\n        }\n        int64_t w = v;\n        size_t x = 0;\n        for (size_t k = msb(container.size() - 1); k > 0; k >>= 1) {\n            if (x + k < container.size() && container[x + k] < w) {\n                w -= container[x + k];\n                x += k;\n            }\n        }\n        return x + 1;\n    }\n\nprivate:\n    size_t msb(size_t x)\n    {\n        x |= x >> 1;\n        x |= x >> 2;\n        x |= x >> 4;\n        x |= x >> 8;\n        x |= x >> 16;\n        return (x + 1) >> 1;\n    }\n};\n\nvector<vector<int>> children;\nvector<int> etL, etR;\n\nint init_et(int node, int idx)\n{\n    etL[node] = idx;\n\n    int tmp = idx + 1;\n    for (int ch : children[node]) {\n        tmp = init_et(ch, tmp);\n    }\n    etR[node] = tmp + 1;\n    return etR[node];\n}\n\nint main()\n{\n    int n;\n    cin >> n;\n\n    children.resize(n);\n    rep(i, n)\n    {\n        int k;\n        cin >> k;\n        rep(j, k)\n        {\n            int c;\n            cin >> c;\n            children[i].push_back(c);\n        }\n    }\n\n    etR.resize(n);\n    etL.resize(n);\n    init_et(0, 0);\n\n    BinaryIndexedTree bit(2 * n);\n    int q;\n    cin >> q;\n    rep(i, q)\n    {\n        int k;\n        cin >> k;\n        if (k == 0) {\n            int v, w;\n            cin >> v >> w;\n            bit.add(etL[v], w);\n            bit.add(etR[v], -w);\n        } else {\n            int u;\n            cin >> u;\n            cout << bit.find(etL[u] + 1) - bit.find(etL[0]) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// GRL_5_D Range Query on a Tree (heavy-light)\n\n#include <algorithm>\n#include <cmath>\n#include <iostream>\n#include <stack>\n#include <vector>\n\n#define MAXN 101000\n\nusing namespace std;\n\nstruct {\n  int to, wt, next;\n} par[MAXN], E[MAXN];\nint LE[MAXN];\n\nstruct Seg {\n  vector<int> v;\n\n  Seg(vector<int> &in) : v(pow(2, 1 + ceil(log2(in.size())))) {\n    for (int i = 0; i < in.size(); ++i)\n      v[v.size() / 2 + i] = par[in[i]].wt;\n    for (int k = v.size() / 2 - 1; k > 0; --k)\n      v[k] = v[2 * k] + v[2 * k + 1];\n  }\n\n  int Add(int i, int x) {\n    i += v.size() / 2;\n    v[i] += x;\n    while (i = i / 2)\n      v[i] = v[2 * i] + v[2 * i + 1];\n  }\n\n  int Get(int i) {\n    i += v.size() / 2;\n    int rs = 0;\n    while (i) {\n      if (i == 1) // not a child\n        return v[1];\n      if (i % 2) { // right child\n        i /= 2;\n      } else { // left child\n        rs += v[i];\n        if (!((i / 2) & (i / 2 - 1)))\n          return rs;\n        i = (i / 2) - 1;\n      }\n    }\n    return rs;\n  }\n};\nSeg *aux[MAXN];\nint tidx[MAXN];\nint jump[MAXN];\nint size[MAXN];\n\nvoid Build(int i, vector<int> &a) {\n  a.push_back(i);\n  for (int j = LE[i]; j != -1; j = E[j].next) {\n    if (size[E[j].to] > size[i] / 2) { // heavy\n      Build(E[j].to, a);\n      aux[i] = aux[E[j].to];\n      jump[i] = jump[E[j].to];\n      tidx[i] = tidx[E[j].to] - 1;\n    } else {\n      vector<int> newa;\n      Build(E[j].to, newa);\n    }\n  }\n  // handle last node on heavy chain\n  if (a.size() > 1 && !aux[i]) {\n    aux[i] = new Seg(a);\n    jump[i] = par[a.front()].to;\n    tidx[i] = a.size() - 1;\n  }\n}\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  int n;\n  cin >> n;\n  fill(LE, LE + n, -1);\n  fill(size, size + n, 1);\n  fill(jump, jump + n, -1);\n  fill(aux, aux + n, nullptr);\n  par[0] = {-1, 0, -1};\n\n  for (int s = 0, i = 0; s < n; ++s) {\n    int k, t;\n    cin >> k;\n    while (k-- > 0) {\n      cin >> t;\n      par[t] = {s, 0, -1};\n      E[i] = {t, 0, LE[s]};\n      LE[s] = i;\n      ++i;\n    }\n  }\n\n  stack<int> dfs;\n  dfs.push(0);\n  vector<bool> visited(n);\n  while (!dfs.empty()) {\n    int u = dfs.top();\n    dfs.pop();\n    if (visited[u] && par[u].to >= 0)\n      size[par[u].to] += size[u];\n    if (!visited[u]) {\n      visited[u] = true;\n      dfs.push(u);\n      for (int j = LE[u]; j != -1; j = E[j].next)\n        dfs.push(E[j].to);\n    }\n  }\n\n  vector<int> a;\n  Build(0, a);\n\n  int q;\n  cin >> q;\n  for (int kind, u, v; cin >> kind >> u;) {\n    if (kind == 0) {\n      cin >> v;\n      if (aux[u]) {\n        aux[u]->Add(tidx[u], v);\n      } else {\n        par[u].wt += v;\n      }\n    } else {\n      int rs = 0;\n      while (u > 0) {\n        if (aux[u]) {\n          rs += aux[u]->Get(tidx[u]);\n          u = jump[u];\n        } else {\n          rs += par[u].wt;\n          u = par[u].to;\n        }\n      }\n      cout << rs << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n#define PB push_back\nconst int N=1e5+10;\nstruct BIT{\n    vector<int> v;\n    void init(int size){\n        v.resize(size,0);\n        return ;\n    }\n    void add(int n,int x){\n        while(n<v.size()){\n            v[n]+=x;\n            n+=n&-n;\n        }\n        return ;\n    }\n    int ask(int n){\n        int ans=0;\n        while(n){\n            ans+=v[n];\n            n^=n&-n;\n        }\n        return ans;\n    }\n};\nvector<int> graph[N];\nint p[N],dep[N],to[N],top[N],size[N],val[N];\nBIT b[N];\nvoid dfs(int now){\n    int temp=0;\n    size[now]=1;\n    val[now]=0;\n    for(int i:graph[now]){\n        dep[i]=dep[now]+1;\n        dfs(i);\n        if(size[i]>temp){\n            temp=size[i];\n            to[now]=i;\n        }\n        size[now]+=size[i];\n    }\n    return ;\n}\nvoid init(int now){\n    if(graph[now].empty())b[top[now]].init(dep[now]-dep[top[now]]+1);\n    for(int i:graph[now]){\n        if(i==to[now])top[i]=top[now];\n        else top[i]=i;\n        init(i);\n    }\n    return ;\n}\nint query(int n){\n    int ans=0;\n    while(n>0){\n        ans+=b[top[n]].ask(dep[n]-dep[top[n]]);\n        ans+=val[n];\n        n=p[top[n]];\n    }\n    return ans;\n}\nint main(){\n    int n,k,temp,q;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        for(int j=0;j<k;j++){\n            scanf(\"%d\",&temp);\n            graph[i].PB(temp);\n            p[temp]=i;\n        }\n    }\n    top[0]=0;\n    p[0]=-1;\n    dep[0]=0;\n    dfs(0);\n    init(0);\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%d\",&k);\n        if(k==0){\n            scanf(\"%d%d\",&k,&temp);\n            if(k==top[k])val[k]+=temp;\n            else b[top[k]].add(dep[k]-dep[top[k]],temp);\n        }\n        else{\n            scanf(\"%d\",&k);\n            printf(\"%d\\n\",query(k));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\nconstexpr int IINF = INT_MAX;\n\ntemplate <typename Monoid>\nstruct SegmentTree{\nprivate:\n    using F = function<Monoid(Monoid, Monoid)>;\n    int N;\n    vector<Monoid> node;\n    F f;\n    Monoid e;  // identity element\n\npublic:\n    SegmentTree(){}\n    SegmentTree(F f, Monoid e):f(f), e(e){}\n    void init(int sz){\n        N = 1;\n        while(N < sz) N <<= 1;\n        node.assign(2*N-1, e);\n    }\n    void build(vector<Monoid>& v){\n        int sz = int(v.size());\n        init(sz);\n        for(int i=0; i<sz; i++){\n            node[i+N-1] = v[i];\n        }\n        for(int i=N-2; i>=0; i--){\n            node[i] = f(node[i*2+1], node[i*2+2]);\n        }\n    }\n    void update(int k, Monoid x){\n        k += N-1;\n        node[k] = x;\n        while(k > 0){\n            k = (k-1)/2;\n            node[k] = f(node[2*k+1], node[2*k+2]);\n        }\n    }\n    // [a,b)\n    Monoid query(int a, int b){return query(a, b, 0, 0, N);}\n    Monoid query(int a, int b, int k, int l, int r){\n        if(b <= l || r <= a) return e;\n        if(a <= l && r <= b) return node[k];\n        Monoid vl, vr;\n        vl = query(a, b, 2*k+1, l, (l+r)/2);\n        vr = query(a, b, 2*k+2, (l+r)/2, r);\n        return f(vl, vr);\n    }\n};\n\n\nstruct edge\n{\n    int from, to, d;\n};\n\n\nint n, q, root = 0;\nvector<vector<edge> > g;\nvector<int> depth, vs, id, idr;\n\nauto funcmin = [=](P a, P b){return min(a,b);};\nSegmentTree<P> rmq(funcmin,{IINF, -1});\nauto funcsum = [=](int a, int b){return a+b;};\nSegmentTree<int> rsq(funcsum, 0);\n\nvoid dfs(int v, int p, int d, int &k){\n    id[v] = k;\n    vs[k] = v;\n    depth[k] = d;\n    k++;\n    for(auto e : g[v]){\n        if(e.to == p) continue;\n        dfs(e.to, v, d+1, k);\n        vs[k] = v;\n        depth[k] = d;\n        k++;\n    }\n    idr[v] = k;\n}\n\nvoid init(){\n    int k=0;\n    depth.resize(n*2-1);\n    vs.resize(n*2-1);\n    id.resize(n);\n    idr.resize(n);\n    dfs(root,-1,0,k);\n    vector<P> tmp;\n    for(int i=0;i<k;i++){\n        tmp.push_back({depth[i], vs[i]});\n    }\n    rmq.build(tmp);\n    rsq.init(k);\n}\n\nint LCA(int u, int v){\n    return rmq.query(min(id[u], id[v]), max(id[u], id[v])+1).second;\n}\n\nvoid update(int v, int w){\n    rsq.update(id[v]-1, rsq.query(id[v]-1,id[v])+w);\n    rsq.update(idr[v]-1, rsq.query(idr[v]-1,idr[v])-w);\n}\n\nint getDist(int u, int v){\n    int w = LCA(u, v);\n    return rsq.query(0, id[u]) + rsq.query(0, id[v]) - rsq.query(0,id[w])*2;\n}\n\nint main() {\n    cin >> n;\n    g.resize(n);\n    for(int i=0;i<n;i++){\n        int m;\n        cin >> m;\n        for(int j=0;j<m;j++){\n            int v;\n            cin >> v;\n            g[i].push_back({i,v,0});\n        }\n    }\n    init();\n    cin >> q;\n    for(int i=0;i<q;i++){\n        int c;\n        cin >> c;\n        if(c){\n            int u;\n            cin >> u;\n            cout << getDist(root, u) << endl;\n        }\n        else{\n            int v, w;\n            cin >> v >> w;\n            update(v, w);\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing UL = unsigned int;\nusing ULL = unsigned long long;\nusing LL = long long;\n#define rep(i, n) for(UL i = 0; i < (n); i++)\n\nstruct RSQ{\n UL N;\n vector<UL> V;\n void init(UL n){\n  N=1; while(N<n)N<<=1;\n  V.resize(N*2-1);\n }\n void add(UL p, UL v){\n  UL i = p+N-1;\n  V[i]+=v;\n  while(i){\n   i=(i-1)>>1;\n   V[i]+=v;\n  }\n }\n UL query(UL l, UL r, UL a=~0u, UL b=~0u, UL i=~0u){\n  if(i==~0u){ a=i=0; b=N; }\n  if(r<=a || b<=l) return 0;\n  if(l<=a && b<=r) return V[i];\n  UL q1=query(l,r,a,(a+b)>>1,(i<<1)+1);\n  UL q2=query(l,r,(a+b)>>1,b,(i<<1)+2);\n  return q1+q2;\n }\n};\n\nUL N,Q;\nUL P[100000];\nvector<UL> E[100000];\nUL Z[100000];\n\nRSQ G;\nUL hlP[100000]={};\nUL hlH[100000];\nUL hlL[100000]={};\nUL hlp = 0;\n\nUL ZDFS(UL p){\n for(UL e:E[p]) Z[p]+=ZDFS(e);\n return ++Z[p];\n}\n\nvoid hlDFS(UL p){\n hlL[hlH[p]]++;\n if(hlH[p] != p) hlP[p]=hlP[P[p]]+1;\n if(E[p].size()!=0) {\n  UL c=E[p].front();\n  for(UL e:E[p]){\n   if(Z[e]>Z[c]) c=e;\n   hlH[e]=e;\n  }\n  hlH[c]=hlH[p];\n }\n for(UL e:E[p]) hlDFS(e);\n if(hlH[p]==p){\n  hlP[p]=hlp;\n  hlp+=hlL[p];\n }\n}\n\nint main() {\n scanf(\"%u\", &N);\n rep(i,N){\n  UL c; scanf(\"%u\", &c);\n  while(c--){ UL v; scanf(\"%u\",&v); P[v]=i; E[i].push_back(v); }\n }\n P[0]=~0u;\n hlH[0]=0;\n ZDFS(0);\n hlDFS(0);\n rep(p,N) if(hlH[p]!=p) hlP[p]+=hlP[hlH[p]];\n \n G.init(N);\n \n scanf(\"%u\", &Q);\n rep(q,Q){\n  UL c; scanf(\"%u\", &c);\n  if(c==0){\n   UL v,w; scanf(\"%u%u\", &v,&w);\n   G.add(hlP[v],w);\n  }\n  else if(c==1){\n   UL u; scanf(\"%u\", &u);\n   UL ans=0;\n   while(u != ~0u){\n    ans+= G.query(hlP[hlH[u]],hlP[u]+1);\n    u=P[hlH[u]];\n   }\n   printf(\"%u\\n\",ans);\n  }\n }\n \n return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define PROBLEM \"http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_D\"\n\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\nstruct FastIO{\n  FastIO(){\n    cin.tie(0);\n    ios::sync_with_stdio(0);\n  }\n}fastio_beet;\n//END CUT HERE\n#ifndef call_from_test\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n#endif\n//BEGIN CUT HERE\ntemplate<typename Node, size_t LIM>\nstruct LinkCutTreeBase{\n  static array<Node, LIM> pool;\n  size_t ptr;\n\n  LinkCutTreeBase():ptr(0){}\n\n  inline Node* create(){\n    return &pool[ptr++];\n  }\n\n  inline Node* create(Node v){\n    return &(pool[ptr++]=v);\n  }\n\n  inline size_t idx(Node *t){\n    return t-&pool[0];\n  }\n\n  Node* operator[](size_t k){\n    return &(pool[k]);\n  }\n\n  virtual void toggle(Node *t) = 0;\n  virtual Node* eval(Node *t) = 0;\n  virtual void pushup(Node *t) = 0;\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    pushup(x);pushup(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      pushup(y);\n    }\n  }\n\n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    pushup(x);pushup(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      pushup(y);\n    }\n  }\n\n  // for splay tree (not original tree)\n  bool is_root(Node *t){\n    return !t->p||(t->p->l!=t&&t->p->r!=t);\n  }\n\n  void splay(Node *t){\n    eval(t);\n    while(!is_root(t)){\n      Node *q=t->p;\n      if(is_root(q)){\n        eval(q);eval(t);\n        if(q->l==t) rotR(t);\n        else rotL(t);\n      }else{\n        auto *r=q->p;\n        eval(r);eval(q);eval(t);\n        if(r->l==q){\n          if(q->l==t) rotR(q),rotR(t);\n          else rotL(t),rotR(t);\n        }else{\n          if(q->r==t) rotL(q),rotL(t);\n          else rotR(t),rotL(t);\n        }\n      }\n    }\n  }\n\n  virtual Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      pushup(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(c);\n    expose(par);\n    c->p=par;\n    par->r=c;\n    pushup(par);\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=nullptr;\n    pushup(c);\n    par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  Node *parent(Node *t){\n    expose(t);\n    if(!(t->l)) return nullptr;\n    t=eval(t->l);\n    while(t->r) t=eval(t->r);\n    splay(t);\n    return t;\n  }\n\n  Node *root(Node *t){\n    expose(t);\n    while(t->l) t=eval(t->l);\n    splay(t);\n    return t;\n  }\n\n  bool is_connected(Node *a,Node *b){\n    return root(a)==root(b);\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n};\ntemplate<typename Node, size_t LIM>\narray<Node, LIM> LinkCutTreeBase<Node, LIM>::pool;\n//END CUT HERE\n#ifndef call_from_test\n//INSERT ABOVE HERE\nsigned main(){\n  return 0;\n}\n#endif\n\n#ifndef call_from_test\n#include<bits/stdc++.h>\nusing namespace std;\n\n#define call_from_test\n#include \"base.cpp\"\n#undef call_from_test\n\n#endif\n//BEGIN CUT HERE\ntemplate<typename Tp,typename Ep>\nstruct NodeBase{\n  using T = Tp;\n  using E = Ep;\n  NodeBase *l,*r,*p;\n  bool rev;\n  T val,dat;\n  E laz;\n  NodeBase(){}\n  NodeBase(T val,E laz):\n    rev(0),val(val),dat(val),laz(laz){\n    l=r=p=nullptr;}\n};\n\ntemplate<typename Np, size_t LIM>\nstruct Path : LinkCutTreeBase<Np, LIM>{\n  using super = LinkCutTreeBase<Np, LIM>;\n  using Node = Np;\n  using T = typename Node::T;\n  using E = typename Node::E;\n\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using S = function<T(T)>;\n  F f;\n  G g;\n  H h;\n  S flip;\n  E ei;\n\n  Path(F f,G g,H h,E ei):\n    super(),f(f),g(g),h(h),ei(ei){\n    flip=[](T a){return a;};\n  }\n\n  Path(F f,G g,H h,S flip,E ei):\n    super(),f(f),g(g),h(h),flip(flip),ei(ei){}\n\n  Node* create(T val){\n    return super::create(Node(val,ei));\n  }\n\n  inline void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,v);\n    t->dat=g(t->dat,v);\n  }\n\n  inline void toggle(Node *t){\n    swap(t->l,t->r);\n    t->dat=flip(t->dat);\n    t->rev^=1;\n  }\n\n  inline Node* eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n    return t;\n  }\n\n  inline void pushup(Node *t){\n    t->dat=t->val;\n    if(t->l) t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->dat=f(t->dat,t->r->dat);\n  }\n\n  using super::expose;\n\n  T query(Node *t){\n    expose(t);\n    return t->dat;\n  }\n\n  void update(Node *t,E v){\n    expose(t);\n    propagate(t,v);\n    eval(t);\n  }\n};\n//END CUT HERE\n#ifndef call_from_test\n\n#define call_from_test\n#include \"../tools/fastio.cpp\"\n#include \"../mod/mint.cpp\"\n#include \"../linearalgebra/squarematrix.cpp\"\n#undef call_from_test\n\n// test edge folding\nsigned YUKI_650(){\n  using M = Mint<int>;\n  using SM = SquareMatrix<M, 2>;\n  using SM2 = pair<SM, SM>;\n  using Node = NodeBase<SM2, SM2>;\n  constexpr size_t LIM = 1e6;\n  using LCT = Path<Node, LIM>;\n\n  auto f=[](SM2 x,SM2 y){return SM2(x.first*y.first,y.second*x.second);};\n  auto g=[](SM2 x,SM2 y){(void)x;return y;};\n  auto flip=[](SM2 x){swap(x.first,x.second);return x;};\n\n  SM ti=SM::mul_identity();\n  SM ei=SM::mul_identity();\n  SM2 ti2(ti,ti),ei2(ei,ei);\n  LCT lct(f,g,g,flip,ei2);\n\n  int n;\n  cin>>n;\n  vector< vector<int> > G(n);\n  vector<int> X,Y;\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    X.emplace_back(a);\n    Y.emplace_back(b);\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n\n  for(int i=0;i<n*2-1;i++) lct.create(ti2);\n\n  vector< map<int, int> > rev(n);\n  int idx=n;\n  {\n    using P = pair<int, int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p){\n        lct.link(lct[p],lct[idx]);\n        lct.link(lct[idx],lct[v]);\n        rev[p][v]=rev[v][p]=idx++;\n      }\n      for(int u:G[v])\n        if(u!=p) q.emplace(u,v);\n    }\n  }\n\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    char c;\n    cin>>c;\n    if(c=='x'){\n      int v,a,b,c,d;\n      cin>>v>>a>>b>>c>>d;\n      int z=rev[X[v]][Y[v]];\n      lct.expose(lct[z]);\n      SM sm;\n      sm[0][0]=a;sm[0][1]=b;\n      sm[1][0]=c;sm[1][1]=d;\n      lct[z]->val=SM2(sm,sm);\n      lct.pushup(lct[z]);\n    }\n    if(c=='g'){\n      int x,y;\n      cin>>x>>y;\n      lct.evert(lct[x]);\n      SM ans=lct.query(lct[y]).first;\n      cout<<ans[0][0]<<\" \"<<ans[0][1]<<\" \";\n      cout<<ans[1][0]<<\" \"<<ans[1][1]<<\"\\n\";\n    }\n  }\n  cout<<flush;\n  return 0;\n}\n/*\n  verified on 2020/01/08\n  https://yukicoder.me/problems/no/650\n*/\n\n// test dynamic tree\nsigned SPOJ_DYNACON1(){\n  int n,m;\n  cin>>n>>m;\n  using Node = NodeBase<int, int>;\n  constexpr size_t LIM = 1e6;\n  using LCT = Path<Node, LIM>;\n\n  auto f=[](int a,int b){return a+b;};\n  LCT lct(f,f,f,0);\n  for(int i=0;i<n;i++) lct.create(0);\n\n  for(int i=0;i<m;i++){\n    string s;\n    int a,b;\n    cin>>s>>a>>b;\n    a--;b--;\n    if(s==\"add\"s){\n      lct.evert(lct[b]);\n      lct.link(lct[a],lct[b]);\n    }\n    if(s==\"rem\"s){\n      auto v=lct.lca(lct[a],lct[b])==lct[a]?lct[b]:lct[a];\n      lct.cut(v);\n    }\n    if(s==\"conn\"s)\n      cout<<(lct.is_connected(lct[a],lct[b])?\"YES\\n\":\"NO\\n\");\n  }\n  cout<<flush;\n  return 0;\n}\n/*\n  verified on 2020/01/08\n  https://www.spoj.com/problems/DYNACON1/\n*/\n\nsigned main(){\n  //YUKI_650();\n  //SPOJ_DYNACON1();\n  return 0;\n}\n#endif\n\n#undef call_from_test\n\nsigned main(){\n  int n;\n  cin>>n;\n\n  using Node = NodeBase<int, int>;\n  constexpr size_t LIM = 1e6;\n  using LCT = Path<Node, LIM>;\n\n  auto f=[](int a,int b){return a+b;};\n  LCT lct(f,f,f,0);\n\n  for(int i=0;i<n;i++) lct.create(0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lct.link(lct[i],lct[c]);\n    }\n  }\n\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lct.expose(lct[a]);\n      lct[a]->val+=b;\n      lct.pushup(lct[a]);\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      cout<<lct.query(lct[a])<<\"\\n\";\n    }\n  }\n  cout<<flush;\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n//1-indexed\ntemplate<typename T>\nstruct BIT{\n\tint n;\n\tvector<T>bit;\n\tBIT():n(-1){}\n\tBIT(int n_,T a):n(n_),bit(n_+1,a){}\n\n\tT sum(int i)\n\t{\n\t\tT ans=0;\n\t\tfor(;i>0;i-=i&-i)ans+=bit[i];\n\t\treturn ans;\n\t}\n\tvoid add(int i,T a)\n\t{\n\t\tif(i==0)return;\n\t\tfor(;i<=n;i+=i&-i)bit[i]+=a;\n\t}\n};\nvector<int>G[1<<17];\nint n;\nint f[1<<17],l[1<<17];\nint dfs(int u,int cnt)\n{\n\tf[u]=cnt++;\n\tfor(int i=0;i<G[u].size();i++)cnt=dfs(G[u][i],cnt);\n\tl[u]=cnt++;\n\treturn cnt;\n}\nmain()\n{\n\tscanf(\"%d\",&n);\n\tfor(int i=0;i<n;i++)\n\t{\n\t\tint k;scanf(\"%d\",&k);\n\t\tfor(int j=0;j<k;j++)\n\t\t{\n\t\t\tint x;scanf(\"%d\",&x);\n\t\t\tG[i].push_back(x);\n\t\t}\n\t}\n\tBIT<int>a(dfs(0,1),0);\n\tint c,x,y,q;scanf(\"%d\",&q);\n\tfor(;q--;)\n\t{\n\t\tscanf(\"%d\",&c);\n\t\tif(!c)\n\t\t{\n\t\t\tscanf(\"%d%d\",&x,&y);\n\t\t\ta.add(f[x],y);\n\t\t\ta.add(l[x],-y);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%d\\n\",a.sum(l[x]-1));\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> G[100010];\n\n#define MAX_N 1<<17\nint n,dat[2*(MAX_N)-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nint find(int k){\n  k+=n-1;\n  int ans=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    ans+=dat[k];\n  }\n  return ans;\n}\n\n\nvoid update(int a,int b,int x,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l)return;\n  if(a<=l&&r<=b){\n    dat[k]+=x;\n  }else{\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n}\n\nint num[2][200010];\nint a;\nvoid dfs(int k=0){\n  num[0][k]=a;\n  a++;\n  for(int i=0;i<G[k].size();i++){\n    dfs(G[k][i]);\n  }\n  num[1][k]=a;\n}\n\nint main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int a;\n      cin>>a;\n      G[i].push_back(a);\n    }\n  }\n  dfs();\n  init(a);\n  // cout<<num[1][0]<<\" happy\"<<endl;\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int x;\n    cin>>x;\n    if(x==0){\n      int w,v;\n      cin>>v>>w;\n      update(num[0][v],num[1][v]+1,w);\n    }else{\n      int u;\n      cin>>u;\n      cout<<find(num[0][u])<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nclass HLDecomposition\n{\n    int n, pos;\n    std::vector<std::vector<int>> G;\n    std::vector<int> vid, head, sub, hvy, par, dep, inv, type;\n\n    void dfs(int rt)\n    {\n        using T = std::pair<int, int>;\n        std::stack<T> st;\n        par[rt] = -1;\n        dep[rt] = 0;\n        st.emplace(rt, 0);\n        while (!st.empty())\n        {\n            int v = st.top().first;\n            int &i = st.top().second;\n            if (i < (int)G[v].size())\n            {\n                int u = G[v][i++];\n                if (u == par[v])\n                    continue;\n                par[u] = v;\n                dep[u] = dep[v] + 1;\n                st.emplace(u, 0);\n            }\n            else\n            {\n                st.pop();\n                int res = 0;\n                for (int u : G[v])\n                {\n                    if (u == par[v])\n                        continue;\n                    sub[v] += sub[u];\n                    if (res < sub[u])\n                        res = sub[u], hvy[v] = u;\n                }\n            }\n        }\n    }\n\n    void bfs(int r, int c)\n    {\n        int &k = pos;\n        std::queue<int> q({r});\n        while (!q.empty())\n        {\n            int h = q.front();\n            q.pop();\n            for (int i = h; i != -1; i = hvy[i])\n            {\n                type[i] = c;\n                vid[i] = k++;\n                inv[vid[i]] = i;\n                head[i] = h;\n                for (int j : G[i])\n                    if (j != par[i] && j != hvy[i])\n                        q.push(j);\n            }\n        }\n    }\n\npublic:\n    HLDecomposition() {}\n    HLDecomposition(int sz) : n(sz), pos(0), G(n),\n                              vid(n, -1), head(n), sub(n, 1), hvy(n, -1),\n                              par(n), dep(n), inv(n), type(n) {}\n\n    void add_edge(int u, int v)\n    {\n        G[u].push_back(v);\n        G[v].push_back(u);\n    }\n\n    void build(std::vector<int> rs = std::vector<int>(1, 0))\n    {\n        int c = 0;\n        for (int r : rs)\n        {\n            dfs(r);\n            bfs(r, c++);\n        }\n    }\n\n    // for_each(vertex)\n    // [l,r] <- attention!!\n    void for_each_vertex(int u, int v, const std::function<void(int, int)> &f)\n    {\n        while (1)\n        {\n            if (vid[u] > vid[v])\n                std::swap(u, v);\n            f(std::max(vid[head[v]], vid[u]), vid[v]);\n            if (head[u] != head[v])\n                v = par[head[v]];\n            else\n                break;\n        }\n    }\n\n    // for_each(edge)\n    // [l,r] <- attention!!\n    void for_each_edge(int u, int v, const std::function<void(int, int)> &f)\n    {\n        while (1)\n        {\n            if (vid[u] > vid[v])\n                std::swap(u, v);\n            if (head[u] != head[v])\n            {\n                f(vid[head[v]], vid[v]);\n                v = par[head[v]];\n            }\n            else\n            {\n                if (u != v)\n                    f(vid[u] + 1, vid[v]);\n                break;\n            }\n        }\n    }\n\n    int lca(int u, int v)\n    {\n        while (1)\n        {\n            if (vid[u] > vid[v])\n                std::swap(u, v);\n            if (head[u] == head[v])\n                return u;\n            v = par[head[v]];\n        }\n    }\n\n    int distance(int u, int v)\n    {\n        return dep[u] + dep[v] - 2 * dep[lca(u, v)];\n    }\n};\n\nclass LazySegmentTree\n{\n    int n;\n    using T1 = int;\n    using T2 = int;\n    std::vector<T1> node;\n    std::vector<T2> lazy;\n\n    // 遅延評価\n    void eval(int k, int l, int r)\n    {\n        // 遅延配列が空なら終了\n        if (lazy[k] == 0)\n            return;\n        // 遅延配列を適用\n        node[k] = node[k] + lazy[k];\n        if (r - l > 1)\n        {\n            lazy[2 * k + 1] = lazy[2 * k + 1] + lazy[k] / 2;\n            lazy[2 * k + 2] = lazy[2 * k + 2] + lazy[k] / 2;\n        }\n        // 遅延配列初期化\n        lazy[k] = 0;\n    }\n\n  public:\n    LazySegmentTree(int _n)\n    {\n        int sz = _n;\n        n = 1;\n        while (n < sz)\n            n *= 2;\n        // 配列初期化\n        node.resize(2 * n - 1, 0);\n        lazy.resize(2 * n - 1, 0);\n    }\n    LazySegmentTree(int _n, T1 _v)\n    {\n        int sz = _n;\n        n = 1;\n        while (n < sz)\n            n *= 2;\n        node.resize(2 * n - 1, 0);\n        lazy.resize(2 * n - 1, 0);\n\n        for (int i = 0; i < sz; i++)\n            node[i + n - 1] = _v;\n        for (int i = n - 2; i >= 0; i--)\n            node[i] = node[i * 2 + 1] + node[i * 2 + 2];\n    }\n\n    // 半開区間 [a, b) に対して値 val を反映させる\n    void update(int a, int b, T2 val, int l = 0, int r = -1, int k = 0)\n    {\n        if (r < 0)\n            r = n;\n        // ノード k で遅延評価\n        eval(k, l, r);\n        if (b <= l || r <= a)\n            return;\n        // 区間が被覆されている場合\n        if (a <= l && r <= b)\n        {\n            // 遅延配列更新, 評価\n            lazy[k] = lazy[k] + (r - l) * val;\n            eval(k, l, r);\n        }\n        else\n        {\n            // 子ノードの値を評価し, 更新\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2 * k + 1);\n            update(a, b, val, mid, r, 2 * k + 2);\n            node[k] = node[2 * k + 1] + node[2 * k + 2];\n        }\n    }\n\n    // 半開区間 [a, b) に対してクエリを投げる\n    T1 query(int a, int b, int l = 0, int r = -1, int k = 0)\n    {\n        if (r < 0)\n            r = n;\n        eval(k, l, r);\n        // 範囲外なら単位元返す\n        if (b <= l || r <= a)\n            return 0;\n        if (a <= l && r <= b)\n            return node[k];\n        int mid = (l + r) / 2;\n        T1 vl = query(a, b, l, mid, 2 * k + 1);\n        T1 vr = query(a, b, mid, r, 2 * k + 2);\n        return vl + vr;\n    }\n};\n\n\nusing namespace std;\n\nvoid solve_grl_5_d()\n{\n    int n;\n    cin >> n;\n    HLDecomposition hld(n);\n    LazySegmentTree lst(n);\n    vector<int> par(n, -1);\n    for (int i = 0; i < n; i++)\n    {\n        int k;\n        cin >> k;\n        for (int j = 0; j < k; j++)\n        {\n            int c;\n            cin >> c;\n            hld.add_edge(i, c);\n            par[c] = i;\n        }\n    }\n    hld.build();\n    int q;\n    cin >> q;\n    while (q--)\n    {\n        int type;\n        cin >> type;\n        if (type == 0)\n        {\n            int v, w;\n            cin >> v >> w;\n            hld.for_each_edge(par[v], v, [&](int l, int r) {\n                lst.update(l, r + 1, w);\n            });\n            continue;\n        }\n        int u;\n        cin >> u;\n        long long ret = 0;\n        hld.for_each_edge(0, u, [&](int l, int r) {\n            ret += lst.query(l, r + 1);\n        });\n        cout << ret << endl;\n    }\n}\n\nint main()\n{\n    solve_grl_5_d();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n\n#define NMAX 100000\n#define QMAX 200000\n#define WMAX 10000\n\nusing namespace std;\n\nclass RQS{\nprivate:\n    int size;\n    vector<int> Tree;\n    vector<vector<int> > Node;\n    vector<int> numbers;\n    vector<int> numbers_child;\n    \n    void dfs(int index) {\n        static int id = 0;\n        numbers[index] = id++;\n        for (int i = 0; i < Node[index].size(); ++i)\n            dfs(Node[index][i]);\n        numbers_child[index] = id;\n    }\n    \n    void update(int index, int weight, int a, int b, int left, int right) {\n        if (right <= a || b <= left)\n            return;\n        else if (a <= left && right <= b)\n            Tree[index] += weight;\n        else {\n            int mid = (left + right) / 2;\n            update(index * 2 + 1, weight, a, b, left, mid);\n            update(index * 2 + 2, weight, a, b, mid, right);\n        }\n    }\n    \npublic:\n    RQS(){\n        int RSize;\n        cin >> RSize;\n        \n        if(!(2 <= RSize && RSize <= NMAX))\n            exit(1);\n        \n        Node.resize(RSize);\n        for (int i = 0; i < RSize; i++) {\n            int k, v;\n            cin >> k;\n            \n            for (int j = 0; j < k; j++) {\n                cin >> v;\n                Node[i].push_back(v);\n            }\n        }\n        \n        size = 1;\n        while (size < RSize)\n            size *= 2;\n        \n        numbers.resize(RSize, -1);\n        numbers_child.resize(RSize, -1);\n        Tree.resize(2 * size - 1, 0);\n        \n        dfs(0);\n    }\n    \n    int sum(int target) {\n        if(!(0 <= target && target < size))\n            exit(1);\n        \n        int index = numbers[target];\n        index += size - 1;\n        int sum = Tree[index];\n        while (index > 0) {\n            index = (index - 1) / 2;\n            sum += Tree[index];\n        }\n        \n        return sum;\n    }\n    \n    void update(int target, int weight){\n        if(!(1 <= target && target < size) || !(1 <= weight && weight <= WMAX))\n            exit(1);\n        update(0, weight, numbers[target], numbers_child[target], 0, size);\n    }\n};\n\nint main() {\n    RQS rqs;\n    int q, o, v, w;\n    \n    cin >> q;\n    if(!(2 <= q && q <= QMAX))\n        exit(1);\n        \n    for (int i = 0; i < q; i++) {\n        cin >> o;\n        if (o == 0) {\n            cin >> v >> w;\n            rqs.update(v, w);\n        }\n        else if(o == 1){\n            cin >> v;\n            cout << rqs.sum(v) << endl;\n        }\n        else\n            exit(1);\n    }\n    \n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n#define PB push_back\nconst int N=1e5+10;\nstruct BIT{\n    vector<int> v;\n    void init(int size){\n        v.resize(size,0);\n        return ;\n    }\n    void add(int n,int x){\n        while(n<v.size()){\n            v[n]+=x;\n            n+=n&-n;\n        }\n        return ;\n    }\n    int ask(int n){\n        int ans=0;\n        while(n){\n            ans+=v[n];\n            n^=n&-n;\n        }\n        return ans;\n    }\n};\nvector<int> graph[N];\nint p[N],dep[N],to[N],top[N],size[N],val[N];\nBIT b[N];\nvoid dfs(int now){\n    int temp=0;\n    size[now]=1;\n    val[now]=0;\n    for(int i:graph[now]){\n        dep[i]=dep[now]+1;\n        dfs(i);\n        if(size[i]>temp){\n            temp=size[i];\n            to[now]=i;\n        }\n        size[now]+=size[i];\n    }\n    return ;\n}\nvoid init(int now){\n    if(graph[now].empty())b[top[now]].init(dep[now]-dep[top[now]]+1);\n    for(int i:graph[now]){\n        if(i==to[now])top[i]=top[now];\n        else top[i]=i;\n        init(i);\n    }\n    return ;\n}\nint query(int n){\n    int ans=0;\n    while(n>0){\n        ans+=b[top[n]].ask(dep[n]-dep[top[n]]);\n        ans+=val[top[n]];\n        n=p[top[n]];\n    }\n    return ans;\n}\nint main(){\n    int n,k,temp,q;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        for(int j=0;j<k;j++){\n            scanf(\"%d\",&temp);\n            graph[i].PB(temp);\n            p[temp]=i;\n        }\n    }\n    top[0]=0;\n    p[0]=-1;\n    dep[0]=0;\n    dfs(0);\n    init(0);\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%d\",&k);\n        if(k==0){\n            scanf(\"%d%d\",&k,&temp);\n            if(k==top[k])val[k]+=temp;\n            else b[top[k]].add(dep[k]-dep[top[k]],temp);\n        }\n        else{\n            scanf(\"%d\",&k);\n            printf(\"%d\\n\",query(k));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvoid dfs(vector<vector<int>>& childLists, vector<vector<int>>& edgeIds, vector<int>& weights, const int& v){\n    for(int i = 0; i < childLists[v].size(); i++){\n        int u = childLists[v][i];\n        weights.push_back(0);\n        edgeIds[u].push_back(weights.size()-1);\n        dfs(childLists, edgeIds, weights, u);\n        weights.push_back(0);\n        edgeIds[u].push_back(weights.size()-1);\n    }\n}\n\nvoid add(vector<int>& tree, const int& n, const int& k, const int& w){\n    int i = k + n - 1; \n    while(i > 0){\n        tree[i] += w;\n        i = (i - 1)/2;\n    }\n    tree[i] += w;\n}\n\nint getSumUtil(vector<int>& tree, const int& L, const int& R, const int& i, const int& l, const int& r){\n    if(i >= tree.size() || l > r){\n        return 0;\n    }\n    if(r < L || l > R){\n        return 0;\n    }\n    if(l >= L && r <= R){\n        return tree[i];\n    }\n    int m = l + (r - l)/2;\n    return  getSumUtil(tree, L, R, 2*i+1, l, m) + getSumUtil(tree, L, R, 2*i+2, m+1, r);\n}\n\nint getSum(vector<int>& tree, const int& n, const int& L, const int& R){\n    return getSumUtil(tree, L, R, 0, 0, n-1);\n}\n\nint main(){\n    int n, q, k, x, v, w;\n    scanf(\"%d\", &n);\n    vector<vector<int>> childLists(n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", &k);\n        for(int j = 0; j < k; j++){\n            scanf(\"%d\", &x);\n            childLists[i].push_back(x);\n        }\n    }\n    vector<int> weights;\n    vector<vector<int>> edgeIds(n);\n    dfs(childLists, edgeIds, weights, 0);\n    int h = ceil(log2(weights.size()))+1;\n    int max_size = pow(2, h)-1;\n    vector<int> tree(max_size, 0);\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++){\n        scanf(\"%d\", &x);\n        if(x == 0){\n            scanf(\"%d %d\", &v, &w);\n            add(tree, pow(2, h-1), edgeIds[v][0], w);\n            add(tree, pow(2, h-1), edgeIds[v][1], -w);\n        }\n        else if(x == 1){\n            scanf(\"%d\", &v);\n            printf(\"%d\\n\", getSum(tree, pow(2, h-1), 0, edgeIds[v][0]));\n        }\n        else printf(\"invalid query %d\\n\", x);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nstruct RSQ{\n  ll n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 1 index\n  /*void add(int i,int v){\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }*/\n  // 0 index\n  void add(int i,ll v){\n    i+=1;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  ll sum(int i){\n    ll res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) 1 index\n  /*int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }*/\n  //[a,b) 0 index\n  int sum(int x,int y){\n    x++;y++;\n    return sum(y-1)-sum(x-1);\n  }\n};\n \nstruct HLD {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  RSQ rsq;\n\n  HLD(){}\n  HLD(int sz):n(sz),pos(0),G(n),vid(n,-1),head(n),sub(n,1),hvy(n,-1),par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int i=0;i<rs.size();i++){\n        int r=rs[i];\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    stack<P> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.push(P(rt,0));\n    while(!st.empty()){\n        int v=st.top().first;\n        int &i=st.top().second;\n        if(i<(int)G[v].size()){\n            int u=G[v][i++];\n            if(u==par[v]) continue;\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            st.push(P(u,0));\n        }else{\n            st.pop();\n            int res=0;\n            for(int i=0;i<G[v].size();i++){\n                int u=G[v][i];\n                if(u==par[v]) continue;\n                sub[v]+=sub[u];\n                if(res<sub[u]) res=sub[u],hvy[v]=u;\n            }\n        }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n        type[i]=c;\n        vid[i]=k++;\n        inv[vid[i]]=i;\n        head[i]=h;\n        for(int J=0;J<G[i].size();J++){\n            int j=G[i][J];\n            if(j!=par[i]&&j!=hvy[i]) q.push(j);\n        }\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  int for_each(int u, int v) {\n    int ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      //f(max(vid[head[v]],vid[u]),vid[v]);\n      //ans = max(ans,rmq.query(l, r + 1));\n      if(head[u]!=head[v]) v=par[head[v]];\n      else {return ans;}\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  ll for_each_edge(int u, int v) {\n    ll ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n        //f(vid[head[v]],vid[v]);\n        ans += rsq.sum(vid[head[v]],vid[v]+1);\n        v=par[head[v]];\n      } else{\n        //if(u!=v) f(vid[u]+1,vid[v]);\n        if(u!=v) ans += rsq.sum(vid[u]+1,vid[v]+1);\n        return ans;\n      }\n    }\n  }\n\n  void update(int u,int w){\n    rsq.add(vid[u],w);\n  }\n\n  void range_update(){\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\nint main(){\n    int n,m,x,w;\n    scanf(\"%d\",&n);\n    HLD Tree(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&x);\n            Tree.add_edge(i,x);\n        }\n    }\n    Tree.build();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        if(m==0){\n            scanf(\"%d%d\",&x,&w);\n            Tree.update(x,w);\n        }\n        else{\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",Tree.for_each_edge(0,x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n  using iterator = vector<Edges>::iterator;\n  using const_iterator = vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  Edges &operator[](const int &i) { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nclass HLDecomposition {\n  Graph g;\n  int vertexId = 0;\n  vector<int> _parent; // _parent[v] := parent of v, parent[root] = -1\n  vector<int> subsize; // subsize[v] := size of subtree rooted at v\n  vector<int> depth; // depth[v] := depth of v\n  vector<int> next; // next[v] := next vertex of v on heavy-path, next[last] := -1\n  vector<int> head; // head[v] := head vertex on heavy-path contains v\n  vector<int> treeId; // treeId[v] := id of tree contains v\n  vector<int> newVertexId; // newVertexId[v] := reassigned vertex id of v\n\n  void decompose(const int &r) {\n    stack<pair<int, int>> s;\n    _parent[r] = -1;\n    depth[r] = 0;\n    s.emplace(r, 0);\n    while (s.size()) {\n      int v = s.top().first;\n      int &i = s.top().second;\n      if (i < g[v].size()) {\n        int u = g[v][i++].dst;\n        if (u == _parent[v]) continue;\n        _parent[u] = v;\n        depth[u] = depth[v] + 1;\n        s.emplace(u, 0);\n      } else {\n        s.pop();\n        int mini = 0;\n        for (auto &e : g[v]) {\n          if (e.dst == _parent[v]) continue;\n          subsize[v] += subsize[e.dst];\n          if (cmax(mini, subsize[e.dst])) next[v] = e.dst;\n        }\n      }\n    }\n  }\n\n  void reassign(const int &root, const int &tid) {\n    queue<int> q({root});\n    while (q.size()) {\n      int h = q.front();\n      q.pop();\n      for (int v = h; v != -1; v = next[v]) {\n        head[v] = h;\n        treeId[v] = tid;\n        newVertexId[v] = vertexId++;\n        for (auto &e : g[v]) {\n          if (e.dst == _parent[v] || e.dst == next[v]) continue;\n          q.emplace(e.dst);\n        }\n      }\n    }\n  }\n\npublic:\n  struct segment {\n    int l, r; // [l, r)\n    segment(const int &l, const int &r) : l(l), r(r) {}\n  };\n\n  vector<segment> vertexSegments(int u, int v) {\n    vector<segment> segs;\n    while (true) {\n      if (newVertexId[u] > newVertexId[v]) swap(u, v);\n      segs.emplace_back(max(newVertexId[u], newVertexId[head[v]]), newVertexId[v] + 1);\n      if (head[u] == head[v]) break;\n      v = _parent[head[v]];\n    }\n    return segs;\n  }\n\n  vector<segment> edgeSegments(int u, int v) {\n    vector<segment> segs;\n    while (true) {\n      if (newVertexId[u] > newVertexId[v]) swap(u, v);\n      if (head[u] == head[v]) {\n        if (u != v) segs.emplace_back(newVertexId[u] + 1, newVertexId[v] + 1);\n        break;\n      }\n      segs.emplace_back(newVertexId[head[v]], newVertexId[v] + 1);\n      v = _parent[head[v]];\n    }\n    return segs;\n  }\n\n  int parent(const int &v) { return _parent[v]; }\n\n  int lca(int u, int v) {\n    while (true) {\n      if (newVertexId[u] > newVertexId[v]) swap(u, v);\n      if (head[u] == head[v]) return u;\n      v = _parent[head[v]];\n    }\n  }\n\n  int distance(const int &u, const int &v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }\n\n  HLDecomposition(const Graph &g, const vector<int> &roots = {0})\n      : g(g), _parent(g.size()), subsize(g.size(), 1), depth(g.size()), //\n        next(g.size(), -1), head(g.size()), treeId(g.size()), newVertexId(g.size(), -1) {\n    int treeId = 0;\n    for (auto &r : roots) decompose(r), reassign(r, treeId++);\n  }\n};\n\ntemplate<typename Monoid> class SegTree {\n  using T = typename Monoid::value_type;\n\n  Monoid m;\n  vector<T> tree; // 1-indexed\n  int size = 1;\n\npublic:\n  SegTree(const int &n = 0) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, m.id());\n  }\n\n  SegTree(const int &n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, x);\n    for (int i = size - 1; i >= 1; i--) tree[i] = m(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  template<typename InputIterator> SegTree(InputIterator first, InputIterator last) {\n    int n = distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2, m.id());\n    copy(first, last, tree.begin() + size);\n    for (int i = size - 1; i >= 1; i--) tree[i] = m(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  T fold(int l, int r) { // [l, r)\n    T accl = m.id(), accr = m.id();\n    for (l += size, r += size; l < r; l /= 2, r /= 2) {\n      if (l & 1) accl = m(accl, tree[l++]);\n      if (r & 1) accr = m(tree[--r], accr);\n    }\n    return m(accl, accr);\n  }\n\n  void update(int i, const T &x) {\n    tree[i += size] = x;\n    while (i /= 2) tree[i] = m(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  const T &operator[](int i) const { return tree[i + size]; }\n};\n\ntemplate<typename T> class RangeSum {\n  struct trait {\n    using value_type = T;\n    T id() { return T(); }\n    T operator()(const T &a, const T &b) { return a + b; }\n  };\n  SegTree<trait> st;\n\npublic:\n  RangeSum(const int &n = 0) : st(n) {}\n  RangeSum(const int &n, const T &x) : st(n, x) {}\n  template<typename InputIterator> RangeSum(InputIterator first, InputIterator last) : st(first, last) {}\n  void update(const int &i, const T &x) { st.update(i, x); }\n  T sum(const int &l, const int &r) { return st.fold(l, r); }\n  T operator[](const int &i) { return st[i]; }\n};\n\nmain {\n  int n = in();\n  Graph g(n);\n  rep(i, n) {\n    int k = in();\n    while (k--) g.addEdge(i, in());\n  }\n  HLDecomposition hld(g);\n  RangeSum<int> rs(n);\n  int q = in();\n  while (q--) {\n    if (in()) {\n      int sum = 0;\n      for (auto &p : hld.edgeSegments(0, in())) sum += rs.sum(p.l, p.r);\n      cout << sum << endl;\n    } else {\n      int v, w;\n      cin >> v >> w;\n      for (auto &p : hld.edgeSegments(v, hld.parent(v))) rs.update(p.l, rs[p.l] + w);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Monoid = int, typename OperatorMonoid = Monoid >\nstruct LinkCutTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  struct Node {\n    Node *l, *r, *p;\n    int idx;\n    Monoid key, sum;\n    OperatorMonoid lazy;\n\n    bool rev;\n    int sz;\n\n    bool is_root() {\n      return !p || (p->l != this && p->r != this);\n    }\n\n    Node(int idx, const Monoid &key, const OperatorMonoid &om) :\n        idx(idx), key(key), sum(key), lazy(om), sz(1),\n        l(nullptr), r(nullptr), p(nullptr), rev(false) {}\n  };\n\n  const Monoid M1;\n  const OperatorMonoid OM0;\n  const F f;\n  const G g;\n  const H h;\n\n  LinkCutTree() : LinkCutTree(F(), Monoid()) {}\n\n  LinkCutTree(const F &f, const Monoid &M1) :\n      LinkCutTree(f, G(), H(), M1, OperatorMonoid()) {}\n\n  LinkCutTree(const F &f, const G &g, const H &h,\n              const Monoid &M1, const OperatorMonoid &OM0) :\n      f(f), g(g), h(h), M1(M1), OM0(OM0) {}\n\n  Node *make_node(int idx, const Monoid &v = Monoid()) {\n    return new Node(idx, v, OM0);\n  }\n\n  void push(Node *t) {\n    if(t->lazy != OM0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy, 1);\n      t->sum = g(t->sum, t->lazy, t->sz);\n      t->lazy = OM0;\n    }\n    if(t->rev) {\n      swap(t->l, t->r);\n      if(t->l) t->l->rev ^= true;\n      if(t->r) t->r->rev ^= true;\n    }\n  }\n\n  void update(Node *t) {\n    t->sz = 1;\n    t->sum = t->key;\n    if(t->l) t->sz += t->l->sz, t->sum = t->l->sum + t->sum;\n    if(t->r) t->sz += t->r->sz, t->sum = t->sum + t->r->sum;\n  }\n\n  void rotr(Node *t) { // 右回転\n    auto *x = t->p, *y = x->p;\n    if((x->l = t->r)) t->r->p = x;\n    t->r = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void rotl(Node *t) { // 左回転\n    auto *x = t->p, *y = x->p;\n    if((x->r = t->l)) t->l->p = x;\n    t->l = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t) {\n    push(t);\n    while(!t->is_root()) {\n      auto *q = t->p;\n      if(q->is_root()) {\n        push(q), push(t);\n        if(q->l == t) rotr(t);\n        else rotl(t);\n      } else {\n        auto *r = q->p;\n        push(r), push(q), push(t);\n        if(r->l == q) {\n          if(q->l == t) rotr(q), rotr(t);\n          else rotl(t), rotr(t);\n        } else {\n          if(q->r == t) rotl(q), rotl(t);\n          else rotr(t), rotl(t);\n        }\n      }\n    }\n  }\n\n  Node *expose(Node *t) {\n    Node *rp = nullptr;\n    for(Node *cur = t; cur; cur = cur->p) {\n      splay(cur);\n      cur->r = rp;\n      update(cur);\n      rp = cur;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *child, Node *parent) {\n    expose(child);\n    expose(parent);\n    child->p = parent;\n    parent->r = child;\n  }\n\n  void cut(Node *child) {\n    expose(child);\n    auto *parent = child->l;\n    child->l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert(Node *t) {\n    expose(t);\n    t->rev ^= true;\n    push(t);\n  }\n\n  Node *lca(Node *u, Node *v) {\n    expose(u);\n    return expose(v);\n  }\n};\n\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  LinkCutTree<> lctree;\n  vector< LinkCutTree<>::Node * > uku(N);\n  for(int i = 0; i < N; i++) {\n    uku[i] = lctree.make_node(i);\n  }\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int T;\n      scanf(\"%d\", &T);\n      lctree.link(uku[T], uku[i]);\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int T;\n    scanf(\"%d\", &T);\n    if(T == 0) {\n      int V, W;\n      scanf(\"%d %d\", &V, &W);\n      lctree.expose(uku[V]);\n      uku[V]->key = W;\n    } else {\n      int U;\n      scanf(\"%d\", &U);\n      lctree.expose(uku[U]);\n      printf(\"%d\\n\", uku[U]->sum);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint tim = 1, q, n, t1, t2, t3, start[100005], nd[100005], f[100005];\nvector <int> v[100005];\n\nvoid dfs(int node) {\n\tstart[node] = tim++;\n\tfor (int i : v[node]) {\n\t\tdfs(i);\n\t}\n\tnd[node] = tim;\n\treturn;\n}\n\nint query(int p) {\n\tint re = 0;\n\twhile (p > 0) {\n\t\tre += f[p];\n\t\tp -= ((-p) & p);\n\t}\n\treturn re;\n}\n\nvoid update(int p, int val) {\n\twhile (p <= n) {\n\t\tf[p] += val;\n\t\tp += ((-p) & p);\n\t}\n\treturn;\n}\n\nint main() {\n\tcin >> n;\n\tfor (int i = 0; i < n; i++) {\n\t\tcin >> t1;\n\t\tfor (int j = 0; j < t1; j++) {\n\t\t\tcin >> t2;\n\t\t\tv[i].push_back(t2);\n\t\t}\n\t}\n\tdfs(0);\n\tcin >> q;\n\tfor (int i = 0; i < q; i++) {\n\t\tcin >> t1;\n\t\tif (t1 == 0) {\n\t\t\tcin >> t2 >> t3;\n\t\t\tupdate(start[t2], t3);\n\t\t\tupdate(nd[t2], -t3);\n\t\t}\n\t\telse {\n\t\t\tcin >> t2;\n\t\t\tcout << query(start[t2]) << endl;\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n  struct Node{\n    Node *l,*r,*p;\n    size_t cnt;\n    int idx;\n    bool rev;\n    T val,dat;\n    E laz;\n    Node():cnt(0){}\n    Node(int idx,T val,E laz):\n      cnt(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n    bool is_root(){\n      return !p||(p->l!=this&&p->r!=this);\n    }\n  };\n  \n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  F f;\n  G g;\n  H h;\n  P p;\n  T ti;\n  E ei;\n  \n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n  \n  LinkCutTree(F f,G g,H h,P p,T ti,E ei):\n    f(f),g(g),h(h),p(p),ti(ti),ei(ei),pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(int idx,T v){\n    return &(pool[ptr++]=Node(idx,v,ei));\n  }\n\n  void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,v);\n    t->dat=g(t->dat,p(v,t->cnt));\n  }\n\n  void toggle(Node *t){\n    swap(t->l,t->r);\n    t->rev^=1;\n  }\n\n  void eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n  }\n\n  void update(Node *t){\n    t->cnt=1;\n    t->dat=t->val;\n    if(t->l) t->cnt+=t->l->cnt,t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->cnt+=t->r->cnt,t->dat=f(t->dat,t->r->dat);\n  }\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n  \n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t){\n    eval(t);\n    while(!t->is_root()){\n      Node *q=t->p;\n      if(q->is_root()){\n\teval(q);eval(t);\n\tif(q->l==t) rotR(t);\n\telse rotL(t);\n      }else{\n\tauto *r=q->p;\n\teval(r);eval(q);eval(t);\n\tif(r->l==q){\n\t  if(q->l==t) rotR(q),rotR(t);\n\t  else rotL(t),rotR(t);\n\t}else{\t\n\t  if(q->r==t) rotL(q),rotL(t);\n\t  else rotR(t),rotL(t);\n\t}\n      }\n    }\n  }\n\n  Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      update(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(c);\n    expose(par);\n    c->p=par;\n    par->r=c;\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=nullptr;\n    par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  bool is_connected(Node *a,Node *b){\n    expose(a);\n    while(a->l) a=a->l;\n    expose(b);\n    while(b->l) b=b->l;\n    return a==b;\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n\n  void set_propagate(Node *t,E v){\n    expose(t);\n    propagate(t,v);\n    eval(t);\n  }\n};\n\n//END CUT HERE\n//INSERT ABOVE HERE\n\nsigned GRL_5_C(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return min(a,b);};\n  LCT::P p=[](int a,size_t b){b++;return a;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int a,b;\n    cin>>a>>b;\n    cout<<lc.lca(v[a],v[b])->idx<<endl;\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_C\n*/\n\nsigned GRL_5_D(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return a+b;};\n  LCT::P p=[](int a,size_t b){b++;return a;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.expose(v[a]);\n      v[a]->val=f(v[a]->val,b);\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_D\n*/\n\n\nsigned GRL_5_E(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<Int,Int>;\n  LCT::F f=[](Int a,Int b){return a+b;};\n  LCT::P p=[](Int a,size_t b){return a*b;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  Int c=0;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.set_propagate(v[a],b);\n      c+=b;\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat-c<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_E\n*/\n\n\nsigned main(){\n  //GRL_5_C();\n  GRL_5_D();\n  //GRL_5_E();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define NUM 100005\n\nstruct Edge{\n\tEdge(int arg_to){\n\t\tto = arg_to;\n\t}\n\tint to;\n};\n\nstruct Info{\n\n\tInfo(){\n\t\tto_root_sum_weight = 0;\n\t}\n\tInfo(ll arg_to_root_sum_weight){\n\t\tto_root_sum_weight = arg_to_root_sum_weight;\n\t}\n\n\tll to_root_sum_weight; //根方向の辺に累積された重さ\n};\n\nstruct Data{\n\tint parent,head,depth,size;\n};\n\nint V,N;\nint root,global_index;\nint index_table[NUM];\nll K;\nData data[NUM];\nInfo  table[8*NUM]; //セグ木\nvector<Edge> G[NUM];\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nInfo merge(Info a,Info b){\n\n\tif(a.to_root_sum_weight == -1)return b; //aが範囲外\n\tif(b.to_root_sum_weight == -1)return a; //bが範囲外\n\n    Info ret = Info(a.to_root_sum_weight+b.to_root_sum_weight);\n\n    return ret;\n}\n\nvoid add(int loc,ll value){\n\n\tloc += N-1;\n\n\ttable[loc].to_root_sum_weight += value; //根方向に加算\n\n\tint parent = (loc-1)/2;\n\tint left_child,right_child;\n\n\twhile(true){\n\n\t\tleft_child = 2*parent+1; //根に近い子\n\t\tright_child = 2*parent+2; //葉に近い子\n\n\t\ttable[parent] = merge(table[left_child], table[right_child]);\n\n\t\tif(parent == 0){\n\n\t\t\tbreak;\n\n\t\t}else{\n\n\t\t\tparent = (parent-1)/2;\n\t\t}\n\t}\n}\n\nint makeTree(int node_id,int parent,int depth){\n\n\tdata[node_id].depth = depth;\n\tdata[node_id].parent = parent;\n\tdata[node_id].size = 1; //部分木のノード数(自分&子孫)\n\n\tint child;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tchild = G[node_id][i].to;\n\t\tif(child == parent)continue;\n\n\t\tdata[node_id].size += makeTree(child,node_id,depth+1);\n\t}\n\n\treturn data[node_id].size;\n}\n\nvoid HLD(int node_id,int head,int parent){\n\n\tindex_table[node_id] = global_index++; //★★根に近いものほど、番号が小さい(★左にある★)\n\tdata[node_id].head = head;\n\n\tif(G[node_id].size() == 0)return;\n\n\t//子の中で、最大の重み(部分木のノード数)を持つものを探す\n\tint max_size = -BIG_NUM;\n\tint max_node_id = -1,child;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tchild = G[node_id][i].to;\n\t\tif(child == parent)continue;\n\n\t\tif(max_size < data[child].size){\n\n\t\t\tmax_size = data[child].size;\n\t\t\tmax_node_id = child;\n\t\t}\n\t}\n\n\tif(max_node_id == -1)return;\n\n\t//最大の重みを持つ子へ(headは変わらず)\n\tHLD(max_node_id,head,node_id);\n\n\t//その他の子を処理(新しいラインを作る)\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tchild = G[node_id][i].to;\n\t\tif(child == parent || child == max_node_id)continue;\n\n\t\tHLD(child,child,node_id);\n\t}\n}\n\n//セグ木には、%Kの判定が済んだ値が保存されている\nInfo query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t//範囲外\n\tif(search_right < node_left || search_left > node_right)return Info(-1);\n\n\t//今回のノードの区間が、検索区間の部分区間である場合\n\tif(search_left <= node_left && search_right >= node_right){\n\t\treturn table[node_id];\n\t}\n\n\t//今回のノードの区間に、一部検索区間と重なっている区間がある場合→再帰的に子どもに尋ねる\n\tInfo left_info = query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\tInfo right_info = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\treturn merge(left_info,right_info);\n}\n\nll query(int from,int to){\n\n\treturn query(index_table[from],index_table[to],0,0,N-1).to_root_sum_weight;\n}\n\n//node_id～rootへのコストを求める\nll get_weight(int node_id){\n\n\tll ret = 0;\n\tint head_node;\n\n\twhile(true){\n\n\t\thead_node = data[node_id].head;\n\n\t\t//node_id～同じラインのヘッドのコストを求める(セグ木演算)\n\t\tret += query(head_node,node_id);\n\n\t\tif(head_node == root)break; //rootまで到達したらbreak\n\n\t\tnode_id = data[head_node].parent;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tint first_N;\n\n\tscanf(\"%d\",&first_N);\n\n\tint num;\n\tint from,to;\n\n\tfor(from = 0; from <= first_N-1; from++){\n\n\t\tscanf(\"%d\",&num);\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\tG[from].push_back(Edge(to));\n\t\t\tG[to].push_back(Edge(from));\n\t\t}\n\t}\n\n\troot = 0;\n\n\tmakeTree(root,-1,0);\n\tglobal_index = 0;\n\tHLD(root,root,-1);  //0スタートでdfs木を作ったので、0がrootとなる\n\n\t//dfs木をセグメント木に変換する\n\tN = 1;\n\tinit(first_N);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tadd(i,0); //セグ木の構築\n\t}\n\n\tint num_query;\n\tscanf(\"%d\",&num_query);\n\n\tint node_id,command,add_weight;\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\n\t\tscanf(\"%d\",&command);\n\n\t\tif(command == 0){\n\n\t\t\tscanf(\"%d %d\",&node_id,&add_weight);\n\t\t\tadd(index_table[node_id],add_weight);\n\n\t\t}else{\n\n\t\t\tscanf(\"%d\",&node_id);\n\t\t\tprintf(\"%lld\\n\",get_weight(node_id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 基本テンプレート\n \n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\nusing namespace std;\n \n#define rep(i,a,n) for(int (i)=(a); (i)<(n); (i)++)\n#define repq(i,a,n) for(int (i)=(a); (i)<=(n); (i)++)\n#define repr(i,a,n) for(int (i)=(a); (i)>=(n); (i)--)\n#define int long long int\n \ntemplate<typename T> void chmax(T &a, T b) {a = max(a, b);}\ntemplate<typename T> void chmin(T &a, T b) {a = min(a, b);}\ntemplate<typename T> void chadd(T &a, T b) {a = a + b;}\n \ntypedef pair<int, int> pii;\ntypedef long long ll;\n \nint dx[] = {0, 0, 1, -1};\nint dy[] = {1, -1, 0, 0};\nconst ll INF = 1001001001001001LL;\nconst ll MOD = 1000000007LL;\n\n// vector 版 (HL 分解に載せるときとかに使おう)\ntemplate<typename T>\nstruct lazysegtree {\n    // ノード、単位元\n    T I_upd, I_qry;\n    vector<T> node, lazy;\n    vector<bool> need_upd;\n    int SIZE;\n\n    // オペレーション (update, query の 2 つが必要？)\n    // update function は範囲を指定する形にしよう\n    // upd_f(X, Y, l, r) -> 範囲が [l, r) であるようなノード X に Y を反映！\n    // lazy について update するときは範囲を 1 にしないとバグります\n    T (*upd_f)(T, T, int, int), (*qry_f)(T, T);\n\n    // 演算子と単位元をセットし、全ての node と lazy を単位元で初期化\n    lazysegtree(int seg_size, T (*op1)(T, T, int, int), T (*op2)(T, T), T X_upd, T X_qry) {\n        upd_f = op1;\n        qry_f = op2;\n        I_upd = X_upd, I_qry = X_qry;\n        SIZE = 1; while(SIZE < seg_size) SIZE *= 2;\n        node     = vector<T> (2*SIZE, I_qry);\n        lazy     = vector<T> (2*SIZE, I_upd);\n        need_upd = vector<bool>(2*SIZE, false);\n    }\n\n    // 配列 vec の値で初期化\n    void init(vector<T> vec) {\n        int N = (int)vec.size();\n        for(int i=0; i<N; i++) {\n            node[SIZE-1+i] = vec[i];\n        }\n        for(int i=SIZE-2; i>=0; i--) {\n            node[i] = qry_f(node[2*i+1], node[2*i+2]);\n        }\n    }\n\n    void lazy_eval(int k, int l, int r) {\n        if(!need_upd[k]) return;\n        node[k] = upd_f(node[k], lazy[k], l, r);\n        if(r - l > 1) {\n            lazy[2*k+1] = upd_f(lazy[2*k+1], lazy[k], 0, 1);\n            lazy[2*k+2] = upd_f(lazy[2*k+2], lazy[k], 0, 1);\n            need_upd[2*k+1] = need_upd[2*k+2] = true;\n        }\n        lazy[k] = I_upd;\n        need_upd[k] = false;\n    }\n\n    // 半開区間 [a, b) に対して値 val を反映させる\n    // (upd_f を用いて処理)\n    void update(int a, int b, T val, int l=0, int r=-1, int k=0) {\n        if(r < 0) r = SIZE;\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return;\n        if(a <= l && r <= b) {\n            lazy[k] = upd_f(lazy[k], val, 0, 1);\n            need_upd[k] = true;\n            lazy_eval(k, l, r);\n        }\n        else {\n            int mid = (l + r) / 2;\n            update(a, b, val, l, mid, 2*k+1);\n            update(a, b, val, mid, r, 2*k+2);\n            node[k] = qry_f(node[2*k+1], node[2*k+2]);\n        }\n    }\n\n    // 半開区間 [a, b) に対してクエリを投げる\n    // (qry_f を用いて処理)\n    T query(int a, int b, int l=0, int r=-1, int k=0) {\n        if(r < 0) r = SIZE;\n        lazy_eval(k, l, r);\n        if(b <= l || r <= a) return I_qry;\n        if(a <= l && r <= b) return node[k];\n        int mid = (l + r) / 2;\n        T vl = query(a, b, l, mid, 2*k+1);\n        T vr = query(a, b, mid, r, 2*k+2);\n        return qry_f(vl, vr);\n    }\n};\n\n// HL 分解\n// ある頂点 v の子たち c_i について、それを根とする部分木の頂点数が\n// 最大のものの 1 つを c_h とおく。このとき、辺 (v, c_h) は \"heavy\" な辺であるという。\n// それ以外の辺は \"light\" な辺であるという。\n\n// すべての辺を \"heavy\" と \"light\" に分類すると、木は \"heavy\" からなるパス\n// (下のコードだと chain) に分解 (\"heavy\" でつながっている頂点をひとつにまとめる) できる。\n// これを HL 分解という。\n\n// chain を縮約したあとの木の高さは O(log N) である。\n// これは、\"heavy\" な辺の定義より、頂点 v と \"light\" な辺で結ばれている v の子それぞれに対して、\n// 部分木の大きさが subsize(v) / 2 以下となっていることから導ける。\n// \"light\" な辺を通るたびに部分木のサイズが半分以下になるため、深さは O(log N) となる。\n\n// 移動元と行先と辺のコストを記録する構造体\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\ntemplate <typename T>\nusing Graph = vector< vector< Edge<T> > >;\n\ntemplate <typename Type>\nstruct HLD {\n    int N;\n    const Graph<int> G;\n    // ・元の木について\n    // 根からの深さ、自分の親、自分を根にしたときの部分木のサイズ\n    // および、その頂点から出る \"heavy\" な辺\n    vector<int> depth, parent, subsize, heavy;\n    // ・chain について\n    // chain の先頭要素、末尾要素、その頂点の 1 つ次・前の要素、chain 内でのインデックス\n    vector<int> head, last, prev, next, chain, idx;\n    // chain の情報 (同じ vector 内にある要素どうしは同じ chain に属する)\n    vector< vector<int> > chains;\n    // 各 chain に載せる遅延評価セグ木 (抽象)\n    vector< lazysegtree<Type> > segs;\n\n    HLD(const Graph<int> &H, int r=-1) :\n        N(H.size()), G(H), depth(N, -1), parent(N, 0), subsize(N, 0), heavy(N, -1),\n        head(N), last(N), prev(N, -1), next(N, -1), chain(N, -1), idx(N, 0)\n    {\n        if(r != -1) decompose(r);\n    }\n\n    // root を根として分解\n    void decompose(const int root) {\n        stack<int> st; st.push(root);\n        parent[root] = -1;\n        depth[root] = 0;        \n\n        while(st.size()) {\n            int cur_v = st.top(); st.pop();\n            // その頂点を初めて訪れた\n            if(cur_v >= 0) {\n                st.push(~cur_v);\n                for(auto e : G[cur_v]) {\n                    // 親の方向でなければ値を更新\n                    if(depth[e.to] != -1) continue;\n                    depth[e.to] = depth[cur_v] + 1;\n                    parent[e.to] = cur_v;\n                    st.push(e.to);\n                }\n            }\n            // 帰りがけ\n            else {\n                int ma = 0;\n                cur_v = ~cur_v;\n                subsize[cur_v] = 1;\n                for(auto e : G[cur_v]) {\n                    if(parent[cur_v] == e.to) continue;\n                    subsize[cur_v] += subsize[e.to];\n                    if(ma < subsize[e.to]) {\n                        // cur_v と部分木のサイズが最大の子を結ぶ\n                        // (これが \"heavy\" の辺)\n                        ma = subsize[e.to];\n                        heavy[cur_v] = e.to;\n                    }\n                }\n            }\n        }\n\n        st.push(root);\n        while(st.size()) {\n            int cur_v = st.top(); st.pop();\n            for(auto e : G[cur_v]) {\n                if(parent[cur_v] != e.to) st.push(e.to);\n            }\n\n            // すでにその頂点について構築済みなら、何もしない\n            // (chain の先頭の頂点でない)\n            if(chain[cur_v] != -1) continue;\n            chains.push_back(vector<int>());\n            vector<int> &path = chains.back();\n\n            // cur_v を始点として、heavy な辺をたどりながら下がる\n            for(int v=cur_v; v!=-1; v=heavy[v]) {\n                path.push_back(v);\n            }\n\n            for(size_t i=0; i<path.size(); i++) {\n                // path (chain) の i 番目の頂点 v に関する情報\n                int v = path[i];\n                head[v] = path.front(), last[v] = path.back();\n                prev[v] = (i != 0 ? path[i-1] : -1);\n                next[v] = (i+1 != path.size() ? path[i+1] : -1);\n                chain[v] = (int)chains.size() - 1;\n                idx[v] = i;\n            }\n        }\n    }\n\n    // chain の個数分だけ segtree を作る\n    void buildSegtree(Type (*op1)(Type, Type, int, int), Type (*op2)(Type, Type), Type X_upd, Type X_qry) {\n        segs.clear();\n        for(size_t i=0; i<chains.size(); i++) {\n            segs.push_back(lazysegtree<Type>(chains[i].size(), op1, op2, X_upd, X_qry));\n        }\n    }\n\n    // 頂点 v について、どの chain に属するか、\n    // またその chain の中でのインデックスは何かを pair で返す\n    pair<int, int> get_index(int v) {\n        return make_pair(chain[v], idx[v]);\n    }\n\n    void debug_path() {\n        for(size_t i=0; i<chains.size(); i++) {\n            fprintf(stderr, \"path:\");\n            for(size_t k=0; k<chains[i].size(); k++) {\n                fprintf(stderr, \" %lld\", chains[i][k]);\n            }\n            fprintf(stderr, \"\\n\");\n        }\n    }\n\n    // v が属する chain の先頭を返す (head[v] が根なら -1 を返す)\n    int climb(int v) {\n        return parent[ head[v] ];\n    }\n\n    // 頂点 u と v の最小共通祖先\n    int lca(int u, int v) {\n        // 同じ chain に属するまで登る\n        while(chain[u] != chain[v]) {\n            if(depth[head[u]] < depth[head[v]]) v = climb(v);\n            else u = climb(u);\n        }\n        // 属する chain が同じになれば、浅いほうが LCA\n        return depth[u] < depth[v] ? u : v;\n    }\n\n    // lca で分解されたあとのパスについて、クエリを処理\n    void update_base(int u, int v, Type x, int f) {\n        while(1) {\n            // u の方が深い\n            if(depth[u] < depth[v]) swap(u, v);\n\n            // 属する chain が異なる → 先頭まで全部更新\n            if(chain[u] != chain[v]) {\n                int lhs = 0, rhs = idx[u] + 1;\n                segs[ chain[u] ].update(lhs, rhs, x);\n                u = climb(u);\n            }\n            // 同じ → v を含めるかどうかに気をつけながら更新\n            else {\n                int lhs = idx[v] + 1 - f, rhs = idx[u] + 1;\n                segs[ chain[u] ].update(lhs, rhs, x);\n                break;\n            }\n        }\n    }\n\n    // 頂点 u - v 間の「点」それぞれについて更新\n    // f は anc を更新対象に含めるかどうか\n    void upd_vertex(int u, int v, Type x) {\n        int anc = lca(u, v);\n        update_base(u, anc, x, 1);\n        update_base(v, anc, x, 0);\n    }\n\n    // 頂点 u - v 間の「辺」それぞれについて更新\n    void upd_edge(int u, int v, Type x) {\n        int anc = lca(u, v);\n        update_base(u, anc, x, 0);\n        update_base(v, anc, x, 0);\n    }\n\n    // lca で分解されたあとのパスについて、クエリを処理\n    Type query_base(int u, int v, Type X, Type (*op)(Type, Type), int f) {\n        Type ret = X;\n        \n        while(1) {\n            if(depth[u] < depth[v]) swap(u, v);\n\n            // A (根に近い) op B (遠い) の順番 (B op A ではない)\n            // u と v の chain が異なるならば、chain の端まで上って次へ\n            if(chain[u] != chain[v]) {\n                int lhs = 0, rhs = idx[u] + 1;\n                ret = op(segs[ chain[u] ].query(lhs, rhs), ret);\n                u = climb(u);\n            }\n            // lhs を含むか含まないか (f = 1 で含む)\n            else {\n                int lhs = idx[v] + 1 - f, rhs = idx[u] + 1;\n                ret = op(segs[ chain[u] ].query(lhs, rhs), ret);\n                break;\n            }\n        }\n        return ret;\n    }\n\n    // 頂点 u - v 間の「点」に関するクエリ (単位元と関数も必要)\n    Type qry_vertex(int u, int v, Type X, Type (*op)(Type, Type)) {\n        int anc = lca(u, v);\n        Type ret = X;\n        ret = op(ret, query_base(anc, u, X, op, 1));\n        ret = op(ret, query_base(anc, v, X, op, 0));\n        return ret;\n    }\n\n    // 頂点 u - v 間の「辺」に関するクエリ\n    Type qry_edge(int u, int v, Type X, Type (*op)(Type, Type)) {\n        int anc = lca(u, v);\n        Type ret = X;\n        ret = op(ret, query_base(anc, u, X, op, 0));\n        ret = op(ret, query_base(anc, v, X, op, 0));\n        return ret;\n    }\n};\n\n// [[つかいかた]]\n// update 用と query 用の関数と単位元 (関数を噛ませても結果が変わらないもの) を用意して宣言する\n// 下の例だと、update 用の関数が upd で、query 用の関数が fnd で、udpate の (作用素の) 単位元が 0、query の単位元が 0\n\n// 範囲が [l, r) のノードの値 a に値 b を反映させる\nll upd(ll a, ll b, int l, int r) {return a + (r - l) * b;}\n// ノードの値 a と b に対してどのような操作をするか？\nll fnd(ll a, ll b) {return a+b;}\n\nint parent[100010];\n \nsigned main() {\n    int N; cin >> N;\n\n    Graph<int> G(N);\n    for(int i=0; i<N; i++) {\n        int K; cin >> K;\n        for(int k=0; k<K; k++) {\n            int ch; cin >> ch;\n            parent[ch] = i;\n\n            G[i].push_back(Edge<int>(ch, 1));\n            G[ch].push_back(Edge<int>(i, 1));\n        }\n    }\n\n    HLD<int> hl(G, 0);\n    hl.buildSegtree(upd, fnd, 0, 0);\n\n    int Q; cin >> Q;\n    for(int i=0; i<Q; i++) {\n        int query; cin >> query;\n        if(query == 0) {\n            int v, w; cin >> v >> w;\n            hl.upd_edge(parent[v], v, w);\n        }\n        if(query == 1) {\n            int u; cin >> u;\n            cout << hl.qry_edge(0, u, 0, fnd) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long int;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\ntemplate<class T> void assign(V<T>& v, int n, const T& a = T()) { v.assign(n, a); }\ntemplate<class T, class... Args> void assign(V<T>& v, int n, const Args&... args) { v.resize(n); for (auto&& e : v) assign(e, args...); }\n\n\ntemplate<class T> struct BIT {\n  int n, h;\n  V<T> t;\n\n  BIT(int n) : n(n), h(__lg(n) + 1), t(n + 1, (T) 0) {}\n\n  void add(int x, T a) {\n    for (int i = x + 1; i < n + 1; i += i & -i) t[i] += a;\n  }\n\n  int lower_bound(T s) {\n    if (s <= 0) return 0;\n    int res = 0;\n    for (int k = 1 << h - 1; k; k >>= 1) if (res + k < n + 1 and t[res + k] < s) s -= t[res += k];\n    return res + 1;\n  }\n\n  T sum(int x) {\n    T res = 0;\n    for (int i = x; i; i -= i & -i) res += t[i];\n    return res;\n  }\n\n  T sum(int l, int r) {\n    return sum(r) - sum(l);\n  }\n};\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> chi(n);\n  for (int i = 0; i < n; ++i) {\n    int k; cin >> k;\n    chi[i].resize(k);\n    for (int j = 0; j < k; ++j) cin >> chi[i][j];\n  }\n  V<> a;\n  auto dfs = [&](auto dfs, int v) -> void {\n    a.push_back(v);\n    for (int w : chi[v]) {\n      dfs(dfs, w);\n      a.push_back(v);\n    }\n  };\n  dfs(dfs, 0);\n  V<> l(n, -1), r(n, -1);\n  for (int i = 0; i < 2 * n - 1; ++i) {\n    if (l[a[i]] == -1) l[a[i]] = i;\n    if (r[a[2 * n - 2 - i]] == -1) r[a[2 * n - 2 - i]] = 2 * n - 2 - i;\n  }\n  BIT<lint> bit(2 * n - 2);\n  int q; cin >> q;\n  for (int i = 0; i < q; ++i) {\n    int c; cin >> c;\n    if (!c) {\n      int v, w; cin >> v >> w;\n      bit.add(l[v] - 1, w);\n      bit.add(r[v], -w);\n    } else {\n      int v; cin >> v;\n      cout << bit.sum(l[v]) << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = (1<<30);\nconst ll INFLL = (1ll<<60);\nconst ll MOD = (ll)(1e9+7);\n\n#define l_ength size\n\nvoid mul_mod(ll& a, ll b){\n\ta *= b;\n\ta %= MOD;\n}\n\nvoid add_mod(ll& a, ll b){\n\ta = (a<MOD)?a:(a-MOD);\n\tb = (b<MOD)?b:(b-MOD);\n\ta += b;\n\ta = (a<MOD)?a:(a-MOD);\n}\n\nbool visited[100100];\nvector<int> g[100100];\nint l[100100],r[100100],m=1;\nll bitree[225816];\n\nvoid dfs(int u){\n\tint i,v;\n\tvisited[u] = true;\n\tfor(i=(g[u].l_ength()-1); i>=0; --i){\n\t\tv = g[u][i];\n\t\tif(visited[v]){\n\t\t\tcontinue;\n\t\t}\n\t\tl[v] = m; ++m;\n\t\tdfs(v);\n\t\tr[v] = m; ++m;\n\t}\n}\n\nll query(int x){\n\tll v = 0ll;\n\twhile(x){\n\t\tv += bitree[x];\n\t\tx -= (x&(-x));\n\t}\n\treturn v;\n}\n\nvoid update(int x, ll v){\n\twhile(x<=m){\n\t\tbitree[x] += v;\n\t\tx += (x&(-x));\n\t}\n}\n\nint main(void){\n\tint n,i,k,j,u,q;\n\tll w;\n\tcin >> n;\n\tfor(i=0; i<n; ++i){\n\t\tcin >> k;\n\t\tfor(j=0; j<k; ++j){\n\t\t\tcin >> u;\n\t\t\tg[i].push_back(u);\n\t\t}\n\t}\n\tdfs(0);\n\tcin >> q;\n\tfor(i=0; i<q; ++i){\n\t\tcin >> k;\n\t\tif(k){\n\t\t\tcin >> u;\n\t\t\tcout << query(l[u]) << endl;\n\t\t}else{\n\t\t\tcin >> u >> w;\n\t\t\tupdate(l[u],w);\n\t\t\tupdate(r[u],-w);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cmath>\n#include <map>\n#include <queue>\n#include <iomanip>\n#include <set>\n#include <tuple>\n#define mkp make_pair\n#define mkt make_tuple\n#define rep(i,n) for(int i = 0; i < (n); ++i)\nusing namespace std;\ntypedef long long ll;\nconst ll MOD=1e9+7;\ntemplate<class T> void chmin(T &a,const T &b){if(a>b) a=b;}\ntemplate<class T> void chmax(T &a,const T &b){if(a<b) a=b;}\n\nstruct Edge{\n    int to,id;\n    ll dist;\n    Edge(int to,ll dist=1,int id=0):to(to),dist(dist),id(id){}\n};\n\n// this class's update method is empty.\nstruct HeavyLightDecomposition{\n    vector<vector<Edge>> g;\n    vector<int> in,out,head,par,dep,sz;\n    int times;\n    int root;\n\n    HeavyLightDecomposition(int V,vector<vector<Edge>> &G,int root=0):\n        g(G),in(V),out(V),head(V),par(V),dep(V),sz(V),root(root){\n            times=0;\n            sz_dfs(root,-1);\n            hld_dfs(root,-1);\n    }\n    \n    void sz_dfs(int now,int p){\n        par[now]=p;\n        sz[now]=1;\n        if(p==-1) dep[now]=0;\n        else dep[now]=dep[p]+1;\n\n        for(auto &e:g[now]){\n            if(e.to==p) continue;\n            sz_dfs(e.to,now);\n            sz[now]+=sz[e.to];\n            if(sz[e.to]>sz[g[now][0].to]) swap(e,g[now][0]);\n        }\n    }\n\n    void hld_dfs(int now,int p){\n        in[now]=times++;\n        for(auto e:g[now]){\n            if(e.to==p) continue;\n            head[e.to]=(e.to == g[now][0].to ? head[now] : e.to);\n            hld_dfs(e.to,now);\n        }\n        out[now]=times;\n    }\n\n\n    int lca(int u,int v){\n        for(;;v=par[head[v]]){\n            if(in[u]>in[v]) swap(u,v);\n            if(head[u]==head[v]) return u;\n        }\n    }\n    int distance(int u,int v){\n        return dep[u]+dep[v]-2*dep[lca(u,v)];\n    }\n\n    /*ex)\n        hld.update(u,x,[&](int a,int b,ll x){\n            seg.add(a,b,x);\n        });\n    */\n    template<class T,class G>\n    void update(int v,const T &x,const G &g){//辺の時は0を使わない(INFのまま)\n        //g(in[v]+1,out[v],x);//部分木(辺)\n        //g(in[v],out[v],x);//部分木（頂点）\n        //g(in[v],in[v]+1,x);//一点\n        g(in[v],x);\n    }\n\n    /*ex)\n        ll ans=0;\n        hld.query(u,v,[&](int a,int b){\n            ans+=seg.getSum(a,b);\n        },true);\n    */\n    template<class F>\n    void query(int u,int v,const F &f,bool isedge){\n        for(;;v=par[head[v]]){\n            if(in[u]>in[v]) swap(u,v);\n            if(head[u]==head[v]) break;\n            f(in[head[v]],in[v]+1);\n        }\n        if(isedge&&u==v) return;\n        f(in[u]+isedge,in[v]+1);\n    }\n};\n\n#include <functional>\n#include <climits>\n\n//SegmentTree<int> seg(N,[](int a,int b){return min(a,b);},INT_MAX);\ntemplate< typename T>\nclass SegmentTree{\npublic:\n\n  using F = function<T(T,T)>;\n\n  int n;\n  vector<T> tree;\n  F operation;\n  T def;\n\n  SegmentTree(int size,F _operation,T _def):operation(_operation),def(_def){\n    n=1;\n    while(n<size) n*=2;\n    tree.resize(2*n-1,def);\n  }\n\n  SegmentTree(){}\n\n  void embody(int size,F _operation,T _def){\n    operation=_operation;\n    def=_def;\n    n=1;\n    while(n<size) n*=2;\n    tree.resize(2*n-1,def);\n  }\n\n  void initialize(vector<T> v){\n    int vSize=v.size();\n    n=1;\n    while(n<vSize) n*=2;\n    tree.resize(2*n-1,def);\n\n    for(int i=0;i<vSize;i++) tree[i+n-1]=v[i];\n    for(int i=n-2;i>=0;i--) tree[i]=operation(tree[2*i+1],tree[2*i+2]);\n  }\n\n  void update(int index,T value){\n    index+=n-1;\n\n    tree[index]+=value;\n    while(index>0){\n      index=(index-1)/2;\n      tree[index]=operation(tree[2*index+1],tree[2*index+2]);\n    }\n  }\n\n  T query(int a,int b,int k=0,int l=0,int r=-1){//[a,b),getMin(a,b,0,0,-1)\n    if(r<0) r=n;\n\n    if(r<=a||b<=l) return def;\n    else if(a<=l&&r<=b) return tree[k];\n    else{\n      T lval=query(a,b,2*k+1,l,(l+r)/2);\n      T rval=query(a,b,2*k+2,(l+r)/2,r);\n      return operation(lval,rval);\n    }\n  }\n\n  int find(int x,int k=0,int l=0,int r=-1){// a[0]+...+a[i]>=x (i:minimal)\n    if(r<0) r=n;\n    if(r-l==1) return k-(n-1);\n    if(tree[2*k+1]>=x) return find(x,2*k+1,l,(l+r)/2);\n    else return find(x-tree[2*k+1],2*k+2,(l+r)/2,r);\n  }\n};\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n\n  int N;\n  cin>>N;\n  vector<vector<Edge>> g(N);\n  rep(i,N){\n      int K;cin>>K;\n      rep(j,K){\n          int a;cin>>a;\n          g[i].push_back(a);\n      }\n  }\n\n  HeavyLightDecomposition hld(N,g);\n  SegmentTree<ll> seg(N,[](ll a,ll b){return a+b;},0);\n  \n  int Q;\n  cin>>Q;\n  rep(q,Q){\n      int t;cin>>t;\n      if(t==0){\n          int v,w;\n          cin>>v>>w;\n          hld.update(v,w,[&](int a,ll x){\n              seg.update(a,x);\n          });\n      }else{\n          int u;cin>>u;\n          ll ans=0;\n          hld.query(0,u,[&](int a,int b){\n              ans+=seg.query(a,b);\n          },true);\n          cout<<ans<<endl;\n      }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define REP(i,n) for (long long i=0;i<(n);i++)\n#define FOR(i,a,b) for (long long i=(a);i<(b);i++)\n#define RREP(i,n) for(long long i=n;i>=0;i--)\n#define RFOR(i,a,b) for(long long i=(a);i>(b);i--)\n#define dump1d_arr(array) REP(i,array.size()) cerr << #array << \"[\" << (i) << \"] ==> \" << (array[i]) << endl;\n#define dump2d_arr(array) REP(i,array.size()) REP(j,array[i].size()) cerr << #array << \"[\" << (i) << \"]\" << \"[\" << (j) << \"] ==> \" << (array[i][j]) << endl;\n#define dump(x)  cerr << #x << \" => \" << (x) << endl;\n#define dumpP(p) cerr << \"( \" << p.first << \" , \" << p.second << \" )\" << ends;\n#define CLR(vec) { REP(i,vec.size()) vec[i] = 0; } \n#define SORT(c) sort((c).begin(),(c).end())\n#define MIN(vec) *min_element(vec.begin(), vec.end());\n#define MAX(vec) *max_element(vec.begin(), vec.end());\n#define UNIQ(vec) vec.erase(unique(vec.begin(), vec.end()),vec.end());\n#define IN(n,m)  (!(m.find(n) == m.end()))\n#define ENUM(m) for (auto itr = m.begin(); itr != m.end(); ++itr)\n#define dump_MAP(m) for(auto itr = m.begin(); itr != m.end(); ++itr) { cerr << itr->first << \" --> \"  << itr->second << endl; }\n#define FINDL(vec,x) (lower_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define FINDU(vec,x) (upper_bound(vec.begin(),vec.end(),x) - vec.begin())\n#define ROUND(N) setprecision(N)\n#define ROUND_PRINT(N,val) cout << fixed;cout << setprecision(N) << val << endl\nusing namespace std;\nconstexpr long double pi = M_PI;\nconstexpr double eps = 1e-10;\nconstexpr long mod = 1000000007;\nconstexpr short shINF = 32767;\nconstexpr long loINF = 2147483647;\nconstexpr long long llINF = 9223372036854775807;\ntypedef long long LL;\ntypedef vector<long> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<LL,LL> pr;\ntypedef vector<pr> VP;\nstruct Order {\n\tbool operator() (pr const& a,pr const& b) const {\n\t\treturn a.first > b.first || ((a.first == b.first) && (a.second > b.second));\n\t}\n};\n\nVVI E;\nVI idx;\nVI chil_idx;\nlong dfs(long node,long num) {\n\tidx[node] = num;\n\tif (E[node].size() == 0) return chil_idx[node] = num;\n\telse {\n\t\tlong next = num;\n\t\tREP(i,E[node].size()) {\n\t\t\tnext = dfs(E[node][i],next+1);\n\t\t}\n\t\tchil_idx[node] = next;\n\t}\n}\n\ntemplate <class Monoid,class MonoidAct,typename N>\nclass LazySegmentTree {\nprivate:\n    using T1 = typename Monoid::T;\n    using T2 = typename MonoidAct::T;\n    vector<T1> data;\n    vector<T2> lazy;\n    vector<N> rank; \n    const size_t h, n;\n\n    //オペレータ2 MonoidAct -> Monoid (値がどう変化するか)\n\n    // RUQ -> RMQ\n    static T1 op2(const T1& l,const T2& r,const N& num) {return r != MonoidAct::id() ? r : l; }\n    // RAQ -> RMQ\n    //static T1 op2(const T1& l,const T2& r,const N& num) {return l + r; }\n    // RAQ -> RSQ \n    //static T1 op2(const T1& l,const T2& r,const N& num) {return l + (r*num); }\n    // RUQ -> RSQ\n    //static T1 op2(const T1& l,const T2& r,const N& num) {return r != MonoidAct::id() ? r*num : l; }\n\n\n\nprivate:\n    void eval(size_t node) {\n        if (lazy[node] == MonoidAct::id()) return;\n        if (node < n) {\n            lazy[node * 2] = MonoidAct::op3(lazy[node * 2], lazy[node]);\n            lazy[node * 2 + 1] = MonoidAct::op3(lazy[node * 2 + 1], lazy[node]);\n        }\n        data[node] = op2(data[node],lazy[node],rank[node]);\n        lazy[node] = MonoidAct::id();\n    }\n    void update(size_t node) {\n        data[node] = Monoid::op1(op2(data[node * 2],lazy[node * 2],rank[node*2])\n                        ,op2(data[node * 2 + 1],lazy[node * 2 + 1],rank[node*2+1]));\n    }\n\npublic:\n    LazySegmentTree(size_t n_)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, Monoid::id());lazy.resize(n * 2, MonoidAct::id());rank.resize(n*2);init();}\n    LazySegmentTree(size_t n_, T1 v1)\n        : h(ceil(log2(n_))), n(1 << h) {data.resize(n * 2, v1);lazy.resize(n * 2, MonoidAct::id());rank.resize(n*2);init();}\n    LazySegmentTree(const vector<T1>& data_)\n        : h(ceil(log2(data_.size()))), n(1 << h) {\n            data.resize(n * 2,Monoid::id());\n            lazy.resize(n * 2, MonoidAct::id());\n            rank.resize(n*2);\n            init(data_);\n    }\n    void init() {\n        for (N i = 0;i < n;i++) rank[i+n] = 1;\n        for (N i = n - 1; i >= 1; i--) {\n            data[i] = Monoid::op1(data[i * 2], data[i * 2 + 1]);\n            rank[i] += (rank[i*2] + rank[i*2+1]);\n        }\n    }\n    void init(const vector<T1>& data_) {\n        for (N i = 0; i < (N)data_.size(); i++) {\n            data[i + n] = data_[i];\n        }\n        init();\n    }\n\n    T1 operator[](size_t i) { return find(i,i+1);}\n\n    void update(size_t l, size_t r, T2 val) {\n        l += n, r += n - 1;\n        for (N i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        size_t tl = l, tr = r;\n        r++;\n        while (l < r) {\n            if (l & 1) lazy[l] = MonoidAct::op3(lazy[l], val), l++;\n            if (r & 1) r--, lazy[r] = MonoidAct::op3(lazy[r],val);\n            l >>= 1; r >>= 1;\n        }\n        while (tl >>= 1, tr >>= 1, tl) {\n            if (lazy[tl] == MonoidAct::id()) update(tl);\n            if (lazy[tr] == MonoidAct::id()) update(tr);\n        }\n    }\n    T1 find(size_t l, size_t r) {\n        l += n, r += n - 1;\n        for (N i = h; i > 0; i--) eval(l >> i), eval(r >> i);\n        r++;\n        T1 res1 = Monoid::id(), res2 = Monoid::id();\n        while (l < r) {\n            if (l & 1) res1 = Monoid::op1(res1, op2(data[l],lazy[l],rank[l])), l++;\n            if (r & 1) r--, res2 = Monoid::op1(op2(data[r],lazy[r],rank[r]),res2);\n            l >>= 1; r >>= 1;\n        }\n        return Monoid::op1(res1, res2);\n    }\n};\n\n\n// findモノイド\nstruct RMQ { // 区間の最小\n    using T = long;\n    static T op1(const T& a, const T& b) { return min(a,b); }\n    static constexpr T id() {return numeric_limits<T>::max();}\n};\nstruct RSQ { // 区間の和\n    using T = long;\n    static T op1(const T& a, const T& b) { return (a+b); }\n    static constexpr T id() {return 0; }\n};\n\n// updateモノイド\nstruct RUQ { // 区間に代入更新\n    using T = long;\n    static T op3(const T& l,const T& r) { return r != id() ? r : l;}\n    static constexpr T id() { return numeric_limits<T>::max(); }\n};\n\nstruct RAQ { // 区間に加算\n    using T = long;\n    static T op3(const T& l,const T& r) { return l+r;}\n    static constexpr T id() { return 0;}\n};\n\nint main(void) {\n\tlong n,k,x,q,com,v,w;\n\tcin >> n;\n\tidx = VI(n);\n\tchil_idx = VI(n);\n\tE = VVI(n);\n\tREP(i,n) {\n\t\tcin >> k;\n\t\tREP(j,k) {\n\t\t\tcin >> x;\n\t\t\tE[i].push_back(x);\n\t\t}\n\t}\n\tdfs(0,0);\n\tLazySegmentTree<RMQ,RAQ,long> sg(n,0);\n\tcin >> q;\n\tREP(i,q) {\n\t\tcin >> com;\n\t\tif (!com) {\n\t\t\tcin >> v >> w;\n\t\t\tsg.update(idx[v],chil_idx[v]+1,w);\n\t\t}\n\t\telse {\n\t\t\tcin >> v;\n\t\t\tcout << sg[idx[v]] << endl;\n\t\t}\n\t}\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (n); i++)\n\nclass HeavyLightDecomposition{\nprivate:\n\tstruct edge{int to,cost;};\n\tint n;\n\tvector<vector<edge>> g;\n\tvector<int> sub;//部分木のサイズ\n\tvector<int> par,depth;\n\tvector<int> head;//自分の所属するheavyパスの先頭\n\tvector<int> idx;//オイラーツアーの番号\n\tvoid dfs(int now){\n\t\tsub[now] = 1;\n\t\tint ma = 0;\n\t\tfor(auto& e: g[now])if(e.to != par[now]){\n\t\t\tpar[e.to] = now;\n\t\t\tdepth[e.to] = depth[now] + 1;\n\t\t\tdfs(e.to);\n\t\t\tsub[now] += sub[e.to];\n\t\t\tif(sub[g[now][0].to] < sub[e.to])swap(g[now][0],e);//g[now][0]に部分木が最大であるようなものが来る\n\t\t}\n\t}\n\tint et = 0;\n\tvoid dfs2(int now, vector<long long> &cost){\n\t\tidx[now] = et;\n\t\tet++;\n\t\trep(i,g[now].size())if(g[now][i].to != par[now]){\n\t\t\tedge e = g[now][i];\n\t\t\tif(i){\n\t\t\t\thead[e.to] = e.to;\n\t\t\t}else{\n\t\t\t\thead[e.to] = head[now];\n\t\t\t}\n\t\t\tcost.push_back(e.cost);\n\t\t\tdfs2(e.to,cost);\n\t\t}\n\t}\n\n\tclass LazySegmentTree{\n\tprivate:\n\t\tint n;\n\t\tvector<long long> node, lazy;\n\t\tlong long node_init = 0; // sum, max, update\n\t\t//long long node_init = LINF; // min\n\t\tlong long lazy_init = 0; // default\n\t\t//long long lazy_init = LINF; // min, update (存在しない値)\n\n\t\tlong long lazy_update(long long a,long long b){\n\t\t\treturn a+b; // sum query\n\t\t\t//return max(a,b); // max query\n\t\t\t//return min(a,b); // min query\n\t\t\t//return b; // update query\n\t\t}\n\n\t\tlong long node_update(long long a, long long b, int l, int r){ // lazy を node に反映\n\t\t\treturn a+b;\n\t\t\t//return a + b; // min query\n\t\t\t//return b; // update query\n\t\t\t//return b * (r-l); // sum query\n            //return max(a,b);\n\t\t}\n\n\tpublic:\n        long long combine(long long a,long long b){\n\t\t\treturn a+b; // sum query\n\t\t\t//return max(a,b); // max query\n\t\t\t//return min(a,b); // min query\n\t\t}\n\n\t\tLazySegmentTree(){}\n\t\tLazySegmentTree(vector<long long> in){\n\t\t\tn = 1;\n\t\t\twhile(n < in.size())n <<= 1;\n\t\t\tnode = vector<long long>(2*n, node_init);\n\t\t\tlazy = vector<long long>(2*n, lazy_init);\n\t\t\tfor(int i = n-1+in.size()-1; i >= 0; i--){\n\t\t\t\tif(n-1 <= i)node[i] = in[i-(n-1)];\n\t\t\t\telse node[i] = combine(node[i*2+1], node[i*2+2]);\n\t\t\t}\n\t\t}\n\t\tvoid eval(int k, int l, int r){\n\t\t\tif(lazy[k] != lazy_init){\n\t\t\t\tnode[k] = node_update(node[k], lazy[k], l, r);\n\t\t\t\tif(r - l > 1){\n\t\t\t\t\tlazy[2*k+1] = lazy_update(lazy[2*k+1], lazy[k]);\n\t\t\t\t\tlazy[2*k+2] = lazy_update(lazy[2*k+2], lazy[k]);\n\t\t\t\t}\n\t\t\t\tlazy[k] = lazy_init;\n\t\t\t}\n\t\t}\n\t\tvoid update(int a, int b, long long x, int k = 0, int l = 0, int r = -1){\n\t\t\t//cout <<\"update\" << a << \" \" << b << \" \" << x << \" \" << l << \" \" << r << endl;\n\t\t\tif(r < 0)r = n;\n\t\t\teval(k,l,r);\n\t\t\tif(b <= l || r <= a)return;\n\t\t\tif(a <= l && r <= b){\n\t\t\t\tlazy[k] = lazy_update(lazy[k],x);///!!\n\t\t\t\teval(k,l,r);\n\t\t\t}else{\n\t\t\t\tupdate(a,b,x,2*k+1,l,(l+r)/2);\n\t\t\t\tupdate(a,b,x,2*k+2,(l+r)/2,r);\n\t\t\t\tnode[k] = combine(node[2*k+1], node[2*k+2]);\n\t\t\t}\n\t\t}\n\t\tlong long query(int a, int b, int k = 0, int l = 0, int r = -1){\n\t\t\tif(r < 0)r = n;\n\t\t\tif(b <= l || r <= a)return node_init;\n\t\t\teval(k,l,r);\n\t\t\tif(a <= l && r <= b)return node[k];\n\t\t\treturn combine(query(a,b,2*k+1,l,(l+r)/2), query(a,b,2*k+2,(l+r)/2,r));\n\t\t}\n\t\tvoid show(){\n\t\t\tcout << \"node :\";\n\t\t\tfor(int i = 0; i < 2*n-1; i++){\n\t\t\t\tif(i == n-1)cout << \"     \";\n\t\t\t\tcout << \" \" << node[i];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t\tcout << \"lazy :\";\n\t\t\tfor(int i = 0; i < 2*n-1; i++){\n\t\t\t\tif(i == n-1)cout << \"     \";\n\t\t\t\tcout << \" \" << lazy[i];\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n\t};\n\tLazySegmentTree lst;\npublic:\n\tHeavyLightDecomposition(int sz){\n\t\tn = sz;\n\t\tg.resize(n);\n\t\tsub.resize(n);\n\t\tpar.resize(n);\n\t\thead.resize(n);\n\t\tdepth.resize(n);\n\t\tidx.resize(n);\n\t}\n\tvoid add_edge(int a, int b, int c){\n\t\tg[a].push_back({b,c});\n\t\tg[b].push_back({a,c});\n\t}\n\tvoid build(int root){\n\t\tpar[root] = -1;\n\t\tdepth[root] = 1;\n\t\tdfs(root);\n\t\thead[root] = root;\n\t\tvector<long long> cost;\n\t\tdfs2(root,cost);\n\t\tlst = LazySegmentTree(cost);\n\t\t//lst.show();\n\t}\n\tint lca(int u, int v){\n\t\tif(idx[u] > idx[v])swap(u,v);\n\t\t// u < v\n\t\tif(head[u] == head[v])return u;\n\t\treturn lca(u,par[head[v]]);\n\t}\n\n\tint query(int u, int v){\n\t\tif(idx[u] > idx[v])swap(u,v);\n\t\t// u < v\n\t\t//cout << \"query:\" << u << \" \" << v << \" \" << head[v] << endl;\n\t\tif(head[u] == head[v])return lst.query(idx[u],idx[v]);\n\t\treturn lst.combine(query(u,par[head[v]]),lst.query(idx[head[v]]-1,idx[v]));\n\t}\n\tvoid add(int u, int v, int x){\n\t\tif(idx[u] > idx[v])swap(u,v);\n\t\t// u < v\n\t\t//cout << \"add:\" << u << \" \" << v << \" \" << head[v] << endl;\n\t\tif(head[u] == head[v]){\n\t\t\tlst.update(idx[u],idx[v],x);\n\t\t}else{\n\t\t\tlst.update(idx[head[v]]-1,idx[v],x);\n\t\t\tadd(u,par[head[v]],x);\n\t\t}\n\t}\n\tvoid add_par(int v, int x){//vとvの親の間の辺を+xする\n\t\tadd(v, par[v],x);\n\t}\n\tvoid show(){\n\t\tcout << \"idx:\";\n\t\tfor(auto x: idx)cout << \" \" << x;cout << endl;\n\t\tlst.show();\n\t}\n};\n\n\n//LCA verify : http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4643677#1\nvoid grl5c(){\n\tint n;\n\tcin >> n;\n\tHeavyLightDecomposition hld(n);\n\trep(i,n){\n\t\tint k;\n\t\tcin >> k;\n\t\trep(_,k){\n\t\t\tint t;\n\t\t\tcin >> t;\n\t\t\thld.add_edge(i,t,1);\n\t\t}\n\t}\n\thld.build(0);\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tint u,v;\n\t\tcin >> u >> v;\n\t\tcout << hld.lca(u,v) << endl;\n\t}\n}\n\n//verify : http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4654815#1\nvoid grl5d(){\n\tint n;\n\tcin >> n;\n\tHeavyLightDecomposition hld(n);\n\trep(i,n){\n\t\tint k;\n\t\tcin >> k;\n\t\twhile(k--){\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\thld.add_edge(i,c,0);\n\t\t}\n\t}\n\thld.build(0);\n\tint q;\n\tcin >> q;\n\twhile(q--){\n\t\tint cond;\n\t\tcin >> cond;\n\t\tif(cond){\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\t//0からuのsumを答える\n\t\t\tcout << hld.query(0,u) << endl;\n\t\t}else{\n\t\t\tint v, w;\n\t\t\tcin >> v >> w;\n\t\t\t//vとその親の間の辺を+wする\n\t\t\thld.add_par(v,w);\n\t\t\t//hld.show();\n\t\t}\n\t}\n}\n\n\nint main(){\n\t//grl5c();\n\tgrl5d();\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<list>\n#include<string>\n#include<cstring>\n#include<cstdlib>\n#include<cstdio>\n#include<cmath>\n#include<ctime>\nusing namespace std;\n\ntypedef long long ll;\n\nbool debug = false;\nconst int NIL = -1;\nconst int INF = 1000000000;\nconst int NUM = 100010;\nclock_t START, END;\n\nint V, Q;\n\nstruct HeapNode {\n\tint d, u;\n\tbool operator < (const HeapNode& rhs) const {\n\t\treturn d > rhs.d;\n\t}\n};\n\nstruct Edge {\n\tint from, to, dist;\n\tEdge(int u, int v, int d) :from(u), to(v), dist(d) {}\n};\n\nstruct Dijkstra {\n\tint n, m;\n\tvector<Edge> edges;\n\tvector<int> G[NUM];\n\n\tint cnt, res;\n\tint dep[NUM], p[NUM], siz[NUM], son[NUM], top[NUM], id[NUM], sumv[NUM << 2], addv[NUM << 2];\n\n\tvoid init(int n) {\n\t\tthis->n = n;\n\t\tcnt = 0;\n\t\tdfs1(0, -1, 0);\n\t\tdfs2(0, 0);\n\t}\n\n\tvoid AddEdge(int from, int to, int dist) {\n\t\tedges.push_back(Edge(from, to, dist));\n\t\tm = edges.size();\n\t\tG[from].push_back(m - 1);\n\t}\n\n\tvoid query(int o, int L, int R, int ql, int qr) {\n\t\tif (ql <= L && qr >= R) {\n\t\t\tres += sumv[o];\n\t\t}\n\t\telse {\n\t\t\tint M = L + (R - L) / 2;\n\t\t\tif (ql <= M)\n\t\t\t\tquery(o * 2, L, M, ql, qr);\n\t\t\tif (qr > M)\n\t\t\t\tquery(o * 2 + 1, M + 1, R, ql, qr);\n\t\t}\n\t}\n\n\tvoid update(int o, int L, int R, int v, int w) {\n\t\tint M = L + (R - L) / 2;\n\t\tif (L == R)\n\t\t\tsumv[o] += w;\n\t\telse {\n\t\t\tif (id[v] <= M)\n\t\t\t\tupdate(o * 2, L, M, v, w);\n\t\t\telse\n\t\t\t\tupdate(o * 2 + 1, M + 1, R, v, w);\n\t\t\tsumv[o] = sumv[o * 2] + sumv[o * 2 + 1];\n\t\t}\n\t}\n\n\tvoid dfs1(int u, int fa, int depth) {\n\t\tdep[u] = depth;\n\t\tp[u] = fa;\n\t\tsiz[u] = 1;\n\t\tint maxson = -1;\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tEdge& e = edges[G[u][i]];\n\t\t\tint v = e.to;\n\t\t\tif (v == fa)\n\t\t\t\tcontinue;\n\t\t\tdfs1(v, u, depth + 1);\n\t\t\tsiz[u] += siz[v];\n\t\t\tif (siz[v] > maxson) {\n\t\t\t\tson[u] = v;\n\t\t\t\tmaxson = siz[v];\n\t\t\t}\n\t\t}\n\t}\n\n\tvoid dfs2(int u, int topf) {\n\t\tid[u] = ++cnt;\n\t\ttop[u] = topf;\n\t\tif (!son[u])\n\t\t\treturn;\n\t\tdfs2(son[u], topf);\n\t\tfor (int i = 0; i < G[u].size(); i++) {\n\t\t\tEdge& e = edges[G[u][i]];\n\t\t\tint v = e.to;\n\t\t\tif (v == p[u] || v == son[u])\n\t\t\t\tcontinue;\n\t\t\tdfs2(v, v);\n\t\t}\n\t}\n\n\tint qRange(int u) {\n\t\tint ans = 0;\n\t\twhile (top[u] != top[0]) {\n\t\t\tres = 0;\n\t\t\tquery(1, 1, n, id[top[u]], id[u]);\n\t\t\tans += res;\n\t\t\tu = p[top[u]];\n\t\t}\n\t\tres = 0;\n\t\tquery(1, 1, n, id[0], id[u]);\n\t\tans += res;\n\t\treturn ans;\n\t}\n};\n\nDijkstra solve;\n\nint main(void)\n{\n\tif (debug) {\n\t\tSTART = clock();\n\t\tfreopen(\"in29.txt\", \"r\", stdin);\n\t\tfreopen(\"out.txt\", \"w\", stdout);\n\t}\n\tint k, c, cmd, v, w, u;\n\tcin >> V;\n\tfor (int i = 0; i < V; i++) {\n\t\tscanf(\"%d\", &k);\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tscanf(\"%d\", &c);\n\t\t\tsolve.AddEdge(i, c, 1);\n\t\t\tsolve.AddEdge(c, i, 1);\n\t\t}\n\t}\n\tsolve.init(V);\n\tcin >> Q;\n\tfor (int i = 0; i < Q; i++) {\n\t\tscanf(\"%d\", &cmd);\n\t\tif (cmd) {\n\t\t\tscanf(\"%d\", &u);\n\t\t\tprintf(\"%d\\n\", solve.qRange(u));\n\t\t}\n\t\telse {\n\t\t\tscanf(\"%d%d\", &v, &w);\n\t\t\tsolve.update(1, 1, V, v, w);\n\t\t}\n\t}\n\tif (debug) {\n\t\tEND = clock();\n\t\tdouble endtime = (double)(END - START) / 1000;\n\t\tprintf(\"total time = %lf s\", endtime);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstring>\n#include <vector>\n\n#define lson l, m, o<<1\n#define rson m + 1, r, o<<1|1\n\ntypedef long long LL;\n\nconst int N = 1e5 + 1;\n\nint n;\nint cnt;\nstd::vector<int> G[N];\nint id[N << 1];\nLL sum[N << 3];\n\nvoid dfs(int u, int p) {\n  id[u] = cnt;\n  cnt ++;\n  for (int &to : G[u]) {\n    if (to != p) {\n      dfs(to, u);\n    }\n  }\n  id[u + n] = cnt;\n  cnt ++;\n}\n\nvoid up(int o) {\n  sum[o] = sum[o << 1] + sum[o << 1 | 1];\n}\n\nvoid modify(int x, int v, int l, int r, int o) {\n  if (l == r) {\n    sum[o] += v;\n    return ;\n  }\n  int m = (l + r) >> 1;\n  if (x <= m) modify(x, v, lson);\n  else if (x > m) modify(x, v, rson);\n  up(o);\n}\n\nLL get(int L, int R, int l, int r, int o) {\n  if (L <= l && R >= r) return sum[o];\n  int m = (l + r) >> 1;\n  LL res = 0;\n  if (L <= m) res += get(L, R, lson);\n  if (R > m) res += get(L, R, rson);\n  return res;\n}\n\nint main() {\n  std::cin >> n;\n  for (int i = 0; i < n; ++i) {\n    int k;\n    std::cin >> k;\n    for (int j = 0; j < k; ++j) {\n      int x;\n      std::cin >> x;\n      G[i].emplace_back(x);\n    }\n  }\n  cnt = 1;\n  dfs(0, 0);\n  memset(sum, 0, sizeof(sum));\n  int q;\n  std::cin >> q;\n  while (q --) {\n    int op;\n    std::cin >> op;\n    if (op == 0) {\n      int v, c;\n      std::cin >> v >> c;\n      modify(id[v], c, 1, 2 * n,  1);\n      modify(id[v + n], -c, 1, 2 * n, 1);\n    } else {\n      int v;\n      std::cin >> v;\n      std::cout << get(1, id[v], 1, 2 * n, 1) << std::endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define int long long\nusing namespace std;\n\nclass Euler{\npublic:\n  \n  int N, root;\n  vector<vector<int> > G;\n  vector<int> l;\n  vector<int> r;\n  \n  Euler():N(-1){}\n  Euler(int N, int root):N(N),root(root),G(N),l(N),r(N){}\n  \n  void add_edge(int a, int b){\n    \n    assert( 0 <= a && a < N );\n    assert( 0 <= b && b < N );\n    \n    G[a].push_back(b);\n    G[b].push_back(a);\n    \n  }\n  \n  void build(){\n    \n    int cnt = -1;\n    \n    dfs( root, root, cnt );\n    \n  }\n  \n  void dfs(int x, int px, int &cnt){\n    \n    l[x] = ++cnt;\n    \n    for(int nx : G[x] ){\n      if( nx != px ) dfs( nx, x, cnt );\n    }\n    \n    r[x] = cnt;\n    \n  }\n  \n  // [ res.first, res.second ]\n  tuple<int,int> getRange(int x){\n    return tuple<int,int>( l[x], r[x] );\n  }\n  \n};\n\nclass Seg{\npublic:\n  \n  int N;\n  vector<int> S;\n  \n  Seg(){}\n  Seg(int n){\n    \n    N = 1;\n    \n    while( N < n ) N *= 2;\n    \n    S.resize( N * 2 - 1, 0 );\n    \n  }\n  \n  void add(int a, int b, int l, int r, int k, int w){\n    \n    if( r <= a || b <= l ) return ;\n    \n    if( a <= l && r <= b ){\n      S[k] += w;\n      return ;\n    }\n    \n    add( a, b, l, ( l + r ) / 2, k * 2 + 1 , w );\n    \n    add( a, b, ( l + r ) / 2, r, k * 2 + 2 , w );\n    \n  }\n  \n  // [a, b)  \n  void add(int a, int b, int w){\n    add( a, b, 0, N, 0, w );\n  }\n  \n  int get(int x){\n    \n    x += N - 1;\n    \n    int res = S[x];\n    \n    while( x ){\n      \n      x = ( x - 1 ) / 2;\n      \n      res += S[x];\n      \n    }\n    \n    return res;\n  }\n  \n};\n\nsigned main(){\n  \n  int N;\n  cin >> N;\n  \n  Euler euler( N, 0 );\n  Seg seg( N );\n  \n  for(int i=0;i<N;i++){\n    \n    int k;\n    cin >> k;\n    \n    for(int j=0;j<k;j++){\n      \n      int c;\n      cin >> c;\n      \n      euler.add_edge( i, c );\n      \n    }\n    \n  }\n  \n  euler.build();\n  \n  int Q;\n  cin >> Q;\n  \n  while( Q-- ){\n    \n    int flg;\n    cin >> flg;\n    \n    if( flg == 0 ){\n      \n      int v, w;\n      cin >> v >> w;\n      \n      int l, r;\n      \n      tie( l, r ) = euler.getRange( v );\n      \n      seg.add( l, r + 1, w );\n      \n    }\n    else{\n      \n      int u;\n      cin >> u;\n      \n      int l, r;\n      \n      tie( l, r ) = euler.getRange( u );\n      \n      cout << seg.get( l ) << endl;\n      \n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint n;\nvector<int>v[100000];\nint st[100000],et[100000],tim=1;\nint f[100001];\nvoid update(int p,int v){\n\twhile(p<=n){\n\t\tf[p]+=v;\n\t\tp+=p&-p;\n\t}\n}\nint query(int x){\n\tint sum=0;\n\twhile(x>0){\n\t\tsum+=f[x];\n\t\tx-=x&-x;\n\t}\n\treturn sum;\n}\nvoid dfs(int u){\n\tst[u]=tim++;\n\tfor(auto i:v[u]){\n\t\tif(!st[i]){\n\t\t\tdfs(i);\n\t\t}\n\t}\n\tet[u]=tim;\n}\nint main(){\n\tcin>>n;\n\tfor(int i=0;i<n;i++){\n\t\tint k;\n\t\tcin>>k;\n\t\twhile(k--){\n\t\t\tint l;\n\t\t\tcin>>l;\n\t\t\tv[i].emplace_back(l);\n\t\t}\n\t}\n\tdfs(0);\n\tint q;\n\tcin>>q;\n\twhile(q--){\n\t\tbool op;\n\t\tcin>>op;\n\t\tif(op){\n\t\t\tint k;\n\t\t\tcin>>k;\n\t\t\tcout<<query(st[k])<<\"\\n\";\n\t\t}\n\t\telse{\n\t\t\tint u,x;\n\t\t\tcin>>u>>x;\n\t\t\tupdate(st[u],x);\n\t\t\tupdate(et[u],-x);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> G[100010];\n\n#define MAX_N 1<<17\nint n,dat[2*(MAX_N)-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nint find(int k){\n  k+=n-1;\n  int ans=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    ans+=dat[k];\n  }\n  return ans;\n}\n\n\nvoid update(int a,int b,int x,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l)return;\n  if(a<=l&&r<=b){\n    dat[k]+=x;\n  }else{\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n}\n\nint num[2][200010];\nint dfs(int k=0,int a=0){\n  num[0][k]=a;\n  for(int i=0;i<G[k].size();i++){\n    a=dfs(G[k][i],a+1);\n  }\n  num[1][k]=a;\n  return a;\n}\n\nint main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int a;\n      cin>>a;\n      G[i].push_back(a);\n    }\n  }\n  n=dfs();\n  init(n);\n  // cout<<num[1][0]<<\" happy\"<<endl;\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int x;\n    cin>>x;\n    if(x==0){\n      int w,v;\n      cin>>v>>w;\n      update(num[0][v],num[1][v]+1,w);\n    }else{\n      int u;\n      cin>>u;\n      cout<<find(num[0][u])<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "\n#include <bits/stdc++.h>\nusing namespace std;\n\nint n;\nvector<int> childs[100005];\nint p[100005];\nint ntoid[100005], idton[100005], nid = 0;\nint treesize[100005];\nint seg[400005];\n\nint query(int x, int l, int r, int k) {\n  if (l == r)\n    return seg[x];\n  int m = l + r >> 1;\n  if (k <= m)\n    return seg[x] + query(x << 1, l, m, k);\n  else\n    return seg[x] + query(x << 1 | 1, m + 1, r, k);\n}\n\nvoid segadd(int x, int l, int r, int ul, int ur, int v) {\n  if (l == ul && r == ur) {\n    seg[x] += v;\n    return;\n  }\n\n  int m = l + r >> 1;\n  if (ur <= m)\n    segadd(x << 1, l, m, ul, ur, v);\n  else if (ul > m)\n    segadd(x << 1 | 1, m + 1, r, ul, ur, v);\n  else {\n    segadd(x << 1, l, m, ul, m, v);\n    segadd(x << 1 | 1, m + 1, r, m + 1, ur, v);\n  }\n}\n\nint dfs(int n) {\n  treesize[n] = 1;\n  idton[nid] = n;\n  ntoid[n] = nid++;\n  for (int h : childs[n])\n    treesize[n] += dfs(h);\n  return treesize[n];\n}\n\nvoid update(int v, int w) {\n  segadd(1, 0, n - 1, ntoid[v], ntoid[v] + treesize[v] - 1, w);\n}\n\nvoid getsum(int u) {\n  cout << query(1, 0, n - 1, ntoid[u]) << endl;\n}\n\nint main() {\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    int t; cin >> t;\n    for (int j = 0; j < t; j++) {\n      int x; cin >> x;\n      p[x] = i;\n      childs[i].push_back(x);\n    }\n  }\n  dfs(0);\n  int q; cin >> q;\n  for (int i = 0; i < q; i++) {\n    int t; cin >> t;\n    if (t == 0) {\n      int v, w; cin >> v >> w;\n      update(v, w);\n    }\n    if (t == 1) {\n      int u; cin >> u;\n      getsum(u);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <iostream>\n#include <string>\n#include <cmath>\n#include <bitset>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <deque>\n#include <algorithm>\n#include <complex>\n#include <unordered_map>\n#include <unordered_set>\n#include <random>\n#include <cassert>\n#include <fstream>\n#include <utility>\n#include <functional>\n#define popcount __builtin_popcount\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<int, int> P;\n\ntemplate<typename Monoid=int>\nstruct LinkCutTree{\n\tusing F=function<Monoid(Monoid, Monoid)>;\n\tusing S=function<Monoid(Monoid)>;\n\n\tstruct Node{\n\t\tNode *l, *r, *p;\n\t\tint idx;\n\t\tMonoid key, sum;\n\n\t\tbool rev;\n\t\tint sz;\n\n\t\tbool is_root(){\n\t\t\treturn !p || (p->l!=this && p->r!=this);\n\t\t}\n\n\t\tNode(int idx, const Monoid &key):idx(idx), key(key), sum(key), sz(1), l(nullptr), r(nullptr), p(nullptr), rev(false) {}\n\t};\n\n\tconst Monoid M1;\n\tconst F f;\n\tconst S s;\n\n\tLinkCutTree():LinkCutTree([](Monoid a, Monoid b){ return a+b;}, [](Monoid a){ return a;}, Monoid()){}\n\tLinkCutTree(const F &f, const S &s, const Monoid &M1):f(f), s(s), M1(M1){}\n\n\tNode *make_node(int idx, const Monoid &v=Monoid()){\n\t\treturn new Node(idx, v);\n\t}\n\n\tvoid toggle(Node *t){\n\t\tassert(t);\n\t\tswap(t->l, t->r);\n\t\tt->sum=s(t->sum);\n\t\tt->rev^=true;\n\t}\n\n\tvoid push(Node *t){\n\t\tif(t->rev){\n\t\t\tif(t->l) toggle(t->l);\n\t\t\tif(t->r) toggle(t->r);\n\t\t\tt->rev=false;\n\t\t}\n\t}\n\n\tvoid update(Node *t){\n\t\tt->sz=1;\n\t\tt->sum=t->key;\n\t\tif(t->l) t->sz+=t->l->sz, t->sum=f(t->l->sum, t->sum);\n\t\tif(t->r) t->sz+=t->r->sz, t->sum=f(t->sum, t->r->sum);\n\t}\n\n\tvoid rotr(Node *t){\n\t\tauto *x=t->p, *y=x->p;\n\t\tif((x->l=t->r)) t->r->p=x;\n\t\tt->r=x, x->p=t;\n\t\tupdate(x), update(t);\n\t\tif((t->p=y)){\n\t\t\tif(y->l==x) y->l=t;\n\t\t\tif(y->r==x) y->r=t;\n\t\t\tupdate(y);\n\t\t}\n\t}\n\n\tvoid rotl(Node *t){\n\t\tauto *x=t->p, *y=x->p;\n\t\tif((x->r=t->l)) t->l->p=x;\n\t\tt->l=x, x->p=t;\n\t\tupdate(x), update(t);\n\t\tif((t->p=y)){\n\t\t\tif(y->l==x) y->l=t;\n\t\t\tif(y->r==x) y->r=t;\n\t\t\tupdate(y);\n\t\t}\n\t}\n\n\tvoid splay(Node* t){\n\t\tpush(t);\n\t\twhile(!t->is_root()){\n\t\t\tauto *q=t->p;\n\t\t\tif(q->is_root()){\n\t\t\t\tpush(q), push(t);\n\t\t\t\tif(q->l==t) rotr(t);\n\t\t\t\telse rotl(t);\n\t\t\t}else{\n\t\t\t\tauto *r=q->p;\n\t\t\t\tpush(r), push(q), push(t);\n\t\t\t\tif(r->l==q){\n\t\t\t\t\tif(q->l==t) rotr(q), rotr(t);\n\t\t\t\t\telse rotl(t), rotr(t);\n\t\t\t\t}else{\n\t\t\t\t\tif(q->r==t) rotl(q), rotl(t);\n\t\t\t\t\telse rotr(t), rotl(t);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tNode *expose(Node *t){\n\t\tNode *rp=nullptr;\n\t\tfor(Node *cur=t; cur; cur=cur->p){\n\t\t\tsplay(cur);\n\t\t\tcur->r=rp;\n\t\t\tupdate(cur);\n\t\t\trp=cur;\n\t\t}\n\t\tsplay(t);\n\t\treturn rp;\n\t}\n\n\tvoid link(Node *child, Node *parent){\n\t\texpose(child);\n\t\texpose(parent);\n\t\tchild->p=parent;\n\t\tparent->r=child;\n\t\tupdate(parent);\n\t}\n\n\tvoid cut(Node *child){\n\t\texpose(child);\n\t\tauto *parent=child->l;\n\t\tchild->l=nullptr;\n\t\tparent->p=nullptr;\n\t\tupdate(child);\n\t}\n\n\tvoid evert(Node *t){\n\t\texpose(t);\n\t\ttoggle(t);\n\t\tpush(t);\n\t}\n\n\tNode *lca(Node *u, Node *v){\n\t\tif(get_root(u)!=get_root(v)) return nullptr;\n\t\texpose(u);\n\t\treturn expose(v);\n\t}\n\n\tNode *get_root(Node *x){\n\t\texpose(x);\n\t\twhile(x->l){\n\t\t\tpush(x);\n\t\t\tx=x->l;\n\t\t}\n\t\treturn x;\n\t}\n};\nint main()\n{\n\tint n;\n\tcin>>n;\n\tusing LCT=LinkCutTree<>;\n\tLCT lct;\n\tvector<LCT::Node*> vt(n);\n\tfor(int i=0; i<n; i++){\n\t\tvt[i]=lct.make_node(i, 0);\n\t}\n\tfor(int i=0; i<n; i++){\n\t\tint k; cin>>k;\n\t\tfor(int j=0; j<k; j++){\n\t\t\tint c; cin>>c;\n\t\t\tlct.link(vt[c], vt[i]);\n\t\t}\n\t}\n\tint Q; cin>>Q;\n\tfor(int i=0; i<Q; i++){\n\t\tint t;\n\t\tcin>>t;\n\t\tif(t==0){\n\t\t\tint v, w; cin>>v>>w;\n\t\t\tlct.expose(vt[v]);\n\t\t\tvt[v]->key+=w;\n\t\t}else{\n\t\t\tint u; cin>>u;\n\t\t\tlct.expose(vt[u]);\n\t\t\tint ans=vt[u]->sum;\n\t\t\tcout<<ans<<endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include <cmath>\n\nusing namespace std;\ntypedef long long ll;\n//typedef unsigned long long ll;\n\n#define rep(i, n) for (int i = 0; i < (n); ++i)\n//#define rep(i, n) for (ll i = 0; i < (n); ++i)\n//#define sz(x) ll(x.size())\n//typedef pair<ll, int> P;\ntypedef pair<ll, ll> P;\n//const double INF = 1e10;\nconst ll INF = LONG_LONG_MAX / 100;\n//const ll INF = (1ll << 31) - 1;\n//const ll INF = 1e15;\nconst ll MINF = LONG_LONG_MIN;\n//const int INF = INT_MAX / 10;\n#define cmin(x, y) x = min(x, y)\n#define cmax(x, y) x = max(x, y)\n//typedef pair<int, int> P;\n//typedef pair<double, double> P;\n\nbool contain(set<P> &s, P a) { return s.find(a) != s.end(); }\n\n//ifstream myfile(\"C:\\\\Users\\\\riku\\\\Downloads\\\\0_00.txt\");\n//ofstream outfile(\"log.txt\");\n//outfile << setw(6) << setfill('0') << prefecture << setw(6) << setfill('0') << rank << endl;\n// std::cout << std::bitset<8>(9);\nconst int mod = 1000000007;\ntypedef priority_queue<long long, vector<long long>, greater<long long>> PQ_ASK;\n\n\nvoid print_line(vector<string> &line) {\n    if (line.size() == 0ll) {\n        cout << endl;\n        return;\n    }\n    for (ll i = 0; i < line.size(); i++) {\n        cout << line[i];\n        if (i == line.size() - 1) cout << endl;\n        else cout << ' ';\n    }\n}\n\n\n// 何もわからん。写経\n// https://onlinejudge.u-aizu.ac.jp/solutions/problem/GRL_5_D/review/4115903/face4/C++14\ntemplate<typename T>\nstruct Seg {\nprivate:\n    vector<T> node;\n    int n;\n    function<T(T, T)> f;\n    T def;\n\npublic:\n    Seg(int siz, T d, function<T(T, T)> f) : def(d), f(f) {\n        n = 1;\n        while (n < siz) n *= 2;\n        node.resize(2 * n - 1, def);\n    }\n\n    Seg(vector<T> v, T d, function<T(T, T)> f) : def(d), f(f) {\n        n = 1;\n        while (n < v.size()) n *= 2;\n        node.resize(2 * n - 1);\n        for (int i = 0; i < v.size(); i++) node[n - 1 + i] = v[i];\n        for (int i = n - 2; i >= 0; i--) node[i] = f(node[2 * i + 1], node[2 * i + 2]);\n    }\n\n    void update(int x, T val) {\n        x += n - 1;\n        node[x] = f(node[x], val); /* ! */\n        while (x) {\n            x = (x - 1) / 2;\n            node[x] = f(node[2 * x + 1], node[2 * x + 2]);\n        }\n    }\n\n    T query(int a, int b) {\n        int L = a + n - 1, R = b + n - 1;\n        T ret = def;\n        while (L < R) {\n            if ((R & 1) == 0) ret = f(ret, node[--R]);\n            if ((L & 1) == 0) ret = f(ret, node[L++]);\n            L >>= 1, R >>= 1;\n        }\n        return ret;\n    }\n};\n\nvector<int> v[200000], et;\nint be[200000], en[200000], k = 0;\n\nvoid dfs(int x, int p) {\n    be[x] = k++;\n    et.push_back(x);\n    for (int j : v[x]) {\n        if (j != p) {\n            dfs(j, x);\n            et.push_back(x);\n            k++;\n        }\n    }\n    en[x] = k;\n}\n\n\nint main() {\n    int n;\n    cin >> n;\n\n//    vector<vector<int>> g(n);\n\n    rep(i, n) {\n        int k;\n        cin >> k;\n        rep(j, k) {\n            int x;\n            cin >> x;\n            v[i].push_back(x);\n        }\n    }\n\n    dfs(0, -1);\n    Seg<int> stsum(et.size(), 0, [](int x, int y) { return x + y; });\n    int q;\n    cin >> q;\n    while (q--) {\n        int op, a, b;\n        cin >> op >> a;\n        if (op == 0) {\n            cin >> b;\n            stsum.update(be[a] - 1, b);\n            stsum.update(en[a], -b);\n        } else {\n            cout << stsum.query(0, be[a]) << endl;\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<functional>\n#include<climits>\nusing namespace std;\n\ntemplate<typename T>\nstruct Seg{\nprivate:\n    vector<T> node;\n    int n;\n    function<T(T,T)> f;\n    T def;\n\npublic:\n    Seg(int siz, T d, function<T(T,T)> f) : def(d), f(f) {\n        n = 1;\n        while(n < siz)  n *= 2;\n        node.resize(2*n-1, def);\n    }\n    Seg(vector<T> v, T d, function<T(T,T)> f) : def(d), f(f){\n        n = 1;\n        while(n < v.size())  n *= 2;\n        node.resize(2*n-1);\n        for(int i = 0; i < v.size(); i++)   node[n-1+i] = v[i];\n        for(int i = n-2; i >= 0; i--)   node[i] = f(node[2*i+1], node[2*i+2]);\n    }\n\n    void update(int x, T val){\n        x += n-1;\n        node[x] = f(node[x], val); /* ! */\n        while(x){\n            x = (x-1)/2;\n            node[x] = f(node[2*x+1], node[2*x+2]);\n        }\n    }\n\n    T query(int a, int b){\n        int L = a+n-1, R = b+n-1;\n        T ret = def;\n        while(L < R){\n            if((R&1) == 0)  ret = f(ret, node[--R]);\n            if((L&1) == 0)  ret = f(ret, node[L++]);\n            L >>= 1, R >>= 1;\n        }\n        return ret;\n    }\n};\n\nvector<int> v[200000], et;\nint be[200000], en[200000], k = 0;\n\nvoid dfs(int x, int p){\n    be[x] = k++;\n    et.push_back(x);\n    for(int j : v[x]){\n        if(j != p){\n            dfs(j, x);\n            et.push_back(x);\n            k++;\n        }\n    }\n    en[x] = k;\n}\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    \n    int n;\n    cin >> n;\n    for(int i = 0; i < n; i++){\n        int k;  cin >> k;\n        while(k--){\n            int x;  cin >> x;\n            v[i].push_back(x);\n        }\n    }\n    dfs(0, -1);\n    Seg<int> stsum(et.size(), 0, [](int x, int y){return x+y;});\n    int q;\n    cin >> q;\n    while(q--){\n        int op, a, b;\n        cin >> op >> a;\n        if(op == 0){\n            cin >> b;\n            stsum.update(be[a]-1, b);\n            stsum.update(en[a], -b);\n        }else{\n            cout << stsum.query(0, be[a]) << endl;\n        }\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iomanip>\n#include<limits>\n#include<thread>\n#include<utility>\n#include<iostream>\n#include<string>\n#include<algorithm>\n#include<set>\n#include<map>\n#include<vector>\n#include<stack>\n#include<queue>\n#include<cmath>\n#include<numeric>\n#include<cassert>\n#include<random>\n#include<chrono>\n#include<unordered_map>\n#include<list>\nusing namespace std;\ntypedef unsigned long long int ull;\ntypedef long long int ll;\ntypedef pair<ll,ll> pll;\ntypedef pair<int,int> pi;\ntypedef pair<double,double> pd;\ntypedef pair<double,ll> pdl;\n#define F first\n#define S second\nconst ll E=1e18+7;\nconst ll MOD=1000000007;\ntypedef pair<pll,pll> P;\nconst ll C=1000;\n\n\n//edgeに値がある場合\ntemplate<typename T,typename U> //T::要素,U::作用素\nclass eHLD{\nprivate:\n    //0-index\n    class late_seg_tree{\n    private:\n        typedef pair<T,U> node;\n        vector<vector<node>> tree;\n        ll high;\n        T err_T;\n        U err_U;\n        ll err;\n        \n        T F(T,T); //要素のマージ (要素,要素)\n        T G(T,U,ll); //作用素->要素 (要素,作用素,場所)\n        U H(U,U); //作用素のマージ (作用素,作用素)\n        T I(T,U,ll,ll); //作用素->区間要素 (要素,作用素,l,r) [l,r)\n        \n        ll bit_size(ll a){\n            for(int i=1;i<63;i++){\n                if(1<<i >= a){return i;}\n            }\n            return err;\n        }\n        \n        //[l,r)\n        void update(ll h,ll where,ll l,ll r,U u){\n            ll L=where<<(high-h-1);\n            ll R=(where+1)<<(high-h-1);\n            if(r<=L || R<=l){return;}\n            if(h==high-1){tree[h][where].F=G(tree[h][where].F,u,where); return;}\n            if(l<=L && R<=r){\n                tree[h][where].S=H(tree[h][where].S,u);\n                tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n                tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n            }\n            else{\n                update(h+1,where*2,l,r,u);\n                update(h+1,where*2+1,l,r,u);\n                tree[h][where].F=F(tree[h+1][where*2].F,tree[h+1][where*2+1].F);\n                tree[h][where].F=I(tree[h][where].F,tree[h][where].S,L,R);\n            }\n        }\n        \n        T search(ll h,ll where,ll l,ll r){\n            ll L=where<<(high-h-1);\n            ll R=(where+1)<<(high-h-1);\n            if(r<=L || R<=l){return err_T;}\n            if(h==high-1){return tree[h][where].F;}\n            if(l<=L && R<=r){return tree[h][where].F;}\n            else{\n                update(h+1,where*2,L,R,tree[h][where].S);\n                update(h+1,where*2+1,L,R,tree[h][where].S);\n                tree[h][where].S=err_U;\n                T ret=err_T;\n                ret=F(ret,search(h+1,where*2,l,r));\n                ret=F(ret,search(h+1,where*2+1,l,r));\n                return ret;\n            }\n            return err_T;\n        }\n        \n    public:\n        late_seg_tree(ull size,T err_T,U err_U):err_T(err_T),err_U(err_U){\n            err=1e18+7;\n            high=bit_size(size)+1;\n            tree.resize(high);\n            for(int i=0;i<high;i++){\n                tree[i].resize(1<<i,{err_T,err_U});\n            }\n        }\n        \n        late_seg_tree(vector<T> t,T err_T,U err_U):err_T(err_T),err_U(err_U){\n            err=1e18+7;\n            high=bit_size(t.size())+1;\n            tree.resize(high);\n            for(int i=0;i<high;i++){\n                tree[i].resize(1<<i,{err_T,err_U});\n            }\n            for(int i=0;i<t.size();i++){\n                tree[high-1][i]={t[i],err_U};\n            }\n            for(ll h=high-2;h>=0;h--){\n                for(int i=0;i<tree[h].size();i++){\n                    tree[h][i].F=F(tree[h+1][i*2].F,tree[h+1][i*2+1].F);\n                }\n            }\n        }\n        \n        void update(ll l,ll r,U u){\n            update(0,0,l,r,u);\n        }\n        \n        T search(ll l,ll r){\n            return search(0,0,l,r);\n        }\n    };\n    \n    class LCA{\n    private:\n        typedef pair<ll,vector<ll>> node; //depth,parents\n        ll root;\n        ll v;\n        vector<node> tree;\n        vector<vector<ll>> E;\n        ll High; //高さのlog\n        \n        void bfs(){\n            tree[root]={0,{root}};\n            queue<ll> q;\n            q.push(root);\n            vector<bool> done(v,false);\n            while(!q.empty()){\n                ll where=q.front();\n                q.pop();\n                if(done[where]){continue;}\n                done[where]=true;\n                for(int i=0;i<E[where].size();i++){\n                    if(!done[E[where][i]]){\n                        tree[E[where][i]].F=tree[where].F+1;\n                        tree[E[where][i]].S={where};\n                        q.push(E[where][i]);\n                    }\n                }\n            }\n        }\n        \n    public:\n        LCA(ll v,ll root):v(v),root(root){\n            tree.resize(v);\n            E.resize(v);\n        }\n        \n        //双方向のエッジでもよい\n        void add_edge(ll from,ll to){\n            E[from].push_back(to);\n        }\n        \n        //searchの前に行う\n        void mk_tree(){\n            bfs();\n            bool j=true;\n            for(int i=0;j;i++){\n                j=false;\n                for(int t=0;t<v;t++){\n                    ll P=tree[t].S[i];\n                    P=tree[P].S[i];\n                    tree[t].S.push_back(P);\n                    if(P!=root){j=true;}\n                }\n            }\n            High=tree[root].S.size();\n        }\n        \n        ll search_parent(ll a,ll h){\n            if(tree[a].F<=h){return root;}\n            for(ll i=High-1;i>=0;i--){\n                if((1<<i)&h){a=tree[a].S[i];}\n            }\n            return a;\n        }\n        \n        ll search_lca(ll a,ll b){\n            ll dif=tree[a].F-tree[b].F;\n            if(0>dif){swap(a,b); dif=abs(dif);}\n            a=search_parent(a,dif);\n            for(ll i=High-1;i>=0;i--){\n                if(tree[a].S[i]!=tree[b].S[i]){\n                    a=tree[a].S[i];\n                    b=tree[b].S[i];\n                }\n            }\n            while(a!=b){\n                a=tree[a].S[0];\n                b=tree[b].S[0];\n            }\n            return a;\n        }\n        \n        ll high(ll a){\n            return tree[a].F;\n        }\n    };\n    \n    struct node{\n        ll high;\n        ll children;\n        ll edge_number;\n        ll parent;\n        vector<ll> child;\n        T a;\n    };\n    \n    struct Edge{\n        ll parent;\n        ll high;\n        ll low;\n        ll begin;\n        ll end;\n        late_seg_tree seg;\n    };\n    \n    bool made;\n    ll v;\n    ll root;\n    vector<node> nodes;\n    LCA lca;\n    vector<Edge> E;\n    T err_T;\n    U err_U;\n    vector<vector<pair<ll,T>>> edge;\n    T F(T,T); //要素のマージ (要素,要素)\n    U P(U,ll,ll,bool); //作用素->セグ木の作用素 (作用素、エッジの始点の高さ、エッジの終点の高さ、向き) true::down false::up\n    \n    bool err(const node &a)const{\n        if(a.high==-1 && a.children==-1 && a.edge_number==-1 && a.parent==-1 && a.child==vector<ll>()){return true;}\n        return false;\n    }\n    \n    ll dfs(ll where){\n        ll count=0;\n        for(int i=0;i<edge[where].size();i++){\n            if(err(nodes[edge[where][i].F])){\n                nodes[where].child.push_back(edge[where][i].F);\n                nodes[edge[where][i].F].parent=where;\n                nodes[edge[where][i].F].high=nodes[where].high+1;\n                nodes[edge[where][i].F].a=edge[where][i].S;\n                count+=dfs(edge[where][i].F);\n            }\n        }\n        count++;\n        nodes[where].children=count;\n        return count;\n    }\n    \n    void MK_TREE(){\n        if(made){return;}\n        made=true;\n        lca.mk_tree();\n        nodes[root].parent=root;\n        nodes[root].high=0;\n        dfs(root);\n        ll count=0;\n        stack<ll> s;\n        s.push(root);\n        while(!s.empty()){\n            ll w=s.top();\n            s.pop();\n            if(nodes[w].edge_number!=-1){continue;}\n            ll where=w;\n            ll parent=nodes[w].parent;\n            vector<T> tree;\n            ll end=-1;\n            while(1){\n                tree.push_back(nodes[where].a);\n                nodes[where].edge_number=count;\n                if(nodes[where].children==1){end=where; break;}\n                ll mx=0;\n                ll to=-1;\n                for(int i=0;i<nodes[where].child.size();i++){\n                    ll t=nodes[where].child[i];\n                    if(nodes[t].children>mx){mx=nodes[t].children; to=t;}\n                    s.push(t);\n                }\n                where=to;\n            }\n            E.push_back({parent,nodes[w].high,nodes[end].high,w,end,late_seg_tree(tree,err_T,err_U)});\n            count++;\n        }\n    }\n    \n    //[low,high]\n    void up_update(ll where,ll low,ll high,U u){\n        ll High=E[where].high;\n        ll Low=E[where].low;\n        u=P(u,High,Low,false);\n        high=max(High,high);\n        low=min(Low,low);\n        high-=High;\n        low-=High;\n        E[where].seg.update(high,low+1,u);\n    }\n    \n    //[high,low]\n    void down_update(ll where,ll high,ll low,U u){\n        ll High=E[where].high;\n        ll Low=E[where].low;\n        u=P(u,High,Low,true);\n        high=max(High,high);\n        low=min(Low,low);\n        high-=High;\n        low-=High;\n        E[where].seg.update(high,low+1,u);\n    }\n    \n    void UPDATE(ll s,ll t,U u){\n        ll mid=lca.search_lca(s,t);\n        ll high=nodes[mid].high+1;\n        if(s!=mid){\n            ll w=s;\n            while(1){\n                ll low=nodes[w].high;\n                ll where=nodes[w].edge_number;\n                if(low<high){break;}\n                up_update(where,low,high,u);\n                w=E[where].parent;\n            }\n        }\n        if(t!=mid){\n            ll w=t;\n            while(1){\n                ll low=nodes[w].high;\n                ll where=nodes[w].edge_number;\n                if(low<high){break;}\n                down_update(where,high,low,u);\n                w=E[where].parent;\n            }\n        }\n    }\n    \n    //[low,high]\n    T up_search(ll where,ll low,ll high){\n        ll High=E[where].high;\n        ll Low=E[where].low;\n        high=max(High,high);\n        low=min(Low,low);\n        high-=High;\n        low-=High;\n        return E[where].seg.search(high,low+1);\n    }\n    \n    //[high,low]\n    T down_search(ll where,ll high,ll low){\n        ll High=E[where].high;\n        ll Low=E[where].low;\n        high=max(High,high);\n        low=min(Low,low);\n        high-=High;\n        low-=High;\n        return E[where].seg.search(high,low+1);\n    }\n    \n    T SEARCH(ll s,ll t){\n        T ret=err_T;\n        ll mid=lca.search_lca(s,t);\n        ll high=nodes[mid].high+1;\n        if(s!=mid){\n            ll w=s;\n            while(1){\n                ll low=nodes[w].high;\n                ll where=nodes[w].edge_number;\n                if(low<high){break;}\n                ret=F(ret,up_search(where,low,high));\n                w=E[where].parent;\n            }\n        }\n        ll w=t;\n        if(t!=mid){\n            while(1){\n                ll low=nodes[w].high;\n                ll where=nodes[w].edge_number;\n                if(low<high){break;}\n                ret=F(ret,down_search(where,high,low));\n                if(where==0){break;}\n                w=E[where].parent;\n            }\n        }\n        return ret;\n    }\n    \npublic:\n    eHLD(ll v,ll root,T err_T,U err_U):v(v),root(root),err_T(err_T),err_U(err_U),lca(v,root){\n        edge.resize(v);\n        nodes.resize(v,{-1,-1,-1,-1,{},err_T});\n        made=false;\n    }\n    \n    //無向\n    void add_edge(ll from,ll to,T a){\n        edge[from].push_back({to,a});\n        edge[to].push_back({from,a});\n        lca.add_edge(from,to);\n        lca.add_edge(to,from);\n    }\n    \n    void update(ll from,ll to,U u){\n        MK_TREE();\n        UPDATE(from,to,u);\n    }\n    \n    T search(ll s,ll t){\n        MK_TREE();\n        return SEARCH(s,t);\n    }\n};\n\n\n\n\nint main(){\n    ll n;\n    cin>>n;\n    eHLD<ll,ll> tree(n,0,0,0);\n    vector<ll> parent(n,-1);\n    for(int i=0;i<n;i++){\n        ll m;\n        cin>>m;\n        for(int t=0;t<m;t++){\n            ll to;\n            cin>>to;\n            tree.add_edge(i,to,0);\n            parent[to]=i;\n        }\n    }\n    ll q;\n    cin>>q;\n    while(q--){\n        ll c;\n        cin>>c;\n        if(c){\n            ll w;\n            cin>>w;\n            cout<<tree.search(0,w)<<endl;\n        }\n        else{\n            ll v,w;\n            cin>>v>>w;\n            tree.update(v,parent[v],w);\n        }\n    }\n    \n    return 0;\n}\n\n\n\n//区間加算、区間和\n\n//要素のマージ (要素,要素)\ntemplate<typename T,typename U>\nT eHLD<T,U>::F(T a,T b){\n    return a+b;\n}\n\n//作用素->セグ木の作用素 (作用素、エッジの始点の高さ、エッジの終点の高さ、向き) true::down false::up\ntemplate<typename T,typename U>\nU eHLD<T,U>::P(U u,ll high,ll low,bool f){\n    return u;\n}\n\ntemplate<typename T,typename U>\nT eHLD<T,U>::late_seg_tree::F(T a,T b){\n    return a+b;\n}\n\ntemplate<typename T,typename U>\nT eHLD<T,U>::late_seg_tree::G(T a,U b,ll where){\n    return a+b;\n}\n\ntemplate<typename T,typename U>\nU eHLD<T,U>::late_seg_tree::H(U a,U b){\n    return a+b;\n}\n\ntemplate<typename T,typename U>\nT eHLD<T,U>::late_seg_tree::I(T a,U b,ll l,ll r){\n    return a+b*(r-l);\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <assert.h>\n\nnamespace beet{\n  \n  template<typename T>\n  void swap(T &a,T &b){\n    T x=a;\n    a=b;\n    b=x;\n  }\n  \n  template<typename T>\n  struct Vector{\n    int sz,cap;\n    T *data;\n    Vector():sz(0),cap(1){\n      data = new T[cap];\n    }    \n    Vector(int sz):sz(sz),cap(sz<<1){\n      data = new T[cap];\n    }\n    Vector(int sz,T t):sz(sz),cap(sz<<1){\n      data = new T[cap];\n      for(int i=0;i<sz;i++) data[i]=t;\n    }\n    ~Vector(){\n      delete[] data;\n    }\n    void resolve(){\n      T *tmp = new T[cap];\n      for(int i=0;i<sz;i++) tmp[i]=data[i];\n      delete[] data;\n      data=tmp;\n    }\n    void resize(int nsz){\n      cap=nsz<<1;\n      if(sz>cap) sz=cap;\n      resolve();      \n    }\n    void assign(int nsz,T t){\n      resize(nsz);\n      sz=nsz;\n      for(int i=0;i<sz;i++) data[i]=t;\n    }    \n    void push_back(T x){\n      if(sz>=cap){\n        cap<<=1;\n        assert(sz<cap);\n        resolve();\n      }      \n      data[sz++]=x;\n    }\n    void pop_back(){\n      sz--;\n    }\n    int size() const{\n      return sz;\n    }\n    const T operator[](int x) const{\n      return data[x];\n    }\n    T& operator[](int x){\n      assert(0<=x&&x<sz);\n      return data[x];\n    }\n  };\n  \n  const int MAX = 1e5+10;\n  struct UnionFind{\n    int r[MAX],p[MAX];\n    UnionFind(int n){\n      for(int i=0;i<n;i++){\n        r[i]=1;\n        p[i]=i;\n      }    \n    }\n    int find(int x){\n      if(p[x]!=x) p[x]=find(p[x]);\n      return p[x];\n    }\n    int same(int x,int y){\n      return find(x)==find(y);\n    }\n    void unite(int x,int y){\n      x=find(x);y=find(y);\n      if(x==y) return;\n      if(r[x]<r[y]) swap(x,y);\n      r[x]+=r[y];\n      p[y]=p[x];\n    }\n  };\n  \n  template <typename T,typename E, typename F, typename G, typename H>\n  struct SegmentTree{\n    int n,height;\n    F f;\n    G g;\n    H h;\n    T ti;\n    E ei;\n    Vector<T> dat;\n    Vector<E> laz;\n    SegmentTree(F f,G g,H h,T ti,E ei):\n      f(f),g(g),h(h),ti(ti),ei(ei){}\n  \n    void init(int n_){\n      n=1;height=0;\n      while(n<n_) n<<=1,height++;\n      dat.assign(2*n,ti);\n      laz.assign(2*n,ei);\n    }\n    void build(const Vector<T> &v){\n      int n_=v.size();\n      init(n_);\n      for(int i=0;i<n_;i++) dat[n+i]=v[i];\n      for(int i=n-1;i;i--)\n        dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    inline T reflect(int k){\n      return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n    }\n    inline void eval(int k){\n      if(laz[k]==ei) return;\n      laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n      laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n      dat[k]=reflect(k);\n      laz[k]=ei;\n    }\n    inline void thrust(int k){\n      for(int i=height;i;i--) eval(k>>i);\n    }\n    inline void recalc(int k){    \n      while(k>>=1)\n        dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n    }\n    void update(int a,int b,E x){\n      thrust(a+=n);\n      thrust(b+=n-1);\n      for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n        if(l&1) laz[l]=h(laz[l],x),l++;\n        if(r&1) --r,laz[r]=h(laz[r],x);\n      }\n      recalc(a);\n      recalc(b);\n    }\n    void set_val(int a,T x){\n      thrust(a+=n);\n      dat[a]=x;laz[a]=ei;\n      recalc(a);\n    }\n    T query(int a,int b){\n      thrust(a+=n);\n      thrust(b+=n-1);\n      T vl=ti,vr=ti;\n      for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n        if(l&1) vl=f(vl,reflect(l++));\n        if(r&1) vr=f(reflect(--r),vr);\n      }\n      return f(vl,vr);\n    }\n  };\n  \n  struct EulerTour{\n    int n,pos;\n    Vector<Vector<int> > G;\n    Vector<int> ls,rs;\n  \n    EulerTour(){}\n    EulerTour(int n):n(n),G(n),ls(n),rs(n){}\n\n    void add_edge(int u,int v){\n      G[u].push_back(v);\n      G[v].push_back(u);\n    }\n\n    void dfs(int v,int p){\n      ls[v]=pos++;\n      //for(int u:G[v]){\n      for(int i=0;i<(int)G[v].size();i++){\n        int u=G[v][i];\n        if(u!=p) dfs(u,v);\n      }\n      rs[v]=pos;\n    }\n  \n    void build(int r=0){\n      pos=0;\n      dfs(r,-1);\n    }\n  };\n}\n\n//INSERT ABOVE HERE\nusing namespace beet;\n\n\nint main(){\n  int n;\n  scanf(\"%d\",&n);\n  EulerTour G(n);\n  for(int i=0;i<n;i++){\n    int k;\n    scanf(\"%d\",&k);\n    for(int j=0;j<k;j++){\n      int v;\n      scanf(\"%d\",&v);\n      G.add_edge(i,v);\n    }\n  }\n  G.build();\n\n  using ll = long long;  \n  ll ti=0;\n  auto f=[](ll a,ll b){return a+b;};\n  SegmentTree<ll, ll, decltype(f), decltype(f), decltype(f)> seg(f,f,f,ti,ti);  \n  seg.build(Vector<ll>(n,0));\n  \n  int q;\n  scanf(\"%d\",&q);\n  for(int i=0;i<q;i++){\n    int t;\n    scanf(\"%d\",&t);\n    if(t==0){\n      int v,w;\n      scanf(\"%d %d\",&v,&w);\n      seg.update(G.ls[v],G.rs[v],w);      \n    }\n    if(t==1){\n      int u;\n      scanf(\"%d\",&u);\n      printf(\"%lld\\n\",seg.query(G.ls[u],G.ls[u]+1));      \n    }\n  }\n  return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing graph = vector<vector<int>>;\n\nclass lct_node {\n\tlct_node *l, *r, *p;\n\tint val, sum;\n\n\tint pos() {\n\t\tif (p && p->l == this) return -1;\n\t\tif (p && p->r == this) return 1;\n\t\treturn 0;\n\t}\n\tvoid update() {\n\t\tsum = (l ? l->sum : 0) + val + (r ? r->sum : 0);\n\t}\n\tvoid rot() {\n\t\tlct_node *par = p;\n\t\tlct_node *mid;\n\t\tif (p->l == this) {\n\t\t\tmid = r;\n\t\t\tr = par;\n\t\t\tpar->l = mid;\n\t\t}\n\t\telse {\n\t\t\tmid = l;\n\t\t\tl = par;\n\t\t\tpar->r = mid;\n\t\t}\n\t\tif (mid) mid->p = par;\n\t\tp = par->p;\n\t\tpar->p = this;\n\t\tif (p && p->l == par) p->l = this;\n\t\tif (p && p->r == par) p->r = this;\n\t\tpar->update();\n\t\tupdate();\n\t}\n\tvoid splay() {\n\t\twhile (pos()) {\n\t\t\tint st = pos() * p->pos();\n\t\t\tif (!st) rot();\n\t\t\telse if (st == 1) p->rot(), rot();\n\t\t\telse rot(), rot();\n\t\t}\n\t}\n\npublic:\n\tlct_node(int v = 0) : l(nullptr), r(nullptr), p(nullptr), val(v), sum(v) {}\n\tvoid expose() {\n\t\tfor (lct_node *x = this, *y = nullptr; x; y = x, x = x->p) x->splay(), x->r = y, x->update();\n\t\tsplay();\n\t}\n\tvoid link(lct_node *x) {\n\t\tx->expose();\n\t\texpose();\n\t\tp = x;\n\t}\n\tvoid cut() {\n\t\texpose();\n\t\tl->p = nullptr;\n\t\tl = nullptr;\n\t\tupdate();\n\t}\n\tint find_sum() {\n\t\texpose();\n\t\treturn sum;\n\t}\n\tvoid update_val(int v) {\n\t\texpose();\n\t\tval += v;\n\t\tupdate();\n\t}\n};\n\nconst int MAX = 1e5;\n\nlct_node lct[MAX];\n\nvoid build(int v, const graph& G) {\n\tfor (auto to : G[v]) {\n\t\tlct[to].link(&lct[v]);\n\t\tbuild(to, G);\n\t}\n}\n\nint main()\n{\n\tios::sync_with_stdio(false), cin.tie(0);\n\tint n;\n\tcin >> n;\n\tgraph G(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint k;\n\t\tcin >> k;\n\t\tfor (int j = 0; j < k; j++) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tbuild(0, G);\n\tint q;\n\tcin >> q;\n\twhile (q--) {\n\t\tint com;\n\t\tcin >> com;\n\t\tif (com == 0) {\n\t\t\tint v, w;\n\t\t\tcin >> v >> w;\n\t\t\tlct[v].update_val(w);\n\t\t}\n\t\telse {\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tprintf(\"%d\\n\", lct[u].find_sum());\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// template version 1.15\nusing namespace std;\n#include <bits/stdc++.h>\n\n// varibable settings\n#define int long long\nconst int INF=1e18;\n\n// define basic macro {{{\n#define _overload3(_1,_2,_3,name,...) name\n#define _rep(i,n) repi(i,0,n)\n#define repi(i,a,b) for(int i=(int)(a);i<(int)(b);++i)\n#define rep(...) _overload3(__VA_ARGS__,repi,_rep,)(__VA_ARGS__)\n#define _rrep(i,n) rrepi(i,0,n)\n#define rrepi(i,a,b) for(int i=(int)((b)-1);i>=(int)(a);--i)\n#define rrep(...) _overload3(__VA_ARGS__,rrepi,_rrep,)(__VA_ARGS__)\n#define each(i,a) for (auto&& i : a)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define pb(a) push_back(a)\n#define mp(a, b) make_pair(a, b)\n#define mt(a, b, c) make_tuple(a, b, c)\n#define ub upper_bound\n#define lb lower_bound\n#define posl(A, x) (lower_bound(all(A), x)-A.begin())\n#define posu(A, x) (upper_bound(all(A),x)-A.begin())\ntemplate<class T> inline void chmax(T &a, const T &b) { if((a) < (b)) (a) = (b); }\ntemplate<class T> inline void chmin(T &a, const T &b) { if((a) > (b)) (a) = (b); }\n\n#define divceil(a,b) ((a)+(b)-1)/(b)\n#define is_in(x, a, b) ((a)<=(x) && (x)<(b))\n#define uni(x) sort(all(x));x.erase(unique(all(x)),x.end())\n#define slice(l, r) substr(l, r-l)\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long double ld;\ntypedef pair<int,int> pii;\ntypedef tuple<int,int,int> iii;\n\ntemplate<typename T> using PQ = priority_queue<T, vector<T>, greater<T>>;\nstruct Fast { Fast(){ std::cin.tie(0); ios::sync_with_stdio(false); } } fast;\n\n#if defined(PCM) || defined(LOCAL)\n  #include \"lib/dump.hpp\"\n#else\n  #define dump(...) 42\n  #define dump_1d(...) 42\n  #define dump_2d(...) 42\n  #define cerrendl 42\n#endif\n//}}}\n\ntemplate <typename T,typename E>\nstruct SegmentTreeLazy{\n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  int n,height;\n  F f;  // 区間のマージ\n  G g;  // 更新をどのように行うか\n  H h;  // 複数の更新のまとめ方\n  T ti;  // 値の単位元\n  E ei;  // 恒等置換\n  vector<T> dat;\n  vector<E> laz;\n  SegmentTreeLazy(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei){}\n\n  void init(int n_){/*{{{*/\n    n=1;height=0;\n    while(n<n_) n<<=1,height++;\n    dat.assign(2*n,ti);\n    laz.assign(2*n,ei);\n  }/*}}}*/\n\n  void build(const vector<T> &v){/*{{{*/\n    int n_=v.size();\n    init(n_);\n    for(int i=0;i<n_;i++) dat[n+i]=v[i];\n    for(int i=n-1;i;i--)\n      dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n  }/*}}}*/\n\n  inline T reflect(int k){/*{{{*/\n    return laz[k]==ei?dat[k]:g(dat[k],laz[k]);\n  }/*}}}*/\n\n  inline void propagate(int k){/*{{{*/\n    if(laz[k]==ei) return;\n    laz[(k<<1)|0]=h(laz[(k<<1)|0],laz[k]);\n    laz[(k<<1)|1]=h(laz[(k<<1)|1],laz[k]);\n    dat[k]=reflect(k);\n    laz[k]=ei;\n  }/*}}}*/\n\n  inline void thrust(int k){/*{{{*/\n    for(int i=height;i;i--) propagate(k>>i);\n  }/*}}}*/\n\n  inline void recalc(int k){/*{{{*/\n    while(k>>=1)\n      dat[k]=f(reflect((k<<1)|0),reflect((k<<1)|1));\n  }/*}}}*/\n\n  void update(int a,int b,E x){/*{{{*/\n    if(a>=b) return;\n    thrust(a+=n);\n    thrust(b+=n-1);\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1){\n      if(l&1) laz[l]=h(laz[l],x),l++;\n      if(r&1) --r,laz[r]=h(laz[r],x);\n    }\n    recalc(a);\n    recalc(b);\n  }/*}}}*/\n\n  void set_val(int a,T x){/*{{{*/\n    thrust(a+=n);\n    dat[a]=x;laz[a]=ei;\n    recalc(a);\n  }/*}}}*/\n\n  T query(int a,int b){/*{{{*/\n    if(a>=b) return ti;\n    thrust(a+=n);\n    thrust(b+=n-1);\n    T vl=ti,vr=ti;\n    for(int l=a,r=b+1;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,reflect(l++));\n      if(r&1) vr=f(reflect(--r),vr);\n    }\n    return f(vl,vr);\n  }/*}}}*/\n\n  template<typename C> int find(int st,C &check,T &acc,int k,int l,int r){/*{{{*/\n    if(l+1==r){\n      acc=f(acc,reflect(k));\n      return check(acc)?k-n:-1;\n    }\n    propagate(k);\n    int m=(l+r)>>1;\n    if(m<=st) return find(st,check,acc,(k<<1)|1,m,r);\n    if(st<=l&&!check(f(acc,dat[k]))){\n      acc=f(acc,dat[k]);\n      return -1;\n    }\n    int vl=find(st,check,acc,(k<<1)|0,l,m);\n    if(~vl) return vl;\n    return find(st,check,acc,(k<<1)|1,m,r);\n  }/*}}}*/\n\n  template<typename C> int find(int st,C &check){/*{{{*/\n    T acc=ti;\n    return find(st,check,acc,1,0,n);\n  }/*}}}*/\n};\n\n\ntemplate<typename T> struct SegmentTree { // {{{\n  private:\n    using F = function<T(T,T)>;\n    int n;  // 元の配列のサイズ\n    int N;  // n以上の最小の2冪\n    vector<T> node;\n    F merge;\n    T identity;\n\n  public:\n    SegmentTree(){}\n    SegmentTree(vector<T> a, F f, T id):merge(f), identity(id) {\n      n = a.size();\n      N = 1; while(N < n) N *= 2;\n      node.resize(2*N-1, identity);\n      for(int i=0; i<n; i++) node[i+N-1] = a[i];\n      for(int i=N-2; i>=0; i--) node[i] = merge(node[2*i+1], node[2*i+2]);\n    }\n    SegmentTree(int n, F f, T id) : SegmentTree(vector<T>(n, id), f, id) {}\n\n    T& operator[](int i) { return node[i+N-1]; }\n\n    void update(int x, T val) {\n      x += (N - 1);\n      node[x] = val;\n      while(x > 0) {\n        x = (x - 1) / 2;\n        node[x] = merge(node[2*x+1], node[2*x+2]);\n      }\n    }\n\n    void add(int x, T val) {\n      x += (N - 1);\n      node[x] += val;\n      while(x > 0) {\n        x = (x - 1) / 2;\n        node[x] = merge(node[2*x+1], node[2*x+2]);\n      }\n    }\n\n    // query for [l, r)\n    T query(int a, int b, int k=0, int l=0, int r=-1) {\n      if(r < 0) r = N;\n      if(r <= a || b <= l) return identity;\n      if(a <= l && r <= b) return node[k];\n\n      T vl = query(a, b, 2*k+1, l, (l+r)/2);\n      T vr = query(a, b, 2*k+2, (l+r)/2, r);\n      return merge(vl, vr);\n    }\n\n    friend ostream& operator<<(ostream &os, SegmentTree<T>& sg){ //\n      os << \"[\";\n      for(int i=0; i<sg.n; i++){\n        os << sg[i] << (i==sg.n-1?\"]\\n\":\", \");\n      }\n      return os;\n    }\n};\n// }}}\nstruct tree{/*{{{*/\n  int n;\n  vector<int> par;  // par[i]: dfs木における親\n  vector<int> cost;  // par[i]: dfs木における親への辺のコスト\n  vector<int> dfstrv; // dfstrv[i]: dfs木でi番目に訪れるノード。dpはこれを逆順に回す\n  vector<int> ord;  // ord[u]: uのdfs木における訪問順\n  vector<int> pos;  // pos[u]: uのdfs終了時のカウンター\n  vector<int> psize; // psize[u]: uのpartial tree size\n  // vの部分木は[ord[v], pos[v])\n  // ordとdfstrvは逆変換\n\n  vector<int> depth;  // depth[i]: dfs木でのiの深さ\n  vector<vector<pair<int, int>>> g; // 辺(隣接リスト)\n  vector<vector<int>> children;\n  vector<int> euler_tour;\n  vector<int> et_fpos;  // euler_tour first occurence position\n  SegmentTree<int> _seg;  // seg(map(ord, euler_tour), mymin, 1e18)\n\n  int _counter = 0;\n\n  tree(int n):\n    n(n),par(n),cost(n,1),ord(n),pos(n),psize(n),depth(n),g(n),children(n),et_fpos(n)\n  {};\n\n  void add_edge(int u, int v, int cost){\n    g[u].emplace_back(v, cost);\n    g[v].emplace_back(u, cost);\n  }\n  void add_edge(int u, int v){\n    g[u].emplace_back(v, 1);\n    g[v].emplace_back(u, 1);\n  }\n\n  void build(int root){\n    _counter = 0;\n    par[root] = -1;\n    cost[root] = INF;\n    _dfs_tree(root, -1, 0);\n    _dfs_et(root);\n    vector<int> ini(2*n-1); rep(i, 2*n-1) ini[i] = ord[euler_tour[i]];\n    _seg = SegmentTree<int>(ini, [](auto a, auto b){return min(a,b);}, 1e18);\n  }\n\n  void _dfs_tree(int u, int pre, int _depth){\n    dfstrv.pb(u);\n    ord[u] = _counter;\n    depth[u] = _depth;\n\n    _counter++;\n    each(el, g[u]){\n      int v = el.first;\n      if (v==pre) continue;\n\n      children[u].pb(v);\n      par[v] = u;\n      cost[v] = el.second;\n      _dfs_tree(v, u, _depth+1);\n    }\n    pos[u] = _counter;\n    psize[u] = pos[u] - ord[u];\n  }\n\n  void _dfs_et(int u){\n    et_fpos[u] = euler_tour.size();\n    euler_tour.pb(u);\n    each(v, children[u]){\n      _dfs_et(v);\n      euler_tour.pb(u);\n    }\n  }\n\n  int lca(int u, int v){\n    if (u==v) return u;\n    if (et_fpos[u]>et_fpos[v]) swap(u, v);\n    return dfstrv[_seg.query(et_fpos[u], et_fpos[v])];\n  }\n};/*}}}*/\n\nsigned main() {\n  int n;cin>>n;\n  tree tr(n);\n\n  rep(u, n){\n    int k;cin>>k;\n    rep(_, k){\n      int v;cin>>v;\n      tr.add_edge(u, v, 0);\n    }\n  }\n  tr.build(0);\n\n  auto f=[](int ta,int tb){return ta+tb;};\n  auto g=[](int t,int e){return t+e;};\n  int ti=0,ei=0;\n  SegmentTreeLazy<int, int> lseg(f,g,g,ti,ei);\n  const int sz = 1<<20;\n  lseg.build(vector<int>(sz,0));\n\n  int Q;cin>>Q;\n  rep(q, Q){\n    int t;cin>>t;\n    if (t==0){\n      int v,w;cin>>v>>w;\n      dump(tr.ord[v], tr.pos[v]);\n      lseg.update(tr.ord[v], tr.pos[v], w);\n    }\n    else{\n      int u;cin>>u;\n      cout << lseg.query(tr.ord[u], tr.ord[u]+1) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n   \nstruct Edge {\n    int to;\n    // int64_t dist{1};\n   \n    // int64_t cost;\n    // int from;\n    // int rev_i;\n};\nusing EdgeVec = std::vector<Edge>;\nusing EdgeLists = std::vector<EdgeVec>;\n   \n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここからコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n   \n// コンストラクタの引数は無向の木の隣接リスト\nclass TreeEulerTour {\nprivate:\n    using vi = std::vector<int>;\n    using vvi = std::vector<vi>;\n   \n    const EdgeLists& edges_;\n    const int root_;\n    vi tourList_;\n    vvi inverseList_;\n   \n    void makeEulerTour(const int index)\n    {\n        addList(index);\n        int parent_i{-1};\n        for (int edge_i{}; edge_i < (int)edges_[index].size(); edge_i++)\n        {\n            const Edge& edge{edges_[index][edge_i]};\n            makeEulerTour(edge.to);\n            addList(index);\n        }\n    }\n   \n    void addList(const int index)\n    {\n        inverseList_[index].push_back(tourList_.size());\n        tourList_.push_back(index);\n    }\n   \npublic:\n    // オイラーツアーのindexのリスト\n    const vi& tourList;\n    // eulerTourListの逆像\n    const vvi& inverseList;\n   \n    TreeEulerTour(const EdgeLists& adjacentList, const int root)\n        : edges_(adjacentList), root_(root), tourList(tourList_), inverseList(inverseList_)\n    {\n        inverseList_.resize(adjacentList.size());\n        makeEulerTour(root_);\n    }\n};\n   \n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////////////////////////// ここまでコピペ ////////////////////////////////////////////////\n//////////////////////////////////////////////////////////////////////////////////////////////////////////\n   \n///////////////////////////\n// Range Sum Query (BIT) //\n///////////////////////////\n   \nclass RSumQBIT {\nprivate:\n    std::vector<int64_t> container_;\n   \n    int64_t getHelper(const int index) const\n    {\n        if (index < 0) return 0;\n        if ((int)(container_.size()) <= index) return container_.back();\n        int64_t sum{};\n        for (int add_place{index}; add_place > 0; add_place -= add_place & -add_place)\n            sum += container_[add_place];\n        return sum;\n    }\n   \npublic:\n    RSumQBIT(const int array_size)\n        : container_(array_size + 1) {}\n    // indexは0-indexed\n    void update(const int index, const int64_t added)\n    {\n        for (int update_place{index + 1}; update_place < (int)(container_.size()); update_place += update_place & -update_place)\n            container_[update_place] += added;\n    }\n    // left,rightは0-indexed、[left, right)の半開区間\n    int64_t get(const int left, const int right) const\n    {\n        return -getHelper(left) + getHelper(right);\n    }\n};\n   \n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_D&lang=jp\nint main()\n{\n    int n;\n    scanf(\"%d\", &n);\n    EdgeLists edges(n);\n    for (int i{}; i < n; i++)\n    {\n        int k;\n        scanf(\"%d\", &k);\n        for (int j{}; j < k; j++)\n        {\n            int c;\n            scanf(\"%d\", &c);\n            edges[i].push_back({c});\n        }\n    }\n    for (auto& e: edges) e.shrink_to_fit();\n       \n    TreeEulerTour euler(edges, 0);\n    RSumQBIT rsq(euler.tourList.size());\n    int q;\n    scanf(\"%d\", &q);\n    for (int q_i{}; q_i < q; q_i++)\n    {\n        int com;\n        scanf(\"%d\", &com);\n        if (com == 0)\n        {\n            int v, w;\n            scanf(\"%d%d\", &v, &w);\n            rsq.update(euler.inverseList[v].front() - 1, w);\n            rsq.update(euler.inverseList[v].back(), -w);\n        }\n        else\n        {\n            int u;\n            scanf(\"%d\", &u);\n            printf(\"%lld\\n\", rsq.get(0, euler.inverseList[u].front()));\n        }\n    }\n   \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<ll, ll> pll;\n\n#define FOR(i, n, m) for(ll (i)=(m);(i)<(n);++(i))\n#define REP(i, n) FOR(i,n,0)\n#define OF64 std::setprecision(10)\n\nconst ll MOD = 1000000007;\nconst ll INF = (ll) 1e15;\n\nstruct EulerTree {\n    EulerTree(int n) {\n        mId.resize(n);\n        mEdgeIndex.resize((n - 1) * 2);\n        mBit = BinaryIndexTree((n - 1) * 2 + 1);\n        mCost.assign(n - 1, 0);\n        mVertex.resize(n);\n    }\n\n    //! add edge\n    void addEdge(int u, int v, int index, long long int cost = 1) {\n        mVertex[u].node.push_back(Edge{v, cost, index});\n        mVertex[v].node.push_back(Edge{u, cost, index});\n        mCost[index] = cost;\n    }\n\n    //! build euler tour tree\n    void build(int root = 0) {\n        mEulerTour.clear();\n        dfs(root, -1, 0);\n\n        mOffset = 1;\n        while (mOffset < mEulerTour.size())\n            mOffset <<= 1;\n        mDat.assign(mOffset << 1, pair<int, int>(INF_VALUE, -1));\n        for (int i = 0; i < mEulerTour.size(); ++i) {\n            mDat[i + mOffset] = mEulerTour[i];\n        }\n        for (int i = mOffset - 1; i >= 0; --i) {\n            mDat[i] = merge(mDat[(i << 1) | 0], mDat[(i << 1) | 1]);\n        }\n    }\n\n    //! update edge cost\n    void update(int index, long long int cost) {\n        long long int c = mCost[index];\n        mBit.add(mEdgeIndex[index * 2 + 0], cost - c);\n        mBit.add(mEdgeIndex[index * 2 + 1], -cost + c);\n        mCost[index] = cost;\n    }\n\n    int lca(int u, int v) {\n        auto q = query(std::min(mId[u], mId[v]), std::max(mId[u], mId[v]));\n        return q.second;\n    }\n\n    //! get u-v path cost\n    long long int cost(int u, int v) {\n        int p = lca(u, v);\n        return mBit.sum(mId[u]) + mBit.sum(mId[v]) - mBit.sum(mId[p]) * 2LL;\n    }\n\n    void dfs(int vertex, int parent, int depth) {\n        mId[vertex] = mEulerTour.size();\n        mEulerTour.push_back(pair<int, int>(depth, vertex));\n        for (int i = 0; i < static_cast<int>(mVertex[vertex].node.size()); ++i) {\n            const Edge &e = mVertex[vertex].node[i];\n            if (e.to == parent)\n                continue;\n\n            int go = mEulerTour.size();\n            mBit.add(go, e.cost);\n            mEdgeIndex[e.index * 2 + 0] = go;\n\n            dfs(e.to, vertex, depth + 1);\n\n            mEulerTour.push_back(pair<int, int>(depth, vertex));\n\n            int back = mEulerTour.size();\n            mBit.add(back, -e.cost);\n            mEdgeIndex[e.index * 2 + 1] = back;\n        }\n    }\n\n    //! [left,right]\n    pair<int, int> query(int left, int right) {\n        left += mOffset;\n        right += mOffset + 1;\n\n        pair<int, int> val = pair<int, int>(INF_VALUE, -1);\n        while (left < right) {\n            if (left & 1)\n                val = merge(val, mDat[left++]);\n            if (right & 1)\n                val = merge(val, mDat[--right]);\n\n            left >>= 1;\n            right >>= 1;\n        }\n        return val;\n    }\n\n    const pair<int, int> &merge(const pair<int, int> &a, const pair<int, int> &b) {\n        if (a.first < b.first)\n            return a;\n        return b;\n    }\n\n    struct Edge {\n        int to;\n        long long int cost;\n        int index;\n    };\n\n    struct Vertex {\n        vector<Edge> node;\n    };\n\n    struct BinaryIndexTree {\n        BinaryIndexTree()\n                : mN(0), mPow(0) {}\n\n        BinaryIndexTree(int n)\n                : mN(n) {\n            mPow = 1;\n            while (mPow < n)\n                mPow <<= 1;\n            node.resize(n + 1);\n            REP(i, n + 1) {\n                node[i] = 0;\n            }\n        }\n\n        ~BinaryIndexTree() {\n            node.resize(0);\n        }\n\n        //! 1-index get\n        ll sum(int index) {\n            ll sum = 0;\n            for (int i = index; i > 0; i -= i & (-i))\n                sum += node[i];\n            return sum;\n        }\n\n        //! 1-index add\n        void add(int index, long long int value) {\n            for (int i = index; i <= mN; i += i & (-i))\n                node[i] += value;\n        }\n\n        vector<long long int> node;\n        int mN;\n        long long int mPow;\n    };\n\n    int mRoot = 0;\n    vector<int> mId;\n    vector<pair<int, int>> mEulerTour;   //!< (depth, index)\n    BinaryIndexTree mBit;\n    vector<Vertex> mVertex;\n    vector<int> mEdgeIndex;\n    vector<long long int> mCost;\n    vector<pair<int, int>> mDat;\n    int INF_VALUE = 1e8;\n    int mOffset;\n};\n\nmap<pll, ll> edge;\nll P[100005];\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    ll N;\n    cin >> N;\n    EulerTree tree(N);\n    ll index = 0;\n    REP(i, N) {\n        ll k;\n        cin >> k;\n        REP(_, k) {\n            ll n;\n            cin >> n;\n            P[n] = i;\n\n            tree.addEdge(n, i, index, 0);\n            edge[pll(i, n)] = index++;\n        }\n    }\n    tree.build(0);\n    ll Q;\n    cin >> Q;\n    REP(_, Q) {\n        ll q;\n        cin >> q;\n        if (q == 0) {\n            ll u, w;\n            cin >> u >> w;\n            ll p = P[u];\n            ll ei = edge[pll(p, u)];\n            tree.update(ei, tree.mCost[ei] + w);\n            continue;\n        }\n\n        ll u;\n        cin >> u;\n        cout << tree.cost(0, u) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\ntypedef long long int ll;\ntypedef unsigned long long int ull;\n#define BIG_NUM 2000000000\n#define HUGE_NUM 99999999999999999\n#define MOD 1000000007\n#define EPS 0.000000001\nusing namespace std;\n\n\n\n#define NUM 100005\n\nstruct Edge{\n\tEdge(int arg_to){\n\t\tto = arg_to;\n\t}\n\tint to;\n};\n\nstruct Info{\n\n\tInfo(){\n\t\tto_root_sum_weight = 0;\n\t}\n\tInfo(ll arg_to_root_sum_weight){\n\t\tto_root_sum_weight = arg_to_root_sum_weight;\n\t}\n\n\tll to_root_sum_weight; //根方向の辺に累積された重さ\n};\n\nstruct Data{\n\tint parent,head,depth,size;\n};\n\nint V,N;\nint root,global_index;\nint index_table[NUM];\nll K;\nData data[NUM];\nInfo  table[8*NUM]; //セグ木\nvector<Edge> G[NUM];\n\nvoid init(int first_N){\n\twhile(N < first_N)N *= 2;\n}\n\nInfo merge(Info a,Info b){\n\n\tif(a.to_root_sum_weight == -1)return b; //aが範囲外\n\tif(b.to_root_sum_weight == -1)return a; //bが範囲外\n\n    Info ret = Info(a.to_root_sum_weight+b.to_root_sum_weight);\n\n    return ret;\n}\n\nvoid add(int loc,ll value){\n\n\tloc += N-1;\n\n\ttable[loc].to_root_sum_weight += value; //根方向に加算\n\n\tint parent = (loc-1)/2;\n\tint left_child,right_child;\n\n\twhile(true){\n\n\t\tleft_child = 2*parent+1; //根に近い子\n\t\tright_child = 2*parent+2; //葉に近い子\n\n\t\ttable[parent] = merge(table[left_child], table[right_child]);\n\n\t\tif(parent == 0){\n\n\t\t\tbreak;\n\n\t\t}else{\n\n\t\t\tparent = (parent-1)/2;\n\t\t}\n\t}\n}\n\nint makeTree(int node_id,int parent,int depth){\n\n\tdata[node_id].depth = depth;\n\tdata[node_id].parent = parent;\n\tdata[node_id].size = 1; //部分木のノード数(自分&子孫)\n\n\tint child;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tchild = G[node_id][i].to;\n\t\tif(child == parent)continue;\n\n\t\tdata[node_id].size += makeTree(child,node_id,depth+1);\n\t}\n\n\treturn data[node_id].size;\n}\n\nvoid HLD(int node_id,int head,int parent){\n\n\tindex_table[node_id] = global_index++; //★★根に近いものほど、番号が小さい(★左にある★)\n\tdata[node_id].head = head;\n\n\tif(G[node_id].size() == 0)return;\n\n\t//子の中で、最大の重み(部分木のノード数)を持つものを探す\n\tint max_size = -BIG_NUM;\n\tint max_node_id = -1,child;\n\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tchild = G[node_id][i].to;\n\t\tif(child == parent)continue;\n\n\t\tif(max_size < data[child].size){\n\n\t\t\tmax_size = data[child].size;\n\t\t\tmax_node_id = child;\n\t\t}\n\t}\n\n\tif(max_node_id == -1)return;\n\n\t//最大の重みを持つ子へ(headは変わらず)\n\tHLD(max_node_id,head,node_id);\n\n\t//その他の子を処理(新しいラインを作る)\n\tfor(int i = 0; i < G[node_id].size(); i++){\n\n\t\tchild = G[node_id][i].to;\n\t\tif(child == parent || child == max_node_id)continue;\n\n\t\tHLD(child,child,node_id);\n\t}\n}\n\n//セグ木には、%Kの判定が済んだ値が保存されている\nInfo query(int search_left,int search_right,int node_id,int node_left,int node_right){\n\n\t//範囲外\n\tif(search_right < node_left || search_left > node_right)return Info(-1);\n\n\t//今回のノードの区間が、検索区間の部分区間である場合\n\tif(search_left <= node_left && search_right >= node_right){\n\t\treturn table[node_id];\n\t}\n\n\t//今回のノードの区間に、一部検索区間と重なっている区間がある場合→再帰的に子どもに尋ねる\n\tInfo left_info = query(search_left,search_right,2*node_id+1,node_left,(node_left+node_right)/2);\n\tInfo right_info = query(search_left,search_right,2*node_id+2,(node_left+node_right)/2+1,node_right);\n\n\treturn merge(left_info,right_info);\n}\n\nll query(int from,int to){\n\n\treturn query(index_table[from],index_table[to],0,0,N-1).to_root_sum_weight;\n}\n\n//node_id～rootへのコストを求める\nll get_weight(int node_id){\n\n\tll ret = 0;\n\tint head_node;\n\n\twhile(true){\n\n\t\thead_node = data[node_id].head;\n\n\t\t//node_id～同じラインのヘッドのコストを求める(セグ木演算)\n\t\tret += query(head_node,node_id);\n\n\t\tif(head_node == root)break; //rootまで到達したらbreak\n\n\t\tnode_id = data[head_node].parent;\n\t}\n\n\treturn ret;\n}\n\nint main(){\n\n\tint first_N;\n\n\tscanf(\"%d\",&first_N);\n\n\tint num;\n\tint from,to;\n\n\tfor(from = 0; from <= first_N-1; from++){\n\n\t\tscanf(\"%d\",&num);\n\t\tfor(int i = 0; i < num; i++){\n\t\t\tscanf(\"%d\",&to);\n\t\t\tG[from].push_back(Edge(to));\n\t\t\tG[to].push_back(Edge(from));\n\t\t}\n\t}\n\n\troot = 0;\n\n\tmakeTree(root,-1,0);\n\tglobal_index = 0;\n\tHLD(root,root,-1);  //0スタートでdfs木を作ったので、0がrootとなる\n\n\t//dfs木をセグメント木に変換する\n\tN = 1;\n\tinit(first_N);\n\n\tfor(int i = 0; i < N; i++){\n\n\t\tadd(i,0); //セグ木の構築\n\t}\n\n\tint num_query;\n\tscanf(\"%d\",&num_query);\n\n\tint node_id,command,add_weight;\n\n\tfor(int loop = 0; loop < num_query; loop++){\n\n\t\tscanf(\"%d\",&command);\n\n\t\tif(command == 0){\n\n\t\t\tscanf(\"%d %d\",&node_id,&add_weight);\n\t\t\tadd(index_table[node_id],add_weight);\n\n\t\t}else{\n\n\t\t\tscanf(\"%d\",&node_id);\n\t\t\tprintf(\"%lld\\n\",get_weight(node_id));\n\t\t}\n\t}\n\n\treturn 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "//sub-BOF\n#define _AOJ_\n        /*vvv>\n        zzzzzI\n .---.  zzuzuI                 .vgggg&,.\n+++++=  dAC:|I  .WbbWo       JMM9^```?TMB`  ..&gNNg,.   gggggggJ,   qgggggggg] (&&&&&&&&[   c+OA&J,   (&&&&&&+J,   .cJeAA&-.  (&&&&&&&&x   .&AA&=-.\n+++++=  dTqk|I  Xpbpbp      JM#`           (M#^   ?MMp  MM|   +TMN. JMF      ' |yk      ` dVY    7Vk,  Vy     XV  cVf     ?Y!  JM         V$      `\n+++++=  dcf:|I  Xppppp      dMN           .MM+     .MM  MM|     MM] JMMMMMM+   |@tqkoh)  ,y0      (V$  yyyyyyyV7  VV           JMWyZWr    TWVVVVW&,\n++++++  d7qk|0  Xppppp      ^HMN,    _.db  WMm,   .MMF  MM|   ..MM` JMF      . |yk       .WV&.   .XW'  yy   4yn.  jyn      +.  JM                #S\n`++++`  ?ZZZX=  ?WWWW=        -THMMMMH9^    (TMMMMM9!   MMMMMMM\"\"   JMMMMMMMME |UU.        ?TUUUUY=    UU.   (UU-  ^7TUUUV7!   JUUUUUUUU  7TUNKO*/\n\n\n//basic\n#pragma GCC target(\"sse4\")\n#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long lint;\ntypedef long double ld;\ntypedef string cs;\n#define all(v) v.begin(),v.end()\n#define pb push_back\n\n//rep\n#define _vcppunko4(tuple) _getname4 tuple\n#define _getname4(_1,_2,_3,_4,name,...) name\n#define _getname3(_1,_2,_3,name,...) name\n#define _trep2(tuple) _rep2 tuple\n#define _trep3(tuple) _rep3 tuple\n#define _trep4(tuple) _rep4 tuple\n#define _rep1(n) for(lint i=0;i<n;++i)\n#define _rep2(i,n) for(lint i=0;i<n;++i)\n#define _rep3(i,a,b) for(lint i=a;i<b;++i)\n#define _rep4(i,a,b,c) for(lint i=a;i<b;i+=c)\n#define _trrep2(tuple) _rrep2 tuple\n#define _trrep3(tuple) _rrep3 tuple\n#define _trrep4(tuple) _rrep4 tuple\n#define _rrep1(n) for(lint i=n-1;i>=0;--i)\n#define _rrep2(i,n) for(lint i=n-1;i>=0;--i)\n#define _rrep3(i,a,b) for(lint i=b-1;i>=a;--i)\n#define _rrep4(i,a,b,c) for(lint i=a+(b-a-1)/c*c;i>=a;i-=c)\n#define rep(...) _vcppunko4((__VA_ARGS__,_trep4,_trep3,_trep2,_rep1))((__VA_ARGS__))\n#define per(...) _vcppunko4((__VA_ARGS__,_trrep4,_trrep3,_trrep2,_rrep1))((__VA_ARGS__))\n#define each(c) for(auto &e:c)\n\n//io\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec);\ntemplate<class T,size_t size>\nistream& operator>>(istream& is,array<T,size>& vec);\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p);\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec);\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p);\ntemplate<class T>\nistream& operator>>(istream& is,vector<T>& vec){ for(T& x: vec) is>>x;return is; }\ntemplate<class T,class L>\nistream& operator>>(istream& is,pair<T,L>& p){ is>>p.first;is>>p.second;return is; }\ntemplate<class T,class L>\nostream& operator<<(ostream& os,pair<T,L>& p){ os<<p.first<<\" \"<<p.second;return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,vector<T>& vec){ os<<vec[0];rep(i,1,vec.size())os<<' '<<vec[i];return os; }\ntemplate<class T>\nostream& operator<<(ostream& os,deque<T>& deq){ os<<deq[0];rep(i,1,deq.size())os<<' '<<deq[i];return os; }\n\n#ifdef __ENV_TQK__\n#include<Windows.h>\nHANDLE hConsole = GetStdHandle(STD_OUTPUT_HANDLE);\ninline void in(){ SetConsoleTextAttribute(hConsole,10); }\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){\n\tSetConsoleTextAttribute(hConsole,15);\n\tcin>>head;in(move(tail)...);\n}\n#else\ninline void in(){}\ntemplate <class Head,class... Tail>\ninline void in(Head&& head,Tail&&... tail){ cin>>head;in(move(tail)...); }\n#endif\n\n\n\ninline bool out(){ return(cout<<'\\n',0); }\ntemplate <class T>\ninline bool out(T t){ return(cout<<t<<'\\n',0); }\ntemplate <class Head,class... Tail>\ninline bool out(Head head,Tail... tail){ cout<<head<<' ';out(move(tail)...);return 0; }\ntemplate <class T>\ninline void alloc(T &c,lint s){ rep(c.size())c[i].resize(s); }\n#define alc alloc\n\n//TA\n#define lin(...) lint __VA_ARGS__;in(__VA_ARGS__)\n#define stin(...) string __VA_ARGS__;in(__VA_ARGS__)\n#define vin(type,name,size) vector<type> name(size);in(name)\n#define vvin(type,name,h,...) vector<vector<type>>name(h,vector<type>(__VA_ARGS__));in(name)\n#define fi e.first\n#define se e.second\n#define YES(c) cout<<((c)?\"YES\\n\":\"NO\\n\"),0\n#define Yes(c) cout<<((c)?\"Yes\\n\":\"No\\n\"),0\n#define POSSIBLE(c) cout<<((c)?\"POSSIBLE\\n\":\"IMPOSSIBLE\\n\"),0\n#define Possible(c) cout<<((c)?\"Possible\\n\":\"Impossible\\n\"),0\n#define o(p) cout<<p<<endl,0\n#define sp(p) cout<<p<<\" \"\n#define no(p) cout<<p\ninline constexpr lint gcd(lint a,lint b){ if(!a||!b)return 0;while(b){ lint c=b;b=a%b;a=c; }return a; }\ntemplate<typename T>\ninline constexpr bool chmin(T &mn,const T &cnt){ if(mn>cnt){ mn=cnt;return 1; } else return 0; }\ntemplate<typename T>\ninline constexpr bool chmax(T &mx,const T &cnt){ if(mx<cnt){ mx=cnt;return 1; } else return 0; }\n#define ve(type) vector<type>\n#define fn(ty1,ty2,ex) [](ty1 a,ty2 b){ return(ex); }\n#define lfn(ex) [](lint a,lint b){ return(ex); }\n\n//other\n#ifdef __ENV_TQK__\n#define deb(ex) out(ex)\n#else\n#define deb(ex) 0\n#endif\nstruct Fastio{\n\tFastio(){\n\t\tcin.tie(0),cout.tie(0);\n\t\tios::sync_with_stdio(0);\n\t\tcout<<fixed<<setprecision(10);\n\t}\n} __fastio;\n\n\n//mint\n#define md_tmp template<uint_fast64_t md=1000000007>\nmd_tmp class mint{\n\tusing u64=uint_fast64_t;\n\npublic:\n\tu64 a;\n\n\tconstexpr mint(const u64 x=0) noexcept: a(x%md){}\n\tconstexpr u64 &value() noexcept{ return a; }\n\tconstexpr const u64 &value() const noexcept{ return a; }\n\tconstexpr mint operator+(const mint rhs) const noexcept{\n\t\treturn mint(*this)+=rhs;\n\t}\n\tconstexpr mint operator-(const mint rhs) const noexcept{\n\t\treturn mint(*this)-=rhs;\n\t}\n\tconstexpr mint operator*(const mint rhs) const noexcept{\n\t\treturn mint(*this)*=rhs;\n\t}\n\tconstexpr mint operator^(const lint rhs) const noexcept{\n\t\treturn mint(*this)^=rhs;\n\t}\n\tconstexpr mint operator/(const mint rhs) const noexcept{\n\t\treturn mint(*this)/=rhs;\n\t}\n\tconstexpr mint &operator+=(const mint rhs) noexcept{\n\t\ta+=rhs.a;\n\t\tif(a>=md)a-=md;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator-=(const mint rhs) noexcept{\n\t\tif(a<rhs.a)a+=md;\n\t\ta-=rhs.a;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator*=(const mint rhs) noexcept{\n\t\ta=a*rhs.a%md;\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator^=(const lint rhs) noexcept{\n\t\tif(!rhs)return *this=1;\n\t\tu64 exp=rhs-1;\n\t\tmint base=this->a;\n\t\twhile(exp){\n\t\t\tif(exp&1)*this*=base;\n\t\t\tbase*=base;\n\t\t\texp>>=1;\n\t\t}\n\t\treturn *this;\n\t}\n\tconstexpr mint &operator/=(const mint rhs) noexcept{\n\t\ta=(*this*(rhs^(md-2))).a;\n\t\treturn *this;\n\t}\n};\nmd_tmp istream& operator>>(istream& os,mint<md>& m){\n\tos>>m.a,m.a%=md;\n\treturn os;\n}\nmd_tmp ostream& operator<<(ostream& os,const mint<md>& m){\n\treturn os<<m.a;\n}\nmd_tmp mint<md> ncr(lint n,lint r){\n\tif(n<r||n<0||r<0)return mint<md>(0);\n\tmint<md>ncr_res=1,ncr_div=1;\n\trep(r)ncr_res*=(n-i),ncr_div*=(r-i);\n\treturn ncr_res/ncr_div;\n}\n#ifndef _AOJ_\nmint<> operator\"\"m(const unsigned long long n){ return mint<>(n); }\nmint<998244353> operator\"\"m9(const unsigned long long n){ return mint<998244353>(n); }\nmint<1000003> operator\"\"m3(const unsigned long long n){ return mint<1000003>(n); }\n#endif\n\n\n//const\n#define linf 1152921504606846976\n//#define inf linf\n#define MAXN 330\n#define md_1e9_7 1000000007\n#define md_998244353 998244353\n#define pi 3.14159265358979323846\n//#define mod md_1e9_7\nconst int d4[5]={0,1,0,-1,0};\n\n//main------\n\nclass P{ public:lint f,s; P(lint a,lint b):f(a),s(b){}; P():f(0),s(0){}; };\nistream& operator>>(istream& os,P& p){ os>>p.f>>p.s;return os; }\nbool operator<(const P& l,const P& r){ return(l.f-r.f?l.f<r.f:l.s<r.s); }\nbool operator>(const P& l,const P& r){ return(l.f-r.f?l.f>r.f:l.s>r.s); }\n\n\nusing length=lint;//info an edge has\nstruct edge{\n\tint src,to;\n\tlength cost;\n\n\tedge(){}\n\tedge(int to,length cost): src(-1),to(to),cost(cost){}\n\tedge(int src,int to,length cost): src(src),to(to),cost(cost){}\n\tedge &operator=(const int &x){\n\t\tto=x;\n\t\treturn *this;\n\t}\n\toperator int() const{ return to; }\n};\nistream& operator>>(istream& os,edge& e){ os>>e.src>>e.to>>e.cost;return os; }\n\nusing Matrix=vector<vector<length> >;\nusing Edges=vector<edge>;\nusing Graph=vector<Edges>;\nusing UnWeighted=vector<vector<int> >;\n\n\n// HLD( <tree> , root )\n// === .build() ===\n// .fold(hi, lo, func, inclusive)\n//   where func(l, r) proceeds with [l, r)\n// === O(1) ===\n// .in(a) : in-time of Euler Tour : alias = .[a]\n// .out(a) : out-time of Euler Tour\n// .rev(a) : rev[in[a]] = a\n// .head(a) : ascend all light edges\n// .tail(a) : descend all heavy edges\n// ---\n// .subtree_size(a)\n// .depth(a) : 0-indexed\n// .parent(a) : -1 if [a] is root\n// .heavy(a) : [a] cannot be a leaf. return the node opposite of the heavy edge\n// === O(log n) ===\n// .climb(a)\n// .descendTo(from, to, steps)\n// .steps(a, b)\n// === --- ===\n// for subtree : [ .in(a)           , .out(a) )\n// (exclusive) : [ .in_exclusive(a) , .out(a) )\n// HL-Decomposition {{{\n// based on Euler Tour\nstruct HLD{\npublic:\n\tusing size_type = std::size_t;\n\tusing graph_type = std::vector< std::vector< int > >;\n\nprivate:\n\tsize_type n;\n\tstd::vector< size_type > hd,tl;\n\tstd::vector< size_type > sub;\n\tstd::vector< size_type > dep;\n\tstd::vector< int > par;\n\tstd::vector< size_type > vid;\n\tsize_type root;\n\tgraph_type tree;\n\npublic:\n\tHLD(): n(0){}\n\tHLD(size_type n,size_type root = 0)\n\t\t: n(n),hd(n),tl(n),sub(n),dep(n),par(n),vid(n),tree(n){\n\t\tsetRoot(root);\n\t}\n\tHLD(const graph_type &tree,size_type root): HLD(tree.size(),root){\n\t\tthis->tree = tree;\n\t}\n\n\tvoid setRoot(size_type root){\n\t\tassert(root < n);\n\t\tthis->root = root;\n\t}\n\nprivate:\n\tbool built = 0;\n\tstd::vector< size_type > vid_rev;\n\npublic:\n\tvoid build(){\n\t\tassert(!built && n);\n\t\tbuilt = 1;\n\n\t\tvid_rev.resize(n);\n\n\t\thd[root] = root;\n\t\tdfs0();\n\t\tdfs1();\n\t\tfor(size_type i = 0; i < n; i++) vid_rev[vid[i]] = i;\n\t}\n\nprivate:\n\tvoid dfs0(){\n\t\tstd::vector< int > used(n);\n\t\tstd::vector< std::tuple< size_type,int,size_type > > stk;\n\t\tstk.reserve(n);\n\t\tstk.emplace_back(root,-1,0);\n\t\twhile(stk.size()){\n\t\t\tsize_type i,d;\n\t\t\tint p;\n\t\t\tstd::tie(i,p,d) = stk.back();\n\t\t\tif(!used[i]){\n\t\t\t\tused[i] = 1;\n\t\t\t\tpar[i] = p;\n\t\t\t\tdep[i] = d;\n\t\t\t\tfor(auto &j : tree[i])\n\t\t\t\t\tif(j != p){\n\t\t\t\t\t\tstk.emplace_back(j,i,d + 1);\n\t\t\t\t\t}\n\t\t\t} else{\n\t\t\t\tstk.pop_back();\n\t\t\t\tsub[i] = 1;\n\t\t\t\tfor(auto &j : tree[i])\n\t\t\t\t\tif(j != p){\n\t\t\t\t\t\tif(sub[j] > sub[tree[i].back()]){\n\t\t\t\t\t\t\tstd::swap(tree[i].back(),j);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsub[i] += sub[j];\n\t\t\t\t\t}\n\t\t\t\tif(tree[i].back() != p){\n\t\t\t\t\ttl[i] = tl[tree[i].back()];\n\t\t\t\t} else{\n\t\t\t\t\ttl[i] = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvoid dfs1(){\n\t\tstd::vector< int > used(n);\n\t\tstd::vector< std::tuple< size_type,int > > stk;\n\t\tstk.reserve(n);\n\t\tstk.emplace_back(root,-1);\n\t\tsize_type id = 0;\n\t\twhile(stk.size()){\n\t\t\tsize_type i;\n\t\t\tint p;\n\t\t\tstd::tie(i,p) = stk.back(),stk.pop_back();\n\t\t\tvid[i] = id++;\n\t\t\tfor(auto j : tree[i])\n\t\t\t\tif(j != p){\n\t\t\t\t\thd[j] = j == tree[i].back() ? hd[i] : j;\n\t\t\t\t\tstk.emplace_back(j,i);\n\t\t\t\t}\n\t\t}\n\t}\n\npublic:\n\tsize_type operator[](size_type i) const{ return in(i); }\n\tsize_type in(size_type i) const{\n\t\tassert(built);\n\t\tassert(i < n);\n\t\treturn vid[i];\n\t}\n\tsize_type in_exclusive(size_type i) const{ return in(i) + 1; }\n\tsize_type out(size_type i) const{\n\t\tassert(built);\n\t\tassert(i < n);\n\t\treturn vid[i] + sub[i];\n\t}\n\tsize_type out_exclusive(size_type i) const{ return out(i) - 1; }\n\tsize_type head(size_type i) const{\n\t\tassert(built);\n\t\treturn hd.at(i);\n\t}\n\tsize_type tail(size_type i) const{\n\t\tassert(built);\n\t\treturn tl.at(i);\n\t}\n\tsize_type rev(size_type i) const{\n\t\tassert(built);\n\t\treturn vid_rev.at(i);\n\t}\n\tsize_type subtree_size(size_type i) const{\n\t\tassert(built);\n\t\treturn sub.at(i);\n\t}\n\tsize_type depth(size_type i) const{\n\t\tassert(built);\n\t\treturn dep.at(i);\n\t}\n\tint parent(size_type i) const{\n\t\tassert(built);\n\t\treturn par.at(i);\n\t}\n\tsize_type steps(size_type a,size_type b) const{\n\t\tassert(built);\n\t\tassert(a < n && b < n);\n\t\treturn dep[a] + dep[b] - 2 * dep[lca(a,b)];\n\t}\n\tsize_type climb(size_type a,long long t) const{\n\t\tassert(built);\n\t\tassert(a < n && t >= 0);\n\t\twhile(t){\n\t\t\tlong long c = std::min< long long >(vid[a] - vid[hd[a]],t);\n\t\t\tt -= c;\n\t\t\ta = vid_rev[vid[a] - c];\n\t\t\tif(t && a != root){\n\t\t\t\tt--;\n\t\t\t\ta = par[a];\n\t\t\t}\n\t\t\tif(a == root) break;\n\t\t}\n\t\treturn a;\n\t}\n\tsize_type descendTo(size_type from,size_type to,long long steps) const{\n\t\tassert(built);\n\t\tassert(steps >= 0);\n\t\tassert(from < n && to < n);\n\t\treturn climb(to,dep[to] - dep[from] - steps);\n\t}\n\tvoid add_edge(size_type a,size_type b){\n\t\tassert(built);\n\t\tassert(a < n && b < n);\n\t\ttree[a].emplace_back(b);\n\t\ttree[b].emplace_back(a);\n\t}\n\tsize_type lca(size_type a,size_type b) const{\n\t\tassert(built);\n\t\tassert(a < n && b < n);\n\t\twhile(1){\n\t\t\tif(vid[a] > vid[b]) std::swap(a,b);\n\t\t\tif(hd[a] == hd[b]) return a;\n\t\t\tb = par[hd[b]];\n\t\t}\n\t}\n\tsize_type heavy(size_type a) const{\n\t\tassert(built);\n\t\tassert(a < n);\n\t\tassert(tree[a].back() != par[a]);\n\t\treturn tree[a].back();\n\t}\n\tvoid _fold_vertex(size_type hi,int lo,std::function< void(int,int) > f,\n\t\t\t  bool inclusive) const{\n\t\tassert(built);\n\t\tassert(hi < n && 0 <= lo && lo < (int)n);\n\t\twhile(lo != -1 && dep[lo] >= dep[hi]){\n\t\t\tsize_type nex = max(vid[hd[lo]],vid[hi]);\n\t\t\tf(nex + (nex == vid[hi] && !inclusive),vid[lo] + 1);\n\t\t\tlo = par[hd[lo]];\n\t\t}\n\t}\n\tvoid _fold_edge(size_type hi,int lo,std::function< void(int,int) > f) const{\n\t\tassert(built);\n\t\tassert(hi < n && 0 <= lo && lo < (int)n);\n\t\twhile(lo != -1 && dep[lo] >= dep[hi]){\n\t\t\tsize_type nex = max(vid[hd[lo]],vid[hi]);\n\t\t\tf(nex+!nex,vid[lo]+1);\n\t\t\tlo = par[hd[lo]];\n\t\t}\n\t}\n\tvoid fold_path_vertex(int s,int t,std::function< void(int,int) > f) const{\n\t\tint l=lca(s,t);\n\t\t_fold_vertex(l,s,f,1);\n\t\t_fold_vertex(l,t,f,0);\n\t}\n\tvoid fold_path_edge(int s,int t,std::function< void(int,int) > f) const{\n\t\tint l=lca(s,t);\n\t\t_fold_edge(l,s,f);\n\t\t_fold_edge(l,t,f);\n\t}\n\tvoid fold_subtree_vertex(int i,std::function< void(int,int) > f) const{\n\t\tf(in(i),out(i));\n\t}\n\tvoid fold_subtree_edge(int i,std::function< void(int,int) > f) const{\n\t\tf(in(i)+1,out(i));\n\t}\n\n\tsize_type distance(size_type a,size_type b) const{\n\t\treturn depth(a)+depth(b)-2*depth(lca(a,b));\n\t}\n\tsize_type size() const{ return n; }\n};\n// }}}\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4000331#1 ushi path_edge\n//http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=4000329#1 lazy path_edge\n//https://atcoder.jp/contests/iroha2019-day2/submissions/8541123 beats subtree_vertex,path_vertex\n\nclass Ushi{\npublic:\n\tusing T=lint;\n\tusing func=function<T(T,T)>;\n\n\tint n,sz;\n\tvector<lint> node;\n\n\tfunc f;\n\tT e;\n\n\tUshi(vector<T> v,func f,T e):f(f),e(e){\n\t\tsz=v.size();n=1;\n\t\twhile(n<sz)n<<=1;\n\t\tnode.resize(2*n,e);\n\t\trep(i,sz)node[n+i]=v[i];\n\t\tfor(int i=n-1;i>0;--i)node[i]=f(node[2*i],node[2*i+1]);\n\t}\n\tT* at(int i){ return &node[i+n]; }//use like *tree.at(i)=x,tree.adjust(i);\n\tvoid adjust(int i){\n\t\ti+=n;while(i>>=1)node[i]=f(node[2*i],node[2*i+1]);\n\t}\n\tT fold(int a,int b,int k=1,int l=0,int r=-1){\n\t\tif(r<0)r=n;\n\t\tif(r<=a||b<=l)return e;\n\t\tif(a<=l&&r<=b)return node[k];\n\t\treturn f(fold(a,b,2*k,l,(l+r)/2),fold(a,b,2*k+1,(l+r)/2,r));\n\t}\n};//verified(DSL_2_A,DSL_2_B):http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3604788#1\n\n\n//define pfs,bellmanford,etc.\n\n\nint main(){\n\tlint n;in(n);\n\tUnWeighted g(n);\n\trep(n){\n\t\tlint k,c;in(k);\n\t\trep(j,k)in(c),g[i].pb(c),g[c].pb(i);\n\t}\n\tHLD tree(g,0);\n\ttree.build();\n\tUshi ki(vector<lint>(n),[](lint a,lint b){return a+b;},0);\n\n\tlint q;in(q);\n\twhile(q--){\n\t\tlint ty;in(ty);\n\t\tif(ty){\n\t\t\tlint u;in(u);\n\t\t\tlint ans=0;\n\t\t\ttree.fold_path_edge(0,u,[&](lint a,lint b){\n\t\t\t\tans+=ki.fold(a,b);\n\t\t\t});\n\t\t\tout(ans);\n\t\t} else{\n\t\t\tlint v,w;in(v,w);\n\t\t\t*ki.at(tree.in(v))+=w;ki.adjust(tree.in(v));\n\t\t}\n\t}\n}\n\n//sub-EOF\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <vector>\nusing namespace std;\n#define PB push_back\nconst int N=1e5+10;\nstruct BIT{\n    vector<int> v;\n    void init(int size){\n        v.resize(size,0);\n        return ;\n    }\n    void add(int n,int x){\n        while(n<v.size()){\n            v[n]+=x;\n            n+=n&-n;\n        }\n        return ;\n    }\n    int ask(int n){\n        int ans=0;\n        while(n){\n            ans+=v[n];\n            n^=n&-n;\n        }\n        return ans;\n    }\n};\nvector<int> graph[N];\nint p[N],dep[N],to[N],top[N],size[N],val[N];\nBIT b[N];\nvoid dfs(int now){\n    int temp=0;\n    size[now]=1;\n    val[now]=0;\n    for(int i:graph[now]){\n        dep[i]=dep[now]+1;\n        dfs(i);\n        if(size[i]>temp){\n            temp=size[i];\n            to[now]=i;\n        }\n        size[now]+=size[i];\n    }\n    return ;\n}\nvoid init(int now){\n    if(graph[now].empty())b[top[now]].init(dep[now]-dep[top[now]]+1);\n    for(int i:graph[now]){\n        if(i==to[now])top[i]=top[now];\n        else top[i]=i;\n        init(i);\n    }\n    return ;\n}\nint query(int n){\n    int ans=0;\n    while(n>0){\n        ans+=b[top[n]].ask(dep[n]-dep[top[n]]);\n        ans+=val[n];\n        n=p[top[n]];\n    }\n    return ans;\n}\nint main(){\n    int n,k,temp,q;\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&k);\n        for(int j=0;j<k;j++){\n            scanf(\"%d\",&temp);\n            graph[i].PB(temp);\n            p[temp]=i;\n        }\n    }\n    top[0]=0;\n    p[0]=-1;\n    dep[0]=0;\n    dfs(0);\n    init(0);\n    scanf(\"%d\",&q);\n    while(q--){\n        scanf(\"%d\",&k);\n        if(k==0){\n            scanf(\"%d%d\",&k,&temp);\n            if(k==top[k])val[k]+=temp;\n            else b[top[k]].add(dep[k]-dep[top[k]],temp);\n        }\n        else{\n            scanf(\"%d\",&k);\n            printf(\"%d\\n\",query(k));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nint main() {\n\tios::sync_with_stdio(false);\n\tint n; cin >> n;\n\tvector<vector<int>> g(n);\n\tfor (int i = 0; i < n; i++) {\n\t\tint k, t; cin >> k;\n\t\twhile (k--) cin >> t, g[i].push_back(t);\n\t}\n\tint timer = 1;\n\tvector<int> stTime(n);\n\tvector<int> fiTime(n);\n\tfunction<void(int)> dfs = [&] (int u) {\n\t\tstTime[u] = timer++;\n\t\tfor (int v : g[u]) dfs(v);\n\t\tfiTime[u] = timer;\n\t};\n\tdfs(0);\n\tvector<int> tr(n + 1);\n\tauto update = [&] (int x, int v) {\n\t\tfor (; x <= n; x += x & -x) tr[x] += v;\n\t};\n\tauto query = [&] (int x) {\n\t\tint rt = 0;\n\t\tfor (; x > 0; x -= x & -x) rt += tr[x];\n\t\treturn rt;\t\n\t};\n\tint q; cin >> q;\n\twhile (q--) {\n\t\tint op; cin >> op;\n\t\tif (op == 0) {\n\t\t\tint x, v; cin >> x >> v;\n\t\t\tupdate(stTime[x], v);\n\t\t\tupdate(fiTime[x], -v);\n\t\t} else {\n\t\t\tint x; cin >> x;\n\t\t\tcout << query(stTime[x]) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\nstruct RSQ{\n  ll n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 1 index\n  /*void add(int i,int v){\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }*/\n  // 0 index\n  void add(int i,ll v){\n    i+=1;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  ll sum(int i){\n    ll res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) 1 index\n  /*int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }*/\n  //[a,b) 0 index\n  int sum(int x,int y){\n    x++;y++;\n    return sum(y-1)-sum(x-1);\n  }\n};\n \nstruct HLD {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  RSQ rsq;\n\n  HLD(){}\n  HLD(int sz):n(sz),pos(0),G(n),vid(n,-1),head(n),sub(n,1),hvy(n,-1),par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int i=0;i<rs.size();i++){\n        int r=rs[i];\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    using T = pair<int, int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n        int v=st.top().first;\n        int &i=st.top().second;\n        if(i<(int)G[v].size()){\n            int u=G[v][i++];\n            if(u==par[v]) continue;\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            st.emplace(u,0);\n        }else{\n            st.pop();\n            int res=0;\n            for(int i=0;i<G[v].size();i++){\n                int u=G[v][i];\n                if(u==par[v]) continue;\n                sub[v]+=sub[u];\n                if(res<sub[u]) res=sub[u],hvy[v]=u;\n            }\n        }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n        type[i]=c;\n        vid[i]=k++;\n        inv[vid[i]]=i;\n        head[i]=h;\n        for(int J=0;J<G[i].size();J++){\n            int j=G[i][J];\n            if(j!=par[i]&&j!=hvy[i]) q.push(j);\n        }\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  int for_each(int u, int v) {\n    int ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      //f(max(vid[head[v]],vid[u]),vid[v]);\n      //ans = max(ans,rmq.query(l, r + 1));\n      if(head[u]!=head[v]) v=par[head[v]];\n      else {return ans;}\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  ll for_each_edge(int u, int v) {\n    ll ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n        //f(vid[head[v]],vid[v]);\n        ans += rsq.sum(vid[head[v]],vid[v]+1);\n        v=par[head[v]];\n      } else{\n        //if(u!=v) f(vid[u]+1,vid[v]);\n        if(u!=v) ans += rsq.sum(vid[u]+1,vid[v]+1);\n        return ans;\n      }\n    }\n  }\n\n  void update(int u,int w){\n    rsq.add(vid[u],w);\n  }\n\n  void range_update(){\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\nint main(){\n    int n,m,x,w;\n    scanf(\"%d\",&n);\n    HLD Tree(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&x);\n            Tree.add_edge(i,x);\n        }\n    }\n    Tree.build();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        if(m==0){\n            scanf(\"%d%d\",&x,&w);\n            Tree.update(x,w);\n        }\n        else{\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",Tree.for_each_edge(0,x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n \n// #include <iostream> // cout, endl, cin\n// #include <string> // string, to_string, stoi\n// #include <vector> // vector\n// #include <algorithm> // min, max, swap, sort, reverse, lower_bound, upper_bound\n// #include <utility> // pair, make_pair\n// #include <tuple> // tuple, make_tuple\n// #include <cstdint> // int64_t, int*_t\n// #include <cstdio> // printf\n// #include <map> // map\n// #include <queue> // queue, priority_queue\n// #include <set> // set\n// #include <stack> // stack\n// #include <deque> // deque\n// #include <unordered_map> // unordered_map\n// #include <unordered_set> // unordered_set\n// #include <bitset> // bitset\n// #include <climits>\n// #include <cmath>\n// #include <iomanip>\n// #include <functional>\n// #include <numeric>\n// #include <random>\n \nusing namespace std;\n    \n#define int long long\n#define pb push_back\n#define F first\n#define S second\n#define FOR(i,a,b) for(int (i)=(a);(i)<(b);(i)++)\n#define rep(i,n) FOR(i,0,n)\n#define all(a) (a).begin(),(a).end()\n#define rall(a) (a).rbegin(),(a).rend()\n#define ve vector\n#define vi vector<int>\n#define vp vector<pair<int,int>>\n#define vvi vector<vector<int>>\n \ntemplate<typename T> using pq = priority_queue<T,vector<T>,greater<T>>; \nusing ll = long long;\nll INF = LLONG_MAX / 4000 - 100;\nll mod = 1e9 + 7;\nint dx[] = {-1,0,1,0}, dy[] = {0,1,0,-1};\nvector<ll> prime;\n    \nclass fact {\npublic:\n    int fmod = 1e9+7;\n    vector<int> fac, finv, inv;\n    fact (int n, int Mod = 1e9+7) {\n        fmod = Mod;\n        fac = vector<int>(n + 1, 0);\n        finv = vector<int>(n + 1, 0);\n        inv = vector<int>(n + 1, 0);\n        fac[0] = 1; for (int i = 1; i < n + 1; i++) fac[i] = fac[i-1] * i % fmod;\n        for (int i = 0;i < n + 1;i++) finv[i] = fact::POW(fac[i], fmod-2);\n        for (int i = 0;i < n + 1;i++) inv[i] = POW(i, fmod-2);\n    }\n    ll nCr(ll n, ll r) {if(n < r) return 0; return (fac[n] * finv[r] % fmod) * finv[n-r] % fmod;}\n    ll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%fmod;}a = a * a%fmod; b >>= 1;}return c;}\n    inline int operator [] (int i) {return fac[i];}\n};\n\nvoid DEBUG(vector<int> a) {for(int i=0;i<a.size();i++)cout<<a[i]<<\" \";cout<<endl;}\nvoid EMP(int x) {cout<<\"!!!\"<<x<<\"!!!\"<<endl;}\nll GCD(ll a, ll b) {ll c; while (b != 0) {c = a % b; a = b; b = c;}return a;}\nll LCM(ll a, ll b) {return (a / GCD(a, b)) * (b / GCD(a, b)) * GCD(a, b);}\nll POW(ll a, ll b) {ll c = 1; while (b > 0) {if (b & 1) {c = a * c%mod;}a = a * a%mod; b >>= 1;}return c;}\nvoid PRI(ll n) {bool a[n + 1LL]; for (int i = 0; i < n + 1LL; i++) {a[i] = 1LL;}for (int i = 2; i < n + 1LL; i++) {if (a[i]) {prime.pb(i); ll b = i; while (b <= n) {a[b] = 0; b += i;}}}}\ntemplate <typename T> T chmin(T& a, T b) {if(a>b)a=b;return a;}\ntemplate <typename T> T chmax(T& a, T b) {if(a<b)a=b;return b;}\nbool isSqrt(ll a) {return pow(sqrt(a),2) == a ? 1 : 0;}\nvoid YesNo(bool a) {if (a) cout << \"Yes\"; else cout << \"No\"; cout << endl;}\nvoid yesno(bool a) {if (a) cout << \"yes\"; else cout << \"no\"; cout << endl;}\nvoid YESNO(bool a) {if (a) cout << \"YES\"; else cout << \"NO\"; cout << endl;}\ndouble dis(int x1, int x2, int y1, int y2) {\n    return sqrt((double)abs(x1-x2)*(double)abs(x1-x2)+(double)abs(y1-y2)*(double)abs(y1-y2));\n}\nint ceili(int x, int y) {\n    if (x % y == 0) return x / y;\n    else return x / y + 1;\n}\n \nlong long extGCD(long long a, long long b, long long &x, long long &y) {\n    if (b == 0) {\n        x = 1;\n        y = 0;\n        return a;\n    }\n    long long d = extGCD(b, a % b, y, x);\n    y -= a / b * x;\n    return d;\n}\n\nvector<int> G[100005];\nvector<int> in(100005);\nvector<int> out(100005);\nint dfs(int u, int cnt) {\n    in[u] = cnt++;\n    for (auto&& v : G[u]) cnt = dfs(v, cnt);\n    out[u] = cnt++;\n    return cnt;\n}\n\ntemplate<typename Monoid>\nclass SegTree {\n\n//半開区間!!!!!!!!!!!!!!!\npublic:\n    int p = 2;\n    vector<Monoid> node;\n    using Func = function<Monoid(Monoid,Monoid)>;\n    Func pick; Monoid init;//操作と単位元\n\n    SegTree(vector<Monoid> A, string type, Monoid m) {\n        if (type == \"min\") {\n            pick = [](int a, int b){return min(a,b);};\n        } else if (type == \"max\") {\n            pick = [](int a, int b){return max(a,b);};\n        } else if (type == \"sum\") {\n            pick = [](int a, int b){return a + b;};\n        }\n\n        init = m;\n        while (A.size() > p) p *= 2;\n        node = vector<Monoid>(2*p-1,init);\n\n        for (int i = 0;i < A.size();i++) {\n            node[p-1+i] = A[i];\n        }\n\n        for (int i = p - 2;i >= 0;i--) {\n            node[i] = pick(node[i*2+1],node[i*2+2]);\n        }\n    }\n\n    SegTree(vector<Monoid> A, Func f, Monoid m) {\n        pick = f; init = m;\n        while (A.size() > p) p *= 2;\n        node = vector<Monoid>(2*p-1,init);\n\n        for (int i = 0;i < A.size();i++) {\n            node[p-1+i] = A[i];\n        }\n\n        for (int i = p - 2;i >= 0;i--) {\n            node[i] = pick(node[i*2+1],node[i*2+2]);\n        }\n    }\n\n    //1点更新\n    void update(int i, Monoid v) {\n        for (node[(i+=p)-1] = v; i >>= 1;) {\n            node[i-1] = pick(node[i*2-1], node[i*2]);\n        }\n    }\n\n    //1点加算\n    void add(int i, Monoid v) {\n        update(i, node[i + p - 1] + v);\n    }\n \n    int getval(int start,int end,int k = 0,int l = 0,int r = -1) {\n        if (r < 0) r = p;\n        if (r <= start || end <= l) {return init;}\n        if (start <= l && r <= end) {return node[k];}\n        int L,R;\n        L = getval(start,end,k*2+1,l,(l+r)/2);\n        R = getval(start,end,k*2+2,(l+r)/2,r);\n        return {pick(L,R)};\n    }\n\n    inline Monoid operator [] (int i) {\n        return node[i+p-1];\n    }\n};\n\nvoid solve() {\n    int n; cin >> n;\n    rep (i, n) {\n        int k; cin >> k;\n        rep (j, k) {\n            int c; cin >> c;\n            G[i].push_back(c);\n        }\n    }\n    SegTree<int> seg(vector<int>(dfs(0, 0)), \"sum\", 0);\n    int q; cin >> q;\n    rep (i, q) {\n        int Q; cin >> Q;\n        if (Q == 0) {\n            int v, w; cin >> v >> w;\n            seg.add(in[v], w);\n            seg.add(out[v], -w);\n        } else {\n            int u; cin >> u;\n            cout << seg.getval(0, in[u] + 1) << endl;\n        }\n    }\n}\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    solve();\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define N 100000\n#define N2 262144\n\nint nnum, nnum2, nmaps[N], nmap[N], sib[N], chil[N];\nint wei[N2], lazy[N2];\n\nvoid buildstree(int i) {\n  static int ni = nnum2 - 1;\n  int c = chil[i];\n  nmaps[i] = ni;\n  while (c != -1) {\n    buildstree(c);\n    c = sib[c];\n  }\n  nmap[i] = ni++;\n  return;\n}\n\nvoid updaterange(int s, int t, int i, int l, int r, int x) {\n  if (s <= l && r <= t) {\n    wei[i] += x;\n    return;\n  }\n  if (t <= l || r <= s) return;\n  updaterange(s, t, i * 2 + 1, l, (l + r) / 2, x);\n  updaterange(s, t, i * 2 + 2, (l + r) / 2, r, x);\n}\n\nvoid addWeight(int i, int w) {\n  updaterange(nmaps[i] - nnum2 + 1, nmap[i] - nnum2 + 2, 0, 0, nnum2, w);\n}\nvoid getSum(int i) {\n  int j = i;\n  int val = 0;\n\n  while (j > 0) {\n    if (wei[j] != 0) val += wei[j];\n    j = (j - 1) / 2;\n  }\n  cout << val << endl;\n}\n\nint main() {\n  int k, c, qnum, x, y, z, last;\n\n  cin >> nnum;\n  nnum2 = 1;\n  while (nnum > nnum2) nnum2 *= 2;\n  for (int i = 0; i < nnum2 * 2; i++) {\n    wei[i] = lazy[i] = 0;\n  }\n  for (int i = 0; i < nnum; i++) {\n    last = -1;\n    cin >> k;\n    for (int j = 0; j < k; j++) {\n      cin >> c;\n      sib[c] = last;\n      last = c;\n    }\n    chil[i] = last;\n  }\n\n  buildstree(0);\n\n  cin >> qnum;\n  for (int i = 0; i < qnum; i++) {\n    cin >> x >> y;\n    if (x == 0) {\n      cin >> z;\n      addWeight(y, z);\n    } else {\n      getSum(nmap[y]);\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstruct RSQ{\n  ll n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 1 index\n  /*void add(int i,int v){\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }*/\n  // 0 index\n  void add(int i,ll v){\n    i+=1;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  ll sum(int i){\n    ll res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) 1 index\n  /*int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }*/\n  //[a,b) 0 index\n  int sum(int x,int y){\n    x++;y++;\n    return sum(y-1)-sum(x-1);\n  }\n};\n \nstruct HLD {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  RSQ rsq;\n\n  HLD(){}\n  HLD(int sz):n(sz),pos(0),G(n),vid(n,-1),head(n),sub(n,1),hvy(n,-1),par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build() {\n    dfs(0);\n    bfs(0, 0);\n  }\n\n  void build_2(vector<int> rs) {\n    if(rs.size()==0)rs.push_back(0);\n    int c=0;\n    for(int i=0;i<rs.size();i++){\n        int r=rs[i];\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    stack<P> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.push(P(rt,0));\n    while(!st.empty()){\n        int v=st.top().first;\n        int &i=st.top().second;\n        if(i<(int)G[v].size()){\n            int u=G[v][i++];\n            if(u==par[v]) continue;\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            st.push(P(u,0));\n        }else{\n            st.pop();\n            int res=0;\n            for(int i=0;i<G[v].size();i++){\n                int u=G[v][i];\n                if(u==par[v]) continue;\n                sub[v]+=sub[u];\n                if(res<sub[u]) res=sub[u],hvy[v]=u;\n            }\n        }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q;\n    q.push(0);\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n        type[i]=c;\n        vid[i]=k++;\n        inv[vid[i]]=i;\n        head[i]=h;\n        for(int J=0;J<G[i].size();J++){\n            int j=G[i][J];\n            if(j!=par[i]&&j!=hvy[i]) q.push(j);\n        }\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  int for_each(int u, int v) {\n    int ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      //f(max(vid[head[v]],vid[u]),vid[v]);\n      //ans = max(ans,rmq.query(l, r + 1));\n      if(head[u]!=head[v]) v=par[head[v]];\n      else {return ans;}\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  ll for_each_edge(int u, int v) {\n    ll ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n        //f(vid[head[v]],vid[v]);\n        ans += rsq.sum(vid[head[v]],vid[v]+1);\n        v=par[head[v]];\n      } else{\n        //if(u!=v) f(vid[u]+1,vid[v]);\n        if(u!=v) ans += rsq.sum(vid[u]+1,vid[v]+1);\n        return ans;\n      }\n    }\n  }\n\n  void update(int u,int w){\n    rsq.add(vid[u],w);\n  }\n\n  void range_update(){\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\nint main(){\n    int n,m,x,w;\n    scanf(\"%d\",&n);\n    HLD Tree(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&x);\n            Tree.add_edge(i,x);\n        }\n    }\n    Tree.build();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        if(m==0){\n            scanf(\"%d%d\",&x,&w);\n            Tree.update(x,w);\n        }\n        else{\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",Tree.for_each_edge(0,x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\ntemplate< typename T >\nstruct edge {\n  int src, to;\n  T cost;\n\n  edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n\n  edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n\n  operator int() const { return to; }\n};\n\ntemplate< typename T >\nusing Edges = vector< edge< T > >;\ntemplate< typename T >\nusing WeightedGraph = vector< Edges< T > >;\nusing UnWeightedGraph = vector< vector< int > >;\ntemplate< typename T >\nusing Matrix = vector< vector< T > >;\n\ntemplate< typename G >\nstruct CentroidPathDecomposition {\n  struct Centroid {\n    int ParIndex, ParDepth, Deep;\n    vector< int > node;\n\n    Centroid(int idx, int dep, int deep) : ParIndex(idx), ParDepth(dep), Deep(deep) {}\n\n    inline size_t size() {\n      return (node.size());\n    }\n\n    inline int &operator[](int k) {\n      return (node[k]);\n    }\n\n    inline pair< int, int > Up() {\n      return (make_pair(ParIndex, ParDepth));\n    }\n  };\n\n  const G &graph;\n  vector< int > SubTreeSize, NextPath;\n  vector< int > TreeIndex, TreeDepth;\n  vector< Centroid > Centroids;\n\n  void BuildSubTreeSize() {\n    stack< pair< int, int > > s;\n    s.emplace(0, -1);\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      if(~SubTreeSize[p.first]) {\n        NextPath[p.first] = -1;\n        for(auto &to : graph[p.first]) {\n          if(p.second == to) continue;\n          SubTreeSize[p.first] += SubTreeSize[to];\n          if(NextPath[p.first] == -1 || SubTreeSize[NextPath[p.first]] < SubTreeSize[to]) {\n            NextPath[p.first] = to;\n          }\n        }\n      } else {\n        s.push(p);\n        SubTreeSize[p.first] = 1;\n        for(auto &to : graph[p.first]) {\n          if(p.second != to) s.emplace(to, p.first);\n        }\n      }\n    }\n  }\n\n  void BuildPath() {\n    stack< pair< int, int > > s;\n    Centroids.emplace_back(-1, -1, 0);\n    s.emplace(0, -1);\n    TreeIndex[0] = 0;\n    while(!s.empty()) {\n      auto p = s.top();\n      s.pop();\n      TreeDepth[p.first] = (int) Centroids[TreeIndex[p.first]].size();\n      for(auto &to : graph[p.first]) {\n        if(p.second == to) continue;\n        if(to == NextPath[p.first]) { // Centroid-Path\n          TreeIndex[to] = TreeIndex[p.first];\n        } else {                  // Not Centroid-Path\n          TreeIndex[to] = (int) Centroids.size();\n          Centroids.emplace_back(TreeIndex[p.first], TreeDepth[p.first], Centroids[TreeIndex[p.first]].Deep + 1);\n        }\n        s.emplace(to, p.first);\n      }\n      Centroids[TreeIndex[p.first]].node.emplace_back(p.first);\n    }\n  }\n\n\n  virtual void Build() {\n    BuildSubTreeSize();\n    BuildPath();\n  }\n\n  inline size_t size() {\n    return (Centroids.size());\n  }\n\n  inline pair< int, int > Information(int idx) {\n    return (make_pair(TreeIndex[idx], TreeDepth[idx]));\n  }\n\n  inline Centroid &operator[](int k) {\n    return (Centroids[k]);\n  }\n\n  inline int LCA(int a, int b) {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    return (Centroids[TreeIdxA][TreeDepthA]);\n  }\n\n  inline virtual void query(int a, int b, const function< void(int, int, int) > &f) {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = Information(a);\n    tie(TreeIdxB, TreeDepthB) = Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(Centroids[TreeIdxA].Deep > Centroids[TreeIdxB].Deep) {\n        f(TreeIdxA, 0, TreeDepthA + 1);\n        tie(TreeIdxA, TreeDepthA) = Centroids[TreeIdxA].Up();\n      } else {\n        f(TreeIdxB, 0, TreeDepthB + 1);\n        tie(TreeIdxB, TreeDepthB) = Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    f(TreeIdxA, TreeDepthA, TreeDepthB + 1);\n  }\n\n  CentroidPathDecomposition(const G &g) : graph(g) {\n    int SZ = g.size();\n    SubTreeSize.assign(SZ, -1);\n    NextPath.resize(SZ);\n    TreeIndex.resize(SZ);\n    TreeDepth.resize(SZ);\n  }\n};\n\ntemplate< typename G >\nstruct TreeArray : CentroidPathDecomposition< G > {\n  using CPD = CentroidPathDecomposition< G >;\n\n  TreeArray(const G &g) : CPD(g) {}\n\n  vector< int > index;\n\n  void Build() {\n    CPD::Build();\n    int ptr = 0;\n    for(auto &centroid : CPD::Centroids) {\n      index.emplace_back(ptr);\n      ptr += centroid.size();\n    }\n  }\n\n  inline int get(int a) {\n    auto p = CPD::Information(a);\n    return (index[p.first] + p.second);\n  }\n\n  inline void query(int a, int b, const function< void(int, int) > &f) {\n    int TreeIdxA, TreeDepthA, TreeIdxB, TreeDepthB;\n    tie(TreeIdxA, TreeDepthA) = CPD::Information(a);\n    tie(TreeIdxB, TreeDepthB) = CPD::Information(b);\n    while(TreeIdxA != TreeIdxB) {\n      if(CPD::Centroids[TreeIdxA].Deep > CPD::Centroids[TreeIdxB].Deep) {\n        f(index[TreeIdxA], index[TreeIdxA] + TreeDepthA);\n        tie(TreeIdxA, TreeDepthA) = CPD::Centroids[TreeIdxA].Up();\n      } else {\n        f(index[TreeIdxB], index[TreeIdxB] + TreeDepthB);\n        tie(TreeIdxB, TreeDepthB) = CPD::Centroids[TreeIdxB].Up();\n      }\n    }\n    if(TreeDepthA > TreeDepthB) swap(TreeDepthA, TreeDepthB);\n    f(index[TreeIdxA] + TreeDepthA, index[TreeIdxA] + TreeDepthB);\n  }\n};\n\ntemplate< class T >\nstruct BinaryIndexedTree {\n  vector< T > data;\n\n  BinaryIndexedTree(int sz) {\n    data.assign(++sz, 0);\n  }\n\n  T sum(int k) {\n    T ret = 0;\n    for(++k; k > 0; k -= k & -k) ret += data[k];\n    return (ret);\n  }\n\n  void add(int k, T x) {\n    for(++k; k < data.size(); k += k & -k) data[k] += x;\n  }\n};\n\nint main() {\n  int N, Q;\n  scanf(\"%d\", &N);\n  UnWeightedGraph g(N);\n  for(int i = 0; i < N; i++) {\n    int k;\n    scanf(\"%d\", &k);\n    for(int j = 0; j < k; j++) {\n      int x;\n      scanf(\"%d\", &x);\n      g[i].emplace_back(x);\n    }\n  }\n  TreeArray< UnWeightedGraph > tree(g);\n  tree.Build();\n  scanf(\"%d\", &Q);\n  BinaryIndexedTree< int > bit(N);\n  while(Q--) {\n    int T;\n    scanf(\"%d\", &T);\n    if(T == 0) {\n      int V, W;\n      scanf(\"%d %d\", &V, &W);\n      bit.add(V, W);\n    } else {\n      int U;\n      scanf(\"%d\", &U);\n      int ret = 0;\n      tree.query(0, U, [&](int x, int y) {\n        ret += bit.sum(y) - bit.sum(x - 1);\n      });\n      printf(\"%d\\n\", ret);\n    }\n  }\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//INSERT ABOVE HERE\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n  struct Node{\n    Node *l,*r,*p;\n    size_t cnt;\n    int idx;\n    bool rev;\n    T val,dat;\n    E laz;\n    Node():cnt(0){}\n    Node(int idx,T val):\n      cnt(1),idx(idx),rev(0),val(val),dat(dat),laz(laz){l=r=p=nullptr;}\n    bool is_root(){\n      return !p||(p->l!=this&&p->r!=this);\n    }\n  };\n  \n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  F f;\n  G g;\n  H h;\n  T ti;\n  E ei;\n  P p;\n  \n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n  \n  LinkCutTree(F f,G g,H h,P p,T ti,E ei):\n    f(f),g(g),h(h),p(p),ti(ti),ei(ei),pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(int idx,T v){\n    return &(pool[ptr++]=Node(idx,v));\n  }\n\n  void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,t->laz);\n    t->dat=g(t->dat,p(t->laz,t->cnt));\n  }\n\n  void toggle(Node *t){\n    swap(t->l,t->r);\n    t->rev^=1;\n  }\n\n  void eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n  }\n\n  void update(Node *t){\n    t->cnt=1;\n    t->dat=t->val;\n    if(t->l) t->cnt+=t->l->cnt,t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->cnt+=t->r->cnt,t->dat=f(t->dat,t->r->dat);\n  }\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n  \n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t){\n    while(!t->is_root()){\n      Node *q=t->p;\n      if(q->is_root()){\n\tif(q->l==t) rotR(t);\n\telse rotL(t);\n      }else{\n\tauto *r=q->p;\n\tif(r->l==q){\n\t  if(q->l==t) rotR(q),rotR(t);\n\t  else rotL(t),rotR(t);\n\t}else{\t\n\t  if(q->r==t) rotL(q),rotL(t);\n\t  else rotR(t),rotL(t);\n\t}\n      }\n    }\n  }\n\n  Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      update(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(par);\n    expose(c);\n    par->r=c;\n    c->p=par;\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n  \n};\n\nsigned GRL_5_C(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return min(a,b);};\n  LCT::P p=[](int a,size_t b){b++;return a;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int a,b;\n    cin>>a>>b;\n    cout<<lc.lca(v[a],v[b])->idx<<endl;\n  }\n  \n  return 0;\n}\n\nsigned GRL_5_D(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return a+b;};\n  LCT::P p=[](int a,size_t b){b++;return a;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.expose(v[a]);\n      v[a]->val=f(v[a]->val,b);\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat<<endl;\n    }\n  }\n  \n  return 0;\n}\n\nsigned main(){\n  //GRL_5_C();\n  GRL_5_D();\n  //GRL_5_E();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n\ntemplate <class Cost = int>\nstruct Edge {\n    int from, to;\n    Cost cost;\n    Edge(int from, int to, Cost cost = 1)\n        : from(from), to(to), cost(cost){};\n\n    bool operator<(const Edge<Cost>& e) const { return this->cost < e.cost; }\n    bool operator>(const Edge<Cost>& e) const { return this->cost > e.cost; }\n};\n\ntemplate <class Cost = int>\nusing Edges = std::vector<Edge<Cost>>;\n\ntemplate <class Cost = int>\nclass Graph {\npublic:\n    int size;\n    std::vector<std::vector<Edge<Cost>>> path;\n\n    explicit Graph(int N = 0) : size(N), path(size) {}\n    void span(int u, int v, Cost cost = 1) {\n        path[u].push_back(Edge<Cost>(u, v, cost));\n    }\n    std::vector<Edge<Cost>> operator[](int v) const { return path[v]; }\n};\n\ntemplate <class Data, class Operator>\nclass BinaryIndexedTree {\n    using DataMerger = std::function<Data(Data, Data)>;   // データをマージする関数\n    using Applier = std::function<Data(Data, Operator)>;  // 作用素をデータに作用させる関数\n\nprivate:\n    int length;\n    std::vector<Data> data;\n    Data id;\n    DataMerger dmerge;\n    Applier app;\n\npublic:\n    explicit BinaryIndexedTree(int length, Data id, DataMerger dmerge, Applier app)\n        : length(length), id(id), dmerge(dmerge), app(app) {\n        data.assign(length + 1, id);\n    }\n\n    // half-open interval [l, r)\n    Data query(int l, int r) const { return query(r - 1) - query(l - 1); }\n\n    // closed interval [0, idx]\n    Data query(int idx) const {\n        ++idx;\n        Data sum = id;\n        while (idx > 0) {\n            sum = dmerge(sum, data[idx]);\n            idx -= (idx & -idx);\n        }\n        return sum;\n    }\n\n    void update(int idx, Operator e) {\n        ++idx;\n        while (idx <= length) {\n            data[idx] = app(data[idx], e);\n            idx += (idx & -idx);\n        }\n    }\n};\n\nint main() {\n    std::cin.tie(nullptr);\n    std::ios::sync_with_stdio(false);\n\n    int N;\n    std::cin >> N;\n    Graph<> graph(N);\n    for (int v = 0; v < N; ++v) {\n        int k;\n        std::cin >> k;\n        for (int i = 0; i < k; ++i) {\n            int c;\n            std::cin >> c;\n            graph.span(v, c);\n        }\n    }\n\n    std::vector<int> order;    // 行きがけ順\n    std::vector<int> size(N);  // 部分木の大きさ\n    std::function<int(int)> dfs = [&](int v) {\n        order.push_back(v);\n        size[v] = 1;\n        for (auto e : graph[v]) size[v] += dfs(e.to);\n        return size[v];\n    };\n    dfs(0);\n\n    std::vector<int> rev(N);\n    for (int i = 0; i < N; ++i) rev[order[i]] = i;\n\n    BinaryIndexedTree<int, int> bit(N, 0,\n                                    [](int a, int b) { return a + b; },\n                                    [](int a, int b) { return a + b; });\n\n    int Q;\n    std::cin >> Q;\n    for (int q = 0; q < Q; ++q) {\n        int t;\n        std::cin >> t;\n        if (t == 0) {\n            int v, w;\n            std::cin >> v >> w;\n            bit.update(rev[v], w);\n            bit.update(rev[v] + size[v], -w);\n        } else {\n            int v;\n            std::cin >> v;\n            std::cout << bit.query(rev[v]) << '\\n';\n        }\n    }\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\ntemplate<typename T,typename U> using P = pair<T,U>;\ntemplate<class T> using vec = vector<T>;\ntemplate<class T> using vvec = vector<vec<T>>;\n\nstruct edge{\n    int to,id;\n    ll dist;\n    edge(int to,ll dist=1,int id=1):to(to),id(id),dist(dist){};\n};\n\ntemplate<typename Monoid,typename F>\nclass SegmentTree{\nprivate:\n    int sz;\n    vector<Monoid> seg;\n    const F op;//演算\n    const Monoid e;//単位元\npublic:\n    SegmentTree(int n,const F op,const Monoid &e):op(op),e(e){\n        sz = 1;\n        while(sz<=n) sz <<= 1;\n        seg.assign(2*sz,e);\n    }\n    //代入\n    void set(int k, const Monoid &x){\n        seg[k+sz] = x;\n    }\n    //前計算(?)\n    void build(){\n        for(int i=sz-1;i>0;i--){\n            seg[i] = op(seg[2*i],seg[2*i+1]);\n        }\n    }\n    void update(int k,const Monoid &x){\n        k += sz;\n        seg[k] += x;\n        while(k>>=1){\n            seg[k] = op(seg[2*k],seg[2*k+1]);\n        }\n    }\n    Monoid query(int l,int r){\n        Monoid L = e,R = e;\n        for(l+=sz,r+=sz;l<r;l>>=1,r>>=1){\n            if(l&1) L = op(L,seg[l++]);\n            if(r&1) R = op(seg[--r],R);\n        }\n        return op(L,R);\n    }\n    Monoid operator[](const int &k)const{\n        return seg[k+sz];\n    }\n};\n\nclass EulerTourForEdge{\nprivate:\n    vec<int> down,up,dep,btm;\n    vvec<edge> g;\n    void dfs(int cur,int par,int d){\n        dep[cur] = d;\n        for(auto& e:g[cur]) if(e.to!=par){\n            down[e.to] = btm.size();\n            btm.push_back(e.to);\n            dfs(e.to,cur,d+1);\n            up[e.to] = btm.size();\n            btm.push_back(e.to);\n        }\n    }\n\npublic:\n    EulerTourForEdge(){}\n    EulerTourForEdge(int N,int root,vvec<edge> g):down(N),up(N),dep(N),g(g){\n        btm.clear();\n        down[root] = btm.size();\n        btm.push_back(root);\n        dfs(root,-1,0);\n        up[root] = btm.size();\n        btm.push_back(root);\n    }\n\n    int child(int u,int v){return dep[u]<dep[v]? v:u;}\n\n    int bottom(int e){return btm[e];}\n\n    template<class T,class G>\n    void update(int u,T x,G g){\n        g(down[u],x);\n        g(up[u],-x);//inverse\n    }\n\n    template<class F>\n    //u-v path s.t. lca(u,v) = u or v\n    void query(int u,int v,F f){\n        if(dep[u]>dep[v]) swap(u,v);\n        f(down[u]+1,down[v]);\n    }\n};\n\nint main(){\n    int N;\n    cin >> N;\n    vvec<edge> tree(N);\n    for(int i=0;i<N;i++){\n        int k;\n        cin >> k;\n        for(int j=0;j<k;j++){\n            int c;\n            cin >> c;\n            tree[i].push_back(c);\n        }\n    }\n\n    EulerTourForEdge et(N,0,tree);\n    auto add = [](ll a,ll b){return a+b;};\n    SegmentTree<ll,decltype(add)> seg(2*N,add,0);\n    int Q;\n    cin >> Q;\n\n    auto g = [&](int i,ll x){seg.update(i,x);};\n    auto f = [&](int l,int r){cout << seg.query(l,r+1) << \"\\n\";};\n    for(int i=0;i<Q;i++){\n        int t;\n        cin >> t;\n        if(t==0){\n            int v; ll w;\n            cin >> v >> w;\n            et.update(v,w,g);\n        }else{\n            int v;\n            cin >> v;\n            et.query(0,v,f);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <functional>\n#include <bitset>\n\nusing namespace std;\nusing lint = long long int;\nlong long int INF = 1001001001001001LL;\nint inf = 1000000007;\nlong long int MOD = 1000000007LL;\ndouble PI = 3.1415926535897932;\n\ntemplate<typename T1,typename T2>inline void chmin(T1 &a,const T2 &b){if(a>b) a=b;}\ntemplate<typename T1,typename T2>inline void chmax(T1 &a,const T2 &b){if(a<b) a=b;}\n\n#define ALL(a) a.begin(),a.end()\n#define RALL(a) a.rbegin(),a.rend()\n\n/* do your best */\n\n// quoted from beet-aizu\ntemplate <typename T, typename E, typename F, typename G>\nstruct SegmentTree{\n    // using F = function<T(T, T)>\n    // using G = function<T(T, E)>\n    int n;\n    F f;\n    G g;\n    T ti;\n    vector<T> dat;\n    SegmentTree(){};\n    SegmentTree(F f,G g,T ti):f(f),g(g),ti(ti){}\n    void init(int n_){    \n        n=1;\n        while(n<n_) n<<=1;\n        dat.assign(n<<1,ti);\n    }\n    void build(const vector<T> &v){\n        int n_=v.size();\n        init(n_);\n        for(int i=0;i<n_;i++) dat[n+i]=v[i];\n        for(int i=n-1;i;i--)\n            dat[i]=f(dat[(i<<1)|0],dat[(i<<1)|1]);\n    }\n    void update(int k,const E &x){\n        k += n;\n        dat[k] = g(dat[k], x);\n        while(k>>=1)\n            dat[k]=f(dat[(k<<1)|0],dat[(k<<1)|1]);    \n    }\n    T operator [](int k) const { return dat[k+n]; }\n    T query(int a,int b) const {\n        T vl=ti,vr=ti;\n        for(int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n            if(l&1) vl=f(vl,dat[l++]);\n            if(r&1) vr=f(dat[--r],vr);\n        }\n        return f(vl,vr);\n    }\n\n    /* TODO わからない 聞く \n    template<typename C>\n    int find(int a,int b,C &check,int k,int l,int r){\n        if(!check(dat[k])||r<=a||b<=l) return -1;\n        if(k>=n) return k-n;\n        int m=(l+r)>>1;\n        int vl=find(a,b,check,(k<<1)|0,l,m);\n        if(~vl) return vl;\n        return find(a,b,check,(k<<1)|1,m,r);\n    }\n    template<typename C>\n    int find(int a,int b,C &check){\n        return find(a,b,check,1,0,n);\n    }*/\n    \n};\n\n\n/**  テンプレ\nint main(){\n}\n**/\n\nvoid dfs(int cur, int par, vector<vector<int>> &g, vector<lint> &tour, vector<int> &fst, vector<int> &lst) {\n  int id = tour.size();\n  fst[cur] = id;\n  tour.push_back(0);\n  for (auto nxt : g[cur]) {\n    if (nxt == par) continue;\n    dfs(nxt, cur, g, tour, fst, lst);\n  }\n  id = tour.size();\n  lst[cur] = id;\n  tour.push_back(0);\n}\n\nint main() {\n  \n  int n; cin >> n;\n  vector<vector<int>> graph(n);\n  for (int i = 0; i < n; i++) {\n    int k; cin >> k;\n    for (int j = 0; j < k; j++) {\n      int to; cin >> to;\n      graph[i].push_back(to);\n      graph[to].push_back(i);\n    }\n  }\n\n  vector<lint> tour;\n  vector<int> fst(n);\n  vector<int> lst(n);\n  dfs(0, -1, graph, tour, fst, lst);\n  using T = lint;  // type T\n  using E = lint;  // type E\n  auto f = [](T a, T b){ // return type T value\n    return a + b;\n  };\n  auto g = [](T a, E b){ // return type T value\n    return a + b;  // return b;\n  };\n  T ti = 0;  // identity element\n  SegmentTree<T, E, decltype(f), decltype(g)> sg(f, g, ti);  // don't change\n  sg.build(tour);\n  int q; cin >> q;\n  for (int i = 0; i < q; i++) {\n    int op; cin >> op;\n    if (op == 0) {\n      lint v, w; cin >> v >> w;\n      sg.update(fst[v] - 1, w);\n      sg.update(lst[v], -w);\n    } else {\n      int u; cin >> u;\n      cout << sg.query(0, fst[u]) << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// includes\n#include <bits/stdc++.h>\nusing namespace std;\n\n// macros\n#define pb emplace_back\n#define mk make_pair\n#define FOR(i, a, b) for(int i=(a);i<(b);++i)\n#define rep(i, n) FOR(i, 0, n)\n#define rrep(i, n) for(int i=((int)(n)-1);i>=0;i--)\n#define irep(itr, st) for(auto itr = (st).begin(); itr != (st).end(); ++itr)\n#define irrep(itr, st) for(auto itr = (st).rbegin(); itr != (st).rend(); ++itr)\n#define all(x) (x).begin(),(x).end()\n#define sz(x) ((int)(x).size())\n#define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end())\n#define bit(n) (1LL<<(n))\n// functions\ntemplate <class T>bool chmax(T &a, const T &b){if(a < b){a = b; return 1;} return 0;}\ntemplate <class T>bool chmin(T &a, const T &b){if(a > b){a = b; return 1;} return 0;}\ntemplate <typename T> istream &operator>>(istream &is, vector<T> &vec){for(auto &v: vec)is >> v; return is;}\ntemplate <typename T> ostream &operator<<(ostream &os, const vector<T>& vec){for(int i = 0; i < vec.size(); i++){ os << vec[i]; if(i + 1 != vec.size())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_set<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T> ostream &operator<<(ostream &os, const unordered_multiset<T>& st){for(auto itr = st.begin(); itr != st.end(); ++itr){ os << *itr; auto titr = itr; if(++titr != st.end())os << \" \";} return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const pair<T1, T2> &p){os << p.first << \" \" << p.second; return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\ntemplate <typename T1, typename T2> ostream &operator<<(ostream &os, const unordered_map<T1, T2> &mp){for(auto itr = mp.begin(); itr != mp.end(); ++itr){ os << itr->first << \":\" << itr->second; auto titr = itr; if(++titr != mp.end())os << \" \"; } return os;}\n//  types\nusing ll = long long int;\nusing P = pair<int, int>;\n// constants\nconst int inf = 1e9;\nconst ll linf = 1LL << 50;\nconst double EPS = 1e-10;\nconst int mod = 1000000007;\nconst int dx[4] = {-1, 0, 1, 0};\nconst int dy[4] = {0, -1, 0, 1};\n// io\nstruct fast_io{\n  fast_io(){ios_base::sync_with_stdio(false); cin.tie(0); cout << fixed << setprecision(20);}\n} fast_io_;\n\ntemplate<typename T, typename E>\nstruct SegmentTree_ {\n  function<T(T, T)> f; // aggregate function\n  function<T(T, E)> g; // update function\n  int n;\n  T def;\n  vector<T> vec;\n  SegmentTree_(){}\n  SegmentTree_(int n_, function<T(T, T)> f, function<T(T, E)> g, T def, vector<T> v=vector<T>()): f(f), g(g), def(def){\n\n    // initialize vector\n    n = 1;\n    while(n < n_){\n      n *= 2;\n    }\n    vec = vector<T>(2*n -1, def);\n\n    // initialize segment tree\n    for(int i = 0; i < v.size(); i++){\n      vec[i + n - 1] = v[i];\n    }\n    for(int i = n - 2; i >= 0; i--){\n      vec[i] = f(vec[2*i+1], vec[2*i+2]);\n    }\n  }\n  void update(int k, const E &val){\n    k = k + n - 1;\n    vec[k] = g(vec[k], val);\n    while(k > 0){\n      k = (k - 1) / 2;\n      vec[k] = f(vec[2*k+1], vec[2*k+2]);\n    }\n  }\n  // [l, r) -> [a, b) (at k)\n  T query(int a, int b, int k, int l, int r){\n    if(r <= a || b <= l)return def;\n    if(a <= l && r <= b)return vec[k];\n    T ld = query(a, b, 2*k+1, l, (l+r)/2);\n    T rd = query(a, b, 2*k+2, (l+r)/2, r);\n    return f(ld, rd);\n  }\n  T query(int a, int b){\n    return query(a, b, 0, 0, n);\n  }\n};\n\ntemplate<typename T, typename E>\nusing SegmentTree = struct SegmentTree_<T, E>;\nusing SegmentTreeI = SegmentTree<int, int>;\nusing SegmentTreeL = SegmentTree<long long, long long>;\n\n\ntemplate <typename T>\nstruct HeavyLightDecomposition{\n  struct edge{\n    int to;\n    T w;\n    edge(int to, T w): to(to), w(w){}\n  };\n  int n, cid;\n  vector<vector<edge>> edges;\n  vector<int> par, chain, depth, siz, pos_seg, head;\n  vector<T> parw;\n  HeavyLightDecomposition(){}\n  explicit HeavyLightDecomposition(int n): n(n){\n    edges.resize(n);\n    par.resize(n, -1);\n    chain.resize(n, -1);\n    depth.resize(n, -1);\n    siz.resize(n, 1);\n    pos_seg.resize(n, -1);\n    head.resize(n, -1);\n    parw.resize(n);\n  }\n  void adde(int from, int to, T w){\n    edges[from].emplace_back(to, w);\n  }\n  void build(int r = 0){\n    par.assign(n, -1);\n    chain.assign(n, -1);\n    depth.assign(n, -1);\n    siz.assign(n, -1);\n    pos_seg.assign(n, -1);\n\n    dfs(r);\n\n    hld(r);\n  }\n  void dfs(int r = 0){\n    par[r] = r;\n    depth[r] = 0;\n    deque<int> dq;\n    dq.push_back(r);\n\n    int l = 0;\n    while(l < (int)dq.size()){\n      int i = dq[l];\n      siz[i] = 1;\n      for(auto &e: edges[i]){\n        if(par[e.to] != -1)continue;\n        par[e.to] = i;\n        parw[e.to] = e.w;\n        depth[e.to] = depth[i] + 1;\n        dq.push_back(e.to);\n      }\n      l++;\n    }\n    while(!dq.empty()){\n      int i = dq.back(); dq.pop_back();\n      if(par[i] != i){\n        siz[par[i]] += siz[i];\n      }\n    }\n  }\n  void hld(int r = 0){\n    cid = 0;\n    chain[r] = cid;\n    pos_seg[r] = 0;\n    head[r] = r;\n\n    stack<int> st;\n    st.push(r);\n\n    while(!st.empty()){\n      int i = st.top(); st.pop();\n      int max_siz = 0;\n      int idx = -1;\n      for(auto &e: edges[i]){\n        if(par[e.to] != i)continue;\n        if(max_siz < siz[e.to]){\n          max_siz = siz[e.to];\n          idx = e.to;\n        }\n      }\n      if(idx == -1)continue;\n      for(auto &e: edges[i]){\n        if(par[e.to] != i)continue;\n        if(idx == e.to){\n          chain[e.to] = chain[i];\n          pos_seg[e.to] = pos_seg[i] + 1;\n          head[e.to] = head[i];\n          st.push(e.to);\n        }else{\n          chain[e.to] = ++cid;\n          pos_seg[e.to] = 0;\n          head[e.to] = e.to;\n          st.push(e.to);\n        }\n      }\n    }\n  }\n  int lca(int u, int v){\n    while(true){\n      if(chain[u] == chain[v]){\n        if(depth[u] < depth[v])return u;\n        else return v;\n      }\n      if(depth[head[u]] > depth[head[v]])swap(u, v);\n      v = par[head[v]];\n    }\n  }\n};\n\n\nint main(int argc, char const* argv[])\n{\n  int n; cin >> n;\n  HeavyLightDecomposition<ll> hld(n);\n  rep(i, n){\n    int k; cin >> k;\n    rep(j, k){\n      int u; cin >> u;\n      hld.adde(i, u, 0);\n    }\n  }\n  hld.build();\n\n  SegmentTreeL seg = SegmentTreeL(n, [](ll a, ll b){return a + b;},\n                                  [](ll a,ll b){return a + b;}, 0, vector<ll>());\n\n  vector<int> cnt(n, 0), acc(n, 0);\n  rep(i, n)cnt[hld.head[i]]++;\n  rep(i, n){\n    acc[i] = (i > 0 ? acc[i-1] + cnt[i-1]: 0);\n  }\n\n  int q; cin >> q;\n  rep(i_, q){\n    int c; cin >> c;\n    if(c == 0){\n      int v;\n      ll w;\n      cin >> v >> w;\n      if(hld.chain[v] != hld.chain[hld.par[v]]){\n        hld.parw[v] += w;\n      }else{\n        int l = acc[hld.head[v]];\n        seg.update(l + hld.pos_seg[v] - 1, w);\n      }\n    }else{\n      int u; cin >> u;\n      ll res = 0;\n      while(true){\n        if(hld.chain[u] == hld.chain[0]){\n          res += seg.query(0, hld.pos_seg[u]);\n          break;\n        }\n        res += seg.query(acc[hld.head[u]], acc[hld.head[u]] + hld.pos_seg[u]);\n        res += hld.parw[hld.head[u]];\n        u = hld.par[hld.head[u]];\n      }\n      cout << res << endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RSAQ{\npublic:\n  typedef long long ll;\n  ll n;\n  vector<ll> dat,td;\n  \n  RSAQ(){n = -1;}\n  RSAQ(int n_){\n    n=1;\n    while(n<n_)n*=2; //要素数nを2のべき乗に\n    dat.resize(2*n-1,0),td.resize(2*n-1,0);\n  }\n  \n  //[a,b)の区間にxを加算する,query(a,b,x);\n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n\n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  //[a,b)の総和を得る\n  ll sum(int a,int b){return add(a,b,0);}\n};\n\n\nclass EulerTour{\npublic:\n  int V;                     //ノード数\n  int root;                  //根の頂点番号\n  vector<vector<int> > G;    //Grapth\n  vector<int> L,R;           //[L,R]\n  bool ok;\n  EulerTour():V(-1),ok(0){};\n  EulerTour(int V,int root = 0):V(V),root(root),G(V),L(V),R(V),ok(0){}\n\n  void add_edge(int a,int b){\n    assert(a >= 0 && b >= 0);\n    assert(a < V && b < V);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  void build(){\n    ok = 1;\n    int cnt = 0;\n    function<void(int,int)> dfs = [&](int pos,int pre){\n      L[pos] = cnt;\n      for(int to:G[pos]) if(to != pre) cnt++, dfs(to, pos);\n      R[pos] = cnt;\n    };\n    dfs(root,-1);\n  }\n\n  \n  typedef pair<int,int> P;\n  P get(int v){assert(ok && v < V); return P(L[v],R[v]);} //[l, r]\n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n\n  EulerTour ET(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++) {\n      int c;\n      cin>>c;\n      ET.add_edge(i,c);\n    }\n  }\n\n  \n\n  ET.build();\n  RSAQ A(n);\n  \n  auto add=[&](int v,int w){\n    int l,r; tie(l, r) = ET.get(v);\n    A.add(l,r+1,w);\n  };\n\n  auto getSum=[&](int u){\n    return A.sum(u,u+1);\n  };\n\n  int q;\n  cin>>q;\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int v, w;\n      cin>> v >> w;\n      add(v,w);\n    }\n    if(cmd == 1){\n      int u;\n      cin>>u;\n      int ans = getSum(u);\n      cout<<ans<<endl;\n    }\n    \n\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i = 0; i < (int)n; i++)\nusing ll = long long;\n\ntemplate <typename T, typename F>\nclass SegTree{\n  int n; T uni; F f;\n  vector<T> dat;\npublic:\n  SegTree(int _n, F f, T uni) : f(f), uni(uni) {\n    n = 1;\n    while(n < _n) n *= 2;\n    dat = vector<T>(2*n,uni);\n  }\n  void set(int k, const T x) {\n    dat[k+n] = x;\n  }\n  void build() {\n    for(int i = n-1; i >= 0; i--) {\n      dat[i] = f(dat[2*i],dat[2*i+1]);\n    }\n  }\n  void update(int k, T x) {\n    k += n;\n    dat[k] += x;\n    while(k >>= 1){\n      dat[k] = f(dat[2*k],dat[2*k+1]);\n    }\n  }\n  T query(int a, int b) {\n    T l = uni, r = uni;\n    for(a += n, b += n; a < b; a >>= 1, b >>= 1) {\n      if(a & 1) l = f(l,dat[a++]);\n      if(b & 1) r = f(dat[--b],r);\n    }\n    return f(l,r);\n  }\n};\n\nstruct HLD {\n  int n;\n  vector<vector<ll>>& g;\n  vector<ll> vid, head, sz, par;\n\n  HLD(vector<vector<ll>>& g): g(g), n(g.size()), vid(n,-1), head(n), sz(n,1), par(n) {}\n\n  void dfs1(ll v, ll p) {\n    if(g[v].size() && g[v][0] == p) swap(g[v][0],g[v].back());\n    for(auto &to : g[v]) {\n      if(to == p) continue;\n      dfs1(to, v);\n      sz[v] += sz[to];\n      if(sz[to] > sz[g[v][0]]) swap(to,g[v][0]);\n    }\n  }\n\n  void dfs2(ll v, ll p, ll &k) {\n    par[v] = p; vid[v] = k++;\n    for(auto to : g[v]) {\n      if(to == p) continue;\n      head[to] = (to == g[v][0] ? head[v] : to);\n      dfs2(to,v,k);\n    }\n  }\n\n  void build(vector<ll> rs = vector<ll>(1,0)) {\n    ll k = 0;\n    for(ll r : rs) {\n      dfs1(r,-1);\n      head[r] = r;\n      dfs2(r,-1,k);\n    }\n  }\n\n  void for_each_vertex(ll u, ll v, const function<void(ll,ll)>& f) {\n    while(true) {\n      if(vid[u] > vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u] != head[v]) v = par[head[v]];\n      else break;\n    }\n  }\n\n  void for_each_edge(ll u, ll v, const function<void(ll,ll)>& f) {\n    while(true) {\n      if(vid[u] > vid[v]) swap(u,v);\n      if(head[u] != head[v]) {\n        f(vid[head[v]],vid[v]); \n        v = par[head[v]];\n      } else {\n        if(u != v) f(vid[u]+1,vid[v]);\n        break;\n      }\n    }\n  }\n\n  ll lca(ll u, ll v) {\n    while(true) {\n      if(vid[u] > vid[v]) swap(u,v);\n      if(head[u] == head[v]) return u;\n      v = par[head[v]];\n    }\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  vector<vector<ll>> g(n);\n  rep(i,n) {\n    int k;\n    cin >> k;\n    int c;\n    rep(j,k) {\n      cin >> c;\n      g[i].push_back(c);\n      g[c].push_back(i);\n    }\n  }\n  HLD hld(g);\n  hld.build();\n  auto f = [](ll a, ll b){return a + b;};\n  SegTree<ll,decltype(f)> st(n,f,0);\n  st.build();\n  int q;\n  cin >> q;\n  vector<ll> ans; \n  rep(i,q) {\n    int type;\n    cin >> type;\n    if(type == 0) {\n      ll v, w;\n      cin >> v >> w;\n      st.update(hld.vid[v],w);\n    } else {\n      int v;\n      cin >> v;\n      ll val = 0;\n      hld.for_each_vertex(0,v,[&](int l, int r){val += st.query(l,r+1);});\n      ans.push_back(val);\n    }\n  }\n  for(ll x : ans) cout << x << endl; \n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntemplate<typename T> constexpr function<T(T, T)> ex_assign(T initE) {\n  return [&initE](const T& x, const T& y) -> const T { return (y == initE) ? x : y; };\n}\ntemplate<typename T> constexpr function<T(T, int)> ex_multiplies(T initE) {\n  return [&initE](const T& x, size_t y) -> const T { return (x == initE) ? x : x * y; };\n}\ntemplate<typename T, typename E> struct LazySegmentTree {\n  using F = function<T(T, T)>;\n  using G = function<T(T, E)>;\n  using H = function<E(E, E)>;\n  using P = function<E(E, int)>;\n\n  int n;\n  T initT;\n  E initE;\n  F f;\n  G g;\n  H h;\n  P p;\n  vector<T> data;\n  vector<E> lazy;\n\n  LazySegmentTree() {}\n  LazySegmentTree(int n_, F f, G g, H h, T initT = INT_MAX, E initE = INT_MAX,\n      vector<T> v = vector<T>(), P p = [](E a, size_t b) { ++b; return a; })\n      : f(f), g(g), h(h), initT(initT), initE(initE), p(p) {\n    n = 1;\n    while (n < n_) n *= 2;\n    data.assign(n * 2 - 1, initT);\n    lazy.assign(n * 2 - 1, initE);\n    if (n_ == v.size()) build(v);\n  }\n  void build(vector<T> v) {\n    for (int i = 0; i < v.size(); ++i) data[i + n - 1] = v[i];\n    for (int i = n - 2; i >= 0; --i) {\n      data[i] = f(data[i * 2 + 1], data[i * 2 + 2]);\n    }\n  }\n  inline void eval(int len, int k) {\n    if (lazy[k] == initE) return;\n    if (k * 2 + 1 < n * 2 - 1) {\n      lazy[k * 2 + 1] = h(lazy[k * 2 + 1], lazy[k]);\n      lazy[k * 2 + 2] = h(lazy[k * 2 + 2], lazy[k]);\n    }\n    data[k] = g(data[k], p(lazy[k], len));\n    lazy[k] = initE;\n  }\n  T update(int a, int b, E x, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return data[k];\n    if (a <= l && r <= b) {\n      lazy[k] = h(lazy[k], x);\n      return g(data[k], p(lazy[k], r - l));\n    }\n    T vl = update(a, b, x, k * 2 + 1, l, (l + r) / 2);\n    T vr = update(a, b, x, k * 2 + 2, (l + r) / 2, r);\n    return data[k] = f(vl, vr);\n  }\n  T query(int a, int b, int k = 0, int l = 0, int r = -1) {\n    if (r < 0) r = n;\n    eval(r - l, k);\n    if (b <= l || r <= a) return initT;\n    if (a <= l && r <= b) return data[k];\n    T vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n    T vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n    return f(vl, vr);\n  }\n};\n//\n// e.g.\n//      |     f     |   g   |   h   |   initT   | initE |   p\n// -----+-----------+-------+-------+-----------+-------+--------\n//  RMQ | min / max |       |       | INF / 0   |       | (mult)\n//  RSQ | plus      |       |       | 0         |       | (mult)\n//  RUQ |           | (ass) | (ass) |           | INF   | (mult)\n//  RAQ |           | plus  | plus  |           | 0     | (mult)\n//\n//  (ass)  := ex_assign;\n//  (mult) := ex_multiplies;\n//\nconst int initT = 0;\nconst int initE = 0;\nconst LazySegmentTree<int, int>::F f = plus<int>();\nconst LazySegmentTree<int, int>::G g = plus<int>();\nconst LazySegmentTree<int, int>::H h = plus<int>();\n\nstruct Tree {\n  using P = pair<int, int>;\n\n  int n;\n  int time;\n  vector<vector<int>> g;\n  vector<int> num;\n  vector<P> depth;\n  vector<int> eulerTour;\n  //LazySegmentTree<> seg;\n  vector<int> es;\n\n  Tree(int n)\n      : n(n), time(0), g(n),\n        num(n), depth(n * 2 - 1), eulerTour(n * 2 - 1), es(n * 2) {}\n\n  void init(int r) {\n    dfs(r, r, 0);\n    //SegmentTree<P>::F f = [](P a, P b) { return min(a, b); };\n    //seg = SegmentTree<P>(n * 2 - 1, f, {INT_MAX, -1}, depth);\n  }\n  void addEdge(int s, int t) {\n    g[s].push_back(t);\n    g[t].push_back(s);\n  }\n  void dfs(int u, int p, int d) {\n    //num[u] = time;\n    //eulerTour[time] = u;\n    //depth[time] = {d, time};\n    ++time;\n    for (auto&& v : g[u]) {\n      if (v != p) {\n        es[v * 2] = time;\n        dfs(v, u, d + 1);\n        //eulerTour[time] = u;\n        //depth[time] = {d, time};\n        es[v * 2 + 1] = time;\n        ++time;\n      }\n    }\n  }\n  //int lowestCommonAncestor(int u, int v) {\n  //  int i = num[u];\n  //  int j = num[v];\n  //  if (i > j) swap(i, j);\n  //  return eulerTour[seg.query(i, j + 1).second];\n  //}\n};\n\nint main() {\n  int n; cin >> n;\n  LazySegmentTree<int, int> weight(n * 2, f, g, h, initT, initE);\n  Tree t(n);\n\n  for (int i = 0; i < n; ++i) {\n    int k; cin >> k;\n    while (k--) {\n      int c; cin >> c;\n      t.addEdge(i, c);\n    }\n  }\n\n  t.init(0);\n  int q; cin >> q;\n  while (q--) {\n    int com; cin >> com;\n    if (com) {\n      int u; cin >> u;\n      cout << weight.query(0, t.es[u * 2] + 1) << endl;\n    } else {\n      int v, w; cin >> v >> w;\n      weight.update(t.es[v * 2], t.es[v * 2] + 1, w);\n      weight.update(t.es[v * 2 + 1], t.es[v * 2 + 1] + 1, -w);\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nint n, vis = 1, start[100005], node[100005], fin[100005];\nvector <int> v[100005];\n\n//オイラーツアー\nvoid dfs(int nd) {\n  start[nd] = vis; vis++;\n  for (int i : v[nd]) {dfs(i);}\n  node[nd] = vis;\n  return;\n}\n\nint query(int p) {\n  int re = 0;\n  while (p > 0) {\n    re += fin[p];\n    p -= ((-p) & p);\n  }\n  return re;\n}\n\nvoid update(int p, int val) {\n  while (p <= n) {\n    fin[p] += val;\n    p += ((-p) & p);\n  }\n  return;\n}\n\nint main() {\n  int q,a,b,c,x,op;\n  cin >> n;\n  for (int i = 0; i < n; i++) {\n    cin >> a;\n    for (int j = 0; j < a; j++) {\n      cin >> x;\n      v[i].push_back(x);\n    }\n  }\n  dfs(0);\n  cin >> q;\n  for (int i = 0; i < q; i++) {\n    cin >> op;\n    if (op == 0) {\n      cin >> a >> b;\n      update(start[a], b);\n      update(node[a], b*-1);\n    }\n    else {\n      cin >> a;\n      cout << query(start[a]) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct HLDecomposition {\n  Int n,pos;\n  vector<vector<Int> > G;\n  vector<Int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(Int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(Int u, Int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<Int> rs={0}) {\n    Int c=0;\n    for(Int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(Int rt) {\n    using T = pair<Int, Int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      Int v=st.top().first;\n      Int &i=st.top().second;\n      if(i<(Int)G[v].size()){\n\tInt u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tInt res=0;\n\tfor(Int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(Int r,Int c) {\n    Int &k=pos;\n    queue<Int> q({r});\n    while(!q.empty()){\n      Int h=q.front();q.pop();\n      for(Int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(Int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(Int u, Int v, const function<void(Int, Int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u]!=head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(Int u, Int v, const function<void(Int, Int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  Int lca(Int u,Int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  Int distance(Int u,Int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  Int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(Int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(Int)v.size()) build(n_,v);\n  }\n  void init(Int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(Int n_, vector<T> v){\n    for(Int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(Int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(Int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(Int a,Int b){\n    T vl=d1,vr=d1;\n    for(Int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n\n  Int find(Int a,Int b,function<bool(T)> &check,Int k,Int l,Int r){\n    if(!check(dat[k])||r<=a||b<=l) return -1;\n    if(k>=n-1) return k-(n-1);\n    Int m=(l+r)>>1;\n    Int vl=find(a,b,check,k*2+1,l,m);\n    if(~vl) return vl;\n    return find(a,b,check,k*2+2,m,r);\n  }\n  \n  Int find(Int a,Int b,function<bool(T)> &check){\n    return find(a,b,check,0,0,n);\n  }\n  \n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  HLDecomposition hld(n);\n  for(Int i=0;i<n;i++){\n    Int k;\n    cin>>k;\n    for(Int j=0;j<k;j++){\n      Int c;\n      cin>>c;\n      hld.add_edge(i,c);\n    }\n  }\n  hld.build();\n  auto G=hld.G;\n  auto vid=hld.vid;\n  auto inv=hld.inv;\n\n  SegmentTree<Int, Int>::F f=[](Int a,Int b){return a+b;};\n  SegmentTree<Int, Int> seg(n,f,f,0);\n  \n  Int q;\n  cin>>q;\n  for(Int i=0;i<q;i++){\n    Int t;\n    cin>>t;\n    if(t==0){\n      Int v,w;\n      cin>>v>>w;\n      seg.update(vid[v],w);\n    }\n    if(t==1){\n      Int u;\n      cin>>u;\n      Int ans=0;\n      hld.for_each_edge(0,u,[&](Int l,Int r){\n\t  ans+=seg.query(l,r+1);\n\t});\n      cout<<ans<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define Rep(i,n) for(int i=0;i<(int)(n);i++)\n#define For(i,n1,n2) for(int i=(int)(n1);i<(int)(n2);i++)\n#define REP(i,n) for(ll i=0;i<(ll)(n);i++)\n#define RREP(i,n) for(ll i=((ll)(n)-1);i>=0;i--)\n#define FOR(i,n1,n2) for(ll i=(ll)(n1);i<(ll)(n2);i++)\n#define RFOR(i,n1,n2) for(ll i=((ll)(n1)-1);i>=(ll)(n2);i--)\n#define all(a)  (a).begin(),(a).end()\n#define SORT(a) sort((a).begin(),(a).end())\n#define oorret 0\n#define oor(x) [&](){try{x;} catch(const out_of_range& oor){return oorret;} return x;}()\n#define IOS cin.tie(0),ios::sync_with_stdio(false)\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<ll, ll> P;\ntemplate<typename T1, typename T2> inline bool chmin(T1& a, T2 b) { if (a > b) { a = b; return 1; }return 0; }\ntemplate<typename T1, typename T2> inline bool chmax(T1& a, T2 b) { if (a < b) { a = b; return 1; }return 0; }\ntemplate<class Type>struct is_vector : std::false_type {};\ntemplate<class ValueType, class Alloc>struct is_vector<std::vector<ValueType, Alloc>> : std::true_type {};\ntemplate <typename T> inline ostream& operator << (ostream& out, const vector<T>& v) {\n\tif (v.empty())return out;\n\tconstexpr bool is_vector_v = is_vector<T>::value;\n\tif (is_vector_v)for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \"\\n\" : \"\");\n\telse for (auto itr = v.begin(); itr != v.end();)out << (*itr), out << ((++itr != v.end()) ? \" \" : \"\");\n\treturn out;\n}\ninline void put() {}\ntemplate<class T> inline void put(const T& first) { std::cout << first << \"\\n\"; }\ntemplate<class T, class... N> inline void put(const T& first, const N& ... rest) { std::cout << first << \" \"; put(rest...); }\ninline void putn() {}\ntemplate<class T, class... N> inline void putn(const T& first, const N& ... rest) { std::cout << first << \"\\n\"; putn(rest...); }\n\ntemplate<typename T>\nT upsum(const T& l, const T& r) {//SegmentTreeのupdate関数\n\tT res;\n\tres = l + r;\n\treturn res;\n}\n\ntemplate<typename T>\nclass SegmentTree {\npublic:\n\tusing F = function<T(T&, T&)>;\n\tvector<T> seg;\n\tint sz = 1;\n\tT unit;\n\tF up;\n\tSegmentTree(int n, F up, T unit = 0) :up(up), unit(unit) {\n\t\twhile (sz < n) sz <<= 1;\n\t\tseg.resize(sz * 2, unit);\n\t}\n\tvoid set(const int& k, const T& x) {//左からk番目の葉にxを代入する\n\t\tseg[sz - 1 + k] = x;\n\t}\n\tvoid set(vector<T> a) {\n\t\tfor (int i = 0; i < a.size(); ++i) {\n\t\t\tthis->set(i, a[i]);\n\t\t}\n\t\tint s = sz;\n\t\twhile (s > 0) {\n\t\t\tfor (int i = s / 2; i < s; ++i) {\n\t\t\t\tseg[i] = up(seg[2 * i + 1], seg[2 * i + 2]);\n\t\t\t}\n\t\t\ts /= 2;\n\t\t}\n\t}\n\tT get(const int& k) {//左からk番目の葉を得る\n\t\treturn seg[sz - 1 + k];\n\t}\n\tvoid update(int k, T v) {// k 番目の値をup(seg[k],v)にする\n\t\tk += sz - 1;\n\t\tseg[k] = up(seg[k], v);\n\t\twhile (k > 0) {\n\t\t\tk = (k - 1) / 2;\n\t\t\tseg[k] = up(seg[2 * k + 1], seg[2 * k + 2]);\n\t\t}\n\t}\n\tT query(int a, int b) {//[a,b)のupの合成を求める\n\t\tint k = 0, l = 0, r = sz;\n\t\tif (r <= a || b <= l) {\n\t\t\treturn unit;\n\t\t}\n\t\tif (a <= l && r <= b) {\n\t\t\treturn seg[k];\n\t\t} else {\n\t\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn up(vl, vr);\n\t\t}\n\t}\n\tT query(int a, int b, int k, int l, int r) {//[a,b)のupの合成を求める(a,b,0,0,sz)のように使う\n\t\tif (r <= a || b <= l) {\n\t\t\treturn unit;\n\t\t}\n\t\tif (a <= l && r <= b) {\n\t\t\treturn seg[k];\n\t\t} else {\n\t\t\tT vl = query(a, b, k * 2 + 1, l, (l + r) / 2);\n\t\t\tT vr = query(a, b, k * 2 + 2, (l + r) / 2, r);\n\t\t\treturn up(vl, vr);\n\t\t}\n\t}\n};\n\n\nclass EularTourPath {\npublic:\n\tvector<vector<int>> path;\n\tint n, m, itr;\n\tvector<int> pos,neg;\n\tSegmentTree<ll> sg;\n\tEularTourPath(vector<vector<int>> path, int n, int m) :path(path), n(n), m(m),sg(SegmentTree<ll>(n*2, upsum<ll>)) {\n\t\tpos.resize(n);\n\t\tneg.resize(n);\n\t\titr = 0;\n\t\tvector<int> visited(n, 0);\n\t\tdfs(0, visited);\n\t}\n\tvoid dfs(int v, vector<int>& visited) {\n\t\tpos[v] = itr++;\n\t\tfor (int i = 0; i < path[v].size(); ++i) {\n\t\t\tint next = path[v][i];\n\t\t\tif (!visited[next]) {\n\t\t\t\tvisited[next] = 1;\n\t\t\t\tdfs(next, visited);\n\t\t\t}\n\t\t}\n\t\tneg[v] = itr++;\n\t}\n\tvoid updateEdge(int e,ll a) {\n\t\tsg.update(pos[e], a);\n\t\tsg.update(neg[e], -a);\n\t}\n\tll get(int e) {//rootからeまでのpathのupの合成\n\t\treturn sg.query(0, neg[e]);\n\t}\n};\n\nint main() {\n\tIOS;\n\tint n, m = 0;\n\tcin >> n;\n\tvector<vector<int>> path(n);\n\tREP(i, n) {\n\t\tint k;\n\t\tcin >> k;\n\t\tm += k;\n\t\tREP(j, k) {\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tpath[i].push_back(c);\n\t\t}\n\t}\n\tEularTourPath etp(path, n, m);\n\tint q;\n\tcin >> q;\n\tREP(i, q) {\n\t\tint p;\n\t\tcin >> p;\n\t\tif (p) {\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tput(etp.get(u));\n\t\t} else {\n\t\t\tint v, w;\n\t\t\tcin >> v >> w;\n\t\t\tetp.updateEdge(v, w);\n\t\t}\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define For(i, a, b) for(int (i)=(int)(a); (i)<(int)(b); ++(i))\n#define rFor(i, a, b) for(int (i)=(int)(a)-1; (i)>=(int)(b); --(i))\n#define rep(i, n) For((i), 0, (n))\n#define rrep(i, n) rFor((i), (n), 0)\n#define fi first\n#define se second\nusing namespace std;\ntypedef long long lint;\ntypedef unsigned long long ulint;\ntypedef pair<int, int> pii;\ntemplate<class T> bool chmax(T &a, const T &b){if(a<b){a=b; return true;} return false;}\ntemplate<class T> bool chmin(T &a, const T &b){if(a>b){a=b; return true;} return false;}\ntemplate<class T> T div_floor(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>=0 ? a/b : (a+1)/b-1;\n}\ntemplate<class T> T div_ceil(T a, T b){\n    if(b < 0) a *= -1, b *= -1;\n    return a>0 ? (a-1)/b+1 : a/b;\n}\n\nconstexpr lint mod = 1e9+7;\nconstexpr lint INF = mod * mod;\nconstexpr int MAX = 200010;\n\ntemplate<typename T> struct SegTree{\n    using F=function<T(T, T)>;\n    int sz=1, seq_sz;\n    T et;\n    F f, g;\n    vector<T> node;\n\n    SegTree(int sz_, T et_, F f_, F g_): seq_sz(sz_), et(et_), f(f_), g(g_){\n        while(sz<sz_) sz<<=1;\n        node.resize(sz<<1, et);\n    }\n\n    void build(vector<T> &a){\n        rep(i, a.size()) node[i+sz] = a[i];\n        rFor(i, sz, 1) node[i] = f(node[i<<1], node[(i<<1)+1]);\n    }\n\n    void build(T x){\n        rep(i, seq_sz) node[i+sz] = x;\n        rFor(i, sz, 1) node[i] = f(node[i<<1], node[(i<<1)+1]);\n    }\n\n    void update(int i, T x){\n        i+=sz;\n        node[i]=g(node[i], x);\n        i>>=1;\n        while(i){\n            node[i]=f(node[i<<1], node[(i<<1)+1]);\n            i>>=1;\n        }\n    }\n\n    T query(int l, int r){\n        T vl=et, vr=et;\n        for(l+=sz, r+=sz; l<r; l>>=1, r>>=1){\n            if(l&1) vl=f(vl, node[l++]);\n            if(r&1) vr=f(node[--r], vr);\n        }\n        return f(vl, vr);\n    }\n\n    int search_left(int l, const T val, function<bool(T, T)> cmp, function<bool(T, T)> check){\n        T sum = et;\n        for(l+=sz; ; l>>=1){\n            if(check(f(sum, node[l]), val)){\n                while(l < sz){\n                    if(check(f(sum, node[l<<1]), val)) l<<=1;\n                    else{\n                        sum = f(sum, node[l<<1]);\n                        l = (l<<1) + 1;\n                    }\n                }\n                return l-sz;\n            }\n            if(__builtin_popcount(l+1) == 1) return seq_sz;\n            if(l&1) sum = f(sum, node[l++]);\n        }\n    }\n\n    int search_right(int r, const T val, function<bool(T, T)> cmp, function<bool(T, T)> check){\n        T sum = et;\n        for(r+=sz; ; r>>=1){\n            if(check(f(sum, node[r]), val)){\n                while(r < sz){\n                    if(check(f(node[(r<<1)+1], sum), val)) r = (r<<1) + 1;\n                    else{\n                        sum = f(node[(r<<1)+1], sum);\n                        r<<=1;\n                    }\n                }\n                return r-sz;\n            }\n            if(__builtin_popcount(r) == 1) return -1;\n            if(!(r&1)) sum = f(node[r--], sum);\n        }\n    }\n\n    int lower_bound_left(int l, const T val, function<bool(T, T)> cmp=less<>()){\n        auto check = [&cmp](auto a, auto b){return !cmp(a, b);};\n        return search_left(l, val, cmp, check);\n    }\n\n    int upper_bound_left(int l, const T val, function<bool(T, T)> cmp=less<>()){\n        auto check = [&cmp](auto a, auto b){return cmp(b, a);};\n        return search_left(l, val, cmp, check);\n    }\n\n    int lower_bound_right(int l, const T val, function<bool(T, T)> cmp=greater<>()){\n        auto check = [&cmp](auto a, auto b){return !cmp(b, a);};\n        return search_right(l, val, cmp, check);\n    }\n\n    int upper_bound_right(int l, const T val, function<bool(T, T)> cmp=greater<>()){\n        auto check = [&cmp](auto a, auto b){return cmp(a, b);};\n        return search_right(l, val, cmp, check);\n    }\n};\n\ntemplate<class T> struct edge{\n    int from, to; T cost;\n    edge(int f, int t, T c): from(f), to(t), cost(c){}\n};\n\ntemplate<typename T> struct HLDecomposition{\n    int n;\n    SegTree<T> *st;\n    vector<vector<edge<T>>> G;\n    vector<int> ttos, par, head;\n\n    HLDecomposition(int n, SegTree<T> *st, bool edge_query=false): n(n), st(st){\n        int k = (edge_query ? 2*n : n);\n        G.resize(k);\n        ttos.resize(k); par.resize(k); head.resize(k);\n    }\n\n    void add_edge(int a, int b, T c){\n        G[a].emplace_back(a, b, c);\n    }\n\n    void build(bool edge_query=false){\n        sz_dfs(0, -1);\n        if(!edge_query){\n            int idx = 0;\n            ttos[0] = idx++;\n            head[0] = 0;\n            hld_dfs(0, -1, 0, idx);\n        }\n        else{\n            int idx = 0;\n            ttos[n] = idx++; ttos[0] = idx++;\n            head[n] = n; head[0] = n;\n            hld_dfs_edge(0, n, n, idx);\n        }\n    }\n\n    int sz_dfs(int v, int pv){\n        int ret = 0, tmax = 0;\n        for(auto &e: G[v])if(e.to != pv){\n            int tmp = sz_dfs(e.to, v);\n            ret += tmp;\n            if(chmax(tmax, tmp)) swap(G[v][0], e);\n        }\n        return ret + 1;\n    }\n\n    void hld_dfs(int v, int pv, int h, int &idx){\n        for(auto &e: G[v])if(e.to != pv){\n            int nv = e.to;\n            ttos[nv] = idx++;\n            par[nv] = v;\n            head[nv] = (G[v][0].to == nv ? h : nv);\n            hld_dfs(nv, v, head[nv], idx);\n        }\n    }\n\n    void hld_dfs_edge(int v, int pv, int h, int &idx){\n        for(auto &e: G[v])if(e.to != pv){\n            int nv = e.to;\n            ttos[nv+n] = idx++; ttos[nv] = idx++;\n            par[nv+n] = v; par[nv] = nv+n;head[nv+n] = (G[v][0].to == nv ? h : nv+n); head[nv] = head[nv+n];\n            hld_dfs_edge(nv, v, head[nv], idx);\n        }\n    }\n\n    void update(int a, T x, bool edge_query=false){\n        st->update((edge_query ? ttos[a+n] : ttos[a]), x);\n    }\n\n    T query(int a, int b){\n        T ret = st->et;\n        while(true){\n            if(ttos[a] < ttos[b]) swap(a, b);\n            if(head[a] == head[b]){\n                ret = st->f(ret, st->query(ttos[b], ttos[a]+1));\n                return ret;\n            }\n            ret = st->f(ret, st->query(ttos[head[a]], ttos[a]+1));\n            a = par[head[a]];\n        }\n    }\n};\n\nint main(){\n    int n;\n    scanf(\"%d\", &n);\n    SegTree<lint> st(2*n, 0, plus<>(), plus<>());\n    HLDecomposition<lint> hld(n, &st, true);\n    rep(i, n){\n        int k, c;\n        scanf(\"%d\", &k);\n        rep(_, k){\n            scanf(\"%d\", &c);\n            hld.add_edge(i, c, 0);\n            hld.add_edge(c, i, 0);\n        }\n    }\n    hld.build(true);\n\n    int q;\n    scanf(\"%d\", &q);\n    rep(_, q){\n        int t, x; lint y;\n        scanf(\"%d%d\", &t, &x);\n        if(t == 0){\n            scanf(\"%lld\", &y);\n            hld.update(x, y, true);\n        }\n        else printf(\"%lld\\n\", hld.query(0, x));\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cassert>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,_7,_8,NAME,...) NAME\n#define pr(...) std::cerr<< GET_MACRO(__VA_ARGS__,pr8,pr7,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__) <<std::endl\n#define pr1(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr2(a,b) pr1(a)<<pr1(b)\n#define pr3(a,b,c) pr1(a)<<pr2(b,c)\n#define pr4(a,b,c,d) pr1(a)<<pr3(b,c,d)\n#define pr5(a,b,c,d,e) pr1(a)<<pr4(b,c,d,e)\n#define pr6(a,b,c,d,e,f) pr1(a)<<pr5(b,c,d,e,f)\n#define pr7(a,b,c,d,e,f,g) pr1(a)<<pr6(b,c,d,e,f,g)\n#define pr8(a,b,c,d,e,f,g,h) pr1(a)<<pr7(b,c,d,e,f,g,h)\n#define prArr(a) {cerr<<(#a)<<\"={\";int i=0;for(auto t:(a))cerr<<(i++?\", \":\"\")<<t;cerr<<\"}\"<<endl;}\n\ntemplate<typename T>\nclass Deque{\npublic:\n  T *val;\n  int sz;\n  int length;\n  int head, tail;\n  \n  Deque(){sz = 0, length = 0, val = new T[0];}\n  Deque(int size, T init = T()){\n    length = 1;\n    while(length < size) length *= 2;\n    val = new T[length];\n    sz = size;\n    head = 0;\n    tail = 0;\n    for(int i=0;i<size;i++) val[tail++] = init;\n  }\n  \n  Deque(const Deque &t){\n    sz = t.size();\n    length = 1;\n    while(length < sz) length *= 2;\n    val = new T[length];\n    head = 0;\n    tail = 0;\n    for(int i=0;i<sz;i++) val[tail++] = t[i];\n  }\n\n  ~Deque(){\n    delete [] val;\n  }\n  \n  Deque<T> operator = (const Deque<T> t){\n    delete [] val;\n    sz = t.size();\n    length = 1;\n    while(length < sz) length *= 2;\n    val = new T[length];\n    head = 0;\n    tail = 0;\n    for(int i=0;i<sz;i++) val[tail++] = t[i];\n    return t;\n  };\n  \n  T& operator [] (int i){\n    assert(0 <= i && i < sz);\n    return head+i<length? val[head+i]:val[head+i - length];\n  }\n  T& operator [] (int i)const{\n   assert(0 <= i && i < sz);\n    return head+i<length? val[head+i]:val[head+i - length];\n  }\n  \n  bool operator == (const Deque<T> &a)const{\n    if(size() != a.size()) return 0;\n    for(int i=0;i<size();i++)\n      if(!((*this)[i] == a[i])) return 0;\n    return 1;\n  }\n  \n  T& front(){return val[head];}\n  T& back(){return val[(head + sz - 1) % length];}\n  \n  int size()const{return sz;}\n  int empty()const{return sz == 0;}\n  \n  void resize(int n, T v=T()){\n    while(n < size()) pop_back();\n    while(n > size()) push_back_fast(v);\n  }\n\n\n  void increaseMemory(){\n    int length_ = length;\n    length = length * 2;\n    if(length == 0) length = 1;\n    T *val2 = new T[length];\n    for(int i=0;i<sz;i++) val2[i] = val[(head + i)%length_];\n    head = 0;\n    tail = sz;\n    delete [] val;\n    val = val2;\n  };\n  \n  void push_back(T v){\n    if(sz == length) increaseMemory();\n    sz++;\n    val[tail++] = v;\n    if(tail == length) tail = 0;\n  }\n\n  void push_back_fast(T &v){\n    if(sz == length) increaseMemory();\n    sz++;\n    val[tail++] = v;\n    if(tail == length) tail = 0;\n  }\n    \n  void push_front(int v){\n    if(sz == length) increaseMemory();\n    sz++;\n    head--;\n    if(head == -1) head = length - 1;\n    val[head] = v;\n  }\n\n  void pop_back(){\n    assert(sz > 0);\n    sz--;\n    tail--;\n    if(tail == -1) tail = length - 1;\n  }\n  \n  void pop_front(){\n    assert(sz > 0);\n    sz--;\n    head++;\n    if(head == length) head = 0;\n  }\n\n  friend std::ostream& operator << (std::ostream& os,const Deque<T> a){\n    os<<\"[\";\n    for(int i=0;i<a.size();i++){\n      if(i) os<<\" \";\n      os<<a[i];\n    }\n    os<<\"]\";\n    return os;\n  }\n};\n\ntemplate <typename T>\nusing vector = Deque<T>;\n\ntemplate <typename T, typename D>\nclass Pair{\npublic:\n  T first;\n  D second;\n  Pair(){first = T(),second = D();}\n  Pair(const T first, const D second):first(first), second(second){}\n  \n  bool operator < (const Pair t)const{\n    return first != t.first? (first < t.first):(second < t.second);\n  }\n  bool operator > (const Pair t)const{\n    return first != t.first? (first > t.first):(second > t.second);\n  }\n  \n  friend std::ostream& operator << (std::ostream& os,const Pair<T, D> a){\n    os<<\"(\"<<a.first<<\", \"<<a.second<<\")\";\n    return os;\n  }\n};\n\ntemplate <typename T, typename D> using pair = Pair<T,D>;\n\nclass EulerTour{\npublic:\n  int V;                     //ノード数\n  int root;                  //根の頂点番号\n  vector<vector<int> > G;    //Grapth\n  vector<int> L,R;           //[L,R]\n  bool ok;\n  EulerTour():V(-1),ok(0){};\n  EulerTour(int V,int root = 0):V(V),root(root),G(V),L(V),R(V),ok(0){}\n\n  void add_edge(int a,int b){\n    assert(a >= 0 && b >= 0);\n    assert(a < V && b < V);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n  \n  void dfs(int pos,int pre, int &cnt){\n    L[pos] = cnt;\n    for(int i=0;i<G[pos].size();i++){\n      int to = G[pos][i];\n      if(to != pre) cnt++, dfs(to, pos, cnt);\n    }\n    R[pos] = cnt;\n  };\n  \n  void build(){\n    ok = 1;\n    int cnt = 0;\n    dfs(root, -1, cnt);\n  }\n  \n  typedef pair<int,int> P;\n  P get(int v){assert(ok && v < V); return P(L[v],R[v]);} //[l, r]\n};\n\nclass RSAQ{\npublic: \n  typedef long long ll;\n\n  //マージ可能な主データ型\n  struct D{\n    ll value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(ll value):value(value){}\n    bool operator < (D a)const {return value < a.value;}\n  };\n\n  //遅延用の型  \n  struct T{\n    int type; //0 - empty   , 1 - update\n    ll value;\n    T():type(0),value(0){}\n    T(int type,ll value):type(type),value(value){}\n  };\n\n  \n  int n, n_;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n  \n  RSAQ(){n=-1;}\n  RSAQ(int n_):n_(n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n  \n  inline D merge(const D a,const D b)const{return a.value + b.value;}\n  \n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    ll type = td[k].type;\n    ll v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    len /= 2;\n    {\n      int l = k*2+1;\n      dat[l].value += v * len;\n      td[l].type = type;\n      td[l].value += v;\n    }\n    {\n      int r = k*2+2;\n      dat[r].value += v * len;\n      td[r].type = type;\n      td[r].value += v;\n    }\n  }\n\n  D write(int k, D x, int len){\n    dat[k].value += x.value * len;\n    td[k].type = 1;\n    td[k].value += x.value;\n    return dat[k];\n  }\n  \n  D dfs(int a, int b, D x, bool flag, int k, int l, int r){\n    if(r <= a||b <= l) return flag? dat[k]:returnD;\n    if(a <= l && r <= b) return flag? write(k, x, r - l):dat[k];\n    delay(k, r - l);\n    D vl = dfs(a, b, x, flag, k*2+1, l, (l+r)/2);\n    D vr = dfs(a, b, x, flag, k*2+2, (l+r)/2, r);\n    return flag? (dat[k] = merge(vl, vr)):merge(vl, vr);\n  }\n\n  //[l,r)の値にx加算\n  void add(int l,int r,ll x){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    dfs(l, r, D(x), true, 0, 0, n);\n  }\n  \n  //[l,r)の合計値を得る\n  ll get(int l,int r){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    D res = dfs(l, r, D(), false, 0, 0, n);\n    return res.value;\n  }\n};\n\n\nsigned main(){\n\n\n  int N;\n  std::cin>>N;\n\n  EulerTour ET(N, 0);\n  \n  for(int i=0;i<N;i++){\n    int k;\n    std::cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      std::cin>>c;\n      ET.add_edge(i, c);\n    }\n  }\n  \n  \n  ET.build();\n  \n  RSAQ seg(N);\n  auto add =[&](int v, int w){\n    auto p = ET.get(v);\n    seg.add(p.first, p.second + 1, w);\n  };\n\n  auto getSum=[&](int u){\n    int idx = ET.get(u).first;\n    return seg.get(idx, idx+1);\n  };\n\n  int q;\n  std::cin>>q;\n  while(q--){\n    int cmd;\n    std::cin>>cmd;\n    if(cmd == 0){\n      int v, w;\n      std::cin>>v>>w;\n      add(v, w);\n    }\n    else{\n      int u;\n      std::cin>>u;\n      int ans = getSum(u);\n      std::cout<<ans<<std::endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing i64 = long long;\n#define rep(i,s,e) for(i64 (i) = (s);(i) < (e);(i)++)\n#define all(x) x.begin(),x.end()\n#define let auto const\n\ntemplate<typename... Types>\nstruct dynarr: std::vector<Types...> {\n  using std::vector<Types...>::vector;\n  using size_type = typename std::vector<Types...>::size_type;\n  auto&& operator[](size_type i) { return this->at(i); }\n  auto&& operator[](size_type i) const { return this->at(i); }\n};\n\nstruct eulartour_path {\n  vector<vector<i64>> G;\n  vector<i64> in, out;\n  i64 cnt;\n  eulartour_path(i64 n): G(n), in(n), out(n) {}\n  void add_edge(i64 u, i64 v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void dfs(i64 v, i64 f) {\n    for(auto to: G[v]) {\n      if(to == f) continue;\n      in[to] = cnt;\n      cnt++;\n      dfs(to, v);\n      out[to] = cnt;\n      cnt++;\n    }\n  }\n\n  i64 start_tour(i64 r) {\n    in[r] = cnt;\n    cnt++;\n    dfs(r, -1);\n    return cnt;\n  }\n};\n\n\nstruct segment_tree {\n  using T = i64;\n  T ope(const T& a, const T& b) {\n    return a + b;\n  }\n  T ide() { return 0; }\n \n  i64 n;\n  vector<i64> node;\n \n  segment_tree(vector<i64> init) {\n    n = 1;\n    while(n < init.size()) n *= 2;\n    node.resize(2 * n);\n    rep(i, 0, init.size()) node[i + n] = init[i];\n    for(int i = n - 1; i >= 1;i--) node[i] = ope(node[i * 2], node[i * 2 + 1]);\n  }\n \n  void update(i64 i, i64 x) {\n    i += n;\n    node[i] += x;\n    while(i > 1) {\n      i = i / 2;\n      node[i] = ope(node[i * 2], node[i * 2 + 1]);\n    }\n  }\n  \n  /* [l, r] */\n  T get(i64 l, i64 r) {\n    T lx = ide();\n    T rx = ide();\n    l += n;\n    r += n;\n    while(l < r) {\n      if(l & 1) { lx = ope(lx, node[l]); }\n      if(!(r & 1)) { rx = ope(node[r], rx); }\n      l = (l + 1) >> 1;\n      r = (r - 1) >> 1;\n    }\n    if(l == r) { lx = ope(lx, node[l]); }\n    return ope(lx, rx);\n  }\n};\n\nint main() {\n  i64 N;\n  cin >> N;\n  eulartour_path eul(N);\n  rep(i,0,N) {\n    i64 k;\n    cin >> k;\n    rep(j,0,k) {\n      i64 c;\n      cin >> c;\n      eul.add_edge(i, c);\n    }\n  }\n\n  segment_tree seg(vector<i64>(eul.start_tour(0)));\n  \n  i64 Q;\n  cin >> Q;\n  rep(q, 0, Q) {\n    i64 type;\n    cin >> type;\n    if(type == 0) {\n      i64 v, w;\n      cin >> v >> w;\n      seg.update(eul.in[v], w);\n      seg.update(eul.out[v], -w);\n    }\n    else {\n      i64 u;\n      cin >> u;\n      cout << seg.get(eul.in[0] + 1, eul.in[u]) << endl;\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nconst int SIZE = 1 << 20;\nconst int NUM_SIZE = 200000;\nint n, segment_tree[SIZE];\nvector<vector<int> > vertex;\nint numbers[NUM_SIZE];\nint numbers_child[NUM_SIZE];\n\nvoid init(int _n) {\n\tn = 1;\n\twhile (n < _n)\n\t\tn *= 2;\n}\n\nint sum(int index) {\n\n\tindex += n - 1;\n\tint sum = segment_tree[index];\n\twhile (index > 0) {\n\t\tindex = (index - 1) / 2;\n\t\tsum += segment_tree[index];\n\t}\n\n\treturn sum;\n}\n\nvoid update(int index, int weight, int a, int b, int left = 0, int right = n) {\n\n\tif (right <= a || b <= left)\n\t\treturn;\n\telse if (a <= left && right <= b) {\n\t\tsegment_tree[index] += weight;\n\t}\n\telse {\n\t\tint mid = (left + right) / 2;\n\t\tupdate(index * 2 + 1, weight, a, b, left, mid);\n\t\tupdate(index * 2 + 2, weight, a, b, mid, right);\n\t}\n\n}\n\nvoid dfs(int index) {\n\n\tstatic int id = 0;\n\n\tnumbers[index] = id;\n\tid++;\n\n\tfor (int i = 0; i < vertex[index].size(); ++i)\n\t\tdfs(vertex[index][i]);\n\n\tnumbers_child[index] = id;\n\n}\n\nvoid print(int k) {\n\n\tfor (int i = 0; i < k; ++i) {\n\t\tcout << i << \" \";\n\t}\n\tcout << endl;\n\n\tfor (int i = 0; i < k; ++i) {\n\t\tcout << numbers[i] << \" \";\n\t}\n\n\tcout << endl;\n\n\tfor (int i = 0; i < k; ++i) {\n\t\tcout << numbers_child[i] << \" \";\n\t}\n\tcout << endl;\n}\n\nvoid print_tree() {\n\n\tfor (int i = 0; i < 2 * n - 1; ++i)\n\t\tcout << segment_tree[i] << \" \";\n\tcout << endl;\n\n}\n\nint main() {\n\n\tint vertex_size;\n\tcin >> vertex_size;\n\n\tvertex.resize(vertex_size);\n\n\tfor (int i = 0; i < vertex_size; ++i) {\n\n\t\tint input_v;\n\t\tcin >> input_v;\n\n\t\tfor (int j = 0; j < input_v; ++j) {\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tvertex[i].push_back(v);\n\t\t}\n\t}\n\n\tinit(vertex_size);\n\tdfs(0);\n\t// print(vertex_size);\n\tint q;\n\n\tcin >> q;\n\n\tfor (int i = 0; i < q; ++i) {\n\n\t\tint command;\n\t\tint v, w;\n\n\t\tcin >> command;\n\n\t\tif (command == 0) {\n\t\t\tcin >> v >> w;\n\t\t//\tcout << \"v = \" << v << \", w = \" << w << endl;\n\t\t\tupdate(0, w, numbers[v], numbers_child[v]);\n\t\t//\tprint_tree();\n\t\t//\tcout << endl;\n\t\t}\n\t\telse {\n\t\t\tcin >> v;\n\t\t\tcout << sum(numbers[v]) << endl;\n\t\t}\n\n\t}\n\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#include <cmath>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\nlong long int INF = 1e18;\nlong long int MOD = 1000000007;\n\nint const TREE_SIZE = 1 << 20;\nlong long int seg_tree[TREE_SIZE] = {};\n\nvoid change(int a, long long int w){\n\t\n\ta += TREE_SIZE / 2;\n\t\n\tseg_tree[a] += w;\n\t\n\tfor(int x = a / 2; x > 0; x /= 2){\n\t\tseg_tree[x] = seg_tree[2 * x] + seg_tree[2 * x + 1];\n\t}\n}\n\nlong long int query(int a, int b, int index, int l, int r){\n\t\n\t// 外からは query(a, b, 1, 0, TREE_SIZE / 2) のように呼ぶ\n\t\n\tif(r <= a || b <= l){\n\t\treturn 0;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn seg_tree[index];\n\t}\n\t\n\treturn query(a, b, index * 2, l, (l + r) / 2) + query(a, b, index * 2 + 1, (l + r) / 2, r);\n}\n\n#define MAX_V 110000\n\nvector<int> E[MAX_V];\nint child_num[MAX_V];\nint p_num[MAX_V];\n\nint func(int p, int id){\n\tp_num[p] = id;\n\tint S = 1;\n\tfor(int i = 0; i < E[p].size(); i++){\n\t\tS += func(E[p][i], id + S);\n\t}\n\treturn child_num[p] = S;\n}\n\nint main(){\n\t\n\tint V, Q;\n\tcin >> V;\n\t\n\tfor(int i = 0; i < V; i++){\n\t\tint num;\n\t\tcin >> num;\n\t\tfor(int j = 0; j < num; j++){\n\t\t\tint v;\n\t\t\tcin >> v;\n\t\t\tE[i].push_back(v);\n\t\t}\n\t}\n\t\n\tfunc(0, 0);\n\t\n\tcin >> Q;\n\t\n\tfor(int i = 0; i < Q; i++){\n\t\tlong long int num, v, w;\n\t\tcin >> num;\n\t\tif(num == 0){\n\t\t\tcin >> v >> w;\n\t\t\tchange(p_num[v], w);\n\t\t\tchange(p_num[v] + child_num[v], -w);\n\t\t}else{\n\t\t\tcin >> v;\n\t\t\tcout << query(0, p_num[v] + 1, 1, 0, TREE_SIZE / 2) << endl;\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntemplate< typename Monoid = int, typename OperatorMonoid = Monoid >\nstruct LinkCutTree {\n  using F = function< Monoid(Monoid, Monoid) >;\n  using G = function< Monoid(Monoid, OperatorMonoid, int) >;\n  using H = function< OperatorMonoid(OperatorMonoid, OperatorMonoid) >;\n\n  struct Node {\n    Node *l, *r, *p;\n    int idx;\n    Monoid key, sum;\n    OperatorMonoid lazy;\n\n    bool rev;\n    int sz;\n\n    bool is_root() {\n      return !p || (p->l != this && p->r != this);\n    }\n\n    Node(int idx, const Monoid &key, const OperatorMonoid &om) :\n        idx(idx), key(key), sum(key), lazy(om), sz(1),\n        l(nullptr), r(nullptr), p(nullptr), rev(false) {}\n  };\n\n  const Monoid M1;\n  const OperatorMonoid OM0;\n  const F f;\n  const G g;\n  const H h;\n\n  LinkCutTree() : LinkCutTree(F(), Monoid()) {}\n\n  LinkCutTree(const F &f, const Monoid &M1) :\n      LinkCutTree(f, G(), H(), M1, OperatorMonoid()) {}\n\n  LinkCutTree(const F &f, const G &g, const H &h,\n              const Monoid &M1, const OperatorMonoid &OM0) :\n      f(f), g(g), h(h), M1(M1), OM0(OM0) {}\n\n  Node *make_node(int idx, const Monoid &v = Monoid()) {\n    return new Node(idx, v, OM0);\n  }\n\n  void push(Node *t) {\n    if(t->lazy != OM0) {\n      if(t->l) t->l->lazy = h(t->l->lazy, t->lazy);\n      if(t->r) t->r->lazy = h(t->r->lazy, t->lazy);\n      t->key = g(t->key, t->lazy, 1);\n      t->sum = g(t->sum, t->lazy, t->sz);\n      t->lazy = OM0;\n    }\n    if(t->rev) {\n      swap(t->l, t->r);\n      if(t->l) t->l->rev ^= true;\n      if(t->r) t->r->rev ^= true;\n    }\n  }\n\n  void update(Node *t) {\n    t->sz = 1;\n    t->sum = t->key;\n    if(t->l) t->sz += t->l->sz, t->sum = t->l->sum + t->sum;\n    if(t->r) t->sz += t->r->sz, t->sum = t->sum + t->r->sum;\n  }\n\n  void rotr(Node *t) { // 右回転\n    auto *x = t->p, *y = x->p;\n    if((x->l = t->r)) t->r->p = x;\n    t->r = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void rotl(Node *t) { // 左回転\n    auto *x = t->p, *y = x->p;\n    if((x->r = t->l)) t->l->p = x;\n    t->l = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t) {\n    push(t);\n    while(!t->is_root()) {\n      auto *q = t->p;\n      if(q->is_root()) {\n        push(q), push(t);\n        if(q->l == t) rotr(t);\n        else rotl(t);\n      } else {\n        auto *r = q->p;\n        push(r), push(q), push(t);\n        if(r->l == q) {\n          if(q->l == t) rotr(q), rotr(t);\n          else rotl(t), rotr(t);\n        } else {\n          if(q->r == t) rotl(q), rotl(t);\n          else rotr(t), rotl(t);\n        }\n      }\n    }\n  }\n\n  Node *expose(Node *t) {\n    Node *rp = nullptr;\n    for(Node *cur = t; cur; cur = cur->p) {\n      splay(cur);\n      cur->r = rp;\n      update(cur);\n      rp = cur;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *child, Node *parent) {\n    expose(child);\n    expose(parent);\n    child->p = parent;\n    parent->r = child;\n  }\n\n  void cut(Node *child) {\n    expose(child);\n    auto *parent = child->l;\n    child->l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert(Node *t) {\n    expose(t);\n    t->rev ^= true;\n    push(t);\n  }\n\n  Node *lca(Node *u, Node *v) {\n    expose(u);\n    return expose(v);\n  }\n};\n\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  LinkCutTree<> lctree;\n  vector< LinkCutTree<>::Node * > uku(N);\n  for(int i = 0; i < N; i++) {\n    uku[i] = lctree.make_node(i);\n  }\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int T;\n      scanf(\"%d\", &T);\n      lctree.link(uku[T], uku[i]);\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int T;\n    scanf(\"%d\", &T);\n    if(T == 0) {\n      int V, W;\n      scanf(\"%d %d\", &V, &W);\n      lctree.expose(uku[V]);\n      uku[V]->key += W;\n    } else {\n      int U;\n      scanf(\"%d\", &U);\n      lctree.expose(uku[U]);\n      printf(\"%d\\n\", uku[U]->sum);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nusing vi = vector<int>; using vvi = vector<vi>; using vvvi = vector<vvi>;\nusing ll = long long int;\nusing vll = vector<ll>; using vvll = vector<vll>; using vvvll = vector<vvll>;\nusing vd = vector<double>; using vvd = vector<vd>; using vvvd = vector<vvd>;\nusing P = pair<int, int>;\nusing Pll = pair<ll, ll>;\nusing cdouble = complex<double>;\n\nconst double eps = 1e-7;\n#define Loop(i, n) for(int i = 0; i < int(n); i++)\n#define Loopll(i, n) for(ll i = 0; i < ll(n); i++)\n#define Loop1(i, n) for(int i = 1; i <= int(n); i++)\n#define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++)\n#define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--)\n#define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--)\n#define Loopr1(i, n) for(int i = int(n); i >= 1; i--)\n#define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--)\n#define Foreach(buf, container) for(const auto &buf : container)\ntemplate<class T> T reversed(T container) { reverse(container.begin(), container.end()); return container; }\n#define Foreachr(buf, container)  for(const auto &buf : reversed(container))\n#define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++)\n#define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++)\n#define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++)\n#define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--)\n#define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++)\n#define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << \" \"; } cout << endl;\n#define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << \" \"; } cout << endl; }\n#define quickio() ios::sync_with_stdio(false); cin.tie(0);\n#define bitmanip(m,val) static_cast<bitset<(int)m>>(val)\n#define Comp(type_t) bool operator<(const type_t &another) const\n#define fst first\n#define snd second\n#define INF INFINITY\nbool feq(double x, double y) { return abs(x - y) <= eps; }\nbool inrange(ll x, ll t) { return x >= 0 && x < t; }\nbool inrange(vll xs, ll t) { Foreach(x, xs) if (!(x >= 0 && x < t)) return false; return true; }\nint ceillog2(ll x) { return int(ceil(log2(x))); }\nint floorlog2(ll x) { return int(floor(log2(x))); }\nll rndf(double x) { return (ll)(x + (x >= 0 ? 0.5 : -0.5)); }\nll floorsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (m * m <= x ? 0 : -1); }\nll ceilsqrt(ll x) { ll m = (ll)sqrt((double)x); return m + (x <= m * m ? 0 : 1); }\nll rnddiv(ll a, ll b) { return (a / b + (a % b * 2 >= b ? 1 : 0)); }\nll ceildiv(ll a, ll b) { return (a / b + (a % b == 0 ? 0 : 1)); }\nll gcd(ll m, ll n) { if (n == 0) return m; else return gcd(n, m % n); }\nll lcm(ll m, ll n) { return m * n / gcd(m, n); }\n\n//========================================================================//\n\nstruct tree_t {\n\tusing nodeval_t = int;\n\tusing edgeval_t = int;\n\tint n;           // |V|, index begins with 0\n\tvector<P> edges; // E\n\tvector<nodeval_t> vals; // value of nodes\n\tvector<edgeval_t> costs; // cost, distance, or weight of edges\n};\n\n\n// a should be sorted, return will be the root\ntemplate<class val_t, class tree_t>\nint make_treap(const vector<val_t> &a, const tree_t &T, int l = 0, int r = -1, int p = -1) {\n\tif (r == -1) { r = a.size(); T.n = a.size(); }\n\tif (r - l == 0) return -1;\n\tint mid = (l + r) / 2;\n\tif (p != -1) T.edges.push_back({ mid, p });\n\tmake_treap(a, T, l, mid, mid);\n\tmake_treap(a, T, mid + 1, r, mid);\n\treturn mid;\n}\n\n#define ANCESTOR\n#define HLD\nclass Tree {\n\tusing nodeval_t = int;\n\tusing edgeval_t = int;\nprivate:\n\tstruct node {\n\t\tvi childs; int parent = -1;\n\t\tint deg = -1; // the number of edges of the path to the root\n\t\tint eid = -1; // edge id of the edge connected by its parent and itself\n\t\tint subtree_n = 1; // the number of nodes of the partial tree rooted by itself\n#ifdef ANCESTOR\n\t\tint visited = -1; // time stamp of visiting on DFS, call solve_sprs_ancestors() for activation\n\t\tint departed = -1; // time stamp of departure on DFS, call solve_sprs_ancestors() for activation\n#endif\n#ifdef HLD\n\t\tint pid = -1; // path id of heavy light decompotion\n\t\tint qid = -1; // id in its path\n#endif\n\t\tnodeval_t val; // value of the node itself\n\t\tedgeval_t cost; // cost of the edge connected by its parent and itself\n\t};\n\tstruct edgeinfo_t {\n\t\tint eid; int to; edgeval_t cost;\n\t};\n\tint n;\n\tstatic const nodeval_t init_val = 0;\n\tstatic const edgeval_t init_cost = 1;\n#ifdef ANCESTOR\n\tvvi sprs_ancestors; // (1 << j)-th ancestors in each node_id = i\n#endif\n#ifdef HLD\n\tvvi hld_paths; // paths\n#endif\n\tvoid tree_construction(const vector<vector<edgeinfo_t>> &edges) {\n\t\tleaves = {};\n\t\tqueue<int> que;\n\t\tque.push(root);\n\t\twhile (que.size()) {\n\t\t\tint a = que.front(); que.pop();\n\t\t\tdeg_order.push_back(a);\n\t\t\tif (a == Tree::root) nodes[a].deg = 0;\n\t\t\tint leaf_flag = true;\n\t\t\tLoop(i, edges[a].size()) {\n\t\t\t\tint b = edges[a][i].to;\n\t\t\t\tif (nodes[b].deg != -1) {\n\t\t\t\t\tnodes[a].parent = b;\n\t\t\t\t\tnodes[a].eid = edges[a][i].eid;\n\t\t\t\t\tnodes[a].cost = edges[a][i].cost;\n\t\t\t\t\tnodes[a].deg = nodes[b].deg + 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tleaf_flag = false;\n\t\t\t\t\tnodes[a].childs.push_back(b);\n\t\t\t\t\tque.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (leaf_flag) leaves.push_back(a);\n\t\t}\n\t\tLoopr(i, n) {\n\t\t\tint a = deg_order[i];\n\t\t\tLoop(j, nodes[a].childs.size()) {\n\t\t\t\tint b = nodes[a].childs[j];\n\t\t\t\tnodes[a].subtree_n += nodes[b].subtree_n;\n\t\t\t}\n\t\t}\n\t}\npublic:\n\tvector<node> nodes;\n\tvi deg_order; // node ids, sorted by deg\n\tvi leaves;\n\tint root;\npublic:\n\t// T should be non-empty tree\n\tTree(const tree_t &T, int root) {\n\t\tthis->n = T.n;\n\t\tthis->root = root;\n\t\tnodes.resize(n);\n\t\tLoop(i, n) {\n\t\t\tnodes[i].val = (int)(T.vals.size()) > i ? T.vals[i] : init_val;\n\t\t\tnodes[i].cost = init_cost;\n\t\t}\n\t\tvector<vector<edgeinfo_t>> edges(n);\n\t\tLoop(i, n - 1) {\n\t\t\tedges[T.edges[i].fst].push_back({ i, T.edges[i].snd, ((int)(T.costs.size()) > i ? T.costs[i] : init_cost) });\n\t\t\tedges[T.edges[i].snd].push_back({ i, T.edges[i].fst, ((int)(T.costs.size()) > i ? T.costs[i] : init_cost) });\n\t\t}\n\t\ttree_construction(edges);\n\t\treturn;\n\t}\n\tint solve_diameter() {\n\t\tvi d(n, -1);\n\t\tqueue<int> que;\n\t\td[deg_order[n - 1]] = 0;\n\t\tque.push(deg_order[n - 1]);\n\t\twhile (que.size()) {\n\t\t\tint a = que.front(); que.pop();\n\t\t\tint p = nodes[a].parent;\n\t\t\tif (d[p] == -1) {\n\t\t\t\td[p] = d[a] + 1;\n\t\t\t\tque.push(nodes[a].parent);\n\t\t\t}\n\t\t\tForeach(b, nodes[a].childs) {\n\t\t\t\tif (d[b] == -1) {\n\t\t\t\t\td[b] = d[a] + 1;\n\t\t\t\t\tque.push(b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn *max_element(d.begin(), d.end());\n\t}\n\tpair<int, vi> solve_center_of_gravity() {\n\t\tpair<int, vi> ret = { INT_MAX,{} };\n\t\tvi record(n, 1);\n\t\tForeach(a, deg_order) {\n\t\t\tint x = n - 1, max_x = INT_MIN;\n\t\t\tForeach(b, nodes[a].childs) {\n\t\t\t\tmax_x = max(max_x, record[b]);\n\t\t\t\tx -= record[b];\n\t\t\t\trecord[a] += record[b];\n\t\t\t}\n\t\t\tmax_x = max(max_x, x);\n\t\t\tif (max_x < ret.fst) ret = { max_x,{ a } };\n\t\t\telse if (max_x == ret.fst) ret.snd.push_back(a);\n\t\t}\n\t\tsort(ret.snd.begin(), ret.snd.end());\n\t\treturn ret;\n\t}\n\tvi solve_node_inclusion_cnt_in_all_path(bool enable_single_node_path) {\n\t\tvi ret(n, 0);\n\t\tLoop(i, n) {\n\t\t\tint a = i;\n\t\t\t// desendants to desendants\n\t\t\tForeach(b, nodes[a].childs) {\n\t\t\t\tret[i] += nodes[b].subtree_n * (nodes[a].subtree_n - nodes[b].subtree_n - 1);\n\t\t\t}\n\t\t\tret[i] /= 2; // because of double counting\n\t\t\tret[i] += (nodes[a].subtree_n - 1) * (n - nodes[a].subtree_n); // desendants to the others except for itself\n\t\t\tret[i] += n - 1; // itself to the others\n\t\t\tif (enable_single_node_path) ret[i]++; // itself\n\t\t}\n\t\treturn ret;\n\t}\n\tvi solve_edge_inclusion_cnt_in_all_path() {\n\t\tvi ret(n - 1, 0);\n\t\tLoop(i, n) {\n\t\t\tint eid = nodes[i].eid;\n\t\t\tif (eid < 0) continue;\n\t\t\tret[eid] = nodes[i].subtree_n * (n - nodes[i].subtree_n); // members in the partial tree to the others\n\t\t}\n\t\treturn ret;\n\t}\n#ifdef ANCESTOR\n\tvoid solve_sprs_ancestors() {\n\t\tsprs_ancestors.resize(n);\n\t\tvector<int> current_ancestors;\n\t\tstack<int> stk;\n\t\tstk.push(Tree::root);\n\t\tint time_stamp = 0;\n\t\twhile (stk.size()) {\n\t\t\tint a = stk.top(); stk.pop();\n\t\t\tnodes[a].visited = time_stamp++;\n\t\t\tfor (int i = 1; i <= (int)(current_ancestors.size()); i *= 2) {\n\t\t\t\tsprs_ancestors[a].push_back(current_ancestors[current_ancestors.size() - i]);\n\t\t\t}\n\t\t\tif (nodes[a].childs.size()) {\n\t\t\t\tLoop(i, nodes[a].childs.size()) {\n\t\t\t\t\tstk.push(nodes[a].childs[i]);\n\t\t\t\t}\n\t\t\t\tcurrent_ancestors.push_back(a);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tnodes[a].departed = time_stamp++;\n\t\t\t\twhile (current_ancestors.size() && (stk.empty() || nodes[stk.top()].parent != current_ancestors.back())) {\n\t\t\t\t\tnodes[current_ancestors.back()].departed = time_stamp++;\n\t\t\t\t\tcurrent_ancestors.pop_back();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn;\n\t}\n\tbool is_ancestor(int descendant, int ancestor) {\n\t\treturn nodes[ancestor].visited < nodes[descendant].visited\n\t\t\t&& nodes[descendant].departed < nodes[ancestor].departed;\n\t}\n\tint get_lowest_common_ancestor(int u, int v) {\n\t\tif (u == v) return u;\n\t\tif (is_ancestor(u, v)) return v;\n\t\tif (is_ancestor(v, u)) return u;\n\t\tint a = u;\n\t\twhile (!is_ancestor(v, sprs_ancestors[a][0])) {\n\t\t\tint b = sprs_ancestors[a][0];\n\t\t\tLoop1(i, sprs_ancestors[a].size() - 1) {\n\t\t\t\tif (is_ancestor(v, sprs_ancestors[a][i])) break;\n\t\t\t\telse b = sprs_ancestors[a][i - 1];\n\t\t\t}\n\t\t\ta = b;\n\t\t}\n\t\treturn sprs_ancestors[a][0];\n\t}\n\tint get_ancestor(int descendant, int k) {\n\t\tif (k == 0) return descendant;\n\t\tint l = (int)log2(k);\n\t\tif (l >= sprs_ancestors[descendant].size()) return -1;\n\t\telse return get_ancestor(sprs_ancestors[descendant][l], k - (1 << l));\n\t}\n\t// return first value causing \"t\" in evalfunc that returns descendant->[f,...,f,t,...,t]->root\n\t// NOTE: if [f,...,f] then return -1\n\ttemplate<typename bsargv_t>\n\tint binary_search_upper_ancestor(int descendant, const bsargv_t &bsargv, bool(*evalfunc)(int, const bsargv_t&)) {\n\t\tif (evalfunc(descendant, bsargv)) return descendant;\n\t\tif (descendant == root) return -1;\n\t\tLoop(i, sprs_ancestors[descendant].size()) {\n\t\t\tif (evalfunc(sprs_ancestors[descendant][i], bsargv)) {\n\t\t\t\tif (i == 0) return binary_search_upper_ancestor(sprs_ancestors[descendant][0], bsargv, evalfunc);\n\t\t\t\telse return binary_search_upper_ancestor(sprs_ancestors[descendant][i - 1], bsargv, evalfunc);\n\t\t\t}\n\t\t}\n\t\treturn binary_search_upper_ancestor(sprs_ancestors[descendant].back(), bsargv, evalfunc);\n\t}\n\t// return last value causing \"t\" in evalfunc that returns descendant->[t,...,t,f,...,f]->root\n\t// NOTE: if [f,...,f] then return -1\n\ttemplate<typename bsargv_t>\n\tint binary_search_lower_ancestor(int descendant, const bsargv_t &bsargv, bool(*evalfunc)(int, const bsargv_t&)) {\n\t\tif (!evalfunc(descendant, bsargv)) return -1;\n\t\tif (descendant == root) return root;\n\t\tLoop(i, sprs_ancestors[descendant].size()) {\n\t\t\tif (!evalfunc(sprs_ancestors[descendant][i], bsargv)) {\n\t\t\t\tif (i == 0) return descendant;\n\t\t\t\telse return binary_search_lower_ancestor(sprs_ancestors[descendant][i - 1], bsargv, evalfunc);\n\t\t\t}\n\t\t}\n\t\treturn binary_search_lower_ancestor(sprs_ancestors[descendant].back(), bsargv, evalfunc);\n\t}\n\t// static bool evalfunc(int id, bsargv_t bsargv);\n#endif\n#ifdef HLD\n\tvoid solve_hld() {\n\t\tForeach(a, deg_order) {\n\t\t\tif (nodes[a].pid == -1) {\n\t\t\t\tnodes[a].pid = int(hld_paths.size());\n\t\t\t\tnodes[a].qid = 0;\n\t\t\t\thld_paths.push_back({ a });\n\t\t\t}\n\t\t\tint max_id = -1;\n\t\t\tint max_subtree_n = 0;\n\t\t\tForeach(b, nodes[a].childs) {\n\t\t\t\tif (nodes[b].subtree_n > max_subtree_n) {\n\t\t\t\t\tmax_id = b;\n\t\t\t\t\tmax_subtree_n = nodes[b].subtree_n;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (max_id == -1) continue;\n\t\t\tnodes[max_id].pid = nodes[a].pid;\n\t\t\tnodes[max_id].qid = nodes[a].qid + 1;\n\t\t\thld_paths[nodes[a].pid].push_back(max_id);\n\t\t}\n\t}\n\tstruct pathinfo_t {\n\t\tint id;\n\t\tint l, r; // [l, r)\n\t};\n\t// if weight is for each node, include_lca = true\n\t// if weight is for each edge, include_lca = false\n\tvector<pathinfo_t> get_path_in_hld(int u, int v, bool include_lca) {\n\t\tvector<pathinfo_t> ret;\n\t\tint w = get_lowest_common_ancestor(u, v);\n\t\tif (include_lca && u == v) {\n\t\t\tret.push_back({ nodes[w].pid, nodes[w].qid, nodes[w].qid + 1 });\n\t\t}\n\t\telse {\n\t\t\tForeach(x, vector<int>({ u, v })) {\n\t\t\t\tint a = x;\n\t\t\t\twhile (a != w) {\n\t\t\t\t\tif (nodes[a].pid != nodes[w].pid) {\n\t\t\t\t\t\tret.push_back({ nodes[a].pid, 0, nodes[a].qid + 1 });\n\t\t\t\t\t\ta = nodes[hld_paths[nodes[a].pid][0]].parent;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tret.push_back({ nodes[a].pid, nodes[w].qid + (include_lca ? 0 : 1), nodes[a].qid + 1 });\n\t\t\t\t\t\ta = w;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\tvi get_hldpathsize() {\n\t\tvi ret(hld_paths.size());\n\t\tLoop(i, hld_paths.size()) {\n\t\t\tret[i] = int(hld_paths[i].size());\n\t\t}\n\t\treturn ret;\n\t}\n#endif\n};\n\nclass SegTreeSum {\n\tusing val_t = ll;\nprivate:\n\tstruct segval_t {\n\t\tbool enable;\n\t\tval_t upd, add, sum;\n\t};\n\tint n, N; // n is the original size, while N is the extended size\n\tint base;\n\tvector<segval_t> nodes;\n\tvi idl, idr, cover_size;\n\tvoid merge(int id) {\n\t\tnodes[id].sum = nodes[idl[id]].sum + nodes[idl[id]].add * cover_size[idl[id]]\n\t\t\t+ nodes[idr[id]].sum + nodes[idr[id]].add * cover_size[idr[id]];\n\t}\n\tvoid lazy(int id) {\n\t\tif (id >= base) return;\n\t\tif (nodes[id].enable) {\n\t\t\tval_t upd = nodes[id].upd + nodes[id].add;\n\t\t\tnodes[idl[id]] = { true, upd, 0, upd * cover_size[idl[id]] };\n\t\t\tnodes[idr[id]] = { true, upd, 0, upd * cover_size[idr[id]] };\n\t\t\tnodes[id] = { false, 0, 0, upd * cover_size[id] };\n\t\t}\n\t\telse {\n\t\t\tnodes[idl[id]].add += nodes[id].add;\n\t\t\tnodes[idr[id]].add += nodes[id].add;\n\t\t\tnodes[id].add = 0;\n\t\t\tmerge(id);\n\t\t}\n\t}\n\tenum change_t {\n\t\tUPD, ADD\n\t};\n\tvoid change_rec(int s, int t, int l, int r, int id, val_t x, change_t op) {\n\t\tif (s == l && t == r) {\n\t\t\tif (op == UPD) nodes[id] = { true, x, 0, x * cover_size[id] };\n\t\t\tif (op == ADD) nodes[id].add += x;\n\t\t}\n\t\telse {\n\t\t\tlazy(id);\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (s < m && m < t) {\n\t\t\t\tchange_rec(s, m, l, m, idl[id], x, op);\n\t\t\t\tchange_rec(m, t, m, r, idr[id], x, op);\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tchange_rec(s, t, l, m, idl[id], x, op);\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tchange_rec(s, t, m, r, idr[id], x, op);\n\t\t\t}\n\t\t\tmerge(id);\n\t\t}\n\t}\n\tval_t solve_rec(int s, int t, int l, int r, int id) {\n\t\tval_t v = 0;\n\t\tif (s == l && t == r) {\n\t\t\tv = nodes[id].sum;\n\t\t}\n\t\telse {\n\t\t\tlazy(id);\n\t\t\tint m = (l + r) >> 1;\n\t\t\tif (s < m && m < t) {\n\t\t\t\tval_t v0 = solve_rec(s, m, l, m, idl[id]);\n\t\t\t\tval_t v1 = solve_rec(m, t, m, r, idr[id]);\n\t\t\t\tv = v0 + v1;\n\t\t\t}\n\t\t\telse if (s < m) {\n\t\t\t\tv = solve_rec(s, t, l, m, idl[id]);\n\t\t\t}\n\t\t\telse if (m < t) {\n\t\t\t\tv = solve_rec(s, t, m, r, idr[id]);\n\t\t\t}\n\t\t}\n\t\tv += nodes[id].add * (t - s);\n\t\treturn v;\n\t}\n\tvoid common_init() {\n\t\tidl.resize(base + N, -1);\n\t\tidr.resize(base + N, -1);\n\t\tLoop(i, base) {\n\t\t\tidl[i] = (i << 1) + 1;\n\t\t\tidr[i] = (i << 1) + 2;\n\t\t}\n\t\tcover_size.resize(base + N);\n\t\tLoop(i, n) {\n\t\t\tcover_size[base + i] = 1;\n\t\t}\n\t\tLoopr(i, base) {\n\t\t\tcover_size[i] = cover_size[idl[i]] + cover_size[idr[i]];\n\t\t}\n\t}\npublic:\n\tSegTreeSum(int n, val_t init = 0) {\n\t\tthis->n = n;\n\t\tN = 1 << ceillog2(n);\n\t\tbase = N - 1;\n\t\tnodes = vector<segval_t>(base + N, { false, 0, 0, 0 });\n\t\tcommon_init();\n\t\tupd(0, n, init);\n\t}\n\tSegTreeSum(const vector<val_t> &a) {\n\t\tthis->n = int(a.size());\n\t\tN = 1 << ceillog2(n);\n\t\tbase = N - 1;\n\t\tnodes = vector<segval_t>(base + N, { false, 0, 0, 0 });\n\t\tcommon_init();\n\t\tLoop(i, n) {\n\t\t\tnodes[base + i] = { true, a[i], 0, a[i] };\n\t\t}\n\t\tLoopr(i, base) {\n\t\t\tmerge(i);\n\t\t}\n\t}\n\tvoid upd(int s, int t, val_t x) {\n\t\tif (s >= t) return;\n\t\tchange_rec(s, t, 0, N, 0, x, UPD);\n\t}\n\tvoid add(int s, int t, val_t x) {\n\t\tif (s >= t) return;\n\t\tchange_rec(s, t, 0, N, 0, x, ADD);\n\t}\n\tval_t sumof(int s, int t) {\n\t\tif (s >= t) return 0;\n\t\treturn solve_rec(s, t, 0, N, 0);\n\t}\n};\n\nint main() {\n\tquickio();\n\ttree_t T;\n\tcin >> T.n;\n\tLoop(i, T.n) {\n\t\tint k; cin >> k;\n\t\tLoop(_, k) {\n\t\t\tint c; cin >> c;\n\t\t\tT.edges.push_back({ i, c });\n\t\t}\n\t}\n\tTree *tree = new Tree(T, 0);\n\ttree->solve_sprs_ancestors();\n\ttree->solve_hld();\n\tvi ps = tree->get_hldpathsize();\n\tvector<SegTreeSum*> sts(ps.size());\n\tLoop(i, sts.size()) sts[i] = new SegTreeSum(ps[i]);\n\tint q; cin >> q;\n\tLoop(_, q) {\n\t\tint op; cin >> op;\n\t\tif (op == 0) {\n\t\t\tint v, w; cin >> v >> w;\n\t\t\tauto paths = tree->get_path_in_hld(tree->nodes[v].parent, v, false);\n\t\t\tForeach(path, paths) {\n\t\t\t\tsts[path.id]->add(path.l, path.r, w);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tint u; cin >> u;\n\t\t\tauto paths = tree->get_path_in_hld(u, 0, false);\n\t\t\tll ans = 0;\n\t\t\tForeach(path, paths) {\n\t\t\t\tans += sts[path.id]->sumof(path.l, path.r);\n\t\t\t}\n\t\t\tcout << ans << endl;\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n// LinkCutTree\n// 各Heavy-edge連結成分を表すBSTをin-orderで捜査すると、元のパスになる\ntemplate<typename Monoid = int, typename OperatorMonoid = Monoid>\nstruct LinkCutTree {\n  using F = function<Monoid(Monoid, Monoid)>;\n  using G = function<Monoid(Monoid, OperatorMonoid, int)>;\n  using H = function<OperatorMonoid(OperatorMonoid, OperatorMonoid)>;\n\n  struct Node {\n    Node *l, *r, *p;\n    int idx;\n    Monoid key, sum;\n    OperatorMonoid lazy;\n\n    bool rev;\n    int sz;\n\n    Node(int idx, const Monoid& key, const OperatorMonoid &om):l(nullptr), r(nullptr), p(nullptr), idx(idx), key(key), sum(key), lazy(om), rev(false), sz(1) {}\n\n    bool is_root() {\n      return !p || (p->l != this && p->r != this);\n    }\n  };\n\n  const F f;\n  const G g;\n  const H h;\n  const Monoid M1;\n  const OperatorMonoid OM0;\n\n  LinkCutTree():LinkCutTree([](Monoid a, Monoid b) {return a+b;}, Monoid()) {}\n  LinkCutTree(const F &f, const Monoid &M1):LinkCutTree(f, G(), H(), M1, OperatorMonoid()) {}\n  LinkCutTree(const F &f, const G &g, const H &h, const Monoid &M1, const OperatorMonoid &OM0):f(f), g(g), h(h), M1(M1), OM0(OM0) {}\n\n  Node *make_node(int idx, const Monoid &v = Monoid()) {\n    return new Node(idx, v, OM0);\n  }\n\n  void propagate(Node *t, const OperatorMonoid &x) {\n    t->lazy = h(t->lazy, x);\n    t->key = g(t->key, x, 1);\n    t->sum = g(t->sum, x, t->sz);\n  }\n\n  void toggle(Node *t) {\n    assert(t);\n    swap(t->l, t->r);\n    /*ここに反転処理*/\n    t->rev ^= true;\n  }\n\n  void push(Node *t) {\n    if(t->lazy != OM0) {\n      if(t->l) propagate(t->l, t->lazy);\n      if(t->r) propagate(t->r, t->lazy);\n      t->lazy = OM0;\n    }\n    if(t->rev) {\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev = false;\n    }\n  }\n\n  void update(Node *t) {\n    t->sz = 1;\n    t->sum = t->key;\n    if(t->l) t->sz += t->l->sz, t->sum = f(t->l->sum, t->sum);\n    if(t->r) t->sz += t->r->sz, t->sum = f(t->sum, t->r->sum);\n  }\n\n  void rotr(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if((x->l = t->r)) t->r->p = x;\n    t->r = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void rotl(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if((x->r = t->l)) t->l->p = x;\n    t->l = x, x->p = t;\n    update(x), update(t);\n    if((t->p = y)) {\n      if(y->l == x) y->l = t;\n      if(y->r == x) y->r = t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t) {\n    push(t);\n    while(!t->is_root()) {\n      auto *q = t->p;\n      if(q->is_root()) { // zig\n\tpush(q), push(t);\n\tif(q->l == t) rotr(t);\n\telse rotl(t);\n      } else {\n\tauto *r = q->p;\n\tpush(r), push(q), push(t);\n\tif(r->l == q) {\n\t  if(q->l == t) rotr(q), rotr(t); // zig zig\n\t  else rotl(t), rotr(t); // zig zag\n\t} else {\n\t  if(q->r == t) rotl(q), rotl(t); // zig zig\n\t  else rotr(t), rotl(t); // zig zag\n\t}\n      }\n    }\n  }\n\n  Node *expose(Node *t) {\n    Node *rp = nullptr;\n    for(Node *cur = t; cur; cur = cur->p /*Light-edgeで移動*/) {\n      splay(cur); \n      cur->r = rp; // Heavy-edgeでつなぐ(元のHeavy-edgeは切れる)\n      update(cur);\n      rp = cur;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *child, Node *parent) {\n    expose(child);\n    expose(parent);\n    child->p = parent;\n    parent->r = child;\n  }\n\n  void cut(Node *child) {\n    expose(child);\n    auto *parent = child->l;\n    child->l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert(Node *t) {\n    expose(t);\n    toggle(t);\n    push(t);\n  }\n\n  Node *lca(Node *u, Node *v) {\n    expose(u);\n    return expose(v);\n  }\n\n  vector<int> get_path(Node *x) {\n    vector<int> vs;\n    function<void(Node*)> dfs = [&](Node *cur) {\n      if(!cur) return;\n      dfs(cur->r);\n      vs.push_back(cur->idx);\n      dfs(cur->l);\n    };\n    expose(x);\n    dfs(x);\n    return vs;\n  }\n\n  void set_propagate(Node *t, const OperatorMonoid &x) {\n    expose(t);\n    propagate(t, x);\n    push(t);\n  }\n};\n\nint main() {\n  int n;\n  cin >> n;\n  LinkCutTree<> tree;\n  vector<LinkCutTree<>::Node*> nodes(n);\n  for(int i = 0; i < n; ++i) nodes[i] = tree.make_node(i);\n  for(int i = 0; i < n; ++i) {\n    int k;\n    cin >> k;\n    while(k--) {\n      int c;\n      cin >> c;\n      tree.link(nodes[c], nodes[i]);\n    }\n  }\n  int q;\n  cin >> q;\n  while(q--) {\n    int k;\n    cin >> k;\n    if(k) {\n      int u;\n      cin >> u;\n      tree.expose(nodes[u]);\n      cout << nodes[u]->sum << endl;\n    } else {\n      int v, w;\n      cin >> v >> w;\n      tree.expose(nodes[v]);\n      nodes[v]->key += w;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nstruct RSQ{\n  ll n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 1 index\n  /*void add(int i,int v){\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }*/\n  // 0 index\n  void add(int i,ll v){\n    i+=1;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  ll sum(int i){\n    ll res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) 1 index\n  /*int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }*/\n  //[a,b) 0 index\n  int sum(int x,int y){\n    x++;y++;\n    return sum(y-1)-sum(x-1);\n  }\n};\n \nstruct HLD {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  RSQ rsq;\n\n  HLD(){}\n  HLD(int sz):n(sz),pos(0),G(n),vid(n,-1),head(n),sub(n,1),hvy(n,-1),par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int i=0;i<rs.size();i++){\n        int r=rs[i];\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    stack<P> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n        int v=st.top().first;\n        int &i=st.top().second;\n        if(i<(int)G[v].size()){\n            int u=G[v][i++];\n            if(u==par[v]) continue;\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            st.emplace(P(u,0));\n        }else{\n            st.pop();\n            int res=0;\n            for(int i=0;i<G[v].size();i++){\n                int u=G[v][i];\n                if(u==par[v]) continue;\n                sub[v]+=sub[u];\n                if(res<sub[u]) res=sub[u],hvy[v]=u;\n            }\n        }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n        type[i]=c;\n        vid[i]=k++;\n        inv[vid[i]]=i;\n        head[i]=h;\n        for(int J=0;J<G[i].size();J++){\n            int j=G[i][J];\n            if(j!=par[i]&&j!=hvy[i]) q.push(j);\n        }\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  int for_each(int u, int v) {\n    int ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      //f(max(vid[head[v]],vid[u]),vid[v]);\n      //ans = max(ans,rmq.query(l, r + 1));\n      if(head[u]!=head[v]) v=par[head[v]];\n      else {return ans;}\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  ll for_each_edge(int u, int v) {\n    ll ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n        //f(vid[head[v]],vid[v]);\n        ans += rsq.sum(vid[head[v]],vid[v]+1);\n        v=par[head[v]];\n      } else{\n        //if(u!=v) f(vid[u]+1,vid[v]);\n        if(u!=v) ans += rsq.sum(vid[u]+1,vid[v]+1);\n        return ans;\n      }\n    }\n  }\n\n  void update(int u,int w){\n    rsq.add(vid[u],w);\n  }\n\n  void range_update(){\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\nint main(){\n    int n,m,x,w;\n    scanf(\"%d\",&n);\n    HLD Tree(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&x);\n            Tree.add_edge(i,x);\n        }\n    }\n    Tree.build();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        if(m==0){\n            scanf(\"%d%d\",&x,&w);\n            Tree.update(x,w);\n        }\n        else{\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",Tree.for_each_edge(0,x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <functional>\n#include <stack>\n\ntemplate<class T>\nstruct segment_tree {\n\tusing value_type = T;\n\tusing F = std::function<T(T, T)>;\nprivate : \n\tint n;\n\tF f;\n\tvalue_type ie;\n\tstd::vector<value_type> node;\n\npublic : \n\tsegment_tree () { }\n\n\tsegment_tree (const F &f, const value_type &ie) : f(f), ie(ie) { }\n\n\tvoid reset (const F &f, const value_type &ie) noexcept {\n\t\t(this->f) = f;\n\t\t(this->ie) = ie;\n\t}\n\n\tvoid assign (int _n) noexcept {\n\t\tn = 1;\n\t\twhile (n < _n) n <<= 1;\n\t\tnode.resize(2 * n);\n\t\tstd::fill(node.begin(), node.end(), ie);\n\t}\n\n\tvoid assign (int _n, const value_type &e) noexcept {\n\t\tassign(_n);\n\t\tfor (int i = n; i < 2 * n; i++) node[i] = e;\n\t\tfor (int i = n; i--> 0;) {\n\t\t\tnode[i] = f(node[i << 1 | 0], node[i << 1 | 1]);\n\t\t}\n\t}\n\n\ttemplate<class iter>\n\tvoid build (iter l, iter r) {\n\t\tassign(r - l);\n\t\tfor (int i = n; l != r; i++, l++) node[i] = *l;\n\t\tfor (int i = n; i--> 0;) {\n\t\t\tnode[i] = f(node[i << 1 | 0], node[i << 1 | 1]);\n\t\t}\n\t}\n\n\ttemplate<class data_list>\n\tvoid build (const data_list &rhs) {\n\t\tbuild(rhs.begin(), rhs.end());\n\t}\n\n\tvoid set_val (int i, const value_type &x) {\n\t\ti += n;\n\t\tnode[i] = x;\n\t\tfor (i >>= 1; i > 0; i >>= 1) {\n\t\t\tnode[i] = f(node[i << 1 | 0], node[i << 1 | 1]);\n\t\t}\n\t}\n\n\tconstexpr value_type fold (int l, int r) {\n\t\tvalue_type vl = ie, vr = ie;\n\t\tfor (l += n, r += n; l < r; l >>= 1, r >>= 1) {\n\t\t\tif (l & 1) vl = f(vl, node[l++]);\n\t\t\tif (r & 1) vr = f(node[--r], vr);\n\t\t}\n\t\treturn f(vl, vr);\n\t};\n\n\tconstexpr const value_type& fold_all() const {\n\t\treturn (node[1]);\n\t}\n\n\tconstexpr const value_type& operator[] (int i) const {\n\t\treturn node[i + n];\n\t}\n\n\tconstexpr const value_type& at (int i) const {\n\t\treturn node.at(i + n);\n\t}\n\n\tvoid swap (segment_tree<value_type> &rhs) {\n\t\t(this->node).swap(rhs.node);\n\t}\n\n};\n\nint main() {\n\tstd::ios::sync_with_stdio(false);\n\tstd::cin.tie(nullptr);\n\t\n\tstd::size_t n;\n\tstd::cin >> n;\n\tstd::vector<std::vector<int>> g(n);\n\tfor (std::size_t p = 0; p < n; p++) {\n\t\tint sz;\n\t\tstd::cin >> sz;\n\t\twhile (sz--) {\n\t\t\tint v;\n\t\t\tstd::cin >> v;\n\t\t\tg[p].push_back(v);\n\t\t}\n\t}\n\t\n\tstd::size_t size = 0;\n\tstd::vector<int> idx1(n, -1), idx2(n, -1);\n\t{\n\t\tstd::vector<bool> status(n, false);\n\t\tstd::stack<int> sta;\n\t\tsta.push(0);\n\t\twhile (not sta.empty()) {\n\t\t\tint v = sta.top();\n\t\t\tif (status[v] == false) {\n\t\t\t\tidx1[v] = size++;\n\t\t\t\tstatus[v] = true;\n\t\t\t\tfor (int u : g[v]) sta.push(u);\n\t\t\t} else {\n\t\t\t\tsta.pop();\n\t\t\t\tidx2[v] = size++;\n\t\t\t}\n\t\t}\n\t}\n\t\n\tsegment_tree<int> seg([](int a, int b) { return (a + b); }, 0);\n\tseg.assign(size);\n\t\n\tint query;\n\tstd::cin >> query;\n\twhile (query--) {\n\t\tint type;\n\t\tstd::cin >> type;\n\t\tif (type == 0) {\n\t\t\tint v, w;\n\t\t\tstd::cin >> v >> w;\n\t\t\tint u = idx1[v], d = idx2[v];\n\t\t\tseg.set_val(u, seg[u] + w);\n\t\t\tseg.set_val(d, seg[d] - w);\n\t\t} else {\n\t\t\tint v;\n\t\t\tstd::cin >> v;\n\t\t\tstd::cout << seg.fold(0, idx1[v] + 1) << '\\n';\n\t\t}\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define endl '\\n'\n#define MOD 1000000007\n#define maxn 300010\n\nvector<int> g[maxn];\nint first[maxn], second[maxn], bit[maxn];\nvector<int> euler;\n\nvoid update(int idx, int val) {\n    while (idx <= euler.size()) {\n        bit[idx] += val;\n        idx += idx & -idx;\n    }\n}\n\nint pref(int idx) {\n    int ans = 0;\n    while (idx > 0) {\n        ans += bit[idx];\n        idx -= idx & -idx;\n    }\n    return ans;\n}\n\nvoid dfs(int u, int p = -1) {\n    first[u] = euler.size() + 1;\n    euler.push_back(u);\n    for (auto x : g[u]) {\n        if (x != p) {\n            dfs(x, u);\n        }\n    }\n    second[u] = euler.size() + 1;\n    euler.push_back(u);\n}\n\nvoid solve() {\n    int n;\n    cin >> n;\n\n    for (int i = 0; i < n; i++) {\n        int k;\n        cin >> k;\n\n        for (int j = 0; j < k; j++) {\n            int tp;\n            cin >> tp;\n\n            g[i].push_back(tp);\n            g[tp].push_back(i);\n        }\n    }\n\n    dfs(0, 0);\n    int q;\n    cin >> q;\n\n    for (int i = 0; i < q; i++) {\n        int type;\n        cin >> type;\n\n        if (!type) {\n            int v, w;\n            cin >> v >> w;\n\n            update(first[v], w);\n            update(second[v], -w);\n        } else {\n            int u;\n            cin >> u;\n\n            cout << pref(first[u]) << endl;\n        }\n    }\n}\n\nint32_t main() {\n    ios_base::sync_with_stdio(false);\n    cin.tie(nullptr);\n\n    int t = 1;\n//    cin >> t;\n\n    while (t--)\n        solve();\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing lint = long long;\ntemplate<class T = int> using V = vector<T>;\ntemplate<class T = int> using VV = V< V<T> >;\n\ntemplate<class T> struct FenwickTree {\n  const int n;\n  V<T> t;\n  FenwickTree(int n) : n(n), t(n + 1) {}\n  void add(int i, T x) { for (++i; i <= n; i += i & -i) t[i] += x; }\n  T sum(int i) const {\n    T s = 0;\n    for (; i; i -= i & -i) s += t[i];\n    return s;\n  }\n  T sum(int l, int r) const { return sum(r) - sum(l); }\n};\n\n// BEGIN CUT HERE\nstruct HeavyLightDecomposition {\n  const int n;\n  VV<> g;\n  V<> sz, par, in, out, anc;\n  HeavyLightDecomposition(VV<>& g, int r = 0) : n(g.size()), g(g), sz(n), par(n), in(n), out(n), anc(n) {\n    dfs_sz(r, -1);\n    anc[r] = r;\n    dfs_hl(r);\n  }\n  void dfs_sz(int v, int p) {\n    par[v] = p;\n    for (auto&& w : g[v]) if (w == p) {\n      swap(w, g[v].back());\n      g[v].pop_back();\n      break;\n    }\n    sz[v] = 1;\n    for (auto&& w : g[v]) {\n      dfs_sz(w, v);\n      sz[v] += sz[w];\n      if (sz[w] > sz[g[v][0]]) swap(w, g[v][0]);\n    }\n  }\n  void dfs_hl(int v) {\n    static int t = 0;\n    in[v] = t++;\n    for (int w : g[v]) {\n      anc[w] = w == g[v][0] ? anc[v] : w;\n      dfs_hl(w);\n    }\n    out[v] = t;\n  }\n  int lca(int u, int v) {\n    while (true) {\n      if (in[u] > in[v]) swap(u, v);\n      if (anc[u] == anc[v]) return u;\n      v = par[anc[v]];\n    }\n  }\n};\n// END CUT HERE\n\nint main() {\n  cin.tie(nullptr); ios::sync_with_stdio(false);\n  int n; cin >> n;\n  VV<> g(n);\n  for (int v = 0; v < n; ++v) {\n    int k; cin >> k;\n    while (k--) {\n      int c; cin >> c;\n      g[v].push_back(c);\n    }\n  }\n  HeavyLightDecomposition hld(g);\n  FenwickTree<lint> ft(n);\n  int q; cin >> q;\n  while (q--) {\n    int tp; cin >> tp;\n    if (!tp) {\n      int v, w; cin >> v >> w;\n      ft.add(hld.in[v], w);\n    } else {\n      int v; cin >> v;\n      int u = 0;\n      lint res = 0;\n      while (true) {\n        if (hld.in[u] > hld.in[v]) swap(u, v);\n        if (hld.anc[u] == hld.anc[v]) break;\n        res += ft.sum(hld.in[hld.anc[v]], hld.in[v] + 1);\n        v = hld.par[hld.anc[v]];\n      }\n      res += ft.sum(hld.in[u] + 1, hld.in[v] + 1);\n      cout << res << '\\n';\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nclass BIT{\npublic:\n  typedef long long ll;\n  ll n;\n  vector<ll> bit0, bit1;\n  BIT(){n=-1;}\n  BIT(ll n_){\n    n=1;\n    while(n<n_)n*=2;\n    bit0.resize(n+1,0);\n    bit1.resize(n+1,0);\n  }\n  \n  ll sum(vector<ll> &b,ll i){\n    ll s=0;\n    while(i>0){\n      s=(s+b[i]);\n      i-=i&-i;\n    }\n    return s;\n  }\n\n  void add(vector<ll> &b,ll i,ll v){\n    while(i<=n){\n      b[i]=(b[i]+v);\n      i+=i&-i;\n    }\n  }\n\n  //[a,b]にxを加算(1<=a)\n  void add (ll a,ll b,ll x){\n    assert(a > 0 && n >= 0);\n\n    add(bit0,a,-x*(a-1));\n    add(bit1,a,x);\n    add(bit0,b+1,x*b);\n    add(bit1,b+1,-x);\n  }\n\n  //[a,b]のsumを得る(1<=a)\n  ll sum(ll a,ll b){\n    assert(a > 0 && n >= 0);\n    ll res=0;\n    res+=sum(bit0,b)+sum(bit1,b)*b;\n    res-=sum(bit0,a-1)+sum(bit1,a-1)*(a-1);\n    return res;\n  }\n};\n\nvector<int> G[100005];\nvector<int> order;\nint s[100005], t[100005];\n\nvoid dfs(int x){\n  \n  s[x]=(int)order.size()+1;\n  \n  order.push_back(x);\n  \n  for(int i=0;i<G[x].size();i++) dfs(G[x][i]);\n\n  t[x]=(int)order.size()+1;\n}\n\nint main(){\n  \n  int n;  \n  cin>>n;\n  \n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      G[i].push_back(c);\n  \n    }\n  }\n\n  dfs(0);\n\n  BIT bit=BIT(n);\n  \n  int q;\n  cin>>q;\n  \n  while(q--){\n    \n    int a;\n    cin>>a;\n\n    if(a==0){\n      int v, w;\n      cin>>v>>w;\n      bit.add(s[v], t[v], w);\n    }\n    else{\n      int u;\n      cin>>u;\n      cout<<bit.sum(s[u], s[u])<<endl;\n    }\n    \n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n\nstruct HLDecomposition {\n  Int n,pos;\n  vector<vector<Int> > G;\n  vector<Int> vid, head, sub, hvy, par, dep, inv, type;\n  \n  HLDecomposition(){}\n  HLDecomposition(Int sz):\n    n(sz),pos(0),G(n),\n    vid(n,-1),head(n),sub(n,1),hvy(n,-1),\n    par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(Int u, Int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<Int> rs={0}) {\n    Int c=0;\n    for(Int r:rs){\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(Int rt) {\n    using T = pair<Int, Int>;\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n      Int v=st.top().first;\n      Int &i=st.top().second;\n      if(i<(Int)G[v].size()){\n\tInt u=G[v][i++];\n\tif(u==par[v]) continue;\n\tpar[u]=v;\n\tdep[u]=dep[v]+1;\n\tst.emplace(u,0);\n      }else{\n\tst.pop();\n\tInt res=0;\n\tfor(Int u:G[v]){\n\t  if(u==par[v]) continue;\n\t  sub[v]+=sub[u];\n\t  if(res<sub[u]) res=sub[u],hvy[v]=u;\n\t}\n      }\n    }\n  }\n\n  void bfs(Int r,Int c) {\n    Int &k=pos;\n    queue<Int> q({r});\n    while(!q.empty()){\n      Int h=q.front();q.pop();\n      for(Int i=h;i!=-1;i=hvy[i]) {\n\ttype[i]=c;\n\tvid[i]=k++;\n\tinv[vid[i]]=i;\n\thead[i]=h;\n\tfor(Int j:G[i])\n\t  if(j!=par[i]&&j!=hvy[i]) q.push(j);\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  void for_each(Int u, Int v, const function<void(Int, Int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      f(max(vid[head[v]],vid[u]),vid[v]);\n      if(head[u]!=head[v]) v=par[head[v]];\n      else break;\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  void for_each_edge(Int u, Int v, const function<void(Int, Int)>& f) {\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n\tf(vid[head[v]],vid[v]);\n        v=par[head[v]];\n      } else{\n\tif(u!=v) f(vid[u]+1,vid[v]);\n\tbreak;\n      }\n    }\n  }\n\n  Int lca(Int u,Int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  Int distance(Int u,Int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\n\n\ntemplate <typename T,typename E>\nstruct SegmentTree{\n  typedef function<T(T,T)> F;\n  typedef function<T(T,E)> G;\n  Int n;\n  F f;\n  G g;\n  T d1;\n  E d0;\n  vector<T> dat;\n  SegmentTree(){};\n  SegmentTree(Int n_,F f,G g,T d1,\n\t      vector<T> v=vector<T>()):\n    f(f),g(g),d1(d1){\n    init(n_);\n    if(n_==(Int)v.size()) build(n_,v);\n  }\n  void init(Int n_){\n    n=1;\n    while(n<n_) n*=2;\n    dat.clear();\n    dat.resize(2*n-1,d1);\n  }\n  void build(Int n_, vector<T> v){\n    for(Int i=0;i<n_;i++) dat[i+n-1]=v[i];\n    for(Int i=n-2;i>=0;i--)\n      dat[i]=f(dat[i*2+1],dat[i*2+2]);\n  }\n  void update(Int k,E a){\n    k+=n-1;\n    dat[k]=g(dat[k],a);\n    while(k>0){\n      k=(k-1)/2;\n      dat[k]=f(dat[k*2+1],dat[k*2+2]);\n    }\n  }\n  inline T query(Int a,Int b){\n    T vl=d1,vr=d1;\n    for(Int l=a+n,r=b+n;l<r;l>>=1,r>>=1) {\n      if(l&1) vl=f(vl,dat[(l++)-1]);\n      if(r&1) vr=f(dat[(--r)-1],vr);\n    }\n    return f(vl,vr);\n  }\n\n  Int find(Int a,Int b,function<bool(T)> &check,Int k,Int l,Int r){\n    if(!check(dat[k])||r<=a||b<=l) return -1;\n    if(k>=n-1) return k-(n-1);\n    Int m=(l+r)>>1;\n    Int vl=find(a,b,check,k*2+1,l,m);\n    if(~vl) return vl;\n    return find(a,b,check,k*2+2,m,r);\n  }\n  \n  Int find(Int a,Int b,function<bool(T)> &check){\n    return find(a,b,check,0,0,n);\n  }\n  \n};\n\n//INSERT ABOVE HERE\nsigned main(){\n  Int n;\n  cin>>n;\n  HLDecomposition hld(n);\n  for(Int i=0;i<n;i++){\n    Int k;\n    cin>>k;\n    for(Int j=0;j<k;j++){\n      Int c;\n      cin>>c;\n      hld.add_edge(i,c);\n    }\n  }\n  hld.build();\n  auto G=hld.G;\n  auto vid=hld.vid;\n  auto inv=hld.inv;\n\n  SegmentTree<Int, Int>::F f=[](Int a,Int b){return a+b;};\n  SegmentTree<Int, Int> seg(n,f,f,0);\n  \n  Int q;\n  cin>>q;\n  for(Int i=0;i<q;i++){\n    Int t;\n    cin>>t;\n    if(t==0){\n      Int v,w;\n      cin>>v>>w;\n      seg.update(vid[v],w);\n    }\n    if(t==1){\n      Int u;\n      cin>>u;\n      Int ans=0;\n      hld.for_each_edge(0,u,[&](Int l,Int r){\n\t  ans+=seg.query(l,r+1);\n\t});\n      cout<<ans<<endl;\n    }\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n\nusing namespace std;\n\nconst int N = 1e5+10;\nint bit[2*N+1];\nint sz;\nint l[N],r[N];\nvector<int> G[N];\nint cnt;\n\nvoid init(int n){\n    cnt = 0;\n    sz = 2*n + 1;\n}\n\nvoid dfs(int v){\n    l[v] = ++cnt;\n    for(int i=0;i<G[v].size();i++){\n        int u = G[v][i];\n        dfs(u);\n    }\n    r[v] = ++cnt;\n}\n\nvoid add(int i,int x){\n    while(i<=sz){\n        bit[i] += x;\n        i += i&-i;\n    }\n}\n\nint getSum(int i){\n    int ans = 0;\n    while(i>0){\n        ans += bit[i];\n        i -= i&-i;\n    }\n    return ans;\n}\n\n\nint main(){\n    int n;\n    while(cin>>n){\n        init(n);\n        for(int i=0;i<n;i++){\n            int k;\n            cin>>k;\n            for(int j=0;j<k;j++){\n                int child;\n                cin>>child;\n                G[i].push_back(child);\n            }\n        }\n        dfs(0);\n        int q;\n        cin>>q;\n        for(int i=0;i<q;i++){\n            int op;\n            cin>>op;\n            if(op == 0){\n                int v,w;\n                cin>>v>>w;\n                add(l[v],w);\n                add(r[v],-w);\n            }else{\n                int v;\n                cin>>v;\n                cout<<getSum(r[v] - 1)<<endl;\n            }\n        }\n    }\n\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#pragma GCC optimize(\"Ofast\")\n#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < (n); ++i)\n#define all(x) (x).begin(),(x).end()\n#define ln '\\n'\nconstexpr long long MOD = 1000000007LL;\n//constexpr long long MOD = 998244353LL;\ntypedef long long ll;\ntypedef unsigned long long ull; \ntypedef pair<int, int> pii;\ntypedef pair<long long, long long> pll;\ntemplate<class T> inline bool chmax(T &a, T b) { if (a < b) { a = b; return true;} return false; }\ntemplate<class T> inline bool chmin(T &a, T b) { if (a > b) { a = b; return true;} return false; }\n///////////////////////////////////////////////////////////////////////////////////////////////////\n\ntemplate<typename T>\nstruct edge {\n    int src,to;\n    T cost;\n\n    edge() = default;\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    bool operator<(const edge &e) const {\n        return cost < e.cost;\n    }\n};\n\ntemplate<typename T, typename Monoid>\nstruct SegmentTree {\n    T unity;\n    Monoid merge;\n    int N;\n    vector<T> node;\n\n    SegmentTree(Monoid f, T id) : merge(f), unity(id) {}\n\n    void init(int sz) {\n        N = 1;\n        while (N < sz) N *= 2;\n        node.assign(2*N,unity);\n    }\n\n    void set(int k, const T &val) {node[k+N] = val;}\n\n    void build() {\n        for (int i = N-1; i > 0; --i) {\n            node[i] = merge(node[i<<1|0], node[i<<1|1]);\n        }\n    }\n\n    // (0-indexed)\n    void update(int x, T val) {\n        x += N;\n        node[x] = val;\n        while (x > 1) {\n            x >>= 1;\n            node[x] = merge(node[x<<1|0], node[x<<1|1]);\n        }\n    }\n\n    // [l, r) (0-indexed)\n    T get(int l, int r) {\n        if (l >= r) return unity;\n        T resl = unity, resr = unity;\n        l += N; r += N;\n        while (l < r) {\n            if (l & 1) resl = merge(resl, node[l++]);\n            l >>= 1;\n            if (r & 1) resr = merge(node[--r], resr);\n            r >>= 1;\n        }\n        return merge(resl, resr);\n    }\n\n    T operator[](int x) {return node[x+N];}\n};\n\n/*\nexample\nauto f=[](int a,int b){return max(a,b);};\nconst int id = -1e9;\nSegmentTree<int, decltype(f)> seg(f,id);\n*/\n\nstruct HeavyLightDecomposition {\n    vector<vector<int>> G;\n    vector<int> vid, head, sub, par, dep, inv, type;\n\n    HeavyLightDecomposition(int N) :\n        G(N),vid(N,-1),head(N),sub(N,1),\n        par(N,-1),dep(N,0),inv(N),type(N){}\n\n    void add_edge(int u,int v) {\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n\n    void build(vector<int> rs={0}) {\n        int c=0,pos=0;\n        for(int r:rs) {\n            dfs_sz(r);\n            head[r]=r;\n            dfs_hld(r,c++,pos);\n        }\n    }\n\n    void dfs_sz(int v) {\n        for(int &u:G[v]) if(u==par[v]) swap(u,G[v].back());\n        if(~par[v]) G[v].pop_back();\n        for(int &u:G[v]) {\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            dfs_sz(u);\n            sub[v]+=sub[u];\n            if(sub[u]>sub[G[v][0]]) swap(u,G[v][0]);\n        }\n    }\n\n    void dfs_hld(int v,int c,int &pos) {\n        vid[v]=pos++;\n        inv[vid[v]]=v;\n        type[v]=c;\n        for(int u:G[v]){\n            if(u==par[v]) continue;\n            head[u]=(u==G[v][0]?head[v]:u);\n            dfs_hld(u,c,pos);\n        }\n    }\n\n    int lca(int u,int v){\n        while(1){\n            if(vid[u]>vid[v]) swap(u,v);\n            if(head[u]==head[v]) return u;\n            v=par[head[v]];\n        }\n    }\n\n    int distance(int u,int v){\n        return dep[u]+dep[v]-2*dep[lca(u,v)];\n    }\n\n    // for_each(vertex)\n    template<typename F>\n    void for_each(int u, int v, const F& f) {\n        while(1){\n            if(vid[u]>vid[v]) swap(u,v);\n            f(max(vid[head[v]],vid[u]),vid[v]+1);\n            if(head[u]!=head[v]) v=par[head[v]];\n            else break;\n        }\n    }\n\n    template<typename T,typename Q,typename F>\n    T for_each(int u,int v,T ti,const Q &q,const F &f){\n        T l=ti,r=ti;\n        while(1){\n            if(vid[u]>vid[v]){\n                swap(u,v);\n                swap(l,r);\n            }\n            l=f(l,q(max(vid[head[v]],vid[u]),vid[v]+1));\n            if(head[u]!=head[v]) v=par[head[v]];\n            else break;\n        }\n        return f(l,r);\n    }\n\n    // for_each(edge)\n    // [l, r) <- attention!!\n    template<typename F>\n    void for_each_edge(int u, int v,const F& f) {\n        while(1){\n            if(vid[u]>vid[v]) swap(u,v);\n            if(head[u]!=head[v]){\n                f(vid[head[v]],vid[v]+1);\n                v=par[head[v]];\n            }else{\n                if(u!=v) f(vid[u]+1,vid[v]+1);\n                break;\n            }\n        }\n    }\n};\n\nint main() {\n    ios::sync_with_stdio(false); cin.tie(nullptr);\n    int N; cin >> N;\n    HeavyLightDecomposition HLD(N);\n    rep(i,N) {\n        int k; cin >> k;\n        rep(j,k) {\n            int c; cin >> c;\n            HLD.add_edge(i,c);\n        }\n    }\n    HLD.build();\n    auto f=[](ll a, ll b) {return a+b;};\n    const ll id = 0;\n    SegmentTree<ll, decltype(f)> seg(f,id);\n    seg.init(N);\n    seg.build();\n\n    int Q; cin >> Q;\n    while (Q--) {\n        int com; cin >> com;\n        if (com) {\n            int u; cin >> u;\n            ll ans = 0;\n            auto g=[&](int u, int v) {ans+=seg.get(u,v);};\n            HLD.for_each_edge<decltype(g)>(0,u,g);\n            cout << ans << ln;\n        } else {\n            int v,w; cin >> v >> w;\n            seg.update(HLD.vid[v],seg[HLD.vid[v]]+w);\n        }\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct LinkCutTree {\n  struct Node {\n    Node *l, *r, *p;\n    int val;\n    int sum;\n    int size = 1;\n    Node(int val) : val(val), sum(val), l(nullptr), r(nullptr), p(nullptr) {}\n    bool is_root() {\n      return !p || (p->l != this && p->r != this);\n    }\n  };\n  Node *make_node(int val) {\n    return new Node(val);\n  }\n  void update(Node *t) {\n    t->size = 1;\n    t->sum = t->val;\n    if (t->l) t->size += t->l->size, t->sum += t->l->sum;\n    if (t->r) t->size += t->r->size, t->sum += t->r->sum;\n  }\n  void rotr(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if ((x->l = t->r)) t->r->p = x;\n    t->r = x, x->p = t;\n    update(x), update(t);\n    if ((t->p = y)) {\n      if (y->l == x) y->l = t;\n      if (y->r == x) y->r = t;\n      update(y);\n    }\n  }\n  void rotl(Node *t) {\n    auto *x = t->p, *y = x->p;\n    if ((x->r = t->l)) t->l->p = x;\n    t->l = x, x->p = t;\n    update(x), update(t);\n    if ((t->p = y)) {\n      if (y->l == x) y->l = t;\n      if (y->r == x) y->r = t;\n      update(y);\n    }\n  }\n  void splay(Node *t) {\n    while (!t->is_root()) {\n      auto *p = t->p;\n      if (p->is_root()) {\n        if (p->l == t) rotr(t);\n        else rotl(t);\n        continue;\n      }\n      auto *q = p->p;\n      if (q->l == p) {\n        if (p->l == t) rotr(p), rotr(t);\n        else rotl(t), rotr(t);\n      } else {\n        if (p->r == t) rotl(p), rotl(t);\n        else rotr(t), rotl(t);\n      }\n    }\n  }\n  void expose(Node *t) {\n    Node *rp = nullptr;\n    for (auto *cur = t; cur; cur = cur->p) {\n      splay(cur);\n      cur->r = rp;\n      update(cur);\n      rp = cur;\n    }\n    splay(t);\n  }\n  void link(Node *child, Node *parent) {\n    expose(child);\n    expose(parent);\n    child->p = parent;\n    parent->r = child;\n  }\n  void cut(Node *child) {\n    expose(child);\n    auto *parent = child->l;\n    child->l = nullptr;\n    parent->p = nullptr;\n  }\n};\n\nusing i64 = long long;\n\nint main() {\n  int N; cin >> N;\n  LinkCutTree lct;\n  vector<LinkCutTree::Node *> nodes(N);\n  for (int i = 0; i < N; i++) {\n    nodes[i] = lct.make_node(0);\n  }\n  for (int i = 0; i < N; i++) {\n    int k; cin >> k;\n    for (int j = 0; j < k; j++) {\n      int u; cin >> u;\n      lct.link(nodes[u], nodes[i]);\n    }\n  }\n  int Q; cin >> Q;\n  for (int i = 0; i < Q; i++) {\n    int q; cin >> q;\n    if (q == 0) {\n      int v, w; cin >> v >> w;\n      lct.expose(nodes[v]);\n      nodes[v]->val += w;\n      lct.update(nodes[v]);\n    } else {\n      int u; cin >> u;\n      lct.expose(nodes[u]);\n      cout << nodes[u]->sum << '\\n';\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "// 参考:http://judge.u-aizu.ac.jp/onlinejudge/review.jsp?rid=3891837#1\n\n#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\ntypedef long long int ll;\n#define MAX 100000\n\nint n, q;\nvector<int> G[MAX];\n\nint id[MAX];\nint es[2 * (MAX - 1)];\nll bit[MAX + 1];\n\nvoid dfs(int v, int p, int &k){\n\tid[v] = k;\n\tk++;\n\tfor(int i = 0; i < G[v].size();++i){\n\t\tint to = G[v][i];\n\t\tif(to != p){\n\t\t\tes[2 * to] = k;\n\t\t\tdfs(to, v, k);\n\t\t\tes[2 * to + 1] = k;\n\t\t}\n\t}\n}\n\nll sum(int i){\n\tll s = 0;\n\twhile(i > 0){\n\t\ts += bit[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, ll x){\n\twhile(i <= n){\n\t\tbit[i] += x;\n\t\ti += i & -i;\n\t}\n}\n\nint main(){\n    int k;\n\tscanf(\"%d\", &n);\n\tfor(int i = 0; i < n;++i){int k;\n\t\tscanf(\"%d\", &k);\n\t\tfor(int j = 0; j < k;++j){\n\t\t\tint c;\n\t\t\tscanf(\"%d\", &c);\n\t\t\tG[i].push_back(c);\n\t\t}\n\t}\n\tk = 0;\n\tdfs(0,-1,k);\n\t\n\tscanf(\"%d\", &q);\n\tfor(int i = 0; i < q;++i){\n\t\tint op;\n\t\tscanf(\"%d\", &op);\n\t\tif(op == 0){\n\t\t\tint v;\n\t\t\tll w;\n\t\t\tscanf(\"%d %lld\", &v, &w);\n\t\t\tadd(es[2 * v], w);\n\t\t\tadd(es[2 * v + 1], -w);\n\t\t}else{\n\t\t\tint u;\n\t\t\tscanf(\"%d\", &u);\n\t\t\tprintf(\"%lld\\n\", sum(id[u]));\n\t\t}\n\t}\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n#define rep(i,n) for (ll i=0;i<(n);++i)\nconst ll MOD=1e9+7;\n//const ll MOD=998244353;\n\nclass EularTourForEdge{\n    private:\n    vector<int> ds,us,dep,btm;\n    void dfs(int v,int p,int d){\n        dep[v]=d;\n        for (int u:G[v]){\n            if (u==p) continue;\n            ds[u]=btm.size();\n            btm.emplace_back(u);\n            dfs(u,v,d+1);\n            us[u]=btm.size();\n            btm.emplace_back(u);\n        }\n    }\n    public:\n    vector<vector<int>> G;\n    EularTourForEdge(int n):\n        ds(n),us(n),dep(n),G(n){}\n    void add_edge(int u,int v){\n        G[u].emplace_back(v);\n        G[v].emplace_back(u);\n    }\n    void build(int r=0){\n        btm.clear();\n        ds[r]=btm.size(); btm.emplace_back(r);\n        dfs(r,-1,0);\n        us[r]=btm.size(); btm.emplace_back(r);\n    }\n    int child(int u,int v){\n        return dep[u]<dep[v]?v:u;\n    }\n    int bottom(int e){\n        return btm[e];\n    }\n    template<typename T,typename F>\n    T query(int v,F f){\n        return f(0,us[v]);\n    }\n    //u or v must be lca(u,v)\n    template<typename T,typename F>\n    T query(int u,int v,F f){\n        if (dep[u]<dep[v]) swap(u,v);\n        return query<T>(u,f)-query<T>(v,f);\n    }\n    template<typename T,typename G>\n    void update(int v,T x,G g){\n        g(ds[v],x);\n        g(us[v],-x);\n    }\n};\n\ntemplate<typename T>\nstruct BinaryIndexedTree{\n    vector<T> dat;\n    BinaryIndexedTree(int n):dat(n+1,0){}\n    void add(int i,T x){\n        if (i==0) return;\n        for (;i<=dat.size();i+=(i&-i)) dat[i]+=x;\n    }\n    T sum(int i){\n        T res=0;\n        for (;i>0;i-=(i&-i)) res+=dat[i];\n        return res;\n    }\n    T query(int l,int r){ //[l,r)\n        return sum(r-1)-sum(l-1);\n    }\n    int lower_bound(T x){\n        if (x<=0) return 0;\n        int lb=0,r=1;\n        while(r<dat.size()) r<<=1;\n        for (;r>0;r>>=1){\n            if (lb+r<dat.size()&&dat[lb+r]<x){\n                x-=dat[lb+r]; lb+=r;\n            }\n        }\n        return lb+1;\n    }\n    void add0(int i,T x){\n        add(i+1,x);\n    }\n    T sum0(int i){\n        return sum(i+1);\n    }\n    T query0(int l,int r){\n        return sum(r)-sum(l);\n    }\n};\n\nint main(){\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n    int n; cin >> n;\n    EularTourForEdge ET(n);\n    rep(i,n){\n        int k; cin >> k;\n        rep(j,k){\n            int c; cin >> c;\n            ET.add_edge(i,c);\n        }\n    }\n    ET.build();\n    BinaryIndexedTree<int> BIT(2*n);\n    auto f=[&](int l,int r){return BIT.query(l+1,r+1);};\n    auto g=[&](int k,int d){BIT.add(k+1,d);};\n    int q; cin >> q;\n    rep(i,q){\n        int c,v,w; cin >> c >> v;\n        if (!c){\n            cin >> w;\n            ET.update(v,w,g);\n        } else cout << ET.query<int>(0,v,f) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define int long long\n#define all(V) (V).begin(),(V).end()\n#define umap unordered_map\n#define uset unordered_set\n#define br cout<<\"\\n\";\n\nconst int MAXN = 1e5 + 10, MOD = 1e9 + 7;\nint n, m;\nvector<int> grf[MAXN], et, st;\nint tin[MAXN], tout[MAXN], timer = 0;\n\nvoid dfs(int node, int p = -1) {\n    et.push_back(node);\n    tin[node] = timer++;\n    for (auto nbr: grf[node]) {\n        if (nbr != p) {\n            dfs(nbr, node);\n        }\n    }\n    tout[node] = timer++;\n    et.push_back(node);\n}\n\n\nvoid update(int start, int end, int point, int val, int index = 1) {\n    if (start == end and start == point) {\n        st[index] += val;\n        return;\n    }\n    int mid = start + end >> 1;\n    if (point <= mid) {\n        update(start, mid, point, val, index << 1);\n    } else {\n        update(mid + 1, end, point, val, index << 1 | 1);\n    }\n    st[index] = st[index << 1] + st[index << 1 | 1];\n}\n\nint query(int start, int end, int l, int r, int index = 1) {\n    if (r < start or l > end) return 0;\n    if (l <= start and end <= r) {\n        return st[index];\n    }\n    int mid = start + end >> 1;\n    return query(start, mid, l, r, index << 1) + query(mid + 1, end, l, r, index << 1 | 1);\n}\n\nvoid doit() {\n    st.resize(5 * et.size());\n}\n\nsigned main() {\n//\t#ifndef ONLINE_JUDGE\n//\t\tfreopen(\"./input.txt\",\"r\",stdin);\n//\t\tfreopen(\"./output.txt\",\"w\",stdout);\n//\t#endif\n    ios::sync_with_stdio(false);\n    cin.tie(nullptr);\n    cin >> n;\n    for (int i = 0, tmp; i < n; i++) {\n        cin >> m;\n        while (m--) {\n            cin >> tmp;\n            grf[i].push_back(tmp);\n            grf[tmp].push_back(i);\n        }\n    }\n    dfs(0);\n    doit();\n    int q;\n    cin >> q;\n    while (q--) {\n        int qt;\n        cin >> qt;\n        if (qt == 0) {\n            int v, w;\n            cin >> v >> w;\n            update(0, et.size() - 1, tin[v], w);\n            update(0, et.size() - 1, tout[v], -w);\n        } else {\n            int u;\n            cin >> u;\n            cout << query(0, et.size() - 1, 0, tin[u]);\n            br;\n        }\n    }\n//    br;\n//    for (int i = 0; i < n; i++) {\n//        cout << tin[i] << \" \";\n//    }\n//    br;\n//    for (int i = 0; i < n; i++) {\n//        cout << tout[i] << \" \";\n//    }\n}\n"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\nusing namespace std;\n#define int long long\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = 3.14159265358979;\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\nbool odd(const int &n) { return n & 1; }\nbool even(const int &n) { return ~n & 1; }\ntemplate<typename T> int len(const T &v) { return v.size(); }\ntemplate<typename T = int> T in() { T x; cin >> x; return x; }\ntemplate<typename T = int> T in(T &&x) { T z(forward<T>(x)); cin >> z; return z; }\ntemplate<typename T> istream &operator>>(istream &is, vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> istream &operator>>(istream &is, pair<A, B> &p) { return is >> p.first >> p.second; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<vector<T>> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \"\\n\"); return os; }\ntemplate<typename T> ostream &operator<<(ostream &os, const vector<T> &v) { int n = v.size(); rep(i, n) os << v[i] << (i == n - 1 ? \"\" : \" \"); return os; }\ntemplate<typename A, typename B> ostream &operator<<(ostream &os, const pair<A, B> &p) { return os << p.first << ' ' << p.second; }\ntemplate<typename Head, typename Value> auto vectors(const Head &head, const Value &v) { return vector<Value>(head, v); }\ntemplate<typename Head, typename... Tail> auto vectors(Head x, Tail... tail) { auto inner = vectors(tail...); return vector<decltype(inner)>(x, inner); }\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = vector<Edge>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\nclass Graph {\n  vector<Edges> g;\n  using iterator = vector<Edges>::iterator;\n  using const_iterator = vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  size_t size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  Edges &operator[](const int &i) { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nclass HLDecomposition {\n  Graph g;\n  int vertexId = 0;\n  vector<int> _parent; // _parent[v] := parent of v, _parent[root] = -1\n  vector<int> subsize; // subsize[v] := size of subtree rooted at v\n  vector<int> depth; // depth[v] := depth of v\n  vector<int> next; // next[v] := next vertex of v on heavy-path, next[last] := -1\n  vector<int> head; // head[v] := head vertex on heavy-path contains v\n  vector<int> treeId; // treeId[v] := id of tree contains v\n  vector<int> newVertexId; // newVertexId[v] := reassigned vertex id of v\n  vector<int> left, right; // [left[v], right[v]) := segment of subtree\n\n  void decompose(const int &r) {\n    stack<pair<int, int>> s;\n    _parent[r] = -1;\n    depth[r] = 0;\n    s.emplace(r, 0);\n    while (s.size()) {\n      int v = s.top().first;\n      int &i = s.top().second;\n      if (i < g[v].size()) {\n        int u = g[v][i++].dst;\n        if (u == _parent[v]) continue;\n        _parent[u] = v;\n        depth[u] = depth[v] + 1;\n        s.emplace(u, 0);\n      } else {\n        s.pop();\n        int mini = 0;\n        rep(i, g[v].size()) {\n          auto &e = g[v][i];\n          if (e.dst == _parent[v]) swap(e, g[v].back());\n          if (e.dst == _parent[v]) continue;\n          subsize[v] += subsize[e.dst];\n          if (subsize[e.dst] > subsize[g[v].front().dst]) swap(e, g[v].front());\n        }\n      }\n    }\n  }\n\n  void reassign(const int &root, const int &tid) {\n    stack<tuple<int, int, int>> s;\n    s.emplace(root, root, 0);\n    while (s.size()) {\n      int v, h;\n      tie(v, h, ignore) = s.top();\n      int &i = get<2>(s.top());\n      if (i == 0) {\n        treeId[v] = tid;\n        left[v] = newVertexId[v] = vertexId++;\n        head[v] = h;\n        if (g[v].size() && g[v][0].dst != _parent[v]) next[v] = g[v][0].dst;\n      }\n      if (i < g[v].size()) {\n        auto &e = g[v][i++];\n        if (e.dst == _parent[v]) continue;\n        s.emplace(e.dst, next[v] == e.dst ? h : e.dst, 0);\n      } else {\n        s.pop();\n        right[v] = vertexId;\n      }\n    }\n  }\n\npublic:\n  struct segment {\n    int l, r; // [l, r)\n    segment(const int &l, const int &r) : l(l), r(r) {}\n  };\n\n  vector<segment> vertexSegments(int u, int v) {\n    vector<segment> segs;\n    while (true) {\n      if (newVertexId[u] > newVertexId[v]) swap(u, v);\n      segs.emplace_back(max(newVertexId[u], newVertexId[head[v]]), newVertexId[v] + 1);\n      if (head[u] == head[v]) break;\n      v = _parent[head[v]];\n    }\n    return segs;\n  }\n\n  vector<segment> edgeSegments(int u, int v) {\n    vector<segment> segs;\n    while (true) {\n      if (newVertexId[u] > newVertexId[v]) swap(u, v);\n      if (head[u] == head[v]) {\n        if (u != v) segs.emplace_back(newVertexId[u] + 1, newVertexId[v] + 1);\n        break;\n      }\n      segs.emplace_back(newVertexId[head[v]], newVertexId[v] + 1);\n      v = _parent[head[v]];\n    }\n    return segs;\n  }\n\n  int parent(const int &v) { return _parent[v]; }\n\n  int lca(int u, int v) {\n    while (true) {\n      if (newVertexId[u] > newVertexId[v]) swap(u, v);\n      if (head[u] == head[v]) return u;\n      v = _parent[head[v]];\n    }\n  }\n\n  int distance(const int &u, const int &v) { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }\n\n  HLDecomposition(const Graph &g, const vector<int> &roots = {0})\n      : g(g), _parent(g.size()), subsize(g.size(), 1), depth(g.size()), //\n        next(g.size(), -1), head(g.size()), treeId(g.size()), newVertexId(g.size(), -1), //\n        left(g.size()), right(g.size()) {\n    int treeId = 0;\n    for (auto &r : roots) decompose(r), reassign(r, treeId++);\n  }\n};\n\ntemplate<typename Monoid> class SegTree {\n  using T = typename Monoid::value_type;\n\n  Monoid m;\n  vector<T> tree; // 1-indexed\n  int size = 1;\n\npublic:\n  SegTree(const int &n = 0) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, m.id());\n  }\n\n  SegTree(const int &n, const T &x) {\n    while (size < n) size *= 2;\n    tree.assign(size * 2, x);\n    for (int i = size - 1; i >= 1; i--) tree[i] = m(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  template<typename InputIterator> SegTree(InputIterator first, InputIterator last) {\n    int n = distance(first, last);\n    while (size < n) size *= 2;\n    tree.resize(size * 2, m.id());\n    copy(first, last, tree.begin() + size);\n    for (int i = size - 1; i >= 1; i--) tree[i] = m(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  T fold(int l, int r) { // [l, r)\n    T accl = m.id(), accr = m.id();\n    for (l += size, r += size; l < r; l /= 2, r /= 2) {\n      if (l & 1) accl = m(accl, tree[l++]);\n      if (r & 1) accr = m(tree[--r], accr);\n    }\n    return m(accl, accr);\n  }\n\n  void update(int i, const T &x) {\n    tree[i += size] = x;\n    while (i /= 2) tree[i] = m(tree[i * 2], tree[i * 2 + 1]);\n  }\n\n  const T &operator[](int i) const { return tree[i + size]; }\n};\n\ntemplate<typename T> class RangeSum {\n  struct trait {\n    using value_type = T;\n    T id() { return T(); }\n    T operator()(const T &a, const T &b) { return a + b; }\n  };\n  SegTree<trait> st;\n\npublic:\n  RangeSum(const int &n = 0) : st(n) {}\n  RangeSum(const int &n, const T &x) : st(n, x) {}\n  template<typename InputIterator> RangeSum(InputIterator first, InputIterator last) : st(first, last) {}\n  void update(const int &i, const T &x) { st.update(i, x); }\n  T sum(const int &l, const int &r) { return st.fold(l, r); }\n  T operator[](const int &i) { return st[i]; }\n};\n\nmain() {\n  int n = in();\n  Graph g(n);\n  rep(i, n) {\n    int k = in();\n    while (k--) g.addEdge(i, in());\n  }\n  HLDecomposition hld(g);\n  RangeSum<int> rs(n);\n  int q = in();\n  while (q--) {\n    if (in()) {\n      int sum = 0;\n      for (auto &p : hld.edgeSegments(0, in())) sum += rs.sum(p.l, p.r);\n      cout << sum << endl;\n    } else {\n      int v, w;\n      cin >> v >> w;\n      for (auto &p : hld.edgeSegments(v, hld.parent(v))) rs.update(p.l, rs[p.l] + w);\n    }\n  }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define pb push_back\nusing namespace std;\nconst int maxn=100005;\n\nint n,q,sec=1;\nint st[maxn],ed[maxn];\nvector<int>G[maxn];\nint a[maxn];\n\nvoid add(int i,int v) {\n    for (;i<=sec;i+=i&-i) a[i]+=v;\n}\n\nint query(int i) {\n    int res=0;\n    for (;i>0;i-=i&-i) res+=a[i];\n    return res;\n}\n\nvoid dfs(int u,int p) {\n    st[u]=sec++;\n    for (int v:G[u])\n        if (v!=p) dfs(v,u);\n    ed[u]=sec;\n}\n\nint main() {\n    cin>>n;\n    for (int i=0;i<n;i++) {\n        int m; cin>>m;\n        for (int j=0;j<m;j++) {\n            int v; cin>>v;\n            G[i].pb(v);\n            G[v].pb(i);\n        }\n    }\n    dfs(0,-1);\n    cin>>q;\n    for (int i=0;i<q;i++) {\n        bool op; cin>>op;\n        if (op) {\n            int u; cin>>u;\n            cout<<query(st[u])<<'\\n';\n        }\n        else {\n            int v,w; cin>>v>>w;\n            add(st[v],w);\n            add(ed[v],-w);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n\nnamespace ProconLib{\n\n    template<class graph_t>\n    class EulerTour{\n        private:\n        int N;\n        std::vector<int> ins;\n        std::vector<int> outs;\n        void dfs(int v,int pre,const graph_t& g,int& id);\n\n        public:\n        EulerTour(int root,const graph_t& g);\n        int in(int v){return ins[v];}\n        int out(int v){return outs[v];}\n    };\n\n    template<class graph_t>\n    EulerTour<graph_t>::EulerTour(int root,const graph_t& g):N(g.size()),\n                                                      ins(N),\n                                                        outs(N)\n    {   \n        int id=0;\n        dfs(root,-1,g,id);\n    }   \n\n    template<class graph_t>\n    void EulerTour<graph_t>::dfs(int v,int pre,const graph_t& g,int& id){\n        ins[v]=id++;\n        for(auto& e:g[v]){\n            if(e.to==pre) continue;\n            dfs(e.to,v,g,id);\n        }\n        outs[v]=id++;\n    }\n}\n\n\n#include<vector>\n\nnamespace ProconLib{\n    \n    template<class Monoid>\n    class SegmentTree{\n        public: \n        using value_t= typename Monoid::value_t;\n        private:\n        int N;\n        std::vector<value_t> dat;\n        static int calcN(int n){int res=1; while(res<n) res*=2; return res;}\n        value_t queryImpl(int a,int b,int k,int l,int r);\n\n        public:\n        SegmentTree(int N);\n        void update(int pos,value_t val);        \n        void updateALL(std::vector<value_t> x);\n        value_t query(int a,int b);\n    };\n\n    // struct MonoidExample{\n    //     using value_t=int;\n    //     static constexpr value_t E(){return 0;}\n    //     static value_t op(value_t lhs,value_t rhs){return lhs+rhs;}\n    // };\n    \n    template<typename Monoid>\n    SegmentTree<Monoid>::SegmentTree(int n):N(calcN(n)),dat(2*N-1,Monoid::E()){}\n\n    template<typename Monoid>\n    void SegmentTree<Monoid>::update(int pos,value_t val){\n        pos+=N-1;\n        dat[pos]=val;\n        while(pos!=0){\n            int par=(pos-1)/2;\n            dat[par]=Monoid::op(dat[par*2+1],dat[par*2+2]);\n            pos=par;\n        }\n    }\n\n    template<typename Monoid>\n    void SegmentTree<Monoid>::updateALL(std::vector<value_t> x){\n        for(int i=0;i<x.size();i++) dat[N-1+i]=x[i];\n        for(int i=N-2;i>=0;i--) dat[i]=Monoid::op(dat[i*2+1],dat[i*2+2]);\n    }\n\n    template<typename Monoid>\n    typename SegmentTree<Monoid>::value_t SegmentTree<Monoid>::query(int a,int b){\n        return queryImpl(a,b,0,0,N);\n    }\n\n    template<typename Monoid>\n    typename SegmentTree<Monoid>::value_t SegmentTree<Monoid>::queryImpl(int a,int b,int k,int l,int r){\n        if(a<=l && r<=b) return dat[k];\n        if(r<=a || b<=l) return Monoid::E();\n        int mid=(l+r)/2;\n        value_t c1v=queryImpl(a,b,k*2+1,l,mid);\n        value_t c2v=queryImpl(a,b,k*2+2,mid,r);\n        return Monoid::op(c1v,c2v);\n    }\n}\n\n\n\n#include<bits/stdc++.h>\n// #include\"../DataStructure/SegmentTree.cpp\"\nusing namespace std;\nusing namespace ProconLib;\n\nstruct Edge{\n    int to;\n};\n\nstruct Monoid{\n    using value_t=int;\n    static constexpr value_t E(){return 0;}\n    static value_t op(value_t lhs,value_t rhs){return lhs+rhs;}\n};    \n\nusing Graph=vector<vector<Edge>>;\nint main(){\n    int n;\n    cin>>n;\n    Graph g(n);\n    vector<int> par(n,-1);\n    vector<int> val(n,0);\n    for(int i=0;i<n;i++){\n        int k; cin>>k;\n        while(k--){\n            int c; cin>>c;\n            par[c]=i;\n            g[i].push_back(Edge{c});\n            g[c].push_back(Edge{i});\n        }\n    }\n    EulerTour<Graph> et(0,g);\n    SegmentTree<Monoid> seg(2*n);\n\n    int q; cin>>q;\n    while(q--){\n        int type; cin>>type;\n        if(!type){\n            int v,w; cin>>v>>w;\n            val[v]+=w;\n            seg.update(et.in(v),val[v]);\n            seg.update(et.out(v),-val[v]);\n        }\n        else{\n            int u; cin>>u;\n            cout<<seg.query(et.in(0),et.in(u)+1)<<endl;\n        }\n    }\n\n\n}\n"
  },
  {
    "language": "C++",
    "code": "\n#include<iostream>\n#include<vector>\nusing namespace std;\n\nconst int N = 100000 ;\nint size,\n    c,\n    l[N],\n    r[N],\n    b[2*N+1];\nvector<int> vec[N];\n\nvoid dfs(int v){\n    l[v] = ++c;\n    for(int i=0;i<vec[v].size();i++){\n        dfs(vec[v][i]);\n    }\n    r[v] = ++c;\n}\n\nvoid add(int i,int x){\n    while(i<=size){\n        b[i] += x;\n        i += i&-i;\n    }\n}\n\nint getSum(int i){\n    int ans = 0;\n    while(i>0){\n        ans += b[i];\n        i -= i&-i;\n    }\n    return ans;\n}\n\nvoid queryChoose(int i){\n    if(i == 0){\n        int v,w;\n        cin>>v>>w;\n        add(l[v],w);\n        add(r[v],-w);\n    }else{\n        int v;\n        cin>>v;\n        cout<<getSum(r[v] - 1)<<endl;\n    }\n}\n\nint main(){\n    int n;\n    while(cin>>n){\n        c = 0;\n        size = 2*n + 1;\n        for(int i=0;i<n;i++){\n            int k;\n            cin>>k;\n            for(int j=0;j<k;j++){\n                int child;\n                cin>>child;\n                vec[i].push_back(child);\n            }\n        }\n        dfs(0);\n        int q;\n        cin>>q;\n        for(int i=0;i<q;i++){\n            int op;\n            cin>>op;\n            queryChoose(op);\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define _MACRO(_1, _2, _3, NAME, ...) NAME\n#define _repl(i,a,b) for(int i=(int)(a);i<(int)(b);i++)\n#define _rep(i,n) _repl(i,0,n)\n#define rep(...) _MACRO(__VA_ARGS__, _repl, _rep)(__VA_ARGS__)\n#define mp make_pair\n#define pb push_back\n#define all(x) begin(x),end(x)\n#define uniq(x) sort(all(x)),(x).erase(unique(all(x)),end(x))\n#define fi first\n#define se second\n#define dbg(...) _dbg(#__VA_ARGS__, __VA_ARGS__)\nvoid _dbg(string){cerr<<endl;}\ntemplate<class H,class... T> void _dbg(string s,H h,T... t){int l=s.find(',');cerr<<s.substr(0,l)<<\" = \"<<h<<\", \";_dbg(s.substr(l+1),t...);}\ntemplate<class T,class U> ostream& operator<<(ostream &o, const pair<T,U> &p){o<<\"(\"<<p.fi<<\",\"<<p.se<<\")\";return o;}\ntemplate<class T> ostream& operator<<(ostream &o, const vector<T> &v){o<<\"[\";for(T t:v){o<<t<<\",\";}o<<\"]\";return o;}\n\n\ntemplate<int SZ>\nclass HLDecomp {\nprivate:\n  int n;\n  void dfs(const int root){\n    stack<pair<int,bool> > st;\n    par[root] = -1;\n    dep[root] = 0;\n    st.push({root,false});\n    while(!st.empty()){\n      int v = st.top().first;\n      bool &b = st.top().second;\n      if(!b){\n        // initial visit of v\n        b = true;\n        for(int u : tree[v]) if(u != par[v]){\n          par[u] = v;\n          dep[u] = dep[v] + 1;\n          // st.push({u, false});\n          st.push(mp(u, false));\n        }\n      }\n      else {\n        // second visit\n        st.pop();\n        int cur_max = 0;\n        for(int u : tree[v]) if(u != par[v]){\n          sub_sz[v] += sub_sz[u];\n          if(sub_sz[u] > cur_max){\n            cur_max = sub_sz[u];\n            heavy_child[v] = u;\n          }\n        }\n      }\n    }\n  }\n  void bfs(const int root){\n    int cnt = 0;\n    queue<int> q;\n    q.push(root);\n    while(!q.empty()){\n      int h = q.front(); q.pop();\n      for(int i=h; i!=-1; i = heavy_child[i]){\n        vid[i] = cnt++;\n        vid2idx[vid[i]] = i;\n        chain_head[i] = h;\n        for(int to : tree[i]) if(to!=par[i] && to!=heavy_child[i]) q.push(to);\n      }\n    }\n  }\npublic:\n  vector<int> tree[SZ];\n  int par[SZ], dep[SZ], sub_sz[SZ], heavy_child[SZ], vid[SZ], vid2idx[SZ], chain_head[SZ];\n  HLDecomp(const int _n) : n(_n) {\n    assert(n<=SZ);\n    fill(sub_sz, sub_sz+n, 1);\n    fill(heavy_child, heavy_child+n, -1);\n  }\n  void add_edge(const int u, const int v){\n    tree[u].push_back(v);\n    tree[v].push_back(u);\n  }\n  void build(const int root = 0){\n    dfs(root);\n    bfs(root);\n  }\n\n  // 閉区間注意\n  void for_each_vertex(int u, int v, const function<void(int,int)> &f) const {\n    while(true){\n      if(vid[u] > vid[v]) swap(u,v);\n      f(max(vid[chain_head[v]], vid[u]), vid[v]);\n      if(chain_head[u] != chain_head[v]) v = par[chain_head[v]];\n      else break;\n    }\n  }\n  // 辺は子側の頂点で管理する!\n  void for_each_edge(int u, int v, const function<void(int,int)> &f) const {\n    while(true){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(chain_head[u] != chain_head[v]){\n        f(vid[chain_head[v]], vid[v]);\n        v = par[chain_head[v]];\n      }\n      else {\n        if(u!=v) f(vid[u]+1, vid[v]);\n        break;\n      }\n    }\n  }\n  int lca(int u, int v) const {\n    while(1){\n      if(vid[u] > vid[v]) swap(u,v);\n      if(chain_head[u] == chain_head[v]) return u;\n      v = par[chain_head[v]];\n    }\n  }\n  int distance(const int u, const int v) const {\n    return dep[u] + dep[v] - 2*dep[lca(u,v)];\n  }\n};\n\ntemplate<typename T>\nclass SegTree {\npublic:\n  int n;\n  T e;\n  T (*op)(const T&, const T&);\n  vector<T> data;\n  SegTree(int m, T _e, T (*_op)(const T&, const T&)) : e(_e), op(_op){\n    n=1;\n    while(n<m) n*=2;\n    data.resize(2*n, e);\n  }\n  SegTree(const vector<T> &v, T _e, T (*_op)(const T&, const T&)) : e(_e), op(_op){\n    n=1;\n    while(n<(int)v.size()) n*=2;\n    data.resize(2*n, e);\n    rep(i,v.size()) data[i+n] = v[i];\n    for(int i=n-1; i>0; i--) data[i] = op(data[i*2], data[i*2+1]);\n  }\n  T query(int l, int r) const {\n    T vl = e, vr = e;\n    for(l+=n, r+=n; l<r; l/=2, r/=2){\n      if(l&1) vl = op(vl, data[l++]);\n      if(r&1) vr = op(data[--r], vr);\n    }\n    return op(vl,vr);\n  }\n  void update(int k, T a){\n    k+=n;\n    data[k]=a;\n    while(k>0){\n      k = k/2;\n      data[k] = op(data[k*2], data[k*2+1]);\n    }\n  }\n  inline T operator[](int idx) const { return data[idx+n]; }\n};\n\nint main(){\n  int n;\n  cin>>n;\n  HLDecomp<100005> hl(n);\n  rep(i,n){\n    int k;\n    cin>>k;\n    rep(j,k){\n      int d;\n      cin>>d;\n      hl.add_edge(i,d);\n    }\n  }\n  hl.build();\n\n  SegTree<int> st(n, 0, [](auto l, auto r){return l+r;});\n\n  int q;\n  cin>>q;\n  rep(i,q){\n    int t;\n    cin>>t;\n    if(t==0){\n      // add\n      int a,b;\n      cin>>a>>b;\n      int idx = hl.vid[a];\n      st.update(idx, st[idx] + b);\n    }\n    else {\n      // getSum\n      int a;\n      cin>>a;\n      int ans = 0;\n      hl.for_each_edge(0,a,[&ans,&st](auto l, auto r){\n        ans += st.query(l, r+1);\n      });\n      cout << ans << \"\\n\";\n    }\n  }\n\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nusing int64 = long long;\n\nstruct LCNode {\n  using LP = LCNode *;\n\n  using data_t = int;\n  using lazy_t = int;\n\n  LP l, r, p;\n  int idx, sz;\n  bool rev;\n  data_t key, sum;\n  lazy_t lazy;\n\n  void init_node(int idx, const data_t &v) {\n    this->sz = 1;\n    this->idx = idx;\n    this->lazy = 0; // <-\n    this->key = this->sum = v;\n  }\n\n  void update() {\n    sz = 1;\n    sum = key;\n    if(l) {\n      sz += l->sz;\n      // <- sum += l->sum\n      sum += l->sum;\n    }\n    if(r) {\n      sz += r->sz;\n      // <- sum += r->sum\n      sum += r->sum;\n    }\n  }\n\n  void propagate(const lazy_t &v) {\n    // <- lazy+=v, key+=v, sum+=v\n  }\n\n  void toggle() {\n    swap(l, r);\n    rev ^= true;\n    // <-\n  }\n\n  bool is_root() {\n    return !p || (p->l != this && p->r != this);\n  }\n\n  void push() {\n    if(lazy) { // <-\n      if(l) l->propagate(lazy);\n      if(r) r->propagate(lazy);\n      lazy = 0; // <-\n    }\n    if(rev) {\n      if(l) l->toggle();\n      if(r) r->toggle();\n      rev = false;\n    }\n  }\n\n  void rotr() {\n    LP x = p, y = x->p;\n    if((x->l = r)) r->p = x;\n    r = x, x->p = this;\n    x->update(), update();\n    if((p = y)) {\n      if(y->l == x) y->l = this;\n      if(y->r == x) y->r = this;\n      y->update();\n    }\n  }\n\n  void rotl() {\n    LP x = p, y = x->p;\n    if((x->r = l)) l->p = x;\n    l = x, x->p = this;\n    x->update(), update();\n    if((p = y)) {\n      if(y->l == x) y->l = this;\n      if(y->r == x) y->r = this;\n      y->update();\n    }\n  }\n\n  void splay() {\n    push();\n    while(!is_root()) {\n      LP q = p;\n      if(q->is_root()) {\n        q->push(), push();\n        if(q->l == this) rotr();\n        else rotl();\n      } else {\n        LP r = q->p;\n        r->push(), q->push(), push();\n        if(r->l == q) {\n          if(q->l == this) q->rotr(), rotr();\n          else rotl(), rotr();\n        } else {\n          if(q->r == this) q->rotl(), rotl();\n          else rotr(), rotl();\n        }\n      }\n    }\n  }\n\n  LP expose() {\n    LP rp = nullptr;\n    for(LP cur = this; cur; cur = cur->p) {\n      cur->splay();\n      cur->r = rp;\n      cur->update();\n      rp = cur;\n    }\n    splay();\n    return rp;\n  }\n\n  void link(LP parent) {\n    expose();\n    parent->expose();\n    p = parent;\n    parent->r = this;\n  }\n\n  void cut() {\n    expose();\n    LP parent = l;\n    l = nullptr;\n    parent->p = nullptr;\n  }\n\n  void evert() {\n    expose();\n    toggle();\n    push();\n  }\n\n  LP lca(LP v) {\n    expose();\n    return v->expose();\n  }\n\n  void set_propagate(const lazy_t &x) {\n    expose();\n    propagate(x);\n    push();\n  }\n};\n\nint main() {\n  int N;\n  scanf(\"%d\", &N);\n  vector< LCNode * > uku(N);\n  for(int i = 0; i < N; i++) {\n    uku[i] = new LCNode();\n    uku[i]->init_node(i, 0);\n  }\n  for(int i = 0; i < N; i++) {\n    int K;\n    scanf(\"%d\", &K);\n    while(K--) {\n      int T;\n      scanf(\"%d\", &T);\n      uku[T]->link(uku[i]);\n    }\n  }\n  int Q;\n  scanf(\"%d\", &Q);\n  while(Q--) {\n    int T;\n    scanf(\"%d\", &T);\n    if(T == 0) {\n      int V, W;\n      scanf(\"%d %d\", &V, &W);\n      uku[V]->expose();\n      uku[V]->key += W;\n    } else {\n      int U;\n      scanf(\"%d\", &U);\n      uku[U]->expose();\n      printf(\"%d\\n\", uku[U]->sum);\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n\n#include <cstdio>\n#include <cstdlib>\n#include <iostream>\n#include <cmath>\n#include <cstring>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <map>\n#include <set>\n#include <unordered_map> \n#include <unordered_set>\n#include <functional>\n\nusing namespace std;\n\ntypedef pair<long long int, long long int> P;\ntypedef tuple<int, int, int> T;\n\nlong long int INF = 1e18;\nlong long int MOD = 1e9 + 7;\n\n/*\n\n訪問順（行きがけ順）をもとに、セグ木に各頂点を割り振る。\n\n・頂点 u の部分木は、区間 [in[u], out[u]) に割り振られる。\n\n*/\n\nint sz[210000]; // 部分木の大きさ\nvector<int> g[210000]; // 親から子への辺\nint par[210000]; // 子から親への辺\nint nxt[210000]; // HL分解後の、各パスの終点\nint in[210000]; // 訪問順（行きがけ順）\nint out[210000]; // 部分木に含まれる訪問順（行きがけ順）の最大値\nint t = 0; // \n\nvoid dfs_sz(int v) {\n\tsz[v] = 1;\n\tfor(int &u: g[v]) {\n\t\tdfs_sz(u);\n\t\tsz[v] += sz[u];\n\t\tif(sz[u] > sz[g[v][0]]) {\n\t\t\tswap(u, g[v][0]);\n\t\t}\n\t}\n}\n\nvoid dfs_hld(int v) {\n\tin[v] = t++;\n\tfor(int u: g[v]) {\n\t\tnxt[u] = (u == g[v][0] ? nxt[v] : u);\n\t\tdfs_hld(u);\n\t}\n\tout[v] = t;\n}\n\nint const TREE_SIZE = (1 << 20);\n\nclass SegTree{\n\tpublic:\n\t// コンストラクタ\n\tSegTree(std::function<long long int(long long int, long long int)> monoidFunc_, long long int invalidValue_){\n\t\tmonoidFunc = monoidFunc_;\n\t\tinvalidValue = invalidValue_;\n\t}\n\t// 値の初期化\n\tvoid init(long long int initValue){\n\t\tfor(int i = 0; i < TREE_SIZE; i++){\n\t\t\tsegTree[i] = initValue;\n\t\t}\n\t}\n\t// a番目(0-indexed)をwに変更する O(log N)\n\tvoid change(int a, long long int w){\n\t\tchange_(a + 1, w);\n\t}\n\t// 区間 [a, b] (0-indexed)の値を求める O(log N)\n\tlong long int query(int a, int b){\n\t\treturn query_(a + 1, b + 2, 1, 0, TREE_SIZE / 2);\n\t}\n\tprivate:\n\tfunction<long long int(long long int, long long int)> monoidFunc;\n\tlong long int invalidValue;\n\tlong long int segTree[TREE_SIZE]; // 1-indexed\n\n\t// a番目をwに変更する O(log N)\n\tvoid change_(int a, long long int w){\n\t\ta += TREE_SIZE / 2;\n\t\tsegTree[a] = w;\n\t\tfor(int x = a / 2; x > 0; x /= 2){\n\t\t\tsegTree[x] = monoidFunc(segTree[2 * x], segTree[2 * x + 1]);\n\t\t}\n\t}\n\t// 区間 [a, b) の値を求める O(log N)\n\t// query(a, b, 1, 0, TREE_SIZE / 2) のように呼ぶ\n\tlong long int query_(int a, int b, int index, int l, int r){\n\t\tif(r <= a || b <= l){\n\t\t\treturn invalidValue;\n\t\t}\n\t\tif(a <= l && r <= b){\n\t\t\treturn segTree[index];\n\t\t}\n\t\treturn monoidFunc(query_(a, b, index * 2, l, (l + r) / 2), query_(a, b, index * 2 + 1, (l + r) / 2, r));\n\t}\n};\n\nlong long int func(long long int a, long long int b){\n\treturn a + b;\n}\nSegTree segTree(func, 0);\n\nint main(){\n\tint n;\n\tcin >> n;\n\tfor(int i = 0; i < n; i++){\n\t\tint k;\n\t\tcin >> k;\n\t\tfor(int loop = 0; loop < k; loop++){\n\t\t\tint c;\n\t\t\tcin >> c;\n\t\t\tg[i].push_back(c);\n\t\t\tpar[c] = i;\n\t\t}\n\t}\n\tdfs_sz(0);\n\tdfs_hld(0);\n\t/*\n\tcout << \"in : \";\n\tfor(int i = 0; i < n; i++){\n\t\tcout << in[i] << \" \";\n\t}\n\tcout << endl;\n\tcout << \"out : \";\n\tfor(int i = 0; i < n; i++){\n\t\tcout << out[i] << \" \";\n\t}\n\tcout << endl;\n\tcout << \"sz : \";\n\tfor(int i = 0; i < n; i++){\n\t\tcout << sz[i] << \" \";\n\t}\n\tcout << endl;\n\t*/\n\tsegTree.init(0);\n\tint q;\n\tcin >> q;\n\tfor(int loop = 0; loop < q; loop++){\n\t\tint tp;\n\t\tcin >> tp;\n\t\tif(tp == 0){\n\t\t\tlong long int v, w;\n\t\t\tcin >> v >> w;\n\t\t\tint num = segTree.query(in[v], in[v]);\n\t\t\tsegTree.change(in[v], num + w);\n\t\t\tnum = segTree.query(out[v], out[v]);\n\t\t\tsegTree.change(out[v], num - w);\n\t\t}else{\n\t\t\tint u;\n\t\t\tcin >> u;\n\t\t\tcout << segTree.query(0, in[u]) << endl;\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "// g++ macro.cpp -std=c++14\n#include <bits/stdc++.h>\ntypedef long long ll;\nconst int INF = 1e9;\nconst int MOD = 1e9+7;\nconst ll LINF = 1e18;\nusing namespace std;\n \n#define dump(x)  cout << #x << \" = \" << (x) << endl;\n#define YES(n) cout << ((n) ? \"YES\" : \"NO\"  ) << endl\n#define Yes(n) cout << ((n) ? \"Yes\" : \"No\"  ) << endl\n#define POSSIBLE(n) cout << ((n) ? \"POSSIBLE\" : \"IMPOSSIBLE\"  ) << endl\n#define Possible(n) cout << ((n) ? \"Possible\" : \"Impossible\"  ) << endl\n#define possible(n) cout << ((n) ? \"possible\" : \"impossible\"  ) << endl\n \n#define SANKOU(n,a,b) cout << ((n) ? (#a) : (#b) ) << endl\n \n#define FOR(i,a,b) for(ll i=(a);i<(b);++i)\n#define REP(i,n) for(ll i=0;i<(n);++i)\n#define REPR(i,n) for(ll i=n;i>=0;i--)\n \n#define FOREACH(x,a) for(auto&& (x) : (a) )\n \n#define WFA(d,v) REP(k,v)REP(i,v)REP(j,v)d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n \n#define SCOUT(x) cout<<(x)<<\" \"\n#define ENDL cout<<endl\n \n#define VECCIN(x) for(auto&youso_: (x) )cin>>youso_\n#define VECIN2(x,y) REP(i,x.size())cin>>x[i]>>y[i]\n#define VECCOUT(x) if(1){for(auto tt=x.begin();tt!=x.end();tt++){if(tt!=x.begin())cout<<\" \";cout<<(*tt);}cout<<endl;}\n\n#define ALL(obj) (obj).begin(),(obj).end()\n \n#define EXIST(n,x) (find(ALL(n),x)!=n.end())\n#define UNIQUE(obj) sort(ALL( obj )); obj.erase(unique(ALL(obj)),obj.end())\n#define EN(x) if(1){cout<<#x<<endl;return 0;}\n#define COUT(x) cout<<(x)<<endl\nvoid CINT(){}\ntemplate <class Head,class... Tail>\nvoid CINT(Head&& head,Tail&&... tail){\n    cin>>head;\n    CINT(move(tail)...);\n}\n#define CIN(...) int __VA_ARGS__;CINT(__VA_ARGS__)\n#define LCIN(...) ll __VA_ARGS__;CINT(__VA_ARGS__)\n#define SCIN(...) string __VA_ARGS__;CINT(__VA_ARGS__)\n \ntemplate <class T = ll>\nT IN(){T x;cin>>x;return (x);}\n \ntemplate <class Head>\nvoid VT(Head head){}\ntemplate <class Head,class Seco,class... Tail>\nvoid VT(Head&& head,Seco&& seco,Tail&&... tail){\n    seco.resize(head);\n    VT(head,move(tail)...);\n}\nvoid VT2(){}\ntemplate <class Head,class... Tail>\nvoid VT2(Head&& head,Tail&&... tail){\n  VECCIN(head);\n  VT2(move(tail)...);\n}\n \ntemplate <class Head>\nvoid VT3(Head&& head){}\ntemplate <class Head,class Seco,class... Tail>\nvoid VT3(Head&& head,Seco&& seco,Tail&&... tail){\n  seco[head]=IN();\n  VT3(head,move(tail)...);\n}\n \n#define VC1(n,...) V __VA_ARGS__;VT(n,__VA_ARGS__);VT2(__VA_ARGS__); //aaabbbccc\n#define VC2(n,...) V __VA_ARGS__;VT(n,__VA_ARGS__);REP(i,n)VT3(i,__VA_ARGS__); //abcabcabc\n \n// #include <boost/multiprecision/cpp_int.hpp>\n// using namespace boost::multiprecision; // cpp_int\n \n#define P pair<ll,ll>\n#define V vector<ll>\n#define M map<ll,ll>\n#define S set<ll>\n \n#define pb(a) push_back(a)\n#define mp make_pair\n\n\nusing value_type = ll;\n\n\nclass Node;\nusing np = shared_ptr<Node>;\n\nclass Node{\npublic:\n\n\tvalue_type val;\n\tvalue_type sum;\n\n\tint index = -1;\n\n\tnp p,l,r;\n\n\tint size = 1;\n\tbool rev = false;\n\n\tNode() : val(value_type()), sum(value_type()){}\n\tNode(value_type v) : val(v), sum(v){}\n\tNode(value_type v, int idx) : val(v), sum(v), index(idx){}\n\n\n};\n\nclass LinkCutTree{\n\npublic:\n\n\tLinkCutTree()\n\t{\n\t}\n\n\tnp makenode(value_type v){\n\t\treturn make_shared<Node>(v);\n\t}\n\n\tnp makenode(value_type v, int idx){\n\t\treturn make_shared<Node>(v, idx);\n\t}\n\n\tvoid update(np x){\n\t\tx->size = 1;\n\t\tx->sum = x->val;\n\n\t\tif(x->r){\n\t\t\tx->size += x->r->size;\n\t\t\tx->sum += x->r->sum;\n\t\t}\n\t\tif(x->l){\n\t\t\tx->size += x->l->size;\n\t\t\tx->sum += x->l->sum;\n\t\t}\n\t}\n\n\n\tbool isroot(np x){\n\t\treturn !(x->p)  || (x->p->l != x && x->p->r != x);\n\t};\n\n\tvoid rotr(np x){\n\t\tnp q = x->p; // 一つ上の親\n\t\tnp qq = q->p; // 二つ上の親\n\n\t\tif((q->l = x->r)) // xの右に子があったらqに付け替える\n\t\t\tx->r->p = q;\n\n\t\tx->r = q; // qとxで親子関係の入れ替え\n\t\tq->p = x;\n\n\t\tupdate(q);\n\t\tupdate(x);\n\n\t\tif((x->p = qq)){\n\t\t\t// 二つ上の親からみた子(qがあった所)をxに更新\n\t\t\tif(qq->l == q)\n\t\t\t\tqq->l = x;\n\t\t\tif(qq->r == q)\n\t\t\t\tqq->r = x;\n\n\t\t\tupdate(qq);\n\t\t}\n\t}\n\n\tvoid rotl(np x){\n\t\tnp q = x->p; // 一つ上の親\n\t\tnp qq = q->p; // 二つ上の親\n\n\t\tif((q->r = x->l)) // xの左に子があったらqに付け替える\n\t\t\tx->l->p = q;\n\n\t\tx->l = q; // qとxで親子関係の入れ替え\n\t\tq->p = x;\n\n\t\tupdate(q);\n\t\tupdate(x);\n\n\t\tif((x->p = qq)){\n\t\t\t// 二つ上の親からみた子(qがあった所)をxに更新\n\t\t\tif(qq->l == q)\n\t\t\t\tqq->l = x;\n\t\t\tif(qq->r == q)\n\t\t\t\tqq->r = x;\n\n\t\t\tupdate(qq);\n\t\t}\n\t}\n\n\t// 対象のノードをsplay木の親まで持っていく\n\tnp splay(np x){\n\t\tpush(x);\n\n\t\twhile(!isroot(x)){\n\t\t\tnp q = x->p;\n\n\t\t\tif(isroot(q)){\n\n\t\t\t\tpush(q);\n\t\t\t\tpush(x);\n\n\t\t\t\tif(q->l == x)\n\t\t\t\t\trotr(x);\n\t\t\t\telse\n\t\t\t\t\trotl(x);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tnp qq = q->p;\n\n\t\t\tpush(qq);\n\t\t\tpush(q);\n\t\t\tpush(x);\n\n\t\t\tif(qq->l == q){\n\t\t\t\tif(q->l == x){\n\t\t\t\t\trotr(q); // 一直線なら\n\t\t\t\t\trotr(x);\n\t\t\t\t}else{\n\t\t\t\t\trotl(x);\n\t\t\t\t\trotr(x);\n\t\t\t\t}\n\t\t\t}else{\n\t\t\t\tif(q->r == x){\n\t\t\t\t\trotl(q); // 一直線なら\n\t\t\t\t\trotl(x);\n\t\t\t\t}else{\n\t\t\t\t\trotr(x);\n\t\t\t\t\trotl(x);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn x;\n\t}\n\n\t// xと根のパスを繋げて、根を返す\n\tnp expose(np x){\n\t\tnp y;\n\t\t// どんどん親に向かっていく\n\t\tfor(np q = x; q; q = q->p){\n\t\t\tsplay(q);\n\t\t\tq->r = y;\n\t\t\tupdate(q);\n\t\t\ty = q;\n\t\t}\n\t\tsplay(x);\n\n\t\treturn y;\n\t}\n\n\t// 反転処理 遅延評価で呼び出す\n\tvoid toggle(np x){\n\t\tswap(x->l, x->r);\n\t\tx->rev ^= 1;\n\t}\n\n\t// 遅延評価\n\tvoid push(np x){\n\n\t\tif(x->rev){\n\t\t\tif(x->r)\n\t\t\t\ttoggle(x->r);\n\t\t\tif(x->l)\n\t\t\t\ttoggle(x->l);\n\n\t\t\tx->rev = false;\n\t\t}\n\t}\n\n\t// xとyを繋げる xが根になる\n\tvoid link(np x, np y){\n\t\texpose(y);\n\t\texpose(x);\n\t\tx->r = y;\n\t\ty->p = x;\n\t}\n\n\t// xを根から切る\n\tvoid cut(np x){\n\t\texpose(x);\n\t\tnp y = x->l;\n\t\tx->l.reset();\n\t\ty->p.reset();\n\t}\n\n\t// xを根にする\n\tvoid evert(np x){\n\t\texpose(x);\n\t\ttoggle(x);\n\t\tpush(x);\n\t}\n\n\tnp lca(np x, np y){\n\t\texpose(x);\n\t\treturn expose(y);\n\t}\n\n};\n\n\nint main(){\n\n\tCIN(n);\n\tLinkCutTree t;\n\n\tvector<np> nodes(n);\n\tREP(i,n)\n\t\tnodes[i] = t.makenode(0,i);\n\n\tREP(i,n){\n\t\tCIN(k);\n\t\tREP(j,k)\n\t\t\tt.link(nodes[i], nodes[IN()]);\n\t}\n\n\n\tCIN(q);\n\t\n\tREP(f,q){\n\t\tif(IN()){\n\t\t\tCIN(k);\n\t\t\tt.expose(nodes[k]);\n\n\t\t\tCOUT(nodes[k]->sum);\n\t\t}else{\n\t\t\tCIN(a,b);\n\t\t\tt.expose(nodes[a]);\n\t\t\tnodes[a]->val += b;\n\t\t}\n\t}\n\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate<class T>\nbool chmax(T& a, const T& b) {\n    if (a < b) { a = b; return true; }\n    return false;\n}\ntemplate<class T>\nbool chmin(T& a, const T& b) {\n    if (b < a) { a = b; return true; }\n    return false;\n}\n// std::vector Declaration\ntemplate<typename T>\nvector<T> make_v(size_t a) { return vector<T>(a); }\ntemplate<typename T, typename... Ts>\nauto make_v(size_t a, Ts... ts) {\n    return vector<decltype(make_v<T>(ts...))>(a, make_v<T>(ts...));\n}\n// std::vector Declaration and Initialization\ntemplate<typename T>\nvector<T> make_vector(size_t a, T x) { return vector<T>(a, x); }\ntemplate<typename T, typename U, typename... Ts>\nauto make_vector(size_t a, U b, Ts... ts) {\n    return vector<decltype(make_vector<T>(b,ts...))>(a, make_vector<T>(b, ts...));\n}\n// std::vector Input\ntemplate<typename T>\nistream& operator>>(istream& is, vector<T>& v) {\n    for (auto &e : v) is >> e;\n    return is;\n}\n// std::vector Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const vector<T>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::array Debug\ntemplate<typename T, size_t n>\nostream& operator<<(ostream& os, const array<T, n>& v) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : v) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::deque Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const deque<T>& d) {\n    os << \"[\";\n    bool a = 1;\n    for (auto e : d) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"]\";\n    return os;\n}\n// std::pair Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const pair<T, U>& p) {\n    os << \"(\" << p.first << \" \" << p.second << \")\";\n    return os;\n}\n// std::set Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const set<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::multiset Debug\ntemplate<typename T>\nostream& operator<<(ostream& os, const multiset<T>& st) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : st) {\n        os << (a ? \"\" : \" \");\n        os << e;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::map Debug\ntemplate<typename T, typename U>\nostream& operator<<(ostream& os, const map<T, U>& mp) {\n    os << \"{\";\n    bool a = 1;\n    for (auto e : mp) {\n        os << (a ? \"\" : \" \");\n        os << e.first << \":\" << e.second;\n        a = 0;\n    }\n    os << \"}\";\n    return os;\n}\n// std::tuple Debug\ntemplate<int N, class Tuple>\nvoid out(ostream& os, const Tuple& t){}\ntemplate<int N, class Tuple, class H, class ...Ts>\nvoid out(ostream& os, const Tuple& t) {\n    if (N) os << \" \";\n    os << get<N>(t);\n    out<N+1,Tuple,Ts...>(os, t);\n}\ntemplate<class ...Ts>\nostream& operator<<(ostream& os, const tuple<Ts...>& t) {\n    os << \"(\";\n    out<0,tuple<Ts...>,Ts...>(os, t);\n    os << \")\";\n    return os;\n}\n// Debug\n// Weighted edge\ntemplate<typename T>\nstruct edge {\n    int src, to;\n    T cost;\n    edge() {}\n    edge(int to, T cost) : src(-1), to(to), cost(cost) {}\n    edge(int src, int to, T cost) : src(src), to(to), cost(cost) {}\n    friend ostream& operator<<(ostream& os, const edge& e) {\n        return os << \"(\" << e.src << \"->\" << e.to << \":\" << e.cost << \")\";\n    }\n};\nusing LL = int64_t;\nconst int64_t MOD = 1e9+7;\nstruct EulerTour {\n    using G = vector<vector<int>>;\n    const G& g;\n    vector<int> ds, us;\n    EulerTour(const G& g) :\n        g(g), ds(g.size()), us(g.size()) {}\n    void dfs(int v, int p, int& idx) {\n        for (int u : g[v]) {\n            if (u == p) continue;\n            ds[u] = idx++;\n            dfs(u, v, idx);\n            us[u] = idx++;\n        }\n    }\n    void build(int v) {\n        int idx = 1;\n        dfs(v, -1, idx);\n        us[v] = 2 * g.size() - 1;\n    }\n};\ntemplate<typename T>\nstruct BIT {\n    // BIT<T> bit(n);\n    //\n    // bit.add(i,x) for i in [0,n)\n    //   bit[i] += x;\n    //\n    // bit.sum(i) for i in [0,n)\n    //   return bit[0] + ... + bit[i]\n    vector<T> data;\n    BIT(int n) : data(n+1) {}\n    void add(int i, T x) {\n        for (++i; i < data.size(); i += i & -i) data[i] += x;\n    }\n    T sum(int i) {\n        T s = 0;\n        for (++i; i > 0; i -= i & -i) s += data[i];\n        return s;\n    }\n};\nint main() {\n    int n; cin >> n;\n    vector<vector<int>> G(n);\n    for (int i = 0; i < n; ++i) {\n        int k; cin >> k; G[i].resize(k);\n        for (int j = 0; j < k; ++j) {\n            cin >> G[i][j];\n        }\n    }\n    EulerTour tour(G);\n    tour.build(0);\n    BIT<int> bit(2*n);\n    int q; cin >> q;\n    for (int t = 0; t < q; ++t) {\n        int c; cin >> c;\n        if (c == 1) {\n            int v; cin >> v;\n            cout << bit.sum(tour.ds[v]) << endl;\n        }\n        if (c == 0) {\n            int v, w; cin >> v >> w;\n            bit.add(tour.ds[v], w);\n            bit.add(tour.us[v], -w);\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<map>\n#include<set>\n#include<string>\n#include<queue>\n#include<stack>\nusing namespace std;\n#define MON 1000000007\n#define INF (1<<29)\ntypedef long long Int;\ntypedef pair<Int, Int> P;\n\n#define max(x, y) ((x)>(y)?(x):(y))\n#define min(x, y) ((x)<(y)?(x):(y))\nvector<int> children[108000];\nint parent[108000];\nint s[108000];\nint u, v, w, n, k, c, q;\nint group[108000];\nint index[108000];\nint order;\nvoid dfs_size(int x){\n  s[x] = 1;\n  for(auto c:children[x]){\n    dfs_size(c);\n    s[x] += s[c];\n  }\n}\n\nvoid dfs_hl(int x, int boss = -1){\n  if(boss != -1)group[x] = boss;\n  else{\n    group[x] = x;\n    index[x] = 0;\n  }\n  if(children[x].empty())return;\n  for(int i = 1;i < children[x].size();i++){\n    if(s[children[x][i]] > s[children[x][0]])\n      swap(children[x][i], children[x][0]);\n  }\n  index[children[x][0]] = index[x] + 1;\n  for(int i = 0;i < children[x].size();i++){\n    dfs_hl(children[x][i], i==0?group[x]:-1);\n  }  \n}\n\nvector<int> bit[108000];\n\nvoid add(vector<int> &bit, int x, int val){\n  x++;\n  while(x < bit.size()){\n    bit[x] += val;\n    x += x & -x;\n  }\n}\n\nInt sum(vector<int> &bit, int x){\n  x++;\n  Int res = 0;\n  while(x){\n    res += bit[x];\n    x -= x & -x;\n  }\n  return res;\n}\n\nint main(){\n  cin >> n;\n  for(int i = 0;i < n;i++){\n    cin >> k;\n    for(int j = 0;j < k;j++){\n      cin >> c;\n      children[i].push_back(c);\n      parent[c] = i;\n    }\n  }\n  parent[0] = -1;\n  dfs_size(0);\n  dfs_hl(0);\n  for(int i = 0;i < n;i++)bit[group[i]].push_back(0);\n  for(int i = 0;i < 108000;i++)if(!bit[i].empty())bit[i].push_back(0);\n  cin >> q;\n  while(q--){\n    cin >> order;\n    if(order == 0){\n      cin >> v >> w;\n      int boss = group[v];\n      add(bit[boss], index[v], w);\n    }\n    if(order == 1){\n      cin >> u;\n      Int res = 0;\n      while(u != -1){\n\tint boss = group[u];\n\tres += sum(bit[boss], index[u]);\n\tu = parent[boss];\n      }\n      cout << res << endl;\n    }\n  }\n  \n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pii;\ntypedef pair<ll, ll> pll;\nconst int INF = 1e9;\nconst ll LINF = 1e18;\ntemplate<class S,class T> ostream& operator << (ostream& out,const pair<S,T>& o){ out << \"(\" << o.first << \",\" << o.second << \")\"; return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<T> V){ for(int i = 0; i < V.size(); i++){ out << V[i]; if(i!=V.size()-1) out << \" \";} return out; }\ntemplate<class T> ostream& operator << (ostream& out,const vector<vector<T> > Mat){ for(int i = 0; i < Mat.size(); i++) { if(i != 0) out << endl; out << Mat[i];} return out; }\ntemplate<class S,class T> ostream& operator << (ostream& out,const map<S,T> mp){ out << \"{ \"; for(auto it = mp.begin(); it != mp.end(); it++){ out << it->first << \":\" << it->second; if(mp.size()-1 != distance(mp.begin(),it)) out << \", \"; } out << \" }\"; return out; }\n\n\n// HL-Decomposition\nstruct HLD{\n    typedef ll TYPE;\n    typedef pair<TYPE,TYPE> PTT;\n    TYPE V; // 頂点数\n    TYPE root;\n    vector<vector<TYPE>> G;\n    vector<TYPE> parent,Hchild,number,id,group,depth;\n    vector<PTT> paths; // [u,v]間の経路を分解(最大でもlogN)\n    vector<PTT> Ledges; // pathsを結ぶライドエッジ\n    \n    HLD() {root = V = -1; }\n    HLD(TYPE V):\n    V(V),root(0),G(V),parent(V,-1),Hchild(V,-1),number(V,-1),id(V,-1),group(V,-1),depth(V,0){}\n    void init(TYPE V){\n        V = V; root = 0;\n        G.clear(); parent.clear(); Hchild.clear(); number.clear();\n        id.clear(); group.clear(); depth.clear();\n        G.resize(V); parent.assign(V,-1); Hchild.assign(V,-1);\n        number.assign(V,-1); id.assign(V,-1); group.assign(V,-1); depth.assign(V,0);\n    }\n    \n    void add_edge(TYPE u,TYPE v){ G[u].push_back(v); G[v].push_back(u);}\n    void build(TYPE _root = 0){\n        root = _root;\n        int num = 0;\n        dfs1(); init_number(num); dfs2();\n    }\n    TYPE dfs1(TYPE pos = -1,TYPE pre = -1){\n        if(pos == -1) pos = root;\n        TYPE maxw = -1, weight = 1;\n        for(TYPE next:G[pos]){\n            if(next == pre) continue;\n            TYPE child_weight = dfs1(next,pos);\n            weight += child_weight;\n            if(maxw < child_weight){ Hchild[pos] = next; maxw = child_weight; }\n        }\n        return weight;\n    }\n    void dfs2(TYPE pos = -1,TYPE pre = -1,TYPE dep = 0,TYPE g = -1){\n        if(pos == -1) pos = g = root;\n        parent[pos] = pre; depth[pos] = dep; group[pos] = g;\n        for(TYPE next:G[pos]){\n            if(next == pre) continue;\n            dfs2(next,pos,dep+1,Hchild[pos]==next?g:next);\n        }\n    }\n    void init_number(int& num,TYPE pos = -1,TYPE pre = -1){\n        if(pos == -1) pos = root;\n        number[pos] = num++;\n        id[number[pos]] = pos;\n        if(Hchild[pos] >= 0) init_number(num,Hchild[pos],pos);\n        for(TYPE next:G[pos]){\n            if(next != pre && next != Hchild[pos]) init_number(num,next,pos);\n        }\n    }\n    \n    void buildPaths(TYPE u,TYPE v){\n        if(depth[group[u]] < depth[group[v]]) swap(u,v);\n        TYPE num_u=number[u], num_v=number[v];\n        if(same(u,v)){ paths.push_back({min(num_u,num_v),max(num_u,num_v)}); return;}\n        TYPE group_u = group[u];\n        buildPaths(parent[group_u],v);\n        paths.push_back({number[group_u], number[u]});\n        Ledges.push_back({number[parent[group_u]], number[group_u]});\n    }\n    \n    TYPE lca(TYPE u,TYPE v){\n        if(depth[group[u]] < depth[group[v]]) swap(u,v);\n        if(same(u,v)) return depth[u] < depth[v]?u:v;\n        return lca(parent[group[u]],v);\n    }\n    pair<vector<PTT>,vector<PTT>> getPath(TYPE u,TYPE v){\n        paths.clear(); Ledges.clear();\n        buildPaths(u,v);\n        return make_pair(paths,Ledges);\n    }\n    bool same(TYPE a,TYPE b){return group[a] == group[b];}\n};\n\n// ================================= //\n// use example\n\n/*\n update : [s,t)にxを加算する\n query : [s,t) の総和を出力する\n */\nconst ll INIT = 0;\nstruct SegTree {\n    int N;\n    ll init_v;\n    vector<ll> node, lazy;\n    SegTree(int _N):init_v(INIT) {\n        N = 1; while (N < _N) N *= 2;\n        node.resize(2 * N - 1, init_v); lazy.resize(2 * N - 1, init_v);\n    }\n    \n    void lazy_evaluate(int k) {\n        node[k] += lazy[k]; // add のため加算\n        if (k < N - 1) { lazy[2 * k + 1] += lazy[k] / 2; lazy[2 * k + 2] += lazy[k] / 2; }\n        lazy[k] = 0;\n    }\n    \n    /* [a,b) 引数の範囲に注意!! s~tまでを更新→update(s,t+1,~) */\n    ll update(int a, int b, int x) { return update(a, b, 0, 0, N, x); }\n    ll update(int a, int b, int k, int l, int r, int x) {\n        if (r <= a || b <= l) { lazy_evaluate(k); return node[k]; }\n        if (a <= l && r <= b) { lazy[k] += (r - l) * x; lazy_evaluate(k); return node[k]; }\n        else {\n            lazy_evaluate(k);\n            ll vl = update(a, b, 2 * k + 1, l, (l + r) / 2, x);\n            ll vr = update(a, b, 2 * k + 2, (l + r) / 2, r, x);\n            return node[k] = vl + vr;\n        }\n    }\n    \n    /* [a,b) 引数の範囲に注意!! */\n    ll query(int a, int b) { return query(a, b, 0, 0, N); }\n    ll query(int a, int b, int k, int l, int r) {\n        if (r <= a || b <= l) return init_v;\n        if (a <= l && r <= b) { lazy_evaluate(k); return node[k]; }\n        else {\n            lazy_evaluate(k);\n            ll vl = query(a, b, 2 * k + 1, l, (l + r) / 2);\n            ll vr = query(a, b, 2 * k + 2, (l + r) / 2, r);\n            return vl + vr;\n        }\n    }\n};\n\n\n// LCA : http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_C&lang=jp\nvoid GRL_5_C(){\n    ll n; cin >> n;\n    HLD hld(n);\n    for(int i = 0; i < n;i++){\n        ll k; cin >> k;\n        for(int j = 0; j < k;j++){\n            ll c; cin >> c;\n            hld.add_edge(i, c);\n        }\n    }\n    hld.build();\n    ll q; cin >> q;\n    while(q--){\n        ll u,v; cin >> u >> v;\n        cout << hld.lca(u,v) << endl;\n    }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_E&lang=jp\nvoid GRL_5_D(){\n    ll n; cin >> n;\n    HLD hld(n);\n    for(int i = 0; i < n;i++){\n        ll k; cin >> k;\n        for(int j = 0; j < k;j++){\n            ll c; cin >> c;\n            hld.add_edge(i, c);\n        }\n    }\n    hld.build();\n    SegTree ST(n);\n    \n    // add(v,w): 節点 v の親と、節点 v の間にある辺の重みを w 増加させる\n    auto query0=[&](ll u,ll w){\n        auto path = hld.getPath(hld.parent[u], u).first;\n        path[0].first++;\n        for(auto p:path){\n            ll l = p.first, r = p.second;\n            ST.update(l,r+1,w);\n        }\n    };\n    \n    // getSum(u) : 根から節点 u までの間にある辺の重みの総和を報告する。\n    auto query1 = [&](ll u){\n        auto path = hld.getPath(0,u).first;\n        path[0].first++;\n        ll ret = 0;\n        for(auto p:path){\n            ll l = p.first, r = p.second;\n            ret += ST.query(l,r+1);\n        }\n        return ret;\n    };\n    \n    ll q; cin >> q;\n    while(q--){\n        ll com; cin >> com;\n        if(com == 0){\n            ll v,w; cin >> v >> w;\n            query0(v,w);\n        }else{\n            ll u; cin >> u;\n            cout << query1(u) << endl;\n        }\n    }\n}\n\n// http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=GRL_5_E&lang=jp\nvoid GRL_5_E(){\n    ll n; cin >> n;\n    HLD hld(n);\n    for(int i = 0; i < n;i++){\n        ll k; cin >> k;\n        for(int j = 0; j < k;j++){\n            ll c; cin >> c;\n            hld.add_edge(i, c);\n        }\n    }\n    hld.build();\n    SegTree ST(n);\n    \n    // add(v,w): 節点 v の親と、節点 v の間にある辺の重みを w 増加させる\n    auto query0=[&](ll u,ll w){\n        auto path = hld.getPath(0, u).first;\n        path[0].first++;\n        for(auto p:path){\n            ll l = p.first, r = p.second;\n            ST.update(l,r+1,w);\n        }\n    };\n    \n    // getSum(u) : 根から節点 u までの間にある辺の重みの総和を報告する。\n    auto query1 = [&](ll u){\n        auto path = hld.getPath(0,u).first;\n        path[0].first++;\n        ll ret = 0;\n        for(auto p:path){\n            ll l = p.first, r = p.second;\n            ret += ST.query(l,r+1);\n        }\n        return ret;\n    };\n    \n    ll q; cin >> q;\n    while(q--){\n        ll com; cin >> com;\n        if(com == 0){\n            ll v,w; cin >> v >> w;\n            query0(v,w);\n        }else{\n            ll u; cin >> u;\n            cout << query1(u) << endl;\n        }\n    }\n}\nint main(void) {\n    cin.tie(0); ios_base::sync_with_stdio(false);\n    //GRL_5_C();\n    GRL_5_D();\n    //GRL_5_E();\n    return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntemplate <typename T>\nstruct segment_tree{\n\tint N;\n\tvector<T> ST;\n\tfunction<T(T, T)> f;\n\tT E;\n\tsegment_tree(){\n\t}\n\tsegment_tree(int n, function<T(T, T)> f, T E): f(f), E(E){\n\t\tN = 1;\n\t\twhile (N < n){\n\t\t\tN *= 2;\n\t\t}\n\t\tST = vector<T>(N * 2 - 1, E);\n\t}\n\tvoid update(int k, T x){\n\t\tk += N - 1;\n\t\tST[k] = x;\n\t\twhile (k > 0){\n\t\t\tk = (k - 1) / 2;\n\t\t\tST[k] = f(ST[k * 2 + 1], ST[k * 2 + 2]);\n\t\t}\n\t}\n\tT query(int L, int R, int i, int l, int r){\n\t\tif (r <= L || R <= l){\n\t\t\treturn E;\n\t\t} else if (L <= l && r <= R){\n\t\t\treturn ST[i];\n\t\t} else {\n\t\t\tint m = (l + r) / 2;\n\t\t\treturn f(query(L, R, i * 2 + 1, l, m), query(L, R, i * 2 + 2, m, r));\n\t\t}\n\t}\n\tT query(int L, int R){\n\t\treturn query(L, R, 0, 0, N);\n\t}\n};\ntemplate <typename T>\nstruct euler_tour_path_query_commutative{\n\tvector<T> A;\n\tvector<int> left;\n\tvector<int> right;\n\tT E;\n\tfunction<T(T, T)> f;\n\tfunction<T(T)> inv;\n\tsegment_tree<T> ST;\n\tvoid dfs(int v, vector<vector<int>> &c){\n\t\tleft[v] = A.size();\n\t\tA.push_back(E);\n\t\tfor (int w : c[v]){\n\t\t\tdfs(w, c);\n\t\t}\n\t\tright[v] = A.size();\n\t\tA.push_back(E);\n\t}\n\teuler_tour_path_query_commutative(vector<vector<int>> &c, function<T(T, T)> f, function<T(T)> inv, T E): f(f), inv(inv), E(E){\n\t\tint N = c.size();\n\t\tleft = vector<int>(N);\n\t\tright = vector<int>(N);\n\t\tdfs(0, c);\n\t\tST = segment_tree<T>(A.size(), f, E);\n\t}\n\tvoid update(int v, T x){\n\t\tA[left[v]] = x;\n\t\tST.update(left[v], x);\n\t\tST.update(right[v], inv(x));\n\t}\n\tT query(int v){\n\t\treturn ST.query(0, left[v] + 1);\n\t}\n};\nlong long add(long long a, long long b){\n  return a + b;\n}\nlong long neg(long long a){\n  return -a;\n}\nint main(){\n  int n;\n  cin >> n;\n  vector<int> p(n, -1);\n  vector<vector<int>> c(n);\n  for (int i = 0; i < n; i++){\n    int k;\n    cin >> k;\n    c[i] = vector<int>(k);\n    for (int j = 0; j < k; j++){\n      cin >> c[i][j];\n      p[c[i][j]] = i;\n    }\n  }\n  euler_tour_path_query_commutative<long long> ET(c, add, neg, 0);\n  int q;\n  cin >> q;\n  for (int i = 0; i < q; i++){\n    int t;\n    cin >> t;\n    if (t == 0){\n      int v;\n      long long w;\n      cin >> v >> w;\n      ET.update(v, ET.A[ET.left[v]] + w);\n    }\n    if (t == 1){\n      int u;\n      cin >> u;\n      cout << ET.query(u) << endl;\n    }\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nstruct RSQ{\n  ll n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 1 index\n  /*void add(int i,int v){\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }*/\n  // 0 index\n  void add(int i,ll v){\n    i+=1;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  ll sum(int i){\n    ll res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) 1 index\n  /*int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }*/\n  //[a,b) 0 index\n  int sum(int x,int y){\n    x++;y++;\n    return sum(y-1)-sum(x-1);\n  }\n};\n \nstruct HLD {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  RSQ rsq;\n\n  HLD(){}\n  HLD(int sz):n(sz),pos(0),G(n),vid(n,-1),head(n),sub(n,1),hvy(n,-1),par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs) {\n    if(rs.size()==0)rs.push_back(0);\n    int c=0;\n    for(int i=0;i<rs.size();i++){\n        int r=rs[i];\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    stack<P> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.push(P(rt,0));\n    while(!st.empty()){\n        int v=st.top().first;\n        int &i=st.top().second;\n        if(i<(int)G[v].size()){\n            int u=G[v][i++];\n            if(u==par[v]) continue;\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            st.push(P(u,0));\n        }else{\n            st.pop();\n            int res=0;\n            for(int i=0;i<G[v].size();i++){\n                int u=G[v][i];\n                if(u==par[v]) continue;\n                sub[v]+=sub[u];\n                if(res<sub[u]) res=sub[u],hvy[v]=u;\n            }\n        }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q;\n    q.push(r);\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n        type[i]=c;\n        vid[i]=k++;\n        inv[vid[i]]=i;\n        head[i]=h;\n        for(int J=0;J<G[i].size();J++){\n            int j=G[i][J];\n            if(j!=par[i]&&j!=hvy[i]) q.push(j);\n        }\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  int for_each(int u, int v) {\n    int ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      //f(max(vid[head[v]],vid[u]),vid[v]);\n      //ans = max(ans,rmq.query(l, r + 1));\n      if(head[u]!=head[v]) v=par[head[v]];\n      else {return ans;}\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  ll for_each_edge(int u, int v) {\n    ll ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n        //f(vid[head[v]],vid[v]);\n        ans += rsq.sum(vid[head[v]],vid[v]+1);\n        v=par[head[v]];\n      } else{\n        //if(u!=v) f(vid[u]+1,vid[v]);\n        if(u!=v) ans += rsq.sum(vid[u]+1,vid[v]+1);\n        return ans;\n      }\n    }\n  }\n\n  void update(int u,int w){\n    rsq.add(vid[u],w);\n  }\n\n  void range_update(){\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\nint main(){\n    int n,m,x,w;\n    scanf(\"%d\",&n);\n    HLD Tree(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&x);\n            Tree.add_edge(i,x);\n        }\n    }\n    Tree.build();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        if(m==0){\n            scanf(\"%d%d\",&x,&w);\n            Tree.update(x,w);\n        }\n        else{\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",Tree.for_each_edge(0,x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <functional>\n#include <iostream>\n#include <vector>\n\n#define REP(i,n) for (int i=0;i<(n);++i)\n\nstruct edge {\n    typedef size_t weight_type;\n\n    size_t m_to;\n\n    edge(size_t to) : m_to(to) { }\n\n    inline size_t to() const { return m_to; }\n\n    inline weight_type weight() const { return 1; }\n\n    friend std::ostream& operator<<(std::ostream &os, const edge &e) {\n        os << \"{ to: \" << e.m_to << \" }\";\n        return os;\n    }\n};\n\ntemplate <class Edge>\nstruct graph {\n    typedef Edge edge_type;\n\n    size_t m_n_vertices;\n    std::vector<std::vector<edge_type>> m_edges;\n\n    graph(size_t n_vertices) : m_n_vertices(n_vertices), m_edges(n_vertices) { }\n\n    inline size_t n_vertices() const { return m_n_vertices; }\n\n    inline void make_edge(size_t from, size_t to, typename edge_type::weight_type weight) {\n        m_edges[from].emplace_back(edge_type(to, weight));\n    }\n\n    inline void make_edge(size_t from, size_t to) {\n        m_edges[from].emplace_back(edge(to));\n    }\n\n    inline void make_edge(size_t from, const edge_type &e) {\n        m_edges[from].emplace_back(e);\n    }\n\n    inline std::vector<edge_type> edges_from(size_t v) const {\n        return m_edges[v];\n    }\n};\n\nunsigned long long clp(unsigned long long x) {\n    x -= 1;\n    x = x | (x >>  1);\n    x = x | (x >>  2);\n    x = x | (x >>  4);\n    x = x | (x >>  8);\n    x = x | (x >> 16);\n    x = x | (x >> 32);\n    return x + 1;\n}\n\ntemplate <class T>\nclass segment_tree {\nprivate:\n    const size_t n;\n    const T UNIT;\n    const std::function<T(const T&, const T&)> f;\n    T *a;\npublic:\n    segment_tree(size_t size, T UNIT, std::function<T(const T&, const T&)> f) : n(clp(size)), UNIT(UNIT), f(f) {\n        a = new T[2 * n - 1];\n        std::fill(a, a + 2 * n - 1, UNIT);\n    }\n    ~segment_tree() {\n        delete [] a;\n    }\n    void update(size_t i, const T &x) {\n        i += n - 1;\n        a[i] += x;\n        while (i) {\n            i = (i - 1) / 2;\n            a[i] = f(a[2 * i + 1], a[2 * i + 2]);\n        }\n    }\n    T query(size_t query_first, size_t query_last, size_t k = 0, size_t node_first = 0, size_t node_last = 0) const {\n        if (k == 0) {\n            node_last = n;\n        }\n        if (node_last <= query_first || query_last <= node_first) {\n            return UNIT;\n        }\n        if (query_first <= node_first && node_last <= query_last) {\n            return a[k];\n        } else {\n            size_t node_mid = (node_first + node_last) / 2;\n            T vl = query(query_first, query_last, k * 2 + 1, node_first, node_mid);\n            T vr = query(query_first, query_last, k * 2 + 2, node_mid, node_last);\n            return f(vl, vr);\n        }\n    }\n};\n\ntemplate <class Graph>\nstruct heavy_light_decomposition {\n    using Edge = typename Graph::edge_type;\n    using Weight = typename Edge::weight_type;\n\n    size_t n_vertices;\n    size_t m_root;\n    std::vector<size_t> branch_vertices;\n    std::vector<size_t> pos;\n    std::vector<size_t> pos_end;\n    std::vector<size_t> depth;\n    segment_tree<Weight> seg_tree;\n    const size_t NIL;\n\n    heavy_light_decomposition(const Graph &g, size_t root) : n_vertices(g.n_vertices()), m_root(root) , seg_tree(n_vertices, 0, [](Weight x, Weight y) { return x + y; }), NIL(n_vertices) {\n\n        std::vector<size_t> sizes(n_vertices);\n        std::vector<size_t> heavy_children(n_vertices);\n        branch_vertices.resize(n_vertices);\n        pos.resize(n_vertices);\n        pos_end.resize(n_vertices);\n        depth.resize(n_vertices);\n\n        std::function<size_t(size_t, size_t)> dfs = [&](size_t v, size_t parent) {\n\n            sizes[v] = 1;\n            heavy_children[v] = NIL;\n            size_t child_size_max = 0;\n\n            for (const Edge &e: g.edges_from(v)) {\n                size_t child = e.to();\n\n                if (child == parent) continue;\n                \n                dfs(child, v);\n\n                sizes[v] += sizes[child];\n\n                if (child_size_max < sizes[child]) {\n                    child_size_max = sizes[child];\n                    heavy_children[v] = child;\n                }\n            }\n\n            return sizes[v];\n        };\n\n        dfs(root, NIL);\n\n        size_t cur_pos = n_vertices;\n\n        std::function<void(size_t, size_t, size_t, size_t)> decompose = [&](size_t v, size_t parent, size_t bv, size_t ep) {\n            branch_vertices[v] = bv;\n            pos[v] = --cur_pos;\n            pos_end[v] = ep;\n            if (heavy_children[v] != NIL) {\n                decompose(heavy_children[v], v, bv, ep);\n            }\n            for (const Edge &e: g.edges_from(v)) {\n                size_t child = e.to();\n\n                if (child != parent && child != heavy_children[v]) {\n                    decompose(child, v, v, cur_pos);\n                }\n            }\n        };\n\n        decompose(root, n_vertices, n_vertices, n_vertices);\n    }\n\n    void update(size_t v, Weight w) {\n        seg_tree.update(pos[v], w);\n    }\n\n    Weight query(size_t v) {\n        Weight result = 0;\n        do {\n            result += seg_tree.query(pos[v], pos_end[v]);\n        } while ((v = branch_vertices[v]) != NIL);\n        return result;\n    }\n};\n\nint main() {\n\n    using namespace std;\n\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    using Graph = graph<edge>;\n\n    int n;\n    cin >> n;\n    Graph g(n);\n    REP(v, n) {\n        int k;\n        cin >> k;\n        REP(_, k) {\n            int c;\n            cin >> c;\n            g.make_edge(v, c);\n        }\n    }\n\n    heavy_light_decomposition<Graph> hld(g, 0);\n\n    int q;\n    cin >> q;\n    REP(_, q) {\n        int query_type;\n        cin >> query_type;\n        if (query_type == 0) {\n            int v, w;\n            cin >> v >> w;\n            hld.update(v, w);\n        } else {// if (query_type == 1) {\n            int u;\n            cin >> u;\n            cout << hld.query(u) << endl;\n        }\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nusing Int = long long;\n//BEGIN CUT HERE\ntemplate<typename T,typename E>\nstruct LinkCutTree{\n  struct Node{\n    Node *l,*r,*p;\n    size_t cnt;\n    int idx;\n    bool rev;\n    T val,dat;\n    E laz;\n    Node():cnt(0){}\n    Node(int idx,T val,E laz):\n      cnt(1),idx(idx),rev(0),val(val),dat(val),laz(laz){l=r=p=nullptr;}\n    bool is_root(){\n      return !p||(p->l!=this&&p->r!=this);\n    }\n  };\n  \n  using F = function<T(T,T)>;\n  using G = function<T(T,E)>;\n  using H = function<E(E,E)>;\n  using P = function<E(E,size_t)>;\n  using S = function<T(T)>;\n  F f;\n  G g;\n  H h;\n  P p;\n  S s;\n  T ti;\n  E ei;\n  \n  const size_t LIM = 1e6;\n  vector<Node> pool;\n  size_t ptr;\n  \n  \n  LinkCutTree(F f,G g,H h,T ti,E ei):\n    f(f),g(g),h(h),ti(ti),ei(ei),pool(LIM),ptr(0){\n    p=[](E a,size_t b){b++;return a;};\n    s=[](T a){return a;};\n  }\n  \n  LinkCutTree(F f,G g,H h,P p,T ti,E ei):\n    f(f),g(g),h(h),p(p),ti(ti),ei(ei),pool(LIM),ptr(0){s=[](T a){return a;};}\n  \n  LinkCutTree(F f,G g,H h,P p,S s,T ti,E ei):\n    f(f),g(g),h(h),p(p),s(s),ti(ti),ei(ei),pool(LIM),ptr(0){}\n  \n  inline Node* create(){\n    return &pool[ptr++];\n  }\n  \n  inline Node* create(int idx,T v){\n    return &(pool[ptr++]=Node(idx,v,ei));\n  }\n\n  void propagate(Node *t,E v){\n    t->laz=h(t->laz,v);\n    t->val=g(t->val,v);\n    t->dat=g(t->dat,p(v,t->cnt));\n  }\n\n  void toggle(Node *t){\n    swap(t->l,t->r);\n    t->dat=s(t->dat);\n    t->rev^=1;\n  }\n\n  void eval(Node *t){\n    if(t->laz!=ei){\n      if(t->l) propagate(t->l,t->laz);\n      if(t->r) propagate(t->r,t->laz);\n      t->laz=ei;\n    }\n    if(t->rev){\n      if(t->l) toggle(t->l);\n      if(t->r) toggle(t->r);\n      t->rev=false;\n    }\n  }\n\n  void update(Node *t){\n    t->cnt=1;\n    t->dat=t->val;\n    if(t->l) t->cnt+=t->l->cnt,t->dat=f(t->l->dat,t->dat);\n    if(t->r) t->cnt+=t->r->cnt,t->dat=f(t->dat,t->r->dat);\n  }\n\n  void rotR(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->l=t->r)) t->r->p=x;\n    t->r=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n  \n  void rotL(Node *t){\n    Node *x=t->p,*y=x->p;\n    if((x->r=t->l)) t->l->p=x;\n    t->l=x;x->p=t;\n    update(x);update(t);\n    if((t->p=y)){\n      if(y->l==x) y->l=t;\n      if(y->r==x) y->r=t;\n      update(y);\n    }\n  }\n\n  void splay(Node *t){\n    eval(t);\n    while(!t->is_root()){\n      Node *q=t->p;\n      if(q->is_root()){\n\teval(q);eval(t);\n\tif(q->l==t) rotR(t);\n\telse rotL(t);\n      }else{\n\tauto *r=q->p;\n\teval(r);eval(q);eval(t);\n\tif(r->l==q){\n\t  if(q->l==t) rotR(q),rotR(t);\n\t  else rotL(t),rotR(t);\n\t}else{\t\n\t  if(q->r==t) rotL(q),rotL(t);\n\t  else rotR(t),rotL(t);\n\t}\n      }\n    }\n  }\n\n  Node* expose(Node *t){\n    Node *rp=nullptr;\n    for(Node *c=t;c;c=c->p){\n      splay(c);\n      c->r=rp;\n      update(c);\n      rp=c;\n    }\n    splay(t);\n    return rp;\n  }\n\n  void link(Node *par,Node *c){\n    expose(c);\n    expose(par);\n    c->p=par;\n    par->r=c;\n  }\n\n  void cut(Node *c){\n    expose(c);\n    Node *par=c->l;\n    c->l=nullptr;\n    par->p=nullptr;\n  }\n\n  void evert(Node *t){\n    expose(t);\n    toggle(t);\n    eval(t);\n  }\n\n  bool is_connected(Node *a,Node *b){\n    expose(a);\n    while(a->l) a=a->l;\n    expose(b);\n    while(b->l) b=b->l;\n    return a==b;\n  }\n\n  Node *lca(Node *a,Node *b){\n    expose(a);\n    return expose(b);\n  }\n\n  void set_propagate(Node *t,E v){\n    expose(t);\n    propagate(t,v);\n    eval(t);\n  }\n};\n\n//END CUT HERE\n//INSERT ABOVE HERE\n\nsigned GRL_5_C(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return min(a,b);};\n  LCT lc(f,f,f,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int a,b;\n    cin>>a>>b;\n    cout<<lc.lca(v[a],v[b])->idx<<endl;\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_C\n*/\n\nsigned GRL_5_D(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<int,int>;\n  LCT::F f=[](int a,int b){return a+b;};\n  LCT lc(f,f,f,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.expose(v[a]);\n      v[a]->val=f(v[a]->val,b);\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_D\n*/\n\n\nsigned GRL_5_E(){\n  int n;\n  cin>>n;\n  using LCT = LinkCutTree<Int,Int>;\n  LCT::F f=[](Int a,Int b){return a+b;};\n  LCT::P p=[](Int a,size_t b){return a*b;};\n  LCT lc(f,f,f,p,0,0);\n\n  vector<LCT::Node*> v(n);\n  for(int i=0;i<n;i++) v[i]=lc.create(i,0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      lc.link(v[i],v[c]);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  Int c=0;\n  for(int i=0;i<q;i++){\n    int t;\n    cin>>t;\n    if(t==0){\n      int a,b;\n      cin>>a>>b;\n      lc.set_propagate(v[a],b);\n      c+=b;\n    }\n    if(t==1){\n      int a;\n      cin>>a;\n      lc.expose(v[a]);\n      cout<<v[a]->dat-c<<endl;\n    }\n  }\n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://onlinejudge.u-aizu.ac.jp/problems/GRL_5_E\n*/\n\nsigned JOISC2013_DAY4_3(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n  \n  using LCT = LinkCutTree<int, int>;\n  auto f=[](int a,int b){return a+b;};\n  LCT lct(f,f,f,0,0);\n  vector<LCT::Node*> vs(n);\n  for(int i=0;i<n;i++) vs[i]=lct.create(i,0);\n\n  for(int i=0;i<q;i++){\n    int t,a,b=0;\n    scanf(\"%d %d\",&t,&a);\n    if(t!=2) scanf(\"%d\",&b);\n    a--;b--;\n    if(t==1) lct.link(vs[b],vs[a]);\n    if(t==2) lct.cut(vs[a]);\n    if(t==3){\n      if(!lct.is_connected(vs[a],vs[b])) puts(\"-1\");\n      else printf(\"%d\\n\",lct.lca(vs[a],vs[b])->idx+1);\n    }\n  }\n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  https://beta.atcoder.jp/contests/joisc2013-day4/tasks/joisc2013_spaceships\n*/\n\nsigned AOJ_2450(){\n  int n,q;\n  scanf(\"%d %d\",&n,&q);\n\n  using T = tuple<int,int,int,int,int,int,int>;\n  using P = pair<int,int>;\n  using LCT = LinkCutTree<T, P>;\n\n  vector<vector<int> > G(n); \n  T d1(-1,-1,-1,-1,-1,-1,-1);\n  P d0(-1,-114514);\n  \n  vector<LCT::Node* > vs(n);\n  vector<int> ps(n,-1);\n  \n  auto f=[&](T a,T b){\n    int al,ar,as,ava,avi,avl,avr;\n    tie(al,ar,as,ava,avi,avl,avr)=a;\n    int bl,br,bs,bva,bvi,bvl,bvr;\n    tie(bl,br,bs,bva,bvi,bvl,bvr)=b;\n    int cl=al,cr=br,cs=as+bs;\n    int cva=ava+bva,cvi=max(avi,bvi),cvl=avl,cvr=bvr;\n    cvi=max(cvi,avr+bvl);\n    cvl=max(cvl,ava+bvl);\n    cvr=max(cvr,avr+bva);\n    return T(cl,cr,cs,cva,cvi,cvl,cvr);\n  };\n  \n  auto g=[&](T a,P p){\n    if(p==d0) return a;\n    int al,ar,as,ava,avi,avl,avr;\n    tie(al,ar,as,ava,avi,avl,avr)=a;\n    int v=p.first,b=p.second;\n    if(~v) al=ar=v,as=1;\n    if(b>=0) return T(al,ar,as,b*as,b*as,b*as,b*as);\n    return T(al,ar,as,b*as,b,b,b);\n  };\n  \n  auto h=[&](P a,P b){a.first++;return b;};\n  auto p=[&](P a,size_t b){b++;return a;};\n  auto s=\n    [&](T a){      \n      int al,ar,as,ava,avi,avl,avr;\n      tie(al,ar,as,ava,avi,avl,avr)=a;\n      swap(al,ar);\n      swap(avl,avr);\n      return T(al,ar,as,ava,avi,avl,avr);\n    };\n  \n  LCT lct(f,g,h,p,s,d1,d0);\n  \n  \n  vector<int> w(n);\n  for(int i=0;i<n;i++) scanf(\"%d\",&w[i]);\n  for(int i=0;i<n;i++) vs[i]=lct.create(i,g(d1,P(i,w[i])));\n  \n  for(int i=0;i<n-1;i++){\n    int a,b;\n    scanf(\"%d %d\",&a,&b);\n    a--;b--;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n\n  for(int i=0;i<n;i++)\n    sort(G[i].begin(),G[i].end());\n\n  {\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p) lct.link(vs[p],vs[v]);\n      ps[v]=p;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tq.emplace(u,v);\n      }\n    }\n  }\n  \n  while(q--){\n    int t,a,b,c;\n    scanf(\"%d %d %d %d\",&t,&a,&b,&c);\n    a--;b--;\n    if(t==1){\n      lct.evert(vs[a]);\n      lct.set_propagate(vs[b],P(-1,c));      \n    }\n    if(t==2){\n      lct.evert(vs[a]);\n      lct.expose(vs[b]);\n      int vva,vvi,vvl,vvr;\n      tie(ignore,ignore,ignore,vva,vvi,vvl,vvr)=vs[b]->dat;\n      printf(\"%d\\n\",max({vva,vvi,vvl,vvr}));\n    }\n  }\n  \n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=2450\n*/\n\nsigned AOJ_0367(){\n  int n,k;\n  cin>>n>>k;\n  \n  vector<vector<int> > G(n); \n  vector<map<Int, Int> > m(n);\n  for(Int i=0;i<n-1;i++){\n    Int a,b,c;\n    cin>>a>>b>>c;\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n    m[a][b]=m[b][a]=c;\n  }\n  \n  vector<Int> w(n,0);\n  vector<int> ps(n,-1);\n  using T = tuple<Int, Int, Int>;\n  auto mget=[&](Int a,Int b){\n\t      if(ps[a]!=b&&ps[b]!=a) return 0LL;\n\t      Int res=w[a]+w[b]+m[a][b];\n\t      if(res%k) return res;\n\t      return 0LL;\n\t    };\n  \n  auto f=[&](T a,T b){\n\t   if(a>b) swap(a,b);\n\t   Int al,ar,av;\n\t   tie(al,ar,av)=a;\n\t   Int bl,br,bv;\n\t   tie(bl,br,bv)=b;\n\t   if(al<0||ar<0) return b;\n\t   Int cl,cr,cv=av+bv;\n\t   if(m[al].count(bl)){\n\t     cl=ar;cr=br;\n\t     cv+=mget(al,bl);\n\t   }else if(m[al].count(br)){\n\t     cl=ar;cr=bl;\n\t     cv+=mget(al,br);\n\t   }else if(m[ar].count(bl)){\n\t     cl=al;cr=br;\n\t     cv+=mget(ar,bl);\n\t   }else if(m[ar].count(br)){\n\t     cl=al;cr=bl;\n\t     cv+=mget(ar,br);\n\t   }else{\n\t     cl=cr=cv=-1;\n\t   }\n\t   return T(cl,cr,cv);\n\t };\n  \n  auto g=[&](T a,Int b){b++;return a;};\n  auto h=[&](Int a,Int b){b++;return a;};\n  \n  using LCT = LinkCutTree<T, Int>;\n  LCT lct(f,g,h,T(-1,-1,0),0);  \n  vector<LCT::Node* > vs(n);\n  for(Int i=0;i<n;i++) vs[i]=lct.create(i,T(i,i,0));\n  \n  {\n    using P = pair<Int, Int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p) lct.link(vs[p],vs[v]);\n      ps[v]=p;\n      for(int u:G[v]){\n\tif(u==p) continue;\n\tq.emplace(u,v);\n      }\n    } \n  }\n  \n  Int q;\n  cin>>q;\n  while(q--){\n    string op;\n    cin>>op;\n    if(op==\"add\"){\n      Int x,d;\n      cin>>x>>d;\n      lct.expose(vs[x]);\n      w[x]+=d;\n      lct.update(vs[x]);\n    }\n    if(op==\"send\"){\n      Int s,t;\n      cin>>s>>t;\n      lct.evert(vs[s]);\n      lct.expose(vs[t]);\n      cout<<get<2>(vs[t]->dat)<<endl;\n    }\n  }  \n  \n  return 0;\n}\n\n/*\n  verified on 2018/06/14\n  http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0367\n*/\n\n\n\nstruct M{\n  Int a,b,c,d;\n  M():a(1),b(0),c(0),d(1){}\n  M(Int a,Int b,Int c,Int d):a(a),b(b),c(c),d(d){}\n  //M(const M &v):a(v.a),b(v.b),c(v.c),d(v.d){}\n  bool operator!=(const M &x)const{\n    return a!=x.a||b!=x.b||c!=x.c||d!=x.d;\n  }\n  bool operator==(const M &x)const{\n    return !(*this!=x);\n  }\n};\n\nsigned YUKI_650(){\n  const int MOD=1e9+7;\n  using M2 = pair<M, M>;\n  using LCT = LinkCutTree<M2, M2>;\n  auto f=[MOD](M x,M y){\n\t   M r(0,0,0,0);\n\t   r.a=x.a*y.a+x.b*y.c;\n\t   r.b=x.a*y.b+x.b*y.d;\n\t   r.c=x.c*y.a+x.d*y.c;\n\t   r.d=x.c*y.b+x.d*y.d;\t   \n\t   r.a%=MOD;r.b%=MOD;r.c%=MOD;r.d%=MOD;\n\t   return r;\n\t };\n  auto f2=[&](M2 x,M2 y){\n\t    return M2(f(x.first,y.first),f(y.second,x.second));\n\t  };\n  auto g=[](M2 x,M2 y){x.first.a++;return y;};\n  auto p=[](M2 x,size_t y){y++;return x;};\n  auto s=[](M2 x){swap(x.first,x.second);return x;};\n  \n  int n;\n  cin>>n;\n  vector<vector<int> > G(n);\n  vector<int> X,Y;\n  for(int i=1;i<n;i++){\n    int a,b;\n    cin>>a>>b;\n    X.emplace_back(a);\n    Y.emplace_back(b);\n    G[a].emplace_back(b);\n    G[b].emplace_back(a);\n  }\n  M ti=M();\n  M ei(-1,-1,-1,-1);\n  LCT lct(f2,g,g,p,s,M2(ti,ti),M2(ei,ei));\n\n  \n  vector<LCT::Node*> vs(n*2-1);\n  for(int i=0;i<(int)vs.size();i++) vs[i]=lct.create(i,M2(ti,ti));\n  \n  vector<map<int, int> > rev(n);\n  int idx=n;\n  {\n    using P = pair<int, int>;\n    queue<P> q;\n    q.emplace(0,-1);\n    while(!q.empty()){\n      int v,p;\n      tie(v,p)=q.front();q.pop();\n      if(~p){\n\tlct.link(vs[p],vs[idx]);\n\tlct.link(vs[idx],vs[v]);\n\trev[p][v]=rev[v][p]=idx++;\n      }\n      for(int u:G[v])\n\tif(u!=p) q.emplace(u,v);\n    }\n  }\n  \n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    char c;\n    cin>>c;\n    if(c=='x'){\n      Int v,a,b,c,d;\n      cin>>v>>a>>b>>c>>d;\n      int z=rev[X[v]][Y[v]];\n      lct.expose(vs[z]);\n      vs[z]->val=M2(M(a,b,c,d),M(a,b,c,d));      \n      lct.expose(vs[z]);\n    }\n    if(c=='g'){\n      Int x,y;\n      cin>>x>>y;\n      lct.evert(vs[x]);\n      lct.expose(vs[y]);\n      M ans=vs[y]->dat.first;\n      cout<<ans.a<<\" \"<<ans.b<<\" \"<<ans.c<<\" \"<<ans.d<<endl;\n    }\n  }\n  \n  \n  return 0;\n}\n/*\n  verified on 2018/06/14\n  https://yukicoder.me/problems/no/650\n*/\n\n\nsigned main(){\n  //GRL_5_C();\n  GRL_5_D();\n  //GRL_5_E();\n  //JOISC2013_DAY4_3();\n  //AOJ_2450();\n  //AOJ_0367();\n  //YUKI_650();\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\n#define int ll\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n\n//0-index 抽象化半開区間遅延セグツリー\ntemplate<typename T, typename E>\nclass segment_tree{\n    typedef function<T(T,T)> F; //要素に適用する演算\n    typedef function<T(T,E)> G; //作用素の適用\n    typedef function<E(E,E)> H; //作用素の合成\n    typedef function<E(E,int)> P;\n    private:\n    int num_of_elm_;\n    vector<T> dat_, lazy_;\n    F f_;\n    G g_;\n    H h_;\n    P p_;\n    T ident_;\n    E op_ident_;\n    public:\n    segment_tree(int n, F f, G g, H h, P p, T ident, E op_ident):f_(f), g_(g), h_(h), p_(p), ident_(ident), op_ident_(op_ident){\n        num_of_elm_ = 1;\n        while(num_of_elm_<n)num_of_elm_*=2;\n        dat_ .resize(2*num_of_elm_,ident);\n        lazy_.resize(2*num_of_elm_,op_ident);\n    }\n    \n    void build(vector<T> vec){\n        rep(i,vec.size()) dat_[num_of_elm_+i] = vec[i];\n        for(int i=num_of_elm_-1;i>=1;i--)dat_[i] = f_(dat_[i*2],dat_[i*2+1]);\n    }\n    \n    void eval(int k, int len){\n        if(lazy_[k] == op_ident_)return ;\n        \n        if(k<num_of_elm_){\n            lazy_[k*2]=h_(lazy_[k*2], lazy_[k]);\n            lazy_[k*2+1]=h_(lazy_[k*2+1], lazy_[k]);\n        }\n        dat_[k] = g_(dat_[k],p_(lazy_[k], len));\n        lazy_[k] = op_ident_;\n    }\n    \n    T update(int L, int R, int val, int l=0, int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return dat_[k];\n        else if(L<=l && r<=R){\n            lazy_[k] = h_(lazy_[k], val);\n            return g_(dat_[k], p_(lazy_[k], r-l));\n        }\n        else{\n            return dat_[k] = f_(update(L,R,val,l,(l+r)/2,k*2), update(L,R,val,(l+r)/2,r,k*2+1));\n        }\n        \n    }\n    \n    T query(int L, int R,int l=0,int r=0, int k=1){\n        if(k==1)r = num_of_elm_;\n        \n        eval(k,r-l);\n        if(r<=L || R<=l)return ident_;\n        else if(L<=l && r<=R){\n            return dat_[k];\n        }\n        else{\n            return f_(query(L,R,l,(l+r)/2,k*2), query(L,R,(l+r)/2,r,k*2+1));\n        }\n    }\n};\n\ntemplate<typename T, typename E>\nclass HLDecomposition{    //verified NJPC-H\n    typedef function<T(T,T)> F; //要素に適用する演算\n    typedef function<T(T,E)> G; //作用素の適用\n    typedef function<E(E,E)> H; //作用素の合成\n    typedef function<E(E,int)> P;\n    \n    public:\n    vector<vector<int>> Graph;\n    \n    vector<int> vid, head, heavy, par, depth, inv;\n    segment_tree<T,E> segt;\n    \n    HLDecomposition(int V, F f, G g, H h, P p, T ident, E op_ident): Graph(V), vid(V,-1), head(V), heavy(V,-1), par(V), depth(V), inv(V), segt(V, f, g, h, p, ident, op_ident) {}\n    \n    void add_edge(int u,int v){\n        Graph[u].pb(v);\n        Graph[v].pb(u);\n    }\n    \n    void build(){\n        dfs(0,-1);\n        bfs();\n    }\n    \n    int dfs(int cur, int prev){\n        par[cur] = prev;\n        int sub=1, chil_sub_max=0;\n        for(auto e:Graph[cur]){\n            if(e==prev)continue;\n            depth[e] = depth[cur]+1;\n            int res = dfs(e,cur);\n            sub += res;\n            if(chil_sub_max<res)chil_sub_max = res, heavy[cur] = e;\n        }\n        return sub;\n    }\n    \n    void bfs(){\n        int num = 0;\n        queue<int> q({0});\n        while(q.size()){\n            int headv = q.front(); q.pop();\n            int cur = headv;\n            while(cur!=-1){\n                vid[cur] = num++;\n                inv[vid[cur]] = cur;\n                head[cur] = headv;\n                for(auto e:Graph[cur]){\n                    if(e!=par[cur]&&e!=heavy[cur])q.push(e);\n                }\n                cur = heavy[cur];\n            }\n        }\n    }\n    \n    //u-vパスをchainに分解し、それぞれの頂点に対して処理を行う\n    void for_each(int u, int v, function<void(int, int)> f){\n        if(vid[u]>vid[v])swap(u,v);\n        f(max(vid[head[v]],vid[u]), vid[v]);\n        if(head[u]!=head[v])for_each(u,par[head[v]], f);\n    }\n    \n    //u-vパスをchainに分解し、それぞれの辺に対して処理を行う\n    void for_each_edge(int u, int v, function<void(int, int)> f){\n        if(vid[u]>vid[v])swap(u,v);\n        if(head[u]!=head[v]){\n            f(vid[head[v]],vid[v]);\n            for_each_edge(u,par[head[v]],f);\n        }else{\n            if(u!=v)f(vid[u]+1,vid[v]);\n        }\n    }\n    \n    int lca(int u, int v) {\n        if(vid[u]>vid[v])swap(u,v);\n        if(head[u]==head[v])return u;\n        return lca(u, par[head[v]]);\n    }\n    \n};\n\nsigned main(){\n    int v;\n    cin>>v;\n\n    auto f = [](int a, int b){ return a+b; };\n    auto g = f;\n    auto h = f;\n    auto p = [](int a, int num){ return a*num; };\n    HLDecomposition<int,int> hld(v, f, g, h, p, 0, 0);\n    \n    rep(i,v){\n        int k;\n        cin>>k;\n        rep(j,k){\n            int to;\n            cin>>to;\n            hld.add_edge(i, to);\n        }\n    }\n    hld.build();\n    \n    int q;\n    cin>>q;\n    rep(i,q){\n        \n        int type;\n        cin>>type;\n        if(type==0){\n            int u,w;\n            cin>>u>>w;\n            hld.for_each_edge(hld.par[u], u, [&](int l, int r){ hld.segt.update(l, r+1, w); });\n        }else{\n            int x;\n            cin>>x;\n            int res = 0;\n            hld.for_each_edge(0, x, [&](int l, int r){ res += hld.segt.query(l, r+1); });\n            cout<<res<<endl;\n        }\n    }\n    \n}\n\n\n\n\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define GET_MACRO(_1,_2,_3,_4,_5,_6,NAME,...) NAME\n#define pr(...) GET_MACRO(__VA_ARGS__,pr6,pr5,pr4,pr3,pr2,pr1)(__VA_ARGS__)\n#define Pr(a) (#a)<<\"=\"<<(a)<<\" \"\n#define pr1(a) cerr<<Pr(a)<<endl;\n#define pr2(a,b) cerr<<Pr(a)<<Pr(b)<<endl;\n#define pr3(a,b,c) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<endl;\n#define pr4(a,b,c,d) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<endl;\n#define pr5(a,b,c,d,e) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<endl;\n#define pr6(a,b,c,d,e,f) cerr<<Pr(a)<<Pr(b)<<Pr(c)<<Pr(d)<<Pr(e)<<Pr(f)<<endl;\n#define int long long\n#define double long double\nusing namespace std;\nconst int N = 100010;\nconst int INF = 1LL<<55;\nconst int mod = (1e9)+7;\nconst double EPS = 1e-8;\nconst double PI = 6.0 * asin(0.5);\ntypedef pair<int,int> P;\ntypedef long long ll;\ntemplate<class T> T Max(T &a,T b){return a=max(a,b);}\ntemplate<class T> T Min(T &a,T b){return a=min(a,b);}\nostream& operator<<(ostream& o,P p){return o<<\"(\"<<p.first<<\",\"<<p.second<<\")\";}\nistream& operator>>(istream& i,P &p){return i>>p.first>>p.second;}\nostream& operator<<(ostream& o,vector<auto> &a){int i=0;for(auto t:a)o<<(i++?\" \":\"\")<<t;return o;}\nistream& operator>>(istream& i,vector<auto> &a){for(auto &t:a)i>>t;return i;}\nvoid prArr(auto a,string s=\" \"){int i=0;for(auto t:a)cout<<(i++?s:\"\")<<t;cout<<endl;}\n\nclass RSAQ{\npublic:\n  typedef long long ll;\n  ll n;\n  vector<ll> dat,td;\n  \n  RSAQ(){n = -1;}\n  RSAQ(int n_){\n    n=1;\n    while(n<n_)n*=2; //要素数nを2のべき乗に\n    dat.resize(2*n-1,0),td.resize(2*n-1,0);\n  }\n  \n  //[a,b)の区間にxを加算する,query(a,b,x);\n  ll add(int a,int b,ll x,int k=0,int l=0,int r=-1){\n    if(r==-1) r=n, assert(a <= n && b <= n);\n    if(r<=a||b<=l)return 0;\n    if(a<=l&&r<=b){\n      dat[k]+=(r-l)*x; \n      td[k]+=x;\n      return dat[k];\n    }\n\n    dat[k]+=(min(r,b)-max(l,a))*x;\n    ll kl=k*2+1,kr=k*2+2,t=td[k]*(r-l)/2;\n    dat[kl]+=t, dat[kr]+=t;\n    td[kl]+=td[k], td[kr]+=td[k];\n    td[k]=0;\n\n    ll vl=add(a,b,x,k*2+1,l,(l+r)/2);\n    ll vr=add(a,b,x,k*2+2,(l+r)/2,r);\n    return vl+vr;\n  }\n  \n  //[a,b)の総和を得る\n  ll sum(int a,int b){return add(a,b,0);}\n};\n\n\nclass EulerTour{\npublic:\n  int V;                     //ノード数\n  int root;                  //根の頂点番号\n  vector<vector<int> > G;    //Grapth\n  vector<int> L,R;           //[L,R]\n  bool ok;\n  EulerTour():V(-1),ok(0){};\n  EulerTour(int V,int root = 0):V(V),root(root),G(V),L(V),R(V),ok(0){}\n\n  void add_edge(int a,int b){\n    assert(a >= 0 && b >= 0);\n    assert(a < V && b < V);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  void build(){\n    ok = 1;\n    int cnt = 0;\n    function<void(int,int)> dfs = [&](int pos,int pre){\n      L[pos] = cnt;\n      for(int to:G[pos]) if(to != pre) cnt++, dfs(to, pos);\n      R[pos] = cnt;\n    };\n    dfs(root,-1);\n  }\n\n  \n  typedef pair<int,int> P;\n  P get(int v){assert(ok && v < V); return P(L[v],R[v]);} //[l, r]\n};\n\n\nsigned main(){\n  cin.tie(0);\n  ios_base::sync_with_stdio(0);\n  cout << fixed << setprecision(12);\n\n  int n;\n  cin>>n;\n\n  EulerTour ET(n);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++) {\n      int c;\n      cin>>c;\n      ET.add_edge(i,c);\n    }\n  }\n\n  \n\n  ET.build();\n  RSAQ A(n);\n  \n  auto add=[&](int v,int w){\n    int l,r; tie(l, r) = ET.get(v);\n    A.add(l,r+1,w);\n  };\n\n  auto getSum=[&](int u){\n    u = ET.get(u).first;\n    return A.sum(u,u+1);\n  };\n\n  int q;\n  cin>>q;\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int v, w;\n      cin>> v >> w;\n      add(v,w);\n    }\n    if(cmd == 1){\n      int u;\n      cin>>u;\n      int ans = getSum(u);\n      cout<<ans<<endl;\n    }\n    \n\n  }\n  \n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> T;\n\nstruct RSQ{\n  ll n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 1 index\n  /*void add(int i,int v){\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }*/\n  // 0 index\n  void add(int i,ll v){\n    i+=1;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  ll sum(int i){\n    ll res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) 1 index\n  /*int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }*/\n  //[a,b) 0 index\n  int sum(int x,int y){\n    x++;y++;\n    return sum(y-1)-sum(x-1);\n  }\n};\n \nstruct HLD {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  RSQ rsq;\n\n  HLD(){}\n  HLD(int sz):n(sz),pos(0),G(n),vid(n,-1),head(n),sub(n,1),hvy(n,-1),par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs={0}) {\n    int c=0;\n    for(int i=0;i<rs.size();i++){\n        int r=rs[i];\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    stack<T> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.emplace(rt,0);\n    while(!st.empty()){\n        int v=st.top().first;\n        int &i=st.top().second;\n        if(i<(int)G[v].size()){\n            int u=G[v][i++];\n            if(u==par[v]) continue;\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            st.emplace(u,0);\n        }else{\n            st.pop();\n            int res=0;\n            for(int i=0;i<G[v].size();i++){\n                int u=G[v][i];\n                if(u==par[v]) continue;\n                sub[v]+=sub[u];\n                if(res<sub[u]) res=sub[u],hvy[v]=u;\n            }\n        }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q({r});\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n        type[i]=c;\n        vid[i]=k++;\n        inv[vid[i]]=i;\n        head[i]=h;\n        for(int J=0;J<G[i].size();J++){\n            int j=G[i][J];\n            if(j!=par[i]&&j!=hvy[i]) q.push(j);\n        }\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  int for_each(int u, int v) {\n    int ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      //f(max(vid[head[v]],vid[u]),vid[v]);\n      //ans = max(ans,rmq.query(l, r + 1));\n      if(head[u]!=head[v]) v=par[head[v]];\n      else {return ans;}\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  ll for_each_edge(int u, int v) {\n    ll ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n        //f(vid[head[v]],vid[v]);\n        ans += rsq.sum(vid[head[v]],vid[v]+1);\n        v=par[head[v]];\n      } else{\n        //if(u!=v) f(vid[u]+1,vid[v]);\n        if(u!=v) ans += rsq.sum(vid[u]+1,vid[v]+1);\n        return ans;\n      }\n    }\n  }\n\n  void update(int u,int w){\n    rsq.add(vid[u],w);\n  }\n\n  void range_update(){\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\nint main(){\n    int n,m,x,w;\n    scanf(\"%d\",&n);\n    HLD Tree(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&x);\n            Tree.add_edge(i,x);\n        }\n    }\n    Tree.build();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        if(m==0){\n            scanf(\"%d%d\",&x,&w);\n            Tree.update(x,w);\n        }\n        else{\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",Tree.for_each_edge(0,x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long ll;\n\ntypedef pair<int,int> P;\n\nstruct RSQ{\n  ll n=(1<<17),data[(1<<18)];\n  RSQ(){\n    memset(data,0,sizeof(data));\n  }\n  // 1 index\n  /*void add(int i,int v){\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }*/\n  // 0 index\n  void add(int i,ll v){\n    i+=1;\n    while(i<=n){\n      data[i]+=v;\n      i+=i&-i;\n    }\n  }\n  ll sum(int i){\n    ll res=0;\n    while(i>0){\n      res+=data[i];\n      i-=i&-i;\n    }\n    return res;\n  }\n  //[a,b) 1 index\n  /*int sum(int x,int y){\n    return sum(y-1)-sum(x-1);\n  }*/\n  //[a,b) 0 index\n  int sum(int x,int y){\n    x++;y++;\n    return sum(y-1)-sum(x-1);\n  }\n};\n \nstruct HLD {\n  int n,pos;\n  vector<vector<int> > G;\n  vector<int> vid, head, sub, hvy, par, dep, inv, type;\n  RSQ rsq;\n\n  HLD(){}\n  HLD(int sz):n(sz),pos(0),G(n),vid(n,-1),head(n),sub(n,1),hvy(n,-1),par(n),dep(n),inv(n),type(n){}\n  \n  void add_edge(int u, int v) {\n    G[u].push_back(v);\n    G[v].push_back(u);\n  }\n\n  void build(vector<int> rs) {\n    if(rs.size()==0)rs.push_back(0);\n    int c=0;\n    for(int i=0;i<rs.size();i++){\n        int r=rs[i];\n      dfs(r);\n      bfs(r, c++);\n    }\n  }\n  \n  void dfs(int rt) {\n    stack<P> st;\n    par[rt]=-1;\n    dep[rt]=0;\n    st.push(P(rt,0));\n    while(!st.empty()){\n        int v=st.top().first;\n        int &i=st.top().second;\n        if(i<(int)G[v].size()){\n            int u=G[v][i++];\n            if(u==par[v]) continue;\n            par[u]=v;\n            dep[u]=dep[v]+1;\n            st.push(P(u,0));\n        }else{\n            st.pop();\n            int res=0;\n            for(int i=0;i<G[v].size();i++){\n                int u=G[v][i];\n                if(u==par[v]) continue;\n                sub[v]+=sub[u];\n                if(res<sub[u]) res=sub[u],hvy[v]=u;\n            }\n        }\n    }\n  }\n\n  void bfs(int r,int c) {\n    int &k=pos;\n    queue<int> q;\n    q.push(r);\n    while(!q.empty()){\n      int h=q.front();q.pop();\n      for(int i=h;i!=-1;i=hvy[i]) {\n        type[i]=c;\n        vid[i]=k++;\n        inv[vid[i]]=i;\n        head[i]=h;\n        for(int J=0;J<G[i].size();J++){\n            int j=G[i][J];\n            if(j!=par[i]&&j!=hvy[i]) q.push(j);\n        }\n      }\n    }\n  }\n  \n  // for_each(vertex)\n  // [l,r] <- attention!!\n  int for_each(int u, int v) {\n    int ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      //f(max(vid[head[v]],vid[u]),vid[v]);\n      //ans = max(ans,rmq.query(l, r + 1));\n      if(head[u]!=head[v]) v=par[head[v]];\n      else {return ans;}\n    }\n  }\n  \n  // for_each(edge)\n  // [l,r] <- attention!!\n  ll for_each_edge(int u, int v) {\n    ll ans=0;\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]!=head[v]){\n        //f(vid[head[v]],vid[v]);\n        ans += rsq.sum(vid[head[v]],vid[v]+1);\n        v=par[head[v]];\n      } else{\n        //if(u!=v) f(vid[u]+1,vid[v]);\n        if(u!=v) ans += rsq.sum(vid[u]+1,vid[v]+1);\n        return ans;\n      }\n    }\n  }\n\n  void update(int u,int w){\n    rsq.add(vid[u],w);\n  }\n\n  void range_update(){\n  }\n\n  int lca(int u,int v){\n    while(1){\n      if(vid[u]>vid[v]) swap(u,v);\n      if(head[u]==head[v]) return u;\n      v=par[head[v]];\n    }\n  }\n\n  int distance(int u,int v){\n    return dep[u]+dep[v]-2*dep[lca(u,v)];\n  }\n};\nint main(){\n    int n,m,x,w;\n    scanf(\"%d\",&n);\n    HLD Tree(n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        for(int j=0;j<m;j++){\n            scanf(\"%d\",&x);\n            Tree.add_edge(i,x);\n        }\n    }\n    Tree.build();\n    scanf(\"%d\",&n);\n    for(int i=0;i<n;i++){\n        scanf(\"%d\",&m);\n        if(m==0){\n            scanf(\"%d%d\",&x,&w);\n            Tree.update(x,w);\n        }\n        else{\n            scanf(\"%d\",&x);\n            printf(\"%lld\\n\",Tree.for_each_edge(0,x));\n        }\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nvector<int> G[100010];\n\n#define MAX_N 1<<17\nint n,dat[2*(MAX_N)-1];\n\nvoid init(int n_){\n  n=1;\n  while(n<n_)n*=2;\n  for(int i=0;i<2*n-1;i++)dat[i]=0;\n}\n\nint find(int k){\n  k+=n-1;\n  int ans=dat[k];\n  while(k>0){\n    k=(k-1)/2;\n    ans+=dat[k];\n  }\n  return ans;\n}\n\n\nvoid update(int a,int b,int x,int k=0,int l=0,int r=n){\n  if(r<=a||b<=l)return;\n  if(a<=l&&r<=b){\n    dat[k]+=x;\n  }else{\n    update(a,b,x,k*2+1,l,(l+r)/2);\n    update(a,b,x,k*2+2,(l+r)/2,r);\n  }\n}\n\nint num[2][200010];\nint dfs(int k=0,int a=0){\n  num[0][k]=a;\n  for(int i=0;i<G[k].size();i++){\n    a=dfs(G[k][i],a+1);\n  }\n  num[1][k]=a;\n  return a+1;\n}\n\nint main(){\n  int N;\n  cin>>N;\n  for(int i=0;i<N;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int a;\n      cin>>a;\n      G[i].push_back(a);\n    }\n  }\n  n=dfs();\n  init(n);\n  //cout<<n<<\" happy\"<<endl;\n  int q;\n  cin>>q;\n  for(int i=0;i<q;i++){\n    int x;\n    cin>>x;\n    if(x==0){\n      int w,v;\n      cin>>v>>w;\n      update(num[0][v],num[1][v]+1,w);\n    }else{\n      int u;\n      cin>>u;\n      cout<<find(num[0][u])<<endl;\n    }\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cmath>\n#include<vector>\nusing namespace std;\n\nvoid dfs(vector<vector<int>>& childLists, vector<vector<int>>& edgeIds, vector<int>& weights, const int& v){\n    for(int i = 0; i < childLists[v].size(); i++){\n        int u = childLists[v][i];\n        weights.push_back(0);\n        edgeIds[u].push_back(weights.size()-1);\n        dfs(childLists, edgeIds, weights, u);\n        weights.push_back(0);\n        edgeIds[u].push_back(weights.size()-1);\n    }\n}\n\nvoid add(vector<int>& tree, const int& n, const int& k, const int& w){\n    int i = k + n - 1; \n    while(i > 0){\n        tree[i] += w;\n        i = (i - 1)/2;\n    }\n    tree[i] += w;\n}\n\nint getSumUtil(vector<int>& tree, const int& L, const int& R, const int& i, const int& l, const int& r){\n    if(i >= tree.size() || l > r){\n        return 0;\n    }\n    if(r < L || l > R){\n        return 0;\n    }\n    if(l >= L && r <= R){\n        return tree[i];\n    }\n    int m = l + (r - l)/2;\n    return  getSumUtil(tree, L, R, 2*i+1, l, m) + getSumUtil(tree, L, R, 2*i+2, m+1, r);\n}\n\nint getSum(vector<int>& tree, const int& n, const int& L, const int& R){\n    return getSumUtil(tree, L, R, 0, 0, n-1);\n}\n\nint main(){\n    int n, q, k, x, v, w;\n    scanf(\"%d\", &n);\n    vector<vector<int>> childLists(n);\n    for(int i = 0; i < n; i++){\n        scanf(\"%d\", &k);\n        for(int j = 0; j < k; j++){\n            scanf(\"%d\", &x);\n            childLists[i].push_back(x);\n        }\n    }\n    vector<int> weights;\n    vector<vector<int>> edgeIds(n);\n    dfs(childLists, edgeIds, weights, 0);\n    int h = ceil(log2(weights.size()))+1;\n    int max_size = pow(2, h)-1;\n    vector<int> tree(max_size, 0);\n    scanf(\"%d\", &q);\n    for(int i = 0; i < q; i++){\n        scanf(\"%d\", &x);\n        if(x == 0){\n            scanf(\"%d %d\", &v, &w);\n            add(tree, pow(2, h-1), edgeIds[v][0], w);\n            add(tree, pow(2, h-1), edgeIds[v][1], -w);\n        }\n        else if(x == 1){\n            scanf(\"%d\", &v);\n            printf(\"%d\\n\", v == 0? 0 : getSum(tree, pow(2, h-1), 0, edgeIds[v][0]));\n        }\n        else printf(\"invalid query %d\\n\", x);\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass EulerTour{\npublic:\n  int V;                     //ノード数\n  int root;                  //根の頂点番号\n  vector<vector<int> > G;    //Grapth\n  vector<int> L,R;           //[L,R]\n  bool ok;\n  EulerTour():V(-1),ok(0){};\n  EulerTour(int V,int root):V(V),root(root),G(V),L(V),R(V),ok(0){}\n\n  void add_edge(int a,int b){\n    assert(a >= 0 && b >= 0);\n    assert(a < V && b < V);\n    G[a].push_back(b);\n    G[b].push_back(a);\n  }\n\n  void build(){\n    ok = 1;\n    int cnt = 0;\n    function<void(int,int)> dfs = [&](int pos,int pre){\n      L[pos] = cnt;\n      for(int to:G[pos]) if(to != pre) cnt++, dfs(to, pos);\n      R[pos] = cnt;\n    };\n    dfs(root,-1);\n  }\n\n  //オイラーツアー上のvの添字を返す。\n  int getIdx(int v){assert(ok && v < V); return L[v];}\n\n  //vを根とする部分木をvを含み[l, r]の区間で返す。\n  pair<int, int> get(int v){assert(ok && v < V); return make_pair(L[v],R[v]);}\n};\n\n\nclass RSAQ{\npublic:\n  typedef long long ll;\n\n  //マージ可能な主データ型\n  struct D{\n    ll value;\n    D():value(0){} /*適切な値にする!!!!!!*/\n    D(ll value):value(value){}\n    bool operator < (D a)const {return value < a.value;}\n  };\n\n  //遅延用の型\n  struct T{\n    int type; //0 - empty   , 1 - update\n    ll value;\n    T():type(0),value(0){}\n    T(int type,ll value):type(type),value(value){}\n  };\n\n\n  int n, n_;\n  vector<D> dat;\n  vector<T> td;\n  D returnD = D(0); // 範囲外の時に返す値。\n\n  RSAQ(){n=-1;}\n  RSAQ(int n_):n_(n_){\n    n=1;\n    while(n < n_) n *= 2;\n    td.resize(2*n-1,T());\n    dat.resize(2*n-1,D());\n  }\n\n  inline D merge(const D a,const D b)const{return a.value + b.value;}\n\n  void delay(int k,int len){\n    if(td[k].type==0) return;\n    ll type = td[k].type;\n    ll v = td[k].value;\n    td[k].type = 0;\n    td[k].value = 0;\n    len /= 2;\n    {\n      int l = k*2+1;\n      dat[l].value += v * len;\n      td[l].type = type;\n      td[l].value += v;\n    }\n    {\n      int r = k*2+2;\n      dat[r].value += v * len;\n      td[r].type = type;\n      td[r].value += v;\n    }\n  }\n\n  D write(int k, D x, int len){\n    dat[k].value += x.value * len;\n    td[k].type = 1;\n    td[k].value += x.value;\n    return dat[k];\n  }\n\n  D dfs(int a, int b, D x, bool flag, int k, int l, int r){\n    if(r <= a||b <= l) return flag? dat[k]:returnD;\n    if(a <= l && r <= b) return flag? write(k, x, r - l):dat[k];\n    delay(k, r - l);\n    D vl = dfs(a, b, x, flag, k*2+1, l, (l+r)/2);\n    D vr = dfs(a, b, x, flag, k*2+2, (l+r)/2, r);\n    return flag? (dat[k] = merge(vl, vr)):merge(vl, vr);\n  }\n\n  //[l,r)の値にx加算\n  void add(int l,int r,ll x){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    dfs(l, r, D(x), true, 0, 0, n);\n  }\n\n  //[l,r)の合計値を得る\n  ll get(int l,int r){\n    assert(l <= r);\n    assert(0 <= l && l <= n);\n    assert(0 <= r && r <= n);\n    D res = dfs(l, r, D(), false, 0, 0, n);\n    return res.value;\n  }\n};\n\nvoid AOJ_GRL_5_D(){\n  int n;\n  cin>>n;\n  EulerTour et(n, 0);\n  for(int i=0;i<n;i++){\n    int k;\n    cin>>k;\n    for(int j=0;j<k;j++){\n      int c;\n      cin>>c;\n      et.add_edge(i, c);\n    }\n  }\n  et.build();\n  RSAQ seg(n);\n\n  int q;\n  cin>>q;\n  while(q--){\n    int cmd;\n    cin>>cmd;\n    if(cmd == 0){\n      int v, w;\n      cin>>v>>w;\n      int l, r; tie(l, r) = et.get(v);\n      seg.add(l, r+1, w);\n    }\n    if(cmd == 1){\n      int u;\n      cin>>u;\n      int idx = et.getIdx(u);\n      int ans = seg.get(idx, idx+1);\n      cout<<ans<<endl;\n    }\n  }\n}\n\nint main(){\n  AOJ_GRL_5_D();\n  return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#define ll long long\n#define rep(i,l,r)for(ll i=(l);i<(r);i++)\n#define max(p,q)((p)>(q)?(p):(q))\n\n//辺の情報を個別に持つタイプ\ntypedef struct edge{ll s,g;}E;\ntypedef struct graph{\n\tint vcnt,ecnt;\n\tE  e[100010];//適宜変える\n\tint id[100010];//適宜変える\n}G;\n\nG g;\nvoid readgraph(){\n\t//適宜変える\n\tll n;\n\tscanf(\"%lld\",&n);\n\tll m=0;\n\trep(x,0,n){\n\t\tint k;\n\t\tscanf(\"%d\",&k);\n\t\twhile(k--){\n\t\t\tll y;\n\t\t\tscanf(\"%lld\",&y);\n\t\t\tg.e[m].s=x;\n\t\t\tg.e[m].g=y;\n\t\t\tm++;\n\t\t}\n\t}\n\tg.vcnt=n;\n\tg.ecnt=m;\n\n\tint p=0;\n\trep(i,0,g.vcnt){\n\t\twhile(p<g.ecnt&&g.e[p].s<i)p++;\n\t\tg.id[i]=p;\n\t}\n\tg.id[g.vcnt]=g.ecnt;//番兵\n}\n\n\n\n\n//*\n//遅延セグ木ここから\n//↓ここを変える\ntypedef struct sayouso{ll k;}sayouso;\ntypedef struct atai{ll c,a;}atai;\n//↑ここを変える\n\ntypedef struct node{sayouso T;atai x;}node;\nnode *lsegN,*lseg;\nll lsegNUM,lsegk;\n\n//↓ここから変える\nsayouso sid={0};\natai aid={0,0};\natai xx(atai x,atai y){\n\tatai ret;\n\tret.c=x.c+y.c;\n\tret.a=x.a+y.a;\n\treturn ret;\n}\natai Tx(sayouso T,atai x){\n\tatai ret;\n\tret.c=x.c;\n\tret.a=T.k*x.c+x.a;\n\treturn ret;\n}\nsayouso TT(sayouso S,sayouso T){\n\tsayouso ret;\n\tret.k=S.k+T.k;\n\treturn ret;\n}\nsayouso fT(sayouso T,ll k){\n\tsayouso ret;\n\tret.k=T.k;\n\treturn ret;\n}\n//↑ここまで変える\n\n//要素数(2ベキ)でこれを呼ぶ\nvoid lseguse(ll n){\n\tlsegN=(node*)calloc(2*n,sizeof(node));\n\tlsegNUM=n;\n\tlseg=lsegN+lsegNUM;\n\tlsegk=0;while(n/=2)lsegk++;\n\trep(i,1,2*lsegNUM){\n\t\tlsegN[i].x=aid;\n\t\tlsegN[i].T=sid;\n\t}\n}\n//lseg[i].xに値を与えてから初期化\nvoid lseginit(){\n\tfor(ll i=lsegNUM-1;i>0;i--)lsegN[i].x=xx(lsegN[2*i].x,lsegN[2*i+1].x);\n}\nvoid lsegupdatesub(ll l,ll r,sayouso T,ll i,ll cl,ll cr,ll ck){\n\tif(l>=r)return;\n\t//disjointなとき\n\tif(cr<=l||r<=cl)return;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r){\n\t\tlsegN[i].T=TT(T,lsegN[i].T);\n\t\treturn;\n\t}\n\t//どちらでもないとき\n\t//遅延伝播\n\tlsegN[2*i  ].T=TT(lsegN[i].T,lsegN[2*i  ].T);\n\tlsegN[2*i+1].T=TT(lsegN[i].T,lsegN[2*i+1].T);\n\t//再帰的に更新\n\tll cm=(cl+cr)/2;\n\tlsegupdatesub(l,r,T,2*i  ,cl,cm,ck-1);\n\tlsegupdatesub(l,r,T,2*i+1,cm,cr,ck-1);\n\t//自身のnodeを更新\n\tlsegN[i].x=xx(Tx(fT(lsegN[2*i].T,ck-1),lsegN[2*i].x),Tx(fT(lsegN[2*i+1].T,ck-1),lsegN[2*i+1].x));\n\tlsegN[i].T=sid;\n}\nvoid lsegupdate(ll l,ll r,sayouso T){lsegupdatesub(l,r,T,1,0,lsegNUM,lsegk);}\natai lsegcalcsub(ll l,ll r,ll i,ll cl,ll cr,ll ck){\n\tif(l>=r)return aid;\n\t//完全に含むとき\n\tif(l<=cl&&cr<=r)return Tx(fT(lsegN[i].T,ck),lsegN[i].x);\n\n\tll cm=(cl+cr)/2;\n\t//遅延伝播(変更はないので配るだけで良い)\n\tlsegN[2*i  ].T=TT(lsegN[i].T,lsegN[2*i  ].T);\n\tlsegN[2*i+1].T=TT(lsegN[i].T,lsegN[2*i+1].T);\n\tlsegN[i].x=Tx(fT(lsegN[i].T,ck),lsegN[i].x);\n\tlsegN[i].T=sid;\n\n\t//左側だけ\n\tif(r<=cm)return lsegcalcsub(l,r,2*i  ,cl,cm,ck-1);\n\t//右側だけ\n\tif(cm<=l)return lsegcalcsub(l,r,2*i+1,cm,cr,ck-1);\n\t//両方\n\treturn xx(lsegcalcsub(l,r,2*i,cl,cm,ck-1),lsegcalcsub(l,r,2*i+1,cm,cr,ck-1));\n}\natai lsegcalc(ll l,ll r){return lsegcalcsub(l,r,1,0,lsegNUM,lsegk);}\n//遅延セグ木ここまで\n//*/\n\n\n\n\n#define VCNT 100000\nll ein[VCNT+10],eout[VCNT+10];\nll vin[VCNT+10],vout[VCNT+10];\nll ETe[2*VCNT+10];\nll cnt=0;\n#undef VCNT\nvoid ETdfs(int v){\n\tvin[v]=cnt;\n\trep(i,g.id[v],g.id[v+1]){\n\t\tein[i]=cnt;\n\t\tETe[cnt]=i;\n\t\tcnt++;\n\t\tETdfs(g.e[i].g);\n\t\teout[i]=cnt;\n\t\tETe[cnt]=i+g.ecnt;\n\t\tcnt++;\n\t}\n\tvout[v]=cnt;\n}\n\nint main(){\n\treadgraph();\n\tETdfs(0);\n\tlseguse(1<<18);\n\trep(i,0,g.ecnt)lseg[ein[i]].x.c=1;\n\trep(i,0,g.ecnt)lseg[eout[i]].x.c=-1;\n\tlseginit();\n\tint q;\n\tscanf(\"%d\",&q);\n\twhile(q--){\n\t\tint t;\n\t\tscanf(\"%d\",&t);\n\t\tif(t){\n\t\t\tint x;\n\t\t\tscanf(\"%d\",&x);\n\t\t\tprintf(\"%lld\\n\",lsegcalc(0,vin[x]).a);\n\t\t}else{\n\t\t\tint x,c;\n\t\t\tscanf(\"%d%d\",&x,&c);\n\t\t\tsayouso T={c};\n\t\t\tlsegupdate(vin[x]-1,vin[x],T);\n\t\t\tlsegupdate(vout[x],vout[x]+1,T);\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DEBUG 0\n#define ADD 0\n#define GETSUM 1\n\ntypedef struct Node Node;\n\nstruct Node {\n    int index;\n    int weight;\n    int child_count;\n    Node* sibling;\n    Node* left_most_child;\n};\n\nNode* node_list[100000];\nint* Eular_Tour;\nint Eular_Enter[100000];\nint Eular_Exit[100000];\nint Eular_Touring_Counter;\n\n\nint N; // Big N is to record the given n from input // it means how much tree node.\nint Q; // Big Q is to record the given q from input // it means how much query actions. \n\nint RQ_n;\nint RQ_q;\n\nvoid _init_global_var();\nNode* create_Node(int index);\nNode* get_Node_address(int index);\nvoid print_Node_tree(void);\nvoid _print_Node_tree(Node* tmp);\n\nvoid Eular_Touring(void);\nvoid _Eular_Touring();\n\nvoid RQ_initRSumQ(int n_);\nvoid RQ_update(int k, int a);\nint RQ_query(int a , int b, int k, int l, int r);\n\nvoid update_weight(int index, int weight);\nvoid query_weight_sum(int target);\n\nint main (){\n    _init_global_var();\n    Node* tmp = NULL;\n    int child_index = 0;\n    int child_count = 0;\n\n    scanf(\"%d\",&N);\n    if(DEBUG)printf(\"N = %d\\n\",N);\n\n    RQ_n = (N-1)*2; // for a N node tree, there's N-1 edge if there's no parallel loop or self loop or other kind of loop.\n\n    for(int i = 0; i < N; i ++){\n        tmp = NULL;\n        tmp = get_Node_address(i);\n\n        scanf(\"%d\",&child_count);\n        tmp->child_count = child_count;\n        if(DEBUG)printf(\"Node %3d have %5d childs.\\n\",i,tmp->child_count);\n\n        for(int j = 0; j< child_count; j++){\n            scanf(\"%d\",&child_index);\n            if(j == 0){\n                tmp->left_most_child = get_Node_address(child_index);\n                tmp = tmp->left_most_child;\n                if(DEBUG)printf(\"Node %3d have Frist child %d\\n\",i,child_index);\n            }else{\n                while(tmp->sibling != NULL){ //insurance, without this it should work//\n                    tmp = tmp->sibling;\n                    if(DEBUG)printf(\"Steping to last sibling\\n\");\n                }\n                tmp->sibling = get_Node_address(child_index);\n                if(DEBUG)printf(\"Node %3d set %4dth child %d\\n\",i,j+1,child_index);\n            }\n        }\n    }\n    if(DEBUG)printf(\"\\nFinish setup Tree\\n\");\n    if(DEBUG)print_Node_tree();\n\n    Eular_Touring();\n\n    scanf(\"%d\",&Q);\n    int cmd = 0;\n    int v = 0;\n    int w = 0;\n    int u = 0;\n    while(Q>0){\n        scanf(\"%d\",&cmd);\n        if(cmd == ADD){\n            scanf(\"%d %d\",&v,&w);\n            update_weight(v,w);\n        }\n\n        if(cmd == GETSUM){\n            scanf(\"%d\",&u);\n            query_weight_sum(u);\n        }\n        Q--;\n    }\n\n\n\n    return 0;\n}\n\nvoid _init_global_var(){\n    N = 0;\n    Q = 0;\n    for(int i = 0; i < 100000; i++){\n        node_list[i] = NULL;\n        Eular_Enter[i] = -1;\n        Eular_Exit[i] = -1;\n    }\n    Eular_Tour = NULL;\n    Eular_Touring_Counter = 0;\n}\n\nNode* create_Node(int index){\n    Node* tmp = malloc(sizeof(Node));\n    tmp->index = index;\n    tmp->weight = 0;\n    tmp->child_count = 0;\n    tmp->sibling = NULL;\n    tmp->left_most_child = NULL;\n    node_list[index] = tmp;\n    return tmp;\n}\n\nNode* get_Node_address(int index){\n    Node* tmp;\n    if(node_list[index] == NULL){\n        tmp = create_Node(index);\n    }else {\n        tmp = node_list[index];\n    }\n    return tmp;\n}\n\nvoid print_Node_tree(void){\n    printf(\"*******************************************************\\nStart_Print_Tree_in_Left_first_DFS\\n\");\n    _print_Node_tree(node_list[0]);\n    printf(\"\\nEnd Tree Printing\\n*******************************************************\\n\");\n}\n\nvoid _print_Node_tree(Node* tmp){\n    if(tmp == NULL){\n        return;\n    }\n    \n    Node* child = NULL;\n\n    printf(\"%3d \",tmp->index);\n\n    if(tmp->left_most_child != NULL){\n        child = tmp->left_most_child;\n        for(int i = 0; i < tmp->child_count; i++){\n            _print_Node_tree(child);\n            child = child->sibling;\n        }\n    }\n\n    printf(\"%3d \",(-1)*tmp->index);\n}\n\nvoid Eular_Touring(void){// this will transfer the node list to euler tour list\n    if(DEBUG)printf(\"*******************************************************\\nStart_Eular_Touring.\\n\");\n    RQ_initRSumQ(RQ_n);\n    Eular_Touring_Counter = 0;\n\n    _Eular_Touring(node_list[0]);\n    if(DEBUG)printf(\"\\nEnd_Eular_Touring.\\n*******************************************************\\n\");\n    if(DEBUG){\n        printf(\"   ID : \");\n        for(int i = 0; i < N;i++){\n            printf(\"%4d\",i);\n        }\n        printf(\"\\n\");\n\n        printf(\"ENTER : \");\n        for(int i = 0; i < N;i++){\n            printf(\"%4d\",Eular_Enter[i]);\n        }\n        printf(\"\\n\");\n\n        printf(\" EXIT : \");\n        for(int i  = 0; i < N;i++){\n            printf(\"%4d\",Eular_Exit[i]);\n        }\n        printf(\"\\n\");\n\n        printf(\"*******************************************************\\n\");\n    }\n}\n\nvoid _Eular_Touring(Node* tmp){\n    if(tmp == NULL){\n        return;\n    }\n    Node* child = NULL;\n    if(DEBUG)printf(\"%3d:%3d    \",Eular_Touring_Counter,tmp->index);\n    Eular_Enter[tmp->index] = Eular_Touring_Counter;\n    Eular_Touring_Counter ++;\n    if(tmp->left_most_child != NULL){\n        child = tmp->left_most_child;\n        for(int i = 0; i < tmp->child_count; i++){\n            _Eular_Touring(child);\n            child = child->sibling;\n        }\n    }\n    if(tmp->index != 0){\n        if(DEBUG)printf(\"%3d:%3d    \",Eular_Touring_Counter,(-1)*tmp->index);\n        Eular_Exit[tmp->index] = Eular_Touring_Counter;\n        Eular_Touring_Counter ++;\n    }\n}\n\nvoid RQ_initRSumQ(int n_){\n\n    RQ_n = 1;\n    while(RQ_n < n_){\n        RQ_n *= 2;\n    }\n\n    Eular_Tour = malloc(sizeof(int)* (2*RQ_n-1));\n    if(Eular_Tour == NULL){\n        printf(\"Init Array Failed, Out of memory or size is wrong\\n\");\n\t\treturn;\n    }\n\n    for(int i = 0; i < 2*RQ_n-1 ; i++){\n        Eular_Tour[i] = 0;\n    }\n    return;\n}\n\nvoid RQ_update(int k, int a){\n    k +=RQ_n-1;\n    Eular_Tour[k] += a;\n    while(k > 0){\n        k = (k-1)/2;\n        Eular_Tour[k] = Eular_Tour[k*2+1] + Eular_Tour[k*2+2];\n    }\n}\n\nint RQ_findSum(int a, int b){\n    return RQ_query(a , b+1, 0, 0, RQ_n);\n}\n\nint RQ_query(int a, int b, int k, int l , int r){\n\n\tif(r <= a || b <= l){\n\t\treturn 0;\n\t}\n\tif(a <= l && r <= b){\n\t\treturn Eular_Tour[k];\n\t}\n\tint vl = RQ_query(a, b, k*2+1, l , (l+r)/2);\n\tint vr = RQ_query(a, b, k*2+2, (l+r)/2, r);\n\treturn vl + vr; \n}\n\nvoid update_weight(int index, int weight){\n    RQ_update(Eular_Enter[index]-1,weight);\n    RQ_update(Eular_Exit[index]-1,(-1)*weight);\n}\n\nvoid query_weight_sum(int target){\n    printf(\"%d\\n\",RQ_findSum(0,Eular_Enter[target]-1));\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DEBUG 0\n\nint parent[100000];\nint weight[100000];\n\nvoid add(int v, int w);\nint getSum(int u);\n\nint main(){\n    memset(parent,0,sizeof(int)*100000); //等同於new int[100000]\n    memset(weight,0,sizeof(int)*100000);\n\n    int n = 0;\n    scanf(\"%d\",&n);\n    if(DEBUG)printf(\"n = %d\\n\",n);\n\n    //初始化用的計數器變數\n    int i = 0;                              // i = 這是第幾個點(同題目)\n    int j = 0;                              // j = 這個點有幾個child\n\n    int ki = 0;                             // ki = 題目中的ki 代表這個點有幾個child\n    int ci = 0;                             // ci = 這個點i 的child 們 在此使用while 迴圈持續取值重複使用\n    while(n > 0){\n        //每當n 還沒歸零 代表還沒初始化到最後一個點\n        \n        scanf(\"%d\",&ki);                    // scanf ki 來確定是否這個點有child\n        while(ki > 0){                      // 當ki 大於零 代表這個點i 有ki 個child\n            scanf(\"%d\",&ci);                // scanf ci 取得誰是child\n            parent[ci] = i;                 // 當ci 是點 i 的child 就把他的parent 設定成 i\n            ki --;                          // 減少 ki 進入下一回圈\n        }\n        // 如果 ki == 0 或者 已經初始化完畢\n        i ++;                               // i++來更新下一個點\n        n --;                               // n--進入下一次迴圈\n    }\n\n    // 完成初始化階段，完成此階段後 對於任意點 i , parent[i] 代表他的parent 是誰\n    // 在此題目中 每個點的parent 只會有一個 所以這個方法非常簡單暴力\n\n    int q ;\n    scanf(\"%d\",&q);\n    if(DEBUG)printf(\"q = %d\\n\",q);\n\n    int cmd = 0;                            // cmd == 0 -> add  1 -> getSum\n    int v = 0;                              // 題目中的v\n    int w = 0;                              // 題目中的w\n    int u = 0;                              // 題目中的u\n\n    while(q>0){\n        //每當q 還沒歸零 代表需要繼續更新重量或者查詢\n        //我有強烈預感這要用lazy\n        //或者要用dp\n        scanf(\"%d\",&cmd);                   // 取得cmd 確定要add or getSum\n        if(DEBUG)printf(\"cmd = %d\\n\",cmd);\n\n        if(cmd == 0){\n            scanf(\"%d %d\",&v,&w);\n            add(v,w);\n        }else{\n            scanf(\"%d\",&u);\n            printf(\"%d\\n\",getSum(u));\n        }\n        q--;\n    }\n\n    return 0;\n}\n\n\nvoid add(int v,int w){                              //直接在weight 更新重量 題目意思是 由V到他parent 的這條路徑重量為w 但是首先 這條路徑唯一 (此題目每個項目的parent 只有一個) 且紀錄parent 我們用另一個矩陣紀錄了\n    weight[v] += w;\n    return;\n}\n\nint getSum(int u){\n    while(u >0){\n        return weight[u] + getSum(parent[u]);\n    }\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DEBUG 0\n\nint parent[100000];\nint weight[100000];\nint sum[100000];\nint dirty[100000];\n\nint Dirty;\n\nvoid add(int v, int w);\nint getSum(int u);\n\nint main(){\n    memset(parent,0,sizeof(int)*100000); //等同於new int[100000]\n    memset(weight,0,sizeof(int)*100000);\n    memset(sum,0,sizeof(int)*100000);\n    memset(dirty,0,sizeof(int)*100000);\n   \n\n    int n = 0;\n    scanf(\"%d\",&n);\n    if(DEBUG)printf(\"n = %d\\n\",n);\n\n    //初始化用的計數器變數\n    int i = 0;                              // i = 這是第幾個點(同題目)\n    int j = 0;                              // j = 這個點有幾個child\n\n    int ki = 0;                             // ki = 題目中的ki 代表這個點有幾個child\n    int ci = 0;                             // ci = 這個點i 的child 們 在此使用while 迴圈持續取值重複使用\n    while(n > 0){\n        //每當n 還沒歸零 代表還沒初始化到最後一個點\n        \n        scanf(\"%d\",&ki);                    // scanf ki 來確定是否這個點有child\n        while(ki > 0){                      // 當ki 大於零 代表這個點i 有ki 個child\n            scanf(\"%d\",&ci);                // scanf ci 取得誰是child\n            parent[ci] = i;                 // 當ci 是點 i 的child 就把他的parent 設定成 i\n            ki --;                          // 減少 ki 進入下一回圈\n        }\n        // 如果 ki == 0 或者 已經初始化完畢\n        i ++;                               // i++來更新下一個點\n        n --;                               // n--進入下一次迴圈\n    }\n\n    // 完成初始化階段，完成此階段後 對於任意點 i , parent[i] 代表他的parent 是誰\n    // 在此題目中 每個點的parent 只會有一個 所以這個方法非常簡單暴力\n    Dirty = 0;\n    int q ;\n    scanf(\"%d\",&q);\n    if(DEBUG)printf(\"q = %d\\n\",q);\n\n    int cmd = 0;                            // cmd == 0 -> add  1 -> getSum\n    int v = 0;                              // 題目中的v\n    int w = 0;                              // 題目中的w\n    int u = 0;                              // 題目中的u\n\n    while(q>0){\n        //每當q 還沒歸零 代表需要繼續更新重量或者查詢\n        //我有強烈預感這要用lazy\n        //或者要用dp\n        scanf(\"%d\",&cmd);                   // 取得cmd 確定要add or getSum\n        if(DEBUG)printf(\"cmd = %d\\n\",cmd);\n\n        if(cmd == 0){\n            scanf(\"%d %d\",&v,&w);\n            add(v,w);\n\t    Dirty ++;\n\t    dirty[v] = 1;\n        }else{\n            scanf(\"%d\",&u);\n            printf(\"%d\\n\",getSum(u));\n\t    //dirty = 0;\n        }\n        q--;\n    }\n\n    return 0;\n}\n\n\nvoid add(int v,int w){                              //直接在weight 更新重量 題目意思是 由V到他parent 的這條路徑重量為w 但是首先 這條路徑唯一 (此題目每個項目的parent 只有一個) 且紀錄parent 我們用另一個矩陣紀錄了\n    weight[v] += w;\n    return;\n}\n\nint getSum(int u){\n    if(u == 0){\n\t    return 0;\n    }\n    if(Dirty){\n        while(u >0){\n\t    if(dirty[u]){dirty[u] = 0; Dirty--;}\n\t    sum[u] = weight[u] + getSum(parent[u]);\n\t    return sum[u];\n\t}\n    }else{\n\t    return sum[u];\n    }\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ GRL_5_D Tree - Range Query on a Tree\n// 2019.3.29 bal4u\n\n#define _CRT_SECURE_NO_WARNINGS\n#include <stdio.h>\n#include <stdlib.h>\n\n//// 入力の高速化\n#if 1\n#define gc() getchar_unlocked()\n#define pc(c) putchar_unlocked(c)\n#else\n#define gc() getchar()\n#define pc(c) putchar(c)\n#endif\nint in()\n{\n\tint n = 0, c = gc();\n\tdo n = 10 * n + (c & 0xf), c = gc(); while (c >= '0');\n\treturn n;\n}\n\nvoid out(int n)\n{\n\tint i;\n\tchar ob[40];\n\n\tif (!n) pc('0');\n\telse {\n\t\tif (n < 0) pc('-'), n = -n;\n\t\ti = 0; while (n) ob[i++] = n % 10 + '0', n /= 10;\n\t\twhile (i--) pc(ob[i]);\n\t}\n\tpc('\\n');\n}\n\n\n//// BIT library\n#define MAX 100005\nint bit[2*MAX]; int bmax;\n\nint sum(int i)\n{\n\tint s = 0;\n\n\twhile (i > 0) {\n\t\ts += bit[i];\n\t\ti -= i & -i;\n\t}\n\treturn s;\n}\n\nvoid add(int i, int v)\n{\n\twhile (i <= bmax) {\n\t\tbit[i] += v;\n\t\ti += i & -i;\n\t}\n}\n\n\n//// 本問題関連\nint N;\nint hi[MAX], *to[MAX];\nint idx[2*MAX][2]; int sz;\nint que[2*MAX], top;\n\nvoid eularTour()\n{\n\tint i, node;\n\n\tsz = 1;\n\n\t// 非再帰dfs\n\tque[0] = 0, top = 1;\n\twhile (top) {\n\t\tnode = que[--top];\n\n\t\t// dfsにする\n\t\tif (node < 0) {\n\t\t\tnode = -node;\n\t\t\tidx[node - 1][1] = sz++;\n\t\t\tcontinue;\n\t\t}\n\t\tque[top++] = -(node + 1);\n\n\t\tidx[node][0] = sz++;\n\t\tfor (i = 0; i < hi[node]; i++) que[top++] = to[node][i];\n\t}\n\n#if 0\n\tint j;\n\tfor (j = 0; j <= 1; j++) {\n\t\tfor (i = 0; i < sz; i++) printf(\"%3d \", idx[i][j]); printf(\"\\n\");\n\t}\n#endif\n}\n\nint main()\n{\n\tint i, j, k, Q;\n\tint cmd;\n\n\tN = in();\n\tfor (i = 0; i < N; i++) {\n\t\thi[i] = k = in();\n\t\tif (k > 0) {\n\t\t\tto[i] = malloc(sizeof(int)*k);\n\t\t\tfor (j = 0; j < k; j++) to[i][j] = in();\n\t\t}\n\t}\n\teularTour();\n\tbmax = sz + 1;\n\n\tQ = in();\n\twhile (Q--) {\n\t\tcmd = in();\n\t\tif (cmd == 0) {  // add(v, w)\n\t\t\tint v, w;\n\t\t\tv = in(), w = in();\n\t\t\tadd(idx[v][0], w);\n\t\t\tadd(idx[v][1], -w);\n\t\t}\n\t\telse {           // getSum(u)\n\t\t\tint u = in();\n\t\t\tif (u == 0) out(0);\n\t\t\telse out(sum(idx[u][0]));\n\t\t}\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define DEBUG 0\n\nint parent[100000];\nint weight[100000];\nint sum[100000];\nint dirty[100000];\nint clean[100000];\n\nint Dirty;\n\nvoid add(int v, int w);\nint getSum(int u);\n\nint main(){\n    memset(parent,0,sizeof(int)*100000); //等同於new int[100000]\n    memset(weight,0,sizeof(int)*100000);\n    memset(sum,0,sizeof(int)*100000);\n    memset(dirty,0,sizeof(int)*100000);\n    memset(clean,0,sizeof(int)*100000);\n   \n\n    int n = 0;\n    scanf(\"%d\",&n);\n    if(DEBUG)printf(\"n = %d\\n\",n);\n\n    //初始化用的計數器變數\n    int i = 0;                              // i = 這是第幾個點(同題目)\n    int j = 0;                              // j = 這個點有幾個child\n\n    int ki = 0;                             // ki = 題目中的ki 代表這個點有幾個child\n    int ci = 0;                             // ci = 這個點i 的child 們 在此使用while 迴圈持續取值重複使用\n    while(n > 0){\n        //每當n 還沒歸零 代表還沒初始化到最後一個點\n        \n        scanf(\"%d\",&ki);                    // scanf ki 來確定是否這個點有child\n        while(ki > 0){                      // 當ki 大於零 代表這個點i 有ki 個child\n            scanf(\"%d\",&ci);                // scanf ci 取得誰是child\n            parent[ci] = i;                 // 當ci 是點 i 的child 就把他的parent 設定成 i\n            ki --;                          // 減少 ki 進入下一回圈\n        }\n        // 如果 ki == 0 或者 已經初始化完畢\n        i ++;                               // i++來更新下一個點\n        n --;                               // n--進入下一次迴圈\n    }\n\n    // 完成初始化階段，完成此階段後 對於任意點 i , parent[i] 代表他的parent 是誰\n    // 在此題目中 每個點的parent 只會有一個 所以這個方法非常簡單暴力\n    Dirty = 0;\n    int q ;\n    scanf(\"%d\",&q);\n    if(DEBUG)printf(\"q = %d\\n\",q);\n\n    int cmd = 0;                            // cmd == 0 -> add  1 -> getSum\n    int v = 0;                              // 題目中的v\n    int w = 0;                              // 題目中的w\n    int u = 0;                              // 題目中的u\n\n    while(q>0){\n        //每當q 還沒歸零 代表需要繼續更新重量或者查詢\n        //我有強烈預感這要用lazy\n        //或者要用dp\n        scanf(\"%d\",&cmd);                   // 取得cmd 確定要add or getSum\n        if(DEBUG)printf(\"cmd = %d\\n\",cmd);\n\n        if(cmd == 0){\n            scanf(\"%d %d\",&v,&w);\n            add(v,w);\n\t    Dirty ++;\n\t    dirty[v] = 1;\n\t    memset(clean,0,sizeof(int)*100000);\n        }else{\n            scanf(\"%d\",&u);\n            printf(\"%d\\n\",getSum(u));\n\t    //dirty = 0;\n        }\n        q--;\n    }\n\n    return 0;\n}\n\n\nvoid add(int v,int w){                              //直接在weight 更新重量 題目意思是 由V到他parent 的這條路徑重量為w 但是首先 這條路徑唯一 (此題目每個項目的parent 只有一個) 且紀錄parent 我們用另一個矩陣紀錄了\n    weight[v] += w;\n    return;\n}\n\nint getSum(int u){\n    if(u == 0){\n\t    return 0;\n    }\n    if(clean[u]){\n\t    return sum[u];\n    }\n    if(Dirty){\n        while(u >0){\n\t    if(dirty[u]){dirty[u] = 0; Dirty--;}\n\t    clean[u] = 1;\n\t    sum[u] = weight[u] + getSum(parent[u]);\n\t    return sum[u];\n\t}\n    }else{\n\t    return sum[u];\n    }\n}\n\n"
  },
  {
    "language": "Java",
    "code": "import sys\n \nsys.setrecursionlimit(int(1e6))\n \n \nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0] * (n + 1)\n \n    def get_sum(self, i):\n        ret = 0\n        while i > 0:\n            ret += self.data[i]\n            i -= (i & -i)\n        return ret\n \n    def add(self, i, w):\n        if i == 0:\n            return\n        while i <= self.n:\n            self.data[i] += w\n            i += (i & -i)\n \n \ndef dfs(u, cnt):\n    cnt += 1\n    l[u] = cnt\n    for c in tree[u]:\n        cnt = dfs(c, cnt)\n    cnt += 1\n    r[u] = cnt\n    return cnt\n \n \nn = int(input())\nl, r = [0] * n, [0] * n\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n \nbit = BIT(dfs(0, 1))\n \nq = int(input())\nfor _ in range(q):\n    line = list(map(int, input().split()))\n    if line[0]:\n        print(bit.get_sum(r[line[1]] - 1))\n    else:\n        bit.add(l[line[1]], line[2])\n        bit.add(r[line[1]], -line[2])\n"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass D\n{\n\tstatic int[] Read() => Console.ReadLine().Split().Select(int.Parse).ToArray();\n\tstatic void Main()\n\t{\n\t\tvar n = int.Parse(Console.ReadLine());\n\t\tmap = new int[n].Select(_ => Read().Skip(1).ToArray()).ToArray();\n\t\tvar q = int.Parse(Console.ReadLine());\n\t\tvar qs = new int[q].Select(_ => Read()).ToArray();\n\n\t\ttour = new List<int>();\n\t\torder = Array.ConvertAll(new int[n], _ => new List<int>());\n\t\tEulerTourDfs(0, 0);\n\n\t\tvar st = new ST_Sum(2 * n);\n\t\tvar r = new List<long>();\n\t\tforeach (var z in qs)\n\t\t{\n\t\t\tif (z[0] == 0)\n\t\t\t{\n\t\t\t\tst.Add(order[z[1]][0], order[z[1]].Last() + 1, z[2]);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tr.Add(st.Get(order[z[1]][0]));\n\t\t\t}\n\t\t}\n\t\tConsole.WriteLine(string.Join(\"\\n\", r));\n\t}\n\n\tstatic int[][] map;\n\tstatic List<int> tour;\n\tstatic List<int>[] order;\n\tstatic void EulerTourDfs(int v, int depth)\n\t{\n\t\torder[v].Add(tour.Count);\n\t\tforeach (var nv in map[v])\n\t\t{\n\t\t\ttour.Add(v);\n\t\t\tEulerTourDfs(nv, depth + 1);\n\t\t\ttour.Add(-nv);\n\t\t\torder[v].Add(tour.Count);\n\t\t}\n\t}\n}\n\nclass ST_Sum\n{\n\tstruct KI\n\t{\n\t\tpublic int k, i;\n\t}\n\n\tint kMax;\n\tList<long[]> vs = new List<long[]> { new long[1] };\n\tpublic ST_Sum(int n)\n\t{\n\t\tfor (int c = 1; c < n; vs.Add(new long[c <<= 1])) ;\n\t\tkMax = vs.Count - 1;\n\t}\n\n\tKI[] GetLevels(int i)\n\t{\n\t\tvar r = new List<KI>();\n\t\tfor (int k = kMax; k >= 0; --k, i >>= 1) r.Add(new KI { k = k, i = i });\n\t\treturn r.ToArray();\n\t}\n\n\tKI[] GetRange(int minIn, int maxEx)\n\t{\n\t\tvar r = new List<KI>();\n\t\tfor (int k = kMax, f = 1; k >= 0 && minIn < maxEx; --k, f <<= 1)\n\t\t{\n\t\t\tif ((minIn & f) != 0) r.Add(new KI { k = k, i = (minIn += f) / f - 1 });\n\t\t\tif ((maxEx & f) != 0) r.Add(new KI { k = k, i = (maxEx -= f) / f });\n\t\t}\n\t\treturn r.ToArray();\n\t}\n\n\tpublic void Add(int minIn, int maxEx, long v)\n\t{\n\t\tforeach (var x in GetRange(minIn, maxEx)) vs[x.k][x.i] += v;\n\t}\n\n\tpublic long Get(int i) => GetLevels(i).Sum(x => vs[x.k][x.i]);\n}\n\n"
  },
  {
    "language": "Ruby",
    "code": "class SegmentTree\n  attr_accessor :disp\n  def inspect\n    @disp\n  end\n  def initialize(arr, l = 0, r = arr.size - 1)\n    @l = l\n    @r = r\n    if l == r\n      @agg = arr[l]\n    else\n      c = (l + r) / 2\n      @left_child = self.class.new(arr, l, c)\n      @right_child = self.class.new(arr, c + 1, r)\n      @agg = aggregate(@left_child.agg, @right_child.agg)\n    end\n  end\n\n  attr_reader :agg, :l, :r\n\n  def update(i, &block)\n    if @l == @r\n      @agg = block.call(@agg)\n    elsif i <= @left_child.r\n      @left_child.update(i, &block)\n      @agg = aggregate(@left_child.agg, @right_child.agg)\n    else\n      @right_child.update(i, &block)\n      @agg = aggregate(@left_child.agg, @right_child.agg)\n    end\n  end\n\n  def query(l = @l, r = @r)\n    return @agg if l == @l && r == @r\n    if r <= @left_child.r\n      return @left_child.query(l, r)\n    elsif @right_child.l <= l\n      return @right_child.query(l, r)\n    else\n      aggl = @left_child.query(l, @left_child.r)\n      aggr = @right_child.query(@right_child.l, r)\n      return aggregate(aggl, aggr)\n    end\n  end\n\n  def aggregate(x, y)\n    x + y\n  end\nend\n\nn = gets.to_i\ntree = Hash[(0..n-1).map {|i| [i, {}] }]\ntree_inv = Hash[(0..n-1).map {|i| [i, nil] }]\nout_degree = Hash[(0..n-1).map {|i| [i, 0] }]\nn.times do |i|\n  k, *neighbours = gets.split.map(&:to_i)\n  neighbours.each do |j|\n    tree[i][j] = 0\n    out_degree[i] += 1\n    tree_inv[j] = i\n  end\nend\n\nsubtree_size = Hash[(0..n-1).map {|i| [i, 1] }]\nqueue = []\nout_degree.each do |i, k|\n  if k == 0\n    queue << i\n  end\nend\nuntil queue.empty?\n  i = queue.shift\n  tree[i].each_key do |j|\n    subtree_size[i] += subtree_size[j]\n  end\n  j = tree_inv[i]\n  if j\n    out_degree[j] -= 1\n    queue << j if out_degree[j] == 0\n  end\nend\n\nqueue = [0]\npaths = []\nposition = {}\nseg_to_path = {}\nuntil queue.empty?\n  i = queue.shift\n  path = [i]\n  loop do\n    heavy = true\n    tree[i].each_key.sort_by {|j| -subtree_size[j]}.each do |j|\n      if heavy\n        path << j\n        i = j\n        heavy = false\n      else\n        queue << j\n      end\n    end\n    break if heavy\n  end\n  path.unshift tree_inv[path[0]] if tree_inv[path[0]]\n  weights = path.each_cons(2).map {|i, j| tree[i][j] }\n  seg = SegmentTree.new(weights)\n  seg_to_path[seg] = path\n  (1..path.size - 1).each do |i|\n    position[path[i]] = [seg, i - 1]\n  end\n  seg.disp = path\n  paths << path\nend\n\nq = gets.to_i\nq.times do\n  t, i, w = gets.split.map(&:to_i)\n  if t == 1\n    sum = 0\n    loop do\n      seg, j = position[i]\n      break if !seg\n      sum += seg.query(0, j)\n      path = seg_to_path[seg]\n      i = path[0]\n    end\n    p sum\n  else\n    seg, j = position[i]\n    seg.update(j) do |x|\n      x + w\n    end\n  end\nend\n\n"
  },
  {
    "language": "Go",
    "code": "package main\n\nimport (\n\t\"bufio\"\n\t\"fmt\"\n\t\"os\"\n)\nvar N =100003\ntype LinkCutTree struct {\n\tn int\n\tprt, left, right, sz, rev []int   ///[N]int\n\tkey, val []int\n}\nfunc (lct *LinkCutTree) update(i, l, r int) {\n\tlct.sz[i] = 1 + lct.sz[l] + lct.sz[r]\n\tlct.val[i] = lct.key[i] + lct.val[l] + lct.val[r]\n}\n\nfunc (lct *LinkCutTree) node_swap(i int) {\n\tif(i>0) {\n\tlct.swap(&lct.left[i], &lct.right[i]);\n\tlct.rev[i] ^= 1;\n\t}\n}\nfunc (lct *LinkCutTree) swap(i, j *int) {\n\ttemp := *i\n\t*i=*j\n\t*j=temp\n\t}\n\nfunc (lct *LinkCutTree)  prop(i int) bool {\n\tif(lct.rev[i]>0) {\n\t\tlct.node_swap(lct.left[i]);\n\t\tlct.node_swap(lct.right[i]);\n\t\tlct.rev[i] = 0;\n\t\treturn true;\n\t}\n\treturn false;\n}\n\nfunc (lct *LinkCutTree) splay(i int) {\n\tx := lct.prt[i]\n\tlct.prop(i)\n\n\tli := lct.left[i]\n\tri := lct.right[i]\n\tfor x>0 && (lct.left[x] == i || lct.right[x] == i) {\n\t\ty := lct.prt[x]\n\t\tif y == 0 || (lct.left[y] != x && lct.right[y] != x) {\n\t\t\tif (lct.prop(x)) {\n\t\t\t\tlct.swap(&li, &ri)\n\t\t\t\tlct.node_swap(li)\n\t\t\t\tlct.node_swap(ri)\n\t\t\t}\n\t\t\tif lct.left[x] == i {\n\t\t\t\tlct.left[x] = ri\n\t\t\t\tlct.prt[ri] = x\n\t\t\t\tlct.update(x, ri, lct.right[x])\n\t\t\t\tri = x\n\t\t\t} else {\n\t\t\t\tlct.right[x] = li\n\t\t\t\tlct.prt[li] = x\n\t\t\t\tlct.update(x, lct.left[x], li)\n\t\t\t\tli = x\n\t\t\t}\n\t\t\tx = y\n\t\t\tbreak\n\t\t}\n\t\tlct.prop(y)\n\t\tif lct.prop(x) {\n\t\t\tlct.swap(&li, &ri)\n\t\t\tlct.node_swap(li)\n\t\t\tlct.node_swap(ri)\n\t\t}\n\t\tz := lct.prt[y]\n\t\tif (lct.left[y] == x) {\n\t\t\tif (lct.left[x] == i) {\n\t\t\t\tv := lct.right[x]\n\t\t\t\tlct.left[y] = lct.right[x]\n\t\t\t\tlct.prt[v] = y\n\t\t\t\tlct.update(y, v, lct.right[y])\n\n\t\t\t\tlct.left[x] = ri\n\t\t\t\tlct.right[x] = y\n\t\t\t\tlct.prt[ri] = x\n\t\t\t\tlct.update(x, ri, y)\n\n\t\t\t\tlct.prt[y] = x\n\t\t\t\tri = x\n\t\t\t} else {\n\t\t\t\tlct.left[y] = ri\n\t\t\t\tlct.prt[ri] = y\n\t\t\t\tlct.update(y, ri, lct.right[y])\n\n\t\t\t\tlct.right[x] = li\n\t\t\t\tlct.prt[li] = x\n\t\t\t\tlct.update(x, lct.left[x], li)\n\n\t\t\t\tli = x;\n\t\t\t\tri = y;\n\t\t\t}\n\t\t} else {\n\t\t\tif lct.right[x] == i {\n\t\t\t\tv := lct.left[x]\n\t\t\t\tlct.right[y] = lct.left[x]\n\t\t\t\tlct.prt[v] = y\n\t\t\t\tlct.update(y, lct.left[y], v)\n\n\t\t\t\tlct.left[x] = y\n\t\t\t\tlct.right[x] = li\n\t\t\t\tlct.prt[li] = x\n\t\t\t\tlct.update(x, y, li)\n\n\t\t\t\tlct.prt[y] = x\n\t\t\t\tli = x\n\t\t\t} else {\n\t\t\t\tlct.right[y] = li\n\t\t\t\tlct.prt[li] = y\n\t\t\t\tlct.update(y, lct.left[y], li)\n\n\t\t\t\tlct.left[x] = ri\n\t\t\t\tlct.prt[ri] = x\n\t\t\t\tlct.update(x, ri, lct.right[x])\n\n\t\t\t\tli = y\n\t\t\t\tri = x\n\t\t\t}\n\t\t}\n\t\tx = z\n\t\tif lct.left[x] == y {\n\t\t\tlct.left[z] = i\n\t\t\tlct.update(z, i, lct.right[z])\n\t\t} else if lct.right[z] == y {\n\t\t\tlct.right[z] = i\n\t\t\tlct.update(z, lct.left[z], i)\n\t\t} else {\n\t\t\tbreak\n\t\t}\n\t}\n\n\tlct.update(i, li, ri)\n\tlct.left[i] = li\n\tlct.right[i] = ri\n\tlct.prt[li] = i\n\tlct.prt[ri] = i\n\tlct.prt[i] = x\n\n\tlct.rev[i] = 0\n\tlct.prt[0] = 0\n}\nfunc (lct *LinkCutTree) expose(i int) int{\n\tp := 0\n\tcur := i\n\tfor cur>0 {\n\t\tlct.splay(cur)\n\t\tlct.right[cur] = p\n\t\tlct.update(cur, lct.left[cur], p)\n\t\tp = cur\n\t\tcur = lct.prt[cur]\n\t}\n\tlct.splay(i)\n\treturn i\n}\n\nfunc (lct *LinkCutTree) cut(i int) int {\n\tlct.expose(i)\n\tp := lct.left[i]\n\tlct.left[i] = 0\n\tlct.prt[p] = 0\n\treturn p\n}\n\nfunc (lct *LinkCutTree) link(i, p int) {\n\tlct.expose(i)\n\tlct.expose(p)\n\tlct.prt[i] = p\n\tlct.right[p] = i\n}\nfunc (lct *LinkCutTree) evert(i int) {\n\tlct.expose(i)\n\tlct.node_swap(i)\n\tlct.prop(i)\n}\n\nfunc (lct *LinkCutTree)InitLinkCutTree(n int) {\n\tlct.n=n\n\tlct.prt=make([]int,N)\n\tlct.left=make([]int,N)\n\tlct.right=make([]int,N)\n\tlct.rev=make([]int,N)\n\tlct.sz=make([]int,N)\n\tlct.key=make([]int,N)\n\tlct.val=make([]int,N)\n\tfor i:=0; i<n+1; i++{\n\t\tlct.prt[i]=0\n\t\tlct.left[i]=0\n\t\tlct.right[i]=0\n\t\tlct.rev[i]=0\n\t\tlct.sz[i]=1\n\t}\n\tlct.sz[0] = 0\n\tlct.left[0] =-1\n\tlct.right[0] = -1\n}\n\nfunc (lct *LinkCutTree) query(v int) int{\n\tr := lct.expose(v+1)\n\treturn lct.val[r]\n}\n\nfunc (lct *LinkCutTree) query_add(v, w int) {\n\tlct.key[v+1] += w\n\tlct.expose(v+1)\n}\nvar in=bufio.NewReader(os.Stdin)\nvar out=bufio.NewWriter(os.Stdout)\nfunc main() {\n\tvar n int\n\tfmt.Fscanf(in,\"%d\\n\",&n)\n\tvar lct LinkCutTree\n\tlct.InitLinkCutTree(n)\n\tfor i:=0; i<n; i++ {\n\t\tvar k int\n\t\tfmt.Fscanf(in,\"%d\",&k)\n\t\tfor j := 0; j < k; j++ {\n\t\t\tvar c int\n\t\t\tfmt.Fscanf(in,\"%d\",&c)\n\t\t\tlct.link(c+1, i+1);\n\t\t}\n\t\tfmt.Fscanf(in,\"\\n\")\n\t}\n\tvar q int\n\tfmt.Fscanf(in,\"%d\\n\",&q)\n\tfor i:=0; i<q; i++ {\n\t\tvar t int\n\t\tfmt.Fscanf(in, \"%d\", &t)\n\t\tif t > 0 {\n\t\t\tvar u int\n\t\t\tfmt.Fscanf(in, \"%d\\n\", &u)\n\t\t\tfmt.Fprintf(out, \"%d\\n\", lct.query(u))\n\t\t\tout.Flush()\n\t\t} else {\n\t\t\tvar v, w int\n\t\t\tfmt.Fscanf(in, \"%d %d\\n\", &v, &w)\n\t\t\tlct.query_add(v, w)\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_D: Tree - Range Query on Tree\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\nclass RAQ:\n    \"\"\"Segment Tree\n    \"\"\"\n    def __init__(self, n, initial=0):\n        size = 1\n        while size < n:\n            size *= 2\n        self.size = 2*size - 1\n        self.data = [initial] * self.size\n\n    def add(self, i, j, v):\n        def _add(r, lo, hi):\n            if i <= lo and hi <= j:\n                data[r] += v\n            elif i <= hi and lo <= j:\n                mid = lo + (hi - lo)//2\n                _add(r*2 + 1, lo, mid)\n                _add(r*2 + 2, mid+1, hi)\n\n        data = self.data\n        return _add(0, 0, self.size//2)\n\n    def get(self, i):\n        def _get(r, lo, hi, v):\n            v += self.data[r]\n            if lo == hi:\n                return v\n            mid = lo + (hi - lo)//2\n            if mid >= i:\n                return _get(r*2 + 1, lo, mid, v)\n            else:\n                return _get(r*2 + 2, mid+1, hi, v)\n\n        return _get(0, 0, self.size//2, 0)\n\n\nclass PathSum:\n    def __init__(self, graph, root):\n        self.seg = RAQ(graph.v)\n        self._dfs(graph, root)\n\n    def _dfs(self, graph, root):\n        visited = [False] * graph.v\n        pos = [None] * graph.v\n        stack = [root]\n        n = 0\n        ns = []\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                ns.append(n)\n                n += 1\n                stack.append(v)\n                for e in graph.adj(v):\n                    w = e.other(v)\n                    if not visited[w]:\n                        stack.append(w)\n            else:\n                pos[v] = (ns.pop(), n - 1)\n\n        self._pos = pos\n\n    def add(self, v, val):\n        i, j = self._pos[v]\n        self.seg.add(i, j, val)\n\n    def get(self, v):\n        return self.seg.get(self._pos[v][0])\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    raq = PathSum(g, 0)\n    q = int(input())\n    for _ in range(q):\n        com, *args = [int(i) for i in input().split()]\n        if com == 0:\n            u, val = args\n            raq.add(u, val)\n        elif com == 1:\n            u, = args\n            print(raq.get(u))\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nN = int(input())\nG = [None for i in range(N)]\nfor i in range(N):\n  temp = list(map(int, input().split()))\n  G[i] = temp[1:]\n  \nINF = 2**31 -1\n\ntemp = 1\nwhile temp < N:\n  temp *= 2\n\nlis = [INF for i in range(2*temp-1)]\n\ndef getSum(x):\n  x += temp-1\n  w_sum = lis[x]\n  while x > 0:\n    x = (x-1) // 2\n    w_sum += lis[x]\n  return w_sum\n\ndef add(a, b, x, k=0, l=0, r=temp):\n  if r <= a or b <= l:\n    return 0\n\n  if a <= l and r <= b:\n    lis[k] += x\n    return 0\n  \n  add(a, b, k*2+1, l, (l+r)//2)\n  add(a, b, k*2+2, (l+r)//2, r)\narr = [[0,0] for i in range(200010)]\n\ndef dfs(k, a=0):\n  arr[0][k] = a\n  a += 1\n  for i in range(len(G[k])):\n    dfs(G[k][i])\n  arr[1][k] = a\n  \ndfs()\nQ = int(intput())\nfor i in range(Q):\n  querry = list(map(int, input().split()))\n  if querry[0] == 0:\n    add()\n  else:\n    print(getSum()\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Tree():\n    def __init__(self, n, edge):\n        self.n = n\n        self.tree = [[] for _ in range(n)]\n        for e in edge:\n            self.tree[e[0] - 1].append(e[1] - 1)\n            self.tree[e[1] - 1].append(e[0] - 1)\n\n    def setroot(self, root):\n        self.root = root\n        self.parent = [None for _ in range(self.n)]\n        self.parent[root] = -1\n        self.depth = [None for _ in range(self.n)]\n        self.depth[root] = 0\n        self.order = []\n        self.order.append(root)\n        self.size = [1 for _ in range(self.n)]\n        stack = [root]\n        while stack:\n            node = stack.pop()\n            for adj in self.tree[node]:\n                if self.parent[adj] is None:\n                    self.parent[adj] = node\n                    self.depth[adj] = self.depth[node] + 1\n                    self.order.append(adj)\n                    stack.append(adj)\n        for node in self.order[::-1]:\n            for adj in self.tree[node]:\n                if self.parent[node] == adj:\n                    continue\n                self.size[node] += self.size[adj]\n\n    def heavylight_decomposition(self):\n        self.order = [None for _ in range(self.n)]\n        self.head = [None for _ in range(self.n)]\n        self.head[self.root] = self.root\n        self.next = [None for _ in range(self.n)]\n        stack = [self.root]\n        order = 0\n        while stack:\n            node = stack.pop()\n            self.order[node] = order\n            order += 1\n            maxsize = 0\n            for adj in self.tree[node]:\n                if self.parent[node] == adj:\n                    continue\n                if maxsize < self.size[adj]:\n                    maxsize = self.size[adj]\n                    self.next[node] = adj\n            for adj in self.tree[node]:\n                if self.parent[node] == adj or self.next[node] == adj:\n                    continue\n                self.head[adj] = adj\n                stack.append(adj)\n            if self.next[node] is not None:\n                self.head[self.next[node]] = self.head[node]\n                stack.append(self.next[node])\n\n    def range_hld(self, u, v, edge=False):\n        res = []\n        while True:\n            if self.order[u] > self.order[v]: u, v = v, u\n            if self.head[u] != self.head[v]:\n                res.append((self.order[self.head[v]], self.order[v] + 1))\n                v = self.parent[self.head[v]]\n            else:\n                res.append((self.order[u] + edge, self.order[v] + 1))\n                return res\n\n    def subtree_hld(self, u):\n        return self.order[u], self.order[u] + self.size[u]\n\n    def lca_hld(self, u, v):\n        while True:\n            if self.order[u] > self.order[v]: u, v = v, u\n            if self.head[u] != self.head[v]:\n                v = self.parent[self.head[v]]\n            else:\n                return u\n\nclass SegmentTree():\n    def __init__(self, arr, func=min, ie=2**63):\n        self.h = (len(arr) - 1).bit_length()\n        self.n = 2**self.h\n        self.ie = ie\n        self.func = func\n        self.tree = [ie for _ in range(2 * self.n)]\n        for i in range(len(arr)):\n            self.tree[self.n + i] = arr[i]\n        for i in range(1, self.n)[::-1]:\n            self.tree[i] = func(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def set(self, idx, x):\n        idx += self.n\n        self.tree[idx] = x\n        while idx:\n            idx >>= 1\n            self.tree[idx] = self.func(self.tree[2 * idx], self.tree[2 * idx + 1])\n\n    def query(self, lt, rt):\n        lt += self.n\n        rt += self.n\n        vl = vr = self.ie\n        while rt - lt > 0:\n            if lt & 1:\n                vl = self.func(vl, self.tree[lt])\n                lt += 1\n            if rt & 1:\n                rt -= 1\n                vr = self.func(self.tree[rt], vr)\n            lt >>= 1\n            rt >>= 1\n        return self.func(vl, vr)\n\n\nimport sys\ninput = sys.stdin.readline\n\nfrom operator import add\n\nN = int(input())\nE = []\n\nfor i in range(N):\n    k, *c = map(int, input().split())\n    for j in range(k):\n        E.append((i + 1, c[j] + 1))\n\nt = Tree(N, E)\nt.setroot(0)\nt.heavylight_decomposition()\n\nst = SegmentTree([0] * N, add, 0)\n\nres = []\n\nQ = int(input())\n\nfor _ in range(Q):\n    q, *p = map(int, input().split())\n    if q == 0:\n        v, w = p\n        st.set(t.order[v], st.query(t.order[v], t.order[v] + 1) + w)\n    else:\n        s = 0\n        u, = p\n        for lt, rt in t.range_hld(0, u, edge=True):\n            s += st.query(lt, rt)\n        res.append(s)\n\nprint('\\n'.join(map(str, res)))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nclass weightRtree:\n    def __init__(self, num):\n        self.num = num\n        self.weight = [0] * (num+1) \n      \n    def add(self, v, w):\n        if v == 0:\n            return 0\n        while v <= self.num:\n            self.weight[v] += w\n            v += (-v) & v    \n\n    def getSum(self, u):\n        temp = 0\n        while u > 0:\n            temp += self.weight[u]\n            u -= (-u) & u\n        return temp\n\nN = int(input())\nleft = [0] * N\nright = [0] * N\nTree = [set(map(int, input().split()[1:])) for i in range(N)]\n\ndef DFS(count, source):\n    count += 1\n    left[source] = count\n    for item in Tree[source]:\n        count = DFS(count, item)\n    count += 1\n    right[source] = count\n    return count\n\nObject = weightRtree(DFS(1, 0))\n\nQ = int(input())\nfor i in range(Q):\n    alist = list(map(int, input().split()))\n    if not alist[0]:\n        Object.add(left[alist[1]], alist[2])\n        Object.add(right[alist[1]], -alist[2])\n    else:\n        print(Object.getSum(right[alist[1]] - 1))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n \nsys.setrecursionlimit(int(1e6))\n \n \nclass B_I_T:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0] * (n + 1)\n \n    def get_sum(self, i):\n        ret = 0\n        while i > 0:\n            ret += self.data[i]\n            i -= (i & -i)\n        return ret\n \n    def add(self, i, w):\n        if i == 0:\n            return\n        while i <= self.n:\n            self.data[i] += w\n            i += (i & -i)\n \n \ndef dfs(u, cnt):\n    cnt += 1\n    l[u] = cnt\n    for c in tree[u]:\n        cnt = dfs(c, cnt)\n    cnt += 1\n    r[u] = cnt\n    return cnt\n \n \nn = int(input())\nl, r = [0] * n, [0] * n\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n \nbit = B_I_T(dfs(0, 1))\n \nq = int(input())\nfor _ in range(q):\n    line = list(map(int, input().split()))\n    if line[0]:\n        print(bit.get_sum(r[line[1]] - 1))\n    else:\n        bit.add(l[line[1]], line[2])\n        bit.add(r[line[1]], -line[2])\n"
  },
  {
    "language": "Python",
    "code": "import sys\n \nsys.setrecursionlimit(int(1e6))\n \n \nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0] * (n + 1)\n \n    def get_sum(self, i):\n        ret = 0\n        while i > 0:\n            ret += self.data[i]\n            i -= (i & -i)\n        return ret\n \n    def add(self, i, w):\n        if i == 0:\n            return\n        while i <= self.n:\n            self.data[i] += w\n            i += (i & -i)\n \n \ndef dfs(u, cnt):\n    cnt += 1\n    l[u] = cnt\n    for c in tree[u]:\n        cnt = dfs(c, cnt)\n    cnt += 1\n    r[u] = cnt\n    return cnt\n \n \nn = int(input())\nl, r = [0] * n, [0] * n\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n \nbit = BIT(dfs(0, 1))\n \nq = int(input())\nfor _ in range(q):\n    line = list(map(int, input().split()))\n    if line[0]:\n        print(bit.get_sum(r[line[1]] - 1))\n    else:\n        bit.add(l[line[1]], line[2])\n        bit.add(r[line[1]], -line[2])\n"
  },
  {
    "language": "Python",
    "code": "N = 10 ** 5\nprt = [0] * (N + 1)\nleft = [-1] + [0] * N\nright = [-1] + [0] * N\nsz = [0] + [1] * N\nkey = [0] * (N + 1)\nval = [0] * (N + 1)\nrev = [0] * (N + 1)\n\n\ndef update(i, l, r):\n    # assert 1 <= i <= N\n    sz[i] = 1 + sz[l] + sz[r]\n    val[i] = key[i] + val[l] + val[r]\n\n\ndef swap(i):\n    if i:\n        left[i], right[i] = right[i], left[i]\n        rev[i] ^= 1\n\n\ndef prop(i):\n    swap(left[i])\n    swap(right[i])\n    rev[i] = 0\n    return 1\n\n\ndef splay(i):\n    # assert 1 <= i <= N\n    x = prt[i]\n    rev[i] and prop(i)\n\n    li = left[i];\n    ri = right[i]\n    while x and not left[x] != i != right[x]:\n        y = prt[x]\n        if not y or left[y] != x != right[y]:\n            if rev[x] and prop(x):\n                li, ri = ri, li\n                swap(li);\n                swap(ri)\n\n            if left[x] == i:\n                left[x] = ri\n                prt[ri] = x\n                update(x, ri, right[x])\n                ri = x\n            else:\n                right[x] = li\n                prt[li] = x\n                update(x, left[x], li)\n                li = x\n            x = y\n            break\n\n        rev[y] and prop(y)\n        if rev[x] and prop(x):\n            li, ri = ri, li\n            swap(li);\n            swap(ri)\n\n        z = prt[y]\n        if left[y] == x:\n            if left[x] == i:\n                v = left[y] = right[x]\n                prt[v] = y\n                update(y, v, right[y])\n\n                left[x] = ri;\n                right[x] = y\n                prt[ri] = x\n                update(x, ri, y)\n\n                prt[y] = ri = x\n            else:\n                left[y] = ri\n                prt[ri] = y\n                update(y, ri, right[y])\n\n                right[x] = li\n                prt[li] = x\n                update(x, left[x], li)\n\n                li = x;\n                ri = y\n        else:\n            if right[x] == i:\n                v = right[y] = left[x]\n                prt[v] = y\n                update(y, left[y], v)\n\n                left[x] = y;\n                right[x] = li\n                prt[li] = x\n                update(x, y, li)\n\n                prt[y] = li = x\n            else:\n                right[y] = li\n                prt[li] = y\n                update(y, left[y], li)\n\n                left[x] = ri\n                prt[ri] = x\n                update(x, ri, right[x])\n\n                li = y;\n                ri = x\n\n        x = z\n        if left[z] == y:\n            left[z] = i\n            update(z, i, right[z])\n        elif right[z] == y:\n            right[z] = i\n            update(z, left[z], i)\n        else:\n            break\n\n    update(i, li, ri)\n    left[i] = li;\n    right[i] = ri\n    prt[li] = prt[ri] = i\n    prt[i] = x\n\n    rev[i] = prt[0] = 0\n\n\ndef expose(i):\n    p = 0\n    cur = i\n    while cur:\n        splay(cur)\n        right[cur] = p\n        update(cur, left[cur], p)\n        p = cur\n        cur = prt[cur]\n    splay(i)\n    return i\n\n\ndef cut(i):\n    expose(i)\n    p = left[i]\n    left[i] = prt[p] = 0\n    return p\n\n\ndef link(i, p):\n    expose(i)\n    expose(p)\n    prt[i] = p\n    right[p] = i\n\n\ndef evert(i):\n    expose(i)\n    swap(i)\n    rev[i] and prop(i)\n\n\ndef query(v):\n    r = expose(v + 1)\n    return val[r]\n\n\ndef query_add(v, w):\n    key[v + 1] += w\n    expose(v + 1)\n\n\nreadline = open(0).readline\nwritelines = open(1, 'w').writelines\n\nN = int(readline())\nfor i in range(N):\n    k, *C = map(int, readline().split())\n    # for c in C:\n    #    link(c+1, i+1)\n    if k:\n        expose(i + 1)\n        for c in C:\n            expose(c + 1)\n            prt[c + 1] = i + 1\n        right[i + 1] = C[0] + 1\n\nQ = int(readline())\nans = []\nfor q in range(Q):\n    t, *args = map(int, readline().split())\n    if t:\n        ans.append(\"%d\\n\" % query(args[0]))\n    else:\n        query_add(*args)\nwritelines(ans)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(1000000)\n\nclass weightRtree:\n    def __init__(self, num):\n        self.num = num\n        self.weight = [0] * (num+1) \n      \n    def add(self, v, w):\n        if v == 0:\n            return 0\n        while v <= self.num:\n            self.weight[v] += w\n            v += (-v) & v    \n\n    def getSum(self, u):\n        temp = 0\n        while u > 0:\n            temp += self.weight[u]\n            u -= (-u) & u\n        return temp\n\nN = int(input())\nleft = [0] * N\nright = [0] * N\nTree = [set(map(int, input().split()[1:])) for i in range(N)]\n\ndef DFS(count, source):\n    count += 1\n    left[source] = count\n    for item in Tree[source]:\n        count = DFS(count, item)\n    count += 1\n    right[source] = count\n    return count\n\nObject = weightRtree(DFS(1, 0))\n\nQ = int(input())\nfor i in range(Q):\n    alist = list(map(int, input().split()))\n    if not alist[0]:\n        Object.add(left[alist[1]], alist[2])\n        Object.add(right[alist[1]], -alist[2])\n    else:\n        print(Object.getSum(right[alist[1]] - 1))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(1000000)\n\n\n# The class of range query on a Tree\nclass RQT:\n    # The initialization of node\n    def __init__(self, num):\n        self.num = num\n        self.weight = [0] * (num + 1)\n\n    # weight add operation\n    def add(self, v, w):\n        if v == 0:\n            return 0\n        while v <= self.num:\n            self.weight[v] += w\n            v += (-v) & v\n\n    # weight sum operation\n    def getSum(self, u):\n        temp = 0\n        while u > 0:\n            temp += self.weight[u]\n            u -= (-u) & u\n        return temp\n\n\nN = int(input())\nleft = [0] * N\nright = [0] * N\n# use set to construct the tree\nTree = [set(map(int, input().split()[1:])) for i in range(N)]\n\n# use DFS to search the target node\ndef DFS(count, source):\n    count += 1\n    left[source] = count\n    for item in Tree[source]:\n        count = DFS(count, item)\n    count += 1\n    right[source] = count\n    return count\n\n\nObject = RQT(DFS(1, 0))\n\n# read the operation code\nQ = int(input())\nfor i in range(Q):\n    alist = list(map(int, input().split()))\n    if not alist[0]:\n        Object.add(left[alist[1]], alist[2])\n        Object.add(right[alist[1]], -alist[2])\n    else:\n        print(Object.getSum(right[alist[1]] - 1))\n"
  },
  {
    "language": "Python",
    "code": "N = 10**5\nprt = [0]*(N+1)\nleft = [-1] + [0]*N\nright = [-1] + [0]*N\nsz = [0] + [1]*N\nkey = [0]*(N+1)\nval = [0]*(N+1)\nrev = [0]*(N+1)\n \ndef update(i, l, r):\n    #assert 1 <= i <= N\n    sz[i] = 1 + sz[l] + sz[r]\n    val[i] = key[i] + val[l] + val[r]\n \ndef swap(i):\n    if i:\n        left[i], right[i] = right[i], left[i]\n        rev[i] ^= 1\n \ndef prop(i):\n    swap(left[i])\n    swap(right[i])\n    rev[i] = 0\n    return 1\n \ndef splay(i):\n    #assert 1 <= i <= N\n    x = prt[i]\n    rev[i] and prop(i)\n \n    li = left[i]; ri = right[i]\n    while x and not left[x] != i != right[x]:\n        y = prt[x]\n        if not y or left[y] != x != right[y]:\n            if rev[x] and prop(x):\n                li, ri = ri, li\n                swap(li); swap(ri)\n \n            if left[x] == i:\n                left[x] = ri\n                prt[ri] = x\n                update(x, ri, right[x])\n                ri = x\n            else:\n                right[x] = li\n                prt[li] = x\n                update(x, left[x], li)\n                li = x\n            x = y\n            break\n \n        rev[y] and prop(y)\n        if rev[x] and prop(x):\n            li, ri = ri, li\n            swap(li); swap(ri)\n \n        z = prt[y]\n        if left[y] == x:\n            if left[x] == i:\n                v = left[y] = right[x]\n                prt[v] = y\n                update(y, v, right[y])\n \n                left[x] = ri; right[x] = y\n                prt[ri] = x\n                update(x, ri, y)\n \n                prt[y] = ri = x\n            else:\n                left[y] = ri\n                prt[ri] = y\n                update(y, ri, right[y])\n \n                right[x] = li\n                prt[li] = x\n                update(x, left[x], li)\n \n                li = x; ri = y\n        else:\n            if right[x] == i:\n                v = right[y] = left[x]\n                prt[v] = y\n                update(y, left[y], v)\n \n                left[x] = y; right[x] = li\n                prt[li] = x\n                update(x, y, li)\n \n                prt[y] = li = x\n            else:\n                right[y] = li\n                prt[li] = y\n                update(y, left[y], li)\n \n                left[x] = ri\n                prt[ri] = x\n                update(x, ri, right[x])\n \n                li = y; ri = x\n \n        x = z\n        if left[z] == y:\n            left[z] = i\n            update(z, i, right[z])\n        elif right[z] == y:\n            right[z] = i\n            update(z, left[z], i)\n        else:\n            break\n \n    update(i, li, ri)\n    left[i] = li; right[i] = ri\n    prt[li] = prt[ri] = i\n    prt[i] = x\n \n    rev[i] = prt[0] = 0\n \ndef expose(i):\n    p = 0\n    cur = i\n    while cur:\n        splay(cur)\n        right[cur] = p\n        update(cur, left[cur], p)\n        p = cur\n        cur = prt[cur]\n    splay(i)\n    return i\n \ndef cut(i):\n    expose(i)\n    p = left[i]\n    left[i] = prt[p] = 0\n    return p\n \ndef link(i, p):\n    expose(i)\n    expose(p)\n    prt[i] = p\n    right[p] = i\n \ndef evert(i):\n    expose(i)\n    swap(i)\n    rev[i] and prop(i)\n \ndef query(v):\n    r = expose(v+1)\n    return val[r]\n \ndef query_add(v, w):\n    key[v+1] += w\n    expose(v+1)\n \n \nreadline = open(0).readline\nwritelines = open(1, 'w').writelines\n \nN = int(readline())\nfor i in range(N):\n    k, *C = map(int, readline().split())\n    #for c in C:\n    #    link(c+1, i+1)\n    if k:\n        expose(i+1)\n        for c in C:\n            expose(c+1)\n            prt[c+1] = i+1\n        right[i+1] = C[0]+1\n \nQ = int(readline())\nans = []\nfor q in range(Q):\n    t, *args = map(int, readline().split())\n    if t:\n        ans.append(\"%d\\n\" % query(args[0]))\n    else:\n        query_add(*args)\nwritelines(ans)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_D: Tree - Range Query on Tree\n# Eular Tour Technique\n# DFSの結果でサブツリーの範囲がわかるので、range add queryを利用して\n# add/getを行う\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\nclass RAQ:\n    \"\"\"Segment Tree\n    \"\"\"\n    def __init__(self, n, initial=0):\n        size = 1\n        while size < n:\n            size *= 2\n        self.size = 2*size - 1\n        self.data = [initial] * self.size\n\n    def add(self, i, j, v):\n        def _add(r, lo, hi):\n            if hi < i or lo > j:\n                return\n            elif i <= lo and hi <= j:\n                self.data[r] += v\n            else:\n                mid = lo + (hi - lo)//2\n                _add(r*2 + 1, lo, mid)\n                _add(r*2 + 2, mid+1, hi)\n\n        return _add(0, 0, self.size//2)\n\n    def get(self, i):\n        def _get(r, lo, hi, v):\n            v += self.data[r]\n            if lo == hi:\n                return v\n            mid = lo + (hi - lo)//2\n            if mid >= i:\n                return _get(r*2 + 1, lo, mid, v)\n            else:\n                return _get(r*2 + 2, mid+1, hi, v)\n\n        return _get(0, 0, self.size//2, 0)\n\n\nclass PathSum:\n    def __init__(self, graph, root):\n        self.seg = RAQ(graph.v)\n        self._in = [0] * graph.v\n        self._out = [0] * graph.v\n        self.dfs(graph, root)\n\n    def dfs(self, graph, root):\n        visited = [False] * graph.v\n        stack = [root]\n        i = 0\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                self._in[v] = i\n                i += 1\n                stack.append(v)\n                for e in graph.adj(v):\n                    w = e.other(v)\n                    if not visited[w]:\n                        stack.append(w)\n            else:\n                self._out[v] = i - 1\n\n    def add(self, v, val):\n        i = self._in[v]\n        j = self._out[v]\n        self.seg.add(i, j, val)\n\n    def get(self, v):\n        return self.seg.get(self._in[v])\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    raq = PathSum(g, 0)\n    q = int(input())\n    for _ in range(q):\n        com, *args = [int(i) for i in input().split()]\n        if com == 0:\n            u, val = args\n            raq.add(u, val)\n        elif com == 1:\n            u, = args\n            print(raq.get(u))\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(int(1e6))\n\n\nclass BIT:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.data = [0] * (n + 1)\n\n\tdef get_sum(self, i):\n\t\tret = 0\n\t\twhile i > 0:\n\t\t\tret += self.data[i]\n\t\t\ti -= (i & -i)\n\t\treturn ret\n\n\tdef add(self, i, w):\n\t\tif i == 0:\n\t\t\treturn\n\t\twhile i <= self.n:\n\t\t\tself.data[i] += w\n\t\t\ti += (i & -i)\n\ndef dfs(u, cnt):\n\tcnt += 1\n\tl[u] = cnt\n\tfor c in tree[u]:\n\t\tcnt = dfs(c, cnt)\n\tcnt += 1\n\tr[u] = cnt\n\treturn cnt\n\nn = int(input())\nl, r = [0] * n, [0] * n\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nbit = BIT(dfs(0, 1))\n\nq = int(input())\nfor _ in range(q):\n\tline = list(map(int, input().split()))\n\tif line[0]:\n\t\tprint(bit.get_sum(r[line[1]] - 1))\n\telse:\n\t\tbit.add(l[line[1]], line[2])\n\t\tbit.add(r[line[1]], -line[2])\n"
  },
  {
    "language": "Python",
    "code": "from collections import deque\n\nimport sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\nwrite = sys.stdout.write\nN = int(readline())\nG = [None]*N\nfor i in range(N):\n    k, *c = map(int, readline().split())\n    G[i] = c\n\nH = [0]*N\nprv = [None]*N\ndef dfs(v):\n    s = 1; heavy = None; m = 0\n    for w in G[v]:\n        prv[w] = v\n        c = dfs(w)\n        if m < c:\n            heavy = w\n            m = c\n        s += c\n    H[v] = heavy\n    return s\ndfs(0)\n\n\nSS = []\nD = []\nL = [0]*N\nI = [0]*N\nque = deque([(0, 0)])\nwhile que:\n    v, d = que.popleft()\n    S = []\n    k = len(SS)\n    while v is not None:\n        I[v] = len(S)\n        S.append(v)\n        L[v] = k\n        h = H[v]\n        for w in G[v]:\n            if h == w:\n                continue\n            que.append((w, d+1))\n        v = h\n    SS.append(S)\n    D.append(d)\n\n\nC = list(map(len, SS))\nDS = [[0]*(c+1) for c in C]\ndef add(K, data, k, x):\n    while k <= K:\n        data[k] += x\n        k += k & -k\ndef get(K, data, k):\n    s = 0\n    while k:\n        s += data[k]\n        k -= k & -k\n    return s\n\ndef query_add(v, x):\n    l = L[v]\n    add(C[l], DS[l], I[v]+1, x)\n    v = prv[SS[l][0]]\n\ndef query_sum(v):\n    s = 0\n    while v is not None:\n        l = L[v]\n        s += get(C[l], DS[l], I[v]+1)\n        v = prv[SS[l][0]]\n    return s\n\n\nQ = int(readline())\nans = []\nfor q in range(Q):\n    t, *cmd = map(int, readline().split())\n    if t:\n        ans.append(str(query_sum(cmd[0])))\n    else:\n        v, w = cmd\n        query_add(v, w)\nwrite(\"\\n\".join(ans))\nwrite(\"\\n\")\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(int(1e6))\n\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0] * (n + 1)\n\n    def get_sum(self, i):\n        ret = 0\n        while i > 0:\n            ret += self.data[i]\n            i -= (i & -i)\n        return ret\n\n    def add(self, i, w):\n        if i == 0:\n            return\n        while i <= self.n:\n            self.data[i] += w\n            i += (i & -i)\n\n\ndef dfs(u, cnt):\n    cnt += 1\n    l[u] = cnt\n    for c in tree[u]:\n        cnt = dfs(c, cnt)\n    cnt += 1\n    r[u] = cnt\n    return cnt\n\n\nn = int(input())\nl, r = [0] * n, [0] * n\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nbit = BIT(dfs(0, 1))\n\nq = int(input())\nfor _ in range(q):\n    line = list(map(int, input().split()))\n    if line[0]:\n        print(bit.get_sum(r[line[1]] - 1))\n    else:\n        bit.add(l[line[1]], line[2])\n        bit.add(r[line[1]], -line[2])\n\n"
  },
  {
    "language": "Python",
    "code": "N = 10 ** 5\nprt = [0] * (N + 1)\nleft = [-1] + [0] * N\nright = [-1] + [0] * N\nsz = [0] + [1] * N\nkey = [0] * (N + 1)\nval = [0] * (N + 1)\nrev = [0] * (N + 1)\n\n\ndef update(i, l, r):\n    # assert 1 <= i <= N\n    sz[i] = 1 + sz[l] + sz[r]\n    val[i] = key[i] + val[l] + val[r]\n\n\ndef swap(i):\n    if i:\n        left[i], right[i] = right[i], left[i]\n        rev[i] ^= 1\n\n\ndef prop(i):\n    swap(left[i])\n    swap(right[i])\n    rev[i] = 0\n    return 1\n\n\ndef splay(i):\n    # assert 1 <= i <= N\n    x = prt[i]\n    rev[i] and prop(i)\n\n    li = left[i];\n    ri = right[i]\n    while x and not left[x] != i != right[x]:\n        y = prt[x]\n        if not y or left[y] != x != right[y]:\n            if rev[x] and prop(x):\n                li, ri = ri, li\n                swap(li);\n                swap(ri)\n\n            if left[x] == i:\n                left[x] = ri\n                prt[ri] = x\n                update(x, ri, right[x])\n                ri = x\n            else:\n                right[x] = li\n                prt[li] = x\n                update(x, left[x], li)\n                li = x\n            x = y\n            break\n\n        rev[y] and prop(y)\n        if rev[x] and prop(x):\n            li, ri = ri, li\n            swap(li);\n            swap(ri)\n\n        z = prt[y]\n        if left[y] == x:\n            if left[x] == i:\n                v = left[y] = right[x]\n                prt[v] = y\n                update(y, v, right[y])\n\n                left[x] = ri;\n                right[x] = y\n                prt[ri] = x\n                update(x, ri, y)\n\n                prt[y] = ri = x\n            else:\n                left[y] = ri\n                prt[ri] = y\n                update(y, ri, right[y])\n\n                right[x] = li\n                prt[li] = x\n                update(x, left[x], li)\n\n                li = x;\n                ri = y\n        else:\n            if right[x] == i:\n                v = right[y] = left[x]\n                prt[v] = y\n                update(y, left[y], v)\n\n                left[x] = y;\n                right[x] = li\n                prt[li] = x\n                update(x, y, li)\n\n                prt[y] = li = x\n            else:\n                right[y] = li\n                prt[li] = y\n                update(y, left[y], li)\n\n                left[x] = ri\n                prt[ri] = x\n                update(x, ri, right[x])\n\n                li = y;\n                ri = x\n\n        x = z\n        if left[z] == y:\n            left[z] = i\n            update(z, i, right[z])\n        elif right[z] == y:\n            right[z] = i\n            update(z, left[z], i)\n        else:\n            break\n\n    update(i, li, ri)\n    left[i] = li;\n    right[i] = ri\n    prt[li] = prt[ri] = i\n    prt[i] = x\n\n    rev[i] = prt[0] = 0\n\n\ndef expose(i):\n    p = 0\n    cur = i\n    while cur:\n        splay(cur)\n        right[cur] = p\n        update(cur, left[cur], p)\n        p = cur\n        cur = prt[cur]\n    splay(i)\n    return i\n\n\ndef cut(i):\n    expose(i)\n    p = left[i]\n    left[i] = prt[p] = 0\n    return p\n\n\ndef link(i, p):\n    expose(i)\n    expose(p)\n    prt[i] = p\n    right[p] = i\n\n\ndef evert(i):\n    expose(i)\n    swap(i)\n    rev[i] and prop(i)\n\n\ndef query(v):\n    r = expose(v + 1)\n    return val[r]\n\n\ndef query_add(v, w):\n    key[v + 1] += w\n    expose(v + 1)\n\n\nreadline = open(0).readline\nwritelines = open(1, 'w').writelines\n\nN = int(readline())\nfor i in range(N):\n    k, *C = map(int, readline().split())\n    # for c in C:\n    #    link(c+1, i+1)\n    if k:\n        expose(i + 1)\n        for c in C:\n            expose(c + 1)\n            prt[c + 1] = i + 1\n        right[i + 1] = C[0] + 1\n\nQ = int(readline())\nans = []\nfor q in range(Q):\n    t, *args = map(int, readline().split())\n    if t:\n        ans.append(\"%d\\n\" % query(args[0]))\n    else:\n        query_add(*args)\nwritelines(ans)\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nclass weightRtree:\n    def __init__(self, num):\n        self.num = num\n        self.weight = [0] * (num+1) \n      \n    def add(self, v, w):\n        if v == 0:\n            return 0\n        while v <= self.num:\n            self.weight[v] += w\n            v += (-v) & v    \n\n    def getSum(self, u):\n        temp = 0\n        while u > 0:\n            temp += self.weight[u]\n            u -= (-u) & u\n        return temp\n\nN = int(input())\nleft = [0] * N\nright = [0] * N\nTree = [set(map(int, input().split()[1:])) for i in range(N)]\n\ndef DFS(count, source):\n    count += 1\n    left[source] = count\n    for item in Tree[source]:\n        count = DFS(count, item)\n    count += 1\n    right[source] = count\n    return count\n\nObject = weightRtree(DFS(1, 0))\n\nQ = int(input())\nfor i in range(Q):\n    alist = list(map(int, input().split()))\n    if not alist[0]:\n        Object.add(left[alist[1]], alist[2])\n        Object.add(left[alist[1]], -alist[2])\n    else:\n        print(Object.getSum(right[alist[1]] - 1))\n\n\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nN = int(input())\nG = [None for i in range(N)]\nfor i in range(N):\n  temp = list(map(int, input().split()))\n  G[i] = temp[1:]\n  \nINF = 2**31 -1\n\ntemp = 1\nwhile temp < N:\n  temp *= 2\n\nlis = [INF for i in range(2*temp-1)]\n\ndef getSum(x):\n  x += temp-1\n  w_sum = lis[x]\n  while x > 0:\n    x = (x-1) // 2\n    w_sum += lis[x]\n  return w_sum\n\ndef add(a, b, x, k=0, l=0, r=temp):\n  if r <= a or b <= l:\n    return 0\n\n  if a <= l and r <= b:\n    lis[k] += x\n    return 0\n  \n  add(a, b, k*2+1, l, (l+r)//2)\n  add(a, b, k*2+2, (l+r)//2, r)\n\ndef dfs(k, a=0):\n  arr[0][k] = a\n  a += 1\n  for i in range(len(G[k])):\n    dfs(G[k][i])\n  arr[1][k] = a\n  \narr = [[0,0] for i in range(200010)]\n\n\n  \ndfs()\nQ = int(input())\nfor i in range(Q):\n  querry = list(map(int, input().split()))\n  if querry[0] == 0:\n    add(arr[0][querry[1]], arr[1][querry[1]],w)\n  else:\n    print(getSum(arr[0][querry[1]])\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nclass weightRtree:\n    def __init__(self, num):\n        self.num = num\n        self.weight = (num+1)*[0] \n      \n    def add(self, v, w):\n        if v == 0:\n            return 0\n        while v <= self.num:\n            self.weight[v] += w\n            v += (-v&v)    \n\n    def getSum(self, u):\n        temp = 0\n        while u > 0:\n            temp += self.weight[u]\n            u -= (-u&u)\n        return temp\n\nN = int(input())\nleft = [0]*N\nright = [0]*N\nTree = [set(map(int, input().split()[1:])) for i in range(N)]\n\ndef DFS(count, source):\n    count += 1\n    left[source] = count\n    for item in Tree[source]:\n        count = DFS(count, item)\n    count += 1\n    right[source] = count\n    return count\n\nObject = weightRtree(DFS(1, 0))\n\nQ = int(input())\nfor i in range(Q):\n    alist = list(map(int, input().split()))\n    if not alist[0]:\n        Object.add(left[alist[1]], alist[2])\n        Object.add(left[alist[1]], -alist[2])\n    else:\n        print(Object.getSum(right[alist[1]] - 1))\n\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(int(1e6))\n\n\nclass BIT:\n\tdef __init__(self, n):\n\t\tself.n = n\n\t\tself.data = [0] * (n + 1)\n\n\tdef get_sum(self, i):\n\t\tret = 0\n\t\twhile i > 0:\n\t\t\tret += self.data[i]\n\t\t\ti -= (i & -i)\n\t\treturn ret\n\n\tdef add(self, i, w):\n\t\tif i == 0:\n\t\t\treturn\n\t\twhile i <= self.n:\n\t\t\tself.data[i] += w\n\t\t\ti += (i & -i)\n\ndef dfs(u, cnt):\n\tcnt += 1\n\tl[u] = cnt\n\tfor c in tree[u]:\n\t\tcnt = dfs(c, cnt)\n\tcnt += 1\n\tr[u] = cnt\n\treturn cnt\n\nn = int(input())\nl, r = [0] * n, [0] * n\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n\nbit = BIT(dfs(0, 1))\n\nq = int(input())\nfor _ in range(q):\n\tline = list(map(int, input().split()))\n\tif line[0]:\n\t\tprint(bit.get_sum(r[line[1]] - 1))\n\telse:\n\t\tbit.add(l[line[1]], line[2])\n\t\tbit.add(r[line[1]], -line[2])\n"
  },
  {
    "language": "Python",
    "code": "import sys\n \nsys.setrecursionlimit(int(1e6))\n \n \nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0] * (n + 1)\n \n    def get_sum(self, i):\n        ret = 0\n        while i > 0:\n            ret += self.data[i]\n            i -= (i & -i)\n        return ret\n \n    def add(self, i, w):\n        if i == 0:\n            return\n        while i <= self.n:\n            self.data[i] += w\n            i += (i & -i)\n \n \ndef dfs(u, cnt):\n    cnt += 1\n    l[u] = cnt\n    for c in tree[u]:\n        cnt = dfs(c, cnt)\n    cnt += 1\n    r[u] = cnt\n    return cnt\n \n \nn = int(input())\nl, r = [0] * n, [0] * n\ntree = [set(map(int, input().split()[1:])) for _ in range(n)]\n \nbit = BIT(dfs(0, 1))\n \nq = int(input())\nfor _ in range(q):\n    line = list(map(int, input().split()))\n    if line[0]:\n        print(bit.get_sum(r[line[1]] - 1))\n    else:\n        bit.add(l[line[1]], line[2])\n        bit.add(r[line[1]], -line[2])\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\nclass weightRtree:\n    def __init__(self, num):\n        self.num = num\n        self.weight = [0]*(num+1) \n      \n    def add(self, v, w):\n        if v == 0:\n            return 0\n        while v <= self.num:\n            self.weight[v] += w\n            v += (-v)&v    \n\n    def getSum(self, u):\n        temp = 0\n        while u > 0:\n            temp += self.weight[u]\n            u -= (-u)&u\n        return temp\n\nN = int(input())\nleft = [0]*N\nright = [0]*N\nTree = [set(map(int, input().split()[1:])) for i in range(N)]\n\ndef DFS(count, source):\n    count += 1\n    left[source] = count\n    for item in Tree[source]:\n        count = DFS(count, item)\n    count += 1\n    right[source] = count\n    return count\n\nObject = weightRtree(DFS(1, 0))\n\nQ = int(input())\nfor i in range(Q):\n    alist = list(map(int, input().split()))\n    if not alist[0]:\n        Object.add(left[alist[1]], alist[2])\n        Object.add(left[alist[1]], -alist[2])\n    else:\n        print(Object.getSum(right[alist[1]] - 1))\n\n\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# GRL_5_D: Tree - Range Query on Tree\n\n\nclass Edge:\n    __slots__ = ('v', 'w')\n\n    def __init__(self, v, w):\n        self.v = v\n        self.w = w\n\n    def either(self):\n        return self.v\n\n    def other(self, v):\n        if v == self.v:\n            return self.w\n        else:\n            return self.v\n\n\nclass Graph:\n    def __init__(self, v):\n        self.v = v\n        self._edges = [[] for _ in range(v)]\n\n    def add(self, e):\n        self._edges[e.v].append(e)\n        self._edges[e.w].append(e)\n\n    def adj(self, v):\n        return self._edges[v]\n\n    def edges(self):\n        for es in self._edges:\n            for e in es:\n                yield e\n\n\nclass RAQ:\n    \"\"\"Segment Tree\n    \"\"\"\n    def __init__(self, n, initial=0):\n        size = 1\n        while size < n:\n            size *= 2\n        self.size = 2*size - 1\n        self.data = [initial] * self.size\n\n    def add(self, i, j, v):\n        def _add(r, lo, hi):\n            if hi < i or lo > j:\n                return\n            elif i <= lo and hi <= j:\n                self.data[r] += v\n            else:\n                mid = lo + (hi - lo)//2\n                _add(r*2 + 1, lo, mid)\n                _add(r*2 + 2, mid+1, hi)\n\n        return _add(0, 0, self.size//2)\n\n    def get(self, i):\n        def _get(r, lo, hi, v):\n            v += self.data[r]\n            if lo == hi:\n                return v\n            mid = lo + (hi - lo)//2\n            if mid >= i:\n                return _get(r*2 + 1, lo, mid, v)\n            else:\n                return _get(r*2 + 2, mid+1, hi, v)\n\n        return _get(0, 0, self.size//2, 0)\n\n\nclass PathSum:\n    def __init__(self, graph, root):\n        self.seg = RAQ(graph.v * 2)\n        self._in = [0] * graph.v\n        self._out = [0] * graph.v\n        self.dfs(graph, root)\n\n    def dfs(self, graph, root):\n        visited = [False] * graph.v\n        stack = [root]\n        i = 0\n        while stack:\n            v = stack.pop()\n            if not visited[v]:\n                visited[v] = True\n                self._in[v] = i\n                i += 1\n                stack.append(v)\n                for e in graph.adj(v):\n                    w = e.other(v)\n                    if not visited[w]:\n                        stack.append(w)\n            else:\n                self._out[v] = i\n                i += 1\n\n    def add(self, v, val):\n        i = self._in[v]\n        j = self._out[v]\n        self.seg.add(i, j, val)\n\n    def get(self, v):\n        return self.seg.get(self._in[v])\n\n\ndef run():\n    n = int(input())\n    g = Graph(n)\n\n    for i in range(n):\n        k, *cs = [int(i) for i in input().split()]\n        if k > 0:\n            for j in cs:\n                g.add(Edge(i, j))\n\n    raq = PathSum(g, 0)\n    q = int(input())\n    for _ in range(q):\n        com, *args = [int(i) for i in input().split()]\n        if com == 0:\n            u, val = args\n            raq.add(u, val)\n        elif com == 1:\n            u, = args\n            print(raq.get(u))\n        else:\n            raise ValueError('invalid command')\n\n\nif __name__ == '__main__':\n    run()\n\n"
  },
  {
    "language": "Python",
    "code": "import sys\n\nsys.setrecursionlimit(200000)\n\n\nclass BIT(object):\n    def __init__(self, n: int) -> None:\n        self.n = n\n        self.data = [0] * (n + 1)\n\n    def get_sum(self, i: int) -> int:\n        ret = 0\n        while i > 0:\n            ret += self.data[i]\n            i -= (i & -i)\n        return ret\n\n    def add(self, i: int, w: int) -> None:\n        if i == 0:\n            return\n        while i <= self.n:\n            self.data[i] += w\n            i += (i & -i)\n\n\ndef dfs(u: int, cnt: int) -> int:\n    global left, right\n    cnt += 1\n    left[u] = cnt\n    for c in tree[u]:\n        cnt = dfs(c, cnt)\n    cnt += 1\n    right[u] = cnt\n    return cnt\n\n\nif __name__ == \"__main__\":\n    n = int(input())\n    left, right = [0] * n, [0] * n\n    tree = []\n    for _ in range(n):\n        _, *children = map(lambda x: int(x), input().split())\n        tree.append(set(children))\n\n    bit = BIT(dfs(0, 1))\n\n    q = int(input())\n    for _ in range(q):\n        query = list(map(lambda x: int(x), input().split()))\n        if query[0]:\n            print(bit.get_sum(right[query[1]] - 1))\n        else:\n            bit.add(left[query[1]], query[2])\n            bit.add(right[query[1]], -query[2])\n\n"
  },
  {
    "language": "Rust",
    "code": "macro_rules ! input { ( source = $ s : expr , $ ( $ r : tt ) * ) => { let mut iter = $ s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; ( iter = $ iter : ident , $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut $ iter = s . split_whitespace ( ) ; input_inner ! { $ iter , $ ( $ r ) * } } ; ( $ ( $ r : tt ) * ) => { let s = { use std :: io :: Read ; let mut s = String :: new ( ) ; std :: io :: stdin ( ) . read_to_string ( & mut s ) . unwrap ( ) ; s } ; let mut iter = s . split_whitespace ( ) ; input_inner ! { iter , $ ( $ r ) * } } ; }\nmacro_rules ! input_inner { ( $ iter : expr ) => { } ; ( $ iter : expr , ) => { } ; ( $ iter : expr , mut $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let mut $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , mut $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , mut $ var : usize $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident : $ t : tt $ ( $ r : tt ) * ) => { let $ var = read_value ! ( $ iter , $ t ) ; input_inner ! { $ iter $ ( $ r ) * } } ; ( $ iter : expr , $ var : ident $ ( $ r : tt ) * ) => { input_inner ! { $ iter , $ var : usize $ ( $ r ) * } } ; }\nmacro_rules ! read_value { ( $ iter : expr , ( $ ( $ t : tt ) ,* ) ) => { ( $ ( read_value ! ( $ iter , $ t ) ) ,* ) } ; ( $ iter : expr , [ $ t : tt ; $ len : expr ] ) => { ( 0 ..$ len ) . map ( | _ | read_value ! ( $ iter , $ t ) ) . collect ::< Vec < _ >> ( ) } ; ( $ iter : expr , { chars : $ base : expr } ) => { read_value ! ( $ iter , String ) . chars ( ) . map ( | c | ( c as u8 - $ base as u8 ) as usize ) . collect ::< Vec < usize >> ( ) } ; ( $ iter : expr , { char : $ base : expr } ) => { read_value ! ( $ iter , { chars : $ base } ) [ 0 ] } ; ( $ iter : expr , chars ) => { read_value ! ( $ iter , String ) . chars ( ) . collect ::< Vec < char >> ( ) } ; ( $ iter : expr , char ) => { read_value ! ( $ iter , chars ) [ 0 ] } ; ( $ iter : expr , usize1 ) => { read_value ! ( $ iter , usize ) - 1 } ; ( $ iter : expr , $ t : ty ) => { $ iter . next ( ) . unwrap ( ) . parse ::<$ t > ( ) . unwrap ( ) } ; }\npub trait Monoid {\n    type T: Clone + PartialEq;\n    fn mempty(&self) -> Self::T;\n    fn mappend(&self, x: &Self::T, y: &Self::T) -> Self::T;\n}\npub trait Group: Monoid {\n    fn invert(&self, x: &Self::T) -> Self::T;\n}\n#[derive(Clone, Debug)]\npub struct BinaryIndexedTree<M: Monoid> {\n    bit: Vec<M::T>,\n    monoid: M,\n}\nimpl<M: Monoid> BinaryIndexedTree<M> {\n    #[inline]\n    pub fn new(n: usize, monoid: M) -> BinaryIndexedTree<M> {\n        let bit = vec![monoid.mempty(); n + 1];\n        BinaryIndexedTree {\n            bit: bit,\n            monoid: monoid,\n        }\n    }\n    #[inline]\n    pub fn ident(&self) -> M::T {\n        self.monoid.mempty()\n    }\n    #[inline]\n    pub fn operate(&self, x: &M::T, y: &M::T) -> M::T {\n        self.monoid.mappend(x, y)\n    }\n    #[inline]\n    #[doc = \" 0-indexed [1, k)\"]\n    pub fn query(&self, k: usize) -> M::T {\n        let mut res = self.ident();\n        let mut k = k;\n        while k > 0 {\n            res = self.operate(&res, &self.bit[k]);\n            k -= k & !k + 1;\n        }\n        res\n    }\n    #[inline]\n    #[doc = \" 1-indexed\"]\n    pub fn update(&mut self, k: usize, x: M::T) {\n        assert!(k > 0);\n        let mut k = k;\n        while k < self.bit.len() {\n            self.bit[k] = self.operate(&self.bit[k], &x);\n            k += k & !k + 1;\n        }\n    }\n}\nimpl<G: Group> BinaryIndexedTree<G> {\n    #[inline]\n    pub fn invert(&self, x: &G::T) -> G::T {\n        self.monoid.invert(x)\n    }\n    #[inline]\n    #[doc = \" 0-indexed [l, r)\"]\n    pub fn query_section(&self, l: usize, r: usize) -> G::T {\n        self.operate(&self.invert(&self.query(l)), &self.query(r))\n    }\n    #[inline]\n    #[doc = \" 1-indexed\"]\n    pub fn get_val(&self, k: usize) -> G::T {\n        self.query_section(k - 1, k)\n    }\n    #[inline]\n    #[doc = \" 1-indexed\"]\n    pub fn set_val(&mut self, k: usize, x: G::T) {\n        let y = self.invert(&self.get_val(k));\n        let z = self.operate(&y, &x);\n        self.update(k, z);\n    }\n}\nimpl<M: Monoid> BinaryIndexedTree<M>\nwhere\n    M::T: Ord,\n{\n    #[doc = \" 1-indexed\"]\n    pub fn lower_bound(&self, x: M::T) -> (usize, M::T) {\n        let n = self.bit.len() - 1;\n        let mut acc = self.ident();\n        let mut pos = 0;\n        let mut k = 1 << format!(\"{:b}\", n).len();\n        while k > 0 {\n            if k + pos <= n && self.operate(&acc, &self.bit[k + pos]) < x {\n                pos += k;\n                acc = self.operate(&acc, &self.bit[pos]);\n            }\n            k >>= 1;\n        }\n        (pos + 1, acc)\n    }\n}\n#[derive(Clone)]\npub struct EdgeAttributeEulerTourBIT<'a, M: Monoid> {\n    bit: BinaryIndexedTree<M>,\n    euler: &'a EulerTourTree,\n}\nimpl<'a, G: Group> EdgeAttributeEulerTourBIT<'a, G> {\n    pub fn update_based_on_path(&mut self, eid: usize, x: G::T) {\n        let e = &self.euler.es[eid];\n        self.bit.update(e.l + 1, x.clone());\n        let y = self.bit.invert(&x);\n        self.bit.update(e.r + 1, y);\n    }\n    pub fn query_based_on_path(&self, u: usize) -> G::T {\n        self.bit.query(self.euler.es[self.euler.vs[u].p].l + 1)\n    }\n}\nimpl EulerTourTree {\n    pub fn gen_bit<'a, M: Monoid>(&'a self, monoid: M) -> EdgeAttributeEulerTourBIT<'a, M> {\n        EdgeAttributeEulerTourBIT {\n            bit: BinaryIndexedTree::new(self.etrace.len(), monoid),\n            euler: self,\n        }\n    }\n}\n#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]\npub struct Adjacent {\n    pub to: usize,\n    pub id: usize,\n}\nimpl Adjacent {\n    pub fn new(to: usize, id: usize) -> Adjacent {\n        Adjacent { to: to, id: id }\n    }\n}\n#[derive(Clone, Debug, Default)]\npub struct Graph {\n    pub vsize: usize,\n    pub esize: usize,\n    pub graph: Vec<Vec<Adjacent>>,\n}\nimpl Graph {\n    pub fn new(vsize: usize) -> Graph {\n        Graph {\n            vsize: vsize,\n            esize: 0,\n            graph: vec![vec![]; vsize],\n        }\n    }\n    pub fn add_edge(&mut self, from: usize, to: usize) {\n        self.graph[from].push(Adjacent::new(to, self.esize));\n        self.esize += 1;\n    }\n    pub fn add_undirected_edge(&mut self, u: usize, v: usize) {\n        self.graph[u].push(Adjacent::new(v, self.esize));\n        self.graph[v].push(Adjacent::new(u, self.esize));\n        self.esize += 1;\n    }\n    pub fn vertexes(&self) -> std::ops::Range<usize> {\n        0..self.vsize\n    }\n    pub fn adjacency(&self, from: usize) -> &Vec<Adjacent> {\n        &self.graph[from]\n    }\n}\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Vertex {\n    l: usize,\n    r: usize,\n    d: i64,\n    p: usize,\n}\n#[derive(Clone, Debug, Default, PartialEq, Eq, Hash)]\npub struct Edge {\n    l: usize,\n    r: usize,\n}\n#[derive(Clone, Debug, Default)]\npub struct EulerTourTree {\n    root: usize,\n    vs: Vec<Vertex>,\n    es: Vec<Edge>,\n    vtrace: Vec<usize>,\n    etrace: Vec<usize>,\n}\nimpl EulerTourTree {\n    pub fn new() -> Self {\n        Default::default()\n    }\n    fn euler_tour(&mut self, u: usize, p: usize, d: i64, graph: &Graph) {\n        self.vs[u].l = self.vtrace.len();\n        self.vs[u].d = d;\n        self.vtrace.push(u);\n        for a in graph.adjacency(u) {\n            if a.to != p {\n                self.es[a.id].l = self.etrace.len();\n                self.etrace.push(a.id);\n                self.euler_tour(a.to, u, d + 1, graph);\n                self.vtrace.push(u);\n                self.es[a.id].r = self.etrace.len();\n                self.etrace.push(a.id);\n                self.vs[a.to].p = a.id;\n            }\n        }\n        self.vs[u].r = self.vtrace.len() - 1;\n    }\n    pub fn build(&mut self, root: usize, graph: &Graph) {\n        let n = graph.vsize;\n        self.root = root;\n        self.vs = vec![Default::default(); n];\n        self.es = vec![Default::default(); n - 1];\n        self.vtrace.clear();\n        self.etrace.clear();\n        self.euler_tour(root, n, 0, graph);\n    }\n    pub fn vertex_in_range(&self, u: usize, v: usize) -> (usize, usize) {\n        let (mut l, mut r) = (self.vs[u].l, self.vs[v].l);\n        if l > r {\n            std::mem::swap(&mut l, &mut r);\n        }\n        (l, r + 1)\n    }\n    pub fn subtree_range(&self, u: usize) -> (usize, usize) {\n        (self.vs[u].l, self.vs[u].r + 1)\n    }\n}\n#[derive(Clone, Debug)]\npub struct AddGroup<T: Copy + std::ops::Add<Output = T> + std::ops::Neg<Output = T>> {\n    zero: T,\n}\nimpl<T: Copy + std::ops::Add<Output = T> + std::ops::Neg<Output = T>> AddGroup<T> {\n    pub fn new(zero: T) -> AddGroup<T> {\n        AddGroup { zero: zero }\n    }\n}\nimpl<T: Copy + std::ops::Add<Output = T> + std::ops::Neg<Output = T> + PartialEq> Monoid\n    for AddGroup<T>\n{\n    type T = T;\n    #[inline]\n    fn mempty(&self) -> T {\n        self.zero.clone()\n    }\n    #[inline]\n    fn mappend(&self, x: &T, y: &T) -> T {\n        *x + *y\n    }\n}\nimpl<T: Copy + std::ops::Add<Output = T> + std::ops::Neg<Output = T> + PartialEq> Group\n    for AddGroup<T>\n{\n    fn invert(&self, x: &T) -> T {\n        -*x\n    }\n}\nfn main() {\n    input! { iter=iter, n };\n    let mut graph = Graph::new(n);\n    let mut euler = EulerTourTree::new();\n    for u in 0..n {\n        input_inner! { iter, k, c: [usize; k] };\n        for &v in &c {\n            graph.add_undirected_edge(u, v);\n        }\n    }\n    euler.build(0, &graph);\n    let mut bit = euler.gen_bit(AddGroup::new(0i64));\n    input_inner! { iter, q };\n    for _ in 0..q {\n        input_inner! { iter, qty };\n        if qty == 0 {\n            input_inner! { iter, v, w: i64 };\n            let i = euler.vs[v].p;\n            bit.update_based_on_path(i, w);\n        } else {\n            input_inner! { iter, u };\n            let ans = if u == 0 {\n                0\n            } else {\n                bit.query_based_on_path(u)\n            };\n            println!(\"{}\", ans);\n        }\n    }\n}\n\n"
  }
]