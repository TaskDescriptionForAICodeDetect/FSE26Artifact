[
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#define M 10000000\n\nusing namespace std;\n\nint Prim(const vector< vector<int> >& data){\n  vector<bool> is_reached(data.size(), false);\n  vector<int> cost(data.size(), M);\n  int i, j, ans;\n\n  i = 0;\n  ans = 0;\n  cost[i] = 0;\n\n  while(i >= 0){\n    ans += cost[i];\n    is_reached[i] = true;\n\n    for(j=0; j<data[i].size(); ++j){\n      cost[j] = min(cost[j], data[i][j]);\n    }\n    for(i=-1, j=0; j<is_reached.size(); ++j){\n      if(!is_reached[j] && (i < 0 || cost[i] > cost[j])) i = j;\n    }\n  }\n  return ans;\n}\n\nint main(){\n  int n, m;\n  int a, b, c;\n  char dm;\n\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    vector< vector<int> > data(n, vector<int>(n, M));\n\n    cin >> m;\n    for(int i=0; i<m; ++i){\n      cin >> a >> dm >> b >> dm >> c;\n      c = c/100 - 1;\n      data[a][b] = c;\n      data[b][a] = c;\n    }\n\n    cout << Prim(data) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <climits>\n#include <vector>\n\n#define MAX_N 256\n\nusing namespace std;\ntypedef pair<int, pair<int, int> > edge;//cost, node, node\n\nint n, m;\nint parent[MAX_N];\nint rank[MAX_N];\n\nvoid uf_init(int n){\n\t\n\tfor(int i=0; i<n; ++i){\n\t\tparent[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\nint find(int x){\n\tif(parent[x] == x)\n\t\treturn x;\n\telse\n\t\treturn parent[x] = find(parent[x]);\n}\n\nvoid unite(int x, int y){\n\t\n\tx = find(x);\n\ty = find(y);\n\n\tif(x==y)\n\t\treturn;\n\t\n\tif(rank[x] < rank[y]){\n\t\tparent[x] = y;\n\t}\n\telse{\n\t\tparent[y] = x;\n\t\t\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\nbool is_same_group(int x, int y){\n\treturn find(x) == find(y);\n}\n\nint solve_krascal(const vector<edge> als){\n\n\tint res = 0;\n\tint cnt = 0;\n\t\n\tuf_init(n);\n\n\tfor(int i=0; (i<m && cnt<n-1); ++i){\n\t\t\n\t\tint a = als[i].second.first,\n\t\t\tb = als[i].second.second;\n\t\t\n\t\tif(!is_same_group(a, b)){\n\t\t\n\t\t\tres += als[i].first;\n\t\t\tunite(a, b);\n\t\t\tcnt++;\n\t\t}\n\t}\n\n\treturn res/100;\n}\n\n\nint main(){\n\n\twhile(cin >> n, n){\n\n\t\tvector<edge> als;\n\t\tcin >> m;\n\t\t\n\t\tint a, b, c;\n\t\tchar cm;\n\t\t\n\t\tfor(int i=0; i<m; ++i){\n\t\t\t\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tals.push_back(make_pair(c-100, make_pair(a, b)));\n\t\t}\n\n\t\tsort(als.begin(), als.end());\n\n\t\tcout << solve_krascal(als) << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\n\nconst int INF=1e9;\nint cost[100][100];\nbool used[100];\nint mincost[100];\nint N,M;\n\nint main(){\n    while(cin>>N,N){\n        cin>>M;\n        fill(cost[0],cost[0]+10000,INF);\n        fill(used,used+100,false);\n        fill(mincost,mincost+100,INF);\n\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            ((cin>>a).ignore()>>b).ignore()>>c;\n            c=c/100-1;\n            cost[a][b]=c;\n            cost[b][a]=c;\n        }\n\n        mincost[0]=0;\n        int res=0;\n\n        //prim\n        while(true){\n            int v=-1;\n            for(int i=0;i<N;i++)\n                if(!used[i]&&(v==-1||mincost[i]<mincost[v]))v=i;\n\n            if(v==-1)break;\n            used[v]=true;\n            res+=mincost[v];\n\n            for(int i=0;i<N;i++)\n                mincost[i]=min(mincost[i],cost[v][i]);\n        }\n\n        cout<<res<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include \"stdio.h\"\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge{\n    Edge(int t, int c)\n        : to(t), cost(c) {}\n\n    int to;\n    int cost;\n};\n\nbool visited[100];\nvector<Edge> G[100];\ntypedef pair<int, int> PII;\n\nint prim(int start){\n    int ans = 0;\n    fill(visited, visited+100, false);\n\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n\n    que.push(PII(0, start));\n    while (!que.empty()){\n        int cst = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        ans += cst;\n        for (int i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            que.push(PII(G[v][i].cost, G[v][i].to));\n        }\n    }\n\n    return ans;\n} \n\nint main(int argc, char const *argv[]){\n    int n, m;\n\n    while (cin>>n, n){\n        cin>>m;\n        for (int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            d = (d-100) / 100;\n            G[a].push_back(Edge(b, d));\n            G[b].push_back(Edge(a, d));\n        }\n\n        cout<<prim(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n//#define int long long\n#define range(i, a, b) for(int i = (a); i < (b); i++)\n#define rep(i, a) range(i, 0, a)\n#define all(a) (a).begin(),(a).end()\nusing namespace std;\nconst int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconst int MOD = 1000000007;\nconst long double EPS = 1e-8;\nusing vi = vector <int>;\nusing vvi = vector <vi>;\n\nclass unionFindTree {\nprivate:\n\tvector <int> tree;\n\tvector <int> rank;\n\npublic:\n\tunionFindTree() {}\n\n\tunionFindTree(int sz) {\n\t\ttree = vector <int> (sz);\n\t\trank = vector <int> (sz, 0);\n\t\tfor(int i = 0; i < tree.size(); i++)\n\t\t\ttree[i] = i;\n\t}\n\n\tunionFindTree(const unionFindTree &o) {\n\t\ttree = o.tree;\n\t\trank = o.rank;\n\t}\n\n\tunionFindTree &operator=(const unionFindTree &o) {\n\t\ttree = o.tree;\n\t\trank = o.rank;\n\t\treturn (*this);\n\t};\n\n\tint root(int x) {\n\t\treturn tree[x] == x ? x : tree[x] = root(tree[x]);\n\t}\n\n\tbool same(int a, int b) {\n\t\treturn root(a) == root(b);\n\t}\n\n\tvoid unite(int a, int b) {\n\t\ta = root(a);\n\t\tb = root(b);\n\t\tif(a == b)return;\n\n\t\tif(rank[a] < rank[b]) swap(a, b);\n\n\t\ttree[b] = a;\n\t\trank[a] += rank[a] == rank[b];\n\t}\n\n\tint size() {\n\t\treturn tree.size();\n\t}\n};\n\n\nclass Kruskal : public unionFindTree{\n\tprivate:\n\t\tstruct edge {\n\t\t\tint u, v, cost;\n\t\t\tbool operator< (const edge& e) const {\n\t\t\t\treturn cost < e.cost;\n\t\t\t}\n\t\t};\n\t\tvector <edge> es;\n\t\tint V;\n\n\tpublic:\n\t\tKruskal(int v, int e) : unionFindTree(v){\n\t\t\tV = v;\n\t\t\tes = vector <edge> (e);\n\t\t}\n\n\t\tvoid addEdge(int start, int end, int cost) {\n\t\t\tes.push_back({start, end, cost});\n\t\t}\n\n\t\tint execute() {\n\t\t\tsort(es.begin(), es.end());\n\t\t\tint res = 0;\n\t\t\tfor(int i = 0; i < es.size(); i++) {\n\t\t\t\tedge e = es[i];\n\t\t\t\tif(!same(e.u, e.v)) {\n\t\t\t\t\tunite(e.u, e.v);\n\t\t\t\t\tres += e.cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n};\n\n\nsigned main() {\n\tint n, m;\n\twhile (cin >> n >> m, n) {\n\t\tKruskal pear(n, m);\n\t\trep (i, m) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d, %d, %d\", &a, &b, &d);\n\t\t\td -= 100;\n\t\t\tpear.addEdge(a, b, d);\n\t\t}\n\t\tcout << pear.execute() / 100 << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 10e6\nint cost[100][100];\nbool used[100];\nint mincost[100];\nint n,m;\n\nint prim(){\n\tfor(int i=0;i<n;i++){\n\t\tmincost[i]=INF;\n\t\tused[i]=false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!used[i]&&(v==-1||mincost[i]<mincost[v])) v=i;\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tmincost[i]=min(mincost[i],cost[i][v]);\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint a,b,d,result;\n\tchar tem;\n\twhile(cin >> n,n){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j]=(i==j)?0:INF;\n\t\tcin >> m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> tem >> b >> tem >> d;\n\t\t\tcost[a][b]=cost[b][a]=d/100-1;\n\t\t}\n\t\tresult=prim();\t\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//Carden Lantern\n#include<bits/stdc++.h>\nusing namespace std;\n#define REP(i,n) for(int i=0; i<(int)n; ++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nstruct Edge{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight){}\n};\nbool operator<(const Edge &e, const Edge &f){\n  return e.weight!=f.weight ? e.weight>f.weight : e.src!=f.src ? e.src<f.src : e.dst<f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r=0){\n  int n=g.size();\n  Edges T;\n  Weight total=0;\n\n  vector<bool>visited(n);\n  priority_queue<Edge> Q;\n  Q.push(Edge(-1, r, 0));\n  while(!Q.empty()){\n    Edge e=Q.top(); Q.pop();\n    if(visited[e.dst])continue;\n    T.push_back(e);\n    total+=e.weight;\n    visited[e.dst]=true;\n    FOR(f, g[e.dst]) if(!visited[f->dst])Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main(){\n  int n, m;\n  while(true){\n    cin>>n;\n    if(n==0)break;\n    cin>>m;\n    Graph g(n);\n    REP(i,m){\n      int src, dst, weight;\n      scanf(\"%d,%d,%d\", &src, &dst, &weight);\n      g[src].push_back(Edge(src, dst, weight/100-1));\n      g[dst].push_back(Edge(dst, src, weight/100-1));\n    }\n    cout<<minimumSpanningTree(g).first<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(i=0;i<n;i++)\nstruct branch{\n\tint n1, n2, w;\n};\nbool f(branch i, branch j){\n\treturn (i.w > j.w);\n}\nint main(){\n\twhile (1){\n\t\tint n,i;\n\t\tchar c;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tvector <int> T(n);\n\t\tREP(i,n) T[i] = i;\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector <branch> S(m);\n\t\tREP(i,m) cin >> S[i].n1 >> c>>S[i].n2 >> c>>S[i].w;\n\n\t\tsort(S.begin(), S.end(),f);\n\n\t\tint a = 0;\n\t\twhile (S.size()){\n\t\t\tbranch tmp = S.back();\n\t\t\tS.pop_back();\n\t\t\tint b = T[tmp.n1], c = T[tmp.n2];\n\t\t\tif (b != c){\n\t\t\t\tREP(i,n)\n\t\t\t\t\tif (T[i] == c) T[i] = b;\n\t\t\t\ta += tmp.w / 100 - 1;\n\t\t\t}\n\t\t}\n\t\tcout << a << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\n\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for (int i = x; i < n; i++)\n#define OP(m) cout << m << endl\ntypedef long long ll;\ntypedef unsigned long long ull;\n\nint main()\n{\n\n    int n, m;\n    while (cin >> n, n)\n    {\n        cin >> m;\n        int M[n][n];\n        rep(i, n) rep(j, n) M[i][j] = 1e7;\n        rep(i, m)\n        {\n            char dot;\n            int a, b, c;\n            cin >> a >> dot >> b >> dot >> c;\n            M[a][b] = c;\n            M[b][a] = c;\n        }\n\n        int d[n], sum = 0;\n        rep(i, n) d[i] = 1e7;\n\n        d[0] = 0;\n        bool used[n] = {};\n\n        while (1)\n        {\n            int u = -1, minv = 1e7;\n\n            rep(i, n)\n            {\n                if (!used[i] && d[i] < minv)\n                {\n                    minv = d[i];\n                    u = i;\n                }\n            }\n            if (u == -1)\n                break;\n            used[u] = true;\n\n            sum += minv;\n            rep(i, n)\n            {\n                if (!used[i] && M[u][i] != 1e7 && d[i] > M[u][i])\n                    d[i] = M[u][i];\n            }\n        }\n        OP(sum / 100 - (n - 1));\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint n, m;\n\nstruct edge{ int to; int cost; };\nvector<edge> G[110];\nint mincost[110];\nint res = 0;\nbool used[110];//?????????????±???????????????????\n\nint prim(){\n\tfor (int i = 0; i < n; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, 0));\n\n\t//cout << '!' << que.size() << endl;\n\twhile (que.size()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\n\t\tif (used[v])continue;\n\n\t\tused[v] = 1;\n\n\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif (used[e.to])continue;\n\t\t\tif (mincost[e.to] > e.cost){\n\t\t\t\tmincost[e.to] = e.cost;\n\t\t\t\tque.push(P(e.cost, e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, n){\n\t\t//cout << mincost[i] << endl;\n\t\tres += mincost[i];\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (cin >> n&&n){\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tint a, b, c;\n\t\t\tchar k;\n\t\t\tcin >> a >> k >> b >> k >> c;\n\t\t\tG[a].push_back({ b, c });\n\t\t\tG[b].push_back({ a, c });\n\t\t}\n\t\tprim();\n\t\tint ans = 0;\n\t\tREP(i, n){\n\t\t\tcout << mincost[i] << endl;\n\t\t\tans += (mincost[i] / 100 - 1);\n\t\t}\n\t\tcout << ans + 1 << endl;\n\t\tREP(i, 110)G[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\ninline int to_int(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string to_str(T x) {ostringstream sout; sout << x; return sout.str();}\n\ntypedef long long ll;\n\nstruct edge{\n\tint to, from, cost;\n};\nint par[101], rank[101];\n\nvoid init(int n)\n{\n\t//初期化して、すべての要素を親にする\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\t//要素の親を辿って、根を見つける\n\t//グループである証\n\tif(par[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nbool same(int x, int y)\n{\n\t//同じグループに所属しているかどうか\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\t//同じグループならすでに結合している。\n\tif(x == y)\n\t{\n\t\treturn;\n\t}\n\t//高さがxのほうが大きい時は\n\t//yのグループをxにする。\n\t//逆もまたSIKARI\n\tif(rank[x] > rank[y])\n\t{\n\t\tpar[y] = x;\n\t}\n\telse\n\t{\n\t\tpar[x] = y;\n\t\t\n\t\t//同じ高さの時は、\n\t\t//xの高さを増やす。\n\t\tif(rank[x] == rank[y])\n\t\t{\n\t\t\trank[x]++;\n\t\t}\n\t}\n}\n\nbool comp(const edge &a, const edge &b)\n{\n\treturn a.cost < b.cost;\n}\n\nint main()\n{\n\tint n, m, c, total;\n\twhile(cin >> n, n)\n\t{\n\t\ttotal = 0;\n\t\tcin >> m;\n\n\t\tinit(n);\n\n\t\tedge dis[m];\n\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d,%d,%d\", &dis[i].from, &dis[i].to, &c);\n\t\t\tc /= 100; c--;\n\t\t\tdis[i].cost = c;\n\t\t}\n\t\tsort(dis, dis+m, comp);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tedge a = dis[i];\n\t\t\tif(!same(a.to, a.from))\n\t\t\t{\n\t\t\t\tunite(a.to, a.from);\n\t\t\t\ttotal += a.cost;\n\t\t\t}\n\t\t}\n\t\tcout << total << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//MST\n#include <iostream>\nusing namespace std;\n\nmain(){\n  while(1){\n    int n, m, a, b, c;\n    int W[100][100];\n    int dist[100];\n    bool mst[100];\n    \n    cin >> n;\n    if(n==0) break;\n    \n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tW[i][j]=10000000;\n      }\n    }\n    cin >> m;\n    for(int i=0;i<m;i++){\n      char temp;\n      cin >> a >> temp >>  b >> temp >> c;\n      W[a][b]=W[b][a]=c;\n    }\n\n    for(int i=0;i<n;i++) dist[i]=10000000;\n\n    mst[0]=true;\n    dist[0]=0;\n    int node=0;\n    int ans=0;\n    for(int count=1;count<=n;count++){\n      for(int i=0;i<n;i++){\n\tif(mst[i]==false){\n\t  if(W[node][i]!=10000000){\n\t    if(dist[i]>W[node][i]){\n\t      dist[i]=W[node][i]-100;\n\t    }\n\t  }\n\t}\n      }\n      int min=10000001;\n      int temp=node;\n      for(int i=0;i<n;i++){\n\tif(mst[i]==false){\n\t  if(min>dist[i]){\n\t    min=dist[i];\n\t    temp=i;\n\t  }\n\t}\n      }\n      mst[temp]=true;\n      ans+=dist[node];\n      node=temp;\n    }\n    cout << ans/100 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w > e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\n//????°???¨?????¨\n//Prim O(ElogV)\n//r????????°?????????????????????????±?\n//Edge??? bool operator<(const Edge &e)const { return w > e.w; } ????????????????????????\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n\tEdges T; Weight total = 0; vector<int> v(g.size());\n\tpriority_queue <Edge> q;\n\tq.emplace(-1, r, 0);\n\twhile (q.size()) {\n\t\tEdge e = q.top(); q.pop();\n\t\tif (v[e.d]) continue;\n\t\tv[e.d] = true;\n\t\ttotal += e.w; if (e.s != -1) T.emplace_back(e);\n\t\tfor (auto &f : g[e.d]) if (!v[f.d]) q.emplace(f);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].push_back(Edge(a, b, d));\n\t\t\tg[b].push_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = prim(g, 0);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> tree_size;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\ttree_size.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\ttree_size[i] = 1;\n\t\t}\n\t}\n\n\t//??¨???????????????\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\t//????????¨????±????????????????\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\t//a???????????¨??¨b???????????¨?????????\n\tvoid marge(int a, int b) {\n\t\tif (same(a, b)) return;\n\n\t\ttree_size[find(a)] += tree_size[find(b)];\n\t\tpar[find(b)] = par[find(a)];\n\t}\n\n\tvoid show_info() {\n\t\tfor (int i = 0; i < par.size(); i++) {\n\t\t\tcout << par[i] << \",\" << tree_size[i] << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\t//a???????????¨?????§??????\n\tint size(int a) {\n\t\treturn tree_size[find(a)];\n\t}\n\n\n};\n\nauto comp = [](pair<pair<int, int>, int > a, pair<pair<int, int>, int > b) {return a.second > b.second; };\npriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, decltype(comp) > que(comp);\nint N;\nint kraskal() {\n\tint sum = 0;\n\tUnionFind tree = UnionFind(N);\n\n\tfor (; tree.size(0) != N;) {\n\t\t//tree.show_info();\n\t\twhile (tree.same(que.top().first.first, que.top().first.second))\n\t\t\tque.pop();\n\n\t\ttree.marge(que.top().first.first, que.top().first.second);\n\t\tsum += que.top().second;\n\t}\n\n\treturn sum;\n}\n\nvoid q72() {\n\tint m;\n\tfor (; cin >> N >> m;) {\n\t\tfor (; !que.empty();) que.pop();\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s, t, c;\n\t\t\tchar tmp;\n\t\t\tcin >> s >> tmp >> t >> tmp >> c;\n\t\t\tque.push(make_pair(make_pair(s, t), c));\n\t\t}\n\t\tcout << kraskal() / 100 - N + 1 << endl;\n\t}\n}\n\nint main() {\n\tq72();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n);\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); ++i)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define MIN(p1,p2)          (((p1)<(p2))?(p1):(p2))\n#define MAX(p1,p2)          (((p1)>(p2))?(p1):(p2))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define mp                  make_pair\n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\n#define pf printf\n#define pr(n) do { cout << #n \" = \" << (n) << endl; } while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#endif\n\ntemplate <class _T1, class _T2>\nclass kruskal_branch {\npublic:\n    _T1 node1, node2;\n    _T2 weight;\n    kruskal_branch(_T1 n1, _T1 n2, _T2 w) : node1(n1), node2(n2), weight(w) {;}\n    bool operator> (const kruskal_branch<_T1, _T2> &p) const { return (weight > p.weight); }\n};\n\ntemplate <class _T1, class _T2>\nclass kruskal {\npublic:\n    typedef kruskal_branch<_T1,_T2> kruskal_branch_t;\n    typedef priority_queue<kruskal_branch_t, vector<kruskal_branch_t>, greater<kruskal_branch_t> > kruskal_queue_t;\n\nprivate:\n    int node_num;\n    kruskal_queue_t queue;\n    set<set<_T1> * > tree;\n    vector<set<_T1> * > node;\n    kruskal_queue_t mintree;\n\n    void free(void){\n        queue = kruskal_queue_t();\n        FOREACH(it, tree) delete (*it);\n        node.resize(0);\n    }\n    void print(void){\n        printf(\"[tree]\\n\");\n        FOREACH(it, tree){\n            printf(\"  tree[%p]\", *it);\n            set<_T1> *s = *it;\n            FOREACH(it2, *s) printf(\", %d\", *it2);\n            printf(\"\\n\");\n        }\n        printf(\"[node]\\n\");\n        REP(i, node_num){\n            set<_T1> *s = node[i];\n            printf(\"  node[%d] -> tree[%p]\", i, s);\n            FOREACH(it2, *s) printf(\", %d\", *it2);\n            printf(\"\\n\");\n        }\n        printf(\"\\n\");\n    }\n\npublic:\n    kruskal(int n) : node_num(n){ free(); }\n    ~kruskal(void){ free(); }\n    void branch_add(kruskal_branch_t &b){ queue.push(b); }\n    kruskal_queue_t &mintree_get(void){ return mintree; }\n\n    int solve(){\n        node.resize(node_num);\n\n        REP(i,node_num){\n            set<_T1> *s = new set<_T1>; s->insert(i);\n            tree.insert(node[i] = s);\n        }\n\n        for(; !queue.empty(); queue.pop()){\n            //print();\n\n            const kruskal_branch_t &b = queue.top();\n            pf(\"node1 = %d, node2 = %d, weight = %d\\n\", b.node1, b.node2, b.weight);\n            if(node[b.node1] != node[b.node2]){\n                mintree.push(b);\n                set<_T1> *newset = node[b.node1];\n                newset->insert(ALL(*node[b.node2]));\n                ITER(tree) it = tree.find(node[b.node2]);\n                if(it != tree.end()) tree.erase(it);\n\n                FOREACH(it, *newset){\n                    node[*it] = newset;\n                }\n            }\n        }\n        //print();\n        return 0;\n    }\n};\n\nint solve(int n, kruskal<int,int> &k){\n    k.solve();\n    kruskal<int,int>::kruskal_queue_t &mintree = k.mintree_get();\n\n    int total = 0;\n    for(; !mintree.empty(); mintree.pop()){\n        const kruskal<int,int>::kruskal_branch_t &b = mintree.top();\n        pf(\"node1 = %d, node2 = %d, weight = %d\\n\", b.node1, b.node2, b.weight);\n        total += b.weight;\n    }\n    return total;\n}\n\nint main(){\n    int n, m, a, b, r;\n    while(cin >> n, n){\n        kruskal<int,int> k(n);\n        cin >> m;\n        REP(i,m){\n            string s;\n            cin >> s;\n            sscanf(s.c_str(), \"%d,%d,%d\", &a, &b, &r);\n            kruskal<int,int>::kruskal_branch_t branch(a, b, r/100-1);\n            k.branch_add(branch);\n        }\n        cout << solve(n, k) << endl;;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define mp make_pair\n\nint n, m, vis[128];\nvector<pair<int, int> > g[128];\n\nint main() {\n    for (;;) {\n        scanf(\"%d\", &n);\n        if (n == 0) return 0;\n        rep (i, n) g[i].clear();\n        scanf(\"%d\", &m);\n        rep (i, m) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            g[a].push_back(mp(-(c/100-1), b));\n            g[b].push_back(mp(-(c/100-1), a));\n        }\n        memset(vis, 0, sizeof(vis));\n        priority_queue<pair<int, int> > q;\n        q.push(mp(0, 0));\n        int ans = 0;\n        while (!q.empty()) {\n            const pair<int, int> vv(q.top());\n            q.pop();\n            const int x = vv.second;\n            if (vis[x]) continue;\n            vis[x] = 1;\n            ans += -vv.first;\n            rep (i, g[x].size()) q.push(g[x][i]);\n        }\n        printf(\"%d\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vp;\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tcin >> m;\n\t\t\n\t\tvector<vp> g(n);\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tg[a].push_back(pii(c / 100, b));\n\t\t}\n\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tvector<bool> used(n);\n\t\tint ans = 0;\n\t\t\n\t\tqu.push(pii(1, 0));\n\t\twhile (! qu.empty()) {\n\t\t\tint cost = qu.top().first;\n\t\t\tint pos = qu.top().second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tif (used[pos]) continue;\n\t\t\tused[pos] = true;\n\t\t\t\n\t\t\tans += cost - 1;\n\t\t\t\n\t\t\tREP(i, g[pos].size()) {\n\t\t\t\tqu.push(pii(g[pos][i].first, g[pos][i].second));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cmath>\n\nusing namespace std;\nchar z;\nint n,m,mx=(1<<20),a,b,c,t,mn,hozon;\nint map[100][100];\nint p[100];\nint d[100];\nint visited[100];\nint main(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cin>>m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tmap[i][j]=mx;\n      }\n      p[i]=0;\n      d[i]=mx;\n      visited[i]=0;\n    }\n    \n    for(int i=0;i<m;i++){\n      cin>>a;\n      cin>>z;\n      cin>>b;\n      cin>>z;\n      cin>>map[a][b];\n      map[b][a]=map[a][b];\n    }\n    d[0]=0;\n    while(1){\n      mn=mx;\n      for(int i=0;i<n;i++){\n\tif(d[i]<mn&&visited[i]==0){\n\t  mn=d[i];\n\t  t=i;\n\t}\n      }\n      //cout<<t<<endl;\n      if(mn==mx)break;\n      visited[t]=1;\n      for(int v=0;v<n;v++){\n\tif(map[t][v]<d[v]&&visited[v]==0){\n\t  d[v]=map[t][v];\n\t  // cout<<d[v]<<endl;\n\t  p[v]=t;\n\t}\n      }\n    }\n    c=0;\n    for(int i=0;i<n;i++)if(d[i]!=mx)c+=d[i];\n    cout<<c/100-n+1<<endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n#define INF 1000000000\n#define MAX_V 102\n\n\n// UnionFind??¨\nclass UnionFindTree{\nprivate:\n  int parent[MAX_V];\n  int rank[MAX_V];\n  int find(int a);\npublic:\n  void init(int size);\n  void unite(int a, int b);\n  bool isSameTree(int a, int b);\n};\n\n// UF??¨????????????\nvoid UnionFindTree::init(int size){\n  for(int i = 0; i < size; i++){\n    parent[i] = i;\n    rank[i] = 0;\n  }\n  return; \n}\n\n// UF??¨?????????????????????\nint UnionFindTree::find(int a){\n  if(parent[a] == a){\n    return a;\n  }else{\n    return parent[a] = find(parent[a]); \n  }\n}\n\n// UF??¨??§???????????£?????????\nvoid UnionFindTree::unite(int a, int b){\n  int x = find(a);\n  int y = find(b);\n  if(x == y){ return; }\n\n  if(rank[x] < rank[y]){\n    parent[x] = y;\n  }else{\n    parent[y] = x;\n    if(rank[x] == rank[y]){ rank[x]++; }\n  }\n  return;\n}\n\n// UF??¨??§???????????????????????????????????????\nbool UnionFindTree::isSameTree(int a, int b){\n  return find(a) == find(b);\n}\n\n// ??????????????????\n// ?????°: ??????????????????????????????????????????????????\\???(first: ?????????, second: to-front), ????????°\n// ?????????: ??¨????????????\nint kruskal(priority_queue<pair<int, pair<int, int> > > edge, int v){\n  int length = 0;\n\n  // UF??¨?????£?¨???¨?????????\n  UnionFindTree uf;\n  uf.init(v);\n  \n  while(!edge.empty()){\n    // ????£????????????????????°?????????????????????????\n    int cost = edge.top().first;\n    int a = edge.top().second.first;\n    int b = edge.top().second.second;\n    edge.pop();\n    // ????????????????????????????????£????????????????£???°???\n    if(uf.isSameTree(a, b)){ continue; }\n\n    // UF??¨?????£??????????????????????????´??°\n    length += (-cost);\n    uf.unite(a, b);\n  }\n  \n  return length;\n}\n\nint main(void){\n  \n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n;\n    if(n == 0){ break; }\n    cin >> m;\n    \n    // ???????????±??????????????????????????????????????\\????????????\n    priority_queue<pair<int, pair<int, int> > > edge;\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      edge.push(make_pair(-d, make_pair(a, b)));\n    }\n  \n    // ????°???¨?????¨????????????????±???????\n    int length = kruskal(edge, n);\n\n    // ???????????????\n    cout << length / 100 - n + 1 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream> \n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef struct{\n\tint cost,v,u;\n}wa;\nwa way[10000];\nint par[200];\nint compare(const wa& a,const wa& b){\n\treturn a.cost<b.cost;\n}\nint find(int t){\n\tif(par[t]==t)\n\treturn t;\n\telse return find(par[t]);\n}\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tpar[y]=find(par[x]);\n}\nint main(){\n\tint n,m,ans,x,y,c;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\tans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&x,&y,&c);\n\t\t\tway[i].v=x;\n\t\t\tway[i].u=y;\n\t\t\tway[i].cost=c/100-1;\n\t\t}\n\t\tsort(way,way+m,compare);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpar[i]=i;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!same(way[i].v,way[i].u)){\n\t\t\tunite(way[i].v,way[i].u);\n\t\t\tans+=way[i].cost;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define INF 1e6\nusing namespace std;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\nint V;\n\nint prim(){\n\trep(i,V){mincost[i]=INF;used[i]=false;}\n\tmincost[0]=0;\n\tint res=0;\n\twhile(1){\n\t\tint v=-1;\n\t\trep(u,V)if(!used[u] && (v==-1 || mincost[u]<mincost[v]))v=u;\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tmincost[v]=0;\n\t\trep(u,V){\n\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint n,m,a,b,d;\n\twhile(cin>>n,n){\n\t\tV=n;\n\t\tcin>>m;\n\t\trep(i,V){\n\t\t\trep(j,V)cost[i][j]=cost[j][i]=INF;\n\t\t}\n\t\trep(i,m){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tcost[a][b]=cost[b][a]=d/100-1;\n\t\t}\n\t\tcout<<prim()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <stack>\n#include <queue>\n#include <cctype>\n#include <complex>\n#include <vector>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <functional>\n#include <cassert>\n#include <iomanip>\n\nusing namespace std;\n\n#define dump(x)  cout << \" \"<< #x << \" = \" << (x) << endl;\n#define pb push_back\ntypedef long long ll;\ntypedef complex<int> P;\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int INF = 1e+6;\n\n\nstruct st{\n\tint a, b;\n\tint d;\n\tst(){}\n};\n\n\nint prim(vector<bool>& used, vector<int>& mincost, vector<vector<int> >& cost, int V){\n\tfor(int i=0;i<V;i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0;u<V;u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tfor(int u=0;u<V;u++){\n\t\t\tmincost[u] = min(mincost[u], cost[u][v]);\n\t\t}\n\t}\n\treturn res;\n}\n\nbool solve(){\n\tint n;\n\tcin>> n;\n\tif(!n) return false;\n\t\n\tint m;\n\tcin>> m;\n\tvector<st> vst(m);\n\tfor(int i=0;i<m;i++){\n\t\tchar c1, c2;\n\t\tcin>> vst[i].a>> c1>> vst[i].b>> c2>> vst[i].d;\n\t\tvst[i].d = vst[i].d/100 -1;\n\t}\n\n\tvector<bool> used(m, false);\n\tvector<int> mincost(n, INF);\n\tvector<vector<int> > cost(n, vector<int>(n, INF));\n\tfor(int i=0;i<m;i++){\n\t\tint u = vst[i].a;\n\t\tint v = vst[i].b;\n\t\tint c = vst[i].d;\n\t\tcost[u][v] = c;\n\t\tcost[v][u] = c;\n\t}\n\t\n\tcout<< prim(used, mincost, cost, n)<< endl;\n\treturn true;\n}\n\nint main(){\n\tcout.setf(ios::fixed);\n\tcout.precision(10);\n\t\n\twhile(solve());\n\treturn 0;\n}\n\n "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<queue>\n#include <functional>\n#define MAX_V 1001\n#define INF 100000\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint n,m;\n\nint prim(){\n  for(int i=0;i<n;i++){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  mincost[0]=0;\n  int res=0;\n  while(true){\n    int v=-1;\n    for(int u=0;u<n;u++){\n      if(!used[u] && (v==-1 || mincost[u]<mincost[v]))v=u;\n    }\n    if(v==-1)break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=0;u<n;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int a,b,c,ans;\n  while(1){\n    cin >> n;\n    if(n == 0)break;\n    cin >> m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    ans = prim();\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef vector <int> vi;\n#define REP(i,n) for(i=0;i<n;i++)\n\nstruct branch{\n\tint n1,n2,w;\n};\nbool f(branch i, branch j){\n\treturn (i.w>j.w);\n}\nint main(){\n\twhile (1){\n\t\tint n,i;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int>T(n);\n\t\tREP(i,n)T[i]=i;\n\n\t\tbranch tmp;\n\t\tint m; cin>>m;\n\t\tvector<branch>S(m);\n\t\tREP(i,m) cin>>S[i].n1>>c>>S[i].n2>>c>>S[i].w;\n\t\tsort(S.begin(),S.end(),f);\n\n\t\tint a=0;\n\t\twhile(S.size()){\n\t\t\ttmp=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[tmp.n1],c=T[tmp.n2];\n\t\t\tif (b!=c){\n\t\t\t\tfor(i=0;i<n;i++)\n\t\t\t\t\tif(T[i]==c)T[i]=b;\n\t\t\t\ta+=tmp.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\n#define MAX_V 111\n#define INF (1<<21)\n\nint cost[MAX_V][MAX_V]={{0}};\nint mincost[MAX_V]={};\nbool used[MAX_V]={};\nint V;\n\n\nint prim(void);\nint min(int a,int b);\n\nint main(){\n  int m;\n  \n  scanf(\"%d\",&V);\n  \n  while(1){\n    if(V==0) break;\n    scanf(\"%d\",&m);\n    \n    \n    for(int i=0;i<m;i++){\n      for(int j=0;j<m;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    \n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b] = c/100 - 1;\n      cost[b][a] = c/100 - 1;\n    }\n    \n    printf(\"%d\\n\",prim());\n    \n    scanf(\"%d\",&V);\n  }\n  \n  return 0;\n}\n\nint min(int a,int b){\n  if(a>b) return b;\n  return a;\n}\n\nint prim(void){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(!used[u] && (v==-1 || mincost[u] <  mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for(int u = 0;u < V;u++){\n      //if(cost[v][u]==0);\n      //else{\n\tmincost[u] = min(mincost[u], cost[v][u]);\n\t//     }\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 100;\n\nstruct edge {\n\tint from_, to_, cost_;\n\tedge() = default;\n\tedge(int from, int to, int cost) :from_(from), to_(to), cost_(cost) {}\n\tbool operator<(const edge& rhs) const{\n\t\treturn (cost_ == rhs.cost_) ? to_ < rhs.to_ : cost_ < rhs.cost_;\n\t}\n};\n\nint n, m;\nstd::vector<edge> edges;\n\nclass Union {\n\tint par[MAX_N], rank[MAX_N];\npublic:\n\tUnion() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x])\n\t\t\treturn x;\n\t\tpar[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y])\n\t\t\tstd::swap(x, y);\n\t\tpar[y] = x;\n\t\trank[x] += rank[y];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (!n)\n\t\t\tbreak;\n\t\tstd::cin >> m;\n\t\tUnion uni;\n\t\tedges.clear();\n\t\tint a, b, d;\n\t\tchar ch;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> ch >> b >> ch >> d;\n\t\t\td /= 100;\n\t\t\t--d;\n\t\t\tedges.push_back(edge(a, b, d));\n\t\t}\n\n\t\tstd::sort(edges.begin(), edges.end());\n\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (!uni.same(edges[i].from_, edges[i].to_)) {\n\t\t\t\tuni.unite(edges[i].from_, edges[i].to_);\n\t\t\t\tans += edges[i].cost_;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n#include <cstdlib>\n\nusing namespace std;\n\n#define pb push_back\n#define mp make_pair\n#define rep(i,n) for(int i=0;i<(int)(n);++i)\n#define REP(i,j,k) for(int i=j;i<(int)(k);++i)\n#define foreach(i,c) for(__typeof(c.begin()) i=c.begin();i!=c.end();++i)\n#define all(x) (x).begin(),(x).end()\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef long long ll;\nconst int INF = 99999999;\nconst double EPS = 1e-9;\n\nstruct UnionFind\n{\n    vi par,rank;\n    UnionFind(int n){\n        par.resize(n),rank.resize(n,0);\n        rep(i,n) par[i]=i;\n    }\n\n    int find(int x){\n        return par[x]==x ? x : par[x]=find(par[x]);\n    }\n\n    void unite(int x, int y){\n        x=find(x),y=find(y);\n        if(x==y) return;\n        if(rank[x]<rank[y]){\n            par[x]=y;\n        }else{\n            par[y]=x;\n            if(rank[x]==rank[y]) rank[x]++;\n        }\n    }\n\n    bool same(int x, int y){\n        return find(x)==find(y);\n    }\n};\n\nstruct Edge\n{\n    int s,d,c;\n    Edge(int s, int d, int c) : s(s),d(d),c(c){}\n    bool operator<(const Edge &x) const{\n        return c < x.c;\n    }\n};\n\nint n,m,a,b,c;\n\nint main()\n{\n    while(cin>>n,n){\n        cin >> m;\n        vector<Edge> ve;\n\n        rep(i,m){\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            ve.pb(Edge(a,b,c));\n        }\n\n        UnionFind uf(n);\n        sort(all(ve));\n\n        int ans=0;\n        rep(i,ve.size()){\n            if(uf.same(ve[i].s,ve[i].d)) continue;\n            ans+=ve[i].c/100-1;\n            uf.unite(ve[i].s,ve[i].d);\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n#include<climits>\n#include<iostream>\n\n#define\tmp(a,b)\tmake_pair((a),(b))\n#define\tdis\t\tfirst\n#define\tnode\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tpair<int,pii>\tpipii;\n\nvector<int> mst;\n\nint UF_root(int i)\n{\n\tif(mst[i]==-1)\treturn i;\n\treturn mst[i]=UF_root(mst[i]);\n}\n\nbool UF_find(int i,int j)\n{\n\treturn UF_root(i)==UF_root(j);\n}\n\nvoid UF_union(int i,int j)\n{\n\tmst[UF_root(j)]=UF_root(i);\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tmst=vector<int>(n,-1);\n\n\t\tpriority_queue< pipii,vector<pipii>,greater<pipii> > pq;\n\t\tint m;\tcin>>m;\n\t\twhile(m--){\n\t\t\tint a,b,dis;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&dis);\n\t\t\tpq.push(mp(dis,mp(a,b)));\n\t\t}\n\n\t\tint total=0;\n\t\twhile(!pq.empty()){\n\t\t\tpipii path=pq.top();\tpq.pop();\n\t\t\tif(!UF_find(path.node.first,path.node.second)){\n\t\t\t\tUF_union(path.node.first,path.node.second);\n\t\t\t\ttotal+=path.dis/100-1;\n\t\t\t}\n\t\t}\n\n\t\tcout<<total<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main()\n{\n\twhile(1) {\n\t\tint n, m;\n\t\tint len[100][100];\n\t\tint Length[100];\n\t\tbool flag[100];\n\t\tint lantern = 0;\n\t\tint point = 0;\n\n\t\t// 初期化\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tfor(int j = 0; j < 100; j++) {\n\t\t\t\tlen[i][j] = -1;\n\t\t\t}\n\t\t\tLength[i] = -1;\n\t\t\tflag[i] = false;\n\t\t}\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcin >> m;\n\t\twhile(m-- > 0) {\n\t\t\tint from, to, L;\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &L);\n\t\t\tlen[from][to] = (L / 100) - 1;\n\t\t}\n\n\t\tflag[0] = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tLength[i] = len[0][i];\n\t\t}\n\n\t\twhile(1) {\n\t\t\tint min = -1;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(flag[i] == false && Length[i] > 0 && (min < 0 || Length[i] < min)) {\n\t\t\t\t\tmin = Length[i];\n\t\t\t\t\tpoint = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tflag[point] = true;\n\t\t\tlantern += Length[point];\n\n\t\t\tbool endflag = true;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(flag[i] == false) {\n\t\t\t\t\tendflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(endflag == true) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(flag[i] == false && len[point][i] > 0 && (Length[i] < 0 || len[point][i] < Length[i])) {\n\t\t\t\t\tLength[i] = len[point][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << lantern << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 10000;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tint a1, a2, a3;\n\t\tchar b1, b2;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tcin >> a1 >> b1 >> a2 >> b2 >> a3;\n\t\t\te.push_back(Edge{a1, a2, a3 / 100});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans - n + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint N, M;\nvector<P> g[100];\nbool done[100];\nint main()\n{\n  while(true)\n  {\n    fill(done, done + 100, 0);\n    for(int i = 0; i < 100; i++)\n      g[i].reset();\n    \n    cin >> N;\n    if(!N)\n      break;\n    cin >> M;\n\n    for(int i = 0; i < M; i++)\n    {\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      printf(\"%d %d %d \\n\", a, b, c);\n      c = c / 100 - 1;\n      g[a].push_back(make_pair(c, b));\n      g[b].push_back(make_pair(c, a));\n    }\n\n    priority_queue<P, vector<P>, greater<P>> q;\n    q.push(make_pair(0, 0));\n    int cost = 0;\n    while(q.size())\n    {\n      auto p = q.top(); q.pop();\n      if(done[p.second])\n        continue;\n      done[p.second] = true;\n      cost += p.first;\n      for(auto e: g[p.second])\n      {\n        if(done[e.second])\n          continue;\n        q.push(e);\n      }\n    }\n    cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge{\n  int to,cost;\n  edge(int t, int c){\n    to = t; cost = c;\n  }\n};\n\ntypedef vector<vector<edge> > AdjList;\n\n#define INF 1e+9\n\nint MinSpanningTree(AdjList g){\n\n  int n = g.size();\n  int res = 0;\n\n  vector<int> d(n,INF);\n  d[0] = 0;\n  vector<int> use(n,0);\n\n  while(1){\n    int v = -1;\n    for(int u=0;u<n;u++){\n      if( !use[u] and (v<0 or d[v] > d[u]))\n\tv = u;\n    }\n    if(v<0) break;\n    use[v] = 1;\n    res += d[v];\n    for(int i=0; i<g[v].size();i++)\n      d[ g[v][i].to ] = min( d[ g[v][i].to ], g[v][i].cost);\n  }\n  return res;\n}\n\nint main(){\n\n  while(1){\n    int n,m; cin >> n;\n    if(!n) break;\n    cin >> m;\n\n    AdjList g(n);\n    for(int i=0; i<m; i++){\n      int from,to,c;\n      //cin >> from >> to >> c;\n      scanf(\"%d,%d,%d\",&from,&to,&c);\n      g[from].push_back(edge(to,c/100 - 1));\n      g[to].push_back(edge(from,c/100 - 1));\n    }\n    int ans = MinSpanningTree(g);\n    cout << ans << endl;\n  }\n  \n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nstruct P {\n\tint from, to, cost;\n};\nint parent[10000];\nint root(int x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = root(parent[x]);\n}\nvoid unite(int x, int y) {\n\tx = parent[x];\n\ty = parent[y];\n\tparent[x] = y;\n}\nbool same(int x, int y) {\n\treturn root(x) == root(y);\n}\nbool operator<(P a, P b) {\n\treturn a.cost < b.cost;\n}\nbool operator>(P a, P b) {\n\treturn a.cost > b.cost;\n}\nint main() {\n\tint n, m;\n\twhile (cin >> n&&n != 0) {\n\t\tcin >> m;\n\t\tpriority_queue<P, vector<P>, greater<P>>p;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf_s(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tp.push(P{ a,b,c });\n\t\t}\n\t\tfor (int i = 0; i < n; i++) parent[i] = i;\n\t\tint d = 0,sum=0;\n\t\twhile (d != n - 1) {\n\t\t\tP t = p.top(); p.pop();\n\t\t\tif (!same(t.from, t.to)) {\n\t\t\t\tunite(t.from, t.to);\n\t\t\t\td++;\n\t\t\t\tsum += t.cost;\n\t\t\t}\n\t\t}\n\t\tsum /= 100;\n\t\tsum = sum - n + 1;\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <bitset>\n \n#define INPUT_FROM_FILE (0) \n#if INPUT_FROM_FILE\n#include <fstream>\n#endif\n\nclass UnionFindTree{\npublic:\n    std::vector<int> parent;\n    std::vector<int> rank;\n \n    UnionFindTree(int n){\n        parent.resize(n, 0);\n        rank.resize(n, 0);\n \n        for(int i = 0; i < n; i++){\n            parent[i] = i;\n        }\n        return;\n    }\n    ~UnionFindTree(){\n        return;\n    }\n \n    int find(int x){\n        if(parent[x] == x){\n            return x;\n        }\n        else{\n            return parent[x] = find(parent[x]);\n        }\n    }\n \n    void unite(int x, int y){\n        x = find(x);\n        y = find(y);\n \n        if(x == y){\n            return;\n        }\n \n        if(rank[x] < rank[y]){\n            parent[x] = y;\n        }\n        else{\n            parent[y] = x;\n            if(rank[x] == rank[y]){\n                rank[x]++;\n            }\n        }\n    }\n \n    bool is_same(int x, int y){\n        return find(x) == find(y);\n    }\n};\n\nclass Edge{\npublic:\n\tint from;\n\tint to;\n\tint cost;\n\n\tEdge(){\n\t\treturn;\n\t}\n\t~Edge(){\n\t\treturn;\n\t}\n};\n\nbool comp(const Edge &l, const Edge &r){\n\treturn l.cost < r.cost;\n}\n\nint main(int argc, char **argv){\n\tint n, m, a, b, d;\n\tchar tmp;\n\n#if INPUT_FROM_FILE\n\tstd::ifstream ifs(\"test.txt\");\n\t//FILE *fp = fopen(\"test.txt\", \"r\");\n#endif\n\n#if INPUT_FROM_FILE\n\twhile(ifs >> n){\n#else\n\twhile(std::cin >> n){\n#endif\n\t\tif(n == 0){ break; }\n\n#if INPUT_FROM_FILE\n\t\tifs >> m;\n#else\n\t\tstd::cin >> m;\n#endif\n\t\tUnionFindTree uft(n);\n\t\tstd::vector<Edge> edges(m);\n\t\tint min_cost = 0;\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n#if INPUT_FROM_FILE\n\t\t\tifs >> a >> tmp >> b >> tmp >> d;\n#else\n\t\t\tstd::cin >> a >> tmp >> b >> tmp >> d;\n#endif\n\t\t\tedges[i].from = a;\n\t\t\tedges[i].to = b;\n\t\t\tedges[i].cost = d;\n\t\t}\n\n\t\tstd::sort(edges.begin(), edges.end(), comp);\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tEdge &e = edges[i];\n\t\t\tif(!uft.is_same(e.from, e.to)){\n\t\t\t\tuft.unite(e.from, e.to);\n\t\t\t\tmin_cost += e.cost - 100;\n\t\t\t}\n\t\t}\n\n\t\tint num_tourou = min_cost / 100;\n\t\tstd::cout << num_tourou << std::endl;\n\t}\n\n\n \n#if INPUT_FROM_FILE\n\t//fclose(fp);\n#endif\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nint N,M;\nint par[100],_rank[100];\n\nstruct Way{\n\tint A,B,D;\n\tWay(){}\n\tWay(int _A,int _B,int _D){\n\t\tA=_A; B=_B; D=_D;\n\t}\n\tbool operator<(const Way &a)const{\n\t\treturn D<a.D;\n\t}\n};\n\nvoid Init(){\n\tfor(int i=0;i<N;i++) par[i] = i;\n}\n\nint Find(int x){\n\tif(par[x]==x) return x;\n\telse return par[x] = Find(par[x]);\n}\n\nbool Unite(int x,int y){\n\tint a = Find(x),\n\t\tb = Find(y);\n\tif(a==b) return false;\n\tif(_rank[a]>_rank[b]){\n\t\tpar[b] = par[a];\n\t}\n\telse{\n\t\tpar[a] = par[b];\n\t\tif(_rank[a]==_rank[b]) _rank[b]++;\n\t}\n\treturn true;\n}\n\nint main(){\n\tWay way[10000];\n\twhile(cin>>N,N){\n\t\tcin>>M;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tscanf(\"%d,%d,%d\",&way[i].A,&way[i].B,&way[i].D);\n\t\t}\n\t\tsort(way,way+M);\n\t\tint ans=0;\n\t\tInit();\n\t\tfor(int i=0;i<M;i++){\n\t\t\tif(Unite(way[i].A,way[i].B)==true){\n\t\t\t\tans += way[i].D/100-1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define  INF 999999999\n\n#ifdef Debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#else\n#define dump(x)\n#endif\n\nbool used[101];\nint mincost[101];\nint edge[101][101];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\trep(i,101)rep(j,101)edge[i][j]=INF;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar ch;\n\t\t\tcin>>a>>ch>>b>>ch>>c;\n\t\t\tedge[a][b]=edge[b][a]=c/100-1;\n\t\t}\n\t\trep(i,n){\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tmincost[0]=0;\n\t\tint res=0;\n\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\trep(u,n){\n\t\t\t\tif(used[u]==false && ( v==-1 || mincost[u]<mincost[v] ))\n\t\t\t\t\tv=u;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=true;\n\t\t\tres+=mincost[v];\n\n\t\t\trep(u,n){\n\t\t\t\tmincost[u]=min(mincost[u],edge[v][u]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <map>\n#define fr first\n#define sc second\n#define INF (2 << 28)\nusing namespace std;\n\ntypedef pair<int, int> iiP;\nstruct edge{\n  int to, cost; edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n}; \n\t\t\t      \nvector<vector<edge> > Graph;\n\nint n, m;\n\nvoid init(int n){\n  \n  Graph.resize(0), Graph.resize(n);\n\n}\n\nint Prim(){\n  \n  int ret = 0;\n  vector <int> used(n, 0); \n  priority_queue<iiP, vector<iiP>, greater<iiP> > que;\n  que.push(iiP(0, 0));\n  while(!que.empty()){\n    iiP p = que.top(); que.pop();\n    if(used[p.sc]++) continue;\n    ret += p.fr;\n    for(int i = 0; i < Graph[p.sc].size(); i++){\n      que.push(iiP(Graph[p.sc][i].cost, Graph[p.sc][i].to));\n    }\n  }\n  return ret;\n\n}\n\nint main(){\n  \n  while(cin >> n, n){\n    cin >> m;\n    init(n);\n\n    for(int i = 0; i < m; i++){\n      int a, b, c; scanf(\"%d, %d, %d\", &a, &b, &c);\n      Graph[a].push_back(edge(b, c/100));\n    }\n\n    cout << Prim() - n + 1 << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\n#define MAX_V 100\n#define INF INT_MAX / 2 - 1\n\nint cost[MAX_V][MAX_V];\nint mindis[MAX_V];\nbool used[MAX_V];\nint V;\n\nvoid printv(string name, int v[], int len) {\n\tcout << name << \" :\";\n\tfor (int i = 0; i < len; i++)\n\t\tcout << \" \" << v[i];\n\tcout << endl;\n}\n\nint prim() {\n\tfill_n(mindis, V, INF);\n\tfill_n(used, V, false);\n\n\tmindis[0] = 0;\n\tint res = 0;\n\n\twhile (1) {\n\t\tint v = -1;\n\t\tfor (int u = 0; u < V; u++)\n\t\t\tif (!used[u] && (v == -1 || mindis[u] < mindis[v]))\n\t\t\t\tv = u;\n\t\tif (v == -1)\n\t\t\tbreak;\n\t\tused[v] = true;\n\t\tif (mindis[v])\n\t\t\tres += mindis[v] / 100 - 1;\n\n\t\tfor (int u = 0; u < V; u++)\n\t\t\tmindis[u] = min(mindis[u], cost[v][u]);\n//\t\tprintv(\"mindis\", mindis, V);\n\t}\n\n\treturn res;\n}\n\nint main() {\n\twhile (1) {\n\t\tfor (int i = 0; i < MAX_V; i++)\n\t\t\tfill_n(cost[i], MAX_V, INF);\n\t\tcin >> V;\n\t\tif (V == 0) break;\n\n\t\tint E;\n\t\tcin >> E;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tint u, v, dis;\n\t\t\tscanf(\"%d,%d,%d\\n\", &u, &v, &dis);\n\t\t\tcost[u][v] = cost[v][u] = dis;\n\t\t}\n\t\tcout << prim() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main()\n{\n\twhile(1) {\n\t\tint n, m;\n\t\tint len[100][100];\n\t\tint Length[100];\n\t\tbool flag[100];\n\t\tint lantern = 0;\n\t\tint point = 0;\n\n\t\tfor(int i = 0; i < 100; i++) {\n\t\t\tfor(int j = 0; j < 100; j++) {\n\t\t\t\tlen[i][j] = -1;\n\t\t\t}\n\t\t\tLength[i] = -1;\n\t\t\tflag[i] = false;\n\t\t}\n\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\tcin >> m;\n\t\twhile(m-- > 0) {\n\t\t\tint from, to, L;\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &L);\n\t\t\tlen[from][to] = (L / 100) - 1;\n\t\t}\n\n\t\tflag[0] = true;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tLength[i] = len[0][i];\n\t\t}\n\n\t\twhile(1) {\n\t\t\tint min = -1;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(flag[i] == false && Length[i] != -1 && (min == -1 || Length[i] < min)) {\n\t\t\t\t\tmin = Length[i];\n\t\t\t\t\tpoint = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tflag[point] = true;\n\t\t\tlantern += Length[point];\n\n\t\t\tbool endflag = true;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(flag[i] == false) {\n\t\t\t\t\tendflag = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(endflag == true) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(flag[i] == false && len[point][i] != -1 && (Length[i] == -1 || len[point][i] < Length[i])) {\n\t\t\t\t\tLength[i] = len[point][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << lantern << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint INF = 1 << 29;\n\nint main(void)\n{\n\tint n,d;\n\tint path[100][100];\n\tint x,y,cost; // 飾り\n\tint used[100]; // 木に入ったか\n\tint mincost; // 最安値\n\tint minnum; // 安い点\n\tint ans;\n\n\tscanf(\"%d\", &n);\n\twhile(n != 0){\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tpath[i][j] = INF;\n\t\t\t}\n\t\t\tused[i] = 0;\n\t\t}\n\t\tused[0] = 1;\n\n\t\tscanf(\"%d\", &d);\n\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tscanf(\"%d,%d,%d\", &x, &y, &cost);\n\t\t\tpath[x][y] = cost;\n\t\t\tpath[y][x] = cost;\n\t\t}\n\t\tmincost = INF;\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(used[j]){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(path[j][k] < mincost){\n\t\t\t\t\t\t\tif(!used[k]){\n\t\t\t\t\t\t\t\tminnum = k;\n\t\t\t\t\t\t\t\tmincost = path[j][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (mincost - 100) / 100;\n\t\t\tused[minnum] = 1;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tscanf(\"%d\", &n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 100;\n\nstruct edge {\n\tint from_, to_, cost_;\n\tedge() = default;\n\tedge(int from, int to, int cost) :from_(from), to_(to), cost_(cost) {}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost_ < rhs.cost_;\n\t}\n};\n\nint n, m;\nstd::vector<edge> edges;\n\nclass Union {\n\tint par[MAX_N], rank[MAX_N];\npublic:\n\tUnion() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x])\n\t\t\treturn x;\n\t\tpar[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y])\n\t\t\tstd::swap(x, y);\n\t\tpar[y] = x;\n\t\trank[x] += rank[y];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (!n)\n\t\t\tbreak;\n\t\tstd::cin >> m;\n\t\tUnion uni;\n\t\tedges.clear();\n\t\tint a, b, d;\n\t\tchar ch;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> ch >> b >> ch >> d;\n\t\t\td /= 100;\n\t\t\t--d;\n\t\t\tedges.emplace_back(a, b, d);\n\t\t}\n\n\t\tstd::sort(edges.begin(), edges.end());\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (!uni.same(edges[i].from_, edges[i].to_)) {\n\t\t\t\tuni.unite(edges[i].from_, edges[i].to_);\n\t\t\t\tans += edges[i].cost_;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\n\nstruct Edge{\n    int a,b,d;\n    bool operator<(const Edge a)const{\n        return d<a.d;\n    }\n};\n\nint par[100],rank_[100];\n\nvoid init(int n){\n    for(int i=0;i<n;i++) par[i] = i, rank_[i] = 1;\n}\n\nint find(int x){\n    if(par[x]==x) return x;\n    return par[x] = find(par[x]);\n}\n\nbool unite(int _a,int _b){\n    int a = find(_a), b = find(_b);\n    if(a==b) return false;\n    if(rank_[a]>rank_[b]) par[b] = a;\n    else{\n        par[a] = b;\n        if(rank_[a]==rank_[b]) rank_[b]++;\n    }\n    return true;\n}\n\nint main(){\n    int N,M;\n    while(cin>>N,N){\n        init(N);\n        cin>>M;\n        Edge e[10000];\n        for(int i=0;i<M;i++) scanf(\"%d,%d,%d\",&e[i].a,&e[i].b,&e[i].d);\n        sort(e,e+M);\n        int ans = 0;\n        for(int i=0;i<M;i++){\n            if(unite(e[i].a,e[i].b)){\n                ans += e[i].d/100-1;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct UF{\n    int N;\n    int par[100],sz[100];\n    void init(int _N){\n        N=_N;\n        for(int i=0;i<N;i++){\n            par[i]=i;\n            sz[i]=1;\n        }\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        par[y]=x;\n        sz[x]+=sz[y];\n        sz[y]=0;\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\ntypedef pair<int,int>pr;\ntypedef pair<int,pr>ppr;\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        int M;\n        scanf(\"%d\",&M);\n        vector<ppr>V;\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            c=c/100-1;\n            V.push_back(ppr(c,pr(a,b)));\n        }\n        sort(V.begin(),V.end());\n\n        UF uf;\n        uf.init(N);\n        int ret=0;\n        for(int i=0;i<M;i++){\n            int a=V[i].second.first;\n            int b=V[i].second.second;\n            int c=V[i].first;\n            if(uf.same(a,b))continue;\n            uf.unite(a,b);\n            ret+=c;\n        }\n        printf(\"%d\\n\",ret);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_V 100\n#define INF 1e9\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];//集合Xからの辺の最小コスト\nbool used[MAX_V];//頂点iがXに含まれてるか\nint V;\n\nint prim(){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res=0;\n  while(true){\n    int v = -1;\n    \n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true; //頂点vをXに追加\n    res += mincost[v]; //円のコストを加える\n    for(int u=0;u<V;u++) mincost[u] = min(mincost[u],cost[v][u]);\n  }\n  return res;\n}\n\n\nint main(){\n  int E;\n  while(cin >> V){\n    if(V==0) break;\n    \n    cin >> E;\n    for(int i=0;i<E;i++){\n      for(int j=0;j<E;j++){\n        cost[i][j] = cost[j][i] = (i==j ? 0 : INF);\n      }\n    }\n\n    int a,b,dist;\n    char camma;\n    for(int i=0;i<E;i++){\n      cin >> a >> camma >> b >> camma >> dist;\n      a; b;\n      cost[a][b] = cost[b][a] = dist;\n    }\n    \n    int sum_of_costs = prim();\n    int lanterns = sum_of_costs/100 - (V - 1); \n    //n00mを100mで分割すると分割点はn-1個\n    cout << lanterns << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint n, m;\n\nstruct edge{ int to; int cost; };\nvector<edge> G[110];\nint mincost[110];\nint res = 0;\nbool used[110];//?????????????±???????????????????\n\nint prim(){\n\tfor (int i = 0; i < n; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, 0));\n\n\t//cout << '!' << que.size() << endl;\n\twhile (que.size()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\n\t\tif (used[v])continue;\n\n\t\tused[v] = 1;\n\n\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif (used[e.to])continue;\n\t\t\tif (mincost[e.to] > e.cost){\n\t\t\t\tmincost[e.to] = e.cost;\n\t\t\t\tque.push(P(e.cost, e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, n){\n\t\t//cout << mincost[i] << endl;\n\t\tres += mincost[i];\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (cin >> n&&n){\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tint a, b, c;\n\t\t\tchar k;\n\t\t\tcin >> a >> k >> b >> k >> c;\n\t\t\tG[a].push_back({ b, c });\n\t\t\tG[b].push_back({ a, c });\n\t\t}\n\t\tprim();\n\t\tint ans = 0;\n\t\tFOR(i,1, n){\n\t\t\tans += (mincost[i] / 100 - 1);\n\t\t\t//cout << ans << endl;\n\t\t}\n\t\tcout << ans << endl;\n\t\tREP(i, 110)G[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nvector<Edge> g[100000],rg[100000];\nconst int MAX_V = 105;\n//inf??§?????????\nvector<vector<ll>> cost;\nll mincost[MAX_V];\nbool used[MAX_V];\nll V;\nll prim(){\n  ll res = 0;\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  priority_queue<NODE> q;\n  q.push({0,0});\n  while(q.size()){\n    auto v = q.top();q.pop();\n    if(mincost[v.pos] == inf){\n      mincost[v.pos] = v.cost;\n      res += v.cost;\n      for(auto n : g[v.pos]){\n        q.push({n.to,n.cost});\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin >> n && n){\n    V = n;\n    cin >> m;\n    int a,b,c;\n    char d;\n    rep(i,m){\n      cin >> a >> d >> b >> d >> c;\n      g[a].push_back({b,c});\n      g[b].push_back({a,c});\n    }\n    ll ans = prim();\n    cout << ans/100-(n-1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n#define MAX_N 10001\n\nvector<pii> G[MAX_N];\n\nint prim(int n){        //n : ノード数\n    bool used[MAX_N];\n    int mincost[MAX_N];\n    \n    rep(i,n){\n        mincost[i]=INF;\n        used[i]=false;\n    }\n    mincost[0]=0;\n    int res=0;\n    \n    while(1){\n        int v=-1;\n        rep(u,n){\n            if(used[u]==false && ( v==-1 || mincost[u]<mincost[v] ))\n                v=u;\n        }\n        if(v==-1)break;\n        used[v]=true;\n        res+=mincost[v];\n        \n        rep(i,G[v].size()){\n            int u = G[v][i].first;\n            mincost[u] = min( mincost[u] , G[v][i].second);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int v,e;\n    while(cin>>v&&v){\n        cin>>e;\n        cin.ignore();\n        rep(i,e){\n            int u,v,d;\n            scanf(\"%d,%d,%d\",&u,&v,&d);\n            G[u].pb(pii(v,d/100-1));\n            G[v].pb(pii(u,d/100-1));\n        }\n        \n        cout<<prim(v)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint G[102][102];\nint NG[102][102];\nbool used[102];\nconst int INF=9999999;\nint main(){\n\tint n,m,ans=0;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tcin>>m;\n\tans=0;\n\tfor(int i=0;i<102;i++)for(int j=0;j<102;j++)G[i][j]=INF,used[i]=false,NG[i][j]=INF;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b,c;\n\t\tchar x;\n\t\tcin>>a>>x>>b>>x>>c;\n\t\tif(a==b){cout<<\"x\";return 0;}\n\t\tG[a][b]=c;\n\t}\n\tint u,v,a,b;\n\tused[0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tv=-1;\n\t\tfor(int j=0;j<n;j++)if(!used[j])v=1;\n\t\tif(v==-1)break;\n\t\tint mi=INF;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\tif(mi>G[j][k]&&used[j]==1&&used[k]==0)mi=G[j][k],a=j,b=k;\n\t\t\t}\n\t\t}\n\t\tused[b]=1;\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\t//for(int i=0;i<n;i++)cout<<used[i]<<\" \";cout<<endl;\n\t\tNG[a][b]=G[a][b];\n\t\tans+=G[a][b]-100;\n\t}\n//for(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<G[i][j]<<\" \";cout<<endl;}\n//\tfor(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<NG[i][j]<<\" \";cout<<endl;}\n\t//for(int i=0;i<n;i++)for(int j=0;j<n;j++)ans+=NG[i][j];\n\tcout<<ans/100<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define MAX 1000\n#define INF 1<<30\nusing namespace std;\nint V,E;\n\nstruct Pox\n{\n  int from,to,cost;\n  Pox(int from = -1,int to = -1,int cost = -1):from(from),to(to),cost(cost){}\n};\n\nbool cmp(const Pox& p1,const Pox& p2)\n{\n  return p1.cost < p2.cost;\n}\n\n\n\nint par[MAX+1];\n\nint find(int x)\n{\n  if(x == par[x])return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x != y)\n    par[x] = y;\n}\n\nbool same(int x,int y)\n{\n  return find(x) == find(y);\n}\n\nint kruskal(vector<Pox>& G)\n{\n  sort(G.begin(),G.end(),cmp);\n  int res = 0;\n  for(int i=0;i<G.size();i++)\n    {\n      Pox pox = G[i];\n      if(!same(pox.from,pox.to))\n\t{\n\t  unit(pox.from,pox.to);\n\t  res += pox.cost;\n\t}\n    }\n  return res;\n}\n \nint main(){\n   \n   \n  while(cin >> V && V){  \n    cin >> E;\n    vector<Pox> G;\n    for(int i=0;i<E;i++){\n      par[i] = i;\n      int from,to,Cost;\n      scanf(\"%d,%d,%d\",&from,&to,&Cost);\n      G.push_back(Pox(from,to,Cost));\n    }\n  \n    cout <<  kruskal(G)/100 - (V-1) << endl;\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define MAX_V 100\n#define INF (1<<21)\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\nint prim(){\n  for(int i = 0; i < V; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(1){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u = 0; u < V; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  while(1){\n    cin >> V;\n    if(V == 0) break;\n    for(int i = 0; i < V; i++){\n      for(int j = 0; j < V; j++){\n\tcost[i][j] = INF;\n      }\n    }\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int a, b, c;\n      char d, e;\n      cin >> a >> d >> b >> e >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    int t = prim();\n    t = t / 100 - m + 1;\n    cout << t << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define rep(i,n) FOR(i,0,n)\n#define dbg(x) cout<<#x<<\": \"<<(x)<<\"\\n\"\n\nusing namespace std;\n\nconst int MAX_N = 114514;\nconst int MAX_E = 114514;\nint n, m;\n\nstruct edge {\n    int u, v, cost;\n    edge() {}\n    edge(int a, int b, int c) {\n        u=a; v=b; cost=c;\n    }\n};\n\nedge es[MAX_E];\n\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\n\n//\n// Union-Find\n//\nint par[MAX_N], _rank[MAX_N];\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i; _rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if(par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x); y = find(y);\n    if(x == y) return ;\n\n    if(_rank[x] < _rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if(_rank[x] == _rank[y]) _rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\n\nint kruskal() {\n    sort(es, es+m, comp);\n    init(n);\n    int res = 0;\n    rep(i,m) {\n        edge e = es[i];\n        if(!same(e.u, e.v)) {\n            unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    cin>>m;\n    rep(i,m) {\n        int a,b,d;\n        scanf(\"%d,%d,%d\",&a,&b,&d);\n        es[i] = edge(a, b, d/100 - 1);\n    }\n    int res = kruskal();\n    cout << res << endl;\n}\n\nint main() {\n    while(cin>>n, n) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\nclass UnionFind {\n  vector<int> parent;\npublic:\n  UnionFind(int n) : parent(n) {\n    rep(i, n) parent[i] = i;\n  }\n\n  int root(int x) {\n    if(x == parent[x]) return x;\n    return parent[x] = root(parent[x]);\n  }\n\n  void unite(int x, int y) {\n    if(root(x) == root(y)) return;\n    if(root(x) < root(y)) {\n      parent[y] = root(x);\n    }else {\n      parent[x] = root(y);\n    }\n  }\n\n  bool is_same(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nint main() {\n  int n, m;\n  while(cin >> n && n) {\n    cin >> m;\n    UnionFind uf(n);\n    vector<IP> v;\n    rep(i, m) {\n      int a, b, c; char d, e;\n      cin >> a >> d >> b >> e >> c;\n      v.push_back(IP(c/100, P(a, b)));\n    }\n    sort(ALL(v));\n    int ans = 0;\n    rep(i, m) {\n      IP &e = v[i];\n      int c = e.first, a = e.second.first, b = e.second.second;\n      if(!uf.is_same(a, b)) {\n        uf.unite(a, b);\n        ans += c - 1;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint Kruskal(Graph& g,Edges& e)\n{\n\te.clear();\n\t\n\tUnionFind uf(g.size());\n\tmultiset<Edge> s;\n\trep(i,g.size())\n\t\trep(j,g[i].size())\n\t\t\ts.insert(g[i][j]);\n\t\n\tint res=0;\n\tforeach(i,s){\n\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n\t\t\tuf.Union(i->src,i->dst);\n\t\t\tres+=i->weight;\n\t\t\te.push_back(*i);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\n//ostream& operator<<(ostream& os,const vi& a)\n//{\n//\trep(i,a.size())\n//\t\tprintf(\"%d%s\",a[i],i==a.size()-1?\"\":\" \");\n//\treturn os;\n//}\n//\n////pair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n//pair<int, Edges> minimumSpanningForest(const Graph &g) {\n//  int n = g.size();\n//  UnionFind uf(n);\n//  //priority_queue<Edge> Q;\n//  priority_queue<Edge,vector<Edge>,greater<Edge> > Q;\n//  //rep(u, n) foreach(e, g[u]) if (u < e->dst) Q.push(*e);\n//  rep(u, n) foreach(e, g[u]) Q.push(*e);\n//  multiset<Edge> s;\n//  rep(i,g.size())rep(j,g[i].size())s.insert(g[i][j]);\n//  //puts(\"#s:\");\n//  //foreach(i,s)\n//  //  printf(\"%d %d %d\\n\",i->src,i->dst,i->weight);\n//\n//  //Weight total = 0;\n//  int total = 0;\n//  Edges F;\n//  //while (F.size() < n-1 && !Q.empty()) {\n//  //  Edge e = Q.top(); Q.pop();\n//  foreach(i,s){\n//    if(F.size()>=n)\n//    \tbreak;\n//    Edge e=*i;\n//    //if (uf.unionSet(e.src, e.dst)) {\n//    //  F.push_back(e);\n//    //  total += e.weight;\n//    //}\n//\tif(uf.Find(e.src)!=uf.Find(e.dst)){\n//\t\tuf.Union(e.src,e.dst);\n//\t\tF.push_back(e);\n//\t\ttotal+=e.weight;\n//\t}\n//  }\n//  //puts(\"#F:\");\n//  //rep(i,F.size())\n//  //  printf(\"%d %d %d\\n\",F[i].src,F[i].dst,F[i].weight);  \n//  //return pair<Weight, Edges>(total, F);\n//  return pair<int, Edges>(total, F);\n//}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\tEdges e;\n\t\tint sum=Kruskal(g,e);\n\t\t//cout<<sum/100-e.size()<<endl;\n\t\tcout<<sum<<endl;\n\t\t\n\t\t//cout<<minimumSpanningForest(g).first<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int,int> pii;\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a) (a).begin(),(a).end()\n#define pb emplace_back\n#define INF (1e9+1)\n\n#define MAX_N 10001\n\nvector<pii> G[MAX_N];\n\nint prim(int n){        //n : ノード数\n    bool used[MAX_N];\n    int mincost[MAX_N];\n    \n    rep(i,n){\n        mincost[i]=INF;\n        used[i]=false;\n    }\n    mincost[0]=0;\n    int res=0;\n    \n    while(1){\n        int v=-1;\n        rep(u,n){\n            if(used[u]==false && ( v==-1 || mincost[u]<mincost[v] ))\n                v=u;\n        }\n        if(v==-1)break;\n        used[v]=true;\n        res+=mincost[v];\n        \n        rep(i,G[v].size()){\n            int u = G[v][i].first;\n            mincost[u] = min( mincost[u] , G[v][i].second);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int v,e;\n    while(cin>>v&&v){\n        cin>>e;\n        cin.ignore();\n        rep(i,MAX_N)G[i].clear();\n        rep(i,e){\n            int u,v,d;\n            scanf(\"%d,%d,%d\",&u,&v,&d);\n            G[u].pb(pii(v,d/100-1));\n            G[v].pb(pii(u,d/100-1));\n        }\n        \n        cout<<prim(v)<<endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\nint par[10010], rk[10010];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trk[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x)return x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\n\tif (rk[x] < rk[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif (rk[x] == rk[y])rk[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tll u, v, cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\n\nedge es[10010];\nint n, m;\n\nll kruskal() {\n\tsort(es, es + m, comp);\n\tinit(n);\n\tll res = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tif(e.cost != 0)\n\t\t\tres += (e.cost) / 100 - 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tll a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tes[i].u = a, es[i].v = b, es[i].cost = d;\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\n\nint main(){\n\n\tint n,m,table[100][100],checkTable[100],fixed[100],count,num,tmp_min,min_index,a,b,dist;\n\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcheckTable[i] = 0;\n\t\t\tfor(int k = 0; k < n; k++)table[i][k] = 0;\n\t\t}\n\n\t\tscanf(\"%d\",&m);\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&dist);\n\t\t\ttable[a][b] = dist;\n\t\t\ttable[b][a] = dist;\n\t\t}\n\n\t\tcheckTable[0] = 1;\t//0?????????????°???¨?????¨??°??????????????????\n\t\tfixed[0] = 0;\n\t\tcount = 1,num = 0;\n\n\t\t//????°???¨?????¨??¢?????´?????????\n\t\twhile(count < n){\n\t\t\ttmp_min = 10000000;\n\n\t\t\t//????°???¨?????¨??¨?????°?????????????????????????????????????±???????\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(table[i][k] > 0 && checkTable[k] == 0 && table[i][k] < tmp_min){\n\t\t\t\t\t\ttmp_min = table[i][k];\n\t\t\t\t\t\tmin_index = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnum += (tmp_min/100)-1;\n\t\t\tcheckTable[min_index] = 1;\n\t\t\tfixed[count] = min_index;\n\t\t\tcount++;\n\t\t}\n\n\t\tprintf(\"%d\\n\",num);\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<map>\n#include<cmath>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n#define fr first\n#define sc second\n#define MAX 101\n#define INFTY 1000000000\nint cost[MAX][MAX];\nint min_cost[MAX];\nbool used[MAX];\nint n,m;\nint prim(){\n  int res = 0;\n  for(int i=0;i<n;i++){\n    min_cost[i] = INFTY;\n    used[i] = false;\n  }\n  min_cost[0] = 0;\n  while( true ){\n    int v = -1;\n    for(int u=0 ; u < n ; u++ ){\n      if( !used[u] && (v == -1 || min_cost[u] < min_cost[v]) ){\n        v = u;\n      }\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += min_cost[v];\n    for(int u=0 ; u < n ; u++ ){\n      min_cost[u] = min( min_cost[u] , cost[v][u] );\n    }\n  }\n  return res;\n}\nint main(){\n  while(cin >> n && n){\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n        cost[i][j] = INFTY;\n      }\n    }\n    cin >> m;\n    for(int i=0,a,b,c;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b] = cost[b][a] = (c-100)/100;\n    }\n    cout  << prim() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cctype>\n#include <utility>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nconst auto gcu = getchar_unlocked;\nconst auto pcu = putchar_unlocked;\n#define _T template <typename T>\n#define _HT template <typename H, typename... T>\n#define _il inline\n#define _in _il int in\n#define _sc _il bool scan\n_T T in(int c){T n=0;bool m=false;while(isspace(c)){c=gcu();}if(c=='-')m=true,c=gcu();\n\tdo{n=10*n+(c-'0'),c=gcu();}while(c>='0'&&c<='9');return m?-n:n;}\n_in() {return in<int>(gcu());}\n_T T scan(T &n){int c=gcu();return c==EOF?false:(n=in<T>(c),true);}\n_sc(char &c){c=gcu();gcu();return c!=EOF;}\n#ifdef _GLIBCXX_STRING\n_sc(string &s){int c;s=\"\";\n\tfor(;;){c=gcu();if(c=='\\n'||c==' ')return true;else if(c==EOF)return false;s+=c;}}\n#endif\n_HT _sc(H &h, T&&... t){return scan(h)&&scan(t...);}\n#define _vo _il void out\n#define _vl _il void outl\n_vo(bool b) {pcu('0'+b);}\n_vo(const char *s){while(*s)pcu(*s++);}\n_vo(char c){pcu(c);}\n#ifdef _GLIBCXX_STRING\n_vo(string s){for(char c:s)pcu(c);}\n#endif\n_T _vo(T n){static char buf[20];char *p=buf;if(n<0)pcu('-'),n*=-1;\n\tif(!n)*p++='0';else while(n)*p++=n%10+'0',n/=10; while (p!=buf)pcu(*--p);}\n_vl(){out('\\n');}\n#ifdef _GLIBCXX_VECTOR\n_T _vo(vector<T> &v){for(T &x:v)out(&x == &v[0]?\"\":\" \"),out(x);outl();}\n#endif\n_HT _vo(H&& h, T&&... t){out(h);out(move(t)...);}\ntemplate <typename... T> _vl(T&&... t){out(move(t)...);outl();}\n\ntemplate <typename T>\nusing V = vector<T>;\n\nstruct node {\n\tint n, w;\n\tbool operator < (const node &a) const { return w > a.w; }\n};\n\nstruct graph {\n\tV<V<node>> nodes;\n\n\tint prim() {\n\t\tint w = 0;\n\t\tV<bool> v(nodes.size());\n\t\tpriority_queue<node> q;\n\t\tq.push({0, 0});\n\t\twhile (!q.empty()) {\n\t\t\tnode n = q.top();\n\t\t\tq.pop();\n\t\t\tif (v[n.n])\n\t\t\t\tcontinue;\n\t\t\tw += n.w;\n\t\t\tv[n.n] = true;\n\t\t\tfor (node &i: nodes[n.n])\n\t\t\t\tq.push(i);\n\t\t}\n\t\treturn w;\n\t}\n};\n\nint main() {\n\tfor (int n; (n = in());) {\n\t\tgraph g;\n\t\tg.nodes.resize(n);\n\t\tfor (int m = in(); m; m--) {\n\t\t\tint a = in(), b = in(), d = in();\n\t\t\tg.nodes[a].push_back({b, d});\n\t\t\tg.nodes[b].push_back({a, d});\n\t\t}\n\t\toutl(g.prim() / 100 - n + 1);\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n\n\nclass union_find{\nprivate:\n  vector<int> parents;\n  vector<int> rank;\npublic:\n  union_find(int n){\n    parents.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      parents[i]=i;\n      rank[i]=0;\n    }\n  }\n  int find(int x){\n    if(parents[x]==x){\n      return x;\n    }else{\n      return parents[x]=find(parents[x]);\n    }\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]){\n      parents[x]=y;\n    }else{\n      parents[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n};\n\nstruct E{\n  int from,to,cost;\n};\nbool operator<(E a, E b){\n  return a.cost>b.cost;\n}\nint n;\nvector<vector<E>> edge;\n\nbool input(){\n  cin>>n;\n  if(n==0)return false;\n  int m;\n  cin>>m;\n  edge.clear();\n  edge.resize(n);\n  for(int i=0;i<m;i++){\n    int a,b,c;\n    char cc;\n    cin>>a>>cc>>b>>cc>>c;\n    edge[a].push_back(E{a,b,c});\n    edge[b].push_back(E{b,a,c});\n  }\n  return true;\n}\n\nint solve(){\n  priority_queue<E> que;\n  union_find uf(n);\n  for(int i=0;i<edge[0].size();i++){\n    que.push(edge[0][i]);\n  }\n  int ans =0;\n  while(!que.empty()){\n    E now = que.top();que.pop();\n    if(uf.same(now.from,now.to))continue;\n    uf.unite(now.from,now.to);\n    ans += now.cost/100-1;\n    for(int i=0;i<edge[now.to].size();i++){\n      que.push(edge[now.to][i]);\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n  while(input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct Kruskal {\n  Kruskal() {}\n  Kruskal(int n) {\n    init(n);\n  }\n\n  struct UnionFind {\n    vector<int> p, r;\n\n    UnionFind() {}\n    UnionFind(int size) {\n      init(size);\n    }\n\n    void init(int size) {\n      p.resize(size);\n      r.resize(size);\n      for (int i = 0; i < size; ++i) {\n        p[i] = i;\n        r[i] = 1;\n      }\n    }\n\n    int root(int x) {\n      if (p[x] == x)\n        return x;\n      else\n        return p[x] = root(p[x]);\n    }\n\n    void unite(int x, int y) {\n      x = root(x);\n      y = root(y);\n\n      if (x == y) return;\n\n      if (r[x] > r[y]) swap(x, y);\n      r[x] += r[y];\n      p[y] = x;\n    }\n\n    bool same(int x, int y) {\n      return root(x) == root(y);\n    }\n  };\n\n  struct edges {\n    edges() {}\n    edges(int u, int v, long long cost) : u(u), v(v), cost(cost) {}\n    bool operator<(const edges &e) const {\n      return cost < e.cost;\n    }\n\n    int u, v;\n    long long cost;\n  };\n\n  struct edge {\n    edge() {}\n    edge(int to, long long cost) : to(to), cost(cost) {}\n\n    int to;\n    long long cost;\n  };\n\n  vector<edges> E;\n  vector<vector<edge>> G;\n\n  void init(int n) {\n    G.resize(n + 1);\n  }\n\n  void add_edge(int u, int v, long long cost) {\n    E.push_back(edges(u, v, cost));\n  }\n\n  void make_graph(edges e) {\n    G[e.u].push_back(edge(e.v, e.cost));\n    G[e.v].push_back(edge(e.u, e.cost));\n  }\n\n  long long kruskal(int n) {\n    long long res = 0;\n    UnionFind uf(n + 1);\n\n    sort(E.begin(), E.end());\n    for (auto &e : E) {\n      if (!uf.same(e.u, e.v)) {\n        res += e.cost;\n        uf.unite(e.u, e.v);\n        make_graph(e);\n      }\n    }\n\n    return res;\n  }\n\n  long long kruskal() {\n    return kruskal(G.size());\n  }\n};\n\nint main() {\n  int n;\n\n  while (cin >> n, n) {\n    Kruskal G(n);\n\n    int m;\n    cin >> m;\n    for (int i = 0; i < m; ++i) {\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n\n      G.add_edge(a, b, c / 100 - 1);\n    }\n\n    cout << G.kruskal() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip> \n#include <complex> \n#include <string>\n#include <vector> \n#include <list>\n#include <deque> \n#include <stack> \n#include <queue> \n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm> \n#include <numeric> \n#include <typeinfo> \n#include <cstdio>\n#include <cstdlib> \n#include <cstring>\n#include <cmath>\n#include <climits> \n#include <ctime>\n\nusing namespace std;\n\nconst int INF=1000000;\nint cost[101][101];\nint mincost[101];\nbool used[101];\nint V;\nint prim(){\n\tint a;\n\tfor(a=0;a<=100;a++){\n\t\tused[a]=false;\n\t\tmincost[a]=INF;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tint u;\n\t\tfor(u=0;u<V;u++){\n\t\t\tif(!used[u] && (v==-1 || mincost[u]<mincost[v]))v=u;\n\t\t}\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tfor(u=0;u<V;u++){\n\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint a,b;\n\tint n;\n\tint ans;\n\twhile(1){\n\t\tfor(a=0;a<=100;a++){\n\t\t\tfor(b=0;b<=100;b++){\n\t\t\t\tcost[b][a]=INF;\n\t\t\t}\n\t\t\tcost[a][a]=0;\n\t\t}\n\t\tcin >> V;\n\t\tif(V==0)break;\n\t\tcin >> n;\n\t\tfor(a=0;a<n;a++){\n\t\t\tint c,d,e;\n\t\t\tscanf(\"%d,%d,%d\",&c,&d,&e);\n\t\t\tcost[c][d]=e/100-1;\n\t\t\tcost[d][c]=e/100-1;\n\t\t}\n\t\tans=prim();\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nstruct UF{\n    vector<int>par,sz;\n    int N;\n    UF(int _N){\n        N=_N;\n        par=sz=vector<int>(N,1);\n        for(int i=0;i<N;i++)par[i]=i;\n    }\n    int find(int x){\n        return x==par[x]?x:par[x]=find(par[x]);\n    }\n    void unite(int x,int y){\n        x=find(x);y=find(y);\n        if(x==y)return;\n        if(sz[x]<sz[y])swap(x,y);\n        par[y]=x;\n        sz[x]+=sz[y];\n    }\n    bool same(int x,int y){\n        return find(x)==find(y);\n    }\n};\n\nstruct edge{\n    int u,v,cost;\n    edge(int a,int b,int c):u(a),v(b),cost(c){}\n    edge(){}\n};\n\nbool operator<(const edge &a,const edge &b){\n    return a.cost<b.cost;\n}\n\nint n,m;\n\nvoid solve(){\n    vector<edge>es;\n    scanf(\"%d\",&m);\n    for(int i=0;i<m;i++){\n        int a,b,c;\n        scanf(\"%d,%d,%d\",&a,&b,&c);\n        es.push_back(edge(a,b,c/100-1));\n    }\n    sort(es.begin(),es.end());\n\n    UF uf(n);\n    int ans=0;\n\n    for(int i=0;i<m;i++){\n        edge &e=es[i];\n        if(uf.same(e.u,e.v))continue;\n        uf.unite(e.u,e.v);\n        ans+=e.cost;\n    }\n\n    printf(\"%d\\n\",ans);\n}\n\nint main(){\n    while(scanf(\"%d\",&n),n)solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nstruct edge { int u, v, cost; };\n\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost < e2.cost;\n}\n\n\nconst int MAX_N = 101;\nconst int MAX_E = 150;\nint par[MAX_N];\nint r[MAX_N];\n\nvoid init(int n) {\n  for ( int i = 0; i < n; i++ ) {\n    par[i] = i;\n    r[i] = 0;\n  }\n}\n\nint find(int x) {\n  if ( par[x] == x ) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x, int y ) {\n  x = find(x);\n  y = find(y);\n  if ( x == y ) return;\n\n  if ( r[x] < r[y] ) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if ( r[x] == r[y] ) r[x]++;\n  }\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\n\n\nedge es[MAX_E];\nint V, E;\n\nint kruskal() {\n  sort(es, es + E, comp);\n  init(V);\n  int res = 0;\n  for ( int i = 0; i < E; i++ ) {\n    edge e = es[i];\n    if ( !same(e.u, e.v) ) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while( cin >> V >> E, V ) {\n\n    for ( int i = 0; i < E; i++ ) {\n      char ch;\n      cin >> es[i].u >> ch >> es[i].v >> ch >> es[i].cost;\n    }\n  \n    int ans = kruskal();\n       cout << ((ans/100)-(V-1)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdlib.h>\n#define INF 0x7fffffff\n#define MAX_V 100\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V; // V<=100\n\nint prim(){\n  for( int i=0;i<V;++i ){\n    mincost[i]=INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while( true ){\n    int v=-1;\n    for( int u=0;u<V;u++ ){\n      if( !used[u] && (v==-1 || mincost[u] < mincost[v])) v=u;\n    }\n    if( v==-1 ) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for( int u=0;u<V;u++ )\n      mincost[u] = min( mincost[u], cost[v][u] );\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  string line;\n  char buf[256];\n\n  while(  cin >> V,V ){\n    cin >> m;\n    cout << \"V=\"<<V <<\" m=\"<<m<<endl;\n\n    int x,y;\n    int k;\n    for( int i=0;i<V;i++ )\n      for( int j=0;j<V;j++ )\n\tcost[i][j] = INF;\n    for( int i=0,j;i<m;i++ ){\n      cin >> line;\n      for( j=0;j<line.size();j++ ) buf[j] = line.at(j);\n      buf[j] = '\\0';\n      x = atoi( buf );\n      for( j=0; buf[j]!=',';j++ );\n      y = atoi( ++j+buf );\n      for( ; buf[j]!=',';j++ );\n      k = atoi( ++j+buf );\n      //      cout << x <<\"_\"<<y<<\"_\"<<k<< endl;\n      k = k/100 -1; // ÂÂÂUÂÃÂÂ\n      cost[x][y] = k;\n      cost[y][x] = k;\n    }\n    cout << prim() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = (1<<28);\nint n, m, mincost[100], cost[100][100];\nbool used[100];\n\nint prim(){\n    int res = 0;\n    while( true ){\n        int v = -1;\n        for(int i = 0; i < n; i++){\n            if( !used[i] && (v == -1 || mincost[i] < mincost[v] ) ){\n                v = i;\n            }\n        }\n        if( v == -1 ) break;\n        used[v] = true;\n        res += mincost[v];\n        for(int i = 0; i < n; i++){\n            mincost[i] = min(mincost[i], cost[v][i]);\n        }\n    }\n    return res;\n}\n\nint main(){\n    while( scanf(\"%d\", &n), n ){\n        scanf(\"%d\", &m);\n        for(int i = 0; i < n; i++){\n            mincost[i] = INF;\n            for(int j = 0; j < n; j++){\n                cost[i][j] = INF;\n            }\n            cost[i][i] = 0;\n            used[i] = false;\n        }\n        mincost[0] = 0;\n        for(int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            cost[a][b] = d/100-1;\n            cost[b][a] = d/100-1;\n        }\n        printf(\"%d\\n\", prim());\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nconst int INF=100000000;\nint main(){\n    int n,m;\n    while(cin>>n,n){\n        cin>>m;\n        int d[100],to[100];\n        bool f[100]={0};\n        fill(d,d+100,INF);\n        while(m--){\n            int a,b,c;\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            c=c/100-1;\n            if(d[a]>c){\n                d[a]=c;\n                to[a]=b;\n            }\n            if(d[b]>c){\n                d[b]=c;\n                to[b]=a;\n            }\n        }\n        int sum=0;\n        for(int i=0;i<n;i++){\n            if(!f[i]){\n                f[i]=true;\n                f[to[i]]=true;\n                sum+=d[i];\n            }\n        }\n        cout<<sum<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V;//??????\nint E;//???\nstruct edge { int from, to, cost; };\ntypedef std::pair<int, int> PP;\nstd::vector<edge> e;\nint Par[100000];\nint Rank[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (std::cin >> V&&V) {\n\t\tstd::cin >> E;\n\t\tint a, b, c;\n\t\tchar aa,bb;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tstd::cin >> a >>aa>> b >>bb>> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tstd::cout << kruskal()/100-V+1 << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nclass node{\npublic:\n  int num;\n};\n\nclass edge{\npublic:\n  node b,e;\n  int cost;\n};\n\nclass graph{\npublic:\n  vector<node> nodes;\n  vector<edge> edges;\n  int n;\n  int e;\n\n  void set(void){\n    nodes.clear();\n    edges.clear();\n    n = 0;\n    e = 0;\n  }\n\n  void Nadd(node a){\n    if(n==0){\n      nodes.push_back(a);\n      n++;\n    }else{\n      int i = 0;\n      while(nodes[i].num < a.num && i<n)i++;\n      nodes.insert(nodes.begin()+i,a);\n      n++;\n    }\n  }\n\n  void Eadd(edge a){\n    if(e==0){\n      edges.push_back(a);\n      e++;\n    }else{\n      int i = 0;\n      while(edges[i].cost < a.cost && i<e)i++;\n      edges.insert(edges.begin()+i,a);\n      e++;\n    }\n  }\n\n  bool Nexist(node a){\n    for(int i=0;i<n;i++){\n      if(a.num == nodes[i].num)return true;\n    }\n    return false;\n  }\n\n  graph prim(void){\n    graph res;\n    graph tmp;\n    tmp.set();\n    for(int i=0;i<e;i++)tmp.Eadd(edges[i]);\n\n    res.set();\n\n    if(!e)return res;\n    else{\n      res.Eadd(tmp.edges[0]);\n      res.Nadd(tmp.edges[0].b);\n      res.Nadd(tmp.edges[0].e);\n      edges.erase(tmp.edges.begin());\n      tmp.e--;\n\n      while(res.n < n){\n\tfor(int i=0;i<tmp.e;i++){\n\t  if(res.Nexist(tmp.edges[i].b) && !res.Nexist(tmp.edges[i].e)){\n\t    res.Eadd(tmp.edges[i]);\n\t    res.Nadd(tmp.edges[i].e);\n\t    tmp.edges.erase(tmp.edges.begin()+i);\n\t    tmp.e--;\n\t    i = 0;\n\t  }else if(!res.Nexist(tmp.edges[i].b) && res.Nexist(tmp.edges[i].e) ){\n\t    res.Eadd(tmp.edges[i]);\n\t    res.Nadd(tmp.edges[i].b);\n\t    tmp.edges.erase(tmp.edges.begin()+i);\n\t    tmp.e--;\n\t    i = 0;\n\t  }\n\t}\n      }\n      return res;\n    }\n    \n    return tmp;\n  }\n\n};\n\nint main(){\n  int n,m;\n  int ans;\n  graph map,prim;\n  node tmp;\n  edge tmp2;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    map.set();\n    for(int i=0;i<n;i++){\n      tmp.num = i;\n      map.Nadd(tmp);\n    }\n    map.n = n;\n    \n    cin >> m;\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&tmp2.b.num,&tmp2.e.num,&tmp2.cost);\n      map.Eadd(tmp2);\n    }\n    map.e = m;\n\n    prim = map.prim();   \n\n    ans = 0;\n    for(int i=0;i<prim.e;i++)ans += prim.edges[i].cost - 100;\n\n    cout << ans/100 << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<utility>\n#include<algorithm>\n#include<cstdlib>\n#include<string>\n\nusing namespace std;\n\n#define mp makepair\n\nint main(){\n  int n,m,k,l;\n  int a,b,c;\n  string data;\n  pair<int,pair<int,int> > p;\n  while(true){\n    cin>>n;\n    if(!n)break;\n    vector<pair<int,pair<int,int> > > nodes;\n    cin>>m;\n    int num[m],count=0;\n    for(int i=0;i<m;i++){\n      num[i] = i;\n      cin>>data;\n      a = atoi(data.substr(0,data.find(\",\")).c_str());\n      b = atoi(data.substr(data.find(\",\")+1,data.find(\",\",data.find(\",\")+1)).c_str());\n      c = atoi(data.substr(data.find(\",\",data.find(\",\")+1)+1).c_str());\n      p.first = c/100-1;\n      p.second.first = a;\n      p.second.second = b;\n      nodes.push_back(p);\n    }\n    sort(nodes.begin(),nodes.end());\n    for(int i=0;i<m;i++){\n      if (num[nodes[i].second.first]!=num[nodes[i].second.second]){\n\tk = min(num[nodes[i].second.first],num[nodes[i].second.second]);\n\tl = max(num[nodes[i].second.first],num[nodes[i].second.second]);\n\tcount+=nodes[i].first;\n\tfor(int j=0;j<m;j++)if(num[j]==l)num[j] = k;\n      }\n    }\n    cout<<count<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Prim\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <climits>\n#define MAX_N 200\nusing namespace std;\n\nint main(){\n\tint n, m;\n\tint from, to, d;\n\tint cost[MAX_N][MAX_N];\n\tint minCost[MAX_N];\n\tbool used[MAX_N];\n\tint ans;\n\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> m;\n\t\t// initialize\n\t\tfor (int y = 0; y < n; y++) {\n\t\t\tminCost[y] = INT_MAX;\n\t\t\tused[y] = false;\n\t\t\tfor (int x = 0; x < n; x++) {\n\t\t\t\tcost[y][x] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &d);\n\t\t\tcost[to][from] = cost[from][to] = d;\n\t\t\tcout << from << ',' << to << ',' << d << endl;\n\t\t}\n\t\tminCost[0] = 0;\n\t\tans = 100;\n\t\t// Prim\n\t\twhile (1) {\n\t\t\tint v = -1;\n\t\t\t// find minNode\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif(!used[i] && (v == -1 || minCost[i] < minCost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v == -1) { // all noses are used?\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused[v] = true;\n\t\t\tans += minCost[v] - 100;\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tminCost[i] = min(minCost[i], cost[v][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans / 100 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nint n;\nint s[100][100];\nbool b[100];\nbool c[100];\nint ans;\nint cc;\n\nvoid dfs(int x, int y, int sum) {\n  /*for (int i=0; i<n; i++) {\n    printf(\"%d \", b[i]);\n  }\n  printf(\"\\n\");*/\n  //printf(\"%d %d %d %d [%d %d %d %d]\\n\", x, y, sum, cc, c[0], c[1], c[2], c[3]);\n  if (s[x][y] && !b[y] && !c[y]) {\n    //printf(\"use %d-%d\\n\", x, y);\n    if (cc == n-1) {\n      //printf(\"%d\\n\", sum+s[x][y]);\n      ans = min(ans, sum+s[x][y]);\n    } else {\n      b[y] = true;\n      ++cc;\n      if (y < n-1) dfs(x, y+1, sum+s[x][y]);\n      else {\n        bool ct[n];\n        //printf(\"save %d %d %d %d\\n\", c[0], c[1], c[2], c[3]);\n        memcpy(ct, c, sizeof(bool)*n);\n        for (int i=0; i<n; i++) {\n          if (!c[i] && b[i]) {\n            c[i] = true;\n            //printf(\"check %d start\\n\", i);\n            dfs(i, 0, sum+s[x][y]);\n            //printf(\"check %d end\\n\", i);\n          }\n        }\n        //printf(\"revert %d %d %d %d\\n\", ct[0], ct[1], ct[2], ct[3]);\n        memcpy(c, ct, sizeof(bool)*n);\n      }\n      b[y] = false;\n      --cc;\n    }\n    //printf(\"unuse %d-%d\\n\", x, y);\n  }\n  if (y < n-1) dfs(x, y+1, sum);\n  else {\n    bool ct[n];\n        //printf(\"save %d %d %d %d\\n\", c[0], c[1], c[2], c[3]);\n    memcpy(ct, c, sizeof(bool)*n);\n    for (int i=0; i<n; i++) {\n      if (!c[i] && b[i]) {\n        c[i] = true;\n        //printf(\"check %d start\\n\", i);\n        dfs(i, 0, sum);\n        //printf(\"check %d end\\n\", i);\n      }\n    }\n        //printf(\"revert %d %d %d %d\\n\", ct[0], ct[1], ct[2], ct[3]);\n    memcpy(c, ct, sizeof(bool)*n);\n  }\n}\n\nint main() {\n  int m, x, y, z;\n\n  while (1) {\n    scanf(\"%d\", &n);\n    if (!n) break;\n    memset(b, 0, sizeof(bool)*n);\n    memset(c, 0, sizeof(bool)*n);\n    memset(s, 0, sizeof(int)*n*100);\n    scanf(\"%d\", &m);\n    for (int i=0; i<m; i++) {\n      scanf(\"%d,%d,%d\", &x, &y, &z);\n      s[x][y] = s[y][x] = z/100-1;\n    }\n    b[0] = true;\n    c[0] = true;\n    ans = INT_MAX;\n    cc = 1;\n    dfs(0, 0, 0);\n    printf(\"%d\\n\", ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <stdio.h>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <string>\n#include <ctype.h>\n#include <cstring>\n#include <cstdio>\n#include <sstream>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define ll long long\n//#define scanf scanf_s\n\nstruct edge{ int from, to, cost; };\nint par[105];\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tpar[y] = x;\n}\n\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tvector<edge> e;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tc = c/100 - 1;\n\t\t\tedge tmp = { a, b, c };\n\t\t\te.push_back(tmp);\n\t\t}\n\t\tsort(e.begin(), e.end(), comp);\n\n\t\tREP(i, 105) par[i] = i;\n\t\tint cost = 0;\n\t\tREP(i, e.size())\n\t\t{\n\t\t\tif (find(e[i].from) != find(e[i].to))\n\t\t\t{\n\t\t\t\tcost += e[i].cost;\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t}\n\t\t}\n\t\tcout << cost << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\nint main(){\n\tint a,b;\n\twhile(1){\n\t\ta=-1;\n\t\tint ret = 0;\n\t\tint data[100]={0};\n\t\twhile(cin >> a >> b && a || b){\n\t\t\ta--;b--;\n\t\t\tdata[a]++;\n\t\t\tdata[b]++;\n\t\t}\n\t\tfor(int i=0;i<100;i++){\n\t\t\tif(data[i]%2==1 && data[i]){\n\t\t\t\tret++;\n\t\t\t}\n\t\t}\n\t\tif(a==-1)return 0;\n\t\tcout << (ret>2?\"NG\":\"OK\") << endl;\n\t}\n\t\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 100;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tstring str;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tint abc[3] = {};\n\t\t\tcin >> str;\n\t\t\tint count = 0;\n\t\t\tfor(size_t i = 0; i != str.size(); ++i){\n\t\t\t\tif(str[i] == ',')\n\t\t\t\t\tcount++;\n\t\t\t\telse {\n\t\t\t\t\tabc[count] *= 10;\n\t\t\t\t\tabc[count] += str[i] - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*cout << abc[0] << endl;\n\t\t\tcout << abc[1] << endl;\n\t\t\tcout << abc[2] << endl;*/\n\t\t\te.push_back(Edge{abc[0], abc[1], abc[2] / 100 - 1});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define rep(i, n) for (int i = 0; i < (n); i++)\n#define REP(i, init, n) for (int i = init; i < (n); i++)\n\nusing namespace std;\nusing ll = long long int;\nusing P = pair<int, int>;\nusing T = tuple<int, int, int>;\nusing edge = struct\n{\n    int to, cost;\n};\n\nconst int MOD = 1e9 + 7;\nconst int iINF = 1e9;\nconst long long int llINF = 1e18;\nconst double PI = acos(-1.0);\n\nconst int dx[4] = {1, 0, -1, 0};\nconst int dy[4] = {0, 1, 0, -1};\n\nclass UnionFind\n{\n  private:\n    vector<int> par;\n    vector<int> sizes;\n\n  public:\n    UnionFind(int N) : par(N), sizes(N, 1)\n    {\n        rep(i, N) par[i] = i;\n    }\n\n    int find(int x)\n    {\n        if (x == par[x])\n            return x;\n\n        return par[x] = find(par[x]);\n    }\n\n    void unite(int x, int y)\n    {\n        x = find(x);\n        y = find(y);\n\n        if (x == y)\n            return;\n\n        if (sizes[x] < sizes[y])\n            swap(x, y);\n\n        par[y] = x;\n        sizes[x] += sizes[y];\n    }\n\n    bool same(int x, int y)\n    {\n        return find(x) == find(y);\n    }\n\n    int size(int x)\n    {\n        return sizes[find(x)];\n    }\n};\n\nint main()\n{\n    int N;\n\n    while (cin >> N, N)\n    {\n        vector<T> graph;\n\n        int M;\n        cin >> M;\n\n        rep(i, M)\n        {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n\n            graph.push_back(T{c / 100 - 1, a, b});\n        }\n\n        sort(graph.begin(), graph.end());\n\n        UnionFind uf(N);\n\n        int ans = 0;\n\n        for(auto e : graph)\n        {\n            int cost, from, to;\n            tie(cost, from, to) = e;\n\n            if(uf.same(from, to)) continue;\n\n            uf.unite(from, to);\n            ans += cost;\n        }        \n\n        cout << ans << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define MAX 100\n#define INFTY (1<<21)\nint G[MAX][MAX], n;\n\nvoid prim(){\n    int D[MAX], V[MAX], P[MAX], sum = 0;\n    rep(i, n) { D[i] = INFTY; V[i] = false; P[i] = -1; }\n    D[0] = 0;\n\n    while(1){\n\tint u, minv = INFTY;\n\trep(i, n) if ( !V[i] && minv > D[i]) { \n\t    minv = D[i], u = i; \n\t}\n\tif ( minv == INFTY ) break;\n\tV[u] = true;\n\tsum += G[u][P[u]];\n\trep(v, n){\n\t    if ( !V[v] && G[u][v] < D[v] ){\n\t\tD[v] = G[u][v];\n\t\tP[v] = u;\n\t    }\n\t}\n    }\n\n    cout << sum<< endl;\n}\n\nmain(){\n    int m, s, t, c;\n    char ch;\n    while( cin >> n >> m && n ){\n\trep(i, n) rep(j, n) G[i][j] = INFTY;\n\trep(i, m) {\n\t    cin >> s >> ch >> t >> ch >> c; \n\t    G[s][t] = G[t][s] = c/100-1;\n\t}\n\tprim();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int maxn = 110,maxm = 5500;\n#define inf 10000\n\nint cost[maxn][maxn]={};\nint mincost[maxn] = {};\nbool used[maxn] = {};\nint n,m,a,b,temp;\nchar t;\n\nint main()\n{\n\twhile(cin >> n && n)\n\t{\n\t\tcin >> m;\n\t\tmemset(cost, inf, sizeof(cost));\n\t\tmemset(mincost, inf, sizeof(mincost));\n\t\tmemset(used, false, sizeof(used));\n\t\tmincost[0] = 0;\n\t\t\n\t\tint ans = 0;\n\t\tREP(m)\n\t\t{\n\t\t\tcin >> a >> t >> b >> t >> temp;\n\t\t\tcost[a][b] = (temp/100)-1;\n\t\t\tcost[b][a] = cost[a][b];\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tint minv = n;\n\t\t\trep(i,n)if(!used[i] &&(minv == n ||mincost[i] < mincost[minv])) minv = i;\n\t\t\tif(minv == n) break;\n\n\t\t\tused[minv] = true;\n\t\t\tans += mincost[minv];\n\n\t\t\tREP(n) mincost[i] = min(mincost[i], cost[minv][i]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nint par[101];\nint rank[101];\nvoid init(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    rank[i]=1;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x]=find(par[x]);\n  }\n}\nvoid unit(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n  if(rank[x]<rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\nstruct edge{int u,v,cost;};\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost<e2.cost;\n}\nedge es[10001];\nint V,E;\nint kruskal(){\n  sort(es,es+E,comp);\n  init(V);\n  int res=0,cnt=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unit(e.u,e.v);\n      res+=e.cost;\n      cnt++;\n    }\n  }\n  return res/100-cnt;\n}\nint main(){\n  while(cin>>V,V){\n    cin>>E;\n    for(int i=0;i<E;i++)\n      scanf(\"%d,%d,%d\",&es[i].u,&es[i].v,&es[i].cost);\n    cout<<kruskal()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS 1\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <queue>\n#include <sstream>\n#include <climits>\n#include <cmath>\n#include <functional>\n#include <map>\n#include <stack>\nusing namespace std;\n#define M_PI 3.141592\n#define FOR(i,n) for(int i=0;i<(int)n;i++)\n#define FORI(i,k,n) for(int i=k;i<(int)n;i++)\n#define toRad 2.0*M_PI/360.0\n#define inin(x) int x;cin>>x;\n#define all(x) x.begin(),x.end()\n#define debug(x) cout<<#x<<\" \"<<x<<endl;\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define EPS 1e-12\n#define pri_max 60000\ntypedef pair<int, int> pii;\ntypedef pair<double, double> pdd;\nint dx[4] = { 0,1,0,-1 };\nint dy[4] = { 1,0,-1,0 };\n\n/*\nbool memo[pri_max] = {};\nvector<int> pri;\nvoid calc()\n{\n\tfor (int i = 2; i < pri_max; i++)\n\t{\n\t\tif (memo[i] == false)\n\t\t{\n\t\t\tpri.push_back(i);\n\t\t\tfor (int l = i; l < pri_max; l += i)\n\t\t\t{\n\t\t\t\tmemo[l] = true;\n\t\t\t}\n\t\t}\n\t}\n}*/\n\nint main()\n{\n\tint n;\n\twhile (cin >> n&&n)\n\t{\n\t\tvector< pii > v[10000];\n\t\tbool ch[10000] = {};\n\t\tint m; cin >> m;\n\t\tFOR(i, m)\n\t\t{\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tv[a].push_back(pii(d, b));\n\t\t\tv[b].push_back(pii(d, a));\n\t\t}\n\t\tch[0] = true;\n\t\tpriority_queue<pii,vector<pii>, greater<pii> > que;\n\t\tFOR(i, v[0].size())\n\t\t{\n\t\t\tque.push(v[0][i]);\n\t\t}\n\t\tint ans = 0;\n\t\twhile (!que.empty())\n\t\t{\n\t\t\tpii now = que.top(); \n\t\t\tque.pop();\n\t\t\tif (ch[now.second])continue;\n\t\t\tch[now.second] = true;\n\t\t\tans += now.first / 100 - 1;\n\t\t\tFOR(i, v[now.second].size())\n\t\t\t{\n\t\t\t\tque.push(v[now.second][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\nstruct EDGE\n{\n    int to, cost;\n    EDGE(int a, int b){\n        to = a;\n        to = b;\n    }\n    bool operator < (const EDGE& t) const {\n        return cost > t.cost;\n    }\n};\nvector<EDGE> v[100]; \nbool f[100];\nint search()\n{\n    int res = 0;\n    priority_queue<EDGE> que;\n    que.push(EDGE(0, 0));\n    while (!que.empty()){\n        EDGE e = que.top(); que.pop();\n        if (f[e.to]) continue;\n        f[e.to] = true;\n        res += e.cost;\n        rep(i, v[e.to].size()){\n            if (!f[v[e.to][i].to]){\n                que.push(v[e.to][i]);\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d\", &n), n){\n        scanf(\"%d\", &m);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            c = c / 100 - 1;\n            v[a].pb(EDGE(b, c));\n            v[b].pb(EDGE(a, c));\n        }\n        printf(\"%d\\n\", search());\n        memset(f, false, sizeof(f));\n        rep(i, n) v[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n\nstatic const int MAX = 100;\nstatic const int INF = (1<<21);\nint n, m;\nint M[MAX][MAX];\n\nint prim(){\n    int p[MAX], d[MAX], visit[MAX];\n\n    for(int i = 0; i < n; i++){\n        p[i] = -1;\n        d[i] = INF;\n        visit[i] = 0;\n    }\n\n    d[0] = 0;\n\n    while(true){\n        int minv = INF;\n        int next = -1;\n        for(int i = 0; i < n; i++){\n            if(minv > d[i] && visit[i] == 0){\n                minv = d[i];\n                next = i;\n            }\n        }\n\n        if(next == -1)  break;\n        visit[next] = 1;\n\n        for(int i = 0; i < n; i++){\n            if(M[next][i] != INF && visit[i] == 0 && d[i] > M[next][i]){\n                d[i] = M[next][i];\n                p[i] = next;\n            }\n        }\n    }\n    \n    int sum = 0;\n    for(int i = 0; i < n; i++){\n        if(p[i] != -1) sum += (M[p[i]][i]/100)-1;\n    }\n\n    return sum;\n}\n\nint main(){\n    while(1){\n        scanf(\"%d\\n\", &n);\n        if(n == 0)  break;\n\n        for(int i = 0; i < MAX; i++){\n            for(int j = 0; j < MAX; j++){\n                M[i][j] = INF;\n            }\n        }\n\n        scanf(\"%d\\n\" , &m);\n\n        int a, b, d;\n        for(int i = 0; i < m; i++){\n            scanf(\"%d,%d,%d\\n\", &a, &b, &d);\n            M[a][b] = M[b][a] = d;\n        }\n\n        cout << prim() << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost + n,numeric_limits<int>::max());\n\n\n\t\tint** cost = new int*[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcost[i] = new int[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcost[i][j]=numeric_limits<int>::max();\n\t\t\t}\n\t\t}\n\n\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from,to,dist;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&dist);\n\t\t\tcost[from][to] = min(cost[from][to],dist / 100 - 1);\n\t\t}\n\n\t\tmincost[0]=0;\n\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!used[i] && (v==-1 || mincost[i] < mincost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(used[i]){\n\t\t\t\t\tmincost[v] = min(mincost[v],cost[i][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tused[v] = true;\t\n\t\t\tres+=mincost[v];\n\t\t}\n\n\t\tcout << res << endl;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdelete[] cost[i];\n\t\t}\n\n\t\tdelete[] cost;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_M = MAX_N * MAX_N;\nint par[MAX_N];\nint myrank[MAX_N];\nint n,m;\n\n\nstruct edge {\n    int a, b, d;\n\n    bool operator <(const edge& r) {\n      return d < r.d;\n    }\n};\narray<edge, MAX_M> e;\n\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init() {\n  for (int i = 0; i < MAX_N; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) {\n    return;\n  }\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n}\n\n// x,y????±?????????????????????????????????????\nint same(int x, int y) {\n  return find(x) == find(y);\n}\n\nint main() {\n  int count ,t ;\n\n  while (cin >> n, n){\n    cin >> m;\n    init();\n\n    t = 0;\n    count = 0;\n    for(int i = 0; i < m; i ++){\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n    }\n\n    sort(e.begin(), e.begin() + n);\n    while(count != n-1) {\n      for (int i = 0; i < n; ++i) {\n        if(same(e[i].a,e[i].b) != 1) {\n          count++;\n          t = t + (int) e[i].d /100 - 1;\n          unite(e[i].a,e[i].b);\n        }\n      }\n      cout << t<<endl;\n    }\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include \"stdio.h\"\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge{\n    Edge(int t, int c)\n        : to(t), cost(c) {}\n\n    int to;\n    int cost;\n};\n\nbool visited[100];\nvector<Edge> G[100];\ntypedef pair<int, int> PII;\n\nint prim(int start){\n    int ans = 0;\n    fill(visited, visited+100, false);\n\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n\n    que.push(PII(0, start));\n    while (!que.empty()){\n        PII p = que.top();\n        int v = p.second;\n        int cst = p.first;\n        que.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        ans += cst;\n        for (int i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            if (!visited[e.to]){\n                que.push(PII(e.cost, e.to));\n            }\n        }\n    }\n\n    return ans;\n} \n\nint main(int argc, char const *argv[]){\n    int n, m;\n\n    while (cin>>n, n){\n        cin>>m;\n        for (int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            d = (d-100) / 100;\n            G[a].push_back(Edge(b, d));\n            G[b].push_back(Edge(a, d));\n        }\n\n        cout<<prim(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\n\n#define N 200\nclass UnionFind {\n  int parent[N];\npublic:\n  UnionFind(int n) {\n    rep(i, n) parent[i] = i;\n  }\n\n  int root(int x) {\n    if(x == parent[x]) return x;\n    return parent[x] = root(parent[x]);\n  }\n\n  void unite(int x, int y) {\n    if(root(x) == root(y)) return;\n    if(root(x) < root(y)) {\n      parent[y] = root(x);\n    }else {\n      parent[x] = root(y);\n    }\n  }\n\n  bool is_same(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nint main() {\n  int n, m;\n  while(cin >> n && n) {\n    cin >> m;\n    UnionFind uf(n);\n    vector<IP> v;\n    rep(i, m) {\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      v.push_back(IP(c/100, P(a, b)));\n    }\n    sort(ALL(v));\n    int ans = 0;\n    rep(i, m) {\n      IP &e = v[i];\n      int c = e.first, a = e.second.first, b = e.second.second;\n      if(!uf.is_same(a, b)) {\n        uf.unite(a, b);\n        ans += c - 1;\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct LINE {\n\tint a;\n\tint b;\n\tint d;\n\tbool use;\n};\n\nvector<int> getconnect(vector<LINE> &lines,int n)\n{\n\tvector<int>\tr;\n\tfor(int i=0;i<lines.size();i++){\n\t\tif( lines[i].a != lines[i].b && (lines[i].a==n || lines[i].b==n) ){\n\t\t\tr.push_back(i);\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\n\tint n,m;\n\tcin >> n >> m;\n\tvector<LINE> lines;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tLINE l;\n\t\tchar c;\n\t\tcin >> l.a >> c >> l.b >> c >> l.d;\n\t\tl.use=false;\n\t\tlines.push_back(l);\n\t}\n\n\twhile( true ){\n\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tauto idxs=getconnect(lines,i);\n\t\t\tif( idxs.empty() ) continue;\n\n\t\t\tcount++;\n\t\t\t\n\t\t\tint mini = idxs[0];\n\t\t\tint mind = lines[mini].d;\n\t\t\tfor(int idx : idxs){\n\t\t\t\tif( lines[idx].d < mind ){\n\t\t\t\t\tmini = idx;\n\t\t\t\t\tmind = lines[idx].d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint t = lines[mini].a!=i?lines[mini].a:lines[mini].b;\n\t\t\t\n\t\t\tauto idxs2=getconnect(lines,t);\n\t\t\tfor(int idx : idxs2){\n\t\t\t\tif( lines[idx].a==t){\n\t\t\t\t\tlines[idx].a = i;\n\t\t\t\t}\n\t\t\t\tif( lines[idx].b==t){\n\t\t\t\t\tlines[idx].b = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlines[mini].use=true;\n\t\t}\n\t\tif( count==0) break;\n\t\tcount=0;\n\t}\n\n\tint ans=0;\n\tfor( auto l : lines){\n\t\tif( l.use){\n\t\t\tans += l.d/100-1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_V 100\n#define INF 1e9\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint V;\n\nint prim(){\n  int mincost[MAX_V];\n  bool used[MAX_V];\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res=0;\n  while(true){\n    int v = -1;\n    \n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true; //頂点vをXに追加\n    res += mincost[v]; //コストを加える\n    for(int u=0;u<V;u++) mincost[u] = min(mincost[u],cost[v][u]);\n  }\n  return res;\n}\n\n\nint main(){\n  int E;\n  while(cin >> V){\n    if(V==0) break;\n    cin >> E;\n    for(int i=0;i<E;i++){\n      for(int j=0;j<E;j++){\n        cost[i][j] = cost[j][i] = (i==j ? 0 : INF);\n      }\n    }\n\n    int a,b,dist;\n    char camma;\n    for(int i=0;i<E;i++){\n      cin >> a >> camma >> b >> camma >> dist;\n      a; b;\n      cost[a][b] = cost[b][a] = dist;\n    }\n    \n    int sum_of_costs = prim();\n    int lanterns = sum_of_costs/100 - (V - 1);\n    //n00mを100mで分割すると分割点はn-1個\n    cout << lanterns << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <queue>\nusing namespace std;\n\nconst int N_MAX = 100;\nint n, m;\nint edges[N_MAX][N_MAX];\n\nint solve() {\n\tbool visited[n];\n\tint result = 0;\n\tmemset(visited, 0, sizeof(visited));\n\ttypedef pair<int, int> P;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(make_pair(0, 0));\n\twhile (!que.empty()) {\n\t\tP current = que.top();\n\t\tque.pop();\n\t\tconst int cost = current.first;\n\t\tconst int pos = current.second;\n\t\tif (visited[pos]) continue;\n\t\tvisited[pos] = true;\n\t\tresult += cost;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (edges[pos][i] != -1) {\n\t\t\t\tque.push(make_pair(edges[pos][i], i));\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main () {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tscanf(\"%d\", &m);\n\t\tmemset(edges, -1, sizeof(edges));\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tedges[a][b] = edges[b][a] = d / 100 - 1;\n\t\t}\n\t\tprintf(\"%d\\n\", solve());\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1000000000000000000LL\nusing namespace std;\nlong long prim(int V, vector<pair<long long, long long>> X[]) {\n\tfor (int i = 0; i < V; i++) { dist[i] = INF; color[i] = WHITE; }\n\tdist[0] = 0; color[0] = GRAY; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<long long, long long>pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; color[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first, leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && color[to] < BLACK) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < V; i++) { sum += dist[i]; }//0-indexed\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<long long, long long> > g[100];\nint main() {\n\twhile(cin >> n >> m) {\n\t\tfor(int i = 0; i < n; i++) g[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", u, v, w);\n\t\t\tg[u].push_back(make_pair(v, w / 100 - 1));\n\t\t\tg[v].push_back(make_pair(u, w / 100 - 1));\n\t\t}\n\t\tcout << prim(n, g) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cmath>\n#include<string>\n#include<cstring>\n#include<map>\n#include<functional>\n#include<stack>\n#include<list>\n#include<set>\n#include<deque>\n#include<climits>\nusing namespace std;\n\nint N,M;\nint par[100],_rank[100];\n\nstruct Way{\n\tint A,B,D;\n\tWay(){}\n\tWay(int _A,int _B,int _D){\n\t\tA=_A; B=_B; D=_D;\n\t}\n\tbool operator<(const Way &a)const{\n\t\treturn D<a.D;\n\t}\n};\n\nvoid Init(){\n\tfor(int i=0;i<N;i++) par[i] = i;\n}\n\nint Find(int x){\n\tif(par[x]==x) return x;\n\telse return par[x] = Find(par[x]);\n}\n\nbool Unite(int x,int y){\n\tint a = Find(x),\n\t\tb = Find(y);\n\tif(a==b) return false;\n\tif(_rank[a]>_rank[b]){\n\t\tpar[b] = par[a];\n\t}\n\telse{\n\t\tpar[a] = par[b];\n\t\tif(_rank[a]==_rank[b]) _rank[b]++;\n\t}\n\treturn true;\n}\n\nint main(){\n\tWay way[10000];\n\twhile(cin>>N,N){\n\t\tcin>>M;\n\t\tfor(int i=0;i<M;i++){\n\t\t\tscanf(\"%d,%d,%d\",&way[i].A,&way[i].B,&way[i].D);\n\t\t}\n\t\tsort(way,way+M);\n\t\tint ans=0;\n\t\tInit();\n\t\tfor(int i=0;i<M;i++){\n\t\t\tif(Unite(way[i].A,way[i].B)==true){\n\t\t\t\tans += way[i].D/100-1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef struct{\n\tint cost,v,u;\n}wa;\nwa way[10000];\nint par[200];\nint compare(const wa& a,const wa& b){\n\treturn a.cost<b.cost;\n}\nint find(int t){\n\tif(par[t]==t)\n\treturn t;\n\telse return find(par[t]);\n}\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tpar[y]=find(par[x]);\n}\nint main(){\n\tint n,m,ans,x,y,c,num;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\tans=0;\n\t\tnum=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&x,&y,&c);\n\t\t\tway[i].v=x;\n\t\t\tway[i].u=y;\n\t\t\tway[i].cost=c/100-1;\n\t\t}\n\t\tsort(way,way+m,compare);\n\t\tfor(int i=0;i<n;i++)\n\t\t\tpar[i]=i;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!same(way[i].v,way[i].u)){\n\t\t\tunite(way[i].v,way[i].u);\n\t\t\t\tnum++;\n\t\t\tans+=way[i].cost;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nint n,m;\n\nclass UnionFind{\n\tvector<int> par;\n\tvector<int> rank;\npublic:\n\tUnionFind(){ }\n\tUnionFind(int size){ reset(size); }\n\n\tvoid reset(int size){\n\t\tpar.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i = 0; i < size; i++) par[i] = i,rank[i] = 0;\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x),y = find(y);\n\t\tif(x == y) return ;\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x,int y){return find(x) == find(y);}\n};\n\n\nstruct P{\n\tint c,f,t;\n\tbool operator<(const P& x)const{\n\t\treturn c < x.c;\n\t}\n};\n\nvoid solve()\n{\n\tcin>>m;\n\tvector<P> p(m);\n\tUnionFind uf(n);\n\tfor (int i = 0; i < m; i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d,%d,%d\",&x,&y,&z);\n\t\tp[i].f = x; p[i].t = y; p[i].c = z;\n\t}\n\tsort(p.begin(),p.end());\n\tint cost = 0;\n\tfor (int i = 0; i < m; i++){\n\t\tif(!uf.same(p[i].f,p[i].t)){\n\t\t\tuf.unite(p[i].f,p[i].t);\n\t\t\tcost += p[i].c;\n\t\t}\n\t}\n\n\tcout << cost / 100 - (n-1) << endl;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tsolve();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\n#define MAX_V 111\n#define INF 2147483647\n\nint cost[MAX_V][MAX_V]={{0}};\nint mincost[MAX_V]={};\nbool used[MAX_V]={};\nint V;\n\n\nint prim(void);\nint min(int a,int b);\n\nint main(){\n  int m;\n  \n  scanf(\"%d\",&V);\n  \n  while(1){\n    if(V==0) break;\n    scanf(\"%d\",&m);\n    \n    /*\n      for(int i=0;i<m;i++){\n      for(int j=0;j<m;j++){\n      cost[i][j]=INF;\n      }\n      }*/\n    \n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b] = c/100 - 1;\n      cost[b][a] = c/100 - 1;\n    }\n    \n    printf(\"%d\\n\",prim());\n    \n    scanf(\"%d\",&V);\n  }\n  \n  return 0;\n}\n\nint min(int a,int b){\n  if(a>b) return b;\n  return a;\n}\n\nint prim(void){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(!used[u] && (v==-1 || mincost[u] <  mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for(int u = 0;u < V;u++){\n      if(cost[v][u]==0);\n      else{\n\tmincost[u] = min(mincost[u], cost[v][u]);\n      }\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\n\nusing namespace std;\n\n#define M 987654321\n\nclass Prim\n{\npublic:\n\tvoid mst (vector <vector <int> >, vector<int> &, vector <bool> &, vector <int> &);\nprivate:\n\n};\nvoid Prim::mst (vector <vector <int> > t, vector <int>& pi, vector <bool>& v, vector <int>& cost)\n{\n\tint size = v.size();\n\tint i;\n\n\tdo{\n\t\tint mincost = M;\n\t\tint u;\n\n\t\t// costªÅ¬ÆÈém[huðIð·é\n\t\tfor (i = 0; i < size; ++i){\n\t\t\tif (!v[i] && cost[i] < mincost){\n\t\t\t\tmincost = cost[i];\n\t\t\t\tu = i;\n\t\t\t} // end if\n\t\t} // end for\n\n\t\tv[u] = true;\n\t\n\t\tfor (i = 0; i < size; ++i){\n\t\t\t// Ü¾ÜÜêÄ¢È¢m[hÌRXgÌXV\n\t\t\tif (!v[i] && t[u][i] < cost[i] ){\n\t\t\t\tcost[i] = t[u][i];\n\t\t\t\tpi[i] = u;\n\t\t\t} // end if\n\t\t} // end for\t\t \n\t\t\n\t} while ((int)count (v.begin(), v.end(), true ) != size );// end while\n}\n\nint main()\n{\n\tPrim prim;\n\n//\tcut here before submit \n//\tfreopen(\"testcase.cdl\", \"r\", stdin);\n\n\tstring str = \"\";\n\tint n,m;\t// n: jÕÌÓ m: jÕðÔ¹Ì\n\n\twhile (getline (cin, str ) ) {\n\t\tstringstream ssn(str);\n\t\tssn >> n;\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t} // end if\n\t\tgetline (cin, str );\n\t\tstringstream ssm(str);\n\t\tssm >> m;\n\n\t\tint i;\n\t\tvector <vector <int> > table (n, vector <int> (n, M ) );\n\t\tfor (i = 0; i < m; ++i){\n\t\t\tint from, to, dist;\n\t\t\tgetline (cin, str );\n\t\t\t\twhile (str.find(',') != string::npos ){\n\t\t\t\tstr = str.replace(str.find(','), 1, \" \");\n\t\t\t} // end while\n\t\t\tstringstream ss(str);\n\t\t\tss >> from >> to >> dist;\n\t\t\ttable[from][to] = dist;\n\t\t\ttable[to][from] = dist;\n\t\t} // end for\n\n\t\tvector <bool> visit (n, false );\n\t\tvector <int> len (n, M );\n\t\tvector <int> path (n, -1);\n\t\tlen[0] = 0;\n\t\tpath[0] = -1;\n\n\t\tprim.mst (table, path, visit, len );\n\n\t\tint res = accumulate (len.begin(), len.end(), 0);\n\t\t\n\t\tmap <int, int> edge;\n\t\tfor (i = 0; i < n; ++i){\n\t\t\tint curr = i;\n\t\t\twhile (path[curr] != -1 ){\n\t\t\t\tedge[curr] = path[curr];\n\t\t\t\tcurr = path[curr];\n\t\t\t} // end while\n\n\t\t} // end for\n\n\t\tcout << (res/100 - edge.size() ) << endl;\n\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n#define MAX_N 100\nint par[MAX_N];\nint myrank[MAX_N];\nint n,m;\n\n\nstruct edge {\n    int a, b, d;\n\n    /*\n    bool operator <(const edge& r) {\n      return this->d < r.d;\n    }\n     */\n};\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n) {\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) {\n    return;\n  }\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n}\n\n// x,y????±?????????????????????????????????????\nint same(int x, int y) { return find(x) == find(y); }\n\nvoid Tree_print() {\n  int i;\n  for (i = 0; i < n; i++) cout << par[i];\n  cout << endl;\n\n}\n\nint compare_edge(const void *a,const void * b){\n  edge temp1 = *(edge *)a;\n  edge temp2 = *(edge *)b;\n\n  return temp1.d-temp2.d;\n}\nint main() {\n  int count = 0,t = 0;\n  while (1){\n    cin >> n ;\n    if(n == 0) break;\n    cin >> m;\n    init(n);\n\n    edge e[n];\n\n    for(int i = 0; i < m; i ++){\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n    }\n\n    qsort(e,n, sizeof(*e),compare_edge);\n    while(count != m-1) {\n      for (int i = 0; i < n; ++i) {\n        if(same(e[i].a,e[i].b) != 1) {\n          count++;\n          t = t + (int) e[i].d /100 - 1;\n          unite(e[i].a,e[i].b);\n        }\n      }\n      cout << t<<endl;\n    }\n\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct LINE {\n\tint a;\n\tint b;\n\tint d;\n\tbool use;\n};\n\nvector<int> getconnect(vector<LINE> &lines,int n)\n{\n\tvector<int>\tr;\n\tfor(int i=0;i<lines.size();i++){\n\t\tif( lines[i].a != lines[i].b && (lines[i].a==n || lines[i].b==n) ){\n\t\t\tr.push_back(i);\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\n\tint n,m;\n\tcin >> n >> m;\n\tvector<LINE> lines;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tLINE l;\n\t\tchar c;\n\t\tcin >> l.a >> c >> l.b >> c >> l.d;\n\t\tl.use=false;\n\t\tlines.push_back(l);\n\t}\n\n\twhile( true ){\n\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tauto idxs=getconnect(lines,i);\n\t\t\tif( idxs.empty() ) continue;\n\n\t\t\tcount++;\n\t\t\t\n\t\t\tint mini = idxs[0];\n\t\t\tint mind = lines[mini].d;\n\t\t\tfor(int idx : idxs){\n\t\t\t\tif( lines[idx].d < mind ){\n\t\t\t\t\tmini = idx;\n\t\t\t\t\tmind = lines[idx].d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint t = lines[mini].a!=i?lines[mini].a:lines[mini].b;\n\t\t\t\n\t\t\tauto idxs2=getconnect(lines,t);\n\t\t\tfor(int idx : idxs2){\n\t\t\t\tif( lines[idx].a==t){\n\t\t\t\t\tlines[idx].a = i;\n\t\t\t\t}\n\t\t\t\tif( lines[idx].b==t){\n\t\t\t\t\tlines[idx].b = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlines[mini].use=true;\n\t\t}\n\t\tif( count==0) break;\n\t\tcount=0;\n\t}\n\n\tint ans=0;\n\tfor( auto l : lines){\n\t\tif( l.use){\n\t\t\tans += l.d/100-1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\nconst int MAX_V = 100,MAX_E = 10000;\nint V,E;\nclass Union_Find{\nprivate:\n\tint par[MAX_V],rank[MAX_V];\npublic:\n\tvoid init(int n);\n\tint find(int x);\n\tvoid unite(int x,int y);\n\tbool same(int x,int y);\n};\nvoid Union_Find::init(int n){\n\tfor(int i = 0;i < n;++i){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\nint Union_Find::find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\nvoid Union_Find::unite(int x,int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y]) rank[x]++;\n\t}\n}\nbool Union_Find::same(int x,int y){\n\treturn find(x) == find(y);\n}\nstruct edge{\n\tint u,v,cost;\n};\nedge es[MAX_E];\nbool comp(const edge& e1,const edge& e2){\n\treturn e1.cost < e2.cost;\n}\nint kruskal(){\n\tsort(es,es + E,comp);\n\tUnion_Find u;\n\tu.init(V);\n\tint res = 0;\n\tfor(int i = 0;i < E;++i){\n\t\tedge e = es[i];\n\t\tif(!u.same(e.u,e.v)){\n\t\t\tu.unite(e.u,e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\tedge e;\n\tint u,v,cost;\n\tchar a;\n\twhile(cin >> V,V){\n\t\tcin >> E;\n\t\tfor(int i = 0;i < E;++i){\n\t\t\tcin >> u >> a >> v >> a >> cost;\n\t\t\te.u = u;\n\t\t\te.v = v;\n\t\t\te.cost = (cost / 100) - 1;\n\t\t\tes[i] = e;\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n\n#define ll long long\n#define ull unsigned long long\n#define pii pair<int,int>\n#define vi vector<int>\n#define VS vector<string>\n#define all(x) x.begin(),x.end()\n#define mp make_pair\n#define pb push_back\n\n#define INF 1000010\n#define MAX_V 110\n\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\nint prim(){\n    for(int i=0; i < V; ++i){\n        mincost[i] = INF;\n        used[i] = false;\n    }\n    mincost[0] = 0;\n    int res = 0;\n\n    while(true){\n        int v = -1;\n        for(int u=0; u < V; u++){\n            if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n        }\n\n        if(v == -1) break;\n        used[v] = true;\n        res += mincost[v];\n\n        for(int u=0; u < V; u++){\n            mincost[u] = min(mincost[u], cost[v][u]);\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n){\n\n        for(int i=0; i < MAX_V; i++) for(int j=0; j < MAX_V; j++) cost[i][j] = INF;\n\n        V = n;\n        int m;\n        cin >> m;\n        for(int i=0; i < m; i++){\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            cost[a][b] = c;\n            cost[b][a] = c;\n        }\n\n        cout << prim()/100-n+1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint Kruskal(Graph& g,Edges& e)\n{\n\te.clear();\n\t\n\tUnionFind uf(g.size());\n\tset<Edge> s;\n\trep(i,g.size())\n\t\trep(j,g[i].size())\n\t\t\ts.insert(g[i][j]);\n\t\n\tint res=0;\n\tforeach(i,s){\n\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n\t\t\tuf.Union(i->src,i->dst);\n\t\t\tres+=i->weight;\n\t\t\te.push_back(*i);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight));\n\t\t\tg[dst].push_back(Edge(src,dst,weight));\n\t\t}\n\t\tEdges e;\n\t\tint sum=Kruskal(g,e);\n\t\tcout<<sum/100-e.size()<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint Par[100],Rank[100];\nvoid Init(int n) {\n\tfor(int i=0;i<n;i++) {\n\t\tPar[i]=i;\n\t\tRank[i]=0;\n\t}\n}\nint Find(int x) {\n\tif(Par[x]==x) {\n\t\treturn x;\n\t}else {\n\t\treturn Par[x]=Find(Par[x]);\n\t}\n}\nvoid Unite(int x,int y) {\n\tx=Find(x);\n\ty=Find(y);\n\tif(x==y) return;\n\tif(Rank[x]<Rank[y]) {\n\t\tPar[x]=y;\n\t}else {\n\t\tPar[y]=x;\n\t\tif(Rank[x]==Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x,int y) {\n\treturn Find(x)==Find(y);\n}\nstruct Edge {\n\tint u,v,cost;\n\tEdge(int _u,int _v,int _cost) {u=_u,v=_v,cost=_cost;}\n\tbool operator < (const Edge& E) const {return cost<E.cost;}\n};\nbool comp(const Edge& E1,const Edge& E2) {\n\treturn E1.cost<E2.cost;\n}\nvector<Edge> es;\nint main() {\n\tint n,m,a,b,d;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tes.push_back(Edge(a,b,d));\n\t\t}\n\t\tsort(es.begin(),es.end());\n\t\tint res=0;\n\t\tInit(n);\n\t\tfor(int i=0;i<es.size();i++) {\n\t\t\tif(!same(es[i].u,es[i].v)) {\n\t\t\t\tUnite(es[i].u,es[i].v);\n\t\t\t\tres+=(es[i].cost/100-1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_V 100\n#define INF 1e9\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint V;\n\nint prim(){\n  int mincost[MAX_V];\n  bool used[MAX_V];\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res=0;\n  while(true){\n    int v = -1;\n    \n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true; //頂点vをXに追加\n    res += mincost[v]; //円のコストを加える\n    for(int u=0;u<V;u++) mincost[u] = min(mincost[u],cost[v][u]);\n  }\n  return res;\n}\n\n\nint main(){\n  int E;\n  while(cin >> V >> E){\n    if(V==0) break;\n    for(int i=0;i<E;i++){\n      for(int j=0;j<E;j++){\n        cost[i][j] = cost[j][i] = (i==j ? 0 : INF);\n      }\n    }\n\n    int a,b,dist;\n    char camma;\n    for(int i=0;i<E;i++){\n      cin >> a >> camma >> b >> camma >> dist;\n      a; b;\n      cost[a][b] = cost[b][a] = dist;\n    }\n    \n    int sum_of_costs = prim();\n    int lanterns = sum_of_costs/100 - (V - 1);\n    //n00mを100mで分割すると分割点はn-1個\n    cout << lanterns << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1000000000\n\nusing namespace std;\n\n\nint main(){\n        int n;\n        cin >> n;\n        while(n){\n                int m;\n                cin >> m;\n                int map[n][n];\n                for(int i = 0; i < n ;i++){\n                        for(int j = 0; j < n; j++){\n                                map[i][j] = INF;\n                        }   \n                }   \n                for(int i = 0; i < m; i++){\n                        int a,b,c;\n                        char d,e;\n                        cin >> a >> d >> b >> e >> c;\n                        map[a][b] = map[b][a] = c/100;\n                }   \n                bool used[100] = {false};\n                used[0] = true;\n                long long cost = 0;\n                for(int i = 0; i < n-1; i++){\n                        int min = INF;\n                        int next = 0;\n                        for(int j = 0; j < n; j++){\n                                for(int k = 0; k < n; k++){\n                                        if(used[j] && !used[k] && map[j][k] < min){\n                                                min = map[j][k];\n                                                next = k;\n                                        }   \n                                }   \n                        }   \n                        used[next] = true;\n                        cost += min-1;\n                }   \n                cout << cost << endl;\n                cin >> n;\n        }   \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\nusing namespace std;\n\n#define ROOT (-1)\n#define INV (-1)\n#define INFTY INT_MAX\n#define MAX_NODES 100\n\nint prim(int n, int dist[][MAX_NODES]){\n\tint ans = 0; // problem answer\n\tbool vis[MAX_NODES];\n\tint cost[MAX_NODES];\n\tint pi[MAX_NODES];\n\n\tfor(int i = 0; i < n; i++){\n\t\tvis[i] = false;\n\t\tcost[i] = INFTY;\n\t}\n\n\tcost[0] = 0;\n\tpi[0] = ROOT;\n\n\twhile( true ){\n\t\tint mincost = INFTY;\n\t\tint nmin;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif( !vis[i] && mincost > cost[i] ){\n\t\t\t\tmincost = cost[i];\n\t\t\t\tnmin = i;\n\t\t\t}\n\t\t}\n\n\t\t// end\n\t\tif( mincost == INFTY ) break;\n\n\t\tvis[nmin] = true;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif( vis[i] || dist[nmin][i] == INV ) continue; // skip\n\t\t\tif( dist[nmin][i] < cost[i] ){\n\t\t\t\tcost[i] = dist[nmin][i];\n\t\t\t\tpi[i] = nmin;\n\t\t\t}\n\t\t}\n\t}\n\n\t// calc\n\tfor(int i = 1; i < n; i++){\n\t\tans += ( (cost[i] == INFTY ? 100 : cost[i]) - 100) / 100;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\twhile( true ){\n\t\tint dist[MAX_NODES][MAX_NODES];\n\t\tint n;\n\t\tint m;\n\n\t\tcin >> n;\n\t\tif( n == 0 ) break;\n\t\tcin >> m;\n\t\t\n\t\t// init\n\t\tfor(int i = 0; i < sizeof(dist)/sizeof(*dist); i++){\n\t\t\tfor(int j = 0; j < sizeof(dist[i])/sizeof(*dist[i]); j++){\n\t\t\t\tdist[ i ][ j ] = INV;\n\t\t\t}\n\t\t}\n\n\t\t// input\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a, b, d;\n\t\t\tchar dum;\n\t\t\tcin >> a >> dum >> b >> dum >> d;\n\t\t\tdist[a][b] = d;\n\t\t\tdist[b][a] = d;\n\t\t}\n\n\t\t// prim algorithm\n\t\tcout << prim(n, dist) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nconst int MAX_V = 10000;\nconst int INF = 1 << 28;\n\nstruct edge { int to, cost; };\ntypedef pair<int, int> P;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\nbool used[MAX_V];\n\nint prim(){\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\t//cout << \"V = \" << V << endl;\n\tfill(d, d + V, INF);\n\tfill(used, used + V, false);\n\td[0] = 0;\n\tque.push(P(0, 0));\n\tint res = 0;\n\twhile(!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\t//cout << p.first << ' ' << p.second << endl;\n\t\tif(used[p.second]) continue;\n\t\tused[p.second] = true;\n\t\tres += p.first;\n\t\tint v = p.second;\n\t\tif(d[v] < p.first) continue;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e = G[v][i];\n\t\t\t//cout << e.to << ' ' << e.cost << ' ' << d[e.to] << endl;\n\t\t\tif(d[e.to] > e.cost){\n\t\t\t\td[e.to] = e.cost;\n\t\t\t\tque.push(P(d[e.to], e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\tint E;\n\twhile(1){\n\t\tscanf(\"%d\", &V);\n\t\tif(V == 0) break;\n\t\tscanf(\"%d\", &E);\n\t\t//cin >> V >> E;\n\t\tfor(int i=0;i<MAX_V;i++) G[i].clear();\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint s, t, w;\n\t\t\tscanf(\"%d,%d,%d\", &s, &t, &w);\n\t\t\t//cout << s << ' ' << t << ' ' << w << endl;\n\t\t\t//cin >> s >> t >> w;\n\t\t\tG[s].push_back((edge){t, w});\n\t\t\tG[t].push_back((edge){s, w});\n\t\t}\n\t\tcout << prim() / 100 - (V - 1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nconst int INF = 10000000;\n\nint main(){\n\tint n, m;\n\twhile(std::cin >> n, n){\n\t\tstd::cin >> m;\n\t\tint cost[100][100];\n\t\tfor(int i=0;i<10000;i++){\n\t\t\tcost[i/100][i%100] = INF;\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = d / 100 - 1;\n\t\t\tcost[b][a] = d / 100 - 1;\n\t\t}\n\t\tint mincost[100];\n\t\tbool used[100];\n\t\tint res = 0;\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tmincost[i] = INF;\n\t\t\tused[i] = false;\n\t\t}\n\t\n\t\tmincost[0] = 0;\n\t\twhile(1){\n\t\t\tint v = -1;\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\t}\n\t\t\tif(v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v];\n\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tmincost[u] = std::min(mincost[u], cost[v][u]);\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << res << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <cfloat>\n#include <climits>\n#include <ctime>\n#include <cassert>\n#include <numeric>\n#include <fstream>\n#include <functional>\n#include <bitset>\n#define chmin(a, b) ((a)=min((a), (b)))\n#define chmax(a, b) ((a)=max((a), (b)))\n#define fs first\n#define sc second\n#define eb emplace_back\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\ntypedef tuple<int, int, int> T;\n\nconst ll MOD=1e9+7;\nconst ll INF=1e18;\nconst double pi=acos(-1);\nconst double eps=1e-10;\n\nint dx[]={1, 0, -1, 0};\nint dy[]={0, -1, 0, 1};\n\nconst int MAX_N = 110;\n\nint par[MAX_N];\nint ranks[MAX_N];\nint ufSize;\n\nvoid init(int n){\n    ufSize = n;\n    for(int i=0; i<n; i++){\n        par[i] = i;\n        ranks[i] = 0;\n    }\n}\n\nint find(int x){\n    if(par[x] == x){\n        return x;\n    }\n    else{\n        return par[x] = find(par[x]);\n    }\n}\n\nbool same(int x, int y){\n    return find(x) == find(y);\n}\n\nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n    ufSize--;\n\n    if(ranks[x] < ranks[y]){\n        par[x] = y;\n    }\n    else{\n        par[y] = x;\n    }\n    \n    if(ranks[x] == ranks[y]){\n        ranks[x]++;\n    }\n}\n\nint kruskal(int n, vector<T> &edge){\n    sort(edge.begin(), edge.end());\n    init(n);\n    int res = 0;\n    for(int i=0; i<edge.size(); i++){\n        int cost, cv, nv;\n        tie(cost, cv, nv) = edge[i];\n        if(!same(cv, nv)){\n            unite(cv, nv);\n            res += (cost - 100) / 100;\n        }\n    }\n    \n    return res;\n}\n\nint main(){\n    while(1){\n        int n; cin>>n;\n        if(n == 0) return 0;\n        int m; cin>>m;\n        \n        vector<T> edge;\n        for(int i=0; i<m; i++){\n            int a, b, d;\n            char c1, c2;\n            cin>>a>>c1>>b>>c2>>d;\n            edge.eb(T(d, a, b));\n        }\n\n        cout << kruskal(n, edge) << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint N, M;\nvector<P> g[100];\nbool done[100];\nint main()\n{\n  while(true)\n  {\n    cin >> N;\n    if(!N)\n      break;\n    cin >> M;\n    fill(done, done + 100, 0);\n    for(int i = 0; i < M; i++)\n    {\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      printf(\"%d %d %d \\n\", a, b, c);\n      c = c / 100 - 1;\n      g[a].push_back(make_pair(c, b));\n      g[b].push_back(make_pair(c, a));\n    }\n\n    priority_queue<P, vector<P>, greater<P>> q;\n    q.push(make_pair(0, 0));\n    int cost = 0;\n    while(q.size())\n    {\n      auto p = q.top(); q.pop();\n      if(done[p.second])\n        continue;\n      done[p.second] = true;\n      cost += p.first;\n      for(auto e: g[p.second])\n      {\n        if(done[e.second])\n          continue;\n        q.push(e);\n      }\n    }\n    cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint Kruskal(Graph& g,Edges& e)\n{\n\te.clear();\n\t\n\tUnionFind uf(g.size());\n\tmultiset<Edge> s;\n\trep(i,g.size())\n\t\trep(j,g[i].size())\n\t\t\ts.insert(g[i][j]);\n\t\n\tint res=0;\n\tforeach(i,s){\n\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n\t\t\tuf.Union(i->src,i->dst);\n\t\t\tres+=i->weight;\n\t\t\te.push_back(*i);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint Prim(Graph& g,Edges& tree,int root=0)\n{\n\ttree.clear();\n\t\n\tint size=g.size();\n\tvector<int> visited(size);\n\t\n\tpriority_queue<Edge,vector<Edge>,greater<Edge> > pq;\n\tpq.push(Edge(-1,root,0));\n\tint res=0;\n\twhile(!pq.empty()){\n\t\tEdge e=pq.top();\n\t\tpq.pop();\n\t\tif(visited[e.dst])\n\t\t\tcontinue;\n\t\tif(e.src!=-1)\n\t\t\ttree.push_back(e);\n\t\tvisited[e.dst]=1;\n\t\tres+=e.weight;\n\t\trep(i,g[e.dst].size()){\n\t\t\tEdge cand=g[e.dst][i];\n\t\t\tif(!visited[cand.dst])\n\t\t\t\tpq.push(cand);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(dst,src,weight/100-1));\n\t\t}\n\t\tEdges e;\n\t\tint sum=Kruskal(g,e);\n\t\t//int sum=Prim(g,e);\n\t\tcout<<sum<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <vector>\nusing namespace std;\n\nconst int INF = 1<<28;\n\nstruct edge_t {\n    int from, to, cost;\n    edge_t(int from, int to, int cost) : from(from), to(to), cost(cost) {}\n    bool operator<(const edge_t &o) const {\n        return (cost < o.cost);\n    }\n    bool operator>(const edge_t &o) const {\n        return (cost > o.cost);\n    }\n};\nstruct state_t {\n    int v;\n    int min_cost;\n    state_t(int v, int min_cost) : v(v), min_cost(min_cost) {}\n    bool operator<(const state_t &o) const {\n        return (min_cost < o.min_cost);\n    }\n    bool operator>(const state_t &o) const {\n        return (min_cost > o.min_cost);\n    }\n};\ntypedef vector<edge_t> vertex_t;\nstruct graph_t {\n    vector<vertex_t> g;\n\n    graph_t() {}\n\n    graph_t(int vertex_count) {\n        g.resize(vertex_count);\n    }\n    graph_t(vector<vertex_t> g) : g(g) {}\n\n    inline vertex_t& operator[](int index) {\n        return g[index];\n    }\n\n    inline void push_back(vertex_t v) {\n        g.push_back(v);\n    }\n\n    int prim() {\n        bool used[g.size()];\n        int min_span_cost = 0;\n        priority_queue< edge_t, vector<edge_t>, greater<edge_t> > q;\n\n        fill(used, used+g.size(), false);\n\n        used[0] = true;\n        for (int i = 0; i < g[0].size(); i++) {\n            q.push(g[0][i]);\n        }\n\n        while (!q.empty()) {\n            edge_t e = q.top(); q.pop();\n            if (used[e.to]) continue;\n            used[e.to] = true;\n            min_span_cost += e.cost;\n            for (int i = 0; i < g[e.to].size(); i++) {\n                q.push(g[e.to][i]);\n            }\n        }\n\n        return min_span_cost;\n    }\n\n    void dijkstra(int s, vector<int> &min_cost) {\n        min_cost.resize(g.size());\n        priority_queue< state_t, vector<state_t>, greater<state_t> > q;\n        \n        fill(min_cost.begin(), min_cost.end(), INF);\n\n        min_cost[s] = 0;\n        q.push(state_t(s, 0));\n\n        while (!q.empty()) {\n            state_t p = q.top(); q.pop();\n            int v = p.v;\n            if (min_cost[v] < p.min_cost) continue;\n            for (int i = 0; i < g[v].size(); i++) {\n                edge_t e = g[v][i];\n                if (min_cost[e.to] > min_cost[v] + e.cost)  {\n                    min_cost[e.to] = min_cost[v] + e.cost;\n                    q.push(state_t(e.to, min_cost[e.to]));\n                }\n            }\n        }\n    }\n};\n\nint main() {\n    int n, m;\n    while (cin >> n) {\n        if (n == 0) break;\n        cin >> m;\n        graph_t g(n);\n        for (int i = 0; i < m; i++) {\n            int a, b, cost;\n            char d;\n            cin >> a >> d >> b >> d >> cost;\n            g[a].push_back(edge_t(a, b, cost/100-1));\n            g[b].push_back(edge_t(b, a, cost/100-1));\n        }\n        cout << g.prim() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\n \nstruct Edge{\n    int a,b,d;\n    bool operator<(const Edge a)const{\n        return d<a.d;\n    }\n};\n \nint par[100],rank_[100];\n \nvoid init(int n){\n    for(int i=0;i<n;i++) par[i] = i, rank_[i] = 1;\n}\n \nint find(int x){\n    if(par[x]==x) return x;\n    return par[x] = find(par[x]);\n}\n \nbool unite(int _a,int _b){\n    int a = find(_a), b = find(_b);\n    if(a==b) return false;\n    if(rank_[a]>rank_[b]) par[b] = a;\n    else{\n        par[a] = b;\n        if(rank_[a]==rank_[b]) rank_[b]++;\n    }\n    return true;\n}\n \nint main(){\n    int N,M;\n    while(cin >> N , N){\n        init( N );\n        cin >> M;\n        Edge e[10000];\n        for(int i = 0;i < M; i++) scanf(\"%d,%d,%d\",&e[i].a,&e[i].b,&e[i].d);\n        sort(e,e+M);\n        int ans = 0;\n        for(int i = 0; i < M; i++){\n            if(unite(e[i].a, e[i].b)){\n                ans += e[i].d/100-1;\n            }\n        }\n        printf(\"%d\\n\" ,ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstdio>\n#define F first\n#define S second\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nint n,m;\nint prim();\nmain(){\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cin>>m;\n    cout<<prim()/100-(n-1)<<endl;\n  }\n}\nint prim(){\n  vector<P> cost[111];\n  bool used[111];\n  int ans=0;\n  int from,to,mm;\n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d\",&from,&to,&mm);\n    cost[from].push_back(P(to,mm));\n    cost[to].push_back(P(from,mm));\n  }\n  for(int i=0;i<111;i++){\n    used[i]=false;\n  }\n  priority_queue< P ,vector<P>,greater<P> > q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    P p=q.top();\n    q.pop();\n    if(used[p.S]==true){\n      continue;\n    }\n    used[p.S]=true;\n    ans+=p.F;\n    for(int i=0;i<cost[p.S].size();i++){\n      q.push(P(cost[p.S][i].S,cost[p.S][i].F));\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint N, M;\nvector<P> g[100];\nbool done[100];\nint main()\n{\n  while(true)\n  {\n    cin >> N;\n    if(!N)\n      break;\n    cin >> M;\n    fill(done, done + 100, 0);\n    for(int i = 0; i < M; i++)\n    {\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      printf(\"%d %d %d \\n\", a, b, c);\n      c = c / 100 - 1;\n      g[a].push_back(make_pair(c, b));\n      g[b].push_back(make_pair(c, a));\n    }\n\n    priority_queue<P, vector<P>, greater<P>> q;\n    q.push(make_pair(0, 0));\n    int cost = 0;\n    while(q.size())\n    {\n      auto p = q.top(); q.pop();\n      if(done[p.second])\n        continue;\n      done[p.second] = true;\n      cost += p.first;\n      for(auto e: g[p.second])\n      {\n        if(done[e.second])\n          continue;\n        q.push(e);\n      }\n    }\n    cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <cmath>\n#include <climits>\n#include <set>\n#include <iostream>\n#include <map>\n#include <functional>\n#include <cstdlib>\n#include <numeric>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nstruct Edge {\n\tint src, dst, cost;\n\tEdge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n\tEdge() {}\n\tbool operator<(const Edge& e)const {\n\t\treturn cost > e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nEdges prim(const Graph& g)\n{\n\tEdges T;\n\tvector<int> visited(g.size(), 0);\n\tvisited[0] = 1;\n\n\tpriority_queue<Edge> Q;\n\trep(i, g[0].size())\n\t\tQ.push(g[0][i]);\n\n\twhile(!Q.empty()){\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif(visited[e.dst])\n\t\t\tcontinue;\n\t\tT.push_back(e);\n\t\tvisited[e.dst] = 1;\n\t\trep(i, g[e.dst].size()){\n\t\t\tif(!visited[g[e.dst][i].dst])\n\t\t\t\tQ.push(g[e.dst][i]);\n\t\t}\n\t}\n\treturn T;\n}\n\nint main()\n{\n\tint n, m;\n\twhile(scanf(\"%d\", &n), n){\n\t\tscanf(\"%d\", &m);\n\t\tGraph g(n);\n\t\trep(i, n){\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tg[a].push_back(Edge(a, b, d));\n\t\t\tg[b].push_back(Edge(b, a, d));\n\t\t}\n\t\tEdges t = prim(g);\n\t\tint ans = 0;\n\t\trep(i, t.size())\n\t\t\tans += t[i].cost / 100 - 1;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//0072\n//vñFÅ¬SæØ\n//QlFhttp://www.deqnotes.net/acmicpc/prim/\n\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<functional>\nusing namespace std;\n\n\nint main(void)\n{\n\tint n, m;\n\tconst int N = 100;\n\tconst int INVALID_VALUE = -1;\n\tint cost[N][N];\n\n\twhile(scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d\", &m);\n\t\tint a, b, d;\n\t\tint i, j;\n\t\t//¢Á½ñ·×ÄÌ¹Ìèðú»·é\n\t\t//©ª©gÖÌ¹ÌèÍ0¾¯ÇA¡ñÍl¶·éKvÍ³¢H\n\t\tfor(i = 0; i < N; ++i)\n\t\t\tfor(j = 0; j < N; ++j)\n\t\t\t\tcost[i][j] = INVALID_VALUE;\n\t\tfor(i = 0; i < m; ++i)\n\t\t{\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d;\n\t\t}\n\n\t\ttypedef pair<int, int> P;\t//<distance, toIndex>@£Å\\[g·é½ßOÉ\n\t\t//¸ÉDæxÂ«ÌL[\n\t\t//½ÅftHgÍ~ÈÌæ\n\t\tpriority_queue<P, vector<P>, greater<P>> q;\n\t\t//»Ì¸_ÍÚ±³êÄ¢Ü·©H\n\t\tbool isConnected[N] = {false};\n\n\t\tint totalDistance = 0;\t//Å¬ØÌ£\n\n\t\t//Æè ¦¸ê0©çnßæ¤\n\t\tq.push(P(0, 0));\t//make_pairÅâÁ½çB¾Æ¢íê½B0Ì¹¢H\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p = q.top();\n\t\t\tq.pop();\n\t\t\t//·ÅÉÂÈªÁÄ¢é¸_¾Á½ç½àµÈ¢\n\t\t\tif(isConnected[p.second])\n\t\t\t\tcontinue;\n\t\t\t//»ÌÓðÚ±µÜ·\n\t\t\tisConnected[p.second] = true;\n\t\t\ttotalDistance += p.first;\n\t\t\t//ÌÓðÚ±µÜ·\n\t\t\tfor(i = 0; i < N; ++i)\n\t\t\t{\n\t\t\t\tif(cost[p.second][i] != INVALID_VALUE)\t//»ÌæÖÌ¹Í¶ÝµÜ·©\n\t\t\t\t\tq.push( P(cost[p.second][i], i) );\t//±±Ímake_pair()ÅàG[ÉÈçÈ¢¯êÇ\n\t\t\t}\n\t\t}\n\n\t\t//UÌÂÍAijÕÌÓ|1jÂ­È­A»µÄ100m¨«ÉÉu©êÄ¢é\n\t\tprintf(\"%d\\n\", (totalDistance/100)-(n-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\n#define MAX_V 100\n#define INF 9999\n\nint prim(void);\n\nint cost[MAX_V][MAX_V]; //cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint mincost[MAX_V]; //集合Xからの最小コスト\nbool used[MAX_V]; //頂点iがxに含まれているか\nint m; //頂点数\n\nusing namespace std;\n\nint main(){\n  int n,i,c,j,a,b;\n  \n  while(1){\n    scanf(\"%d\",&n); if(n==0) break;\n    scanf(\"%d\",&m);\n    for(j=0;j<m;j++){\n      for(i=0;i<m;++i){\n\tcost[j][i]=INF;\n      }\n    }\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    printf(\"%d\\n\",prim());\n    \n  }\n  return 0;\n}\n\nint prim(){\n  \n  //初期化\n  for(int i=0;i<m;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(true){\n    int v=-1;\n    //xに属さない頂点のうちxからの辺のコストが最小になる頂点を探す\n    for(int u=0;u<m;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    \n    used[v]=true; //頂点vをxに追加\n    res+=mincost[v]; //辺のコストを比べる\n    \n    for(int u=0;u<m;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "//20\n#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<functional>\n#include<numeric>\n\nusing namespace std;\n\nint main(){\n  for(int n;cin>>n,n;){\n    typedef pair<int,int> pii;\n    int m;\n    cin>>m;\n    vector<pii> e[100];\n    while(m--){\n      int a,b,d;\n      ((cin>>a).ignore()>>b).ignore()>>d;\n      e[a].push_back(make_pair(d,b));\n      e[b].push_back(make_pair(d,a));\n    }\n    priority_queue<pii,vector<pii>,greater<pii> > que;\n    que.push(make_pair(0,0));\n    vector<int> v(100,-1);\n    int r=n;\n    while(r--){\n      pii p;\n      do{\n\tp=que.top();\n\tque.pop();\n      }while(v[p.second]!=-1);\n      v[p.second]=p.first;\n      for(int i=0;i<e[p.second].size();i++){\n\tque.push(make_pair(e[p.second][i].first,e[p.second][i].second));\n      }\n    }\n    cout<<accumulate(v.begin(),v.begin()+n,0)/100-n+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX_V 10100\n#define MAX_E 101000\nusing namespace std;\n\nstruct P\n{\n  int to,cost;\n  P(int to=inf,int cost=inf):to(to),cost(cost){}\n  bool operator < (const P &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint V,E;\nvector<P> G[MAX_V];\nbool used[MAX_V];\nint mincost[MAX_V];\n\nint prim()\n{\n  rep(i,V)used[i] = false,mincost[i] = inf;\n  mincost[0] = 0;\n\n  priority_queue<P> Q;\n  Q.push(P(0,0));\n\n  int ans = 0;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      int cur = p.to;\n\n      if(used[cur])continue;\n      used[cur] = true;\n\n      if(mincost[cur] < p.cost)continue;\n\n      ans += p.cost;\n\n      for(int i=0;i<G[cur].size();i++)\n\t{\n\t  int next = G[cur][i].to;\n\t  if(used[next])continue;\n\t  if(mincost[next] > G[cur][i].cost)\n\t    {\n\t      mincost[next] = G[cur][i].cost;\n\t      Q.push(P(next,mincost[next]));\n\t    }\n\t}\n    }\n  return ans;\n}\n\nint main()\n{\n  while(cin >> V,V)\n    {\n      rep(i,V)G[i].clear();\n      cin >> E;\n      rep(i,E)\n\t{\n\t  int from,to,w;\n\t  //cin >> from >> to >> w;\n\t  scanf(\"%d,%d,%d\",&from,&to,&w);\n\t  G[from].push_back(P(to,w));\n\t  G[to].push_back(P(from,w));\n\t}\n      \n      cout << prim()/100 - (V-1) << endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<set>\nusing namespace std;\n#define INF 30000\nint main(){\n\twhile(1){\n\t\tint n,m;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>m;\n\t\tint cost[100][100];\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tchar t;\n\t\t\tcin>>a>>t>>b>>t>>c;\n\t\t\tc=c/100-1;\n\t\t\tcost[a][b]=c;\n\t\t\tcost[b][a]=c;\n\t\t}\n\t\tint v[100]={0};\n\t\tv[0]=1;\n\t\tint ans=0;\n\t\twhile(1){\n\t\t\tbool flag=true;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(v[i]==0){\n\t\t\t\t\tflag=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag==true)break;\n\t\t\tint min=INF;\n\t\t\tint to;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(v[i]==1){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(v[j]==0){\n\t\t\t\t\t\t\tif(min>cost[i][j]){\n\t\t\t\t\t\t\t\tmin=cost[i][j];\n\t\t\t\t\t\t\t\tto=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[to]=1;\n\t\t\tans+=min;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef long long int ll;\ntypedef pair<int, int> pii;\ntypedef vector<int> vi;\ntypedef vector<pair<int, int> > vii;\n#define rrep(i, m, n) for(int (i)=(m); (i)<(n);  (i)++)\n#define erep(i, m, n) for(int (i)=(m); (i)<=(n); (i)++)\n#define  rep(i, n)    for(int (i)=0; (i)<(n);  (i)++)\n#define rrev(i, m, n) for(int (i)=(n)-1; (i)>=(m); (i)--)\n#define erev(i, m, n) for(int (i)=(n); (i)>=(m); (i)--)\n#define  rev(i, n)    for(int (i)=(n)-1; (i)>=0; (i)--)\n#define vrep(i, c)    for(__typeof((c).begin())i=(c).begin(); i!=(c).end(); i++)\n#define  ALL(v)       (v).begin(), (v).end()\n#define mp            make_pair\n#define pb            push_back\ntemplate<class T, class S> inline bool minup(T& m, S x){ return m>(T)x ? (m=(T)x, true) : false; }\ntemplate<class T, class S> inline bool maxup(T& m, S x){ return m<(T)x ? (m=(T)x, true) : false; }\n\nconst int    INF = 1000000000;\nconst ll     MOD = 1000000007LL;\nconst double EPS = 1E-12;\n\nstruct UnionFind\n{\nprivate:\n  vi data;\n  int cnt;\n\npublic:\n  UnionFind(const int size) : data(size, -1), cnt(size) {}\n  bool unite(int x, int y){\n    x = root(x);\n    y = root(y);\n    if(x != y){\n      if(data[y] < data[x]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n      cnt -= 1;\n    }\n    return x != y;\n  }\n  bool same(int x, int y){ return root(x) == root(y); }\n  int root(int x){ return data[x] < 0 ? x : data[x] = root(data[x]); }\n  int size(int x){ return -data[root(x)]; }\n  int group(){ return cnt; }\n};\n\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) : src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\n\n// ????????°?????????????°????????????????\npair<Weight, Edges> Kruskal(const Graph &g)\n{\n  int n = g.size();\n  UnionFind uf(n);\n  priority_queue<Edge> Q;\n  rep(u, n) vrep(e, g[u]) if (u < e->dst) Q.push(*e);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unite(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n    }\n  }\n  return pair<Weight, Edges>(total, F);\n}\n\nint n, m;\nint s, t;\nWeight w;\n\nint main()\n{\n  while((cin >> n) && n){\n    cin >> m;\n    Graph g(n);\n    rep(i, m){\n      scanf(\"%d,%d,%d\", &s, &t, &w);\n      g[s].pb(Edge(s, t, w / 100 - 1));\n      g[t].pb(Edge(t, s, w / 100 - 1));\n    }\n    cout << Kruskal(g).first << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF= 1e9;\n\nstruct edge{\n  int from, to, cost;\n  edge(int x,int y, int z):from(x),to(y),cost(z){}\n  bool operator<(const edge &x)const{ return cost<x.cost; }\n};\n\ntypedef pair<int,int> pii;\n\nclass Prim{\n  int n;\n  vector< vector<edge> > g;\npublic:\n  Prim(int a=0):n(a){ g.resize(n); }\n\n  void AddEdge(int a, int b, int cost){\n    g[a].push_back(edge(a,b,cost));\n    g[b].push_back(edge(b,a,cost));\n  }\n\n  int MinSpanningTree(){\n    int res = 0;\n    vector<int> d(n,INF); d[0] = 0;\n    priority_queue<pii, vector<pii>, greater<pii> > q;\n    q.push(pii(0,0));\n\n    while(q.size()){\n      int cost = q.top().first, v = q.top().second; q.pop();\n      if(d[v] < cost)continue;\n      res += cost; d[v] = -INF;\n\n      for(int i=0;i<(int)g[v].size();i++){\n\tint to = g[v][i].to, nxtcost = g[v][i].cost;\n\tif(d[to] > nxtcost){\n\t  d[to] = nxtcost;\n\t  q.push( pii(nxtcost,to) );\n\t}\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n,m;\n  while(scanf(\"%d\",&n),n){\n    Prim p(n);\n    cin >> m;\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      p.AddEdge(a,b,c/100-1);\n    }\n    cout << p.MinSpanningTree() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <functional>\nusing namespace std;\n\nint main()\n{\n  const int INF = 1 << 30;\n\n  int n, m;\n  while (~scanf(\"%d\", &n)) {\n    if (n == 0)\n      break;\n\n    scanf(\"%d\", &m);\n    vector<vector<int> > edge(n, vector<int>(n, INF));\n    for (int i = 0; i < m; ++i) {\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      d /= 100;\n      edge[a][b] = edge[b][a] = d;\n    }\n\n    int ans = 0;\n    vector<int> visited(n, 0);\n    priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int> > > que;\n    que.push(pair<int, int>(1, 0));\n    while (!que.empty()) {\n      const pair<int, int> p = que.top();\n      que.pop();\n\n      if (visited[p.second])\n\tcontinue;\n\n      visited[p.second] = 1;\n      ans += p.first - 1;\n      for (int i = 0; i < n; ++i) {\n\tif (visited[i] || edge[p.second][i] == INF)\n\t  continue;\n\tque.push(pair<int, int>(edge[p.second][i], i));\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\nusing namespace std;\n\n#define INF 1e9\n#define MAX_V 102\n\n// ????????????????????£?¨?\nint prim(int adjmatrix[MAX_V][MAX_V], int v);\n\n// ?????????\nint main(void){\n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n;\n    if(n == 0){ break; }\n    cin >> m;\n    \n    // ??£??\\???????????£?¨???¨?????????\n    int adjmatrix[MAX_V][MAX_V];\n    for(int i = 0; i < MAX_V; i++)\n      for(int j = 0; j < MAX_V; j++)\n        adjmatrix[i][j] = INF;\n\n    // ???????????±????????????????????£??\\???????????????\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      adjmatrix[a][b] = d;\n      adjmatrix[b][a] = d;\n    }\n  \n    // ????°???¨?????¨????????????????±??????????????????????\n    int length = prim(adjmatrix, n);\n    cout << length / 100 - n + 1 << endl;\n  }\n\n  return 0;\n}\n\n\n// ????????????\n// ?????°: ??£??\\??????, ????????°\n// ?????????: ??¨????????????\nint prim(int adjmatrix[MAX_V][MAX_V], int v){\n  vector<int> mincost(v, INF); // ?????§???????????????????????¨?????§???????°??????????\n  vector<bool> used(v, false); // ??????i?????¨????????????????????????\n  int length = 0; // ??¨????????¶???\n\n  // ???????????????\n  mincost[0] = 0;\n  while(true){\n    // ??¨????±??????????????????????????????¨?????§?????????????????????????°?????????????????????¢???\n    // newmember???????¬??????¨????????????????£??????????(-1??§?????????)\n    int newmember = -1;\n    for(int u = 0; u < v; u++){\n      // if(???u???????????¨???????±?????????????????????? && ?????¶???????£??????????u?????¨?????????){ u???????£??????????; }\n      if(!used[u] && (newmember == -1 || mincost[u] < mincost[newmember])){ newmember = u; }\n    }\n\n    // ????????????????????£??????newmember???-1??¨???????????¨???\n    // ???????????????????????¨???????±???????????????¨???????????¨????????§?????¢?´¢??????\n    if(newmember == -1){ break; }\n    \n    // ???newmember?????¨?????????\n    used[newmember] = true;\n    length += mincost[newmember];\n\n    // ??¨?????§???????°??????????????¨?????????´???\n    // ??°?????????newmember?????¨???????±????????????¨????????£????????§???????????§???????°???¨???newmember?????§??????????????¢???????????????????????°??????\n    for(int u = 0; u < v; u++){\n      mincost[u] = min(mincost[u], adjmatrix[newmember][u]);\n    }\n  }\n  \n  return length;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\nusing namespace std;\n\nclass node{\npublic:\n  int num;\n};\n\nclass edge{\npublic:\n  node b,e;\n  int cost;\n};\n\nclass graph{\npublic:\n  vector<node> nodes;\n  vector<edge> edges;\n  int n;\n  int e;\n\n  void set(void){\n    nodes.clear();\n    edges.clear();\n    n = 0;\n    e = 0;\n  }\n\n  void Nadd(node a){\n    if(n==0){\n      nodes.push_back(a);\n      n++;\n    }else{\n      int i = 0;\n      while(nodes[i].num < a.num && i<n)i++;\n      nodes.insert(nodes.begin()+i,a);\n      n++;\n    }\n  }\n\n  void Eadd(edge a){\n    if(e==0){\n      edges.push_back(a);\n      e++;\n    }else{\n      int i = 0;\n      while(edges[i].cost < a.cost && i<e)i++;\n      edges.insert(edges.begin()+i,a);\n      e++;\n    }\n  }\n\n  bool Nexist(node a){\n    for(int i=0;i<n;i++){\n      if(a.num == nodes[i].num)return true;\n    }\n    return false;\n  }\n\n  graph prim(void){\n    graph res;\n\n    res.set();\n\n    if(!e)return res;\n    else{\n      res.Eadd(edges[0]);\n      res.Nadd(edges[0].b);\n      res.Nadd(edges[0].e);\n\n      while(res.n < n){\n\tfor(int i=0;i<e;i++){\n\t  if(res.Nexist(edges[i].b) && !res.Nexist(edges[i].e)){\n\t    res.Eadd(edges[i]);\n\t    res.Nadd(edges[i].e);\n\t    i = 0;\n\t  }else if(!res.Nexist(edges[i].b) && res.Nexist(edges[i].e) ){\n\t    res.Eadd(edges[i]);\n\t    res.Nadd(edges[i].b);\n\t    i = 0;\n\t  }\n\t}\n      }\n      return res;\n    }\n  }\n\n};\n\nint main(){\n  int n,m;\n  int ans;\n  graph map,prim;\n  node tmp;\n  edge tmp2;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    map.set();\n    for(int i=0;i<n;i++){\n      tmp.num = i;\n      map.Nadd(tmp);\n    }\n    \n    cin >> m;\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&tmp2.b.num,&tmp2.e.num,&tmp2.cost);\n      map.Eadd(tmp2);\n    }\n\n    prim = map.prim();   \n\n    ans = 0;\n    for(int i=0;i<prim.e;i++)ans += prim.edges[i].cost - 100;\n\n    cout << ans/100 << endl;\n    \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\nclass UnionFind {\n  int n;\n  vector<int> parent;\npublic:\n  UnionFind(int n) : n(n), parent(n) {\n    rep(i, n) parent[i] = i;\n  }\n\n  int root(int x) {\n    if(x == parent[x]) return x;\n    return parent[x] = root(parent[x]);\n  }\n\n  void unite(int x, int y) {\n    if(root(x) == root(y)) return;\n    else if(root(x) < root(y)) {\n      parent[y] = root(x);\n    }else {\n      parent[x] = root(y);\n    }\n  }\n\n  bool is_same(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nint main() {\n  int n, m;\n  while(cin >> n && n) {\n    cin >> m;\n    UnionFind uf(n);\n    vector<IP> v;\n    rep(i, m) {\n      int a, b, c; char d;\n      cin >> a >> d >> b >> d >> c;\n      v.push_back(IP(c, P(a, b)));\n    }\n    sort(ALL(v));\n    int ans = 0;\n    rep(i, m) {\n      IP &e = v[i];\n      int c = e.first, a = e.second.first, b = e.second.second;\n      if(!uf.is_same(a, b)) {\n        uf.unite(a, b);\n        ans += (c - 100) / 100;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define MAX 114514\n\nint par[MAX], rnk[MAX];\n\nvoid init(int N)\n{\n    for (int i = 0; i < N; i++) {\n        par[i] = i;\n        rnk[i] = 0;\n    }\n}\n\nint find(int x)\n{\n    if (par[x] == x) {\n        return x;\n    }\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n    x = find(x); y = find(y);\n    if (x == y) return;\n\n    if (rnk[x] < rnk[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rnk[x] == rnk[y]) rnk[x]++;\n    }\n}\n\nbool same(int x, int y)\n{\n    return (find(x) == find(y));\n}\n\ntypedef pair<int, int> pii;\ntypedef pair<int, pii> P;\n\nint kruscal(P *p, int N, int M)\n{\n    sort(p, p + M);\n    init(N);\n    int res = 0;\n    for (int i = 0; i < M; i++) {\n        int a = p[i].second.first, b = p[i].second.second;\n        if (!same(a, b)) {\n            unite(a, b);\n            res += p[i].first;\n        }\n    }\n    return res;    \n}\n\nint main()\n{\n    int N, M;\n    while (cin >> N, N) {\n        cin >> M;\n        P p[MAX];\n        char x;\n        for (int i = 0; i < M; i++) {\n            int a, b, c;\n            cin >> a >> x >> b >> x >> c;\n            p[i] = P(c/100-1, pii(a, b));\n        }\n        cout << kruscal(p, N, M) << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#define INF 10000000\n\nusing namespace std;\n\n\nint main(){\n        int n;\n        cin >> n;\n        while(n){\n                int m;\n                cin >> m;\n                int map[n][n];\n                for(int i = 0; i < n ;i++){\n                        for(int j = 0; j < n; j++){\n                                map[i][j] = INF;\n                        }   \n                }   \n                for(int i = 0; i < m; i++){\n                        int a,b,c;\n                        char d,e;\n                        cin >> a >> d >> b >> e >> c;\n                        map[a][b] = map[b][a] = c/100;\n                }   \n                bool used[100] = {false};\n                used[0] = true;\n                int cost = 0;\n                for(int i = 0; i < m-1; i++){\n                        int min = INF;\n                        int next = 0;\n                        for(int j = 0; j < n; j++){\n                                for(int k = 0; k < n; k++){\n                                        if(used[j] && !used[k] && map[j][k] < min){\n                                                min = map[j][k];\n                                                next = k;\n                                        }   \n                                }   \n                        }   \n                        used[next] = true;\n                        cost += min-1;\n                }   \n                cout << cost << endl;\n                cin >> n;\n        }   \n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct branch{\n\tint n1,n2,w;\n};\nbool f(branch i, branch j){\n\treturn (i.w>j.w);\n}\nint main(){\n\twhile (1){\n\t\tint n,i;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int>T(n);\n\t\tfor(i=0;i<n;i++) T[i]=i;\n\n\t\tbranch tmp;\n\t\tint m; cin>>m;\n\t\tvector<branch>S(m);\n\t\tfor(i=0;i<m;i++) cin>>S[i].n1>>c>>S[i].n2>>c>>S[i].w;\n\t\tsort(S.begin(),S.end(),f);\n\n\t\tint a=0;\n\t\twhile(S.size()){\n\t\t\ttmp=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[tmp.n1],c=T[tmp.n2];\n\t\t\tif (b!=c){\n\t\t\t\tfor(i=0;i<n;i++)\n\t\t\t\t\tif(T[i]==c)T[i]=b;\n\t\t\t\ta+=tmp.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <string>\n#include <cstring>\n#include <deque>\n#include <list>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <utility>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <complex>\n#include <cmath>\n#include <limits>\n#include <ctime>\nusing namespace std;\n\n#define rep(i,a,n) for(int i=a; i<n; i++)\n#define repr(i,a,n) for(int i=a; i>=n; i--)\n#define pb(a) push_back(a)\n#define fr first\n#define sc second\n#define INF 999999999\n\n#define X real()\n#define Y imag()\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a) - (b)) < EPS)\n#define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) )\n#define LE(n, m) ((n) < (m) + EPS)\n#define GE(n, m) ((n) + EPS > (m))\n\ntypedef vector<int> VI;\ntypedef vector<VI> MAT;\ntypedef pair<int, int> pii;\ntypedef long long int ll;\n\ntypedef complex<double> P;\ntypedef pair<P, P> L;\ntypedef pair<P, double> C;\n\nint dy[]={0, 0, 1, -1};\nint dx[]={1, -1, 0, 0};\nint const MOD = 1000000007;\n\ntemplate <typename T>\nstruct Edge {\n    int from, to;\n    T cost;\n    Edge(int s, T d) : to(s), cost(d) {}\n    Edge(int f, int s, T d) : from(f), to(s), cost(d) {}\n\n    bool operator<(const Edge &e) const {\n        return cost < e.cost;\n    }\n    bool operator>(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n#define Graph(type) vector< vector< Edge<type> > >\n\n// ????°???¨?????¨(??????)\n// Verified: AOJ GRL_2_A: Minimum Spanning Tree\ntemplate <typename T>\nT prim(vector< vector< Edge<T> > > &G) {\n    int V = G.size(); T ans = 0;\n    vector<bool> used(V, false);\n    priority_queue< Edge<T>, vector< Edge<T> >, greater< Edge<T> > > q;\n    q.push(Edge<T>(0, 0, 0));\n    while(!q.empty()) {\n        Edge<T> temp = q.top(); q.pop();\n        if(used[temp.to]) continue;\n        used[temp.to] = true;\n        ans += temp.cost;\n\n        rep(i,0,G[temp.to].size()) q.push(G[temp.to][i]);\n    }\n    return ans;\n}\n\nint main() {\n    int n, m;\n    while(cin >> n) {\n      if(n == 0) break;\n      cin >> m;\n      Graph(int) g(n);\n      int a,b,d;\n      rep(i,0,m) {\n        scanf(\"%d,%d,%d\", &a, &b, &d);\n        d = d / 100 - 1;\n        g[a].pb(Edge<int>(a,b,d));\n        g[b].pb(Edge<int>(b,a,d));\n      }\n      int ret = prim(g);\n      cout << ret << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<string>\n#include<cmath>\n\nusing namespace std;\n#define MAX_A 200\n#define MAX_E 10100\n\nstruct edge{int s, v, cost;};\n\nint e, v;\nedge es[MAX_E];\nint _rank[MAX_A], par[MAX_A];\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nvoid init(int n){\n\tfor(int i = 0; i < n; i++){\n\t\tpar[i] = i;\n\t\t_rank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x)return x;\n\telse return par[x] = find(par[x]);\n}\n\nint unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(_rank[x] < _rank[y]){\n\t\tpar[x] = y;\n\t} else {\n\t\tpar[y] = x;\n\t\tif(_rank[y] == _rank[x]) _rank[x]++;\n\t}\n}\n\nbool same(int x,int y){\n\treturn find(x) == find(y);\n}\n\nint kraskal(){\n\tsort(es, es+e,comp);\n\t\n\tinit(v);\n\t\n\tint sum = 0;\n\t\n\tfor(int i = 0; i < e; i++){\n\t\tif(same(es[i].s, es[i].v) == false){\n\t\t\t// cout<<es[i].s<<\" \"<<es[i].v<<\" \"<<es[i].cost<<endl;\n\t\t\tsum += (es[i].cost-100)/100;\n\t\t\tunite(es[i].s, es[i].v);\n\t\t}\n\t}\n\treturn sum;\n}\n\nint main(){\n\t\n\twhile(1){\n\t\tstring s, z;\n\t\tchar t;\n\t\tint a[3], count = 0,  size;\n\t\tcin>>v;\n\t\tif(!v)break;\n\t\tcin>>e;\n\t\tfor(int i = 0; i < e; i++){\n\t\t\tcin>>z;\n\t\t\tsize = z.size();\n\t\t\tcount = 0;\n\t\t\tfor(int j = 0; j < size; j++){\n\t\t\t\tt = z[j];\n\t\t\t\tif(t != ',') s += t;\n\t\t\t\tif(t == ',' || j == size-1){\n\t\t\t\t\ta[count++] = stoi(s);\n\t\t\t\t\ts.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t\tes[i].s = a[0];\n\t\t\tes[i].v = a[1];\n\t\t\tes[i].cost = a[2];\n\t\t}\n\t\t\n\t\tcout<<kraskal()<<endl;\n\t\t\n\t}\n\t\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <map>\n#include <sstream>\n#include <queue>\n#include <cstring>\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n#include <stack>\n#include <list>\nusing namespace std;\n#define INF 1000000000\ntypedef long long int lli;\ntypedef pair<int,int> P;\n\nconst int MAX_V=100;\nint cost[MAX_V][MAX_V];\nbool used[MAX_V];\nint mincost[MAX_V];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n){\n\t\tif(n==0) break;\n\t\tcin >>m;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t\tfor(int j=0; j<n; ++j){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tmincost[0]=0;\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint a,b,d;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tcost[a][b]=cost[b][a]=d;\n\t\t}\n\t\tint res=0;\n\t\twhile(true){\n\t\t\tint v=-1;\n\t\t\tfor(int u=0; u<n; ++u){\n\t\t\t\tif(!used[u]&&(v==-1||mincost[v]>mincost[u])) v=u;\n\t\t\t}\n\t\t\tif(v==-1) break;\n\t\t\tused[v]=true;\n\t\t\tres+=mincost[v];\n\t\t\tfor(int u=0; u<n; ++u){\n\t\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t\t}\n\t\t}\n\t\tcout << res/100-n+1 << \"\\n\";\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 100;\n\nstruct edge {\n\tint from_, to_, cost_;\n\tedge() = default;\n\tedge(int from, int to, int cost) :from_(from), to_(to), cost_(cost) {}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost_ < rhs.cost_;\n\t}\n};\n\nint n, m;\nstd::vector<edge> edges;\n\nclass Union {\n\tint par[MAX_N], rank[MAX_N];\npublic:\n\tUnion() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x])\n\t\t\treturn x;\n\t\tpar[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y])\n\t\t\tstd::swap(x, y);\n\t\tpar[y] = x;\n\t\trank[x] += rank[y];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (!n)\n\t\t\tbreak;\n\t\tstd::cin >> m;\n\t\tUnion uni;\n\t\tedges.clear();\n\t\tint a, b, d;\n\t\tchar ch;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> ch >> b >> ch >> d;\n\t\t\td /= 100;\n\t\t\t--d;\n\t\t\tedges.emplace_back(a, b, d);\n\t\t}\n\n\t\tstd::sort(edges.begin(), edges.end());\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (!uni.same(edges[i].from_, edges[i].to_)) {\n\t\t\t\tuni.unite(edges[i].from_, edges[i].to_);\n\t\t\t\tans += edges[i].cost_;\n\t\t\t\tstd::cout << edges[i].cost_ << std::endl;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\ninline int to_int(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string to_str(T x) {ostringstream sout; sout << x; return sout.str();}\n\ntypedef long long ll;\nconst int INF = 1 << 28;\n\nint main()\n{\n\tint dist[101][101], mincost[101];\n\tbool used[101];\n\n\tint n, m;\n\tint a, b, c;\n\n\twhile(cin >> n ,n)\n\t{\n\t\tint total = 0;\n\t\tcin >> m;\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tdist[i][j] = INF;\n\n\t\t\t\tif(i == j)\n\t\t\t\t{\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[i] = false;\n\t\t\tmincost[i] = INF;\n\t\t}\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d%*c%d%*c%d\", &a, &b, &c);\n\t\t\tc /= 100; c -= 1;\n\t\t\tdist[a][b] = c; dist[b][a] = c;\n\t\t}\n\n\t\tmincost[0] = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tint v = -1;\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v])) v = i;\n\t\t\t}\n\t\t\tif(v == -1)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tused[v] = true;\n\t\t\ttotal += mincost[v];\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tmincost[i] = min(mincost[i], dist[v][i]);\n\t\t\t}\n\t\t}\n\t\n\t\tcout << total << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n\n#define N 100 //史跡の数\n\nint main(void) {\n\tint n, m;\n\tint a, b, d;\n\tint road[N][N]; //添え字から添え字への距離を1/100に縮小したもの\n\tbool ruin[N]; //通った史跡はtrue\n\tint count; //通った史跡の数\n\tint ans; //灯篭の数\n\tint min_a, min_b;\n\t\n\twhile(true) {\n\t\tcin >> n;\n\t\tif(n == 0) break;\n\t\t\n\t\t//初期化\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\troad[i][j] = INT_MAX;\n\t\t\t}\n\t\t\truin[i] = false;\n\t\t}\n\t\tcount = 0;\n\t\tans = 0;\n\t\t\n\t\tcin >> m;\n\t\t\n\t\tfor(int i = 0; i < m; ++i) {\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\troad[a][b] = road[b][a] = d / 100;\n\t\t}\n\t\t\n\t\truin[0] = true; //始点は0\n\t\t++count; //始点をカウント\n\t\twhile(count != n) {\n\t\t\tmin_a = min_b = 0; //road[0][0]はINT_MAXだから番兵として利用\n\t\t\tfor(int i = 0; i < n; ++i) {\n\t\t\t\tif(ruin[i]) {\n\t\t\t\t\tfor(int j = 0; j < n; ++j) {\n\t\t\t\t\t\tif(road[i][j] < road[min_a][min_b] && !ruin[j]) {\n\t\t\t\t\t\t\tmin_a = i;\n\t\t\t\t\t\t\tmin_b = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tans += road[min_a][min_b] - 1;\n\t\t\truin[min_b] = true;\n\t\t\t++count;\n\t\t\troad[min_a][min_b] = road[min_b][min_a] = INT_MAX;\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint V, E;\nvector<vector<edge>> es;\nbool used[10000];\n\npair<int, vector<edge>> prim()\n{\n\tmemset(used, false, sizeof(used));\n\tvector<edge> res;\n\tint sum = 0;\n\n\tpriority_queue<edge, vector<edge>, greater<edge>> que;\n\tque.push(edge{ -1, 0, 0 });\n\n\twhile (!que.empty())\n\t{\n\t\tedge e = que.top(); que.pop();\n\t\tif (used[e.to]) continue;\n\t\tif (e.from >= 0) res.push_back(e);\n\t\tsum += e.cost;\n\t\tused[e.to] = true;\n\t\tfor (edge i : es[e.to])\n\t\t{\n\t\t\tif (!used[i.to]) que.push(i);\n\t\t}\n\t}\n\treturn pair<int, vector<edge>>(sum, res);\n}\n\nint main()\n{\n\twhile (cin >> V >> E, V)\n\t{\n\t\tes.clear();\n\t\tes.resize(V);\n\t\tREP(i, E)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tes[a].push_back(edge{ a, b, c });\n\t\t\tes[b].push_back(edge{ b, a, c });\n\t\t}\n\t\tcout << prim().first / 100 - (V - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\n#define MAX_V 111\n#define INF 2147483647\n\nint cost[MAX_V][MAX_V]={{}};\nint mincost[MAX_V]={};\nbool used[MAX_V]={};\nint V;\n\n\nint prim(void);\nint min(int a,int b);\n\nint main(){\n  int m;\n\n  scanf(\"%d\",&V);\n\n  while(1){\n    if(V==0) break;\n    scanf(\"%d\",&m);\n    \n    /*\n    for(int i=0;i<m;i++){\n      for(int j=0;j<m;j++){\n\tcost[i][j]=INF;\n      }\n      }*/\n    \n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b] = c/100 - 1;\n      cost[b][a] = c/100 - 1;\n    }\n    \n    printf(\"%d\\n\",prim());\n    \n    scanf(\"%d\",&V);\n  }\n  \n  return 0;\n}\n\nint min(int a,int b){\n  if(a>b) return b;\n  return a;\n}\n\nint prim(void){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(!used[u] && (v==-1 || mincost[u] <  mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for(int u = 0;u < V;u++){\n      if(cost[v][u]==0);\n      else mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\nusing namespace std;\n\ntypedef pair<int, int> edge;\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tvector<edge> edges[100];\n\t\tbool inTree[100];\n\t\tfill(inTree, inTree+100, false);\n\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tedges[a].push_back(edge(c, b));\n\t\t\tedges[b].push_back(edge(c, a));\n\t\t}\n\n\t\tint res = 0;\n\n\t\tpriority_queue<int, vector<edge>, greater<edge> > q;\n\t\tinTree[0] = true;\n\t\tfor (int i = 0; i < edges[0].size(); ++i)\n\t\t\tq.push(edges[0][i]);\n\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tedge e = q.top();\n\t\t\tq.pop();\n\t\t\tif (inTree[e.second])\n\t\t\t\tcontinue;\n\n\t\t\tinTree[e.second] = true;\n\t\t\tres += e.first / 100 - 1;\n\t\t\tfor (int i = 0; i < edges[e.second].size(); ++i)\n\t\t\t\tq.push(edges[e.second][i]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 10000;\nconst int INF = 999999;\n\nint V;\nint m;\n\nint prim (vector<vector<P> > G) {\n    set<int> used;\n    priority_queue<P, vector<P>, greater<P> > que;\n    for (int i = 0; i < V; i++) {\n        used.insert(i);\n    }\n    int res = 0;\n    int v = 0;\n    while (!used.empty()) {\n        for (auto i : G[v])   que.push(i);\n        P p;\n        while (used.find(que.top().second) == used.end() || que.top().second == v) {\n            que.pop();\n            if (que.empty()) break;\n        }\n        if (que.empty()) break;\n        used.erase(used.find(v));\n        p = que.top(); que.pop();\n        v = p.second;\n        res += p.first;\n    }\n\n    return res;\n}\n\nint main ()\n{\n    while (cin >> V, V) {\n        cin >> m;\n        vector<vector<P> >  G(V);\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            c /= 100;\n            G[a].push_back(P(c,b));\n            G[b].push_back(P(c,a));\n        }\n\n        cout << prim(G) - V + 1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <utility>\n#include <cstdio>\nusing namespace std;\n\ntypedef pair<int, int> ii;\n\nstruct Node {\n    bool d;\n    vector<ii> tos;\n};\n\nint n;\nvector<Node> ns;\n\nint prim() {\n    for (int i = 0; i < n; i++) {\n        ns[i].d = false;\n    }\n    priority_queue<ii, vector<ii>, greater<ii> > q;\n    q.push(make_pair(0, 0));\n    int ans = 0;\n    while (!q.empty()) {\n        ii p = q.top();\n        q.pop();\n        int i = p.second;\n        if (ns[i].d) {\n            continue;\n        }\n        ns[i].d = true;\n        ans += p.first;\n        for (vector<ii>::iterator it = ns[i].tos.begin(); it != ns[i].tos.end(); it++) {\n            q.push(make_pair(it->second, it->first));\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (cin >> n, n) {\n        ns.clear();\n        ns.resize(n);\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            c = c / 100 - 1;\n            ns[a].tos.push_back(make_pair(b, c));\n            ns[b].tos.push_back(make_pair(a, c));\n        }\n        cout << prim() << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nconst double EPS = 1e-9;\nconst int INF = 1<<28;\nconst double PI = acos(-1.0);\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nbool vpos(int x,int y,int w,int h){return 0<=x&&x<w&&y>=0&&y<h;}\n\ntypedef pair<int,pair<int,int> > E;\n\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int n){\n        REP(i,n)par.push_back(i);\n    }\n\n    int find(int x){\n        if(par[x]==x)return x;\n        return par[x] = find(par[x]);\n    }\n\n    void union_(int x,int y){\n        x = find(x);\n        y = find(y);\n        par[x] = y;\n    }\n\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nint main(){\n    for(;;){\n        int n,m;\n        vector<E> es;\n        cin >> n >> m;\n        if(!n)break;\n        UnionFind uf(n);\n        REP(i,m){\n            char conma;\n            int a,b,d;\n            cin >> a >> conma >> b >> conma >> d;\n            es.PB(MP(d,MP(a,b)));\n        }\n        int sum = 0;\n        sort(ALL(es));\n        for(int i=0;i<m;i++){\n            E e = es[i];\n            int a = e.second.first;\n            int b = e.second.second;\n            int d = e.first;\n            if(uf.same(a,b))continue;\n            uf.union_(a,b);\n            sum+=d/100-1;\n        }\n        cout << sum << endl;\n        return 0;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\n#define MAX_V 111\n#define INF 11111111\n\nint cost[MAX_V][MAX_V]={{}};\nint mincost[MAX_V]={};\nbool used[MAX_V]={};\nint V;\n\n\nint prim(void);\nint min(int a,int b);\n\nint main(){\n  int m;\n\n  scanf(\"%d\",&V);\n\n  while(1){\n    if(V==0) break;\n    scanf(\"%d\",&m);\n    \n    /*\n    for(int i=0;i<m;i++){\n      for(int j=0;j<m;j++){\n\tcost[i][j]=INF;\n      }\n      }*/\n    \n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b] = c/100 - 1;\n      cost[b][a] = c/100 - 1;\n    }\n    \n    printf(\"%d\\n\",prim());\n    \n    scanf(\"%d\",&V);\n  }\n  \n  return 0;\n}\n\nint min(int a,int b){\n  if(a>b) return b;\n  return a;\n}\n\nint prim(void){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(!used[u] && (v==-1 || mincost[u] <  mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for(int u = 0;u < V;u++){\n      if(cost[v][u]==0);\n      else mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\nusing namespace std;\n\nstruct Path{\n  int a;\n  int b;\n  int d;\n\n  bool operator<(const Path &another) const{\n    return d<another.d;\n  }\n}typedef path;\n\nint main(void){\n  int n;\n  int m;\n  int a,b,d;\n  vector<path> p;\n  int lantern;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cin>>m;\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&d);\n      path _p;\n      _p.a=a;\n      _p.b=b;\n      _p.d=d;\n      p.push_back(_p);\n    }\n    int group[n];\n    for(int i=0;i<n;i++){\n      group[i]=i;\n    }\n    lantern=0;\n    sort(p.begin(),p.end());\n    for(int i=0;i<m;i++){\n      if(group[p[i].a]!=group[p[i].b]){\n        lantern+=p[i].d/100-1;\n        int g=group[p[i].a];\n        for(int j=0;j<n;j++){\n          if(group[j]==g){\n            group[j]=group[p[i].b];\n          }\n        }\n      }\n\n    }\n    cout<<lantern<<endl;\n    p.clear();\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<(int)n;i++)\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rrep(i,n) for(int i = 1; i <= n; i++)\n#define drep(i,n) for(int i = n; i >= 0; i--)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nint chmax(int& a,int b){\n\tif(b > a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nint chmin(int& a,int b){\n\tif(b < a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nstruct edge{\n\tint to;\n\tint cost;\n\tedge(int t,int c):to(t),cost(c){}\n\n};\nvector<vector<edge> >l(101);\nint d[101];\nint used[101];\n\nint N;\nint M;\n\nint main(){\n\twhile(cin >> N,N){\n\t\tcin >> M;\n\t\trep(i,101){\n\t\t\tused[i]=0;\n\t\t\td[i]=inf;\n\t\t\tl[i].clear();\n\t\t}\n\t\trep(i,M){\n\t\t\tchar tmp;\n\t\t\tint a,b,c;\n\t\t\tcin >> a >> tmp >> b >> tmp >> c;\n\t\t\tl[a].pb(edge(b,c/100-1));\n\t\t\tl[b].pb(edge(a,c/100-1));\n\t\t}\n\t\tpriority_queue<pii,vector<pii>,greater<pii> >q;\n\t\tq.push(mp(0,0));\n\t\tint ans=0;\n\t\twhile(!q.empty()){\n\t\t\tint c=q.top().first,u=q.top().second;q.pop();\n\t\t\tif(d[u]==inf){\n\t\t\t\td[u]=c;\n\t\t\t\tans+=c;\n\t\t\t}\n\t\t\trep(i,l[u].size()){\n\t\t\t\tedge &now=l[u][i];\n\t\t\t\tif(d[now.to]==inf){\n\t\t\t\t\tq.push(mp(now.cost,now.to));\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\n\n\n\n\n\treturn 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\n#include<cassert>\n#include<iostream>\n#include<sstream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<set>\n#include<map>\n#include<utility>\n#include<numeric>\n#include<algorithm>\n#include<bitset>\n#include<complex>\n#include<stack>\n\nusing namespace std;\n\ntypedef long long Int;\ntypedef vector<int> vint;\ntypedef pair<int,int> pint;\n#define mp make_pair\n\ntemplate<class T> void pv(T a, T b) { for (T i = a; i != b; ++i) cout << *i << \" \"; cout << endl; }\ntemplate<class T> void chmin(T &t, T f) { if (t > f) t = f; }\ntemplate<class T> void chmax(T &t, T f) { if (t < f) t = f; }\nint in() { int x; scanf(\"%d\", &x); return x; }\n\nint way[110][110];\nbool used[110];\nint main() {\n\tint n,m;\n\twhile(n=in()){\n\t\tm=in();\n\t\tint i,j;\n\t\tfor(i=0;i<110;i++){\n\t\t\tfor(j=0;j<110;j++){\n\t\t\t\tway[i][j]=1000000000;\n\t\t\t}\n\t\t\tway[i][i]=0;\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tint a,b,d;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tchmin(way[a][b],d/100-1);\n\t\t\tchmin(way[b][a],d/100-1);\n\t\t}\n\t\t/*for(i=0;i<n;i++){\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\tcout<<way[i][j]<<\" \";\n\t\t\t}\n\t\t\tcout<<endl;\n\t\t}\n\t\t*/\n\t\tfor(i=0;i<110;i++){\n\t\t\tused[i]=false;\n\t\t}\n\t\tpriority_queue<pint,vector<pint>,greater<pint> > que;\n\t\tint res=0;\n\t\tque.push(pint(0,0));\n\t\twhile(!que.empty()){\n\t\t\tpint p=que.top();\n\t\t\tque.pop();\n\t\t\tint v=p.second;\n\t\t\tif(used[v])continue;\n\t\t\tres+=p.first;\n\t\t\tused[v]=true;\n//cout<<\"v:\"<<v<<endl;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(way[v][i]!=1000000000&&v!=i&&!used[i]){\n\t\t\t\t\tque.push(pint(way[v][i],i));\n//cout<<\"i:\"<<i<<endl;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 10e6\nint cost[100][100];\nbool used[100];\nint mincost[100];\nint n,m;\n\nint prim(){\n\tfor(int i=0;i<n;i++){\n\t\tmincost[i]=INF;\n\t\tused[100]=false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!used[i]&&(v==-1||mincost[i]<mincost[v])) v=i;\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tmincost[i]=min(mincost[i],cost[i][v]);\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint a,b,d,result;\n\tchar tem;\n\twhile(cin >> n,n){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j]=(i==j)?0:INF;\n\t\tcin >> m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> tem >> b >> tem >> d;\n\t\t\tcost[a][b]=cost[b][a]=d/100-1;\n\t\t}\n\t\tresult=prim();\t\n\t\tcout << result << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\n#define MAX_V 100\n#define INF 99999\n\nint prim(void);\n\nint cost[MAX_V][MAX_V]; //cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint mincost[MAX_V]; //集合Xからの最小コスト\nbool used[MAX_V]; //頂点iがxに含まれているか\nint m; //頂点数\n\nusing namespace std;\n\nint main(){\n  int n,i,c,j,a,b;\n  \n  while(1){\n    scanf(\"%d\",&n); if(n==0) break;\n scanf(\"%d\",&m);\n    for(j=0;j<m;j++){\n      for(i=0;i<m;++i){\n\tcost[j][i]=INF;\n      }\n    }\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d\",&a,&b); scanf(\",%d\",&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    printf(\"%d\\n\",prim());\n    \n  }\n  \n}\n\nint prim(){\n  \n  //初期化\n  for(int i=0;i<m;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(true){\n    int v=-1;\n    //xに属さない頂点のうちxからの辺のコストが最小になる頂点を探す\n    for(int u=0;u<m;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    \n    used[v]=true; //頂点vをxに追加\n    res+=mincost[v]; //辺のコストを比べる\n    \n    for(int u=0;u<m;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<map>\n#include<vector>\nusing namespace std;\nint main(){\n  int n;\n  while(cin >>n,n){\n    int m,ans = 0;\n    vector<pair<int,pair<int,int> > > P;\n    bool done[100]={false};\n    cin >>m;\n    for(int i=0,a,b,c; i<m; i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      P.push_back(make_pair(c,make_pair(a,b)));\n    }\n    sort(P.begin(),P.end());\n    ans+=(P[0].first/100)-1;\n    done[P[0].second.first] = done[P[0].second.second] = true;\n    for(int i=0; i<n-1; i++){\n      for(int j=0; j<m; j++){\n\tif(done[P[j].second.first]^done[P[j].second.second]){\n\t  ans+=(P[j].first/100)-1;\n\t  done[P[j].second.first] = done[P[j].second.second] = true;\n\t  break;\n\t}\n      }\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n// ????????????????????£?¨?\nint kruskal(priority_queue<pair<int, pair<int, int> > > edge, int v);\n\n// ?????????\nint main(void){\n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n;\n    if(n == 0){ break; }\n    cin >> m;\n    \n    // ???????????±??????????????????????????????????????\\????????????\n    priority_queue<pair<int, pair<int, int> > > edge;\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      edge.push(make_pair(-d, make_pair(a, b)));\n    }\n  \n    // ????°???¨?????¨????????????????±??????????????????????\n    int length = kruskal(edge, n);\n    cout << length / 100 - n + 1 << endl;\n  }\n\n  return 0;\n}\n\n// UnionFind??¨\nclass UnionFindTree{\nprivate:\n  vector<int> parent;\n  vector<int> rank;\n  int find(int a);\npublic:\n  void init(int size);\n  void unite(int a, int b);\n  bool isSameTree(int a, int b);\n};\n\n// UF??¨????????????\nvoid UnionFindTree::init(int size){\n  parent.clear();\n  rank.clear();\n  for(int i = 0; i < size; i++){\n    parent.push_back(i);\n    rank.push_back(0);\n  }\n  return; \n}\n\n// UF??¨?????????????????????\nint UnionFindTree::find(int a){\n  if(parent[a] != a){ parent[a] = find(parent[a]); }\n  return parent[a];\n}\n\n// UF??¨??§???????????£?????????\nvoid UnionFindTree::unite(int a, int b){\n  int x = find(a);\n  int y = find(b);\n  // ?????§???????????£???????????????????????????\n  if(x == y){ return; }\n\n  if(rank[x] < rank[y]){ parent[x] = y; }\n  else{\n    parent[y] = x;\n    if(rank[x] == rank[y]){ rank[x]++; }\n  }\n  return;\n}\n\n// UF??¨??§???????????????????????????????????????\nbool UnionFindTree::isSameTree(int a, int b){\n  return find(a) == find(b);\n}\n\n// ??????????????????\n// ?????°: ??????????????????????????????????????????????????\\???(first: -?????????, second: to-front), ????????°\n// ?????????: ??¨????????????\nint kruskal(priority_queue<pair<int, pair<int, int> > > edge, int v){\n  int length = 0; // ??¨????????????\n\n  // UF??¨?????£?¨???¨?????????\n  UnionFindTree uf;\n  uf.init(v);\n\n  // ?????????????????????\n  while(!edge.empty()){\n    // ????£????????????????????°?????????????????????????\n    int cost = -edge.top().first;\n    int a = edge.top().second.first;\n    int b = edge.top().second.second;\n    edge.pop();\n    // ????????????????????????????????£????????????????£???°???\n    if(uf.isSameTree(a, b)){ continue; }\n\n    // UF??¨?????£??????????????????????????´??°\n    length += cost;\n    uf.unite(a, b);\n  }\n  \n  return length;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nusing lint = long long;\n\nclass UnionFind{\n    vector<int> par;\n    vector<long long> wei;\n    int groupCount;\n\npublic:\n    UnionFind(int n = 0){\n        init(n);\n    }\n\n    void init(int n = 0){\n        par.resize(n);\n        fill(par.begin(), par.end(), -1);\n\n        wei.resize(n);\n        fill(wei.begin(), wei.end(), 0LL);\n\n        groupCount = n;\n\n        return;\n    }\n\n    int root(int x){\n        if(par[x] < 0){\n            return x;\n        }\n        int r = root(par[x]);\n        wei[x] += wei[par[x]];\n        return par[x] = r;\n    }\n\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n\n    int size(int x){\n        return -par[root(x)];\n    }\n\n    long long weight(int x){\n        root(x);\n        return wei[x];\n    }\n\n    long long diff(int x, int y){\n        return weight(y) - weight(x);\n    }\n\n    bool unite(int x, int y, long long w = 0){\n        w += weight(x) - weight(y);\n\n        x = root(x);\n        y = root(y);\n\n        if(x == y){\n            return false;\n        }\n\n        if(par[y] < par[x]){\n            swap(x, y);\n            w = -w;\n        }\n\n        par[x] += par[y];\n        par[y] = x;\n        wei[y] = w;\n        --groupCount;\n\n        return true;\n    }\n\n    int size(void){\n        return groupCount;\n    }\n};\n\nstruct edge{\n    int from, to;\n    lint cost;\n\n    bool operator<(const edge& rhs) const {\n        return cost < rhs.cost;\n    }\n};\n\nint main(){\n    int n;\n    while(cin >> n, n){\n        int m;\n        cin >> m;\n\n        vector<edge> es;\n        for(int i = 0 ; i < m ; ++i){\n            int a, b;\n            lint d;\n            char c;\n            cin >> a >> c >> b >> c >> d;\n            es.push_back({a, b, d / 100LL - 1LL});\n        }\n\n        sort(es.begin(), es.end());\n        UnionFind uf(n);\n        lint ans = 0;\n        for(int i = 0 ; i < m ; ++i){\n            if(uf.unite(es[i].from, es[i].to)){\n                ans += es[i].cost;\n            }\n        }\n\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SORT(a) sort(a.begin(), a.end())\n#define RSORT(a) sort(a.rbegin(), a.rend())\n#define REP(i, n) for (int i = 0; i < n; i++)\n#define FOR(i, start, end) for (int i = start; i < end; i++)\n#define ALL(a) a.begin(), a.end()\n#define MOD(a) a %= 1'000'000'007\nusing ll = long long;\nusing namespace std;\nconst int INF32       = 1'050'000'000;\nconst long long INF64 = 4'000'000'000'000'000'000;\nconst int MOD7        = 1'000'000'007;\nconst int MOD9        = 1'000'000'009;\ntemplate <class T> inline bool chmin(T &a, T b) {\n    if (a > b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\ntemplate <class T> inline bool chmax(T &a, T b) {\n    if (a < b) {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nclass UnionFind {\n  public:\n    // 親の番号を格納する。親の場合 -1 になる\n    vector<int> Parent;\n\n    // 宣言されたとき Parent の値はすべて -1 にする\n    UnionFind(int N) { Parent = vector<int>(N, -1); }\n\n    // 与えられた値 x がどの親であるか調べる\n    int root(int x) {\n        if (Parent[x] < 0)\n            return x;\n        return Parent[x] = root(Parent[x]);\n    }\n\n    // 木の全体の数を返す\n    int size(int x) { return -Parent[root(x)]; }\n\n    // 2つの引数を同じ親にする\n    bool update(int x, int y) {\n        x = root(x);\n        y = root(y);\n        if (x == y)\n            return false;\n        if (size(x) < size(y))\n            swap(x, y);\n        Parent[x] += Parent[y];\n        Parent[y] = x;\n        return true;\n    }\n\n    // 引数の親が同じか判定する\n    bool is_same(int x, int y) { return root(x) == root(y); }\n};\n\n// 最小全域木\nclass Kruskal {\n  private:\n    struct Edge {\n        int u, v, cost;\n    };\n    int vertex_max, edge_max;\n    long long cost_sum = 0;\n    vector<Edge> edge;\n\n  public:\n    Kruskal(int edge_in, int vertex_in) {\n        edge_max   = edge_in;\n        vertex_max = vertex_in;\n    }\n    // 辺を追加する\n    void update(int u, int v, int c) { edge.push_back({u, v, c}); }\n    // 最小全域木を求める。そのときの最小コストを返す。\n    long long cal() {\n        sort(edge.begin(), edge.end(),\n             [](const Edge e1, const Edge e2) { return e1.cost < e2.cost; });\n        auto uni = UnionFind(vertex_max);\n        for (int i = 0; i < edge_max; i++) {\n            auto e = edge[i];\n            if (!uni.is_same(e.u, e.v)) {\n                uni.update(e.u, e.v);\n                cost_sum += (long long)e.cost;\n            }\n        }\n        return cost_sum;\n    };\n};\n\nint main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    int N, M;\n    while (true) {\n        cin >> N;\n        if (N == 0)\n            break;\n        cin >> M;\n        auto kr = Kruskal(M, N);\n        REP(i, M) {\n            int a, b, d;\n            char c;\n            cin >> a >> c >> b >> c >> d;\n            d -= 100;\n            kr.update(a, b, d);\n        }\n        auto sum = kr.cal();\n        std::cout << sum / 100 << '\\n';\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <stack>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <cmath>\n#include <cstring>\n#include <cstdio>\n#include <queue>\n#include <bitset>\n\n#define rep(i, n) for(int i = 0; i < (n); i++)\n#define FOR(i, a, n) for(int i = (a); i < (n); i++)\n#define MP make_pair\n#define all(s) (s).begin(), (s).end()\n#define rev(s) (s).rbegin(), (s).rend()\n#define X first\n#define Y second\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> P;\n\nstruct edge{\n\tint to;\n\tint cost;\n\tedge(int t, int c){to=t; cost=c;}\n\tbool operator<(const edge &r)const{\n\t\treturn cost>r.cost;\n\t}\n};\n\nint main(){\n\tint n, m;\n\twhile(cin >> n, n){\n\t\tcin >> m;\n\n\t\tvector<vector<edge> > G(n);\n\t\trep(i, m){\n\t\t\tint cost, from, to;\n\t\t\tchar c;\n\t\t\tcin >> from >> c >> to >> c >> cost;\n\t\t\tG[from].push_back(edge(to, cost));\n\t\t\tG[to].push_back(edge(from, cost));\n\t\t}\n\n\t\tpriority_queue<edge> q;\n\t\trep(i, G[0].size()){\n\t\t\tq.push(G[0][i]);\n\t\t}\n\t\tvector<int> v;\n\t\tv.push_back(0);\n\n\t\tint sum = 0;\n\t\twhile(v.size() < G.size()){\n\t\t\tedge e = q.top();\n\t\t\tq.pop();\n\t\t\tif( find(all(v), e.to) != v.end()) continue;\n\t\t\tv.push_back(e.to);\n\t\t\tsum += e.cost/100-1;\n\n\t\t\trep(i, G[e.to].size()){\n\t\t\t\tq.push(G[e.to][i]);\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\n\t}\n\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\n#define MAX_V 111\n#define INF 11111111\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\n\nint prim(void);\nint min(int a,int b);\n\nint main(){\n  int m;\n\n  scanf(\"%d\",&V);\n\n  while(1){\n    if(V==0) break;\n    scanf(\"%d\",&m);\n    \n    for(int i=0;i<m;i++){\n      for(int j=0;j<m;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    \n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b] = c/100 - 1;\n      cost[b][a] = c/100 - 1;\n    }\n    \n    int x;\n    \n    x = prim();\n    \n    \n    printf(\"%d\\n\",x);\n    \n    scanf(\"%d\",&V);\n  }\n  \n  return 0;\n}\n\nint min(int a,int b){\n  if(a>b) return b;\n  return a;\n}\n\nint prim(void){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(!used[u] && (v==-1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for(int u = 0;u < V;u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\ninline int to_int(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string to_str(T x) {ostringstream sout; sout << x; return sout.str();}\n\ntypedef long long ll;\nconst int INF = 1 << 28;\n\nint main()\n{\n\tint dist[101][101], mincost[101];\n\tbool used[101];\n\n\tint n, m;\n\tint a, b, c;\n\n\twhile(cin >> n ,n)\n\t{\n\t\tint total = 0;\n\t\t\n\t\tcin >> m;\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t{\n\t\t\t\tdist[i][j] = INF;\n\n\t\t\t\tif(i == j)\n\t\t\t\t{\n\t\t\t\t\tdist[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tused[i] = false;\n\t\t\tmincost[i] = INF;\n\t\t}\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tscanf(\"%d%*c%d%*c%d\", &a, &b, &c);\n\t\t\tc /= 100; c -= 1;\n\t\t\tdist[a][b] = c; dist[b][a] = c;\n\t\t}\n\n\t\tmincost[0] = 0;\n\n\t\twhile(1)\n\t\t{\n\t\t\tint v = -1;\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v])) v = i;\n\t\t\t}\n\t\t\tif(v == -1)\n\t\t\t{\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tused[v] = true;\n\t\t\ttotal += mincost[v];\n\n\t\t\tfor(int i = 0; i < n; i++)\n\t\t\t{\n\t\t\t\tmincost[i] = min(mincost[i], dist[v][i]);\n\t\t\t}\n\t\t}\n\t\n\t\tcout << total << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef struct{\n\tint cost,v,u,par;\n}wa;\nwa way[10000];\nint compare(const wa& a,const wa& b){\n\treturn a.cost<b.cost;\n}\nint find(int t){\n\tif(way[t].par==t)\n\treturn t;\n\telse return find(way[t].par);\n}\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tway[x].par=find(way[y].par);\n}\nint main(){\n\tint n,m,ans,x,y,c,num;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\tans=0;\n\t\tnum=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&x,&y,&c);\n\t\t\tway[i].v=x;\n\t\t\tway[i].u=y;\n\t\t\tway[i].cost=c;\n\t\t}\n\t\tsort(way,way+m,compare);\n\t\tfor(int i=0;i<m;i++)\n\t\t\tway[i].par=i;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!same(way[i].v,way[i].u)){\n\t\t\tunite(way[i].v,way[i].u);\n\t\t\t\tnum++;\n\t\t\tans+=way[i].cost;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\n\t\tcout<<ans/100-num<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstring>\n#include <algorithm>\n\nusing namespace std;\n\n#define INF 1<<30\n\nstruct node{\n  int cost, num;\n  node(int c, int n): cost(c), num(n){}\n  bool operator >(const node &e) const{\n\treturn cost > e.cost;\n  }\n\n};\n\nint main(void){\n  int n;\n  int m;\n  int n1,n2,c;\n\n  while(1){\n\tcin >> n;\n\tif(n == 0) break;\n\n\tbool visited[n];\n\tmemset(visited, false, sizeof(visited));\n\tint cost[n][n];\n\tfill((int *)cost, (int *)cost+n*n, INF);\n\tbool used[n];\n\tfill(used, used+n, false);\n\tpriority_queue<node, vector<node>, greater<node> > q;\n\tint ret=0;\n\n\tcin >> m;\n\n\tfor(int i=0;i<m;i++){\n\t  cin >> n1; cin.ignore();\n\t  cin >> n2; cin.ignore();\n\t  cin >> c;\n\n\t  cost[n1][n2] = c / 100 - 1;\n\t  cost[n2][n1] = c / 100 - 1;\t\n\t}\n\tq.push(node(0,0));\n\twhile(!q.empty()){\n\t  node tmp = q.top(); q.pop();\n\t  //cout << \"poped: from \" << tmp.num << \" cost \" << tmp.cost << endl;\n\n\t  if(used[tmp.num] == true) continue;\n\t  used[tmp.num] = true;\n\t  ret += tmp.cost;\n\n\t  for(int i=0;i<n;i++){\n\t\tif(cost[tmp.num][i] != INF){\n\t\t  q.push(node(cost[tmp.num][i], i));\n\t\t}\n\t  }\n\t}\n\tcout << ret << endl;\n  }\t\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w > e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\n//????°???¨?????¨\n//Prim O(ElogV)\n//r????????°?????????????????????????±?\n//Edge??? bool operator<(const Edge &e)const { return w > e.w; } ????????????????????????\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n\tEdges T; Weight total = 0; vector<int> v(g.size());\n\tpriority_queue <Edge> q;\n\tq.push(-1, r, 0);\n\twhile (q.size()) {\n\t\tEdge e = q.top(); q.pop();\n\t\tif (v[e.d]) continue;\n\t\tv[e.d] = true;\n\t\ttotal += e.w; if (e.s != -1) T.push_back(e);\n\t\tfor (auto &f : g[e.d]) if (!v[f.d]) q.push(f);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].push_back(Edge(a, b, d));\n\t\t\tg[b].push_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = prim(g, 0);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef struct{\n\tint cost,v,u,par;\n}wa;\nwa way[120];\nint compare(const wa& a,const wa& b){\n\treturn a.cost<b.cost;\n}\nint find(int t){\n\tif(way[t].par==t)\n\treturn t;\n\telse return find(way[t].par);\n}\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tway[x].par=find(way[y].par);\n}\nint main(){\n\tint n,m,ans,x,y,c,num;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\tans=0;\n\t\tnum=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&x,&y,&c);\n\t\t\tway[i].v=x;\n\t\t\tway[i].u=y;\n\t\t\tway[i].cost=c;\n\t\t}\n\t\tsort(way,way+m,compare);\n\t\tfor(int i=0;i<m;i++)\n\t\t\tway[i].par=i;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!same(way[i].v,way[i].u)){\n\t\t\tunite(way[i].v,way[i].u);\n\t\t\t\tnum++;\n\t\t\tans+=way[i].cost;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\n\t\tcout<<ans/100-num<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 100;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\tint n, m;\n\tcin >> n >> m;\n\t\n\tstring str;\n\tfor(int i = 0; i != n; ++i){\n\t\tint abc[3] = {};\n\t\tcin >> str;\n\t\tint count = 0;\n\t\tfor(size_t i = 0; i != str.size(); ++i){\n\t\t\tif(str[i] == ',')\n\t\t\t\tcount++;\n\t\t\telse {\n\t\t\t\tabc[count] *= 10;\n\t\t\t\tabc[count] += str[i] - '0';\n\t\t\t}\n\t\t}\n\t\t/*cout << abc[0] << endl;\n\t\tcout << abc[1] << endl;\n\t\tcout << abc[2] << endl;*/\n\t\te.push_back(Edge{abc[0], abc[1], abc[2]});\n\t}\n\t\n\tfor(int i = 0; i != n; ++i){\n\t\tpar[i] = i;\n\t\trank_[i] = 0;\n\t}\n\t\n\tsort(e.begin(), e.end(), comp);\n\t\n\tint ans = 0;\n\tfor(int i = 0; i != n; ++i){\n\t\tif(!same(e[i].from, e[i].to)){\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tif(e[i].cost % 100 == 0)\n\t\t\t\tans += e[i].cost / 100 -1;\n\t\t\telse\n\t\t\t\tans += e[i].cost / 100;\n\t\t}\n\t}\n\t\n\tcout << ans << endl;\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint G[102][102];\nint NG[102][102];\nbool used[102];\nconst int INF=9999999;\nint main(){\n\tint n,m,ans=0;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tcin>>m;\n\tans=0;\n\tfor(int i=0;i<102;i++)for(int j=0;j<102;j++)G[i][j]=INF,used[i]=false,NG[i][j]=INF;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar x;\n\t\tcin>>a>>x>>b>>x>>c;\n\t\t//if(a==b){cout<<\"x\";return 0;}\n\t\tG[a][b]=c;\n\t}\n\tint u,v,a,b;\n\tused[0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tv=-1;\n\t\tfor(int j=0;j<n;j++)if(!used[j])v=1;\n\t\tif(v==-1)break;\n\t\tint mi=INF;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\tif(mi>G[j][k]&&used[j]==1&&used[k]==0)mi=G[j][k],a=j,b=k;\n\t\t\t}\n\t\t}\n\t\tused[b]=1;\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\t//for(int i=0;i<n;i++)cout<<used[i]<<\" \";cout<<endl;\n\t\tNG[a][b]=G[a][b];\n\t\tans+=G[a][b]-100;\n\t}\n//for(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<G[i][j]<<\" \";cout<<endl;}\n//\tfor(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<NG[i][j]<<\" \";cout<<endl;}\n\t//for(int i=0;i<n;i++)for(int j=0;j<n;j++)ans+=NG[i][j];\n\tcout<<ans/100<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\ntypedef pair<int, int> PII;\n\nint solve(int n, int m, const vector<vector<int> > edges) {\n  priority_queue<PII, vector<PII>, greater<PII> > pq;\n  vector<bool> visited(n, false);\n\n  int sum = 0;\n  pq.push(make_pair(0, 0));\n  \n  while(!pq.empty()) {\n    auto top = pq.top(); pq.pop();\n    auto node = top.second;\n    if (!visited[node]) {\n      visited[node] = true;\n      sum += top.first;\n      \n      for (auto i = 0; i < n; i++) {\n\tauto cost = edges[node][i];\n\tif (cost > 0) pq.push(make_pair(cost, i));\n      }\n    }\n  }\n  \n  return sum;\n}\n\nint main() {\n  int n;\n  while(cin >> n, n) {\n    int m;\n    cin >> m;\n\n    vector<vector<int> > street(n, vector<int>(n));\n\n    for (auto i = 0; i < m; i++) {\n      int a, b, d;\n      scanf(\"\\n%d,%d,%d\", &a, &b, &d);\n      d /= 100;\n      d -= 1;\n      street[a][b] = d;\n      street[b][a] = d; \n    }\n\n    cout << solve(n, m, street) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\n//Union-Find木\n#include <vector>\n\n//Union-Find木\n#include <vector>\n\nstruct Union_Find {\n\tvector<int> par;\n\tvector<int> rank;\n\n\t//初期化\n\tvoid init( int n ) {\n\t\tpar.resize( n );\n\t\trank.resize( n );\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tpar[ i ] = i;\n\t\t\trank[ i ] = 0;\n\t\t}\n\t}\n\n\t//木の根を探す\n\tint find( int s ) {\n\t\tif ( par[ s ] == s ) {\n\t\t\treturn s;\n\t\t}\n\t\treturn par[ s ] = find( par[ s ] );\n\t}\n\n\t//結合\n\tvoid unite( int x, int y ) {\n\t\tint a = find( x ), b = find( y );\n\t\tif ( a == b ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( rank[ x ] < rank[ y ] ) {\n\t\t\tpar[ x ] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[ y ] = x;\n\t\t\tif ( rank[ x ] == rank[ y ] ) {\n\t\t\t\t++rank[ x ];\n\t\t\t}\n\t\t}\n\t}\n\n\t//二つの数の根が同じかどうか\n\tbool same( int x, int y ) {\n\t\treturn find( x ) == find( y );\n\t}\n\n\t//サイズを返す\n\tunsigned int size() {\n\t\treturn par.size();\n\t}\n};\n\n\nint main() {\n\tint n, m;\n\tUnion_Find u;\n\twhile ( ~scanf( \"%d\", &n ) && n ) {\n\t\tscanf( \"%d\", &m );\n\t\tVVI root( n, VI( n, INF ) );\n\t\tfor ( int i = 0; i < m; i++ ) {\n\t\t\tint a, b, c;\n\t\t\tscanf( \"%d,%d,%d\", &a, &b, &c );\n\t\t\troot[ a ][ b ] = root[ b ][ a ] = c / 100 - 1;\n\t\t}\n\t\tu.init( n );\n\t\tint ans = 0;\n\t\tfor ( int i = 1; i < n; i++ ) {\n\t\t\tint _min = INF, add;\n\t\t\tfor ( int j = 0; j < n; j++ ) {\n\t\t\t\tif ( !u.same( 0, j ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor ( int k = 1; k < n; k++ ) {\n\t\t\t\t\tif ( !u.same( 0, k ) && _min >= root[ j ][ k ] ) {\n\t\t\t\t\t\tadd = k;\n\t\t\t\t\t\t_min = root[ j ][ k ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tu.unite( 0, add );\n\t\t\tans += _min;\n\t\t}\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1000000000000000000LL\nusing namespace std;\nlong long prim(int V, vector<pair<long long, long long>> X[]) {\n\tqueue<int> Q; int dist[100], color[100];\n\tfor (int i = 0; i < V; i++) { dist[i] = INF; color[i] = WHITE; }\n\tdist[0] = 0; color[0] = GRAY; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<long long, long long>pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; color[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first, leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && color[to] < BLACK) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < V; i++) { sum += dist[i]; }//0-indexed\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<long long, long long> > g[100];\nint main() {\n\twhile(cin >> n >> m) {\n\t\tfor(int i = 0; i < n; i++) g[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", u, v, w);\n\t\t\tg[u].push_back(make_pair(v, w / 100 - 1));\n\t\t\tg[v].push_back(make_pair(u, w / 100 - 1));\n\t\t}\n\t\tcout << prim(n, g) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DBG 1\n#define dump(o) if(DBG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DBG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define each(it,c) for(auto it=(c).begin();it!=(c).end();it++)\n#define all(c) c.begin(),c.end()\nconst int INF = sizeof(int) == sizeof(long long) ? 0x3f3f3f3f3f3f3f3fLL : 0x3f3f3f3f;\nconst int MOD = (int)(1e9 + 7);\nconst int W(1), B(0);\nvector<vector<pair<int,int>>>M; // d,c\nint n;\nint prim() {\n\tvector<int>d(n, INF), color(n, W);\n\td[0] = 0;\n\tpriority_queue<pair<int,int>>pq; // d[v], v\n\tpq.push(make_pair(0, 0));\n\twhile (!pq.empty()) {\n\t\tpair<int, int>f(pq.top()); pq.pop();\n\t\tcolor[f.second] = B;\n\t\tif (d[f.second] < f.first*(-1)) continue;\n\t\trep(i, 0, M[f.second].size()) {\n\t\t\tpair<int, int>u(M[f.second][i]);\n\t\t\tif (color[u.first] != B&&u.second<d[u.first]) {\n\t\t\t\td[u.first] = u.second;\n\t\t\t\tpq.push(make_pair(d[u.first] * (-1), u.first));\n\t\t\t}\n\t\t}\n\t}\n\treturn accumulate(all(d), 0) / 100 - d.size()+1;\n}\nsigned main() {\n\twhile (cin >> n, n) {\n\t\tM = vector<vector<pair<int,int>>>(n, vector<pair<int,int>>());\n\t\tint m; cin >> m;\n\t\trep(i, 0, m) {\n\t\t\tint a, b, d; char c; cin >> a >> c >> b >> c >> d;\n\t\t\tM[a].push_back(make_pair(b, d));\n\t\t\tM[b].push_back(make_pair(a, d));\n\t\t}\n\t\tcout << prim() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <utility>\n#include <cstring>\n#include <iomanip>\n#include <numeric>\n#include <cmath>\n#include <queue>\n#include <map>\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int INF = 1<<30; \nconst int MOD = 1e9 + 7;\nconst int dy[] = {1, 0, -1, 0};\nconst int dx[] = {0, 1, 0, -1};\nconst int MAX_N = 150;\nstruct edge { int to, dist; };\nvector<edge> G[MAX_N];\nint solve(int n)\n{\n    int res = 0;\n    bool used[MAX_N] = {};\n    priority_queue<P, vector<P>, greater<P>> que;\n    que.push(P(0, 0));\n    while(not que.empty())\n    {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if(used[v]) continue;\n        used[v] = true;\n        res += p.first;\n        for(int u = 0; u < G[v].size(); u++)\n        {\n            edge e = G[v][u];\n            if(used[e.to] == false) que.push(P(e.dist, e.to));\n        }\n    }\n    res /= 100;\n    res -= n - 1;\n    return res;\n}\nint main()\n{\n    int n;\n    while(cin >> n, n)\n    {\n        int m; cin >> m;\n        for (int i = 0; i < m; i++)\n        {\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            G[a].push_back({b, d});\n            G[b].push_back({a, d});\n        }\n        cout << solve(n) << endl;\n        for(int i = 0; i < MAX_N; i++) G[i].clear();\n    }\n    return 0;\n}\n\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_M = MAX_N * MAX_N;\nint par[MAX_N];\nint myrank[MAX_N];\nint n, m;\n\n\nstruct edge {\n    int a, b, d;\n\n    bool operator<(const edge &r) {\n      return d < r.d;\n    }\n};\n\narray<edge, MAX_M> e;\n\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init() {\n  for (int i = 0; i < MAX_N; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nbool unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y)\n    return false;\n\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n\n  return true;\n}\n\nint main() {\n  int count, t;\n\n  while (cin >> n, n) {\n    cin >> m;\n    init();\n\n    t = 0;\n    for (int i = 0; i < m; i++)\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n\n    sort(e.begin(), e.begin() + n);\n    for (int i = 0; i < n; ++i) {\n      if (unite(e[i].a, e[i].b))\n        t += e[i].d / 100 - 1;\n    }\n    cout << t << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\ntypedef pair<int,int> P;\nvector<vector<P> > edge;\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d\\n\",&n);\n        if(n==0) break;\n        scanf(\"%d\\n\",&m);\n        int a,b,d;\n        edge=vector<vector<P> >(n,vector<P>());\n        for(int i=0;i<m;i++){\n            scanf(\"%d,%d,%d\\n\",&a,&b,&d);\n            d=d/100-1;\n            edge[a].PB(MP(d,b));\n            edge[b].PB(MP(d,a));\n        }\n        vector<bool> isvis(n,false);\n        priority_queue<P,vector<P>,greater<P> > pq;\n        int ret=0;\n        pq.push(MP(0,0));\n        while(!pq.empty()){\n            int d=pq.top().first,at=pq.top().second;\n            pq.pop();\n            if(isvis[at]) continue;\n            isvis[at]=true;\n            ret+=d;\n            for(int i=0;i<edge[at].size();i++){\n                if(!isvis[edge[at][i].second]){\n                    pq.push(edge[at][i]);\n                }\n            }\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_V 100\n#define INF 1e9\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint V;\n\nint prim(){\n  int mincost[MAX_V];\n  bool used[MAX_V];\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res=0;\n  while(true){\n    int v = -1;\n    \n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true; //頂点vをXに追加\n    res += mincost[v]; //円のコストを加える\n    for(int u=0;u<V;u++) mincost[u] = min(mincost[u],cost[v][u]);\n  }\n  return res;\n}\n\n\nint main(){\n  int E;\n  while(cin >> V){\n    if(V==0) break;\n    \n    cin >> E;\n    for(int i=0;i<E;i++){\n      for(int j=0;j<E;j++){\n        cost[i][j] = cost[j][i] = (i==j ? 0 : INF);\n      }\n    }\n\n    int a,b,dist;\n    char camma;\n    for(int i=0;i<E;i++){\n      cin >> a >> camma >> b >> camma >> dist;\n      a; b;\n      cost[a][b] = cost[b][a] = dist;\n    }\n    \n    int sum_of_costs = prim();\n    int lanterns = sum_of_costs/100 - (V - 1);\n    //n00mを100mで分割すると分割点はn-1個\n    cout << lanterns << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tfor(;;){\n\t\tint n,m,sum = 0;\n\t\tcin >>n;\n\t\tif(!n){break;}\n\t\tcin >>m;\n\t\tvector<pair<int, pair<int,int> > > edge;\n\t\tbool done[100] = {false};\n\t\tfor(int i=0; i<m ;i++){\n\t\t\tint a,b,cost;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&cost);\n\t\t\tedge.push_back(make_pair(cost,make_pair(a,b)));\n\t\t}\n\t\tsort(edge.begin(),edge.end());\n\t\tdone[edge[0].second.first] = true;\n\t\tdone[edge[0].second.second] = true;\n\t\tsum += edge[0].first/100;\n\t\tif(!(edge[0].first%100)){sum--;}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tfor(int k=0; k<m; k++){\n\t\t\t\tif(done[edge[k].second.first]^done[edge[k].second.second]){\n\t\t\t\t\tsum += edge[k].first/100;\n\t\t\t\t\tif(!(edge[k].first%100)){sum--;}\n\t\t\t\t\tdone[edge[k].second.first] = true;\n\t\t\t\t\tdone[edge[k].second.second] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\nusing ll = long long;\nusing pii = pair<int, int>;\n\ntemplate <class T>\nstruct Kruskal {\n  struct UnionFind {\n    int N;\n    vector<int> sz_tree, parent;\n    UnionFind() {}\n    UnionFind(int N) : N(N), sz_tree(N, 1), parent(N) {\n      iota(parent.begin(), parent.end(), 0);\n    }\n    int root(int x) {\n      return parent[x] == x ? x : parent[x] = root(parent[x]);\n    }\n    void merge(int x, int y) {\n      if ((x = root(x)) == (y = root(y))) return;\n      if (sz_tree[x] < sz_tree[y]) swap(x, y);\n      sz_tree[x] += sz_tree[y];\n      parent[y] = x;\n    }\n    bool same(int x, int y) {\n      return root(x) == root(y);\n    }\n    int size(int x) {\n      return sz_tree[root(x)];\n    }\n  };\n  struct edge {\n    int from, to; T cost;\n    edge() {}\n    edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n  };\n \n  int N;\n  vector<edge> es;\n  Kruskal() {}\n  Kruskal(int N) : N(N) {}\n \n  void add_edge(int from, int to, T cost) {\n    es.emplace_back(from, to, cost);\n  }\n  T mst() {\n    T res = 0;\n    UnionFind uf(N);\n    sort(es.begin(), es.end(), [&](edge a, edge b) {\n      return a.cost < b.cost;\n    });\n    for (auto &e : es) {\n      if (uf.same(e.from, e.to)) continue;\n      uf.merge(e.from, e.to);\n      res += e.cost;\n    }\n    return res;\n  }\n};\n\nint main() {\n  cin.tie(0);\n  ios_base::sync_with_stdio(false);\n  cout << fixed << setprecision(10);\n  \n  int n, m;\n  while (cin >> n, n) {\n    cin >> m;\n    Kruskal<int> K(n);\n    for (int i = 0; i < m; i++) {\n      int a, b, d;\n      char c;\n      cin >> a >> c >> b >> c >> d;\n      K.add_edge(a, b, d / 100);\n      K.add_edge(b, a, d / 100);\n    }\n    cout << K.mst() - (n - 1) << endl;\n  }  \n\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define  INF 999999999\n\n#ifdef Debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#else\n#define dump(x)\n#endif\n\nbool used[200];\nint mincost[200];\nint edge[200][200];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\trep(i,200)rep(j,200)edge[i][j]=INF;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar ch;\n\t\t\tcin>>a>>ch>>b>>ch>>c;\n\t\t\tedge[a][b]=edge[b][a]=max(0,(int)(c/100)-1);\n\t\t}\n\t\trep(i,m){\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tmincost[0]=0;\n\t\tint res=0;\n\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\trep(u,m){\n\t\t\t\tif(used[u]==false && ( v==-1 || mincost[u]<mincost[v] ))\n\t\t\t\t\tv=u;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=true;\n\t\t\tres+=mincost[v];\n\n\t\t\trep(u,m){\n\t\t\t\tmincost[u]=min(mincost[u],edge[v][u]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\n#define NMAX 100\n#define NOT -1\n\nstruct mini{\n\tint fr,to,cost;\n};\n\n\nint main(){\n\n\tint n,m;\n\tint a,b,d;\n\tchar gav;\n\tint e[NMAX][NMAX];\n\tbool use[NMAX];\n\tint cost;\n\tmini min;\n\n\twhile(1){\n\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcin>>m;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\te[i][j]=NOT;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>a>>gav>>b>>gav>>d;\n\t\t\te[a][b]=d;\n\t\t\te[b][a]=d;\n\t\t}\n\n\t\tfor(int i=0;i<n;i++) use[i]=false;\n\t\tuse[0]=true;\n\t\tcost=0;\n\n\t\twhile(1){\n\t\t\tmin.fr=NOT,min.to=NOT,min.cost=NOT;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(use[i]==true){\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(use[j]==false){\n\t\t\t\t\t\t\tif(e[i][j]!=NOT){\n\t\t\t\t\t\t\t\tif(min.fr==NOT||min.cost>e[i][j]) min.fr=i,min.to=j,min.cost=e[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min.fr==NOT) break;\n\t\t\tuse[min.to]=true;\n\t\t\tcost+=(min.cost)/100-1;\n\t\t}\n\t\tcout<<cost<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint Par[100],Rank[100];\nvoid Init(int n) {\n\tfor(int i=0;i<n;i++) {\n\t\tPar[i]=i;\n\t\tRank[i]=0;\n\t}\n}\nint Find(int x) {\n\tif(Par[x]==x) {\n\t\treturn x;\n\t}else {\n\t\treturn Par[x]=Find(Par[x]);\n\t}\n}\nvoid Unite(int x,int y) {\n\tx=Find(x);\n\ty=Find(y);\n\tif(x==y) return;\n\tif(Rank[x]<Rank[y]) {\n\t\tPar[x]=y;\n\t}else {\n\t\tPar[y]=x;\n\t\tif(Rank[x]==Rank[y])Rank[x]++;\n\t}\n}\nbool Same(int x,int y) {\n\treturn Find(x)==Find(y);\n}\nstruct Edge {\n\tint u,v,cost;\n\tEdge(int _u,int _v,int _cost) {u=_u,v=_v,cost=_cost;}\n\tbool operator < (const Edge& E) const {return cost<E.cost;}\n};\nvector<Edge> es;\nint main() {\n\tint n,m,a,b,d;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tscanf(\"%d\",&m);\n\t\tes.clear();\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tes.push_back(Edge(a,b,d));\n\t\t}\n\t\tsort(es.begin(),es.end());\n\t\tint res=0;\n\t\tInit(n);\n\t\tfor(int i=0;i<es.size();i++) {\n\t\t\tif(!Same(es[i].u,es[i].v)) {\n\t\t\t\tUnite(es[i].u,es[i].v);\n\t\t\t\tres+=(es[i].cost/100-1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <utility>\nusing namespace std;\n\nclass data {\n\tpublic:\n\t\tint a, b;\n\t\tint c;\n\n\t\tdata(int p1, int p2, int cost) {\n\t\t\ta = p1;\n\t\t\tb = p2;\n\t\t\tc = cost;\n\t\t}\n\n\t\tbool operator<(const data & c_) const {\n\t\t\treturn c > c_.c;\n\t\t}\n};\n\nint n, m;\nvector<data> cost;\nvector<data> modefied_cost;\nvector<vector<int> > used_point;\n\nvoid init() {\n\tcost.clear();\n\tmodefied_cost.clear();\n\tused_point.clear();\n}\n\nbool input() {\n\tcin >> n;\n\tif(!n)\n\t\treturn false;\n\n\tcin >> m;\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\tcost.push_back(data(a, b, c));\n\t}\n\n\treturn true;\n}\n\nvoid modefy_cost() {\n\tfor(int i = 0; i < cost.size(); i++) {\n\t\tmodefied_cost.push_back(data(cost[i].a, cost[i].b, cost[i].c / 100 - 1));\n\t}\n}\n\npair<pair<int,int>,pair<int,int> > find_point(data d) {\n\tpair<pair<int, int>, pair<int, int> > ij_pair(pair<int,int>(-1, -1), pair<int,int>(-2, -2));\n\tfor(int i = 0; i < used_point.size(); i++) {\n\t\tfor(int j = 0; j < used_point[i].size(); j++) {\n\t\t\tif(used_point[i][j] == d.a) {\n\t\t\t\tij_pair.first.first = i;\n\t\t\t\tij_pair.first.second = j;\n\t\t\t}\n\t\t\telse if(used_point[i][j] == d.b) {\n\t\t\t\tij_pair.second.first = i;\n\t\t\t\tij_pair.second.second = j;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ij_pair;\n}\n\nint solve() {\n\tmodefy_cost();\n\tsort(modefied_cost.begin(), modefied_cost.end());\n\tint ans = 0;\n\n\tfor(int i = 1; i < modefied_cost.size(); i++) {\n\t\tpair<pair<int,int>,pair<int,int> > tmp;\n\t\ttmp = find_point(modefied_cost[i]);\n\n\t\tif(tmp.first.first == tmp.second.first)\n\t\t\tcontinue;\n\n\t\telse if(tmp.first.first > -1 && tmp.second.first < 0) {\n\t\t\tused_point[tmp.first.first].push_back(modefied_cost[i].b);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse if(tmp.first.first < 0 && tmp.second.first > -1) {\n\t\t\tused_point[tmp.second.first].push_back(modefied_cost[i].a);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse if(tmp.first.first > -1 && tmp.second.first > -1) {\n\t\t\tused_point[tmp.first.first].insert(used_point[tmp.first.first].end(),\n\t\t\t\t\tused_point[tmp.second.first].begin(), used_point[tmp.second.first].end());\n\t\t\tused_point.erase(used_point.begin() + tmp.second.first, used_point.begin() + tmp.second.first + 1);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse {\n\t\t\tused_point.push_back(vector<int>(modefied_cost[i].a, modefied_cost[i].b));\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile(init(), input()) {\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\nstruct EDGE\n{\n    int to, cost;\n    bool operator < (const EDGE& t) const {\n        return cost > t.cost;\n    }\n};\nvector<EDGE> v[100]; \nbool f[100];\nint search()\n{\n    int res = 0;\n    priority_queue<EDGE> que;\n    que.push((EDGE){0, 0});\n    while (!que.empty()){\n        EDGE e = que.top(); que.pop();\n        if (f[e.to]) continue;\n        f[e.to] = true;\n        res += e.cost;\n        rep(i, v[e.to].size()){\n            if (!f[v[e.to][i].to]){\n                que.push(v[e.to][i]);\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d\", &n), n){\n        scanf(\"%d\", &m);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            c = c / 100 - 1;\n            v[a].pb((EDGE){b, c});\n            v[b].pb((EDGE){a, c});\n        }\n        printf(\"%d\\n\", search());\n        memset(f, false, sizeof(f));\n        rep(i, n) v[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* Minimum Spanning Tree */\n\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<climits>\n#include<iostream>\n\n#define\tmp(a,b)\tmake_pair((a),(b))\n#define\tdis\t\tfirst\n#define\tnode\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tpair<int,pii>\tpipii;\n\nvector<int> mst;\n\nint UF_root(int i)\n{\n\tif(mst[i]==-1)\treturn i;\n\treturn mst[i]=UF_root(mst[i]);\n}\n\nbool UF_find(int i,int j)\n{\n//cout<<\"root\"<<i<<\"=\"<<UF_root(i)<<\" root\"<<j<<\"=\"<<UF_root(j)<<endl;\n\treturn UF_root(i)==UF_root(j);\n}\n\nvoid UF_union(int i,int j)\n{\n\tmst[j]=i;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tmst=vector<int>(n,-1);\t// initial forest has n trees\n\n\t\tpriority_queue< pipii,vector<pipii>,greater<pipii> > pq;\n\t\tint m;\tcin>>m;\n\t\twhile(m--){\n\t\t\tint a,b,dis;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&dis);\n\t\t\tpq.push(mp(dis,mp(a,b)));\n\t\t}\n\n\t\tint total=0;\n\t\twhile(!pq.empty()){\n\t\t\tpipii path=pq.top();\tpq.pop();\n/*\t\t\tif(!UF_find(path.node.first,path.node.second)){\n\t\t\t\tUF_union(path.node.first,path.node.second);\nprintf(\">%d\\n\",path.dis);\n\t\t\t\ttotal+=path.dis/100-1;\n\t\t\t}\nprintf(\"this step : \");\nfor(int i=0;i<n;i++)\tprintf(\"%d \",mst[i]);\nputs(\"\");\n*/\n\t\t\tif(mst[path.node.first]==-1 || mst[path.node.second]==-1){\n\t\t\t\tmst[path.node.first]=1;\n\t\t\t\tmst[path.node.second]=1;\n\t\t\t\ttotal+=path.dis/100-1;\n\t\t\t}\n\t\t}\n\n\t\tcout<<total<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\ntypedef pair<int,int> PI;\n\nstruct UF{\n    \n    int root[230010];\n    \n    UF(int n){\n        for(int i=0;i<n;i++) root[i] = i;\n    }\n    \n    int find(int n){\n        if(root[n] == n) return n;\n        return find( root[n] );\n    }\n    \n    void unit(int a,int b){\n        a = find(a);\n        b = find(b);\n        if(a < b) root[b] = a;\n        else root[a] = b;\n    }\n    \n    bool same(int a,int b){\n        return find(a)==find(b);\n    }\n    \n};\n\nint main(){\n    \n    int n,m,d,ans;\n    int a[230010],b[230010];\n\n    while(cin >> n,n!=0){\n        cin >> m;\n        vector<PI> vec;\n        for(int i=0;i<m;i++){\n            scanf(\"%d,%d,%d\",&a[i],&b[i],&d);\n            vec.push_back( PI(d/100-1,i) );\n        }\n    \n        sort(vec.begin(),vec.end());\n        UF uf(n);\n        ans = 0;\n        for(int i=0;i<vec.size();i++){\n            int toro = vec[i].first;\n            int idx = vec[i].second;\n            if(!uf.same(a[idx],b[idx])){\n                ans += toro;\n                uf.unit(a[idx],b[idx]);\n            }\n        }\n    \n        cout << ans << endl;\n    }\n    \n    return(0);\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#define MAX 1000\n#define INF 1<<30\nusing namespace std;\nint V,E,cost[MAX][MAX],from,to,Cost;\nbool used[MAX];\nint mincost[MAX];\n\nint prim(){\n  int ans = 0;\n  for(int i=0;i<V;i++){\n    used[i] = false;\n    mincost[i] = INF;\n  }\n  mincost[0] = 0;\n\n  while(true){\n    int v = -1;\n    for(int i=0;i<V;i++){\n      if(!used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n    }\n    if(v == -1)break;\n    used[v] = true;\n    ans += mincost[v];\n\n    for(int i=0;i<V;i++){\n      mincost[i] = min(mincost[i],cost[v][i]);\n    }\n  }\n\n\n  return ans;\n\n}\n\nint main(){\n  \n  \n  while(cin >> V && V){\n    for(int i=0;i<MAX;i++)for(int j=0;j<MAX;j++)cost[i][j] = INF;\n    cin >> E;\n    for(int i=0;i<E;i++){\n      scanf(\"%d,%d,%d\\n\",&from,&to,&Cost);\n      cost[from][to] = cost[to][from] =  Cost;\n    }\n    \n    cout <<  prim()/100 - (V-1) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\nusing namespace std;\nstruct edge{int u,v,cost;};\nint parent[100];\nint rank[100];\n\nvoid init(int n)\n{\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tparent[i]=i;\n\t\trank[i]=0;\n\t}\n}\n\nint find(int x)\n{\n\tif(parent[x]==x) return x;\n\telse return parent[x]=find(parent[x]);\n}\n\nvoid unit(int x,int y)\n{\n\tx=find(x);\n\ty=find(y);\n\tif(x==y) return;\n\n\tif(rank[x]<rank[y])\n\t{\n\t\tparent[x]=y;\n\t}\n\telse\n\t{\n\t\tparent[y]=x;\n\t\tif(rank[x]==rank[y]) rank[x]++;\n\t}\n}\n\nbool same(int x,int y)\n{\n\treturn find(x)==find(y);\n}\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost<e2.cost;\n}\n\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tinit(n);\n\t\tint m; cin>>m;\n\t\tedge es[m];\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tscanf(\"%d,%d,%d\",&es[i].u,&es[i].v,&es[i].cost);\n\t\t}\n\n\t\tsort(es,es+m,comp);\n\t\tint ans=0;\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tedge e=es[i];\n\t\t\tif(!same(e.u,e.v))\n\t\t\t{\n\t\t\t\tunit(e.u,e.v);\n\t\t\t\tans+=e.cost-100;\n\t\t\t}\n\t\t}\n\t\tcout<<ans/100<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 100;\n\nstruct edge {\n\tint from_, to_, cost_;\n\tedge() = default;\n\tedge(int from, int to, int cost) :from_(from), to_(to), cost_(cost) {}\n\tbool operator<(const edge& rhs) const{\n\t\treturn cost_ < rhs.cost_;\n\t}\n};\n\nint n, m;\nstd::vector<edge> edges;\n\nclass Union {\n\tint par[MAX_N], rank[MAX_N];\npublic:\n\tUnion() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x])\n\t\t\treturn x;\n\t\tpar[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y])\n\t\t\tstd::swap(x, y);\n\t\tpar[y] = x;\n\t\trank[x] += rank[y];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (!n)\n\t\t\tbreak;\n\t\tstd::cin >> m;\n\t\tUnion uni;\n\t\tedges.clear();\n\t\tint a, b, d;\n\t\tchar ch;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> ch >> b >> ch >> d;\n\t\t\td /= 100;\n\t\t\t--d;\n\t\t\tedges.emplace_back(a, b, d);\n\t\t}\n\n\t\tstd::sort(edges.begin(), edges.end());\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (!uni.same(edges[i].from_, edges[i].to_)) {\n\t\t\t\tuni.unite(edges[i].from_, edges[i].to_);\n\t\t\t\tans += edges[i].cost_;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nclass Edge{\npublic:\n\tint edge_dist;\n\tint cost;\n\tEdge() : edge_dist(0), cost(0) {}\n\tEdge(int _dist, int _cost) : edge_dist(_dist), cost(_cost) {}\n};\n\nbool operator==(const Edge &a, const Edge &b){\n\treturn (a.cost == b.cost);\n}\nbool operator!=(const Edge &a, const Edge &b){\n\treturn !(a == b);\n}\nbool operator<(const Edge &a, const Edge &b){\n\treturn (a.cost < b.cost);\n}\nbool operator>=(const Edge &a, const Edge &b){\n\treturn !(a < b);\n}\nbool operator>(const Edge &a, const Edge &b){\n\treturn (a.cost > b.cost);\n}\nbool operator<=(const Edge &a, const Edge &b){\n\treturn !(a > b);\n}\n\nint main(){\n\tint v, e, s, t, w, sum;\n\tvector< int > vlist; //??¢?´¢?????? -> 1 / else -> 0\n\tvector< vector< Edge > > edge;\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > priq;\n\t\n\twhile(cin >> v, v){\n\t\tcin >> e;\n\t\t\n\t\tvlist.resize(v);\n\t\tedge.resize(v);\n\t\tsum = 0;\n\t\t\n\t\tfor(int i = 0; i < v; ++i){\n\t\t\tvlist[i] = 0;\n\t\t\tedge[i].erase(edge[i].begin(),edge[i].end());\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < e; ++i){\n\t\t\tscanf(\"%d,%d,%d\", &s, &t, &w);\n\t\t\tw /= 100;\n\t\t\t\n\t\t\tedge[s].push_back(Edge(t, w - 1));\n\t\t\tedge[t].push_back(Edge(s, w - 1));\n\t\t}\n\t\t\n\t\tvlist[0] = 1;\n\t\tfor(vector< Edge >::iterator it = edge[0].begin(); it != edge[0].end(); ++it){\n\t\t\tpriq.push(*it);\n\t\t}\n\t\t\n\t\twhile(!priq.empty()){\n\t\t\t\n\t\t\tEdge ed = priq.top();\n\t\t\tpriq.pop();\n\t\t\t\n\t\t\tif(vlist[ed.edge_dist])continue;\n\t\t\t\n\t\t\tvlist[ed.edge_dist] = 1;\n\t\t\tsum += ed.cost;\n\t\t\t\n\t\t\tfor(vector< Edge >::iterator it = edge[ed.edge_dist].begin(); it != edge[ed.edge_dist].end(); ++it){\n\t\t\t\tif(vlist[(*it).edge_dist] == 0){\n\t\t\t\t\tpriq.push(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nint main() {\n\n  int n,m,a,b,l;\n  char c;\n\n  vector<int> list;\n\n  while(true) {\n\n    cin >> n;\n    if ( n == 0 ) break;\n\n    cin >> m;\n\n    int ans = 0;\n    int cnt = 0;\n    int flag_num = 1;\n\n    int map[100][100] = {0};\n    int flag[100] = {0};\n\n    for ( int i = 0; i < m; i++ ) {\n\n      cin >> a >> c >> b >> c >> l;\n      map[a][b] = l;\n      map[b][a] = l;\n      list.push_back( l );\n\n    }\n\n    sort( list.begin(), list.end() );\n\n    int num[100] = {0};\n\n    while(true) {\n\n      for ( int x = 0; x < n-1; x++ ) {\n\tfor ( int y = x+1; y < n; y++ ) {\n\n\t  if ( map[x][y] != list[0] ) continue;\n\n\t  if ( flag[x] > 0 && flag[y] > 0 ) {     //その木の両端が両方とも連結済みだったら\n\t    if ( flag[x] != flag[y] ) {\n\t      int k = flag[y];\n\t      for ( int i = 0; i < n; i++ ) {\n\t\tif ( flag[i] == k ) flag[i] = flag[x];\n\t      }\n\t      ans += map[x][y]/100-1;\n\t      cnt++;\n\t    }\n\t  }else if ( flag[x] == 0 && flag[y] == 0 ) {\n\t    flag[x] = flag_num;\n\t    flag[y] = flag_num;\n\t    flag_num++;\n\t    ans += map[x][y]/100-1;\n\t    cnt++;\n\t  }else {\n\t    if ( flag[x] == 0 ) {\n\t      flag[x] = flag[y];\n\t      ans += map[x][y]/100-1;\n\t      cnt++;\n\t    }else {\n\t      flag[y] = flag[x];\n\t      ans += map[x][y]/100-1;\n\t      cnt++;\n\t    }\n\t  }\n\n\t  vector<int>::iterator it = list.begin();\n\t  list.erase( it );\n\t  map[x][y] = 0;\n\t  if ( cnt == n-1 ) break;\n\n\t}\n\tif ( cnt == n-1 ) break;\n      }\n      if ( cnt == n-1 ) break;\n\n    }\n\n    cout << ans << endl;\n\n  }\n\n  return 0;\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint inf=1<<21;\nint n;\n\nint prim_souwa(int G[500][500]){\n    int d[n],vstd[n];\n    int u=0,sum=0;\n    fill(d,d+n,inf);\n    fill(vstd,vstd+n,0);\n    d[0]=0;\n    while(true){\n        int mini=inf;\n        for(int i=0; i<n; i++){\n            if(mini>d[i]&&vstd[i]==0){\n                mini=d[i];\n                u=i;\n            }\n        }\n        if(mini==inf)break;\n        sum+=mini;\n        vstd[u]=1;\n        for(int i=0; i<n; i++){\n            if(G[u][i]<d[i]){\n                d[i]=G[u][i];\n            }\n        }\n    }\n    return sum;\n}\n\nint main(){\n    int m;\n    int G[500][500];\n    while(cin>>n,n){\n        cin>>m;\n        fill(G[0],G[500],inf);\n        for(int i=0; i<m; i++){\n            int in1,in2,in3;\n            scanf(\"%d,%d,%d\",&in1,&in2,&in3);\n            G[in1][in2]=in3;\n            G[in2][in1]=in3;\n        }\n        cout<<prim_souwa(G)/100-(n-1)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\n#include<functional>\n#include<cstdio>\n#define reep(num1,num2,num3) for(int num1=num3;num1<num2;num1++)\n#define rep(num1,num2) reep(num1,num2,0)\n#define INF 1e9\nusing namespace std;\nclass edge{\npublic:\n    int to,c;\n    edge(int to,int c):to(to),c(c){}\n    edge(){}\n    bool operator<(const edge &a)const{\n        if(c!=a.c)return c>a.c;\n        return to<a.to;\n    }\n};\nint main()\n{\n    int n;\n    while(cin>>n,n)\n    {\n        bool vis[111]={false};\n        vector<edge> G[111];\n        int d[111];\n        int m,res=0;\n        cin>>m;\n        rep(i,m){\n            int a,b,c;\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            G[a].push_back(edge(b,c));\n            G[b].push_back(edge(a,c));\n        }\n        priority_queue<edge> PQ;\n        PQ.push(edge(0,0));\n        while(!PQ.empty())\n        {\n            edge e=PQ.top();PQ.pop();\n            if(vis[e.to])continue;\n            vis[e.to]=true;\n            res+=e.c;\n            rep(i,G[e.to].size()){\n                PQ.push(edge(G[e.to][i].to,G[e.to][i].c));\n            }\n        }\n        cout<<res/100-n+1<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_M = MAX_N * MAX_N;\nint par[MAX_N];\nint myrank[MAX_N];\nint n,m;\n\n\nstruct edge {\n    int a, b, d;\n\n    bool operator <(const edge& r) {\n      return d < r.d;\n    }\n};\narray<edge, MAX_M> e;\n\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init() {\n  for (int i = 0; i < MAX_N; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) {\n    return;\n  }\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n}\n\n// x,y????±?????????????????????????????????????\nint same(int x, int y) {\n  return find(x) == find(y);\n}\n\nint compare_edge(const void *a,const void * b){\n  edge temp1 = *(edge *)a;\n  edge temp2 = *(edge *)b;\n\n  return temp1.d-temp2.d;\n}\nint main() {\n  int count ,t ;\n\n  while (cin >> n, n){\n    cin >> m;\n    init();\n\n    t = 0;\n    count = 0;\n    for(int i = 0; i < m; i ++){\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n    }\n    \n    sort(e.begin(), e.begin() + n);\n    while(count != m-1) {\n      for (int i = 0; i < n; ++i) {\n        if(same(e[i].a,e[i].b) != 1) {\n          count++;\n          t = t + (int) e[i].d /100 - 1;\n          unite(e[i].a,e[i].b);\n        }\n      }\n      cout << t<<endl;\n    }\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> split(string s){\n    vector<int> ret;\n    s += ',';\n    int x = -1;\n    REP(i,s.size()){\n\tif(s[i] == ','){\n\t    ret.PB( stoi(s.substr(x+1,i-x-1)) );\n\t    x = i;\n\t}\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n\tint n,m;\n\tint d[101][101];\n\tint dd[101];\n\tmemset(d,-1,sizeof(d));\n\tmemset(dd,-1,sizeof(dd));\n\tcin >> n;\n\tif(n == 0) break;\n\tcin >> m;\n\tvector< vector<int> > vec(n,vector<int>(0));\n\tREP(i,m){\n\t    string s;\n\t    cin >> s;\n\t    vector<int> sl = split(s);\n\t    vec[sl[0]].PB(sl[1]);\n\t    vec[sl[1]].PB(sl[0]);\n\t    d[sl[0]][sl[1]] = sl[2];\n\t    d[sl[1]][sl[0]] = sl[2];\n\t}\n\tint ans = 0;\n\tint count = 0;\n\tint t = 0;\n\tint v = 0;\n\tvector<bool> used(n,false);\n\tused[0] = true;\n\tpriority_queue< pair<int,int>,vector< pair<int,int> >, greater< pair<int,int> > > q;\n\tREP(i,vec[0].size()){\n\t    q.push( pair<int,int>(d[0][vec[0][i]],vec[0][i]));\n\t}\n\twhile(!q.empty()){\n\t    v = q.top().first;\n\t    t = q.top().second;\n\t    q.pop();\n\t    if(!used[t]){\n\t\tused[t] = true;\n\t\tdd[t] = v;\n\t\tans += v/100 - 1;\n\t\tREP(i,vec[t].size()){\n\t\t    q.push( pair<int,int>(d[t][vec[t][i]],vec[t][i]));\n\t\t}\n\t    }else if(dd[t] > v){\n\t    }\n\t}\n\tREP(i,n){\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\n//int Kruskal(Graph& g,Edges& e)\n//{\n//\te.clear();\n//\t\n//\tUnionFind uf(g.size());\n//\tset<Edge> s;\n//\trep(i,g.size())\n//\t\trep(j,g[i].size())\n//\t\t\ts.insert(g[i][j]);\n//\t\n//\tint res=0;\n//\tforeach(i,s){\n//\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n//\t\t\tuf.Union(i->src,i->dst);\n//\t\t\tres+=i->weight;\n//\t\t\te.push_back(*i);\n//\t\t}\n//\t}\n//\t\n//\treturn res;\n//}\n\n//pair<Weight, Edges> minimumSpanningForest(const Graph &g) {\npair<int, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  //priority_queue<Edge> Q;\n  //priority_queue<Edge,vector<Edge>,greater<Edge> > Q;\n  //rep(u, n) foreach(e, g[u]) if (u < e->dst) Q.push(*e);\n  //rep(u, n) foreach(e, g[u]) Q.push(*e);\n  set<Edge> s;\n  rep(i,g.size())rep(j,g[i].size())s.insert(g[i][j]);\n\n  //Weight total = 0;\n  int total = 0;\n  Edges F;\n  //while (F.size() < n-1 && !Q.empty()) {\n  //  Edge e = Q.top(); Q.pop();\n  foreach(i,s){\n    if(F.size()>=n)\n\t\tbreak;\n    Edge e=*i;\n    //if (uf.unionSet(e.src, e.dst)) {\n    //  F.push_back(e);\n    //  total += e.weight;\n    //}\n\tif(uf.Find(e.src)!=uf.Find(e.dst)){\n\t\tuf.Union(e.src,e.dst);\n\t\tF.push_back(e);\n\t\ttotal+=e.weight;\n\t}\n  }\n  //return pair<Weight, Edges>(total, F);\n  return pair<int, Edges>(total, F);\n}\n\nostream& operator<<(ostream& os,const vi& a)\n{\n\trep(i,a.size())\n\t\tprintf(\"%d%s\",a[i],i==a.size()-1?\"\":\" \");\n\treturn os;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\t//Edges e;\n\t\t//int sum=Kruskal(g,e);\n\t\t////cout<<sum/100-e.size()<<endl;\n\t\t//cout<<sum<<endl;\n\t\t\n\t\tcout<<minimumSpanningForest(g).first<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const int INF = 10000000;\n\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost + n,INF);\n\n\n\t\tint** cost = new int*[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcost[i] = new int[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\n\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from,to,dist;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&dist);\n\t\t\tcost[from][to] = dist / 100 - 1;\n\t\t}\n\n\t\tmincost[0]=0;\n\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!used[i] && (v==-1 || mincost[i] < mincost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmincost[v] = min(mincost[v],cost[i][v]);\n\t\t\t}\n\n\t\t\tres+=mincost[v];\n\t\t\t\n\t\t}\n\n\t\tcout << res << endl;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdelete[] cost[i];\n\t\t}\n\n\t\tdelete[] cost;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstatic const int INF = 99999999;\nint cost[101][101];\nint mincost[101];\nbool used[101];\nint n;\n\nint prim()\n{\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v]))\n\t\t\t{\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\t\tif(v == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tmincost[i] = min(mincost[i], cost[v][i]);\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i = 0; i < 101; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 101; ++j)\n\t\t\t{\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, dist;\n\t\t\tchar c;\n\t\t\tcin >> a >> c >> b >> c >> dist;\n\t\t\tcost[a][b] = dist;\n\t\t\tcost[b][a] = dist;\n\t\t}\n\t\t\n\t\tcout << prim() / 100 - 3 << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#include <string>\n#include <queue>\n#include <cmath>\n#include <stack>\n#include <numeric>\n#include <ctime>\n#include <algorithm>\n#include <set>\n#include <stdio.h>\n#include <map>\n\nusing namespace std;\ntypedef long long int lint;\n\n#define INF 10000000\n#define MAX 100\n\nint solve(int n)\n{\n\tint m;\n\tint cost[MAX][MAX];\t\t// cost[i][j] は 辺ijのコスト\n\tint mincost[MAX];\t\t// 集合Xからの辺の最小コスト\n\tbool used[MAX];\t\t\t// 頂点iがXに含まれているか\n\n\tfor(int i = 0; i < n; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t\tfor(int j = 0; j < n; j++){\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\n\tcin >> m;\n\n\tfor(int k = 0; k < m; k++){\n\t\tint i, j, c;\n\t\tscanf(\"%d,%d,%d\", &i, &j, &c);\n\t\tcost[i][j] = cost[j][i] = (c / 100) - 1;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile(1){\n\t\tint v = -1;\n\t\tfor(int u = 0; u < n; u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\n\t\tfor(int u = 0; u < n; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\twhile(1){\n\t\tint n;\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tcout << solve(n) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\n#include<cmath>\n#include<cctype>\n#include<math.h>\n#include<string>\n#include<string.h>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<utility>\n#include<set>\n#include<map>\n#include<stdlib.h>\n#include<iomanip>\n\nusing namespace std;\n\n#define ll long long\n#define ld long double\n#define EPS 0.0000000001\n#define INF 1e9\n#define LINF (ll)INF*INF\n#define MOD 1000000007\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define loop(i,a,n) for(int i=a;i<(n);i++)\n#define all(in) in.begin(),in.end()\n#define shosu(x) fixed<<setprecision(x)\n\n//#define int ll //!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\ntypedef vector<pii> vp;\n\nint gcd(int a, int b){\n    if(b==0) return a;\n    return gcd(b,a%b);\n}\nint lcm(int a, int b){\n    return a/gcd(a,b)*b;\n}\n\n\nclass UnionFind{\n\nprivate:\n    vector<int> rank,p;\n\n    void makeSet(int x){\n      p[x] = x;\n      rank[x] = 0;\n    }\n\n  public:\n      UnionFind(){};\n      UnionFind(int size){\n        rank.resize(size,0);\n        p.resize(size,0);\n        for(int i = 0; i < size; i++){\n          makeSet(i);\n        }\n      }\n\n    bool same(int x, int y){\n      return  find(x) == find(y);\n    }\n\n    void unite(int x, int y){\n      link(find(x), find(y));\n    }\n\n    int find(int x){\n      if(x != p[x]) p[x] = find(p[x]);\n      return p[x];\n    }\n\nprivate:\n    void link(int x, int y){\n      if(rank[x] > rank[y]){\n        p[y] = x;\n      }else{\n        p[x] = y;\n        if(rank[x] == rank[y]) rank[y]++;\n      }\n    }\n\n};\n\nstruct edge{\n    int from, to, cost;\n\n    bool operator<(const edge& e) const {\n        return cost < e.cost;\n    }\n\n};\n\nint kruskal(vector<edge> es, int v){\n\n    sort(es.begin(), es.end());\n\n     UnionFind uf(v);\n\n     int ret = 0;\n\n     for(int i = 0 ; i < es.size() ; i++){\n\n         edge e = es[i];\n\n         if(!uf.same(e.from, e.to)){\n             uf.unite(e.from, e.to);\n             ret += e.cost;\n         }\n\n     }\n\n     return ret;\n\n}\n\n\nsigned main(void) {\n    int n,m;\n    while(cin >> n,n){\n        cin >> m;\n        vector<edge> g;\n        rep(i,m){\n            edge e;\n            scanf(\"%d,%d,%d\", &e.from, &e.to, &e.cost);\n            e.cost /= 100;\n            e.cost--;\n            g.push_back(e);\n        }\n        cout << kruskal(g,n) << endl;\n    }\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdlib.h>\n#define INF 0x7fffffff\n#define MAX_V 100\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V; // V<=100\n\nint prim(){\n  for( int i=0;i<V;++i ){\n    mincost[i]=INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while( true ){\n    int v=-1;\n    for( int u=0;u<V;u++ ){\n      if( !used[u] && (v==-1 || mincost[u] < mincost[v])) v=u;\n    }\n    if( v==-1 ) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for( int u=0;u<V;u++ )\n      mincost[u] = min( mincost[u], cost[v][u] );\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  string line;\n  char buf[256];\n\n  while(  cin >> V,V ){\n    cin >> m;\n    //    cout << \"V=\"<<V <<\" m=\"<<m<<endl;\n\n    int x,y;\n    int k;\n    for( int i=0;i<V;i++ )\n      for( int j=0;j<V;j++ )\n\tcost[i][j] = INF;\n    for( int i=0,j;i<m;i++ ){\n      cin >> line;\n      for( j=0;j<line.size();j++ ) buf[j] = line.at(j);\n      buf[j] = '\\0';\n      x = atoi( buf );\n      for( j=0; buf[j]!=',';j++ );\n      y = atoi( ++j+buf );\n      for( ; buf[j]!=',';j++ );\n      k = atoi( ++j+buf );\n      //       cout << x <<\"_\"<<y<<\"_\"<<k<< endl;\n      k = k/100 -1; // UÌ\n      cost[x][y] = k;\n      cost[y][x] = k;\n    }\n    cout << prim() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nint Par[100],Rank[100];\nvoid init(int n) {\n\tfor(int i=0;i<n;i++) {\n\t\tPar[i]=i;\n\t\tRank[i]=0;\n\t}\n}\nint find(int x) {\n\tif(Par[x]==x) {\n\t\treturn x;\n\t}else {\n\t\treturn Par[x]=find(Par[x]);\n\t}\n}\nvoid unite(int x,int y) {\n\tx=find(x);\n\ty=find(y);\n\tif(x==y) return;\n\tif(Rank[x]<Rank[y]) {\n\t\tPar[x]=y;\n\t}else {\n\t\tPar[y]=x;\n\t\tif(Rank[x]==Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x,int y) {\n\treturn find(x)==find(y);\n}\nstruct Edge {\n\tint u,v,cost;\n\tEdge(int _u,int _v,int _cost) {u=_u,v=_v,cost=_cost;}\n\tbool operator < (const Edge& E) const {return cost<E.cost;}\n};\nvector<Edge> es;\nint main() {\n\tint n,m,a,b,d;\n\twhile(scanf(\"%d\",&n),n) {\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++) {\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tes.push_back(Edge(a,b,d));\n\t\t}\n\t\tsort(es.begin(),es.end());\n\t\tint res=0;\n\t\tinit(n);\n\t\tfor(int i=0;i<es.size();i++) {\n\t\t\tif(!same(es[i].u,es[i].v)) {\n\t\t\t\tunite(es[i].u,es[i].v);\n\t\t\t\tres+=(es[i].cost/100-1);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",res);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\n//struct Edge{\n//\tint src,dst,weight;\n//\tEdge(){}\n//\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n//};\n//\n//bool operator<(const Edge& lhs,const Edge& rhs)\n//{\n//\treturn lhs.weight<rhs.weight;\n//}\n//\n//bool operator>(const Edge& lhs,const Edge& rhs)\n//{\n//\treturn lhs.weight>rhs.weight;\n//}\n//\n//typedef vector<Edge> Edges;\n//typedef vector<Edges> Graph;\n//\n//struct UnionFind{\n//\tvi data;\n//\tUnionFind(int size):data(size,-1){}\n//\tint Find(int n){\n//\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n//\t}\n//\tvoid Union(int n1,int n2){\n//\t\tint d1=Find(n1);\n//\t\tint d2=Find(n2);\n//\t\tif(d1!=d2){\n//\t\t\tif(-data[d1]<-data[d2])\n//\t\t\t\tswap(d1,d2);\n//\t\t\tdata[d1]+=data[d2];\n//\t\t\tdata[d2]=d1;\n//\t\t}\n//\t}\n//\tint Size(int n){\n//\t\treturn -data[Find(n)];\n//\t}\n//};\n//\n//int Kruskal(Graph& g,Edges& e)\n//{\n//\te.clear();\n//\t\n//\tUnionFind uf(g.size());\n//\tset<Edge> s;\n//\trep(i,g.size())\n//\t\trep(j,g[i].size())\n//\t\t\ts.insert(g[i][j]);\n//\t\n//\tint res=0;\n//\tforeach(i,s){\n//\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n//\t\t\tuf.Union(i->src,i->dst);\n//\t\t\tres+=i->weight;\n//\t\t\te.push_back(*i);\n//\t\t}\n//\t}\n//\t\n//\treturn res;\n//}\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  priority_queue<Edge> Q;\n  rep(u, n) foreach(e, g[u]) if (u < e->dst) Q.push(*e);\n\n  Weight total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (uf.unionSet(e.src, e.dst)) {\n      F.push_back(e);\n      total += e.weight;\n    }\n  }\n  return pair<Weight, Edges>(total, F);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\t//Edges e;\n\t\t//int sum=Kruskal(g,e);\n\t\t////cout<<sum/100-e.size()<<endl;\n\t\t//cout<<sum<<endl;\n\t\t\n\t\tcout<<minimumSpanningForest(g).first<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": " #include<iostream>\n #include<stdio.h>\n #include<string>\n #include<math.h>\n #include<iomanip>\n #include<algorithm>\n #include<string.h>\n #include<cctype>\n #include<map>\n #include<set>\n #include<vector>\n #include<sstream>\n #include<stack>\n #include<queue>\n #include<deque>\n #include<functional>\n #include<utility>\n \n using namespace std;\n \n const int MAX_V=500+5;\n const int INF=1000000000;\n \n int graph[MAX_V][MAX_V];\n int mincost[MAX_V];\n bool used[MAX_V];\n int V,m;\n \n int prim()\n {\n   for(int i=0;i<V;i++)\n   {\n     mincost[i]=INF;\n     used[i]=false;        \n   }    \n   mincost[0]=0;\n   int res=0;\n   while(true)\n   {\n     int v=-1;\n     for(int u=0;u<V;u++)\n     {\n       if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;        \n     }           \n     if(v==-1) break;\n     used[v]=true;\n     res+=mincost[v];\n     for(int u=0;u<V;u++)\n     {\n       mincost[u]=min(mincost[u],graph[u][v]);        \n     }\n   }\n   return res;\n }\n \n int main()\n {\n   while(cin>>V&&V&&cin>>m)\n   {\n     int p,q,d;\n     char temp1,temp2;\n     for(int i=0;i<V;i++)\n     {\n       for(int j=0;j<V;j++)\n       {\n         graph[i][j]=INF;        \n       }        \n     }\n     while(m--)\n     {\n       cin>>p>>temp1>>q>>temp2>>d;\n       graph[p][q]=(d/100-1);\n       graph[q][p]=(d/100-1);          \n     }                    \n     int result=prim();\n     cout<<result<<endl;        \n   }\n   //while(1);\n   return 0;\n }\n\n \n  "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\ntypedef pair<int,P> P1;\ntypedef pair<P,P> P2;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint par[100005];\nint ran[100005];\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\tran[i]=0;\n\t}\n}\nint find(int x){\n\tif(par[x] == x){\n\t\treturn x;\n\t}else{\n\t\treturn par[x]=find(par[x]);\n\t}\n}\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(x == y) return ;\n\tif(ran[x]<=ran[y]){\n\t\tpar[x]=par[y];\n\t}else{\n\t\tpar[y]=par[x];\n\t\tif(ran[x] == ran[y]) ran[x]++;\n\t}\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nstruct edge{\n\tint u,v,cost;\n};\nbool comp(edge a,edge b){\n\treturn a.cost<b.cost;\n}\nedge s[100005];\nint V,E;\nint kruskal(){\n\tsort(s,s+E,comp);\n\tinit(V);\n\tint res=0;\n\tfor(int i=0;i<E;i++){\n\t\tedge e=s[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres+=e.cost;\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(scanf(\"%d\",&V) && V){\n\t\tscanf(\"%d\",&E);\n\t\tfor(int i=0;i<E;i++){\n\t\t\tint w,e,r;\n\t\t\tscanf(\"%d,%d,%d\",&w,&e,&r);\n\t\t\tedge tt;\n\t\t\ttt.u=w;\n\t\t\ttt.v=e;\n\t\t\ttt.cost=(r-100)/100;\n\t\t\ts[i]=tt;\n\t\t}\n\t\tprintf(\"%d\\n\",kruskal());\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\nstruct EDGE\n{\n    int to, cost;\n    bool operator < (const EDGE& t) const {\n        return cost > t.cost;\n    }\n};\nvector<EDGE> v[100]; \nbool f[100];\nint search()\n{\n    int res = 0;\n    priority_queue<EDGE> que;\n    que.push({0, 0});\n    while (!que.empty()){\n        EDGE e = que.top(); que.pop();\n        if (f[e.to]) continue;\n        f[e.to] = true;\n        res += e.cost;\n        rep(i, v[e.to].size()){\n            if (!f[v[e.to][i].to]){\n                que.push(v[e.to][i]);\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d\", &n), n){\n        scanf(\"%d\", &m);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            c = c / 100 - 1;\n            v[a].pb({b, c});\n            v[b].pb({a, c});\n        }\n        printf(\"%d\\n\", search());\n        memset(f, false, sizeof(f));\n        rep(i, n) v[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<map>\n#include<set>\n#include<utility>\n#include<vector>\n#include<cmath>\n#include<cstring>\n#include<cstdio>\n#include<time.h>\n#define loop(i,a,b) for(int i=a;i<b;i++) \n#define rep(i,a) loop(i,0,a)\n#define pb push_back\n#define mp make_pair\n#define all(in) in.begin(),in.end()\nconst double PI=acos(-1);\nconst double EPS=1e-10;\nconst int inf=1e8;\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> vi;\nint main(){\n\tint n;\n\twhile(cin>>n,n){\n\t\tint m;\n\t\tcin>>m;\n\t\tvector<vector<int> >cost(n,vector<int>(n));\n\t\trep(i,n)rep(j,n)cost[i][j]=inf;\n\t\tvector<int>used(n);\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar d;\n\t\t\tcin>>a>>d>>b>>d>>c;\n\t\t\tc=(c-100)/100;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t}\n\t\tvector<int>d(n);\n\t\trep(i,n)d[i]=inf;\n\t\td[0]=0;\n\t\tint out=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\trep(i,n)if(!used[i]&&(v==-1||d[v]>d[i]))v=i;\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=true;\n\t\t\tout+=d[v];\n\t\t\trep(i,n)d[i]=min(d[i],cost[v][i]);\n\t\t}\n\t\tcout<<out<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Carden Lantern [AOJ 0072]\n// URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072\n//\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\ntypedef vector <PIP>    Edges;\n\nconst int size = 101;\nint P[size];\n\nvoid init( int n ) {\n    for ( int i = 0; i < n; i++ ) {\n        P[i] = -1;\n    }\n}\n\nint find( int a ) {\n    if ( P[a] == -1 ) {\n        return a;\n    }\n    return P[a] = find( P[a] );\n}\n\nvoid merge( int a, int b ) {\n    int fa = find( a ), fb = find( b );\n\n    if ( fa != fb ) {\n        if ( P[a] == -1 ) {\n            P[a] = fb;\n        } else {\n            P[b] = fa;\n        }\n    }\n}\n\nbool same_set( int a, int b ) {\n    return find( a ) == find( b );\n}\n\nint main( void ) {\n    string line;\n\n    while ( getline( cin, line ) ) {\n        // init\n        int n, m;\n        Edges E;\n\n        // input\n        if ( line == \"0\" ) {\n            break;\n        }\n        {\n            istringstream is( line );\n            is >> n;\n        }\n        {\n            getline( cin, line );\n            istringstream is( line );\n            is >> m;\n        }\n        for ( int i = 0; i < m; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            int a, b, c;\n            istringstream is( line );\n            is >> a >> b >> c;\n\n            PIP edge( c / 100, PII( a, b ) );\n            E.push_back( edge );\n        }\n\n        // proc\n        int answer = 0;\n        init( n );\n\n        sort( E.begin(), E.end() );\n        for ( int i = 0; i < m; i++ ) {\n            int a = E[i].second.first;\n            int b = E[i].second.second;\n            int c = E[i].first;\n\n            if ( !same_set( a, b ) ) {\n                answer += c - 1;\n                merge( a, b );\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 0072\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nstruct road{\n\tint dis;\n\tint v1;\n\tint v2;\n};\n\nint lantern(vector<road> ver){\n\tvector<bool> her;\n\tfor(int i=0;i<ver.size();i++)\n\t\ther.push_back(false);\n\n\tint lan = 0;\n\tfor(int i=0;i<ver.size();i++){\n\t\tif(her[ver[i].v1] == false || her[ver[i].v2] == false){\n\t\t\tlan += ver[i].dis/100-1;\n\t\t\ther[ver[i].v1] = true;\n\t\t\ther[ver[i].v2] = true;\n\t\t}\n\t}\n\n\treturn lan;\n}\n\nint main(){\n\twhile(1){\n\t\tint n, m, a, b, d;\n\t\tvector<road> ver;\n\t\troad v;\n\n\t\tcin>>n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tv.v1 = a;\n\t\t\tv.v2 = b;\n\t\t\tv.dis = d;\n\t\t\tver.push_back(v);\n\t\t}\n\n\t\tsort(ver.begin(), ver.end(),[](const road& x, const road& y) { return x.dis < y.dis;});\n\t\t\n\t\tcout<<lantern(ver)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nint Prim(Graph& g,Edges& tree,int root=0)\n{\n\ttree.clear();\n\t\n\tint size=g.size();\n\tvector<int> visited(size);\n\t\n\tpriority_queue<Edge,vector<Edge>,greater<Edge> > pq;\n\tpq.push(Edge(-1,root,0));\n\tint res=0;\n\twhile(!pq.empty()){\n\t\tEdge e=pq.top();\n\t\tpq.pop();\n\t\tif(visited[e.dst])\n\t\t\tcontinue;\n\t\tif(e.src!=-1)\n\t\t\ttree.push_back(e);\n\t\tvisited[e.dst]=1;\n\t\tres+=e.weight;\n\t\trep(i,g[e.dst].size()){\n\t\t\tEdge cand=g[e.dst][i];\n\t\t\tif(!visited[cand.dst])\n\t\t\t\tpq.push(cand);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\tEdges e;\n\t\tint sum=Prim(g,e);\n\t\tcout<<sum<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<algorithm>\nusing namespace std;\npair<int,pair<int,int> > edge[10000];\nint UF[100];\nint FIND(int a){\n\tif(UF[a]<0)return a;\n\treturn UF[a]=FIND(UF[a]);\n}\nvoid UNION(int a,int b){\n\ta=FIND(a);\n\tb=FIND(b);\n\tif(a==b)return;\n\tUF[a]+=UF[b];\n\tUF[b]=a;\n}\nint main(){\n\tint a;\n\twhile(scanf(\"%d\",&a),a){\n\t\tint b;\n\t\tscanf(\"%d\",&b);\n\t\tint now=0;\n\t\tfor(int i=0;i<a;i++)UF[i]=-1;\n\t\tfor(int i=0;i<b;i++){\n\t\t\tint c,d,e;\n\t\t\tscanf(\"%d,%d,%d\",&c,&d,&e);\n\t\t\tedge[now++]=make_pair(e/100-1,make_pair(c,d));\n\t\t}\n\t\tstd::sort(edge,edge+now);\n\t\tint ret=0;\n\t\tfor(int i=0;i<now;i++){\n\t\t\tif(FIND(edge[i].second.first)!=FIND(edge[i].second.second)){\n\t\t\t\tUNION(edge[i].second.first,edge[i].second.second);\n\t\t\t\tret+=edge[i].first;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ret);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nstruct Edge {\n  int len;\n  int to;\n};\n\nint n;\nint m;\nbool used[10000];\nvector<Edge> es[10000];\npriority_queue<Pair, vector<Pair>, greater<Pair> > q;\n\nint CalcMSTCost() {\n  int ret = 0;\n\n  fill(used, used+n, false);\n  q.push(Pair(0, 0));\n  while (!q.empty()) {\n    Pair p = q.top(); q.pop();\n    int d = p.first;\n    int v = p.second;\n\n    if (used[v]) continue;\n    used[v] = true;\n    ret += d;\n    for (int i=0; i<es[v].size(); i++) {\n      q.push(Pair(es[v][i].len, es[v][i].to));\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      es[i].clear();\n    }\n  \n    scanf(\"%d\", &m);\n    for (int i=0; i<m; i++) {\n      int a, b;\n      struct Edge e;\n      scanf(\"%d,%d,%d\", &a, &b, &e.len);\n      --a;\n      --b;\n      e.len -= 100;\n      e.to = b;\n      es[a].push_back(e);\n      e.to = a;\n      es[b].push_back(e);\n    }\n\n    printf(\"%d\\n\", CalcMSTCost()/100);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\n#include <climits>\n\nstatic int const N = 100;\n\nint main()\n{\n  for(;;) {\n    int n, m;\n    std::cin >> n;\n    if ( n == 0 )\n      break;\n\n    std::cin >> m;\n    int G[N][N] = {};\n    for( int i=0; i<N; ++i )\n      std::fill( G[i], G[i] + N, INT_MAX );\n\n    for( int i=0; i<m; ++i ) {\n      int a, b, l;\n      std::scanf( \"%d,%d,%d\", &a, &b, &l );\n      l = l / 100 - 1;\n    \n      G[a][b] = G[b][a] = l;\n    }\n\n    int d[N], p[N] = {};\n    bool visited[N] = {};\n    std::fill( d, d + N, INT_MAX );\n    std::fill( visited, visited + N, false );\n\n    // initialize\n    int u = 0;\n    d[u] = 0;\n    p[u] = -1;\n    \n    int sum = 0;\n\n    for( int i=0; i<n; ++i ) {\n      int tmp = INT_MAX;\n      for( int j=0; j<n ; ++j ) {\n\tif ( !visited[j] && d[j] < tmp ) {\n\t  u = j;\n\t  tmp = d[j];\n\t}\n      }\n      visited[u] = true;\n      sum += d[u];\n            \n      for( int j=0; j<n; ++j ) {\n\tif ( !visited[j] && G[u][j] < d[j] ) {\n\t  d[j] = G[u][j];\n\t  p[j] = u;\n       \t}\n      }\n    }\n    std::cout << sum << std::endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nusing Weight = int;\nstruct Edge {\n\tint src, dst; Weight weight;\n\tEdge() {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\n\nstruct UnionFind {\n\tvector<int> par;\n\tint cnt;\n\tUnionFind(int size_) : par(size_, -1), cnt(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif((x = find(x)) != (y = find(y))) {\n\t\t\tif(par[y] < par[x]) swap(x, y);\n\t\t\tpar[x] += par[y]; par[y] = x; cnt--;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tint size(int x) { return -par[find(x)]; }\n\tint size() { return cnt; }\n};\n\nbool operator < (const Edge &e, const Edge &f) { return e.weight < f.weight; }\npair<Weight, Edges> kruskal(int N, Edges es) {\n\tUnionFind uf(N);\n\tWeight total = 0; Edges T;\n\tfor(auto &e : es) if(!uf.same(e.src, e.dst)) {\n\t\tT.push_back(e); total += e.weight; uf.unite(e.src, e.dst);\n\t}\n\treturn make_pair(total, T);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\twhile(cin >> n >> m, n) {\n\t\tEdges G;\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tint a, b, d;\n\t\t\tchar c;\n\t\t\tcin >> a >> c >> b >> c >> d;\n\t\t\tG.push_back(Edge(a, b, d / 100 - 1));\n\t\t}\n\t\tsort(G.begin(), G.end());\n\t\tauto res = kruskal(n, G);\n\t\tcout << res.first << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint INF = 1 << 30;\n\nint main(void)\n{\n\tint n,d;\n\tint path[200][200];\n\tint x,y,cost; // 飾り\n\tint used[200]; // 木に入ったか\n\tint mincost; // 最安値\n\tint minnum; // 安い点\n\tint ans;\n\tint minsia;\n\n\tscanf(\"%d\", &n);\n\twhile(n != 0){\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tpath[i][j] = INF;\n\t\t\t}\n\t\t\tused[i] = 0;\n\t\t}\n\t\tused[0] = 1;\n\n\t\tscanf(\"%d\", &d);\n\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tscanf(\"%d,%d,%d\", &x, &y, &cost);\n\t\t\tpath[x][y] = cost;\n\t\t\tpath[y][x] = cost;\n\t\t}\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tmincost = INF + 1;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(used[j] == 1){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(path[j][k] < mincost){\n\t\t\t\t\t\t\tif(used[k] != 1){\n\t\t\t\t\t\t\t\tminsia = j;\n\t\t\t\t\t\t\t\tminnum = k;\n\t\t\t\t\t\t\t\tmincost = path[j][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tscanf(\"%d\", &n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n\nusing namespace std;\n\n#define MIN(A, B) (A) < (B) ? (A) : (B)\n\n\nint main() {\n\tbool st[10000];\n\tint a[10000], b[10000], d[10000];\n\tint n, m;\t\n\twhile (cin >> n, n) {\n\t\tmemset(st, 0, sizeof st);\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint dis;\n\t\t\tscanf(\"%d,%d,%d\", &a[i], &b[i], &dis);\n\t\t\td[i] = dis/100;\n\t\t}\n\t\t\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tint min = -1;\n\t\t\tfor (int j = 0; j < m; j++) {\n\t\t\t\tif (a[j] == i || b[j] == i) {\n\t\t\t\t\tif (min == -1)\n\t\t\t\t\t\tmin = j;\n\t\t\t\t\telse\n\t\t\t\t\t\tmin = d[min] < d[j] ? min : j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tst[min] = true;\n\t\t}\n\n\t\tint md = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (st[i])\n\t\t\t\tmd += d[i];\n\t\t}\n\n\t\tcout << md - (n-1) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1000000000000000000LL\nusing namespace std;\nlong long prim(int V, vector<pair<long long, long long>> X[]) {\n\tpriority_queue<pair<long long, long long> > Q; long long dist[100], color[100];\n\tfor (int i = 0; i < V; i++) { dist[i] = INF; color[i] = WHITE; }\n\tdist[0] = 0; color[0] = GRAY; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<long long, long long>pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; color[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first, leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && color[to] < BLACK) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < V; i++) { sum += dist[i]; }//0-indexed\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<long long, long long> > g[100];\nint main() {\n\twhile(cin >> n >> m) {\n\t\tfor(int i = 0; i < n; i++) g[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", u, v, w);\n\t\t\tg[u].push_back(make_pair(v, w / 100 - 1));\n\t\t\tg[v].push_back(make_pair(u, w / 100 - 1));\n\t\t}\n\t\tcout << prim(n, g) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\nint par[110], rk[110];\nvoid init(int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tpar[i] = i;\n\t\trk[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x)return x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\n\tif (rk[x] < rk[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif (rk[x] == rk[y])rk[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tint u, v, cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\n\nedge es[110];\nint n, m;\n\nint kruskal() {\n\tsort(es, es + m, comp);\n\tinit(n);\n\tll res = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += (e.cost) / 100 - 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d;\n\t\t\tscanf_s(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tes[i].u = a, es[i].v = b, es[i].cost = d;\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define MAX_V 100\n#define INF (1<<21)\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\nint prim(){\n  for(int i = 0; i < V; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(1){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u = 0; u < V; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  while(1){\n    for(int i = 0; i < MAX_V; i++){\n      for(int j = 0; j < MAX_V; j++){\n\tcost[i][j] = INF;\n      }\n    }\n    cin >> V;\n    if(V == 0) break;\n    cin >> m;\n    for(int i = 0; i < V; i++){\n      int a, b, c;\n      char d, e;\n      cin >> a >> d >> b >> e >> c;\n      cost[a][b] = c;\n    }\n    int t = prim();\n    t = t / 100 - m + 1;\n    cout << t << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n\n#define MAX_V 101\n#define INF 10000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\n\nint V,mincost[MAX_V];\nvector<edge>G[MAX_V];\n\nint Prim(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  fill(mincost, mincost+V, INF);\n\n  vector<bool> visited(V);\n  fill(visited.begin(),visited.end(),false);\n\n  mincost[s]=0;\n  que.push(P(0,s));\n  int res=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    \n    int v = p.second;\n    if(visited[v])continue;\n    visited[v]=true;\n    res+=mincost[v];\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(mincost[e.to] > e.cost && !visited[e.to]){\n\tmincost[e.to] = e.cost;\n\tque.push(P(mincost[e.to], e.to));\n      }\n    }\n  }\n \n  return res;\n}\n\n\nint main(void){\n  int m,a,b,c;\n  char ch1,ch2;\n  edge e;\n\n  while(cin >> V,V){\n    for(int i=0;i<V;i++)G[i].clear();\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> a >> ch1 >> b >> ch2 >> c;\n      e.to=b,e.cost=c/100-1;\n      G[a].push_back(e);\n      e.to=a;\n      G[b].push_back(e);\n    }\n      cout << Prim(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost + n,numeric_limits<int>::max());\n\n\n\t\tint** cost = new int*[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcost[i] = new int[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcost[i][j]=numeric_limits<int>::max();\n\t\t\t}\n\t\t}\n\n\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from,to,dist;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&dist);\n\t\t\tcost[from][to] = min(cost[from][to],dist / 100 - 1);\n\t\t\tcost[to][from] = cost[from][to];\n\t\t}\n\n\t\tmincost[0]=0;\n\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!used[i] && (v==-1 || mincost[i] < mincost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(used[i]){\n\t\t\t\t\tmincost[v] = min(mincost[v],cost[i][v]);\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tused[v] = true;\t\n\t\t\tres+=mincost[v];\n\t\t}\n\n\t\tcout << res << endl;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdelete[] cost[i];\n\t\t}\n\n\t\tdelete[] cost;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define REP(i,s,e)\tfor(int i=(s); i<(e); i++)\n#define rep(i,n)\tREP(i,0,n)\n#define REPE(i,s,e)\tfor(int i=s; i>e; i--)\n#define repe(i,n)\tREPE(i,n,-1)\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef vector<vi> vii;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n \n\nconst int MAX_E = 300100;\nconst int MAX_V = 100100;\n \nint par_uft[MAX_V];\nint rank_uft[MAX_V];\n \nvoid init_uft(int n) {\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tpar_uft[i] = i;\n\t\trank_uft[i] = 0;\n\t}\n}\n \nint find_uft(int x) {\n\tif (par_uft[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par_uft[x] = find_uft(par_uft[x]);\n\t}\n}\n \nvoid unite_uft(int x, int y) {\n\tx = find_uft(x);\n\ty = find_uft(y);\n\tif (x == y)return;\n \n\tif (rank_uft[x] < rank_uft[y]) {\n\t\tpar_uft[x] = y;\n\t}\n\telse {\n\t\tpar_uft[y] = x;\n\t\tif (rank_uft[x] == rank_uft[y]) {\n\t\t\trank_uft[x]++;\n\t\t}\n\t}\n}\n \nbool same_uft(int x, int y) {\n\treturn find_uft(x) == find_uft(y);\n}\n \n \n \nstruct edge { int u, v, cost; };\n \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n \nedge es[MAX_E];\nint V, E;\n \nll kruskal() {\n\tsort(es, es + E, comp);\n\tinit_uft(V);\n\tll res = 0LL;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same_uft(e.u, e.v)) {\n\t\t\tunite_uft(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tchar c;\n\tint a,b,d;\n\twhile(cin>>V>>E){\n\t\tif(E==0)break;\n\t\trep(i,E){\n\t\t\tcin>>a>>c>>b>>c>>d;\n\t\t\td/=100;\n\t\t\td--;\n\t\t\tif(a>b){\n\t\t\t\tint t=a;\n\t\t\t\ta=b;\n\t\t\t\tb=t;\n\t\t\t}\n\t\t\tes[i].u=a;\n\t\t\tes[i].v=b;\n\t\t\tes[i].cost=d;\n\t\t}\n\t\tcout<<kruskal()<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w > e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\n//????°???¨?????¨\n//Prim O(ElogV)\n//r????????°?????????????????????????±?\n//Edge??? bool operator<(const Edge &e)const { return w > e.w; } ????????????????????????\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n\tEdges T; Weight total = 0; vector<int> v(g.size());\n\tpriority_queue <Edge> q;\n\tq.emplace(-1, r, 0);\n\twhile (q.size()) {\n\t\tEdge e = q.top(); q.pop();\n\t\tif (v[e.d]) continue;\n\t\tv[e.d] = true;\n\t\ttotal += e.w; if (e.s != -1) T.emplace_back(e);\n\t\tfor (auto &f : g[e.d]) if (!v[f.d]) q.emplace(f);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, m) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].emplace_back(a, b, d);\n\t\t\tg[b].emplace_back(b, a, d);\n\t\t}\n\t\tpair<Weight, Edges> k = prim(g, 0);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_V = 100000;\n\n//union-find tree defenition\n\nint par[MAX_V];\n\nvoid init(int n){\n    for(int x = 0; x < n;x++){\n        par[x] = -1;\n    }\n}\n\nint find(int x){\n    if(par[x] < 0) return x;\n    return par[x] = find(par[x]);\n}\n\nbool same(int a, int b){\n    return find(a) == find(b);\n}\n\nbool unite(int a, int b){\n    int xa = find(a), xb = find(b);\n    if(xa == xb) return false;\n    if(par[xa] < par[xb]){\n        par[xb] = xa;\n    }else{\n        if(par[xa] == par[xb]){\n            par[xb]--;\n        }\n        par[xa] = xb;\n    }\n    return true;\n}\n\n//END union-find tree definition\n\nstruct edge{\n    int from;\n    int to;\n    int cost;\n    edge(){}\n    ~edge(){}\n    edge(int a, int b, int c) : from(a), to(b), cost(c){}\n    bool operator < (const edge& r) const {\n        return cost < r.cost;\n    }\n};\n\nvector<edge> G;\nint V;\n\nvoid append_edge(int from, int to, int cost){\n    G.push_back(edge(from, to, cost));\n}\n\nint kruskal(void){\n    init(V);\n    sort(G.begin(), G.end());\n    int ret = 0;\n    for(int i = 0; i < G.size(); i++){\n        edge e = G[i];\n        if(!unite(e.from, e.to)) break;\n        ret += e.cost;\n    }\n    return ret;\n}\n\nint main(){\n    int m, a, b, c;\n    while(scanf(\"%d%d\", &V, &m) && V){\n        G.clear();\n        for(int x = 0; x < m; x++){\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            append_edge(a, b, c / 100 - 1);\n        }\n        int res = kruskal();\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\nint par[110], rk[110];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trk[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x)return x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\n\tif (rk[x] < rk[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif (rk[x] == rk[y])rk[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tll u, v, cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\n\nedge es[110];\nint n, m;\n\nll kruskal() {\n\tsort(es, es + m, comp);\n\tinit(n);\n\tll res = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += (e.cost) / 100 - 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tll a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tes[i].u = a, es[i].v = b, es[i].cost = d;\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\n\nstruct E\n{\n\tint u, v, cost;\n};\nbool comp(const E& l, const E& r)\n{\treturn l.cost < r.cost;\t}\n\n\n\nvint par;\nvint rank;\n\nvoid init(int n)\n{\n\trep(i, n)\n\t{\n\t\t::par.push_back(i);\n\t\t::rank.push_back(0);\n\t}\n}\n\nint find(int x)\n{\n\tif(par[x] == x) return x;\n\telse\t\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y) return;\n\n\n\tif(::rank[x] < ::rank[y])\tpar[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif(::rank[x] == ::rank[y]) ::rank[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n && n)\n\t{\n\t\tcin >> m;\n\n\t\tvector<E> es(m);\n\n\t\tchar k;\n\t\trep(i, m)\n\t\t\tcin >> es[i].u >> k >> es[i].v >> k >> es[i].cost;\n\n\t\tsort(ALL(es), comp);\n\t\tinit(n);\n\n\t\tint res = 0;\n\t\trep(i, m)\n\t\t{\n\t\t\tE e = es[i];\n\t\t\tif(!same(e.u, e.v))\n\t\t\t{\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tres += e.cost - 100;\n\t\t\t}\n\t\t}\n\n\t\tcout << res / 100 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\ntypedef long long ll;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<ll> VL;\ntypedef vector<VL> VVL;\ntypedef pair<int, int> PII;\n\n#define FOR(i, a, n) for (ll i = (ll)a; i < (ll)n; ++i)\n#define REP(i, n) FOR(i, 0, n)\n#define ALL(x) x.begin(), x.end()\n#define MP make_pair\n#define PB push_back\n#define MOD 1000000007\n#define INF (1LL<<30)\n#define LLINF (1LL<<60)\n#define PI 3.14159265359\n#define EPS 1e-12\n//#define int ll\n\n#define MAX_N 200000\n\nclass UnionFind {\nprivate:\n  // ?????¨??¨?????±???\n  int par[MAX_N];\n  int rank[MAX_N];\n  int s[MAX_N];\npublic:\n  void init(int n);\n  int find(int x);\n  void unite(int x, int y);\n  bool same(int x, int y);\n};\n\n// ????´???°n??§?????????\nvoid UnionFind::init (int n) {\n  for(int i=0; i<n; i++) {\n    par[i] = i;\n    rank[i] = 0;\n    s[i] = 1;\n  }\n}\n\n// ????´?x??????????±???????\nint UnionFind::find(int x) {\n  if(par[x] == x) return x;\n  else return par[x] = find(par[x]);\n}\n\n// x??¨y????±??????????????????????\nvoid UnionFind::unite(int x, int y) {\n  // x??¨y??????\n  x = find(x);\n  y = find(y);\n  if(x == y) return;\n\n  // y??????????????±????????±??????x?????????y??????\n  if(rank[x] < rank[y]) {\n    par[x] = y;\n    s[y] = s[x] + s[y];\n  }\n  else {\n    par[y] = x;\n    s[x] = s[x] + s[y];\n    if( rank[x] == rank[y] ) rank[x]++;\n  }\n}\n\n// x??¨y???????????????????±??????????\nbool UnionFind::same(int x, int y) { return find(x) == find(y);}\n\nstruct edge{\n  int u, v, cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost < e2.cost;\n}\n\nedge es[10000];\nint v, e;\nUnionFind uf;\n\nint kruskal() {\n  sort(es, es+e, comp);\n  uf.init(v);\n  int res = 0;\n  REP(i, e) {\n    edge e = es[i];\n    if(!uf.same(e.u, e.v)) {\n      uf.unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nsigned main(void)\n{\n  while(true) {\n    cin >> v;\n    if(!v) break;\n    cin >> e;\n    REP(i, e) {\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      es[i] = {a, b, c/100-1};\n    }\n    cout << kruskal() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V;//??????\nint E;//???\nstruct edge { int from, to, cost; };\ntypedef std::pair<int, int> PP;\nstd::vector<edge> e;\nint Par[100000];\nint Rank[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (std::cin >> V&&V) {\n\t\tstd::cin >> E;\n\t\tint a, b, c;\n\t\tchar aa,bb;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tstd::cin >> a >>aa>> b >>bb>> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tstd::cout << kruskal()/100-V+1 << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight): src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    return weight < rhs.weight;\n  }\n};\n\nstruct UnionFind {\n  int parent[100];\n  UnionFind() {\n    memset(parent, -1, sizeof(parent));\n  }\n\n  bool unite(int x, int y) \n  {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) { swap(x, y); }\n    parent[x] += parent[y];\n    parent[y] = x;\n    return true;\n  }\n\n  bool find(int x, int y) \n  {\n    return root(x) == root(y);\n  }\n\n  int root(int x) \n  {\n    return parent[x] < 0 ? x : parent[x] = root(parent[x]);\n  }\n};\n\nint M, N;\nvector<Edge> es;\nvoid Solve() \n{\n  sort(es.begin(), es.end());\n  UnionFind uf;\n  int res = 0;\n  for (int i = 0; i < M; i++) {\n    Edge e = es[i];\n    if (!uf.find(e.src, e.dest)) {\n      uf.unite(e.src, e.dest);\n      res += (int)(e.weight / 100) - 1;\n    }\n  \n  }\n  cout << res << endl;\n}\n\nint main() \n{\n  int u, v, w;\n  while (cin >> N && N) {\n    cin >> M;\n    es.clear();\n    for (int i = 0; i < M; i++) {\n      scanf(\"%d,%d,%d\", &u, &v, &w);\n      es.push_back(Edge(u, v, w));\n    }\n\n    Solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <iomanip>\n#include <algorithm>\n#include <cmath>\n#include <string>\n#include <vector>\n#include <list>\n#include <queue>\n#include <stack>\n#include <set>\n#include <map>\n#include <bitset>\n#include <numeric>\n#include <climits>\n#include <cfloat>\nusing namespace std;\n\nclass Edge\n{\npublic:\n    int to, cost;\n    Edge(){};\n    Edge(int to0, int cost0){to = to0; cost = cost0;}\n};\n\nlong long minSpanningTree(const vector<vector<Edge> >& edges)\n{\n    int n = edges.size();\n    vector<bool> used(n, false);\n    int usedNum = 0;\n    vector<int> minCost(n, INT_MAX);\n    priority_queue<pair<int,int> ,vector<pair<int,int> >, greater<pair<int,int> > > q;\n    q.push(make_pair(0, 0));\n\n    long long ret = 0;\n    while(!q.empty()){\n        pair<int, int> p = q.top();\n        q.pop();\n        int v = p.second;\n        if(used[v])\n            continue;\n        ret += p.first;\n        used[v] = true;\n        if(++usedNum == n)\n            return ret;\n        for(unsigned i=0; i<edges[v].size(); ++i){\n            Edge e = edges[v][i];\n            if(!used[e.to] && e.cost < minCost[e.to]){\n                minCost[e.to] = e.cost;\n                q.push(make_pair(e.cost, e.to));\n            }\n        }\n    }\n    return -1;\n}\n\n\nint main()\n{\n    for(;;){\n        int n, m;\n        cin >> n >> m;\n        if(n == 0)\n            return 0;\n\n        vector<vector<Edge> > edges(n);\n        for(int i=0; i<m; ++i){\n            int a, b, cost;\n            char c;\n            cin >> a >> c >> b >> c >> cost;\n            edges[a].push_back(Edge(b, cost/100-1));\n            edges[b].push_back(Edge(a, cost/100-1));\n        }\n\n        cout << minSpanningTree(edges) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define M 9999\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;scanf(\"%d%d\",&n,&m)>1;printf(\"%d\\n\",s/100-n+1)){\n\t\tfor(i=0;i<m;i++)scanf(\"%d,%d,%d\",a+i,b+i,&node[i].first),node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\nusing namespace std;\nlong long prim(int V, vector<pair<long long, long long>> X[]) {\n\tfor (int i = 0; i < V; i++) { dist[i] = INF; color[i] = WHITE; }\n\tdist[0] = 0; color[0] = GRAY; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<long long, long long>pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; color[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first, leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && color[to] < BLACK) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < V; i++) { sum += dist[i]; }//0-indexed\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<long long, long long> > g[100];\nint main() {\n\twhile(cin >> n >> m) {\n\t\tfor(int i = 0; i < n; i++) g[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", u, v, w);\n\t\t\tg[u].push_back(make_pair(v, w / 100 - 1));\n\t\t\tg[v].push_back(make_pair(u, w / 100 - 1));\n\t\t}\n\t\tcout << prim(n, g) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <climits>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <stack>\n#include <vector>\n#include <queue>\n#include <bitset>\n#include <string>\nusing namespace std;\n\n#define REP(i,n) for(int i=0; i<n; i++)\n#define RPA(i,s,e) for(int i=s; i<=e; i++)\n#define RPD(i,s,e) for(int i=s; i>=e; i--)\n#define PB(a) push_back(a)\n#define MP(i,s) make_pair(i,s)\n#define ALL(a) (a).begin(), (a).end()\n#define PRT(a) cout << (a) << endl\n\ntypedef pair<int,int> P;\n\nconst int INF = 100000009;\nint m, n;\nint dist[101][101];\nbool used[101];\nint f, t, c;\n\nint solve() {\n\tmemset(used, 0, sizeof(used));\n\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tused[0] = true;\n\tREP(i,m) {\n\t\tif(dist[0][i] != INF) {\n\t\t\tque.push(P(dist[0][i], i));\n\t\t}\n\t}\n\n\tint cost = 0;\n\twhile(!que.empty()) {\n\t\tP p = que.top();\n\t\tque.pop();\n\n\t\tint from = p.second;\n\t\tif(used[from]) continue;\n\t\n\t\tused[from] = true;\n\t\tcost += p.first;\n\t\tREP(i,m) {\n\t\t\tif(dist[from][i] != INF && !used[i]) {\n\t\t\t\tque.push(P(dist[from][i], i));\n\t\t\t}\n\t\t}\n\t}\n\treturn cost;\n}\n\nvoid coding() {\n\twhile(scanf(\"%d\", &m) != EOF) {\n\t\tif(m == 0) break;\n\t\tscanf(\"%d\", &n);\n\n\t\tREP(i,m) {\n\t\t\tREP(j,m) {\n\t\t\t\tdist[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tREP(i,n) {\n\t\t\tscanf(\"%d,%d,%d\", &f, &t, &c);\n\t\t\tc = c / 100 - 1;\n\t\t\tdist[f][t] = c;\n\t\t\tdist[t][f] = c;\n\t\t}\n\t\tprintf(\"%d\\n\", solve());\n\t}\n}\n\n// #define _LOCAL_TEST\n\nint main() {\n#ifdef _LOCAL_TEST\n\tfreopen(\"a.in\", \"r\", stdin);\n#endif\n\n\tcoding();\n\n#ifdef _LOCAL_TEST\n\tcout << endl;\n\tcout << \"This is local test\" << endl;\n\tcout << \"Do not forget to comment out _LOCAL_TEST\" << endl;\n#endif\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int MAX = 100000;\n\nint par[MAX],rank[MAX],n,m;\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x); y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint kruskal(pair<int,pair<int,int> > es[MAX]){\n  sort(es,es + m);\n  init(n);\n  int res = 0;\n  for(int i = 0 ; i < m ; i++){\n    int a = es[i].second.first;\n    int b = es[i].second.second;\n    if(!same(a,b)){\n      res += es[i].first;\n      unite(a,b);\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> n,n){\n    cin >> m;\n    pair<int,pair<int,int> > es[MAX];\n    for(int i = 0 ; i < m ; i++){\n      scanf(\"%d,%d,%d\", &es[i].second.first, &es[i].second.second,&es[i].first);\n    }\n    for(int i = 0 ; i < m ; i++){\n      es[i].first = es[i].first/100-1;\n    }\n\n    cout << kruskal(es) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#define INF 10000000\n#define MAX_V 100\nusing namespace std;\nint n,m;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint prim(){\n  int res = 0;\n  fill(mincost,mincost + n,INF);\n  fill(used,used + n,false);\n\n  mincost[0] = 0;\n  while(1){\n\n    int v = -1;\n\n    for(int u = 0 ; u < n ; u++ ){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]))v = u;\n    }\n    if(v == -1)break;\n    used[v] = true;\n    res += mincost[v];\n    for(int i = 0 ; i < n ; i++ ){\n      mincost[i] = min(mincost[i],cost[i][v]);\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  char ch;\n  while(cin >> n,n){\n    cin >> m;\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = 0 ; j < n ; j++ ){\n\tcost[i][j] = INF;\n      }\n    }\n    for(int i = 0 ; i < m ; i++ ){\n      int a,b,c;\n      cin >> a >> ch >> b >> ch >> c;\n      cost[a][b] = cost[b][a] = (c-100)/100;\n    }\n    cout <<  prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <list>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\nint main(){\n\tint n,m,a,b,c,mi,ret;\n\tint info[100][100];\n\n\twhile(cin >> n && n){\n\t\tcin >> m;\n\t\tret = 0;\n\t\trep(i,100)rep(j,100)info[i][j] = INT_MAX;\n\n\t\trep(i,m){\n\t\t\tscanf(\"%d,%d,%d\\n\",&a,&b,&c);\n\t\t\tinfo[a][b] = info[b][a] = (c/100)-1;\n\t\t}\n\n\t\tlist<int> X,Y;\n\t\tX.push_back(0);\n\t\tfor(int i=1;i<n;i++){\n\t\t\tY.push_back(i);\n\t\t}\n\n\t\twhile(!Y.empty()){\n\t\t\tmi = INT_MAX;\n\t\t\tfor(list<int>::iterator it = X.begin(); it != X.end(); ++it){\n\t\t\t\trep(i,n){\n\t\t\t\t\tif( count(Y.begin(),Y.end(),i) ){\n\t\t\t\t\t\tif(info[*it][i]<mi){\n\t\t\t\t\t\t\ta = i;\n\t\t\t\t\t\t\tmi = info[*it][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tX.push_back(a);\n\t\t\tfor(list<int>::iterator it = Y.begin(); it != Y.end(); ++it){\n\t\t\t\tif((*it)==a){\n\t\t\t\t\tY.erase(it);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tret+=mi;\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<queue>\n#include<map>\n#include<cstdio>\nusing namespace std;\ntypedef pair<int, int> P;\ntypedef pair<int, P> T;\nint u[105];\n\nint p(int x){\n    if(u[x] == x)return x;\n    return u[x] = p(u[x]);\n}\n\nvoid unin(int x, int y){\n    x = p(x);\n    y = p(y);\n    u[x] = y;\n}\n\nint main(){\n    int n, m, a, b, w;\n    while(cin >> n, n){\n\tcin >> m;\n\tint res = 0;\n\tpriority_queue<T, vector<T>, greater<T> > pq;\n\tfor(int i = 0;i < m;i++){\n\t    scanf(\"%d,%d,%d\", &a, &b, &w);\n\t    w/=100;w--;\n\t    pq.push(T(w, P(a, b)));\n\t}\n\tfor(int i = 0;i <= n;i++)u[i] = i;\n\twhile(!pq.empty()){\n\t    T tmp = pq.top();pq.pop();\n\t    int a = tmp.second.first, b = tmp.second.second;\n\t    if(p(a) == p(b))continue;\n\t    unin(a, b);\n\t    res += tmp.first;\n\t}\n\tcout << res << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 100000000\nusing namespace std;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\nint n;\nint prim();\nmain(){\n  int m;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    cin >> m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      c/=100;\n      cost[a][b]=cost[b][a]=c;\n    }\n    \n    cout << prim() << endl;\n  }\n  return 0;\n}\n\nint prim(){\n  for(int i=1;i<n;i++){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  mincost[0]=0;\n  int res=0;\n\n  while(true){\n    int v=-1;\n    for(int u=0;u<n;u++){\n      if(!used[u] && (v==-1 || mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    used[v]=true;\n    if(v==0) res+=mincost[v];\n    else res+=mincost[v]-1;\n    for(int u=0;u<n;u++){\n      mincost[u]=min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define INF 1e6\nusing namespace std;\n\nint dist[200][200];\nint mincost[200];\nbool used[200];\nint n,m,a,b,d;\n\t\nint prim(){\n\tint ans=0;\n\trep(i,n){mincost[i]=INF;used[i]=false;}\n\tmincost[0]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\trep(u,n)if(!used[u] && (v==-1 || mincost[u]<mincost[v]))v=u;\n\t\tif(v==-1)break;\n\t\tused[v]=true;\n\t\tans+=mincost[v];\n\t\trep(u,n)mincost[u]=min(mincost[u],dist[v][u]);\n\t}\n\treturn ans;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\trep(i,n)rep(j,n)dist[i][j]=(i==j)?0:INF;\n\t\trep(i,m){scanf(\"%d,%d,%d\",&a,&b,&d);dist[a][b]=dist[b][a]=d/100-1;}\n\t\tcout<<prim()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<cstdio>\n#include<algorithm>\nconst int N = 100000;\nint par[N];\nint rank[N];\n\nvoid init(int n){\n\tfor (int i = 0; i < n; ++i){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif (par[x] == x)return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\tif (rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}\n\telse{\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y])rank[x]++;\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tint u, v, cost;\n};\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nedge es[1000000];\nint V, E;\n\nint kruskal(){\n\tstd::sort(es, es + E, comp);\n\tinit(V);\n\tint res = 0;\n\tfor (int i = 0; i < E; ++i){\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)){\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0)break;\n\t\tscanf(\"%d\", &E);\n\t\tfor (int i = 0; i < E; ++i){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tes[i].u = a, es[i].v = b, es[i].cost = c;\n\t\t}\n\t\tint ans = kruskal();\n\t\tprintf(\"%d\\n\", ans / 100 - V + 1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\nusing namespace std;\nstruct edge { int u, v, cost; };\nstruct unionfind {\n    int par[100], rank[100];\n    unionfind(int n) {\n        for (int i=0; i<n; i++) {\n            par[i]=i;\n            rank[i]=0;\n        }\n    }\n    int find(int x) {\n        if (x==par[x]) {\n            return x;\n        } else {\n            return par[x]=find(par[x]);\n        }\n    }\n    void unite(int x, int y) {\n        x=find(x);\n        y=find(y);\n        if (x==y) return;\n        if (rank[x]<rank[y]) {\n            par[x]=y;\n        } else {\n            par[y]=x;\n            if (rank[x]==rank[y]) rank[x]++;\n        }\n    }\n    bool same(int x, int y) {\n        return find(x)==find(y);\n    }\n};\nbool comp(const edge& a, const edge& b) {\n    return a.cost<b.cost;\n}\nedge es[10000];\nint main() {\n    int n, m;\n    while (scanf(\"%d\",&n)) {\n        if (!n) break;\n        scanf(\"%d\",&m);\n        unionfind uf(n);\n        for (int i=0; i<m; i++) {\n            int a, b, d; scanf(\"%d%*c%d%*c%d\",&a,&b,&d);\n            es[i]=(edge){a,b,d/100-1};\n        }\n        sort(es, es+m, comp);\n        int res=0;\n        for (int i=0; i<m; i++) {\n            edge e=es[i];\n            if (!uf.same(e.u,e.v)) {\n                uf.unite(e.u,e.v);\n                res+=e.cost;\n            }\n        }\n        printf(\"%d\\n\",res);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <sstream>\n#include <cstdlib>\n#include <cstring>\n#include <functional>\n#include <numeric>\n#include <cmath>\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <fstream>\n\nusing namespace std;\n\nstruct TREE {\n\tint sum;\n\tint edge;\n};\n\n\n// SæÅ¬Øðßé\nstruct TREE *make_tree (vector <vector <int> > t, TREE **tree )\n{\n\tint size = t.size();\n\tint i,j;\n\tint used_edge = 0;\n\t \n\tfor (i = 0; i < size; ++i){\n\t\tint n;\n\t\tint sum = 0;\n\t\tused_edge = 0;\n\t\tvector <bool> v (size, false );\n\t\tqueue<int> Q;\n\n\t\tQ.push (i );\t// i is Root \n\t\tv[i] = true;\n\n\t\twhile (!Q.empty() ){\n\t\t\tn = Q.front();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tfor (j = 0; j < size; ++j){\n\t\t\t\tif (!v[j] && t[n][j] != 0 ){\n\t\t\t\t\tQ.push (j ) ;\n\t\t\t\t\tv[j] = true;\n\t\t\t\t\tsum += t[n][j];\n\t\t\t\t\t++used_edge;\n\t\t\t\t} // end if\n\t\t\t} // end for\n\t\t} // end while\n//\t\tcout << \"sum: \" << sum << endl;\n\t\ttree[i]->sum = sum;\n\t\ttree[i]->edge = used_edge;\n\t} // end for\n\n\tint res = INT_MAX;\n\tint min_index = -1;\n\tfor (i = 0; i < size; ++i){\n\t\tif (tree[i]->sum < res ){\n\t\t\tres = tree[i]->sum;\n\t\t\tmin_index = i;\n\t\t} // end if\n\t} // end for\n\n\treturn tree[min_index];\n}\n\nvoid disp_table ( vector <vector <int> > t )\n{\n\tint size = t.size();\n\tint len  = t[0].size();\n\tint i,j;\n\n\tfor (i = 0; i < size; ++i){\n\t\tfor (j = 0; j < len; ++j){\n\t\t\tcout << setw(4) << t[i][j] << ' ';\n\t\t} // end for\n\t\tcout << endl;\n\t} // end for\n\tcout << endl;\n}\n\t\nint main()\n{\n//\tcut here before submit \n//\tfreopen(\"testcase.cdl\", \"r\", stdin);\n\n\tstring str = \"\";\n\tint n,m;\t// n: jÕÌÓ m: jÕðÔ¹Ì\n\n\twhile (getline (cin, str ) ) {\n\t\tstringstream ssn(str);\n\t\tssn >> n;\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t} // end if\n\t\tgetline (cin, str );\n\t\tstringstream ssm(str);\n\t\tssm >> m;\n\n\t\tint i;\n\t\tint sum = 0;\n\t\tvector <vector <int> > table (n, vector <int> (n, 0 ) );\n\t\tfor (i = 0; i < m; ++i){\n\t\t\tint from, to, dist;\n\t\t\tgetline (cin, str );\n\t\t\t\twhile (str.find(',') != string::npos ){\n\t\t\t\tstr = str.replace(str.find(','), 1, \" \");\n\t\t\t} // end while\n\t\t\tstringstream ss(str);\n\t\t\tss >> from >> to >> dist;\n\t\t\ttable[from][to] = dist;\n\t\t\ttable[to][from] = dist;\n\t\t} // end for\n//\t\tdisp_table (table );\n\t\n//\t\tTREE **root = talloc (n );\n\t\tTREE *tree[n];\n\n\t\tfor (i = 0; i < n; ++i){\n\t\t\t tree[i] = new TREE;\n\t\t} // end for\n\n\t\tTREE *mintree;\n\n\t\tmintree = make_tree (table , tree);\n//\t\tcout << \"min_sum: \" << mintree->sum << endl;\n//\t\tcout << \"edge:    \" << mintree->edge << endl;\n\n\t\tint res = ((mintree->sum)/100 - mintree->edge );\n\t\tcout << res << endl;\n\n\t\tfor (i = 0; i < n; ++i){\n\t\t\tdelete tree[i];\n\t\t} // end for\n\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\n\nconst int size = 101;\nint P[size];\nbool used[size];\nint cnt[size];\nint n, m;\nvector <PIP> E;\n\nvoid init( int n ) {\n  for ( int i = 0; i < n; i++ ) {\n    P[i] = -1;\n  }\n}\n\nint find( int a ) {\n  if ( P[a] == -1 ) return a;\n  return P[a] = find( P[a] );\n}\n\nvoid unite( int a, int b ) {\n  int fa = find( a ), fb = find( b );\n  if ( fa != fb ) {\n    P[fa] = fb;\n  }\n}\n\nbool same_set( int a, int b ) {\n  return find( a ) == find( b );\n}\n\nint main() {\n  string line;\n\n  while ( getline( cin, line ) ) {\n    if ( line == \"0\" ) break;\n\n    {\n      // n\n      istringstream is( line );\n      is >> n;\n    }\n    {\n      // m\n      getline( cin, line );\n      istringstream is( line );\n      is >> m;\n    }\n\n    E.clear();\n    for ( int i = 0; i < m; i++ ) {\n      // a, b, c\n      getline( cin, line );\n      replace( line.begin(), line.end(), ',', ' ' );\n      istringstream is( line );\n      int a, b, c;\n      is >> a >> b >> c;\n\n      // add edge\n      PIP edge( c, PII( a, b ) );\n      E.push_back( edge );\n    }\n\n    sort( E.begin(), E.end() );\n\n    init(n);\n    for ( int i = 0; i < n; i++ ) {\n      used[i] = false;\n      cnt[i] = 0;\n    }\n\n    int answer = 0;\n    for ( int i = 0; i < m; i++ ) {\n      int a = E[i].first;\n      int b = E[i].second.first;\n      int c = E[i].second.second;\n\n      if ( find( b ) != find( c ) ) {\n\tunite( b, c );\n\tanswer += ( a / 100 ) - 1;\n      }\n    }\n\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nconst int INF= 1e9;\n\nstruct edge{\n  int from, to, cost;\n  edge(int x,int y, int z):from(x),to(y),cost(z){}\n  bool operator<(const edge &x)const{ return cost>x.cost; }\n  //逆！！！ (for priority_queue)\n};\n\nclass Kruskal{\n  int n;\n  vector< vector<edge> > g;\npublic:\n  Kruskal(int a=0):n(a){ g.resize(n); }\n\n  void AddEdge(int a, int b, int cost){\n    g[a].push_back(edge(a,b,cost));\n    g[b].push_back(edge(b,a,cost));\n  }\n\n  int MinSpanningTree(){\n    UF connect(n);\n    priority_queue<edge> q;\n    for(int v=0;v<n;v++){\n      for(int i=0;i<(int)g[v].size();i++)q.push(g[v][i]);\n    }\n    \n    int res = 0;\n    while(q.size()){\n      edge e = q.top(); q.pop();\n      if(!connect.same(e.from,e.to)){\n\tres += e.cost;\n\tconnect.unite(e.from,e.to);\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n,m;\n  while(scanf(\"%d\",&n),n){\n    Kruskal p(n);\n    cin >> m;\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      p.AddEdge(a,b,c/100-1);\n    }\n    cout << p.MinSpanningTree() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cassert>\n#include <cctype>\n#include <complex>\n#include <cstdio>\n#include <map>\n#include <math.h>\n#include <queue>\n#include <set>\n#include <stack>\n#include <string>\n#include <vector>\nusing namespace std;\n\nstruct edge{int u,v,cost;};\n\nint par[100000],rank[100000],V,E,n,m,a,b,d;\nedge es[100000];\n\nvoid init(int n){for(int i=0;i<n;i++){par[i]=i;rank[i]=0;}}\nint find(int x){if(par[x]==x)return x;else return find(par[x]);}\nvoid unite(int x,int y){x=find(x);y=find(y);if(x==y)return;if(rank[x]<rank[y])par[x]=y;else{par[y]=x;if(rank[x]==rank[y])rank[x]++;}}\nbool same(int x,int y){return find(x)==find(y);}\n\nbool comp(const edge e1,const edge e2){return e1.cost<e2.cost;}\n\nint kruskal(){\n\tsort(es,es+E,comp);\n\tinit(V);\n\tint res=0;\n\tfor(int i=0;i<E;i++){\n\t\tedge e=es[i];\n\t\tif(!same(e.u,e.v)){\n\t\t\tunite(e.u,e.v);\n\t\t\tres+=e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(cin>>n>>m){\n\t\tchar com;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>a>>com>>b>>com>>d;\n\t\t\tes[i].u=a;es[i].v=b;es[i].cost=d/100-1;\n\t\t}\n\t\tV=n;\n\t\tE=m;\n\t\tcout<<kruskal()<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include\"bits/stdc++.h\"\n#ifdef _DEBUG\n#define DBG(n) n\n#else\n#define DBG(n)\n#endif\n#define INF         1e9\n#define INFLL       1e18\n#define EPS         1e-9\n#define REP(i,n)    for(ll i=0,i##_len=(n);i<i##_len;++i)\n#define REP1(i,n)   for(ll i=1,i##_len=(n);i<=i##_len;++i)\n#define REPR(i,n)   for(ll i=(n)-1;i>=0;--i)\n#define REPR1(i,n)  for(ll i=(n);i>0;--i)\n#define REPC(i,obj) for(auto i:obj)\n#define ALL(obj)    (obj).begin(),(obj).end()\n#define SETP(n)     cout << fixed << setprecision(n)\nusing namespace std;\nusing ll = long long;\ntemplate<typename T = ll>inline T in() { T ret; cin >> ret; return ret; }\n\nclass union_find {\nprivate:\n\tvector<ll> par, sz, rank;\npublic:\n\tunion_find(ll n) : par(n), sz(n), rank(n)\n\t{\n\t\tREP(i, n) {\n\t\t\tpar[i] = i;\n\t\t\tsz[i] = 1;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tll find(ll x)\n\t{\n\t\treturn par[x] == x ? x : par[x] = find(par[x]);\n\t}\n\tvoid unite(ll x, ll y)\n\t{\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x != y) {\n\t\t\tif (rank[x] < rank[y]) {\n\t\t\t\tpar[x] = y;\n\t\t\t\tsz[y] += sz[x];\n\t\t\t} else {\n\t\t\t\tpar[y] = x;\n\t\t\t\tsz[x] += sz[y];\n\t\t\t\tif (rank[x] == rank[y]) {\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tbool same(ll x, ll y)\n\t{\n\t\treturn find(x) == find(y);\n\t}\n\tll size(ll n)\n\t{\n\t\treturn sz[find(n)];\n\t}\n};\nstruct edge { ll from, to, cost; };\nsigned main()\n{\n\twhile (true) {\n\t\tll n = in(); if (n == 0)break;\n\t\tll  m = in();\n\t\tvector<edge>es(m);\n\t\tREP(i, m) {\n\t\t\tll a, b, d;\n\t\t\tscanf(\"%lld,%lld,%lld\", &a, &b, &d);\n\t\t\tes[i] = { a,b,d };\n\t\t}\n\t\tsort(ALL(es), [](const edge&e1, const edge&e2) {return e1.cost < e2.cost; });\n\t\tunion_find uf(n);\n\t\tll ans = 0;\n\t\tREP(i, m) {\n\t\t\tif (!uf.same(es[i].from, es[i].to)) {\n\t\t\t\tuf.unite(es[i].from, es[i].to);\n\t\t\t\tans += es[i].cost / 100 - 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <cstdio>\n#include <string>\n#include <vector>\n#include <stack>\n\n//AOJ0072\n#define rep(x,to) for(int x=0;x<to;x++)\n#define rep2(x,from,to) for(int x=from;x<to;x++)\n\nusing namespace std;\nstruct ttk{\n\tint tf,tt,km;\n//\tttk(int tf, int tt, int km): tf(tf), tt(tt), km(km) {}\n\tbool operator<(const  ttk  &s) const {\n    return km < s.km;\n  }\n\n};\n\nint main(void){\n\nint n,m;\nchar k;\n\twhile(cin >> n){\n\t\tif(n==0 || cin.eof()) break;\n\t\tvector<int> mt(n,0);\n\t\tint cnt=0,cnt2=0;\n\t\tcin >> m;\n\t\tvector< ttk > tw(m);\n\t\trep(i,m)\n\t\t\tcin >> tw[i].tf >> k >> tw[i].tt >> k >> tw[i].km;\n\t\tsort(tw.begin(), tw.end());\n//\t\trep(i,m) printf(\"%d-%d :%d\\n\",tw[i].tf, tw[i].tt, tw[i].km );\n\t\tmt[tw[0].tf]=1; \tmt[tw[0].tt]=1;\n\t\tcnt += 1;    cnt2 += tw[0].km;\n\t\t\n\t\twhile(1){\n\t\t\tbool brsw=true;\n\t\t\trep(i,m){\n\t\t\t\tif(mt[tw[i].tf] + mt[tw[i].tt] == 1){\n\t\t\t\t\tmt[tw[i].tf]=1; \tmt[tw[i].tt]=1;\n\t\t\t\t\tcnt += 1;    cnt2 += tw[i].km;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\trep(i,n) if(mt[i]==0) brsw = false;\n\t\t\tif(brsw) break;\n\t\t\t\n\t\t\t\n\t\t}\n\n//\t\tprintf(\" %d: %d \\n\",cnt,cnt2);\n\t\tcout << cnt2/100 - cnt << endl;\n\t}\n\treturn 0;\n\t\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\n#define MAX_V 100\n#define INF 99999\n\nint prim(void);\n\nint cost[MAX_V][MAX_V]; //cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint mincost[MAX_V]; //集合Xからの最小コスト\nbool used[MAX_V]; //頂点iがxに含まれているか\nint m; //頂点数\n\nusing namespace std;\n\nint main(){\n  int n,i,c,j,a,b;\n  \n  while(1){\n    scanf(\"%d\",&n); if(n==0) break;\n scanf(\"%d\",&m);\n    for(j=0;j<m;j++){\n      for(i=0;i<m;++i){\n\tcost[j][i]=INF;\n      }\n    }\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d\",&a,&b); scanf(\",%d\",&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    printf(\"%d\\n\",prim());\n    \n  }\n  \n}\n\nint prim(){\n  \n  //初期化\n  for(int i=0;i<m;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(true){\n    int v=-1;\n    //xに属さない頂点のうちxからの辺のコストが最小になる頂点を探す\n    for(int u=0;u<m;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    \n    used[v]=true; //頂点vをxに追加\n    res+=mincost[v]; //辺のコストを比べる\n    \n    for(int u=0;u<m;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cstdio>\n#define F first\n#define S second\nusing namespace std;\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\nint main(){\n    int n;\n    while(cin>>n,n){\n        int m;\n        cin>>m;\n        vector<piii>E(m);\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            c=c/100-1;\n            E[i]=piii(c,pii(a,b));\n        }\n        sort(E.begin(),E.end());\n        bool f[100]={0};\n        int cnt=0;\n        for(int i=0;i<m;i++){\n            int a=E[i].S.F,b=E[i].S.S;\n            int c=E[i].F;\n            if(f[a]==false||f[b]==false){\n                f[a]=f[b]=true;\n                cnt+=c;\n            }\n        }\n        cout<<cnt<<endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <map>\n#include <algorithm>\n#define INF 1<<27\n#define MAX_N 201\n\nusing namespace std;\nint mincost[MAX_N];\nint n,m;\nint cost[MAX_N][MAX_N];\nbool used[MAX_N];\nint prim()\n{\n  int res = 0;\n  mincost[0] = 0;\n  while(1)\n    {\n      int v = -1;\n      for(int i = 0 ; i < n ; i++ ){\n\twhile( !used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n      }\n      if(v == -1)break;\n      used[v] = true;\n      res += mincost[v];\n\n      for(int i = 0 ; i < n ; i++ )\n\t{\n\t  mincost[i] = min(mincost[i],cost[v][i]);\n\t}\n    }\n  return res;\n}\n\nint main()\n{\n  while(cin >> n >> m,n)\n    {\n      fill(cost[0],cost[MAX_N],INF);\n      fill(used,used+MAX_N,false);\n      fill(mincost,mincost+MAX_N,INF);\n      for(int i = 0 ; i < m ; i++ )\n\t{\n\t  char c;\n\t  int a,b,d;\n\t  cin >> a >> c >> b>>c >> d;\n\t  cost[a][b] = cost[b][a] = (d-100)/100;\n\t}\n      int res = prim();\n      cout << res << endl;\n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_V 200\n#define INF 1e6\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];//集合Xからの辺の最小コスト\nbool used[MAX_V];//頂点iがXに含まれてるか\nint V;\n\nint prim(){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res=0;\n  while(true){\n    int v = -1;\n    \n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true; //頂点vをXに追加\n    res += mincost[v]; //円のコストを加える\n    for(int u=0;u<V;u++) mincost[u] = min(mincost[u],cost[v][u]);\n  }\n  return res;\n}\n\n\nint main(){\n  int E;\n  while(true){\n    cin >> V;\n    if(V==0) break;\n    cin >> E;\n    for(int i=0;i<E;i++){\n      for(int j=0;j<E;j++){\n        cost[i][j] = (i==j ? 0 : INF);\n        cost[j][i] = (i==j ? 0 : INF);\n      }\n    }\n\n    int a,b,dist;\n    char camma;\n    for(int i=0;i<E;i++){\n      cin >> a >> camma >> b >> camma >> dist;\n      a; b;\n      cost[a][b] = dist;\n      cost[b][a] = dist;\n    }\n    \n    int sum_of_costs = prim();\n    int lanterns = sum_of_costs/100 - (V - 1); \n    //n00mを100mで分割すると分割点はn-1個\n    cout << lanterns << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define X 1111\n#define INF 1<<30\nusing namespace std;\nint n,m;\nint purimu(int cost[][X]);\nint main(){\n  int a,b,c;\n  int ans=0;\n  int cost[X][X];\n  while(1){\n    cin >> n;\n    if(n==0)break;\n    cin >> m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    } \n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b]=c/100-1;\n    }\n    ans=purimu(cost);\n    cout << ans << endl;\n  }\n}\n\nint purimu(int cost[][X]){\n  int mincost[X];\n  bool used[X];\n  for(int i=0;i<n;i++){\n    mincost[i]=INF;//min関数での回避\n    used[i]=false;//まだいっていないところ用\n  }\n  mincost[0]=0;//出発点のコストは0\n  int res=0;\n  while(1){\n    int v=-1;//最初のために\n    for(int i=0;i<n;i++){\n      if(!used[i] && (v==-1 || mincost[i]<mincost[v])){//まだそこの町に行けない\n\tv=i;\n      } \n    }\n    if(v==-1)break;//全部見終わった\n    used[v]=true;\n    res+=mincost[v];\n    for(int i=0;i<n;i++){\n      mincost[i]=min(mincost[i],cost[v][i]);\n    }\n  }\n  return res;\n}\n\t\n    "
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<vector>\n#include<algorithm>\n#define INF 10000000\nusing namespace std;\ntypedef pair<int,int> P;\nbool used[101];\nint cost[101][101];\nint n,m;\nint prim(){\n  for(int i=0;i<n;i++){\n    used[i]=false;\n  }\n  priority_queue<P,vector<P>,greater<P> > q;\n  int res=0;\n  q.push(P(0,0));\n  while(!q.empty()){\n    P p=q.top();\n    q.pop();\n    if(used[p.second]==true){\n      continue;\n    }\n    used[p.second]=true;\n    res+=p.first;\n    for(int i=0;i<n;i++){\n      if(cost[p.second][i]!=INF){\n\tq.push(P(cost[p.second][i],i));\n      }\n    }\n    \n  }\n  return res;\n}\nmain(){\n  int a,b,k;\n  while(1){  \n    cin>>n;\n    if(n==0) break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    cin>>m;\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&k);\n      cost[a][b]=k/100-1;\n      cost[b][a]=k/100-1;\n    }\n    cout<<prim()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <stdio.h>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <math.h>\n#include <utility>\n#include <string>\n#include <ctype.h>\n#include <cstring>\n#include <cstdio>\n#include <sstream>\n#include <functional>\n\nusing namespace std;\n\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define INF 114514810\n#define ll long long\n//#define scanf scanf_s\n\nstruct edge{ int from, to, cost; };\nint par[105];\n\nbool comp(const edge& e1, const edge& e2)\n{\n\treturn e1.cost < e2.cost;\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tpar[y] = x;\n}\n\n\nint main()\n{\n\tint n, m;\n\twhile (cin >> n >> m, n)\n\t{\n\t\tvector<edge> e;\n\t\tREP(i, m)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tc = c/100 - 1;\n\t\t\tedge tmp = { a, b, c };\n\t\t\te.push_back(tmp);\n\t\t}\n\t\tsort(e.begin(), e.end(), comp);\n\n\t\tREP(i, 105) par[i] = i;\n\t\tint cost = 0;\n\t\tREP(i, e.size())\n\t\t{\n\t\t\tif (find(e[i].from) != find(e[i].to))\n\t\t\t{\n\t\t\t\tcost += e[i].cost;\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t}\n\t\t}\n\t\tcout << cost << endl;\n\t\treturn 0;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100\nint par[MAX_N];\nint rank[MAX_N];\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(rank[x]<rank[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rank[x]==rank[y])rank[x]++;\n\t}\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nstruct Edge{\n\tint a,b,c;\n\tEdge(){}\n\tEdge(int a,int b,int c):a(a),b(b),c(c){}\n\tbool operator<(const Edge &e)const{return c<e.c;}\n};\n\nint main(){\n\tint n,m;\n\tvector<Edge> edge;\n\twhile(cin>>n&&n){\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tchar _;\n\t\t\tcin>>a>>_>>b>>_>>c;\n\t\t\tedge.push_back(Edge(a,b,c/100-1));\n\t\t}\n\t\tinit(n);\n\t\tsort(edge.begin(),edge.end());\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tEdge &e=edge[i];\n\t\t\tif(!same(e.a,e.b)){\n\t\t\t\tunite(e.a,e.b);\n\t\t\t\tans+=e.c;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\n#define MAX_V 100\n#define INF 11111\n\nint prim(void);\n\nint cost[MAX_V][MAX_V]; //cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint mincost[MAX_V]; //集合Xからの最小コスト\nbool used[MAX_V]; //頂点iがxに含まれているか\nint m; //頂点数\n\nusing namespace std;\n\nint main(){\n  int n,i,c,j,a,b;\n  \n  while(1){\n    scanf(\"%d\",&n); if(n==0) break;\n scanf(\"%d\",&m);\n    for(j=0;j<m;j++){\n      for(i=0;i<m;++i){\n\tcost[j][i]=INF;\n      }\n    }\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d\",&a,&b); scanf(\",%d\",&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    printf(\"%d\\n\",prim());\n    \n  }\n  return 0;\n}\n\nint prim(){\n  \n  //初期化\n  for(int i=0;i<m;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(true){\n    int v=-1;\n    //xに属さない頂点のうちxからの辺のコストが最小になる頂点を探す\n    for(int u=0;u<m;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    \n    used[v]=true; //頂点vをxに追加\n    res+=mincost[v]; //辺のコストを比べる\n    \n    for(int u=0;u<m;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\ntypedef priority_queue<PII, vector<PII>, greater<PII> > PQPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = (int) 10e9;\n\nint solve(int n, int m){\n\tVVPII node(n);\n\tvector<bool> done(n, false);\n\tchar comma;\n\tREP(i, m){\n\t\tint from, to, cost;\n\t\tcin >> from >> comma >> to >> comma >> cost;\n\t\tnode[from].PB(MP(cost, to));\n\t\tnode[to].PB(MP(cost, from));\n\t}\n\tPQPII q;\n\tint result = 0;\n\tq.emplace(0, 0);\n\tVI costs(n, INF);\n\twhile(!q.empty()){\n\t\tint w = q.top().first, u = q.top().second;\n\t\tq.pop();\n\t\tif(costs[u] < w) continue;\n\t\tresult += w > 0 ? (w / 100) - 1 : 0 ;\n\t\tfor(PII p : node[u]){\n\t\t\tif(p.first < costs[p.second] && !done[p.second]){\n\t\t\t\tdone[u] = true;\n\t\t\t\tcosts[p.second] = p.first;\n\t\t\t\tq.emplace(p.first, p.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor(int n, m; cin >> n, n;){\n\t\tcin >> m;\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\nusing namespace std;\nconst int INF = (1<<21);\nint cost[100][100];\nint mincost[100];\nbool used[100];\nint n;\nint prim(){\n  for(int i=0;i<n;i++){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n\n  mincost[0]=0;\n  int res=0;\n\n  while(1){\n    int v=-1;\n    for(int u=0;u<n;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\tv=u;\n      }\n    }\n\n    if(v == -1) break;\n    used[v]= true;\n    res+=mincost[v];\n\n    for(int u=0;u<n;u++){\n      mincost[u] = min(mincost[u],cost[v][u]);\n    }\n  }\n\n  return res;\n}\nint main(){\n  while(cin>> n){\n    if(n == 0){\n      break;\n    }\n    int m;\n    cin>> m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    \n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b]=cost[b][a]=c/100-1;\n    }\n    \n    cout<< prim()<< endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 10000;\nvector<Edge> e;\n\nint par[N];\nint rank[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank[x] < rank[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tint a1, a2, a3;\n\t\tchar b1, b2;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tcin >> a1 >> b1 >> a2 >> b2 >> a3;\n\t\t\te.push_back(Edge{a1, a2, a3 / 100 - 1});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 100;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tint a1, a2, a3;\n\t\tchar b1, b2;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tcin >> a1 >> b1 >> a2 >> b2 >> a3;\n\t\t\te.push_back(Edge{a1, a2, a3 / 100 - 1});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct ST_edge {\n\tint a;\n\tint b;\n\tint d;\n\tST_edge() { a=0; b=0; d=0; }\n\tST_edge(int a_, int b_, int d_) { a=a_; b=b_; d=d_; }\n\tbool operator>(const ST_edge& e) const { return d > e.d; }\n} edge;\n\nint main()\n{\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tcin >> m;\n\t\tpriority_queue< edge, vector<edge>, greater<edge> > E;\n\t\tint a_, b_, d_;\n\t\tchar dummy;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tcin >> a_ >> dummy >> b_ >> dummy >> d_;\n\t\t\tE.push( edge(a_, b_, d_) );\n\t\t}\n\t\t\n\t\tvector<int> anc;\n\t\tanc.reserve(n);\n\t\tfor (int i=0; i<n; i++) anc.push_back(i);\n\t\t\n\t\tint num_of_lantern = 0;\n\t\twhile ( !E.empty() ) {\n\t\t\tedge e = E.top();\n\t\t\twhile ( e.a != anc.at(e.a) ) e.a = anc.at(e.a);\n\t\t\twhile ( e.b != anc.at(e.b) ) e.b = anc.at(e.b);\n\t\t\tif (e.a != e.b) {\n\t\t\t\tanc.at(e.b) = e.a;\n\t\t\t\tnum_of_lantern += e.d/100 - 1;\n\t\t\t}\n\t\t\tE.pop();\n\t\t}\n\t\t// for (int i=0; i<n; i++) cout << anc.at(i) << \" \"; // test\n\t\t// cout << endl; // test\n\t\tcout << num_of_lantern << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef long long ll;\n//struct edge {int to, cost;};\ntypedef pair<int, int> P;\ntypedef complex<double> C;\n\nstruct edge {\n    int from, to, cost;\n    edge() {}\n    edge(int f, int t, int c) {\n        from = f; to = t; cost = c;\n    }\n};\n\nbool cmp (const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\nint INF = 100000000;\nconst int MAX_V = 100000;\nconst int MAX_E = 100000;\n\nint uni[MAX_V];\nedge es[MAX_E];\nint V, E;\n\nvoid init_uf(int n) {\n    REP(i, n) uni[i] = -1;\n}\n\nint root(int x) {\n    if (uni[x] < 0) return x;\n    else {\n        return uni[x] = root(uni[x]);\n    }\n}\n\nbool same(int x, int y) {\n    return root(x) == root(y);\n}\n\nvoid unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n\n    if (x == y) return;\n\n    if (uni[x] > uni[y]) swap(x, y);\n\n    uni[x] += uni[y];\n    uni[y] = x;\n}\n\nint kruskal() {\n    sort(es, es + E, cmp);\n    init_uf(V);\n    int res = 0;\n    REP(i, E) {\n        edge e = es[i];\n        if (!same(e.from, e.to)) {\n            unite(e.from, e.to);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    printf(\"%d\\n\", kruskal() );\n}\n\nint main() {\n    while (true) {\n        scanf(\"%d\", &V);\n        if (!V) return 0;\n        scanf(\"%d\", &E);\n        REP(i, E) {\n            int f, t, c;\n            scanf(\"%d,%d,%d\\n\", &f, &t, &c);\n            es[i] = edge(f, t, c/100 - 1);\n        }\n        solve();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1000000000\nusing namespace std;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\nint n;\nint prim();\nmain(){\n  int m;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    cin >> m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      cost[a][b]=cost[b][a]=c;\n    }\n    \n    cout << (prim()/100)-(n-1) << endl;\n  }\n  return 0;\n}\n\nint prim(){\n  for(int i=0;i<n;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  mincost[0]=0;\n  int res=0;\n\n  while(true){\n    int v=-1;\n    for(int u=0;u<n;u++){\n      if(!used[u] && (v==-1 || mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=0;u<n;u++){\n      mincost[u]=min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define X 1111\n#define INF 1<<30\nusing namespace std;\nint n,m;\nint purimu(int cost[][X]);\nint main(){\n  int a,b,c;\n  int ans=0;\n  int cost[X][X];\n  while(1){\n    cin >> n;\n    if(n==0)break;\n    cin >> m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    } \n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b]=c;\n      cost[b][a]=c;\n    }\n    ans=purimu(cost);\n    cout << ans/100-(n-1) << endl;\n  }\n}\n\nint purimu(int cost[][X]){\n  int mincost[X];\n  bool used[X];\n  for(int i=0;i<n;i++){\n    mincost[i]=INF;//min関数での回避\n    used[i]=false;//まだいっていないところ用\n  }\n  mincost[0]=0;//出発点のコストは0\n  int res=0;\n  while(1){\n    int v=-1;//最初のために\n    for(int i=0;i<n;i++){\n      if(!used[i]/*調べていない*/ && (v==-1/*まだそこの場所から行くことができる場所を見つけていない。*/ || mincost[i]<mincost[v])){\n\tv=i;\n      } \n    }\n    if(v==-1)break;//全部見終わった\n    used[v]=true;\n    res+=mincost[v];\n    for(int i=0;i<n;i++){\n      mincost[i]=min(mincost[i],cost[v][i]);\n    }\n  }\n  return res;\n}\n\t\n    "
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(itr,c) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ninline int in(){ int x; scanf(\"%d\",&x); return x;}\n\n//---------- union find ----------- begin\nnamespace UF {\n#define MAX_N  10000\n  int par[MAX_N], rank[MAX_N];\n\n  void init(int n){\n    int i;\n    rep(i,n){ par[i] = i; rank[i] = 0;}\n  }\n\n  int find(int x){\n    if(par[x] == x) return x;\n    else return par[x] = find(par[x]);\n  }\n\n  void unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if(x == y) return;\n\n    if(rank[x] < rank[y]) par[x] = y;\n    else {\n      par[y] = x;\n      if(rank[x] == rank[y]) rank[x]++;\n    }\n  }\n\n  bool same(int x, int y){ return (find(x) == find(y));}\n}\n//---------- union find ---------- end\n\nstruct Edge {\n  int from, to, cost;\n/*\n  Edge(int from_, int to_, int cost_){\n    from = from_;\n    to = to_;\n    cost = cost_;\n  }\n*/\n  bool operator < (const Edge& a) const {\n    return cost < a.cost;\n  }\n};\n\nint n,m;\nvector<Edge> edges;\n\nint main(){\n  int i,j,k;\n\n  while(scanf(\"%d\",&n)){\n    if(n == 0) break;\n\n    m = in();\n    edges.resize(m);\n    rep(i,m) scanf(\"%d,%d,%d\",&edges[i].from,&edges[i].to,&edges[i].cost);\n\n    //---------- kuruskal ---------- begin\n    int ans = 0;\n    sort(edges.begin(),edges.end());\n    UF::init(n);\n    rep(i,m){\n      if(UF::same(edges[i].from, edges[i].to)) continue;\n      ans += (edges[i].cost / 100) - 1;\n      UF::unite(edges[i].from, edges[i].to);\n    }\n\n    printf(\"%d\\n\",ans);\n    //---------- kurusukal ---------- end\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\n#define rep(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nint prim(int n)\n{\n\tint cost[101][101];\n\tint mincost[101];\n\tint used[101] = {};\n\tint res = 0;\n\n\trep(i,n)\n\t{\n\t\tmincost[i] = 1000000;\n\t\trep(j,n)\n\t\t{\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\t\n\tint m;\n\tcin >> m;\n\n\trep(i,m)\n\t{\n\t\tint a,b,d;\n\t\tchar c1,c2;\n\t\tcin >> a >> c1 >> b >> c2 >> d;\n\t\tcost[b][a] = cost[a][b] = d/100 -1;\n\t}\n\n\tmincost[0] = 0;\n\twhile(true)\n\t{\n\t\tint  v = -1;\n\t\trep(u,n)\n\t\t{\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t{\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\n\t\tif(v == -1) break;\n\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\trep(i,n)\n\t\t{\n\t\t\tmincost[i] = min(mincost[i],cost[v][i]);\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile(cin >> n && n)\n\t{\n\t\tcout << prim(n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\n\nconst int size = 101;\nint P[size];\nbool used[size];\nint cnt[size];\nint n, m;\nvector <PIP> E;\n\nvoid init( int n ) {\n  for ( int i = 0; i < n; i++ ) {\n    P[i] = -1;\n  }\n}\n\nint find( int a ) {\n  if ( P[a] == -1 ) return a;\n  return P[a] = find( P[a] );\n}\n\nvoid unite( int a, int b ) {\n  int fa = find( a ), fb = find( b );\n  if ( fa != fb ) {\n    P[fa] = fb;\n  }\n}\n\nbool same_set( int a, int b ) {\n  return find( a ) == find( b );\n}\n\nint main() {\n  string line;\n\n  while ( getline( cin, line ) ) {\n    if ( line == \"0\" ) break;\n\n    {\n      // n\n      istringstream is( line );\n      is >> n;\n    }\n    {\n      // m\n      getline( cin, line );\n      istringstream is( line );\n      is >> m;\n    }\n    for ( int i = 0; i < m; i++ ) {\n      // a, b, c\n      getline( cin, line );\n      replace( line.begin(), line.end(), ',', ' ' );\n      istringstream is( line );\n      int a, b, c;\n      is >> a >> b >> c;\n\n      // add edge\n      PIP edge( c, PII( a, b ) );\n      E.push_back( edge );\n    }\n\n    sort( E.begin(), E.end() );\n\n    init(n);\n    for ( int i = 0; i < n; i++ ) {\n      used[i] = false;\n      cnt[i] = 0;\n    }\n\n    for ( int i = 0; i < m; i++ ) {\n      int b = E[i].second.first;\n      int c = E[i].second.second;\n\n      if ( find( b ) != find( c ) ) {\n\tunite( b, c );\n\tused[i] = true;\n      }\n    }\n\n    int answer = 0;\n    for ( int i = 0; i < m; i++ ) {\n      if ( used[i] ) {\n\tanswer += ( E[i].first / 100 ) - 1;\n      }\n    }\n\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nint  par[100000];  // ?????????????????????????´? \nint find(int x) { if (par[x] == x)return x; par[x] = find(par[x]); return par[x]; }\nvoid unite(int x, int y) { x = find(x); y = find(y); if (x == y)return; par[x] = y; }\nbool same(int x, int y) { return find(x) == find(y); }\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = 1000000000;\nconst double PI = acos(-1);\nLL n, m, a[100000] = {}, x[10000][3] = {}, ans = 0;\nstruct edge { int cost, to; };\nstruct add { int x, y, z; };\nvector<edge>vec[10000];\nstring S[100],str1,str2;\nint main() {\n\tfor(int i=0;i<100000;i++)par[i]=i;  // ????????????????????????\n\twhile (cin >> n&&n) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint  a, b, c;\n\t\t\tchar z;\n\t\t\tcin >> a >> z >> b >> z >> c;\n\t\t\tx[i][0] = min(a, b), x[i][1] = max(a, b), x[i][2] = c / 100 - 1;\n\t\t}\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tif (x[i][2] > x[j][2]) {\n\t\t\t\t\tfor (int h = 0; h < 3; h++) {\n\t\t\t\t\t\tint a = x[i][h];\n\t\t\t\t\t\tx[i][h] = x[j][h];\n\t\t\t\t\t\tx[j][h] = a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (find(x[i][0]) != find(x[i][1])) {\n\t\t\t\tunite(x[i][0], x[i][1]);\n\t\t\t\tans += x[i][2];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\ntypedef long long ll;\nconst int MAX = 101;\nconst int INF = (1<<25);\nint data[MAX][MAX],n;\n\nvoid solve(){\n  for(int i = 0; i < MAX; i++)\n    data[i][i] = 0;\n\n  for(int k = 0; k < MAX; k++)\n    for(int i = 0; i < MAX; i++)\n      for(int j = 0; j < MAX; j++)\n\tdata[i][j] = min(data[i][j],data[i][k]+data[k][j]);\n  \n\n  ll ans = INF;\n  for(int i = 0; i < n; i++){\n    ll sum = 0;\n    bool able = true;\n    for(int j = 0; j < n; j++){\n      if(data[i][j] == INF){\n\table = false;\n\tbreak;\n      }\n      sum += data[i][j];\n    }\n    ans = min(ans,sum);\n  }\n\n  cout << ans/100 - n +1<< endl;\n}\n\n\nvoid init(){\n  for(int i = 0; i < MAX; i++)\n    fill(data[i],data[i]+MAX,INF);\n}\nint main(){\n  while(cin >> n && n){\n    init();\n    int m;\n    cin >> m;\n    while(m--){\n      int from,to,d;\n      char c;\n      cin >> from >> c >> to >> c >> d;\n      data[from][to] = d;\n      data[to][from] = d;\n    }\n    solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\n\nusing Weight = int;\nstruct Edge {\n\tint src, dst; Weight weight;\n\tEdge() {}\n\tEdge(int s, int d, Weight w) : src(s), dst(d), weight(w) {}\n};\nusing Edges = vector<Edge>;\n\nstruct UnionFind {\n\tvector<int> par;\n\tint cnt;\n\tUnionFind(int size_) : par(size_, -1), cnt(size_) {}\n\tvoid unite(int x, int y) {\n\t\tif((x = find(x)) != (y = find(y))) {\n\t\t\tif(par[y] < par[x]) swap(x, y);\n\t\t\tpar[x] += par[y]; par[y] = x; cnt--;\n\t\t}\n\t}\n\tbool same(int x, int y) { return find(x) == find(y); }\n\tint find(int x) { return par[x] < 0 ? x : par[x] = find(par[x]); }\n\tint size(int x) { return -par[find(x)]; }\n\tint size() { return cnt; }\n};\n\nbool operator < (const Edge &e, const Edge &f) { return e.weight < f.weight; }\npair<Weight, Edges> kruskal(int N, Edges es) {\n\tUnionFind uf(N);\n\tWeight total = 0; Edges T;\n\tfor(auto &e : es) if(!uf.same(e.src, e.dst)) {\n\t\tT.push_back(e); total += e.weight; uf.unite(e.src, e.dst);\n\t}\n\treturn make_pair(total, T);\n}\n\nint main() {\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\n\tint n, m;\n\tcin >> n >> m;\n\n\tEdges G;\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, d;\n\t\tchar c;\n\t\tcin >> a >> c >> b >> c >> d;\n\t\tG.push_back(Edge(a, b, d / 100 - 1));\n\t}\n\tsort(G.begin(), G.end());\n\tauto res = kruskal(n, G);\n\tcout << res.first << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct LINE {\n\tint a;\n\tint b;\n\tint d;\n\tbool use;\n};\n\nvector<int> getconnect(vector<LINE> &lines,int n)\n{\n\tvector<int>\tr;\n\tfor(int i=0;i<lines.size();i++){\n\t\tif( lines[i].a != lines[i].b && (lines[i].a==n || lines[i].b==n) ){\n\t\t\tr.push_back(i);\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\n\twhile(true){\n\n\tint n,m;\n\tcin >> n >> m;\n\tif( n==0) break;\n\t\n\tvector<LINE> lines;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tLINE l;\n\t\tchar c;\n\t\tcin >> l.a >> c >> l.b >> c >> l.d;\n\t\tl.use=false;\n\t\tlines.push_back(l);\n\t}\n\n\twhile( true ){\n\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tauto idxs=getconnect(lines,i);\n\t\t\tif( idxs.empty() ) continue;\n\n\t\t\tcount++;\n\t\t\t\n\t\t\tint mini = idxs[0];\n\t\t\tint mind = lines[mini].d;\n\t\t\tfor(int idx : idxs){\n\t\t\t\tif( lines[idx].d < mind ){\n\t\t\t\t\tmini = idx;\n\t\t\t\t\tmind = lines[idx].d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint t = lines[mini].a!=i?lines[mini].a:lines[mini].b;\n\t\t\t\n\t\t\tauto idxs2=getconnect(lines,t);\n\t\t\tfor(int idx : idxs2){\n\t\t\t\tif( lines[idx].a==t){\n\t\t\t\t\tlines[idx].a = i;\n\t\t\t\t}\n\t\t\t\tif( lines[idx].b==t){\n\t\t\t\t\tlines[idx].b = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlines[mini].use=true;\n\t\t}\n\t\tif( count==0) break;\n\t\tcount=0;\n\t}\n\n\tint ans=0;\n\tfor( auto l : lines){\n\t\tif( l.use){\n\t\t\tans += l.d/100-1;\n\t\t}\n\t}\n\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n\nusing namespace std;\n\nconst int inf = 99999;\n\nint prim(int a[101][101], int n)\n{\n\tint r=0;\n\tbool vis[101];\n\tint cost[101];\n\t\n\tfill(vis, vis+101, false);\n\tfill(cost, cost+101, inf);\n\tcost[0] = 0;\n\t\n\twhile(1){\n\t\tint v = -1;\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(!vis[i] && (v == -1 || cost[i] < cost[v])){\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(v == -1){\n\t\t\tbreak;\n\t\t}\n\t\t\n\t\tvis[v] = true;\n\t\tr += cost[v];\n\t\t\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcost[i] = min(cost[i], a[v][i]);\n\t\t}\n\t}\n\t\n\treturn r;\n}\n\nint main()\n{\n\tint a[101][101], n, m, s, t, u;\n\t\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tfill(&a[0][0], &a[n][n], inf);\n\t\tfor(int i = 0; i < n; i++){\n\t\t\ta[i][i] = 0;\n\t\t}\n\t\t\n\t\tcin >> m;\n\t\twhile(m--){\n\t\t\tscanf(\"%d,%d,%d\",&s,&t,&u);\n\t\t\ta[s][t] = a[t][s] = u/100;\n\t\t}\n\t\t\n\t\tcout << (prim(a, n)-(n-1)) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nstruct P {\n\tint from, to, cost;\n};\nint parent[10000];\nint root(int x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = root(parent[x]);\n}\nvoid unite(int x, int y) {\n\tx = parent[x];\n\ty = parent[y];\n\tparent[x] = y;\n}\nbool same(int x, int y) {\n\treturn root(x) == root(y);\n}\nbool operator<(P a, P b) {\n\treturn a.cost < b.cost;\n}\nbool operator>(P a, P b) {\n\treturn a.cost > b.cost;\n}\nint main() {\n\tint n, m;\n\twhile (cin >> n&&n != 0) {\n\t\tcin >> m;\n\t\tpriority_queue<P, vector<P>, greater<P>>p;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tp.push(P{ a,b,c });\n\t\t}\n\t\tfor (int i = 0; i < n; i++) parent[i] = i;\n\t\tint d = 0,sum=0;\n\t\twhile (d != n - 1) {\n\t\t\tP t = p.top(); p.pop();\n\t\t\tif (!same(t.from, t.to)) {\n\t\t\t\tunite(t.from, t.to);\n\t\t\t\td++;\n\t\t\t\tsum += t.cost;\n\t\t\t}\n\t\t}\n\t\tsum /= 100;\n\t\tsum = sum - n + 1;\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <string>\n#include <map>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(int)(n);i++)\n\nusing namespace std;\n\nint prim(vector<vector<int>> to, vector<vector<int>> dist, int n) {\n  priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> q;\n  q.push(make_pair(0,0));\n  vector<bool> vis(n,false);\n  int sum = 0;\n  while(!q.empty()){\n    auto p=q.top();q.pop();\n    if(vis[p.second]) continue;\n    vis[p.second] = true;\n    sum += p.first;\n    for(int i = 0;i < to[p.second].size(); ++i) {\n      if(vis[to[p.second][i]] == false) {\n        q.push(make_pair(dist[p.second][i], to[p.second][i]));\n      }\n    }\n  }\n  return sum;\n}\n\nint main() {\n  while(1){\n    int n;\n    cin>>n;\n    if(!n)break;\n    int m;\n    cin >> m;\n    vector<vector<int>> to(n);\n    vector<vector<int>> dist(n);\n    for(int i = 0; i < m; ++i) {\n      int a,b,d;\n      scanf(\"%d,%d,%d\", &a,&b,&d);\n      to[a].push_back(b);\n      to[b].push_back(a);\n      dist[a].push_back(d);\n      dist[b].push_back(d);\n    }\n    int mspd = prim(to,dist,n);\n    mspd /= 100;\n    mspd -= n - 1;\n    cout << mspd << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <ctime>\n#include <cstring>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <map>\n#include <set>\n#include <bitset>\n#include <numeric>\n#include <utility>\n#include <iomanip>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vint;\ntypedef vector<long long> vll;\ntypedef pair<int,int> pint;\ntypedef pair<long long, long long> pll;\n\n#define MP make_pair\n#define PB push_back\n#define ALL(s) (s).begin(),(s).end()\n#define EACH(i, s) for (__typeof__((s).begin()) i = (s).begin(); i != (s).end(); ++i)\n#define COUT(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << endl\n\ntemplate<class T> inline bool chmax(T& a, T b) { if (a < b) { a = b; return 1; } return 0; }\ntemplate<class T> inline bool chmin(T& a, T b) { if (a > b) { a = b; return 1; } return 0; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, pair<T1,T2> P) \n{ return s << '<' << P.first << \", \" << P.second << '>'; }\ntemplate<class T> ostream& operator << (ostream &s, vector<T> P) \n{ for (int i = 0; i < P.size(); ++i) { if (i > 0) { s << \" \"; } s << P[i]; } return s << endl; }\ntemplate<class T1, class T2> ostream& operator << (ostream &s, map<T1,T2> P) \n{ EACH(it, P) { s << \"<\" << it->first << \"->\" << it->second << \"> \"; } return s << endl; }\n\n\n\nconst int MAX = 1000;\nstruct UnionFind {    \n    int size_;\n    int par[MAX];\n    int rank[MAX];\n    \n    UnionFind(int n = 0) {size_ = n; for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0;}\n    void init(int n) {size_ = n; for (int i = 0; i < n; ++i) par[i] = i, rank[i] = 0;}\n    int root(int x) {return par[x] == x ? x : par[x] = root(par[x]);}    \n    bool same(int x, int y) {return root(x) == root(y);}\n    \n    void connect(int x, int y) {\n        x = root(x); y = root(y);\n        if (x == y) return;        \n        if (rank[x] < rank[y]) par[x] = y;\n        else {par[y] = x; if (rank[x] == rank[y]) ++rank[x];}\n    }\n};\n\ntemplate<class T> struct Edge {\n    int from, to;\n    T cost;\n    Edge(int f, int t, T c) : from(f), to(t), cost(c) {}\n    friend bool operator < (const Edge &e1, const Edge &e2) {return e1.cost < e2.cost;}\n    friend bool operator > (const Edge &e1, const Edge &e2) {return e1.cost > e2.cost;}\n    friend ostream& operator << (ostream& s, const Edge<T>& E) {\n        return s << E.from << \"->\" << E.to << '(' << E.cost << ')';\n    }\n};\n\nUnionFind uf;\n\ntemplate<class T> T Kruskal(int V, vector<Edge<T> > &edges) {\n    T res = 0.0;\n    uf.init(V);\n    sort(edges.begin(), edges.end());\n    for (int i = 0; i < edges.size(); ++i) {\n        Edge<T> e = edges[i];\n        if (!uf.same(e.from, e.to)) {\n            uf.connect(e.from, e.to);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\n\n\nint n, m;\nint a, b, d;\n\nint main() {\n    while (cin >> n >> m) {\n        if (n == 0) break;\n        vector<Edge<int> > vec;\n        for (int i = 0; i < m; ++i) {\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            vec.push_back(Edge<int>(a, b, d/100-1));\n        }\n        int res = Kruskal(n, vec);\n        cout << res << endl;\n    }\n    \n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <map>\n#include <queue>\n#define F first\n#define S second\nusing namespace std;\nint n,m;\nint p[111];\nvoid init(){for(int i=0;i<n;i++)p[i]=i;}\nint find(int x){return p[x]=(p[x]==x?x:find(p[x]));}\nbool same(int x,int y){return find(x)==find(y);}\nvoid merge(int x,int y){p[find(x)]=find(y);}\nint main(void){\n  while(true){\n    scanf(\"%d\",&n);\n    if(!n) break;\n    init();\n    priority_queue<pair<int,pair<int,int> >,vector<pair<int,pair<int,int> > >,greater<pair<int,pair<int,int> > > > que;\n    scanf(\"%d\",&m);\n    for(int i = 0; i < m; i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      que.push(make_pair(c/100-1,make_pair(a,b)));\n    }\n    int res = 0;\n    while(--n){\n      while(same(que.top().S.F,que.top().S.S)) que.pop();\n      res += que.top().F;\n      merge(que.top().S.F,que.top().S.S);\n      que.pop();\n    }\n    printf(\"%d\\n\",res);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nconst int E_MAX = 100010;\nstruct edge {int u, v, cost;};\n\nbool comp(const edge& e1, const edge& e2){\n    return e1.cost < e2.cost;\n}\n\nint V, E;\nedge G[E_MAX];\n\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int N) : par(N){\n        for(int i = 0; i < N; i++){\n            par[i] = -1;\n        }\n    }\n    int root(int x){\n        if(par[x] < 0) return x;\n        else return par[x] = root(par[x]);\n    }\n    void unite(int x, int y){\n        int rx = root(x);\n        int ry = root(y);\n        if(rx == ry) return;\n        else{\n            if(par[rx] > par[ry]) swap(rx, ry);\n            par[rx] += par[ry];\n            par[ry] = rx;\n       }\n    }\n    bool same(int x, int y){\n        return root(x) == root(y);\n    }\n    void check(){\n        for(auto x : par){\n            cout << x << \" \";\n        }\n        cout << endl;\n    }\n};\n\nint kruskal() {\n    sort(G, G + E, comp);\n    UnionFind uf(V);\n    int res = 0;\n    for(int i = 0; i < E; i++){\n        edge e = G[i];\n        if(uf.same(e.u, e.v)) continue;\n        else{\n            uf.unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nint main(){\n    cin.tie(nullptr);\n    ios::sync_with_stdio(false);\n\n    while(cin >> V){\n        if(V == 0) break;\n        cin >> E;\n        for(int i = 0; i < E; i++){\n            int a, b, d;\n            char c;\n            cin >> a >> c >> b >> c >> d;\n            G[i].u = a;\n            G[i].v = b;\n            G[i].cost = d;\n        }\n        cout << kruskal() / 100 - (V - 1) << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nstruct P {\n\tint from, to, cost;\n};\nint parent[10000];\nint root(int x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = root(parent[x]);\n}\nvoid unite(int x, int y) {\n\tx = parent[x];\n\ty = parent[y];\n\tparent[x] = y;\n}\nbool same(int x, int y) {\n\treturn root(x) == root(y);\n}\nbool operator<(P a, P b) {\n\treturn a.cost < b.cost;\n}\nbool operator>(P a, P b) {\n\treturn a.cost > b.cost;\n}\nint main() {\n\tint n, m;\n\twhile (cin >> n&&n != 0) {\n\t\tcin >> m;\n\t\tpriority_queue<P, vector<P>, greater<P>>p;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf_s(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tp.push(P{ a,b,c });\n\t\t}\n\t\tfor (int i = 0; i < n; i++) parent[i] = i;\n\t\tint d = 0,sum=0;\n\t\twhile (d != n - 1) {\n\t\t\tP t = p.top(); p.pop();\n\t\t\tif (!same(t.from, t.to)) {\n\t\t\t\tunite(t.from, t.to);\n\t\t\t\td++;\n\t\t\t\tsum += t.cost;\n\t\t\t}\n\t\t}\n\t\tsum /= 100;\n\t\tsum = sum - n + 1;\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<map>\n#include<cstdio>\n#include<algorithm>\n#define INF 10000000\nusing namespace std;\nbool used[101];\nint cost[101][101];\nint mincost[101];\nint n,m;\nint prim(){\n  for(int i=0;i<n;i++){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  mincost[0]=0;\n  int res=0;\n  while(true){\n    int v=-1;\n    for(int u=0;u<n;u++){\n      if(!used[u] && (v==-1 || mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=0;u<n;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}\nmain(){\n  int a,b,k;\n  while(1){  \n    cin>>n;\n    if(n==0) break;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    cin>>m;\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&k);\n      cost[a][b]=k/100-1;\n      cost[b][a]=k/100-1;\n    }\n    cout<<prim()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "// Carden Lantern [AOJ 0072]\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\ntypedef vector <PIP>    Edges;\n\nconst int size = 101;\nint P[size];\n\nvoid init( int n ) {\n    for ( int i = 0; i < n; i++ ) {\n        P[i] = -1;\n    }\n}\n\nint find( int a ) {\n    if ( P[a] == -1 ) {\n        return a;\n    }\n    return P[a] = find( P[a] );\n}\n\nvoid merge( int a, int b ) {\n    int fa = find( a ), fb = find( b );\n    if ( fa != fb ) {\n        if ( P[a] == -1 ) {\n            P[a] = fb;\n        } else {\n            P[b] = fa;\n        }\n    }\n}\n\nbool same_set( int a, int b ) {\n    return find( a ) == find( b );\n}\n\nint main( void ) {\n    string line;\n    while ( getline( cin, line ) ) {\n        // init\n        int n, m;\n        Edges E;\n\n        // input\n        if ( line == \"0\" ) {\n            break;\n        }\n        {\n            istringstream is( line );\n            is >> n;\n        }\n        {\n            getline( cin, line );\n            istringstream is( line );\n            is >> m;\n        }\n        for ( int i = 0; i < m; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            int a, b, c;\n            istringstream is( line );\n            is >> a >> b >> c;\n            PIP edge( c, PII( a, b ) );\n            E.push_back( edge );\n        }\n\n        // proc\n        int answer = 0;\n        init( n );\n\n        sort( E.begin(), E.end() );\n        for ( int i = 0; i < m; i++ ) {\n            int a = E[i].second.first;\n            int b = E[i].second.second;\n            int c = E[i].first;\n\n            if ( !same_set( a, b ) ) {\n                answer += ( c - 1 ) / 100;\n                merge( a, b );\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <sstream>\n#include <queue>\n#include <functional>\n\nusing namespace std;\n\n#define rep(i,n) for((i)=0;(i)<(int)(n);(i)++)\n#define foreach(itr,c) for(__typeof((c).begin()) itr=(c).begin();itr!=(c).end();itr++)\ninline int in(){ int x; scanf(\"%d\",&x); return x;}\n\nconst int INF = 1<<29;\n\ntypedef pair<int,int> P;\n\nint g[110][110];\n\nint main(){\n  int i,j,k;\n  int n,m;\n\n  while(scanf(\"%d\",&n)){\n    if(n == 0) break;\n    rep(i,n){ rep(j,n) g[i][j] = INF;}\n\n    m = in();\n    while(m--){\n      int a, b, cost;\n      scanf(\"%d,%d,%d\",&a,&b,&cost);\n      g[a][b] = g[b][a] = cost;\n    }\n\n//    rep(i,n){ rep(j,n) cout << g[i][j] << ' '; cout << endl;}\n\n    int ans = 1;\n    int rest = n;\n    vector<int> end(n,0);\n    priority_queue<P, vector<P>, greater<P> > q;\n    q.push(P(0,0));\n    while(!q.empty()){\n      int now = q.top().second;\n      int cost = q.top().first;\n      q.pop();\n\n//      cout << now << ' ' << cost << endl;\n\n      if(end[now] == 1) continue;\n      end[now] = 1;\n      int tmp = (cost /100 ) -1;\n//      cout << \"ans \" << ans << endl;\n//      cout << \"tmp \" << tmp << endl;\n      ans += tmp;\n      rest--;\n      if(rest == 0) break;\n      rep(i,n){\n//        cout << \"g[now][i] \" << g[now][i] << endl;\n        if(!end[i] && g[now][i] != INF) q.push(P(g[now][i],i));\n      }\n    }\n\n    printf(\"%d\\n\",ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <numeric>\n#include <sstream>\n//#include <fstream>\n\nusing namespace std;\n\n#define M 100000000\n\nint t[100][100];\n\nvoid mst (vector <int>& pi, vector <int>& cost )\n{\n\tint n = pi.size();\n\tint i;\n\n\tvector <bool> v (n, false );\n\n\tdo{\n\t\tint mincost = M;\n\t\tint u;\n\n\t\t// costªÅ¬ÆÈém[huðIð·é\n\t\tfor (i = 0; i < n; ++i ){\n\t\t\tif (!v[i] && cost[i] < mincost ){\n\t\t\t\tmincost = cost[i];\n\t\t\t\tu = i;\n\t\t\t} // end if\n\t\t} // end for\n\n\t\tv[u] = true;\n\t\n\t\tfor (i = 0; i < n; ++i ){\n\t\t\t// Ü¾ÜÜêÄ¢È¢m[hÌRXgÌXV\n\t\t\tif (!v[i] && t[u][i] < cost[i] ){\n\t\t\t\tcost[i] = t[u][i];\n\t\t\t\tpi[i] = u;\n\t\t\t} // end if\n\t\t} // end for\t\t \n\t\t\n\t} while ((int)count (v.begin(), v.end(), true ) != n );// end while\n}\n\nint main()\n{\n\n//\tcut here before submit \n//\tfreopen(\"testcase.cdl\", \"r\", stdin);\n\n\tstring str = \"\";\n\tint n,m;\t// n: jÕÌÓ m: jÕðÔ¹Ì\n\n\twhile (getline (cin, str ) ) {\n\t\tstringstream ssn(str);\n\t\tssn >> n;\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t} // end if\n\t\tgetline (cin, str );\n\t\tstringstream ssm (str );\n\t\tssm >> m;\n\n\t\tint i, j;\n\t\tfor (i = 0; i < 100; ++i ){\n\t\t\tfor (j = 0; j < 100; ++j ){\n\t\t\t\tt[i][j] = M;\n\t\t\t} // end for\n\t\t} // end for \n\n\t\tfor (i = 0; i < m; ++i ){\n\t\t\tint from, to, dist;\n\t\t\tgetline (cin, str );\n\t\t\t\twhile (str.find(',') != string::npos ){\n\t\t\t\tstr = str.replace (str.find (','), 1, \" \" );\n\t\t\t} // end while\n\t\t\tstringstream ss (str );\n\t\t\tss >> from >> to >> dist;\n\t\t\tt[from][to] = dist;\n\t\t\tt[to][from] = dist;\n\t\t} // end for\n\n\t\tvector <int> len (n, M );\n\t\tvector <int> path (n, -1 );\n\t\tlen[0] = 0;\n\t\tpath[0] = -1;\n\n\t\tmst (path, len );\n\n\t\tint res = accumulate (len.begin(), len.end(), 0 );\n\t\t\n\t\tmap <int, int> edge;\n\t\tfor (i = 0; i < n; ++i ){\n\t\t\tint curr = i;\n\t\t\twhile (path[curr] != -1 ){\n\t\t\t\tedge[curr] = path[curr];\n\t\t\t\tcurr = path[curr];\n\t\t\t} // end while\n\n\t\t} // end for\n\n\t\tcout << (res/100 - edge.size() ) << endl;\n\n\t} // end while\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define bitcount(x) __builtin_popcount(x)\n\nclass NODE{\npublic:\t\n\tint a,b,c;\n\tNODE(int A,int B,int C){a = A , b = B , c = C;}\n};\nbool operator<(const NODE &a,const NODE &b){return a.c > b.c;}\n\nint main(){\n\tint n;\n\twhile(cin >> n , n){\n\t\tint m; cin >> m;\n\t\tvector<NODE> data[100];\n\t\tpriority_queue<NODE> Q;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tdata[a].push_back(NODE(a,b,c/100-1));\n\t\t\tdata[b].push_back(NODE(b,a,c/100-1));\n\t\t}\n\t\tint ret = 0;\n\t\tbool done[100] = {0};\n\t\tQ.push(NODE(0,0,0));\n\t\twhile(Q.size()){\n\t\t\tNODE q = Q.top(); Q.pop();\n\t\t\tif(done[q.b])continue;\n\t\t\telse ret += q.c , done[q.b] = true;\n\t\t\trep(i,data[q.b].size()) Q.push(data[q.b][i]);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#define MAX 1000\n#define INF 1<<30\nusing namespace std;\nint V,E,cost[MAX][MAX],from,to,Cost;\nbool used[MAX];\nint mincost[MAX];\n\nint prim(){\n  int ans = 0;\n  for(int i=0;i<V;i++){\n    used[i] = false;\n    mincost[i] = INF;\n  }\n  mincost[0] = 0;\n\n  while(true){\n    int v = -1;\n    for(int i=0;i<V;i++){\n      if(!used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n    }\n    if(v == -1)break;\n    used[v] = true;\n    ans += mincost[v];\n\n    for(int i=0;i<V;i++){\n      mincost[i] = min(mincost[i],cost[v][i]);\n    }\n  }\n\n\n  return ans;\n\n}\n\nint main(){\n  \n\n \n\n  while(cin >> V && V){\n for(int i=0;i<MAX;i++)for(int j=0;j<MAX;j++)cost[i][j] = INF;\n    cin >> E;\n    for(int i=0;i<V;i++){\n      scanf(\"%d,%d,%d\\n\",&from,&to,&Cost);\n      cost[from][to] = cost[to][from] =  Cost;\n    }\n\n    cout <<  (prim()/100) - (V-1) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#define INF 2147483647\nusing namespace std;\n\nclass Lantern{\npublic:\n\tbool vector_find(vector<int> v,int key){\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(v[i]==key){return 1;}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Solve(int n, int roadlist[100][100] ){\n\t\tint ans=0,i,j;\n\t\tvector<int> V;\n\t\tV.push_back(0);\n\t\twhile(V.size()!=n){\n\t\t\tint u,v,min=INF;\n\t\t\tfor(i=0;i<V.size();i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(!vector_find(V,j)){\n\t\t\t\t\t\tif(roadlist[i][j]<min){\n\t\t\t\t\t\t\tu=i,v=j;\n\t\t\t\t\t\t\tmin=roadlist[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=min;\n\t\t\tV.push_back(v);\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\n\n\nint main(){\n\tint n,m;\n\tint rlist[100][100];\n\twhile(1){\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\trlist[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){break;}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\trlist[a][b]=rlist[b][a]=c/100-1;\n\t\t}\n\t\tLantern lantern;\n\t\tprintf(\"%d\\n\",lantern.Solve(n,rlist));\n\t}\n\t\n\t\n\t\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n\n#define MAX_V 101\n#define INF 10000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\n\nint V,mincost[MAX_V];\nvector<edge>G[MAX_V];\n\nint Prim(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  fill(mincost, mincost+V, INF);\n\n  vector<bool> visited(V);\n  fill(visited.begin(),visited.end(),false);\n\n  mincost[s]=0;\n  que.push(P(0,s));\n  int res=0;\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    \n    int v = p.second;\n    if(mincost[v]<p.first || visited[v])continue;\n    visited[v]=true;\n    res+=mincost[v];\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(mincost[e.to] > e.cost && !visited[e.to]){\n\tmincost[e.to] = e.cost;\n\tque.push(P(mincost[e.to], e.to));\n      }\n    }\n  }\n \n  return res;\n}\n\n\nint main(void){\n  int m,a,b,c;\n  char ch1,ch2;\n  edge e;\n\n  while(cin >> V,V){\n    for(int i=0;i<V;i++)G[i].clear();\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> a >> ch1 >> b >> ch2 >> c;\n      e.to=b,e.cost=c/100-1;\n      G[a].push_back(e);\n      e.to=a;\n      G[b].push_back(e);\n    }\n      cout << Prim(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n\nstruct edge { int u, v, cost; };\n\nbool comp(const edge& e1, const edge& e2) {\n  return e1.cost < e2.cost;\n}\n\n\nconst int MAX_N = 101;\nconst int MAX_E = 10000;\nint par[MAX_N];\nint r[MAX_N];\n\nvoid init(int n) {\n  for ( int i = 0; i < n; i++ ) {\n    par[i] = i;\n    r[i] = 0;\n  }\n}\n\nint find(int x) {\n  if ( par[x] == x ) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\nvoid unite(int x, int y ) {\n  x = find(x);\n  y = find(y);\n  if ( x == y ) return;\n\n  if ( r[x] < r[y] ) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if ( r[x] == r[y] ) r[x]++;\n  }\n}\n\nbool same(int x, int y) {\n  return find(x) == find(y);\n}\n\n\n\nedge es[MAX_E];\nint V, E;\n\nint kruskal() {\n  sort(es, es + E, comp);\n  init(V);\n  int res = 0;\n  for ( int i = 0; i < E; i++ ) {\n    edge e = es[i];\n    if ( !same(e.u, e.v) ) {\n      unite(e.u, e.v);\n      res += e.cost;\n    }\n  }\n  return res;\n}\n\nint main() {\n  while( cin >> V >> E, V ) {\n\n    for ( int i = 0; i < E; i++ ) {\n      char ch;\n      cin >> es[i].u >> ch >> es[i].v >> ch >> es[i].cost;\n    }\n  \n    int ans = kruskal();\n       cout << ((ans/100)-(V-1)) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main() {\n    int n,m,i,j,sum,a,b,c,x,y;\n\tint da[100][100],use[100];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (i=0;i<n;i++) { use[i]=0; for (j=0;j<n;j++) da[i][j]=0; }\n        cin >> m;\n\t\tfor (i=0;i<m;i++) {\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tda[a][b]=c/100; da[b][a]=c/100;\n\t\t}\n\t\tuse[0]=1; sum=0;\n\t\tfor (a=0; a<n-1; a++) {\n         b=600000000;\n\t\t for (i=0;i<n;i++) if (use[i]==1) {\n\t\t\t for (j=0;j<n;j++) if (da[i][j]>0) if (da[i][j]<b && use[j]==0) { b=da[i][j]; x=j; y=i;}\n\t\t }\n\t\t use[x]=1; sum+=b-1;\n         da[y][x]=0; da[x][y]=0;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\nstruct EDGE\n{\n    int to, cost;\n    EDGE(int a, int b){\n        to = a;\n        to = b;\n    }\n    bool operator < (const EDGE& t) const {\n        return cost > t.cost;\n    }\n};\nvector<EDGE> v[100]; \nbool f[100];\nint search()\n{\n    int res = 0;\n    priority_queue<EDGE> que;\n    que.push(EDGE(0, 0));\n    while (!que.empty()){\n        EDGE e = que.top(); que.pop();\n        if (f[e.to]) continue;\n        f[e.to] = true;\n        res += e.cost;\n/*\n        rep(i, v[e.to].size()){\n            if (!f[v[e.to][i].to]){\n                que.push(v[e.to][i]);\n            }\n        }\n*/\n    }\n    return res;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d\", &n), n){\n        scanf(\"%d\", &m);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            c = c / 100 - 1;\n            v[a].pb(EDGE(b, c));\n            v[b].pb(EDGE(a, c));\n        }\n        printf(\"%d\\n\", search());\n        memset(f, false, sizeof(f));\n        rep(i, n) v[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INFTY 1000000000\n\nint n,M[100][100],color[100],d[100],p[100];\n\nvoid prim() {\n  for ( int i = 0; i < 100; i++ ) {\n    color[i] = WHITE;\n    d[i] = INFTY;\n    p[i] = -1;\n  }\n  \n  d[0] = 0;\n  int u;\n  while(1){\n    u = -1;\n    int mincost = INFTY;\n\n    for ( int i = 0; i < n; i++ ) {\n      if ( color[i] != BLACK && d[i] < mincost ) {\n\tmincost = d[i];\n\tu = i;\n      }\n    }\n\n    if ( u == -1 ) break;\n\n    color[u] = BLACK;\n    \n    for ( int v = 0; v < n; v++ ) {\n      if ( color[v] != BLACK && M[u][v] != INFTY ) {\n\tif ( M[u][v] < d[v] ) {\n\t  d[v] = M[u][v];\n\t  p[v] = u;\n\t  color[v] = GRAY;\n\t}\n      }\n    }\n  }\n  int ans = 0;\n\n  for ( int i = 1; i < n; i++ ) {\n    // cout << d[i] << \" \" ;\n    int tmp = d[i]/100-1;\n    //   cout << tmp  << endl;\n    ans += tmp;\n  }\n  // cout << endl;\n  cout << ans << endl;\n}\n\n  int main() {\n    for ( int i = 0; i  < 100; i++ ) {\n      for ( int j = 0; j < 100; j++ ) {\n\tM[i][j] = INFTY;\n      }\n    }\n    cin >> n;\n    int m; cin >> m;\n    char ch;\n    for ( int i = 0; i < m; i++ ) {\n      int a,b,distance;\n      cin >> a >> ch >> b >> ch >> distance;\n      M[a][b] = distance;\n    }\n  \n    prim();\n  \n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <map>\n#include <queue>\nusing namespace std;\n\nint main(){\n    int n;\n    int m;\n    while(cin >> n, n){\n        cin >> m;\n        int mat[n][n];\n        for(int k(0); k < n; ++k)\n            for(int l(0); l < n; ++l)\n                mat[k][l] = 1 << 30;\n        for(int i(0); i < n; ++ i) mat[i][i]=0;\n        for(int i(0);i < m;++i){\n            int a, b, d;\n            char g;\n            cin >> a;\n            cin >> g;\n            cin>> b;\n            cin >> g;\n            cin>> d;\n\n            d = d / 100 - 1;\n            mat[a][b] = mat[b][a] = d;\n            // map[a].push_back(make_pair(b, d/100 -1));\n            // map[b].push_back(make_pair(a, d/100 -1));\n        }\n        // for(int k(0); k < n; ++k){\n        //     for(int l(0); l < n; ++l){\n        //      cout << mat[k][l] << \" \";\n        //     }\n        //     cout << endl;\n        // }\n        vector<int> vs, nvs;\n        for(int i(1); i < n; ++ i) nvs.push_back(i);\n        // vector<pair<int,int>> es;\n        int sum=0;\n        vs.push_back(0);\n        while(vs.size() < n){\n            pair<int,int> tmp = {0,0};\n            int d = 1 << 30;\n            for(int i: vs){\n                for(int j: nvs){\n                    if(mat[i][j] < d){\n                        d = mat[i][j];\n                        tmp = make_pair(i,j);\n                    }\n                }\n            }\n            vs.push_back(tmp.second);\n//          std::remove(nvs.begin(), nvs.end(), tmp.second);\n            nvs.erase(std::remove(nvs.begin(), nvs.end(), tmp.second), nvs.end());\n            sum += d;\n        }\n        cout << sum << endl;\n    }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<ios>\n#include<algorithm>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,0)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\tif(rank[a]==rank[b])rank[a]++;\n\t\t}\n\t\treturn true;\n\t}\n};\nmain()\n{\n    int n;\n    while(cin>>n,n)\n    {\n        int m;cin>>m;\n        int ans=n;\n        vector<pair<int,pair<int,int> > >e;\n        for(;m--;)\n        {\n            int a,b,c;scanf(\"%d,%d,%d\",&a,&b,&c);\n            c=c/100-1;\n            e.push_back(make_pair(c,make_pair(a,b)));\n        }\n        UF uf(n);\n        sort(e.begin(),e.end());\n        for(int i=0;i<e.size();i++)\n        {\n            int a=e[i].second.first,b=e[i].second.second,c=e[i].first;\n            if(uf.same(a,b))continue;\n            uf.unite(a,b);\n            ans+=c;\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <stack>\n#include <functional>\n#include <iostream>\n#include <map>\n#include <set>\nusing namespace std;\ntypedef pair<int,int> P;\n#define pu push\n#define pb push_back\n#define mp make_pair\n#define eps 1e-7\n#define INF 2000000000\nint main()\n{\n\tint n,m;\n\twhile(1)\n\t{\n\t\tcin >> n;\n\t\tif(n==0)break;\n\t\tint cost[n][n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t{\n\t\t\t\tif(i==j)\n\t\t\t\t{\n\t\t\t\t\tcost[i][j]=0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcost[i][j]=INF;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tfor(int i=0;i<m;i++)\n\t\t{\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tcost[a][b]=c/100-1;\n\t\t\tcost[b][a]=c/100-1;\n\t\t}\n\t\tint mincost[n];\n\t\tbool used[n];\n\t\tfor(int i=0;i<n;i++)\n\t\t{\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tmincost[0]=0;\n\t\tint res=0;\n\t\twhile(1)\n\t\t{\n\t\t\tint v=-1;\n\t\t\tfor(int u=0;u<n;u++)\n\t\t\t{\n\t\t\t\tif(!used[u]&&(v==-1||mincost[u] < mincost[v]))v=u;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=true;\n\t\t\tres+=mincost[v];\n\t\t\tfor(int u=0;u<n;u++)\n\t\t\t{\n\t\t\t\tmincost[u]= min(mincost[u],cost[v][u]);\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<algorithm>\nusing namespace std;\n\nclass street{\npublic:\n  int a,b,d;\n  void set(int x,int y,int z){a = x;b = y;d = z;};\n  bool operator<(const street x)const{return d>x.d;}\n};\n\nint main(){\n  int n,m;\n\n  while(scanf(\"%d\",&n) && n){\n    scanf(\"%d\",&m);\n    priority_queue<street> q;\n    for(int i=0;i<m;i++){\n      int x,y,z;\n      scanf(\"%d%*c%d%*c%d \",&x,&y,&z);\n      q.push((street){x,y,z/100-1});\n    }\n    \n\n    bool visit[100];\n    for(int i=0;i<n;i++)visit[i] = false;\n    \n    int ans = 0;\n\n    while(q.size()){\n      street s = q.top();q.pop();\n      if(!visit[s.a] || !visit[s.b]){\n\tans += s.d;\n\tvisit[s.a] = visit[s.b] = true;\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint find(vector<int> &u, int &x){\n\treturn x == u[x] ? x : find(u, u[x]);\n}\n\nint main(){\n\tint n, m, a, b, d, c;\n\tfor(;;){\n\t\tscanf(\"%d\",&n);\n\t\tif(!n)break;\n\t\t\n\t\tvector<int> u(n);\n\t\tfor(int i = 0; i < n; i++) u[i] = i;\n\t\t\n\t\tscanf(\"%d\",&m);\n\t\tvector< pair<int, pair<int, int> > > v;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tv.push_back( make_pair(d / 100 - 1, make_pair(min(a, b), max(a, b))));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\t\n\t\tc = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\ta = find(u,u[v[i].second.first]);\n\t\t\tb = find(u,u[v[i].second.second]);\n\t\t\tif(a != b){\n\t\t\t\tu[v[i].second.first] = u[v[i].second.second] = a;\n\t\t\t\tc += v[i].first;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",c);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "using namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define MAX 100\n#define INFTY (1<<21)\nint G[MAX][MAX], n;\n\nvoid prim(){\n    int D[MAX], V[MAX], P[MAX], sum = 0;\n    rep(i, n) { D[i] = INFTY; V[i] = 0; }\n    D[0] = 0;\n\n    while(1){\n\tint u, minv = INFTY;\n\trep(i, n) if ( !V[i] && minv > D[i]) { \n\t    minv = D[i], u = i; \n\t}\n\tif ( minv == INFTY ) break;\n\tV[u] = 1;\n\tif ( u ) sum += G[u][P[u]];\n\trep(v, n){\n\t    if ( !V[v] && G[u][v] < D[v] ){\n\t\tD[v] = G[u][v];\n\t\tP[v] = u;\n\t    }\n\t}\n    }\n\n    cout << sum<< endl;\n}\n\nmain(){\n    int m, s, t, c;\n    char ch;\n    while( cin >> n >> m && n ){\n\trep(i, n) rep(j, n) G[i][j] = INFTY;\n\trep(i, m) {\n\t    cin >> s >> ch >> t >> ch >> c; \n\t    G[s][t] = G[t][s] = c/100-1;\n\t}\n\tprim();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct EDGE\n{\n\tint from, to, cost;\n\tEDGE(int a, int b, int c){\n\t\tfrom = a;\n\t\tto = b;\n\t\tcost = c;\n\t}\n\tbool operator < (const EDGE& t) const {\n\t\treturn cost < t.cost;\n\t}\n};\n\nvector<EDGE> v;\nint par[100];\n\nvoid init()\n{\n\tv.clear();\n\tfor (int i = 0; i < 100; i++){\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x)\n{\n\tif (par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nvoid _union(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tpar[x] = y;\n}\n\nint main()\n{\n\tint n;\n\twhile (scanf(\"%d\", &n), n){\n\t\tinit();\n\t\tint m;\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tc = c / 100 - 1;\n\t\t\t\n\t\t\tv.push_back(EDGE(a, b, c));\n\t\t\tv.push_back(EDGE(b, a, c));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\tint res = 0;\n\t\tfor (int i = 0; i < v.size(); i++){\n\t\t\tEDGE& e = v[i];\n\t\t\tif (same(e.from, e.to)) continue;\n\t\t\t_union(e.from, e.to);\n\t\t\tres += e.cost;\n\t\t}\n\t\tprintf(\"%d\\n\", res);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nconst int INF = 10000000;\n\nint main(){\n\tint n, m;\n\twhile(std::cin >> n, n){\n\t\tstd::cin >> m;\n\t\tint cost[100][100];\n\t\tfor(int i=0;i<10000;i++){\n\t\t\tcost[i/100][i%100] = INF;\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = d / 100;\n\t\t}\n\t\tint mincost[100];\n\t\tbool used[100];\n\t\tint res = 0;\n\n\t\tfor(int i=0;i<100;i++){\n\t\t\tmincost[i] = INF;\n\t\t\tused[i] = false;\n\t\t}\n\t\n\t\tmincost[0] = 0;\n\t\twhile(1){\n\t\t\tint v = -1;\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\t}\n\t\t\tif(v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v] - 1;\n\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tmincost[u] = std::min(mincost[u], cost[v][u]);\n\t\t\t}\n\t\t}\n\n\t\tstd::cout << res + 1 << std::endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\nstruct EDGE\n{\n    int to, cost;\n    bool operator < (const EDGE& t) const {\n        return cost > t.cost;\n    }\n};\nvector<EDGE> v[100]; \nbool f[100];\nint search()\n{\n    int res = 0;\n    priority_queue<EDGE> que;\n    que.push({0, 0});\n    while (!que.empty()){\n        EDGE e = que.top(); que.pop();\n        if (f[e.to]) continue;\n        f[e.to] = true;\n        res += e.cost;\n        rep(i, v[e.to].size()){\n            if (!f[v[e.to][i].to]){\n                que.push(v[e.to][i]);\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d\", &n), n){\n        scanf(\"%d\", &m);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            c = c / 100 - 1;\n            v[a].pb({b, c});\n            v[b].pb({a, c});\n        }\n        printf(\"%d\", search());\n        memset(f, false, sizeof(f));\n        rep(i, n) v[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint INF = 1 << 30;\n\nint main(void)\n{\n\tint n,d;\n\tint path[200][200];\n\tint x,y,cost; // 飾り\n\tint used[200]; // 木に入ったか\n\tint mincost; // 最安値\n\tint minnum; // 安い点\n\tint ans;\n\tint minsia;\n\n\tscanf(\"%d\", &n);\n\twhile(n != 0){\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tpath[i][j] = INF;\n\t\t\t}\n\t\t\tused[i] = 0;\n\t\t}\n\t\tused[0] = 1;\n\n\t\tscanf(\"%d\", &d);\n\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tscanf(\"%d,%d,%d\", &x, &y, &cost);\n\t\t\tpath[x][y] = cost;\n\t\t\tpath[y][x] = cost;\n\t\t}\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tmincost = INF + 1;\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(used[j] == 1){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(path[j][k] < mincost){\n\t\t\t\t\t\t\tif(used[k] != 1){\n\t\t\t\t\t\t\t\tminsia = j;\n\t\t\t\t\t\t\t\tminnum = k;\n\t\t\t\t\t\t\t\tmincost = path[j][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (mincost - 100) / 100;\n\t\t\tused[minnum] = 1;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tscanf(\"%d\", &n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<cstdio>\n\nint par[100], rank[100];\n\nvoid init( int n )\n{\n\tfor( int i = 0; i != n; ++i )\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n\n\treturn;\n}\n\nint find( int x )\n{\n\tif( x == par[x] )\n\t\treturn x;\n\telse\n\t\treturn par[x] = find( par[x] );\n}\n\nvoid unite( int x, int y )\n{\n\tx = find( x );\n\ty = find( y );\n\tif( x == y )\n\t\treturn;\n\n\tif( rank[x] < rank[y] )\n\t\tpar[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif( rank[x] == rank[y] )\n\t\t\t++rank[x];\n\t}\n\n\treturn;\n}\n\nbool same( int x, int y )\n{\n\treturn find( x ) == find( y );\n}\n\nstruct edge{ int from, to, cost; };\n\nstd::vector<edge> es;\n\nbool compare( const edge& lhs, const edge& rhs )\n{\n\treturn lhs.cost < rhs.cost;\n}\n\nint main()\n{\n\tint n, m;\n\twhile( scanf( \"%d\", &n ), n )\n\t{\n\t\tes.clear();\n\n\t\tscanf( \"%d\", &m );\n\n\t\tfor( int i = 0; i != m; ++i )\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf( \"%d,%d,%d\", &a, &b, &c );\n\t\t\tedge e = { a, b, c / 100 - 1 };\n\t\t\tes.push_back( e );\n\t\t}\n\n\t\tstd::sort( es.begin(), es.end(), compare );\n\n\t\tinit( n );\n\n\t\tint ans = 0;\n\t\tfor( int i = 0; i != es.size(); ++i )\n\t\t{\n\t\t\tif( !same( es[i].from, es[i].to ) )\n\t\t\t{\n\t\t\t\tunite( es[i].from, es[i].to );\n\t\t\t\tans += es[i].cost;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define  INF 999999999\n\n#ifdef Debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#else\n#define dump(x)\n#endif\n\nbool used[5000];\nint mincost[5000];\nint edge[5000][5000];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\trep(i,200)rep(j,200)edge[i][j]=INF;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar ch;\n\t\t\tcin>>a>>ch>>b>>ch>>c;\n\t\t\tedge[a][b]=edge[b][a]=max(0,(int)(c/100)-1);\n\t\t}\n\t\trep(i,m){\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tmincost[0]=0;\n\t\tint res=0;\n\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\trep(u,m){\n\t\t\t\tif(used[u]==false && ( v==-1 || mincost[u]<mincost[v] ))\n\t\t\t\t\tv=u;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=true;\n\t\t\tres+=mincost[v];\n\n\t\t\trep(u,m){\n\t\t\t\tmincost[u]=min(mincost[u],edge[v][u]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <sstream>\n#include <string>\n#include <vector>\n#include <map>\n#include <algorithm>\n#include <iostream>\n#include <utility>\n#include <set>\n#include <cctype>\n#include <queue>\n#include <stack>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\nusing namespace std;\n#define INF 100000000\n\ntypedef long long ll;\nint n, m;\n\n// UnionFind\n#define MAXN 110\nint par[MAXN], rank[MAXN];\n\nvoid init(int n_) {\n    for (int i = 0; i < n_; i++) {\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if (x == par[x]) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n    x = find(x); y = find(y);\n    if (x == y) return;\n    if (rank[x] < rank[y]) par[x] = y;\n    else {\n        par[y] = x;\n        if (rank[x] == rank[y]) rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\n// kruskal\n#define MAXM 100010\nstruct edge {\n    int from, to, cost;\n};\n\nbool comp(const edge &e1, const edge &e2) {\n    return e1.cost < e2.cost;\n}\n\nedge es[MAXM];\n\nint kruskal(void) {\n    sort(es, es+m, comp);\n    init(n);\n    int ret = 0;\n    for (int i = 0; i < m; i++) {\n        edge e = es[i];\n        if (!same(e.from, e.to)) {\n            unite(e.from, e.to);\n            ret += e.cost / 100 - 1;\n        }\n    }\n    return ret;\n}\n\n\nint main(void) {\n    while (cin >> n && n) {\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &es[i].from, &es[i].to, &es[i].cost);\n        }\n        cout << kruskal() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\n\nstruct P{\n    int edge;\n    int cost;\n};\n\nint n,m;\nint ans;\nint E[150];\nvector<P> V[150];\nP p;\n\nsigned main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            p={y,z};\n            V[x].PB(p);\n            p={x,z};\n            V[y].PB(p);\n        }\n        rep(i,n){\n            P res;\n            res.cost=INT_MAX;\n            rep(j,V[i].size()){\n                if(E[i]==1&&E[V[i][j].edge]==1)continue;\n                if(res.cost>V[i][j].cost){\n                    res=V[i][j];\n                }\n            }\n            if(res.cost==INT_MAX)continue;\n            ans+=res.cost-100;\n            E[i]=1;\n            E[res.edge]=1;\n        }\n        cout<<ans/100<<endl;\n        ans=0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <limits.h>\nusing namespace std;\nint dist[100][100]; //距離,道がないところはINF\nint mincost[100];\nbool used[100];\nint n; //頂点数\n//prim法\nint prim(){\n\tfor(int i=0;i<n;i++) mincost[i]=INT_MAX, used[i]=false;\n\tint res=0; mincost[0]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u=0;u<n;u++) if(!used[u] && (v==-1 || mincost[u]<mincost[v])) v=u;\n\t\tif(v==-1) break;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\t//距離の更新\n\t\tfor(int u=0;u<n;u++) mincost[u]=min(mincost[u],dist[v][u]);\n\t\tfor(int i=0;i<n;i++) cout << mincost[i] << ' '; cout << '\\n' ;\n\t}\n\treturn res;\n}\nint main() {\n\tint m;\n\twhile(1){\n\t\tcin >> n ; if(!n) break;\n\t\tcin >> m ;\n\t\tfor(int i=0;i<100;i++) for(int j=0;j<100;j++) dist[i][j]=INT_MAX;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint st,fin,DIST; scanf(\"%d,%d,%d\",&st,&fin,&DIST);\n\t\t\tdist[st][fin]=dist[fin][st]=DIST/100;\n\t\t}\n\t\tcout << prim()-(n-1) << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <sstream>\n#include <istream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define vci vector<int>\n#define vcs vector<string>\n#define pb push_back\n#define sz size()\n#define mapii map<int, int>\n#define mapci map<char, int>\n#define mapsi map<string, int>\n#define all(x) x.begin(), x.end()\n#define minit(a, i) memset(a, i, sizeof(a));\n\n#define for_(i, a, b) for (int i=(int)a; i<(int)b; i++)\n#define for_d(i, a, b) for (int i=(int)a-1; i>=b; i--)\n#define for_r(i, a, b, c) for (int i=(int)a; i<(int)b; i += c)\n#define for_dr(i, a, b, c) for (int i=(int)a-1; i>=b; i -= c)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n\ntypedef long long ll;\ntypedef double D;\n\nconst int iINF = 2147483647;\nconst ll lINF = 9223372036854775807;\n\ntemplate <class T> inline void dbg(T t) { cout << t << endl; }\n\n\ntypedef int Weight;\n\nstruct Edge {\n\tint from, to;\n\tWeight weight;\n\tEdge(int f, int t, int w) : from(f), to(t), weight(w) { }\n};\ntypedef vector<Edge> Edges;\n\nint solve(int n, Edges& es) {\n\tint m = (int)es.sz;\n\t\n\tint dp[1<<n];\n\tfor_(s, 0, 1<<n) dp[s] = 1000000000;\n\t\n\tdp[0] = 0;\n\tfor_(s, 0, 1<<n) {\n\t\tfor_(i, 0, m) {\n\t\t\tEdge e = es[i];\n\t\t\tint ns = s|1<<e.from; ns = ns|1<<e.to;\n\t\t\tdp[ns] = min(dp[ns], dp[s] + e.weight);\n\t\t}\n\t}\n\n\treturn dp[(1<<n) - 1];\n}\n\nint main() {\n\tint n, m;\n\t\n\twhile (1) {\n\t\tcin >> n; if (n==0) break;\n\t\tcin >> m;\n\t\t\n\t\tEdges es;\n\t\t\n\t\tint a, b, w;\n\t\tfor_(i, 0, m) {\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &w);\n\t\t\tEdge e(a, b, w/100 - 1);\n\t\t\tes.pb(e);\n\t\t}\n\t\t\n\t\tcout << solve(n, es) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//\n// Carden Lantern [AOJ 0072]\n// URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072\n//\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\ntypedef vector <PIP>    Edges;\n\nconst int size = 101;\nint P[size];\n\nvoid init( int n ) {\n    for ( int i = 0; i < n; i++ ) {\n        P[i] = -1;\n    }\n}\n\nint find( int a ) {\n    if ( P[a] == -1 ) {\n        return a;\n    }\n    return P[a] = find( P[a] );\n}\n\nvoid merge( int a, int b ) {\n    int fa = find( a ), fb = find( b );\n\n    if ( fa != fb ) {\n        if ( P[a] == -1 ) {\n            P[b] = fa;\n        } else {\n            P[b] = fa;\n        }\n    }\n}\n\nbool same_set( int a, int b ) {\n    return find( a ) == find( b );\n}\n\nint main( void ) {\n    string line;\n\n    while ( getline( cin, line ) ) {\n        // init\n        int n, m;\n        Edges E;\n\n        // input\n        if ( line == \"0\" ) {\n            break;\n        }\n        {\n            istringstream is( line );\n            is >> n;\n        }\n        {\n            getline( cin, line );\n            istringstream is( line );\n            is >> m;\n        }\n        for ( int i = 0; i < m; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            int a, b, c;\n            istringstream is( line );\n            is >> a >> b >> c;\n\n            PIP edge( c / 100, PII( a, b ) );\n            E.push_back( edge );\n        }\n\n        // proc\n        int answer = 0;\n        init( n );\n\n        sort( E.begin(), E.end() );\n        for ( int i = 0; i < m; i++ ) {\n            int a = E[i].second.first;\n            int b = E[i].second.second;\n            int c = E[i].first;\n\n            if ( !same_set( a, b ) ) {\n                answer += c - 1;\n                merge( a, b );\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define SAFE_DELETE( x ) { if ( x ){ delete x; x = NULL; } }\n\nstruct tCell{\n\ttCell() : x( 0 ), prev( NULL ), next( NULL ){}\n\tint x;\n\ttCell *prev, *next;\n};\n\n\nclass MyArray{\npublic:\n\tMyArray() : mSize( 0 ), head( NULL ), tail( NULL ){\n\t\thead = new tCell;\n\t\ttail = new tCell;\n\t\thead->next = tail;\n\t\ttail->prev = head;\n\t}\n\t~MyArray(){\n\t\tinit();\n\t\tSAFE_DELETE( head );\n\t\tSAFE_DELETE( tail );\n\t}\n\n\tvoid init(){\n\t\tfor ( int i = mSize; i > 0; --i ){\n\t\t\ttCell* it = tail->prev;\n\t\t\tit->prev->next = it->next;\n\t\t\tit->next->prev = it->prev;\n\t\t\tSAFE_DELETE( it );\n\t\t}\n\t\tmSize = 0;\n\t}\n\n\tvoid pushBack( int x ){\n\t\ttCell* it = new tCell;\n\t\tit->x = x;\n\t\tit->prev = tail->prev;\n\t\tit->next = tail;\n\t\tit->prev->next = it;\n\t\tit->next->prev = it;\n\t\t++mSize;\n\t}\n\tvoid pushAsc( int x ){\n\t\t\n\t}\n\tint size(){ return mSize; }\n\n\ttCell operator[]( int index ){\n\t\ttCell* it = head->next;\n\t\tfor ( int i = 0; i < index; ++i ){\n\t\t\tit = it->next;\n\t\t}\n\t\treturn *it;\n\t}\n\nprivate:\n\tint mSize;\n\ttCell *head, *tail;\n};\n\nstruct tData{\n\ttData() : done( false ){}\n\n\tbool done;\n\tMyArray to;\n\tMyArray dis;\n};\n\n\nclass Route{\npublic:\n\tRoute( int m ) : list( NULL ), mSize( m ){\n\t\tlist = new tData[ mSize ];\n\t}\n\t~Route(){\n\t\tdelete[] list;\n\t}\n\n\tint calc(){\n\t\tbool end;\n\t\tint ret = 0;\n\t\tlist[ 0 ].done = true;\n\t\tdo{\n\t\t\tend = true;\n\t\t\tint nextTo, nextDis = INT_MAX;\n\t\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\t\tif ( list[ i ].done ){\n\t\t\t\t\tfor ( int j = 0; j < list[ i ].to.size(); ++j ){\n\t\t\t\t\t\tint to = list[ i ].to[ j ].x;\n\t\t\t\t\t\tif ( !list[ to ].done && list[ i ].dis[ j ].x < nextDis ){\n\t\t\t\t\t\t\tnextTo = to;\n\t\t\t\t\t\t\tnextDis = list[ i ].dis[ j ].x;\n\t\t\t\t\t\t\tend = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !end ){\n\t\t\t\tret += nextDis / 100 - 1;\n\t\t\t\tlist[ nextTo ].done = true;\n\t\t\t}\n\t\t}while ( !end );\n\n\t\treturn ret;\n\t}\n\n\tint mSize;\n\ttData* list;\n};\n\nint main(){\n\tint n, m, p1, p2, d;\n\tchar c;\n\n\twhile ( cin >> n && n ){\n\t\tcin >> m;\n\t\tRoute* route = new Route( m );\n\t\tfor ( int i = 0; i < m; ++i ){\n\t\t\tcin >> p1 >> c >> p2 >> c >> d;\n\t\t\troute->list[ p1 ].to.pushBack( p2 );\n\t\t\troute->list[ p1 ].dis.pushBack( d );\n\t\t\troute->list[ p2 ].to.pushBack( p1 );\n\t\t\troute->list[ p2 ].dis.pushBack( d );\n\t\t}\n\n\t\tcout << route->calc() << endl;\n\n\n\t\tSAFE_DELETE( route );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V;//??????\nint E;//???\nstruct edge { int from, to, cost; };\ntypedef std::pair<int, int> PP;\nstd::vector<edge> e;\nint Par[100000];\nint Rank[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (std::cin >> V&&V) {\n\t\tstd::cin >> E;\n\t\tint a, b, c;\n\t\tchar aa,bb;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tstd::cin >> a >>aa>> b >>bb>> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tstd::cout << kruskal()/100-V+1 << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\n#define NMAX 100\n#define NOT -1\n\nstruct mini{\n\tint fr,to,cost;\n};\n\n\nint main(){\n\n\tint n,m;\n\tint a,b,d;\n\tchar gav;\n\tint e[NMAX][NMAX];\n\tbool use[NMAX];\n\tint cost;\n\tmini min;\n\n\twhile(1){\n\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcin>>m;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\te[i][j]=NOT;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>a>>gav>>b>>gav>>d;\n\t\t\te[a][b]=d;\n\t\t\te[b][a]=d;\n\t\t}\n\n\t\tfor(int i=0;i<m;i++) use[i]=false;\n\t\tuse[0]=true;\n\t\tcost=0;\n\n\t\twhile(1){\n\t\t\tmin.fr=NOT,min.to=NOT,min.cost=NOT;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tif(use[i]==true){\n\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\tif(use[j]==false){\n\t\t\t\t\t\t\tif(e[i][j]!=NOT){\n\t\t\t\t\t\t\t\tif(min.fr==NOT||min.cost>e[i][j]) min.fr=i,min.to=j,min.cost=e[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min.fr==NOT) break;\n\t\t\tuse[min.to]=true;\n\t\t\tcost+=(min.cost)/100-1;\n\t\t}\n\t\tcout<<cost<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define INF 1e9\n#define LINF 1e18\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> Pi;\ntypedef pair<P, P> PP;\n\nconst int MOD = 1e9 + 7;\nconst int dy[] = { 0, 0, 1, -1 };\nconst int dx[] = { 1, -1, 0, 0 };\n\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\n\ntypedef pair<int, int> P;\nstruct edge{int to, cost;};\nint n, m;\nbool used[101];\nvector<edge> G[100];\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> n) {\n        if(n == 0) break;\n        cin >> m;\n        rep(i, m) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            G[a].push_back(edge{b, c / 100 - 1});\n            G[b].push_back(edge{a, c / 100 - 1});\n        }\n        priority_queue<P, vector<P>, greater<P> > que;\n        memset(used, 0, sizeof(used));\n        que.push(P(0, 0));\n        int res = 0;\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            int cst = p.first, v = p.second;\n            if(used[v]) continue;\n            used[v] = true;\n            res += cst;\n            rep(i, G[v].size()) {\n                que.push(P(G[v][i].cost, G[v][i].to));\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<queue>\n#include<vector>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint N, M;\nvector<P> g[100];\nbool done[100];\nint main()\n{\n  while(true)\n  {\n    fill(done, done + 100, 0);\n    for(int i = 0; i < 100; i++)\n      g[i].clear();\n    \n    cin >> N;\n    if(!N)\n      break;\n    cin >> M;\n\n    for(int i = 0; i < M; i++)\n    {\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      printf(\"%d %d %d \\n\", a, b, c);\n      c = c / 100 - 1;\n      g[a].push_back(make_pair(c, b));\n      g[b].push_back(make_pair(c, a));\n    }\n\n    priority_queue<P, vector<P>, greater<P>> q;\n    q.push(make_pair(0, 0));\n    int cost = 0;\n    while(q.size())\n    {\n      auto p = q.top(); q.pop();\n      if(done[p.second])\n        continue;\n      done[p.second] = true;\n      cost += p.first;\n      for(auto e: g[p.second])\n      {\n        if(done[e.second])\n          continue;\n        q.push(e);\n      }\n    }\n    cout << cost << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define range(i,a,b) for(int i = (a); i < (b); i++)\n#define rep(i,b) range(i,0,b)\n#define all(a) (a).begin(), (a).end()\n#define debug(x) cout << \"debug \" << x << endl;\n#define INF (1 << 30)\nusing namespace std;\n\nconst int kn = 105;\nint atl[kn][kn];\n\nint findMinPath(int n, vector<int> &v, bool isVisited[kn]){\n    int mp, md = INF;\n    rep(i,v.size()){\n        rep(j,n){\n            if(isVisited[j] == 0){\n                if(md > atl[v[i]][j]){\n                    md = atl[v[i]][j];\n                    mp = j;\n                }\n            }\n        }\n    }\n    isVisited[mp] = 1;\n    v.push_back(mp);\n    return md;\n}\n\nint PrimAlgorithm(int n){\n    int sum = 0;\n    bool isVisited[kn] = {0};\n    vector<int> v;\n    v.push_back(0);\n    isVisited[0] = 1;\n\n    while(not (v.size() == n)){\n        sum += findMinPath(n, v, isVisited);\n    }\n\n    return sum;\n}\n\nint main(){\n    int n, m;\n    while(cin >> n >> m, n){\n        rep(i,kn) rep(j,kn) atl[i][j] = INF;\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d%*c%d%*c%d\", &a, &b, &c);\n            atl[a][b] = atl[b][a] = c;\n        }\n        cout << (PrimAlgorithm(n) / 100) - n + 1 << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define COST_MAX 1000000\n\nusing namespace std;\n\nint main() {\n  int n;\n  int m;\n  while(1) {\n    cin >> n;\n    if(n == 0) break;\n    cin >> m;\n\n    int dist[n][n];\n    for(int i = 0; i < n; i++) {\n      for(int j = 0; j < n; j++) {\n\tdist[i][j] = COST_MAX;\n      }\n    }\n\n    for(int i = 0; i < m; i++) {\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      dist[a][b] = dist[b][a] = d;\n    }\n\n    int cost[n];\n    bool visited[n];\n    for(int i = 0; i < n; i++) {\n      cost[i] = COST_MAX;\n      visited[i] = false;\n    }\n    cost[0] = 0;\n    int pre[n];\n\n    while(1) {\n      int min = COST_MAX;\n      int p;\n      for(int i = 0; i < n; i++) {\n\tif(!visited[i] && cost[i] < min) {\n\t  min = cost[i];\n\t  p = i;\n\t}\n      }\n      if(min == COST_MAX) break;\n\n      visited[p] = true;\n      for(int i = 0; i < n; i++) {\n\tif(!visited[i] && dist[i][p] < cost[i]) {\n\t  cost[i] = dist[i][p];\n\t  pre[i] = p;\n\t}\n      }\n    }\n    int ans = 0;\n    for(int i = 0; i < n; i++) {\n      if(cost[i] == 0) continue;\n      ans += cost[i] / 100 - 1;\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ndouble Prim(Graph& g,Edges& tree,int root=0)\n{\n\ttree.clear();\n\t\n\tint size=g.size();\n\tvector<int> visited(size);\n\t\n\tpriority_queue<Edge,vector<Edge>,greater<Edge> > pq;\n\tpq.push(Edge(-1,root,0));\n\tint res=0;\n\twhile(!pq.empty()){\n\t\tEdge e=pq.top();\n\t\tpq.pop();\n\t\tif(visited[e.dst])\n\t\t\tcontinue;\n\t\tif(e.src!=-1)\n\t\t\ttree.push_back(e);\n\t\tvisited[e.dst]=1;\n\t\tres+=e.weight;\n\t\trep(i,g[e.dst].size()){\n\t\t\tEdge cand=g[e.dst][i];\n\t\t\tif(!visited[cand.dst])\n\t\t\t\tpq.push(cand);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\tEdges e;\n\t\tint sum=Prim(g,e);\n\t\tcout<<sum<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint Kruskal(Graph& g,Edges& e)\n{\n\te.clear();\n\t\n\tUnionFind uf(g.size());\n\tset<Edge> s;\n\trep(i,g.size())\n\t\trep(j,g[i].size())\n\t\t\ts.insert(g[i][j]);\n\t\n\tint res=0;\n\tforeach(i,s){\n\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n\t\t\tuf.Union(i->src,i->dst);\n\t\t\tres+=i->weight;\n\t\t\te.push_back(*i);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight));\n\t\t}\n\t\tEdges e;\n\t\tint sum=Kruskal(g,e);\n\t\tcout<<sum/100-e.size()<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\nint par[110], rk[110];\nvoid init(int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tpar[i] = i;\n\t\trk[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x)return x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\n\tif (rk[x] < rk[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif (rk[x] == rk[y])rk[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tint u, v, cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\n\nedge es[110];\nint n, m;\n\nint kruskal() {\n\tsort(es, es + m, comp);\n\tinit(n);\n\tll res = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += (e.cost) / 100 - 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tes[i].u = a, es[i].v = b, es[i].cost = d;\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "// 0072\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nstruct road{\n\tint dis;\n\tint v1;\n\tint v2;\n};\n\nvoid Sort(vector<road> &ver){\n\troad r;\n\tfor(int i=0;i<ver.size();i++){\n\t\tfor(int j=1;j<ver.size()-i;j++){\n\t\t\tif(ver[j-1].dis > ver[j].dis){\n\t\t\t\tr = ver[j-1];\n\t\t\t\tver[j-1] = ver[j];\n\t\t\t\tver[j] = r;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint lantern(vector<road> ver){\n\tvector<bool> her;\n\tfor(int i=0;i<ver.size();i++)\n\t\ther.push_back(false);\n\n\tint lan = 0;\n\tfor(int i=0;i<ver.size();i++){\n\t\tif(her[ver[i].v1] == false || her[ver[i].v2] == false){\n\t\t\tlan += ver[i].dis/100-1;\n\t\t\ther[ver[i].v1] = true;\n\t\t\ther[ver[i].v2] = true;\n\t\t}\n\t}\n\n\treturn lan;\n}\n\nint main(){\n\twhile(1){\n\t\tint n, m, a, b, d;\n\t\tvector<road> ver;\n\t\troad v;\n\n\t\tcin>>n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tv.v1 = a;\n\t\t\tv.v2 = b;\n\t\t\tv.dis = d;\n\t\t\tver.push_back(v);\n\t\t}\n\n\t\tSort(ver);\n\t\t\n\t\tcout<<lantern(ver)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n && n)\n\t{\n\t\tcin >> m;\n\n\t\tvint mincost(n, INF);\n\t\tvector<bool> used(n, false);\n\t\tvector<vint> cost(n, vint(n, INF));\n\t\trep(i, m)\n\t\t{\n\t\t\tint from, to, c;\n\t\t\tchar k;\n\t\t\tcin >> from >> k >> to >> k >> c;\n\n\t\t\tcost[from][to] = cost[to][from] = c;\n\t\t}\n\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\n\t\twhile(true)\n\t\t{\n\t\t\tint v = -1;\n\t\t\trep(u, n)\n\t\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\t\tv = u;\n\n\t\t\tif(v == -1) break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v] - 100;\n\n\t\t\trep(u, n)\n\t\t\t\tchmin(mincost[u], cost[v][u]);\n\t\t}\n\n\t\tcout << (res + 100) / 100 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V;//??????\nint E;//???\nstruct edge { int from, to, cost; };\ntypedef std::pair<int, int> PP;\nstd::vector<edge> e;\nint Par[100000];\nint Rank[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (std::cin >> V&&V) {\n\t\tstd::cin >> E;\n\t\tint a, b, c;\n\t\tchar aa,bb;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tstd::cin >> a >>aa>> b >>bb>> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tstd::cout << kruskal()/100-V+1 << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <cstdlib>\n#include <cstdio>\n#include <set>\nusing namespace std;\n#define MAX_V 100\n#define INF 1<<30\n\nint N, M;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nbool Vused[MAX_V][MAX_V];\n\nint prim(){\n\tfor(int i=0;i<N;i++){\n\t\tmincost[i]=INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(!used[u] && (v==-1 || mincost[u] < mincost[v])) v=u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tif(mincost[v] >= INF) return INF;\n\t\tres += mincost[v];\n\t\tfor(int u=0;u<N;u++){\n\t\t\tif(mincost[u] > cost[v][u]){\n\t\t\t\tmincost[u] = cost[v][u];\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\nmain(){\n\tint i,j;\n\twhile(cin >> N, N){\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<N;j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t\tVused[i][j] = false;\n\t\t\t}\n\t\t}\n\t\tcin >> M;\n\t\tfor(i=0;i<M;i++){\n\t\t\tint a,b,c;\n\t\t\tchar x;\n\t\t\tcin >> a >> x >> b >> x >> c;\n\t\t\tcost[a][b] = cost[b][a] = c/100-1;\n\t\t}\n\t\tcout << prim() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n\n\nusing namespace std;\n\nstring bom[8];\n\nclass Graph{\npublic:\n    int a;\n    int b;\n    int ab;\n};\n\n\nbool asc( const Graph& left, const Graph& right ) {\n    return left.ab<right.ab;\n}\n\n\n\n\nint main(void) {\n    Graph gr[100];\n    \n    while(1){\n        int n,m;\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        for(int i=0; i<m; i++){\n            scanf(\"%d,%d,%d\",&gr[i].a,&gr[i].b,&gr[i].ab);\n            if(gr[i].a>gr[i].b)swap(gr[i].a,gr[i].b);\n            //cin>>gr[i].a>>gr[i].b>>gr[i].ab;\n        }\n        sort(gr, gr+m, asc);\n        /*for(int i=0; i<m; i++){\n            cout<<gr[i].a<<\" \"<<gr[i].b<<\" \"<<gr[i].ab<<endl;\n        }*/\n        int check[100]={0};\n        int dist=0;\n        check[gr[0].a]++;\n        check[gr[0].b]++;\n        dist+=gr[0].ab-200;\n        while(1){\n            int count=0;\n            for(int i=0; i<m; i++)count+=check[i];\n            if(count==m)break;\n            for(int i=0; i<m; i++){\n                if(check[gr[i].a]==1&&check[gr[i].b]==0){\n                    check[gr[i].b]++;\n                    dist+=gr[i].ab;\n                    break;\n                }else if(check[gr[i].b]==1&&check[gr[i].a]==0){\n                    check[gr[i].a]++;\n                    dist+=gr[i].ab-100;\n                    break;\n                }\n            }\n            \n        }\n        cout<<dist/100<<endl;\n        \n        \n        \n    }\n    \n    \n    \n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nint s[100][100];\n\nint main() {\n  int n, m, x, y, z, ans, mind, mini;\n  int d[100], a[100];\n  bool b[100];\n\n  while (1) {\n    scanf(\"%d\", &n);\n    if (!n) break;\n    scanf(\"%d\", &m);\n    memset(s, 0, sizeof(int)*n*100);\n    for (int i=0; i<m; i++) {\n      scanf(\"%d,%d,%d\", &x, &y, &z);\n      s[x][y] = s[y][x] = z/100-1;\n    }\n\n    for (int i=0; i<n; i++) d[i] = INT_MAX;\n    memset(b, 0, sizeof(bool)*n);\n    d[0] = 0;\n    a[0] = 0;\n    ans = 0;\n    while (1) {\n      mind = INT_MAX;\n      for (int i=0; i<n; i++) {\n        if (!b[i] && d[i]<mind) {\n          mind = d[i];\n          mini = i;\n        }\n      }\n      if (mind == INT_MAX) break;\n      ans += s[a[mini]][mini];\n      b[mini] = true;\n      for (int i=0; i<n; i++) {\n        if (!b[i] && s[mini][i]) {\n          if (d[i] > s[mini][i]) {\n            d[i] = s[mini][i];\n            a[i] = mini;\n          }\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1000000000\n\nusing namespace std;\n\n\nint main(){\n        int n;\n        cin >> n;\n        while(n){\n                int m;\n                cin >> m;\n                int map[n][n];\n                for(int i = 0; i < n ;i++){\n                        for(int j = 0; j < n; j++){\n                                map[i][j] = INF;\n                        }   \n                }   \n                for(int i = 0; i < m; i++){\n                        int a,b,c;\n                        char d,e;\n                        cin >> a >> d >> b >> e >> c;\n                        map[a][b] = map[b][a] = c/100;\n                }   \n                bool used[100] = {false};\n                used[0] = true;\n                long long cost = 0;\n                for(int i = 0; i < m-1; i++){\n                        int min = INF;\n                        int next = 0;\n                        for(int j = 0; j < n; j++){\n                                for(int k = 0; k < n; k++){\n                                        if(used[j] && !used[k] && map[j][k] < min){\n                                                min = map[j][k];\n                                                next = k;\n                                        }   \n                                }   \n                        }   \n                        used[next] = true;\n                        cost += min-1;\n                }   \n                cout << cost << endl;\n                cin >> n;\n        }   \n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio.txt>\n#include<cctype>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<list>\n#include<bitset>\n#include<set>\n\nusing namespace std;\n\n#define MAX_N 100\n#define INF 1 << 20\n\nint n, m, a, b, c, d[MAX_N][MAX_N], i, j, min[3], cnt, ans;\nbool array[MAX_N];\n\nint main(){\n\twhile (true){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) return 0;\n\t\tscanf(\"%d\", &m);\n\t\tcnt = 1;\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++){\n\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\tif (i == j){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t\tarray[i] = false;\n\t\t}\n\t\tarray[0] = true;\n\t\tfor (i = 0; i < m; i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\td[a][b] = c / 100 - 1;\n\t\t\td[b][a] = c / 100 - 1;\n\t\t}\n\t\tfor (cnt = 1; cnt < n; cnt++){\n\t\t\tc = INF;\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\tif (array[i] && !array[j] && c > d[i][j]){\n\t\t\t\t\t\tc = d[i][j];\n\t\t\t\t\t\tb = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += c;\n\t\t\tarray[b] = true;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <map>\n#include <set>\n#include <queue>\n#include <stack>\n#include <numeric>\n#include <bitset>\n#include <cmath>\n\nstatic const int MOD = 1000000007;\nusing ll = long long;\nusing u32 = unsigned;\nusing u64 = unsigned long long;\nusing namespace std;\n\ntemplate<class T> constexpr T INF = ::numeric_limits<T>::max()/32*15+208;\n\ntemplate <typename T>\nstruct edge {\n    int from, to;\n    T cost;\n\n    edge(int to, T cost) : from(-1), to(to), cost(cost) {}\n    edge(int from, int to, T cost) : from(from), to(to), cost(cost) {}\n\n    explicit operator int() const {return to;}\n};\n\nclass UnionFind {\n    vector<int> uni;\n    int n;\npublic:\n    explicit UnionFind(int n) : uni(static_cast<u32>(n), -1) , n(n){};\n\n    int root(int a){\n        if (uni[a] < 0) return a;\n        else return (uni[a] = root(uni[a]));\n    }\n\n    bool unite(int a, int b) {\n        a = root(a);\n        b = root(b);\n        if(a == b) return false;\n        if(uni[a] > uni[b]) swap(a, b);\n        uni[a] += uni[b];\n        uni[b] = a;\n        return true;\n    }\n};\n\ntemplate< typename T >\nT kruskal(vector<edge<T>> &G, int V) {\n    sort(begin(G), end(G), [](const edge<T> &a, const edge<T> &b) { return (a.cost < b.cost); });\n    UnionFind tree(V);\n    T ret = 0;\n    for(auto &e : G) {\n        if(tree.unite(e.from, e.to)) ret += e.cost;\n    }\n    return (ret);\n}\n\nint main() {\n    int n;\n    while(cin >> n, n){\n        vector<edge<int>> G;\n        int m;\n        cin >> m;\n        for (int i = 0; i < m; ++i) {\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            G.emplace_back(a, b, d/100-1);\n        }\n        cout << kruskal(G, n) << \"\\n\";\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nconst int INF= 1e9;\n\nstruct edge{\n  int from, to, cost;\n  edge(int x,int y, int z):from(x),to(y),cost(z){}\n  bool operator<(const edge &x)const{ return cost<x.cost; }\n};\n\nclass Kruskal{\n  int n;\n  vector< vector<edge> > g;\npublic:\n  Kruskal(int a=0):n(a){ g.resize(n); }\n\n  void AddEdge(int a, int b, int cost){\n    g[a].push_back(edge(a,b,cost));\n    g[b].push_back(edge(b,a,cost));\n  }\n\n  int MinSpanningTree(){\n    UF connect(n);\n    vector<edge> edges;\n    for(int v=0;v<n;v++){\n      for(edge e : g[v])edges.push_back(e);\n    }\n    sort(edges.begin(), edges.end());\n    \n    int res = 0;\n    for(edge e : edges){\n      if(!connect.same(e.from,e.to)){\n\tres += e.cost;\n\tconnect.unite(e.from,e.to);\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n,m;\n  while(scanf(\"%d\",&n),n){\n    Kruskal p(n);\n    cin >> m;\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      p.AddEdge(a,b,c/100-1);\n    }\n    cout << p.MinSpanningTree() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INFTY 1000000000\n\nint n,M[101][101],color[101],d[101],p[101];\n\nvoid prim() {\n  for ( int i = 0; i < 101; i++ ) {\n    color[i] = WHITE;\n    d[i] = INFTY;\n    p[i] = -1;\n  }\n  \n  d[0] = 0;\n  int u;\n  while(1){\n    u = -1;\n    int mincost = INFTY;\n\n    for ( int i = 0; i < n; i++ ) {\n      if ( color[i] != BLACK && d[i] < mincost ) {\n\tmincost = d[i];\n\tu = i;\n      }\n    }\n\n    if ( u == -1 ) break;\n\n    color[u] = BLACK;\n    \n    for ( int v = 0; v < n; v++ ) {\n      if ( color[v] != BLACK && M[u][v] != INFTY ) {\n\tif ( M[u][v] < d[v] ) {\n\t  d[v] = M[u][v];\n\t  p[v] = u;\n\t  color[v] = GRAY;\n\t}\n      }\n    }\n  }\n  int ans = 0;\n\n  for ( int i = 1; i < n; i++ ) {\n    // cout << d[i] << \" \" ;\n    int tmp = d[i]/100-1;\n    //   cout << tmp  << endl;\n    ans += tmp;\n  }\n  // cout << endl;\n  cout << ans << endl;\n}\n\n  int main() {\n    for ( int i = 0; i  < 101; i++ ) {\n      for ( int j = 0; j < 101; j++ ) {\n\tM[i][j] = INFTY;\n      }\n    }\n    cin >> n;\n    int m; cin >> m;\n    char ch;\n    for ( int i = 0; i < m; i++ ) {\n      int a,b,distance;\n      cin >> a >> ch >> b >> ch >> distance;\n      M[a][b] = distance;\n    }\n  \n    prim();\n  \n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 100;\n\nstruct edge {\n\tint from_, to_, cost_;\n\tedge() = default;\n\tedge(int from, int to, int cost) :from_(from), to_(to), cost_(cost) {}\n\tbool operator<(const edge& rhs) const{\n\t\treturn (cost_ == rhs.cost_) ? to_ < rhs.to_ : cost_ < rhs.cost_;\n\t}\n};\n\nint n, m;\nstd::vector<edge> edges;\n\nclass Union {\n\tint par[MAX_N], rank[MAX_N];\npublic:\n\tUnion() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x])\n\t\t\treturn x;\n\t\tpar[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y])\n\t\t\tstd::swap(x, y);\n\t\tpar[y] = x;\n\t\trank[x] += rank[y];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (!n)\n\t\t\tbreak;\n\t\tstd::cin >> m;\n\t\tUnion uni;\n\t\tedges.clear();\n\t\tint a, b, d;\n\t\tchar ch;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> ch >> b >> ch >> d;\n\t\t\td /= 100;\n\t\t\t--d;\n\t\t\tedges.push_back(edge(a, b, d));\n\t\t}\n\n\t\tstd::sort(edges.begin(), edges.end());\n\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (!uni.same(edges[i].from_, edges[i].to_)) {\n\t\t\t\tuni.unite(edges[i].from_, edges[i].to_);\n\t\t\t\tans += edges[i].cost_;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstatic const int MAX_N = 100;\nstatic const int INFTY = (1 << 21);\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\n\nint n, m;\nint dist[MAX_N][MAX_N];\nint color[MAX_N], p[MAX_N], d[MAX_N];\n\nint prim(){\n\tint u, mincost;\n\tfor(int i = 0; i < n; i++){\n\t\td[i] = INFTY; p[i] = -1; color[i] = WHITE;\n\t}\n\n\td[0] = 0;\n\n\twhile(1){\n\t\tmincost = INFTY;\n\t\tu = -1;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(mincost > d[i] && color[i] != BLACK){\n\t\t\t\tu = i; mincost = d[i];\n\t\t\t}\n\t\t}\n\t\tif(u == -1) break;\n\t\tcolor[u] = BLACK;\n\t\tfor(int v = 0; v < n; v++){\n\t\t\tif(color[v] != BLACK && dist[u][v] != INFTY){\n\t\t\t\tif(d[v] > dist[u][v]){\n\t\t\t\t\td[v] = dist[u][v];\n\t\t\t\t\tp[v] = u;\n\t\t\t\t\tcolor[v] = GRAY;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor(int i = 0; i < n; i++){\n\t\tif(p[i] != -1) sum += dist[i][p[i]];\n\t}\n\treturn sum;\n}\n\nint main(){\n\twhile(1){\n\t\tint a, b, d;\n\t\tscanf(\"%d\", &n);\n\t\tif(n == 0) break;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tdist[i][j] = INFTY;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\tfor(int i = 1; i <= m; i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tdist[a][b] = dist[b][a] = d / 100 - 1;\n\t\t}\n\n\t\tcout << prim() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w > e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\n//????°???¨?????¨\n//Prim O(ElogV)\n//r????????°?????????????????????????±?\n//Edge??? bool operator<(const Edge &e)const { return w > e.w; } ????????????????????????\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n\tEdges T; Weight total = 0; vector<int> v(g.size());\n\tpriority_queue <Edge> q;\n\tq.push(Edge(-1, r, 0));\n\twhile (q.size()) {\n\t\tEdge e = q.top(); q.pop();\n\t\tif (v[e.d]) continue;\n\t\tv[e.d] = true;\n\t\ttotal += e.w; if (e.s != -1) T.push_back(e);\n\t\tfor (auto &f : g[e.d]) if (!v[f.d]) q.push(f);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].push_back(Edge(a, b, d));\n\t\t\tg[b].push_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = prim(g, 0);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#pragma warning (disable:4996)\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 114514\n\nint x[1000][1000];\nint color[10000];\nint MIN[10000];\nint sum;\nint sum_min = INF;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(color, 0, sizeof(color));\n\t\tmemset(MIN, 0, sizeof(MIN));\n\t\tint n, a, b, c, m, e, f, g;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tx[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", &e, &f, &g);\n\t\t\tx[e][f] = g / 100 - 1;\n\t\t\tx[f][e] = g / 100 - 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tMIN[j] = INF;\n\t\t\t\tcolor[j] = WHITE;\n\t\t\t}\n\t\t\tb = INF;\n\t\t\ta = n;\n\t\t\tcolor[i] = GRAY;\n\t\t\tMIN[i] = 0;\n\t\t\twhile (a != 0) {\n\t\t\t\tb = INF;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\t\tc = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolor[c] = BLACK;\n\t\t\t\ta -= 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (color[k] != BLACK && x[c][k] != -1) {\n\t\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tsum += MIN[j];\n\t\t\t}\n\t\t\tsum_min = min(sum_min, sum);\n\t\t}\n\t\tcout << sum_min << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\nusing namespace std;\n\n#define ROOT (-1)\n#define INV (-1)\n#define INFTY INT_MAX\n#define MAX_NODES 100\n\nint prim(int n, int dist[][MAX_NODES]){\n\tint ans = 0; // problem answer\n\tbool vis[MAX_NODES];\n\tint cost[MAX_NODES];\n\tint pi[MAX_NODES];\n\n\tfor(int i = 0; i < n; i++){\n\t\tvis[i] = false;\n\t\tcost[i] = INFTY;\n\t}\n\n\tcost[0] = 0;\n\tpi[0] = ROOT;\n\n\twhile( true ){\n\t\tint mincost = INFTY;\n\t\tint nmin;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif( !vis[i] && mincost > cost[i] ){\n\t\t\t\tmincost = cost[i];\n\t\t\t\tnmin = i;\n\t\t\t}\n\t\t}\n\n\t\t// end\n\t\tif( mincost == INFTY ) break;\n\n\t\tvis[nmin] = true;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif( vis[i] || dist[nmin][i] == INV ) continue; // skip\n\t\t\tif( dist[nmin][i] < cost[i] ){\n\t\t\t\tcost[i] = dist[nmin][i];\n\t\t\t\tpi[i] = nmin;\n\t\t\t}\n\t\t}\n\t}\n\n\t// calc\n\tfor(int i = 1; i < n; i++){\n\t\tans += (cost[i] - 100) / 100;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\twhile( true ){\n\t\tint dist[MAX_NODES][MAX_NODES];\n\t\tint n;\n\t\tint m;\n\n\t\tcin >> n;\n\t\tif( n == 0 ) break;\n\t\tcin >> m;\n\t\t\n\t\t// init\n\t\tfor(int i = 0; i < sizeof(dist)/sizeof(*dist); i++){\n\t\t\tfor(int j = 0; j < sizeof(dist[i])/sizeof(*dist[i]); j++){\n\t\t\t\tdist[ i ][ j ] = INV;\n\t\t\t}\n\t\t}\n\n\t\t// input\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a, b, d;\n\t\t\tchar dum;\n\t\t\tcin >> a >> dum >> b >> dum >> d;\n\t\t\tdist[a][b] = d;\n\t\t}\n\n\t\t// prim algorithm\n\t\tcout << prim(n, dist) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <ctime>\n#include <cassert>\n#include <iostream>\n#include <cctype>\n#include <sstream>\n#include <string>\n#include <list>\n#include <vector>\n#include <queue>\n#include <set>\n#include <stack>\n#include <map>\n#include <utility>\n#include <numeric>\n#include <algorithm>\n#include <iterator>\n#include <bitset>\n#include <complex>\n#include <fstream>\nusing namespace std;\ntypedef long long ll;\nconst double EPS = 1e-9;\ntypedef vector<int> vint;\ntypedef pair<int, int> pint;\n#define rep(i, n) REP(i, 0, n)\n#define ALL(v) v.begin(), v.end()\n#define MSG(a) cout << #a << \" \" << a << endl;\n#define REP(i, x, n) for(int i = x; i < n; i++)\ntemplate<class T> T RoundOff(T a){ return int(a+.5-(a<0)); }\ntemplate<class T, class C> void chmax(T& a, C b){ if(a < b) a = b; }\ntemplate<class T, class C> void chmin(T& a, C b){ if(b < a) a = b; }\ntemplate<class T, class C> pair<T, C> mp(T a, C b){ return make_pair(a, b); }\n\nconst int INF = 1 << 30;\n\nstruct E\n{\n\tint u, v, cost;\n};\nbool comp(const E& l, const E& r)\n{\treturn l.cost < r.cost;\t}\n\n\n\nvint par;\nvint rank;\n\nvoid init(int n)\n{\n\trep(i, n)\n\t{\n\t\t::par.push_back(i);\n\t\t::rank.push_back(0);\n\t}\n}\n\nint find(int x)\n{\n\tif(par[x] == x) return x;\n\telse\t\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y) return;\n\n\n\tif(::rank[x] < ::rank[y])\tpar[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif(::rank[x] == ::rank[y]) ::rank[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\n\nint main()\n{\n\tint n, m;\n\twhile(cin >> n && n)\n\t{\n\t\tcin >> m;\n\n\t\tvector<E> es(m);\n\n\t\tchar k;\n\t\trep(i, m)\n\t\t\tcin >> es[i].u >> k >> es[i].v >> k >> es[i].cost;\n\n\t\tsort(ALL(es), comp);\n\t\tinit(n);\n\n\t\tint res = 0;\n\t\trep(i, m)\n\t\t{\n\t\t\tE e = es[i];\n\t\t\tif(!same(e.u, e.v))\n\t\t\t{\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tres += e.cost - 100;\n\t\t\t}\n\t\t}\n\n\t\tcout << res / 100 << endl;\n\n\t\tpar.clear();\n\t\t::rank.clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\n\nconst int size = 101;\nint P[size];\nbool used[size];\nint cnt[size];\nint n, m;\nvector <PIP> E;\n\nvoid init( int n ) {\n  for ( int i = 0; i < n; i++ ) {\n    P[i] = -1;\n  }\n}\n\nint find( int a ) {\n  if ( P[a] == -1 ) return a;\n  return P[a] = find( P[a] );\n}\n\nvoid unite( int a, int b ) {\n  int fa = find( a ), fb = find( b );\n  if ( fa != fb ) {\n    P[fa] = fb;\n  }\n}\n\nbool same_set( int a, int b ) {\n  return find( a ) == find( b );\n}\n\nint main() {\n  string line;\n\n  while ( getline( cin, line ) ) {\n    if ( line == \"0\" ) break;\n\n    {\n      // n\n      istringstream is( line );\n      is >> n;\n    }\n    {\n      // m\n      getline( cin, line );\n      istringstream is( line );\n      is >> m;\n    }\n    for ( int i = 0; i < m; i++ ) {\n      // a, b, c\n      getline( cin, line );\n      replace( line.begin(), line.end(), ',', ' ' );\n      istringstream is( line );\n      int a, b, c;\n      is >> a >> b >> c;\n\n      // add edge\n      PIP edge( c, PII( a, b ) );\n      E.push_back( edge );\n    }\n\n    sort( E.begin(), E.end() );\n\n    init(n);\n    for ( int i = 0; i < n; i++ ) {\n      used[i] = false;\n      cnt[i] = 0;\n    }\n\n    for ( int i = 0; i < m; i++ ) {\n      int a = E[i].first;\n      int b = E[i].second.first;\n      int c = E[i].second.second;\n\n      if ( find( b ) != find( c ) ) {\n\tunite( b, c );\n\tused[i] = true;\n      }\n    }\n\n    int answer = 0;\n    for ( int i = 0; i < m; i++ ) {\n      if ( used[i] ) {\n\tanswer += ( E[i].first / 100 ) - 1;\n      }\n    }\n\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define M 999\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;scanf(\"%d%d\",&n,&m)>1;printf(\"%d\\n\",s/100-n+1)){\n\t\tfor(i=0;i<m;i++)scanf(\"%d,%d,%d\",a+i,b+i,&node[i].first),node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\ntypedef struct ST_edge {\n\tint a;\n\tint b;\n\tint d;\n\tST_edge() { a=0; b=0; d=0; }\n\tST_edge(int a_, int b_, int d_) { a=a_; b=b_; d=d_; }\n\tbool operator>(const ST_edge& e) const { return d > e.d; }\n} edge;\n\nint main()\n{\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif (n==0) break;\n\t\tcin >> m;\n\t\tpriority_queue< edge, vector<edge>, greater<edge> > E;\n\t\tint a_, b_, d_;\n\t\tchar dummy;\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tcin >> a_ >> dummy >> b_ >> dummy >> d_;\n\t\t\tE.push( edge(a_, b_, d_) );\n\t\t}\n\t\t\n\t\tvector<int> comp;\n\t\tcomp.reserve(n);\n\t\tfor (int i=0; i<n; i++) comp.push_back(i);\n\t\t\n\t\tint num_of_lantern = 0;\n\t\twhile ( !E.empty() ) {\n\t\t\tedge e = E.top();\n\t\t\tif (comp.at(e.a) != comp.at(e.b)) {\n\t\t\t\tcomp.at(e.a) = comp.at(e.b);\n\t\t\t\tnum_of_lantern += e.d/100 - 1;\n\t\t\t}\n\t\t\tE.pop();\n\t\t}\n\t\t\n\t\tcout << num_of_lantern << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <limits.h>\nusing namespace std;\nint dist[100][100]; //距離,道がないところはINF\nint mincost[100];\nbool used[100];\nint n; //頂点数\n//prim法\nint prim(){\n\tfor(int i=0;i<n;i++) mincost[i]=INT_MAX, used[i]=false;\n\tint res=0; mincost[0]=0;\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u=0;u<n;u++) if(!used[u] && (v==-1 || mincost[u]<mincost[v])) v=u;\n\t\tif(v==-1) break;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\t//距離の更新\n\t\tfor(int u=0;u<n;u++) mincost[u]=min(mincost[u],dist[v][u]);\n\t}\n\treturn res;\n}\nint main() {\n\tint m;\n\twhile(1){\n\t\tcin >> n ; if(!n) break;\n\t\tcin >> m ;\n\t\tfor(int i=0;i<100;i++) for(int j=0;j<100;j++) dist[i][j]=INT_MAX;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint st,fin,DIST; scanf(\"%d,%d,%d\",&st,&fin,&DIST);\n\t\t\tdist[st][fin]=dist[fin][st]=DIST/100;\n\t\t}\n\t\tcout << prim()-(n-1) << '\\n';\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string.h>\n#define MAX 100\n#define INT_MAX 2000000\n\nint N;\nint M[MAX][MAX];\n\nvoid prim(){\n//    dist = 0.0;\n    \n    char visited[MAX];\n    int cost[MAX];\n    int pi[MAX];\n    int i;\n    for (i = 0; i < N; i++ ){\n        visited[i] = 0;\n        cost[i] = INT_MAX;\n    }\n    \n    cost[0] = 0;\n    pi[0] = -1;\n    \n    while ( 1 ){\n        int mincost = INT_MAX;\n        int u;\n        // cost ªÅ¬ÆÈém[h u ðIð·é\n        for (i = 0; i < N; i++ ){\n            if ( !visited[i] && cost[i] < mincost ){\n                mincost = cost[i];\n                u = i;\n            }\n        }\n        \n        // ·×ÄÌm[hª MST ÉÜÜê½Æ«\n        if ( mincost == INT_MAX ) break;\n        \n        visited[u] = 1;\n        int v;\n        for (  v = 0; v < N; v++ ){\n            if ( visited[v] || M[u][v] == INT_MAX ) continue;\n            // XV\n            if ( M[u][v] < cost[v] ){\n                cost[v] = M[u][v];\n                pi[v] = u;\n            }\n        }\n    }\n\tint j=0;\n\tfor(i=0;i<N;i++){\n\t\tj+=M[i][pi[i]];\n\t}\n\tprintf(\"%d\\n\",j);\n}\n\nint main(){\n\tint m,i,j,a,b,c;\n\t\n\twhile(~scanf(\"%d\",&N)){\n\t\tif(N==0) break;\n\t\t\n\t\tfor(i=0;i<N;i++){\n\t\t\tfor(j=0;j<N;j++){\n\t\t\t\tM[i][j]=INT_MAX;\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tM[a][b]=c/100-1;\n\t\t\tM[b][a]=c/100-1;\n\t\t}\n\t\t\n\t\tprim();\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nint arive[101][101];\nint main(void){\n  int n,m;\n  while(cin>>n>>m){\n    if(n==0) break;\n    int ans = 0;\n    vector<pair<int,PII> > route;\n    REP(i,n)REP(j,n)arive[i][j] = 1;\n    REP(i,m){\n      int a,b,l;\n      scanf(\"%d,%d,%d\",&a,&b,&l);\n      l = (l-1)/100;\n      route.push_back(pair<int,PII>(l,PII(a,b)));\n    }\n    sort(route.begin(),route.end());\n    REP(i,route.size()){\n      int a = route[i].second.first;\n      int b = route[i].second.second;\n      if(arive[a][b]){\n        arive[a][b] = arive[b][a] = 0;\n        REP(i2,n)REP(j,n) arive[i2][j] = min(arive[i2][j]\n            ,arive[i2][a] + arive[a][j]);\n        REP(i2,n)REP(j,n) arive[i2][j] = min(arive[i2][j]\n            ,arive[i2][b] + arive[b][j]);\n        ans += route[i].first;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c) : to(t), cost(c) { }\n};\ntypedef pair<int, int> P;\n\nint prim ( int n, vector<vector<edge> >* E )\n{\n\tvector<bool> used(n, false);\n\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0, 0));\n\n\tint res = 0;\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\t\t\n\t\tint v = p.second;\n\t\tif (used[v]) { continue; }\n\t\tused[v] = true;\n\t\tres += max(0, p.first / 100 - 1);\n\t\t\n\t\tvector<edge> es = (*E)[v];\n\t\tfor (int i = 0; i < es.size(); ++i) {\n\t\t\tedge& e = es[i];\n\t\t\tif (!used[e.to]) { que.push(P(e.cost, e.to)); }\n\t\t}\n\t}\n\treturn res;\n}\n\nint main ( void )\n{\n\tint n;\n\n\twhile (cin >> n, n) {\n\t\tint m;\n\t\tcin >> m;\n\n\t\tvector<vector<edge> > E(n);\n\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\n\t\t\tE[a].push_back(edge(b, c));\n\t\t\tE[b].push_back(edge(a, c));\n\t\t}\n\n\t\tcout << prim(n, &E) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\n// ????????????????????£?¨?\nint kruskal(int v, vector<vector<pair<int, int> > > adjlist);\n\n// ?????????\nint main(void){\n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n;\n    if(n == 0){ break; }\n    cin >> m;\n\n    // ???????????±????????????????????£??\\??????????????????\n    vector<vector<pair<int, int> > > adjlist(n);\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      adjlist[a].push_back(make_pair(d, b));\n      adjlist[b].push_back(make_pair(d, a));\n    }\n  \n    // ????°???¨?????¨????????????????±??????????????????????\n    int length = kruskal(n, adjlist);\n    cout << length / 100 - n + 1 << endl;\n  }\n\n  return 0;\n}\n\n// UnionFind??¨\nclass UnionFindTree{\nprivate:\n  int m_size;\n  vector<int> parent;\n  vector<int> rank;\n  vector<int> vertices;\n  int find(int a);\npublic:\n  void init(int s);\n  void unite(int a, int b);\n  bool same(int a, int b);\n  bool isConnected(void);\n};\n\n// UF??¨????????????\nvoid UnionFindTree::init(int size){\n  parent.clear();\n  rank.clear();\n  vertices.clear();\n  m_size = size;\n  for(int i = 0; i < size; i++){\n    parent.push_back(i);\n    rank.push_back(0);\n    vertices.push_back(1);\n  }\n  return;\n}\n\n// UF??¨?????????????????????\nint UnionFindTree::find(int a){\n  if(parent[a] != a){ parent[a] = find(parent[a]); }\n  return parent[a];\n}\n\n// UF??¨??§???????????£?????????\nvoid UnionFindTree::unite(int a, int b){\n  int x = find(a);\n  int y = find(b);\n  // ?????§???????????£???????????????????????????\n  if(x == y){ return; }\n\n  if(rank[x] < rank[y]){\n    parent[x] = y;\n    vertices[y] += vertices[x];\n  }\n  else{\n    parent[y] = x;\n    vertices[x] += vertices[y];\n    if(rank[x] == rank[y]){ rank[x]++; }\n  }\n  return;\n}\n\n// UF??¨??§???????????????????????????????????????\nbool UnionFindTree::same(int a, int b){\n  return find(a) == find(b);\n}\n\n// UF??¨??§?????????????????????????????¨???????????????????????????\nbool UnionFindTree::isConnected(void){\n  return vertices[find(0)] == m_size;\n}\n\n// ??????????????????\n// v: ????????°, adjlist: ??£??\\?????????(first: ???????????????, second: ?????????)\nint kruskal(int v, vector<vector<pair<int, int> > > adjlist){\n  int length = 0; // ??¨????????????\n\n  // ?????????????????????\n  vector<pair<int, pair<int, int> > > edge;\n  for(int i = 0; i < v; i++)\n    for(int j = 0; j < adjlist[i].size(); j++)\n      edge.push_back(make_pair(adjlist[i][j].first, make_pair(i, adjlist[i][j].second)));\n  sort(edge.begin(), edge.end());\n\n  // UF??¨?????£?¨???¨?????????\n  UnionFindTree uf;\n  uf.init(v);\n\n  // ???????????????????????????????????????????????????????????£?????????????????§?????????\n  for(int i = 0; i < edge.size() && !uf.isConnected(); i++){\n    // i??????????°???????????????????\n    int cost = edge[i].first;\n    int a = edge[i].second.first;\n    int b = edge[i].second.second;\n    // ????????????????????????????????£????????????????£???°???\n    if(uf.same(a, b)){ continue; }\n\n    // UF??¨?????£??????????????????????????´??°\n    uf.unite(a, b);\n    length += cost;\n  }\n    /*\n  while(!edge.empty() && !uf.isConnected()){\n    // ????£????????????????????°?????????????????????????\n    int cost = -edge.top().first;\n    int a = edge.top().second.first;\n    int b = edge.top().second.second;\n    edge.pop();\n    // ????????????????????????????????£????????????????£???°???\n  //   if(uf.same(a, b)){ continue; }\n\n  //   // UF??¨?????£??????????????????????????´??°\n  //   uf.unite(a, b);\n  //   length += cost;\n  // }\n  //   */\n\n  // ?????????: ??¨????????????\n  return length;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n#define INF 1e9\n\n// ????????????????????£?¨?\nint prim(int vertex, vector<vector<pair<int, int> > > adjlistv);\n\n// ?????????\nint main(void){\n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n;\n    if(n == 0){ break; }\n    cin >> m;\n\n    // ???????????±????????????????????£??\\??????????????????\n    vector<vector<pair<int, int> > > adjlist(n);\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      adjlist[a].push_back(make_pair(d, b));\n      adjlist[b].push_back(make_pair(d, a));\n    }\n  \n    // ????°???¨?????¨????????????????±??????????????????????\n    int length = prim(n, adjlist);\n    cout << length / 100 - n + 1 << endl;\n  }\n\n  return 0;\n}\n\n// ????????????\n// v: ????????°, adjlist: ??£??\\?????????(first: ???????????????, second: ?????????)\nint prim(int v, vector<vector<pair<int, int> > > adjlist){\n  priority_queue<pair<int, int> > wait;  // ?????§???????????????????????¨?????§???????°??????????\n  vector<int> result(v, INF);  // ??????i??¨??¨?????????????°??????????\n  int length = 0;  // ??¨????????????\n\n  // ??¨?????????????????????1?????¨?????????\n  result[0] = 0;\n  wait.push(make_pair(0, 0));\n  \n  // ???????????????\n  while(!wait.empty()){\n    // ????£?????????????????°?????????????????????????\n    int newpoint = wait.top().second;\n    int newcost = -wait.top().first;\n    wait.pop();\n    if(result[newpoint] < newcost){ continue; }\n\n    // ???????????????????????¨?????????\n    result[newpoint] = -INF;\n    length += newcost;\n\n    // ???newpoint????????\\?¶???????????????????????????????????????? \n    for(int i = 0; i < adjlist[newpoint].size(); i++){\n      int nextpoint =  adjlist[newpoint][i].second;\n      int nextcost = adjlist[newpoint][i].first;\n      // ????????¨??????????????£????????????????????°?????????????????????queue?????????\n      if(result[nextpoint] > nextcost){\n        result[nextpoint] = nextcost;\n        wait.push(make_pair(-nextcost, nextpoint));\n      }\n    }\n  }\n\n  // ?????????: ??¨????????????\n  return length;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint G[102][102];\nint NG[102][102];\nbool used[102];\nconst int INF=9999999;\nint main(){\n\tint n,m,ans=0;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tcin>>m;\n\tans=0;\n\tfor(int i=0;i<102;i++)for(int j=0;j<102;j++)G[i][j]=INF,used[i]=false,NG[i][j]=INF;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar x;\n\t\tcin>>a>>x>>b>>x>>c;\n\t\t//if(a==b){cout<<\"x\";return 0;}\n\t\tG[a][b]=c;\n\t}\n\tint u,v,a,b;\n\tused[0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tv=-1;\n\t\tfor(int j=0;j<n;j++)if(!used[j])v=1;\n\t\tif(v==-1)break;\n\t\tint mi=INF;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\tif(mi>G[j][k]&&used[j]==1&&used[k]==0)mi=G[j][k],a=j,b=k;\n\t\t\t}\n\t\t}\n\t\tused[b]=1;\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\t//for(int i=0;i<n;i++)cout<<used[i]<<\" \";cout<<endl;\n\t\tNG[a][b]=G[a][b];\n\t}\n//for(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<G[i][j]<<\" \";cout<<endl;}\n\tint cnt=0;\n\tfor(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){;\n\t\tif(NG[i][j]!=INF)ans+=NG[i][j],cnt++;\n\t\t}\n\n\t}\n\t//for(int i=0;i<n;i++)for(int j=0;j<n;j++)ans+=NG[i][j];\n\tcout<<ans/100-cnt<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <set>\n#include <algorithm>\n#include <climits>\n#include <cstdio>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define MP(a,b) make_pair(a,b)\nint main(){\n\tint n,m,a,b,c,mi,ret;\n\tint info[100][100];\n\tpair<int,int> now;\n\twhile(cin >> n && n){\n\t\tcin >> m;\n\t\tret = 0;\n\t\trep(i,100)rep(j,100)info[i][j] = INT_MAX;\n\n\t\trep(i,m){\n\t\t\tscanf(\"%d,%d,%d\\n\",&a,&b,&c);\n\t\t\tinfo[a][b] = info[b][a] = (c/100)-1;\n\t\t}\n\n\t\tset<int> remain;\n\t\tfor(int i=1;i<n;i++)remain.insert(i);\n\n\t\twhile(!remain.empty()){\n\t\t\tnow = MP(1<<21,-1);\n\t\t\trep(i,n)\n\t\t\t\tif(remain.find(i) == remain.end() )\n\t\t\t\t\trep(j,n)\n\t\t\t\t\t\tif(remain.find(j) != remain.end())now = min(now,MP(info[i][j],j));\n\t\t\tret+=now.first;\n\t\t\tremain.erase(now.second);\n\t\t}\n\t\tcout << ret << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include \"stdio.h\"\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge{\n    Edge(int t, int c)\n        : to(t), cost(c) {}\n\n    int to;\n    int cost;\n};\n\nbool visited[100];\nvector<Edge> G[100];\ntypedef pair<int, int> PII;\n\nint prim(int start){\n    int ans = 0;\n    fill(visited, visited+100, false);\n\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n\n    que.push(PII(0, start));\n    visited[0] = true;\n    while (!que.empty()){\n        PII p = que.top();\n        int v = p.second;\n        int cst = p.first;\n        que.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        ans += cst;\n        for (int i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            que.push(PII(G[v][i].cost, G[v][i].to));\n        }\n    }\n\n    return ans;\n} \n\nint main(int argc, char const *argv[]){\n    int n, m;\n\n    while (cin>>n, n){\n        cin>>m;\n        for (int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            d = (d-100) / 100;\n            G[a].push_back(Edge(b, d));\n            G[b].push_back(Edge(a, d));\n        }\n\n        cout<<prim(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>   \n#include <algorithm>   \nusing namespace std;   \n  \nconst int MAX_N = 100, MAX_M = MAX_N * MAX_N;   \n  \nint par[MAX_N]; // e   \nint rank[MAX_N]; // ØÌ[³   \n  \n// nvfÅú»   \nvoid init_union_find(int n)   \n{   \n    for (int i = 0; i < n; i++)   \n    {   \n        par[i] = i;   \n        rank[i] = 0;   \n    }   \n}   \n  \n// ØÌªðßé   \nint find_union_find(int x)   \n{   \n    if (par[x] == x)   \n        return x;   \n    else  \n        return par[x] = find_union_find(par[x]);   \n}   \n  \n// xÆyÌ®·éWð¹   \nvoid unite_union_find(int x, int y)   \n{   \n    x = find_union_find(x);   \n    y = find_union_find(y);   \n    if (x == y) return ;   \n  \n    if (rank[x] < rank[y])   \n        par[x] = y;   \n    else  \n    {   \n        par[y] = x;   \n        if (rank[x] == rank[y]) rank[x]++;   \n    }   \n}   \n  \n// xÆyª¯¶WÉ®·é©Û©   \nbool same_union_find(int x, int y)   \n{   \n    return find_union_find(x) == find_union_find(y);   \n}   \n  \nstruct edge { int u, v, cost; };   \n  \nbool comp(const edge &e1, const edge &e2)   \n{   \n    return e1.cost < e2.cost;   \n}   \n  \n// üÍ   \nint n, m;   \nedge es[MAX_M];   \n  \nint kruskal()   \n{   \n    std::sort(es, es + m, comp);   \n    init_union_find(n);   \n    int res = 0;   \n    for (int i = 0; i < m; i++)   \n    {   \n        edge e = es[i];   \n        if (!same_union_find(e.u, e.v))   \n        {   \n            unite_union_find(e.u, e.v);   \n            res += e.cost;   \n        }   \n    }   \n    return res;   \n}   \n  \nvoid solve()   \n{ \n    printf(\"%d\\n\", kruskal());   \n}   \n  \nint main()   \n{   \n    while (scanf(\"%d\", &n) && n)   \n    {   \n        scanf(\"%d\", &m);   \n        for (int i = 0; i < m; i++)   \n        {   \n            int a, b, d;   \n            scanf(\"%d,%d,%d\", &es[i].u, &es[i].v, &es[i].cost);   \n            es[i].cost = es[i].cost / 100 - 1;   \n        }   \n  \n        solve();   \n    }   \n  \n    return 0;   \n}  "
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint main(){\n  int h,i,j;\n  int a[100][100],b[100],p[5000],q[5000],r[5000],m,n,o;\n  int sm;\n  while(cin>>n&&n){\n    cin>>m;\n    memset(a,0,sizeof(a));\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&p[i],&q[i],&r[i]);\n      r[i]=r[i]/100-1;\n      a[p[i]][q[i]]=r[i];\n      a[q[i]][p[i]]=r[i];\n    }\n    do{\n      h=0;\n      for(i=1;i<m;i++){\n\tif(r[i-1]>r[i]){\n\t  swap(p[i-1],p[i]);\n\t  swap(q[i-1],q[i]);\n\t  swap(r[i-1],r[i]);\n\t  h=1;\n\t}\n      }\n    }while(h);\n    memset(b,0,sizeof(b));\n    h=-1;\n    o=0;\n    sm=0;\n    for(i=1;i<n;i++){\n      for(h++;r[h]==0;h++);\n      sm+=r[h];\n      if(b[p[h]]==0&&b[q[h]]==0){\n\to++;\n\tb[p[h]]=o;\n\tb[q[h]]=o;\n      }else if(b[p[h]]==0)\n\tb[p[h]]=b[q[h]];\n      else if(b[q[h]]==0)\n\tb[q[h]]=b[p[h]];\n      else{\n\tfor(j=0;j<n;j++){\n\t  if(p[h]!=j&&b[p[h]]==b[j])\n\t    b[j]=b[q[h]];\n\t}\n\tb[p[h]]=b[q[h]];\n      }\n      for(j=0;j<n;j++){\n\tif(b[p[h]]==b[j]&&a[p[h]][j]){\n\t  a[p[h]][j]=0;\n\t  a[j][p[h]]=0;\n\t}\n\tif(b[q[h]]==b[j]&&a[q[h]][j]){\n\t  a[q[h]][j]=0;\n\t  a[j][q[h]]=0;\n\t}\n      }\n      for(j=h+1;j<m;j++){\n\tif(r[j]&&a[p[j]][q[j]]==0)\n\t  r[j]=0;\n      }\n    }\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nconstexpr int MAX_N = 100;\n\nstruct edge {\n\tint from_, to_, cost_;\n\tedge() = default;\n\tedge(int from, int to, int cost) :from_(from), to_(to), cost_(cost) {}\n\tbool operator<(const edge& rhs) const{\n\t\treturn (cost_ == rhs.cost_) ? to_ < rhs.to_ : cost_ < rhs.cost_;\n\t}\n};\n\nint n, m;\nstd::vector<edge> edges;\n\nclass Union {\n\tint par[MAX_N], rank[MAX_N];\npublic:\n\tUnion() {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\tint find(int x) {\n\t\tif (x == par[x])\n\t\t\treturn x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\tif (rank[x] < rank[y])\n\t\t\tstd::swap(x, y);\n\t\tpar[y] = x;\n\t\trank[x] += rank[y];\n\t}\n};\n\nint main() {\n\twhile (1) {\n\t\tstd::cin >> n;\n\t\tif (!n)\n\t\t\tbreak;\n\t\tstd::cin >> m;\n\t\tUnion uni;\n\t\tedges.clear();\n\t\tint a, b, d;\n\t\tchar ch;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tstd::cin >> a >> ch >> b >> ch >> d;\n\t\t\td /= 100;\n\t\t\t--d;\n\t\t\tedges.push_back(edge(a, b, d));\n\t\t}\n\n\t\tstd::sort(edges.begin(), edges.end());\n\n\t\tlong long int ans = 0;\n\t\tfor (int i = 0; i < edges.size(); ++i) {\n\t\t\tif (!uni.same(edges[i].from_, edges[i].to_)) {\n\t\t\t\tuni.unite(edges[i].from_, edges[i].to_);\n\t\t\t\tans += edges[i].cost_;\n\t\t\t}\n\t\t}\n\t\tstd::cout << ans << std::endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#include <functional>\n#pragma warning(disable : 4996)\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1000000000000000000LL\nusing namespace std;\nlong long prim(int V, vector<pair<long long, long long>> X[]) {\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long> > > Q;\n\tlong long dist[101], color[101];\n\tfor (int i = 0; i < V; i++) { dist[i] = INF; color[i] = WHITE; }\n\tdist[0] = 0; color[0] = GRAY; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<long long, long long>pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; color[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first, leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && color[to] < BLACK) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < V; i++) { sum += dist[i]; }//0-indexed\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<long long, long long> > g[100];\nint main() {\n\twhile (scanf(\"%d\", &n), n) {\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < n; i++) g[i].clear();\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", &u, &v, &w);\n\t\t\tg[u].push_back(make_pair((long long)(v), (long long)(w / 100 - 1)));\n\t\t\tg[v].push_back(make_pair((long long)(u), (long long)(w / 100 - 1)));\n\t\t}\n\t\tcout << prim(n, g) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<queue>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\nint main(){\n  int n;\n  while(cin>>n,n){\n    int m;cin>>m;\n    int d[n+1][n+1];\n    for(int i=0;i<n+1;i++)\n      for(int j=0;j<n+1;j++)\n\td[i][j]=1000000000;\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      d[a][b]=c;\n      d[b][a]=c;\n    }\n    for(int k=0;k<n;k++){\n      for(int i=0;i<n;i++){\n\tfor(int j=0;j<n;j++){\n\t  d[i][j]=min(d[i][k]+d[k][j],d[i][j]);\n\t}\n      }\n    }\n    int ans=1000000000;\n    for(int i=0;i<n;i++){\n      int cnt=0;\n      for(int j=0;j<n;j++){\n\tif(i!=j)\n\t  cnt+=d[i][j];\n\t//cout<<d[i][j]<<\" \";\n      }\n      ans=min(ans,cnt);\n      //cout<<endl;\n    }\n    cout<<(ans/100)-n+1<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<climits>\n#include<cfloat>\n#include<cmath>\n#include<map>\n#include<complex>\n\n#define f first\n#define s second\n#define mp make_pair\n\n#define REP(i,n) for(int i=0; i<(int)(n); i++)\n#define FOR(i,c) for(__typeof((c).begin()) i=(c).begin(); i!=(c).end(); i++)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef unsigned int uint;\ntypedef long long ll;\n\nusing namespace std;\n\n#define MAX (100000000)\n\nint main(){\n  int n;\n  while(scanf(\"%d\",&n), n){\n    int m;\n    vector<bool> f(n, false);\n    vector<vector<int> > g(n, vector<int>(n, MAX));\n    int ans = 0;\n    scanf(\"%d\",&m);\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c); c/=100;\n      g[a][b] = g[b][a] = c - 1;\n    }\n    f[0] = true;\n    REP(k, n-1){\n      int a,b,s;\n      s = MAX;\n      REP(i, n) REP(j, n) if(f[i] != f[j]){\n        if(s > g[i][j]){\n          a = i; b = j; s = g[i][j];\n        }\n      }\n      f[a] = f[b] = true;\n      ans += s;\n    }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nconst int N = 100000;\nint par[N];\nint rank[N];\n \nvoid init(int n){\n    for (int i = 0; i < n; ++i){\n        par[i] = i;\n        rank[i] = 0;\n    }\n}\n \nint find(int x){\n    if (par[x] == x)return x;\n    return par[x] = find(par[x]);\n}\n \nvoid unite(int x, int y){\n    x = find(x);\n    y = find(y);\n    if (x == y)return;\n    if (rank[x] < rank[y]){\n        par[x] = y;\n    }\n    else{\n        par[y] = x;\n        if (rank[x] == rank[y])rank[x]++;\n    }\n}\n \nbool same(int x, int y){\n    return find(x) == find(y);\n}\n \nstruct edge {\n    int u, v, cost;\n};\n \nbool comp(const edge& e1, const edge& e2){\n    return e1.cost < e2.cost;\n}\n \nedge es[1000000];\nint V, E;\n \nint kruskal(){\n    std::sort(es, es + E, comp);\n    init(V);\n    int res = 0;\n    for (int i = 0; i < E; ++i){\n        edge e = es[i];\n        if (!same(e.u, e.v)){\n            unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n \nint main(){\n    while (1){\n        scanf(\"%d\", &V);\n        if (V == 0)break;\n        scanf(\"%d\", &E);\n        for (int i = 0; i < E; ++i){\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            es[i].u = a, es[i].v = b, es[i].cost = c;\n        }\n        int ans = kruskal();\n        printf(\"%d\\n\", ans / 100 - V + 1);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Carden Lantern [AOJ 0072]\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\ntypedef vector <PIP>    Edges;\n\nconst int size = 101;\nint P[size];\n\nvoid init( int n ) {\n    for ( int i = 0; i < n; i++ ) {\n        P[i] = -1;\n    }\n}\n\nint find( int a ) {\n    if ( P[a] == -1 ) {\n        return a;\n    }\n    return P[a] = find( P[a] );\n}\n\nvoid merge( int a, int b ) {\n    int fa = find( a ), fb = find( b );\n\n    if ( fa != fb ) {\n        if ( P[a] == -1 ) {\n            P[a] = fb;\n        } else {\n            P[b] = fa;\n        }\n    }\n}\n\nbool same_set( int a, int b ) {\n    return find( a ) == find( b );\n}\n\nint main( void ) {\n    string line;\n\n    while ( getline( cin, line ) ) {\n        // init\n        int n, m;\n        Edges E;\n\n        // input\n        if ( line == \"0\" ) {\n            break;\n        }\n        {\n            istringstream is( line );\n            is >> n;\n        }\n        {\n            getline( cin, line );\n            istringstream is( line );\n            is >> m;\n        }\n        for ( int i = 0; i < m; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            int a, b, c;\n            istringstream is( line );\n            is >> a >> b >> c;\n\n            PIP edge( c / 100, PII( a, b ) );\n            E.push_back( edge );\n        }\n\n        // proc\n        int answer = 0;\n        init( n );\n\n        sort( E.begin(), E.end() );\n        for ( int i = 0; i < m; i++ ) {\n            int a = E[i].second.first;\n            int b = E[i].second.second;\n            int c = E[i].first;\n\n            if ( !same_set( a, b ) ) {\n                answer += c - 1;\n                merge( a, b );\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct branch{\n\tint n1,n2,w;\n};\nbool f(branch i,branch j){\n\treturn(i.w>j.w);\n}\nint main(){\n\twhile(1){\n\t\tint m,n,i,x=0;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int>T(n);\n\t\tfor(i=0;i<n;i++) T[i]=i;\n\n\t\tcin>>m;\n\t\tvector<branch>S(m);\n\t\tfor(i=0;i<m;i++) cin>>S[i].n1>>c>>S[i].n2>>c>>S[i].w;\n\t\tsort(S.begin(),S.end(),f);\n\n\t\tbranch tmp;\n\t\twhile(S.size()){\n\t\t\ttmp=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[tmp.n1],c=T[tmp.n2],a=b;\n\t\t\tif(b!=c){\n\t\t\t\tif(b>c)a=c,c=b;\n\t\t\t\tfor(i=c;i<n;i++)\n\t\t\t\t\tif(T[i]==c)T[i]=a;\n\t\t\t\tx+=tmp.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1145141919810\n\nint x[1000][1000];\nint color[10000];\nint MIN[10000];\nint sum;\nint sum_min = INF;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(color, 0, sizeof(color));\n\t\tmemset(MIN, 0, sizeof(MIN));\n\t\tint n, a, b, c, m, e, f, g;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tx[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", e, f, g);\n\t\t\tx[e][f] = g;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tMIN[j] = INF;\n\t\t\t\tcolor[j] = WHITE;\n\t\t\t}\n\t\t\tb = INF;\n\t\t\ta = n;\n\t\t\tcolor[i] = GRAY;\n\t\t\tMIN[i] = 0;\n\t\t\twhile (a != 0) {\n\t\t\t\tb = INF;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\t\tc = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolor[c] = BLACK;\n\t\t\t\ta -= 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (color[k] != BLACK && x[c][k] != -1) {\n\t\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tsum += MIN[j];\n\t\t\t}\n\t\t\tsum_min = min(sum_min, sum);\n\t\t}\n\t\tcout << sum_min / 100 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<map>\n#include<utility>\n#include<algorithm>\n#include<cstdlib>\n#include<string>\n\nusing namespace std;\n\n#define mp makepair\n\nint main(){\n  int n,m,k,l;\n  int a,b,c;\n  string data;\n  pair<int,pair<int,int> > p;\n  vector<pair<int,pair<int,int> > > nodes;\n  while(true){\n    cin>>n;\n    if(!n)break;\n    cin>>m;\n    int num[m],count=0;\n    for(int i=0;i<m;i++){\n      num[i] = i;\n      cin>>data;\n      a = atoi(data.substr(0,data.find(\",\")).c_str());\n      b = atoi(data.substr(data.find(\",\")+1,data.find(\",\",data.find(\",\")+1)).c_str());\n      c = atoi(data.substr(data.find(\",\",data.find(\",\")+1)+1).c_str());\n      p.first = c/100-1;\n      p.second.first = a;\n      p.second.second = b;\n      nodes.push_back(p);\n    }\n    sort(nodes.begin(),nodes.end());\n    for(int i=0;i<m;i++){\n      if (num[nodes[i].second.first]!=num[nodes[i].second.second]){\n\tk = min(num[nodes[i].second.first],num[nodes[i].second.second]);\n\tl = max(num[nodes[i].second.first],num[nodes[i].second.second]);\n\tcount+=nodes[i].first;\n\tfor(int j=0;j<m;j++)if(num[j]==l)num[j] = k;\n      }\n    }\n    cout<<count<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int INF = (1 << 30);\n\nvoid setV(vector< vector<int> > &v){\n  string str, tmp; cin >>str;\n  vector<string> nums;\n  stringstream ss(str);\n  while(getline(ss, tmp, ',')) nums.push_back(tmp);\n  int from = atoi(nums[0].c_str()), to = atoi(nums[1].c_str()), cost = atoi(nums[2].c_str());\n  v[from][to] = cost;\n  v[to][from] = cost;\n}\n\nint main() {\n  int V;\n  while(cin >>V && V){\n    int E; cin >>E;\n    vector< vector<int> > v(V, vector<int>(V, INF));\n    REP(i, E) setV(v);\n\n    priority_queue< P, vector<P>, greater<P> > open;\n    open.push(P(100, 0));\n    vector<int> closed(V, INF);\n\n    int min_cost = 0;\n    while(!open.empty()){\n      P now = open.top();\n      open.pop();\n\n      if(closed[now.second] != INF) continue;\n      closed[now.second] = now.first;\n      min_cost += (now.first - 100) / 100;\n\n      REP(i, V){\n        if(closed[i] == INF && v[now.second][i] != INF){\n          open.push(P(v[now.second][i], i));\n        }\n      }\n\n    }\n    cout <<min_cost <<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n#define _CRT_SECURE_NO_WARNINGS\n#define _USE_MATH_DEFINES\n#include <cfloat>\n#include <climits>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <iostream>\n#include <memory>\n#include <string>\n\n#include <algorithm>\n#include <complex>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <stack>\n#include <vector>\n#include <bitset>\n\nusing namespace std;\n\n#ifdef _MSC_VER\n#define __typeof__ decltype\n#define strtok_r strtok_s\n#endif\n\n#define ITER(c)             __typeof__((c).begin())\n#define FOREACH(it, c)      for (ITER(c) it=(c).begin(); it != (c).end(); ++it)\n#define RITER(c)            __typeof__((c).rbegin())\n#define RFOREACH(it, c)     for (RITER(c) it=(c).rbegin(); it != (c).rend(); ++it)\n#define REP(i, n)           REPEAT(i, 0, n)\n#define RREP(i, n)          RREPEAT(i, 0, n)\n#define REPEAT(i, k, n)     for(int i = (k); i < (k+n); ++i)\n#define RREPEAT(i, k, n)    for(int i = (k)+(n)-1; i >= (k); --i)\n#define FROMTO(i,f,t)       for(int i = f; i < t; i++)\n#define ALL(c)              (c).begin(), (c).end()\n#define LLPOW(p1,p2)        ((ll)pow((double)(p1), (int)p2))\n#define ESIZEOF(A)          (sizeof(A)/sizeof((A)[0]))\n#define CIN_NO_SYNC         do { cin.tie(0); ios_base::sync_with_stdio(false); } while(0)\n#define GETSTR(p)           fgets((p), sizeof(p), stdin)\n#define CHOMP(p)            do{ char *_q = (p) + strlen(p)-1; if(*_q == '\\n' || *_q == '\\r') *_q = 0; } while(0)\n#define FILL(m,v)           memset(m, v, sizeof(m))\n#define mp                  make_pair\n#define pb                  push_back\ntemplate<class _T> _T MAX(_T p1,_T p2){return (p1>p2)?p1:p2;} \ntemplate<class _T> _T MIN(_T p1,_T p2){return (p1<p2)?p1:p2;} \n\ntypedef long long ll;\ntypedef unsigned long long ull;\n\n#define X real()\n#define Y imag()\ntypedef double D;\ntypedef complex<D> P;\n#define EPS (1e-9)\n\n#ifdef _DEBUG\ntemplate<class _T>\ninline void _prfe(const char *_n, _T _c, bool _p = false){\n    ITER(_c) _it=_c.begin();\n    if(_p){ cout<<_n<<\" = [\"<<endl;for(;_it!=_c.end();++_it)cout<<\"    \"<<*_it<<endl;cout<<\"]\"<<endl; }\n    else{ cout<<_n<<\" = [ \"<<*_it++;for(;_it!=_c.end();++_it)cout<<\", \"<<*_it;cout<<\" ]\"<<endl; }\n}\n#define pf printf\n#define pr(n) do{cout<<#n\" = \"<<(n)<<endl;}while(0)\n#define prfe(n) _prfe(#n, n)\n#define prfep(n) _prfe(#n, n, true)\n#define dbgchk(n) do{if(n)throw;}while(0)\n#else\n#define pf(...) /* */\n#define pr(...) /* */\n#define prfe(...) /* */\n#define prfep(...) /* */\n#define dbgchk(...) /* */\n#endif\n\ntemplate <class _Tn>\nclass UnionFind {\n    int m_node;\n    vector<_Tn> node;\npublic:\n    UnionFind(int n = 0){ init(n);}\n    void init(int n){ m_node = n; node = vector<_Tn>(n,-1); }\n    bool connect(_Tn n1, _Tn n2){\n        dbgchk(n1 < 0 || n2 < 0 || n1 >= m_node || n2 >= m_node);\n        n1 = root(n1); n2 = root(n2);\n        if(n1 == n2) return false;\n        if(node[n1] > node[n2]) swap(n1,n2);\n        node[n1] += node[n2]; node[n2] = n1;\n        return true;\n    }\n    bool is_connect(_Tn n1, _Tn n2){ return root(n1) == root(n2); }\n    _Tn root(_Tn n){\n        dbgchk(n < 0 || n >= m_node);\n        return (node[n] < 0) ? n : root(node[n]);\n    }\n    int size(_Tn n){\n        idbgchkf(n < 0 || n >= m_node);\n        return -node[root(n)];\n    }\n    void dbgprint(){\n        REP(i,m_node){\n            if(node[i] >= 0) continue;\n            printf(\"(%d:%d\", -node[i], i);\n            REP(j,m_node){\n                if(i == j) continue;\n                if(root(j) == i) printf(\",%d\", j);\n            }\n            printf(\"),\");\n        }\n        printf(\"\\n\");\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass kruskal_branch {\npublic:\n    _T1 node1, node2;\n    _T2 weight;\n    kruskal_branch(_T1 n1, _T1 n2, _T2 w) : node1(n1), node2(n2), weight(w) {;}\n    bool operator> (const kruskal_branch<_T1, _T2> &p) const { return (weight > p.weight); }\n};\n\ntemplate <class _T1, class _T2>\nclass kruskal {\npublic:\n    typedef kruskal_branch<_T1,_T2> kruskal_branch_t;\n    typedef priority_queue<kruskal_branch_t, vector<kruskal_branch_t>, greater<kruskal_branch_t> > kruskal_queue_t;\nprivate:\n    int m_nodes;\n    kruskal_queue_t queue, mintree;\n    UnionFind<_T1> node;\npublic:\n    kruskal() : m_nodes(0){;}\n    void nodenum_set(int n){ m_nodes = MAX(m_nodes, n); }\n    void branch_add(kruskal_branch_t &b){\n        dbgchk(b.node1 < 0 || b.node2 < 0);\n        queue.push(b); m_nodes = MAX(m_nodes, MAX(b.node1+1, b.node2+1));\n    }\n    kruskal_queue_t &get_mintree(void){ return mintree; }\n    UnionFind<_T1> &get_node(void){ return node; }\n\n    _T2 solve(){\n        _T2 totalcost = 0;\n        node.init(m_nodes);\n        for(; !queue.empty(); queue.pop()){\n            const kruskal_branch_t &b = queue.top();\n            if(!node.is_connect(b.node1, b.node2)){\n                mintree.push(b);\n                totalcost += b.weight;\n                node.connect(b.node1, b.node2);\n            }\n        }\n        return totalcost;\n    }\n};\n\ntypedef kruskal<int,int> kruskal_t;\ntypedef kruskal_t::kruskal_queue_t kruskal_queue_t;\ntypedef kruskal_t::kruskal_branch_t kruskal_branch_t;\n\nint solve(int n, kruskal_t &k){\n    k.solve();\n    kruskal_queue_t &mintree = k.get_mintree();\n\n    int total = 0;\n    for(; !mintree.empty(); mintree.pop()){\n        const kruskal_branch_t &b = mintree.top();\n        pf(\"node1 = %d, node2 = %d, weight = %d\\n\", b.node1, b.node2, b.weight);\n        total += b.weight;\n    }\n    return total;\n}\n\nint main(){\n    int n, m, a, b, r;\n\n    while(cin >> n, n){\n        kruskal_t k;\n        cin >> m;\n        REP(i,m){\n            string s;\n            cin >> s;\n            sscanf(s.c_str(), \"%d,%d,%d\", &a, &b, &r);\n            kruskal_branch_t branch(a, b, r/100-1);\n            k.branch_add(branch);\n        }\n        cout << solve(n, k) << endl;;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define N 100\n#define F first\n#define S second\ntypedef pair<int,int>pii;\ntypedef pair<int,pii>piii;\n\nint u[N],r[N];\n\nvoid init(int n){\n    for(int i=0;i<n;i++){\n        u[i]=i;r[i]=0;\n    }\n}\nint find(int x){return x==u[x]?x:u[x]=find(u[x]);}\n\nvoid unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(r[x]<r[y])u[x]=y;\n    else u[y]=x;\n    r[x]+=(r[x]==r[y])?1:0;\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nint main(){\n    int n,m;\n    while(scanf(\"%d\",&n),n){\n        scanf(\"%d\",&m);\n        vector<piii>es(m);\n        for(int i=0;i<m;i++){\n            int a,b,c;\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            c=c/100-1;\n            es[i]=piii(c,pii(min(a,b),max(a,b)));\n        }\n        init(n);\n        sort(es.begin(),es.end());\n        int res=0;\n        for(int i=0;i<m;i++){\n            piii p=es[i];\n            if(same(p.S.F,p.S.S))continue;\n            unite(p.S.F,p.S.S);\n            res+=p.F;\n        }\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<map>\n#include<set>\n#include<unordered_map>\n#include<unordered_set>\n#include<list>\n#include<queue>\n#include<stack>\n#include<deque>\n#define p pair<int,int>\n#define P pair<int,p>\nusing namespace std;\n\nP g[100000];\nint Par[100000], Rank[100000];\nint saiki(int a) {\n\tif (Par[a] == a)return a;\n\treturn Par[a] = saiki(Par[a]);\n}\nvoid unite(int a, int b) {\n\ta = saiki(a);\n\tb = saiki(b);\n\tif (Rank[a] > Rank[b]) {\n\t\tPar[b] = a;\n\t}\n\telse if (Rank[a] < Rank[b]) {\n\t\tPar[a] = b;\n\t}\n\telse {\n\t\tPar[b] = a;\n\t\tRank[a]++;\n\t}\n}\nint main() {\n\tint a, b;\n\twhile (cin >> a, a) {\n\t\tcin >> b;\n\t\tfor (int c = 0; c < b; c++) {\n\t\t\tint d, e, f;\n\t\t\tscanf(\"%d,%d,%d\", &d, &e, &f);\n\t\t\tg[c] = P(f, p(d, e));\n\t\t}\n\t\tfor (int c = 0; c < a; c++) {\n\t\t\tPar[c] = c;\n\t\t\tRank[c] = 0;\n\t\t}\n\t\tsort(g, g + b);\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < b; i++) {\n\t\t\tif (saiki(g[i].second.first) != saiki(g[i].second.second)) {\n\t\t\t\tans += g[i].first / 100 - 1;\n\t\t\t\tunite(g[i].second.first, g[i].second.second);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\ntypedef pair<int,pair<int,int> > PII;\nint n,m;\nint ans;\nint E[15000];\nPII V[15000];\n\nsigned main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            V[i].first=z;\n            V[i].second.first=x;\n            V[i].second.second=y;\n        }\n        sort(V,V+m);\n        rep(i,m){\n            if(E[V[i].second.first]==1&&E[V[i].second.second]==1)continue;\n            ans+=V[i].first-100;\n            E[V[i].second.first]=1;\n            E[V[i].second.second]=1;\n        }\n        cout<<ans/100<<endl;\n        ans=0;\n        rep(i,n)E[i]=0;\n        rep(i,m){\n            V[i].first=0;\n            V[i].second.first=0;\n            V[i].second.second=0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\nclass Dijkstra {\n#define MAX_V 101\n  typedef pair<int, int> P;\n\nprivate:\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n        }\n      }\n    }\n\n    return d;\n  }\n};\n\n\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    Dijkstra dijkstra(n);\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n      int a, b, d;\n      char split;\n      cin >> a >> split >> b >> split >> d;\n      dijkstra.AddEdge(a, b, d);\n      dijkstra.AddEdge(b, a, d);\n    }\n\n    int ans = INF;\n    for (int i = 0; i < n; i++) {\n      vector<int> d = dijkstra.Solve(i);\n      int tmp = accumulate(d.begin(), d.end(), 0);\n      ans = min(ans, tmp);\n    }\n\n    cout << ans / 100 - (n - 1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <stack>\n#include <queue>\n#include <cstring>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n\n#define VARIABLE(x) cerr << #x << \"=\" << x << endl\n#define rep(i,n) for(int i=0;i<(int)(n);i++)\n#define REP(i,m,n) for (int i=m;i<(int)(n);i++)\n\nconst int INF = 10000000;\nusing namespace std;\ntypedef long long  ll;\n\n/** Problem0072 : Carden Lantern **/\nint n, m;\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\n// 最小全域木を求める : プリム法\nint prim()\n{\n\trep(i, n) {\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\t\n\twhile (1) {\n\t\tint v = -1;\n\t\tfor (int u=0; u<n; u++) {\n\t\t\tif (!used[u] && (v == -1 || mincost[u]<mincost[v])) v=u;\n\t\t}\n\t\t\n\t\tif (v==-1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\trep(u, n)\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tchar ca;\n\t\n\twhile (cin>>n, n) {\n\t\tcin >> m;\n\t\tfill(cost[0], cost[0]+100*100, INF);\n\t\trep(i, m) {\n\t\t\tint a, b, c;\n\t\t\tcin >> a >> ca >> b >> ca >> c;\n\t\t\tcost[a][b] = c/100-1;\n\t\t\tcost[b][a] = c/100-1;\n\t\t}\n\t\t\n\t\tcout << prim() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge\n{\n    int src, dist, weight;\n    Edge( int src, int dist, int weight ): \\\n        src ( src ), dist ( dist ), weight ( weight ) { }\n    bool operator< ( const Edge &rhs ) const\n    {\n        if ( weight != rhs.weight ) {\n            return weight > rhs.weight;\n        }\n        if ( src != rhs.src ) {\n            return src < rhs.src;\n        }\n        return dist < rhs.dist;\n    }\n};\n\nvector< vector< Edge > > g;\nint m, n;\nconst int MAX = 100, INF = 1e9;\n\nint main()\n{\n    while ( true ) {\n        cin >> n;\n        if ( n == 0 )  {\n            break;\n        }\n\n        // init\n        g.resize( n );\n\n        cin >> m;\n        int s;\n        for ( int i = 0; i < m; i++ ) {\n            int a, b, dist;\n            scanf ( \"%d,%d,%d\", &a, &b, &dist );\n            g[a].push_back( Edge( a, b, ( dist / 100 ) - 1 ) );\n            g[b].push_back( Edge( b, a, ( dist / 100 ) - 1 ) );\n            s = a;\n        }\n\n        vector< bool > visit( n, false );\n        priority_queue< Edge > que;\n        que.push( Edge( -1, s, 0 ) );\n\n        int ans = 0;\n        while ( !que.empty() ) {\n            Edge edge = que.top();\n            que.pop();\n\n            if ( visit[edge.dist] ) {\n                continue;\n            }\n            visit[edge.dist] = true;\n\n            ans += edge.weight;\n            for ( int i = 0; i < g[edge.dist].size(); i++ ) {\n                if ( !visit[g[edge.dist][i].dist] ) {\n                    que.push( g[edge.dist][i] );\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass UnionFind\n{\npublic:\n    UnionFind(int n) : parent(n), rank(n)\n    {\n        for(int i = 0; i < n; ++i) parent[i] = i;\n    }\n    \n    int root(int x)\n    {\n        if(parent[x] == x) return x;\n        else return parent[x] = root(parent[x]);\n    }\n    \n    bool same(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    \n    void unite(int x, int y)\n    {\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n        } else {\n            parent[y] = x;\n            if(rank[x] == rank[y]){\n                rank[x]++;\n            }\n        }\n    }\n\nprivate:\n    vector<int> parent, rank;\n};\n\nstruct Edge\n{\n    int u, v, cost;\n    bool operator<(const Edge& rhs) const\n    {\n        return cost < rhs.cost;\n    }\n};\n\nvector<Edge> E;\n\nint main()\n{\n    int n, m, a, b, c;\n    while(1){\n        E.clear();\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        scanf(\"%d\", &m);\n        for(int i = 0; i < m; ++i){\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            Edge e = {a, b, c / 100 - 1};\n            E.push_back(e);\n        }\n        \n        sort(E.begin(), E.end());\n        \n        UnionFind uf(n);\n        int ans = 0;\n        for(int i = 0; i < E.size(); ++i){\n            if(!uf.same(E[i].u, E[i].v)){\n                ans += E[i].cost;\n                uf.unite(E[i].u, E[i].v);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_V = 100000;\n\n//union-find tree defenition\n\nint par[MAX_V];\n\nvoid init(int n){\n    for(int x = 0; x < n;x++){\n        par[x] = -1;\n    }\n}\n\nint find(int x){\n    if(par[x] < 0) return x;\n    return par[x] = find(par[x]);\n}\n\nbool same(int a, int b){\n    return find(a) == find(b);\n}\n\nbool unite(int a, int b){\n    int xa = find(a), xb = find(b);\n    if(xa == xb) return false;\n    if(par[xa] < par[xb]){\n        par[xb] = xa;\n    }else{\n        if(par[xa] == par[xb]){\n            par[xb]--;\n        }\n        par[xa] = xb;\n    }\n    return true;\n}\n\n//END union-find tree definition\n\nstruct edge{\n    int from;\n    int to;\n    int cost;\n    edge(){}\n    ~edge(){}\n    edge(int a, int b, int c) : from(a), to(b), cost(c){}\n    bool operator < (const edge& r) const {\n        return cost > r.cost;\n    }\n};\n\nvector<edge> G;\nint V;\n\nvoid append_edge(int from, int to, int cost){\n    G.push_back(edge(from, to, cost));\n}\n\nvoid append_edge_u(int from, int to, int cost){\n    G.push_back(edge(from, to, cost));\n    G.push_back(edge(to, from, cost));\n}\n\nint kruskal(void){\n    init(V);\n    priority_queue<edge> que;\n    for(int i = 0; i < G.size(); i++){\n        que.push(G[i]);\n    }\n    int ret = 0;\n    while(true){\n        edge e = que.top(); que.pop();\n        if(!unite(e.from, e.to)) break;\n        ret += e.cost;\n    }\n    return ret;\n}\n\nint main(){\n    int m, a, b, c;\n    while(scanf(\"%d%d\", &V, &m) != EOF && V){\n        for(int x = 0; x < m; x++){\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            append_edge(a, b, c/100-1);\n        }\n        int res = kruskal();\n        printf(\"%d\\n\", res);\n        G.clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000000;\nconst int MAX_V = 101;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\n\nint prim() {\n  for ( int i = 0; i < V; ++i ) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true) {\n    int v = -1;\n    for ( int u = 0; u < V; u++ ) {\n      if ( !used[u] && ( v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n     \n    if ( v == -1 ) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for ( int u = 0; u < V; u++ ) {\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\n\nint main() {\n  int m;\n  while( cin >> V >> m,V ) {\n    for ( int i = 0; i < V; i++ ) {\n      for ( int j = 0; j < m; j++ ) {\n\tcost[i][j] = INF;\n      }\n    }\n    for ( int i = 0; i < m; i++ ) {\n      char ch; int a,b,c;\n      cin >> a >> ch >> b >> ch >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    int ans = prim();\n    cout << (ans/100) - (V-1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX_V 10100\n#define MAX_E 101000\nusing namespace std;\n\nstruct P\n{\n  int to,cost;\n  P(int to=inf,int cost=inf):to(to),cost(cost){}\n  bool operator < (const P &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint V,E;\nvector<P> G[MAX_V];\nbool used[MAX_V];\nint mincost[MAX_V];\n\nint prim()\n{\n  rep(i,V)used[i] = false,mincost[i] = inf;\n  mincost[0] = 0;\n\n  priority_queue<P> Q;\n  Q.push(P(0,0));\n\n  int ans = 0;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      int cur = p.to;\n\n      if(used[cur])continue;\n      used[cur] = true;\n\n      if(mincost[cur] < p.cost)continue;\n\n      ans += p.cost;\n\n      for(int i=0;i<G[cur].size();i++)\n\t{\n\t  int next = G[cur][i].to;\n\t  if(used[next])continue;\n\t  if(mincost[next] > G[cur][i].cost)\n\t    {\n\t      mincost[next] = G[cur][i].cost;\n\t      Q.push(P(next,mincost[next]));\n\t    }\n\t}\n    }\n  return ans;\n}\n\nint main()\n{\n  while(cin >> V,V)\n    {\n      cin >> E;\n      rep(i,E)\n\t{\n\t  int from,to,w;\n\t  //cin >> from >> to >> w;\n\t  scanf(\"%d,%d,%d\",&from,&to,&w);\n\t  G[from].push_back(P(to,w));\n\t  G[to].push_back(P(from,w));\n\t}\n      \n      cout << prim()/100 - (V-1) << endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nvector<int> par,rank;\nvector<pair<int,pair<int,int> > > edge;\nint find(int n){\n    if(par[n]==n) return n;\n    else return par[n]=find(par[n]);\n}\nvoid unite(int a,int b){\n    int pa=find(a),pb=find(b);\n    par[pa]=pb;\n//    if(pa==pb) return;\n//    if(rank[pa]>rank[pb]) swap(pa,pb);\n//    par[pa]=pb;\n//    if(rank[pa]==rank[pb]) rank[pb]++;\n}\nint main(){\n    int n,m;\n    scanf(\"%d\\n%d\\n\",&n,&m);\n    int a,b,d;\n    for(int i=0;i<m;i++){\n        scanf(\"%d,%d,%d\\n\",&a,&b,&d);\n        d=d/100-1;\n        edge.PB(MP(d,MP(a,b)));\n    }\n    par=vector<int>(n);\n    rank=vector<int>(n);\n    for(int i=0;i<n;i++){\n        par[i]=i;\n        rank[i]=0;\n    }\n    sort(ALL(edge));\n    int ret=0;\n    for(int i=0;i<edge.size();i++){\n        int a=edge[i].second.first,b=edge[i].second.second,d=edge[i].first;\n        if(find(a)!=find(b)){\n            ret+=d;\n            unite(a,b);\n        }\n    }\n    printf(\"%d\\n\",ret);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\n\nint cost[1000][1000];\nint mincost[1000];\nchar used[1000];\nint V;\n\n\n\nint prim(void)\n{\n    int i;\n    int res;\n    int u, v;\n    \n    for (i = 0; i < V; i++){\n        mincost[i] = 1000000000;\n        used[i] = 0;\n    }\n    \n    mincost[0] = 0;\n    res = 0;\n    \n    while (1){\n        v = -1;\n        for (u = 0; u < V; u++){\n            if (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n                v = u;\n            }\n        }\n        \n        if (v == -1){\n            break;\n        }\n        used[v] = 1;\n        res += mincost[v];\n        \n        for (u = 0; u < V; u++){\n            mincost[u] = min(mincost[u], cost[v][u]);\n        }\n    }\n    return (res);\n}\n\nint main(void)\n{\n    int num, from, to, dist;\n    int ans;\n    int i, j;\n    \n    while (1){\n        scanf(\"%d\", &V);\n        if (V == 0){\n            break;\n        }\n        scanf(\"%d\", &num);\n        \n        for (i = 0; i < V; i++){\n            for (j = 0; j < V; j++){\n                cost[i][j] = 1000000000;\n            }\n        }\n        \n        for (i = 0; i < num; i++){\n            scanf(\"%d,%d,%d\", &from, &to, &dist);\n            cost[from][to] = cost[to][from] = (dist / 100) - 1;\n        }\n        ans = prim();\n        printf(\"%d\\n\", ans);\n    }\n    return (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstdio>\n#define F first\n#define S second\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> cost[111];\nint prim(int n);\nmain(){\n  int n,m;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cin>>m;\n    int from,to,mm,nn;\n    nn=n;\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&from,&to,&mm);\n      cost[from].push_back(P(to,mm));\n      cost[to].push_back(P(from,mm));\n    }\n    cout<<prim(n)/100-(n-1)<<endl;\n  }\n}\nint prim(int n){\n  bool used[111];\n  int ans=0;\n  for(int i=0;i<111;i++){\n    used[i]=false;\n  }\n  priority_queue< P ,vector<P>,greater<P> > q;\n  q.push(P(0,0));\n  while(!q.empty()){\n    P p=q.top();\n    q.pop();\n    if(used[p.S]==true){\n      continue;\n    }\n    used[p.S]=true;\n    ans+=p.F;\n    for(int i=0;i<cost[p.S].size();i++){\n      q.push(P(cost[p.S][i].S,cost[p.S][i].F));\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <map>\n#define fr first\n#define sc second\n#define INF (2 << 28)\nusing namespace std;\n\ntypedef pair<int, int> iiP;\nstruct edge{\n  int to, cost; edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n}; \n\t\t\t      \nvector<vector<edge> > Graph;\n\nint n, m;\n\nvoid init(int n){\n  \n  Graph.resize(0), Graph.resize(n);\n\n}\n\nint Prim(){\n  \n  int ret = 0;\n  int used[n];\n  for(int i = 0; i < n; i++) used[i] = 0;\n  priority_queue<iiP, vector<iiP>, greater<iiP> > que;\n  que.push(iiP(0, 0));\n  while(!que.empty()){\n    iiP p = que.top(); que.pop();\n    if(used[p.sc]++) continue;\n    ret += p.fr;\n    for(int i = 0; i < Graph[p.sc].size(); i++){\n      que.push(iiP(Graph[p.sc][i].cost, Graph[p.sc][i].to));\n    }\n  }\n  return ret;\n\n}\n\nint main(){\n  \n  while(cin >> n, n){\n    cin >> m;\n    init(n);\n\n    for(int i = 0; i < m; i++){\n      int a, b, c; scanf(\"%d, %d, %d\", &a, &b, &c);\n      Graph[a].push_back(edge(b, c/100-1));\n    }\n\n    cout << Prim() << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint G[102][102];\nint NG[102][102];\nbool used[102];\nconst int INF=9999999;\nint main(){\n\tint n,m,ans=0;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tcin>>m;\n\tans=0;\n\tfor(int i=0;i<102;i++)for(int j=0;j<102;j++)G[i][j]=INF,used[i]=false,NG[i][j]=INF;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;\n\t\tchar x;\n\t\tcin>>a>>x>>b>>x>>c;\n\t\tif(a==b){cout<<\"x\";return 0;}\n\t\tG[a][b]=c;\n\t}\n\tint u,v,a,b;\n\tused[0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tv=-1;\n\t\tfor(int j=0;j<n;j++)if(!used[j])v=1;\n\t\tif(v==-1)break;\n\t\tint mi=INF;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\tif(mi>G[j][k]&&used[j]==1&&used[k]==0)mi=G[j][k],a=j,b=k;\n\t\t\t}\n\t\t}\n\t\tused[b]=1;\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\t//for(int i=0;i<n;i++)cout<<used[i]<<\" \";cout<<endl;\n\t\tNG[a][b]=G[a][b];\n\t\tans+=G[a][b]-100;\n\t}\n//for(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<G[i][j]<<\" \";cout<<endl;}\n//\tfor(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<NG[i][j]<<\" \";cout<<endl;}\n\t//for(int i=0;i<n;i++)for(int j=0;j<n;j++)ans+=NG[i][j];\n\tcout<<ans/100<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vp;\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tcin >> m;\n\t\t\n\t\tvector<vp> g(n);\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tg[a].push_back(pii(c / 100, b));\n\t\t\tg[b].push_back(pii(c / 100, a));\n\t\t}\n\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tvector<bool> used(n);\n\t\tint ans = 0;\n\t\t\n\t\tqu.push(pii(0, 0));\n\t\twhile (! qu.empty()) {\n\t\t\tint cost = qu.top().first;\n\t\t\tint pos = qu.top().second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tif (used[pos]) continue;\n\t\t\tused[pos] = true;\n\t\t\t\n\t\t\tans += cost;\n\t\t\t\n\t\t\tREP(i, g[pos].size()) {\n\t\t\t\tqu.push(pii(g[pos][i].first, g[pos][i].second));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans - (n-1) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stack>\n#include <math.h>\n\nusing namespace std;\n\n\nint main(){\n\n\tint n,m,table[100][100],checkTable[100],fixed[100],count,num,tmp_min,min_index,a,b,dist;\n\n\twhile(true){\n\t\tscanf(\"%d\",&n);\n\t\tif(n == 0)break;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tcheckTable[i] = 0;\n\t\t\tfor(int k = 0; k < n; k++)table[i][k] = 0;\n\t\t}\n\n\t\tscanf(\"%d\",&m);\n\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&dist);\n\t\t\ttable[a][b] = dist;\n\t\t\ttable[b][a] = dist;\n\t\t}\n\n\t\tcheckTable[0] = 1;\t//0?????????????°???¨?????¨??°??????????????????\n\t\tfixed[0] = 0;\n\t\tcount = 1,num = 0;\n\n\t\t//????°???¨?????¨??¢?????´?????????\n\t\twhile(count < n){\n\t\t\ttmp_min = 2147483647;\n\n\t\t\t//????°???¨?????¨??¨?????°?????????????????????????????????????±???????\n\t\t\tfor(int i = 0; i < count; i++){\n\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\tif(table[fixed[i]][k] > 0 && checkTable[k] == 0 && table[fixed[i]][k] < tmp_min){\n\t\t\t\t\t\ttmp_min = table[fixed[i]][k];\n\t\t\t\t\t\tmin_index = k;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tnum += (tmp_min/100)-1;\n\t\t\tcheckTable[min_index] = 1;\n\t\t\tfixed[count] = min_index;\n\t\t\tcount++;\n\t\t}\n\n\t\tprintf(\"%d\\n\",num);\n\n\t}\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <ctime>\n#include <cassert>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <complex>\n#include <stack>\n#include <queue>\n#include <numeric>\n#include <list>\n#include <iomanip>\n\nusing namespace std;\n\nint n,m;\n\nclass UnionFind{\n\tvector<int> par;\n\tvector<int> rank;\npublic:\n\tUnionFind(){ }\n\tUnionFind(int size){ reset(size); }\n\n\tvoid reset(int size){\n\t\tpar.resize(size);\n\t\trank.resize(size);\n\t\tfor(int i = 0; i < size; i++) par[i] = i,rank[i] = 0;\n\t}\n\n\tint find(int x){\n\t\tif(par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x),y = find(y);\n\t\tif(x == y) return ;\n\t\tif(rank[x] < rank[y]){\n\t\t\tpar[x] = y;\n\t\t}else{\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x,int y){return find(x) == find(y);}\n};\n\n\nstruct P{\n\tint c,f,t;\n\tbool operator<(const P& x)const{\n\t\treturn c < x.c;\n\t}\n};\n\nbool use[100];\n\nvoid solve()\n{\n\tcin>>m;\n\tvector<P> p(m);\n\tUnionFind uf(n);\n\tfor (int i = 0; i < n; i++){\n\t\tint x,y,z;\n\t\tscanf(\"%d,%d,%d\",&x,&y,&z);\n\t\tp[i].f = x; p[i].t = y; p[i].c = z;\n\t}\n\tsort(p.begin(),p.end());\n\tint cost = 0;\n\tfor (int i = 0; i < m; i++){\n\t\tif(!uf.same(p[i].f,p[i].t)){\n\t\t\tuf.unite(p[i].f,p[i].t);\n\t\t\tcost += p[i].c;\n\t\t}\n\t}\n\n\tcout << cost / 100 - (n-1) << endl;\n}\n\nint main(){\n\twhile(cin>>n,n){\n\t\tsolve();\n\t}\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\n#define MAX_V 100\n#define INF 9999\n\nint prim(void);\n\nint cost[MAX_V][MAX_V]; //cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint mincost[MAX_V]; //集合Xからの最小コスト\nbool used[MAX_V]; //頂点iがxに含まれているか\nint V; //頂点数\n\nusing namespace std;\n\nint main(){\n  int n,i,c,j,a,b;\n  \n  while(1){\n    scanf(\"%d\",&V);\n    if(V==0) break;\n    scanf(\"%d\",&n);\n    for(j=0;j<V;j++){\n      for(i=0;i<V;++i){\n\tcost[j][i]=INF;\n      }\n    }\n    for(i=0;i<n;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    printf(\"%d\\n\",prim());\n    \n  }\n  return 0;\n}\n\nint prim(){\n  \n  //初期化\n  for(int i=0;i<V;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(true){\n    int v=-1;\n    //xに属さない頂点のうちxからの辺のコストが最小になる頂点を探す\n    for(int u=0;u<V;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    \n    used[v]=true; //頂点vをxに追加\n    res+=mincost[v]; //辺のコストを比べる\n    \n    for(int u=0;u<V;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\nstatic const int INF = 999999;\nstruct SEdge\n{\n\tint From;\n\tint To;\n\tint Cost;\n};\nint V, E;\nvector<SEdge> Edge;\n\nvector<int> par;\nvector<int> rank;\n\nvoid init(int n)\n{\n\tpar.clear();\n\trank.clear();\n\tpar.resize(n);\n\trank.resize(n);\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\tif(par[x] == x)\n\t{\n\t\treturn(x);\n\t}\n\telse\n\t{\n\t\treturn(par[x] = find(par[x]));\n\t}\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t{\n\t\treturn;\n\t}\n\tif(rank[x] < rank[y])\n\t{\n\t\tpar[x] = y;\n\t}\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])\n\t\t{\n\t\t\t++rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn(find(x) == find(y));\n}\n\nbool comp(const SEdge& e1, const SEdge& e2)\n{\n\treturn(e1.Cost < e2.Cost);\n}\n\nint Kruskal()\n{\n\tinit(V);\n\tsort(Edge.begin(), Edge.end(), comp);\n\tint res = 0;\n\tfor(int i = 0; i < E; ++i)\n\t{\n\t\tSEdge e = Edge[i];\n\t\tif(!same(e.From, e.To))\n\t\t{\n\t\t\tunite(e.From, e.To);\n\t\t\tres += e.Cost;\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> V, V)\n\t{\n\t\tcin >> E;\n\t\tEdge.clear();\n\t\tEdge.resize(E);\n\t\tfor(int i = 0; i < E; ++i)\n\t\t{\n\t\t\tSEdge e;\n\t\t\tscanf(\"%d,%d,%d\", &e.From, &e.To, &e.Cost);\n\t\t\te.Cost = e.Cost / 100 - 1;\n\t\t\tEdge[i] = e;\n\t\t}\n\t\tcout << Kruskal() << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\n \nstruct Edge{\n    int a,b,d;\n    bool operator<(const Edge a)const{\n        return d<a.d;\n    }\n};\n \nint par[100],rank_[100];\n \nvoid init(int n){\n    for(int i=0;i<n;i++) par[i] = i, rank_[i] = 1;\n}\n \nint find(int x){\n    if(par[x]==x) return x;\n    return par[x] = find(par[x]);\n}\n \nbool unite(int _a,int _b){\n    int a = find(_a), b = find(_b);\n    if(a==b) return false;\n    if(rank_[a]>rank_[b]) par[b] = a;\n    else{\n        par[a] = b;\n        if(rank_[a]==rank_[b]) rank_[b]++;\n    }\n    return true;\n}\n \nint main(){\n    int N,M;\n    while(cin>>N,N){\n        init(N);\n        cin>>M;\n        Edge e[10000];\n        for(int i=0;i<M;i++) scanf(\"%d,%d,%d\",&e[i].a,&e[i].b,&e[i].d);\n        sort(e,e+M);\n        int ans = 0;\n        for(int i=0;i<M;i++){\n            if(unite(e[i].a,e[i].b)){\n                ans += e[i].d/100-1;\n            }\n        }\n        printf(\"%d\\n\",ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <list>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <string>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n\n#define rep(i,n)\tfor(int i = 0;i < n;i++)\n#define rep2(i,n)\tfor(int i = 1;i <= n;i++)\n#define each(i,x)\tfor(auto & i : x)\n\nusing namespace std;\n\nstruct edge\n{\n\tedge(int _s,int _t,int _cost)\n\t{\n\t\ts = _s;t = _t;cost = _cost;\n\t}\n\tint s;\n\tint t;\n\tint cost;\n};\n\nbool operator<(const edge & x,const edge & y)\n{\n\treturn x.cost < y.cost;\n}\n\nint uf_f(vector<int> & t,int i)\n{\n\tif(t[i] != i)\n\t\tt[i] = uf_f(t,t[i]);\n\treturn t[i];\n}\n\nvoid uf_u(vector<int> & t,int i,int j)\n{\n\tint p1 = uf_f(t,i);\n\tint p2 = uf_f(t,j);\n\tt[i] = t[p1] = t[p2];\n}\n\nint main()\n{\n\tint n,m;\n\tcin >> n;\n\twhile(n)\n\t{\n\t\tcin >> m;\n\t\tvector<edge> eary;\n\t\trep(i,m)\n\t\t{\n\t\t\tint a,b,d;\n\t\t\t//cin >> a >> b >> d;\n\t\t\tstring s;\n\t\t\tcin >> s;\n\t\t\trep(j,s.size())\n\t\t\t{\n\t\t\t\tif(s[j] == ',')\n\t\t\t\t\ts[j] = ' ';\n\t\t\t}\n\t\t\tstringstream ss;\n\t\t\tss << s;\n\t\t\tss >> a >> b >> d;\n\t\t\teary.push_back(edge(a,b,d));\n\t\t}\n\t\tsort(eary.begin(),eary.end());\n\t\tvector<int> uft(n);\n\t\trep(i,n)\n\t\t{\n\t\t\tuft[i] = i;\n\t\t}\n\t\tint j = 0;\n\t\tint sd = 0;\n\t\trep(i,eary.size())\n\t\t{\n\t\t\tint a = eary[i].s;\n\t\t\tint b = eary[i].t;\n\t\t\tint d = eary[i].cost;\n\t\t\tif(uf_f(uft,a) != uf_f(uft,b))\n\t\t\t{\n\t\t\t\tj++;\n\t\t\t\tuf_u(uft,a,b);\n\t\t\t\tsd += d/100-1;\n\t\t\t}\n\t\t\tif(j == n-1)\n\t\t\t\tbreak;\n\t\t}\n\t\tcout << sd << endl;\n\t\tcin >> n;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<(int)n;i++)\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rrep(i,n) for(int i = 1; i <= n; i++)\n#define drep(i,n) for(int i = n; i >= 0; i--)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nint chmax(int& a,int b){\n\tif(b > a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nint chmin(int& a,int b){\n\tif(b < a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nstruct uf{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\npublic:\n\tuf(int n){\n\t\tfor (int i=0;i<n;i++){\n\t\t\tpar.pb(i);\n\t\t}\n\t\trank.resize(n,0);\n\t}\n\n\tint find(int x){\n\t\tif (par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif ( x== y ) return;\n\n\t\tif (rank[x] < rank[y] ) {\n\t\t\tpar[x]=y;\n\t\t}else{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstruct edge{\n\tint u,v,cost;\n\tedge(int ui,int vi,int costi):u(ui),v(vi),cost(costi){}\n};\nbool comp(const edge& l,const edge& r){\n\treturn l.cost < r.cost;\n}\nint N,M;\nvector<edge> es;\nint main () {\n\twhile(cin >> N,N){\n\t\tcin >> M;\n\t\tes.clear();\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tchar t;\n\t\t\tcin >> a >> t >> b >>t >> c;\n\t\t\tes.pb(edge(a,b,c/100-1));\n\t\t\tes.pb(edge(b,a,c/100-1));\n\t\t}\n\t\tsort(all(es),comp);\n\t\tuf U(101);\n\t\tint ans=0;\n\t\trep(i,es.size()){\n\t\t\tedge &e = es [i];\n\t\t\tif(!U.same(e.u,e.v)){\n\t\t\t\tU.unite(e.u,e.v);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 999999;\nstruct SEdge\n{\n\tint To;\n\tint Cost;\n};\nint V, E;\nvector<int> mincost;\nvector< vector<SEdge> > G;\nbool used[128];\n\nint Prim()\n{\n\tfill(used, used + V, false);\n\tfill(mincost.begin(), mincost.end(), INF);\n\tmincost[0] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > PQue;\n\tPQue.push(P(0, 0));\n\tint res = 0;\n\twhile(!PQue.empty())\n\t{\n\t\tP p = PQue.top();\n\t\tPQue.pop();\n\t\tint v = p.second;\n\t\tif(mincost[v] < p.first || used[v])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tused[v] = true;\n\t\tres += p.first;\n\t\tfor(int i = 0; i < G[v].size(); ++i)\n\t\t{\n\t\t\tSEdge e = G[v][i];\n\t\t\tif(mincost[e.To] > e.Cost)\n\t\t\t{\n\t\t\t\tmincost[e.To] = e.Cost;\n\t\t\t\tPQue.push(P(mincost[e.To], e.To));\n\t\t\t}\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> V, V)\n\t{\n\t\tcin >> E;\n\t\tmincost.resize(V);\n\t\tG.resize(V);\n\t\tfor(int i = 0; i < E; ++i)\n\t\t{\n\t\t\tint From, To, Cost;\n\t\t\tscanf(\"%d,%d,%d\", &From, &To, &Cost);\n\t\t\tSEdge e1, e2;\n\t\t\te1.To = To;\n\t\t\te2.To = From;\n\t\t\te1.Cost = e2.Cost = Cost;\n\t\t\tG[From].push_back(e1);\n\t\t\tG[To].push_back(e2);\n\t\t}\n\t\tcout << Prim() / 100 - (V - 1)<< endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct Edge { int to, cost; };\nvector<vector<Edge> > G;\n\nconst int INF = 1e8;\nint n, m;\n\nvoid addEdge(int a, int b, int cost) {\n    G[a].push_back((Edge){ b, cost });\n    G[b].push_back((Edge){ a, cost });\n}\n\nint prim() {\n    vector<int> mincost(n, INF);\n    vector<bool> used(n, false);\n    mincost[0] = 0;\n    int res = 0;\n    while (1) {\n        int v = -1;\n        for (int i=0; i<n; ++i) {\n            if ( ! used[i] && (v == -1 || mincost[i] < mincost[v])) v = i;\n        }\n        if (v == -1) break;\n        used[v] = true;\n        res += mincost[v];\n\n        for (int i=0; i<(int)G[v].size(); ++i) {\n            Edge &e = G[v][i];\n            mincost[e.to] = min(mincost[e.to], e.cost);\n        }\n    }\n    return res;\n}\n\nint main() {\n    while (cin >> n >> m, n) {\n        G.resize(n);\n        fill(G.begin(), G.end(), vector<Edge>());\n        int a, b, c;\n        char dlm;\n        for (int i=0; i<m; ++i) {\n            cin >> a >> dlm >> b >> dlm >> c;\n            addEdge(a, b, c / 100 - 1);\n        }\n        cout << prim() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#include<vector>\n#define MAX 100000\n#define INF 1<<30\nusing namespace std;\nint V,E;\n\nstruct Pox\n{\n  int from,to,cost;\n  Pox(int from = -1,int to = -1,int cost = -1):from(from),to(to),cost(cost){}\n};\n\nbool cmp(const Pox& p1,const Pox& p2)\n{\n  return p1.cost < p2.cost;\n}\n\n\n\nint par[MAX+1];\n\nint find(int x)\n{\n  if(x == par[x])return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unit(int x,int y)\n{\n  x = find(x);\n  y = find(y);\n  if(x != y)\n    par[x] = y;\n}\n\nbool same(int x,int y)\n{\n  return find(x) == find(y);\n}\n\nint kruskal(vector<Pox>& G)\n{\n  sort(G.begin(),G.end(),cmp);\n  int res = 0;\n  for(int i=0;i<G.size();i++)\n    {\n      Pox pox = G[i];\n      if(!same(pox.from,pox.to))\n\t{\n\t  unit(pox.from,pox.to);\n\t  res += pox.cost;\n\t}\n    }\n  return res;\n}\n \nint main(){\n   \n   \n  while(cin >> V && V){  \n    cin >> E;\n    vector<Pox> G;\n    for(int i=0;i<E;i++){\n      par[i] = i;\n      int from,to,Cost;\n      scanf(\"%d,%d,%d\",&from,&to,&Cost);\n      G.push_back(Pox(from,to,Cost));\n    }\n  \n    cout <<  kruskal(G)/100 - (V-1) << endl;\n \n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <queue>\nusing namespace std;\n\nstruct edge { int to, cost; };\nvector<vector<edge>> G;\nvector<bool> used;\n\nint mst() {\n    int ret = 0;\n    priority_queue<pair<int,int>> q;\n    q.push(make_pair(0, 0));\n    while ( ! q.empty()) {\n        int dist = -q.top().first;\n        int v = q.top().second;\n        q.pop();\n        if (used[v]) continue;\n        used[v] = true;\n        ret += dist;\n        for (int i=0; i<(int)G[v].size(); ++i) {\n            if ( ! used[G[v][i].to]) {\n                q.push(make_pair(-G[v][i].cost, G[v][i].to));\n            }\n        }\n    }\n    return ret;\n}\n\nint main() {\n    int n, m;\n    while (cin >> n, n) {\n        G.clear(); G.resize(n);\n        used.clear(); used.resize(n);\n        cin >> m;\n        int a, b, d;\n        char c;\n        for (int i=0; i<m; ++i) {\n            cin >> a >> c >> b >> c >> d;\n            G[a].push_back((edge){b, d / 100 - 1});\n            G[b].push_back((edge){a, d / 100 - 1});\n        }\n        cout << mst() << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <climits>\n#include <algorithm>\nusing namespace std;\n\nint s[100][100];\n\nint main() {\n  int n, m, x, y, z, ans, mind, mini;\n  int d[100], a[100];\n  bool b[100];\n\n  while (1) {\n    scanf(\"%d\", &n);\n    if (!n) break;\n    scanf(\"%d\", &m);\n    memset(s, 0, sizeof(int)*n*100);\n    for (int i=0; i<m; i++) {\n      scanf(\"%d,%d,%d\", &x, &y, &z);\n      s[x][y] = s[y][x] = z/100-1;\n    }\n\n    for (int i=0; i<n; i++) d[i] = INT_MAX;\n    memset(b, 0, sizeof(bool)*n);\n    d[0] = 0;\n    a[0] = 0;\n    ans = 0;\n    while (1) {\n      mind = INT_MAX;\n      for (int i=0; i<n; i++) {\n        if (!b[i] && d[i]<mind) {\n          mind = d[i];\n          mini = i;\n        }\n      }\n      if (mind == INT_MAX) break;\n      ans += s[a[mini]][mini];\n      b[mini] = true;\n      for (int i=0; i<n; i++) {\n        if (!b[i] && s[mini][i]) {\n          d[i] = min(d[i], d[mini]+s[mini][i]);\n          a[i] = mini;\n        }\n      }\n    }\n    printf(\"%d\\n\", ans);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<queue>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\nclass street{\npublic:\n  int a,b,d;\n  void set(int x,int y,int z){a = x;b = y;d = z;};\n  bool operator<(const street x)const{return d>x.d;}\n};\n\nint uf[100],rank[100];\n\nint par(int x){\n  if(uf[x] == x)return x;\n  return uf[x] = par(uf[x]);\n}\n\nvoid unit(int x,int y){\n  x = par(x);\n  y = par(y);\n  if(x==y)return;\n  if(rank[x] < rank[y]){\n    uf[x] = y;\n  }else{\n    uf[y] = x;\n    if(rank[x]==rank[y])rank[x]++;\n  }\n}\n\nint main(){\n  int n,m;\n\n  while(scanf(\"%d\",&n) && n){\n    scanf(\"%d\",&m);\n    priority_queue<street> q;\n\n    for(int i=0;i<m;i++){\n      int x,y,z;\n      scanf(\"%d%*c%d%*c%d \",&x,&y,&z);\n      q.push((street){x,y,z/100-1});\n    }\n    \n    for(int i=0;i<n;i++){\n      uf[i] = i;\n      rank[i] = 0;\n    }\n    int ans = 0;\n\n    while(q.size()){\n      street s = q.top();q.pop();\n      if(par(s.a) != par(s.b)){\n\tans += s.d;\n\tunit(s.a,s.b);\n      }\n    }\n    printf(\"%d\\n\",ans);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstatic const int INF = 99999999;\nint d[101][101];\n\nvoid solve()\n{\n\tint n;\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i = 0; i < 101; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 101; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, dist;\n\t\t\tchar c;\n\t\t\tcin >> a >> c >> b >> c >> dist;\n\t\t\td[a][b] = dist;\n\t\t\td[b][a] = dist;\n\t\t}\n\t\tfor(int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_sum_dist = INF;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif(d[i][j] != INF)\n\t\t\t\t{\n\t\t\t\t\tsum += d[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min_sum_dist > sum)\n\t\t\t{\n\t\t\t\tmin_sum_dist = sum;\n\t\t\t}\n\t\t}\n\t\tcout << min_sum_dist / 100 - 3 << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#define FOR(i,a,b) for(int i=(a);i<(int)(b);i++)\n#define rep(i,n) FOR(i,0,n)\n#define dbg(x) cout<<#x<<\": \"<<(x)<<\"\\n\"\n\nusing namespace std;\n\nconst int MAX_N = 114514;\nint n, m;\n\nstruct edge {\n    int u, v, cost;\n    edge() {}\n    edge(int a, int b, int c) {\n        u=a; v=b; cost=c;\n    }\n};\n\nvector<edge> es;\n\nbool comp(const edge& e1, const edge& e2) {\n    return e1.cost < e2.cost;\n}\n\n\n//\n// Union-Find\n//\nint par[MAX_N], _rank[MAX_N];\n\nvoid init(int n) {\n    for (int i = 0; i < n; i++) {\n        par[i] = i; _rank[i] = 0;\n    }\n}\n\nint find(int x) {\n    if(par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y) {\n    x = find(x); y = find(y);\n    if(x == y) return ;\n\n    if(_rank[x] < _rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if(_rank[x] == _rank[y]) _rank[x]++;\n    }\n}\n\nbool same(int x, int y) {\n    return find(x) == find(y);\n}\n\n\nint kruskal() {\n    sort(es.begin(), es.end(), comp);\n    init(n);\n    int res = 0;\n    rep(i,m) {\n        edge e = es[i];\n        if(!same(e.u, e.v)) {\n            unite(e.u, e.v);\n            res += e.cost;\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    es.clear();\n    cin>>m;\n    rep(i,m) {\n        int a,b,d;\n        scanf(\"%d,%d,%d\",&a,&b,&d);\n        es.push_back(edge(a, b, d/100 - 1));\n    }\n    int res = kruskal();\n    cout << res << endl;\n}\n\nint main() {\n    while(cin>>n, n) solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(i=0;i<n;i++)\n\nstruct branch{\n\tint n1, n2, w;\n};\nbool f(branch i, branch j){\n\treturn (i.w > j.w);\n}\nint main(){\n\twhile (1){\n\t\tint n,i;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int>T(n);\n//\t\tREP(i,n)T[i]=i;\n\n\t\tbranch tmp;\n\t\tint m; cin>>m;\n\t\tvector<branch>S(m);\n\t\tREP(i,m){\n\t\t\tcin>>tmp.n1>>c>>tmp.n2>>c>>tmp.w;\n\t\t\tS[i]=tmp;\n\t\t\tT[tmp.n1]=tmp.n1;\n\t\t\tT[tmp.n2]=tmp.n2;\n\t\t}\n\n\t\tsort(S.begin(), S.end(),f);\n\n\t\tint a = 0;\n\t\twhile(S.size()){\n\t\t\ttmp=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[tmp.n1], c=T[tmp.n2];\n\t\t\tif (b!=c){\n\t\t\t\tfor(i=b+1;i<n;i++)\n\t\t\t\t\tif (T[i]==c)T[i]=b;\n\t\t\t\ta += tmp.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nconst int INF = 1e9;\nconst int MAX_V = 100;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\nint prim() {\n    fill(mincost, mincost + V, INF);\n    fill(used, used + V, false);\n    mincost[0] = 0;\n    int res = 0;\n\n    while (true) {\n        int v = -1;\n        for (int u = 0; u < V; u++)\n            if (!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n        \n        if (v == -1) break;\n        used[v] = true;\n        res += mincost[v];\n\n        for (int u = 0; u < V; u++)\n            mincost[u] = min(mincost[u], cost[v][u]);\n    }\n\n    return res;\n}\n\nint main() {\n    while (scanf(\"%d\", &V), V) {\n        int m;\n        scanf(\"%d\", &m);\n                \n        for (int i = 0; i < V; i++)\n            fill(cost[i], cost[i] + V, INF);\n\n        for (int i = 0; i < m; i++) {\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            cost[a][b] = cost[b][a] = d;\n        }\n        \n        int ans = prim() / 100 - (V - 1);\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<vector>\n#include<list>\n#include<algorithm>\n#include<iostream>\n#include<string>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<cmath>\nusing namespace std;\nint f(int a[][100],int b[],int c[],int n){\n  int i,j;\n  int mn=-1;\n  for(i=0;i<n;i++){\n    if(c[i]){\n      for(j=0;j<n;j++){\n\tif(a[i][j]!=-1&&c[j]==0&&(b[j]==-1||b[j]>a[i][j]))\n\t  b[j]=a[i][j];\n      }\n    }\n  }\n  for(i=0;i<n;i++){\n    if(b[i]!=-1&&c[i]==0&&(mn==-1||b[mn]>b[i]))\n      mn=i;\n  }\n  c[mn]=1;\n  return b[mn];\n}\nint main(){\n  int h,i,j;\n  int a[100][100],b[100],c[100],m,n;\n  int sm;\n  while(cin>>n&&n){\n    cin>>m;\n    memset(a,-1,sizeof(a));\n    memset(c,0,sizeof(c));\n    for(i=0;i<m;i++){\n      int p,q,r;\n      scanf(\"%d,%d,%d\",&p,&q,&r);\n      a[p][q]=r/100-1;\n      a[q][p]=a[p][q];\n      c[p]++;\n      c[q]++;\n    }\n    sm=0;\n    do{\n      h=0;\n      for(i=0;i<n;i++){\n\tif(c[i]==1){\n\t  for(j=0;a[i][j]==-1;j++);\n\t  sm+=a[i][j];\n\t  a[i][j]=-1;\n\t  a[j][i]=-1;\n\t  c[i]--;\n\t  c[j]--;\n\t  h=1;\n\t}\n      }\n    }while(h);\n    memset(b,-1,sizeof(b));\n    memset(c,0,sizeof(c));\n    b[0]=0;\n    c[0]=1;\n    for(i=1;i<n;i++)\n      sm+=f(a,b,c,n);\n    cout<<sm<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<vector>\n#include<algorithm>\n#include<map>\n#include<cstdio>\n#define F first\n#define S second\n#define INF 1<<30\nusing namespace std;\ntypedef pair<int,int> P;\nint cost[120][120]={0};\nint prim(int n);\nmain(){\n  int n,m;\n  while(1){\n    cin>>n;\n    if(n==0)break;\n    cin>>m;\n    int from,to,mm,nn;\n    nn=n;\n    for(int i=0;i<120;i++){\n      for(int j=0;j<120;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&from,&to,&mm);\n      cost[from][to]=mm;\n      cost[to][from]=mm;\n    }\n    cout<<prim(n)/100-(n-1)<<endl;\n  }\n}\nint prim(int n){\n  int min_cost[120];\n  bool used[120];\n  //すでにいけるかどうかを表す\n  for(int i=0;i<n;i++){\n    min_cost[i]=INF;\n    used[i]=false;\n  }\n  min_cost[0]=0;\n  int ans=0;\n  while(1){\n    int v=-1;\n    for(int i=0;i<n;i++){\n      if(used[i]==false/*まだ行くことができない*/&&(v==-1/*まだ他のルートを見つけていない*/||min_cost[i]<min_cost[v]/**/)){\n\tv=i;\n      }\n    }\n    if(v==-1)break;//もうすべてのばしょにいける\n    used[v]=true;//この場所にいく道を造った\n    ans+=min_cost[v];//辺のコストを加える\n    for(int i=0;i<n;i++){\n      min_cost[i]=min(min_cost[i],cost[v][i]);\n    }\n  }\n  return ans;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\n#define MAX_V 100\n#define INF 99999\n\nint prim(void);\n\nint cost[MAX_V][MAX_V]; //cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint mincost[MAX_V]; //集合Xからの最小コスト\nbool used[MAX_V]; //頂点iがxに含まれているか\nint m; //頂点数\n\nusing namespace std;\n\nint main(){\n  int n,i,c,j,a,b;\n  \n  while(1){\n    scanf(\"%d\",&n); if(n==0) break;\n scanf(\"%d\",&m);\n    for(j=0;j<m;j++){\n      for(i=0;i<m;++i){\n\tcost[j][i]=INF;\n      }\n    }\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d\",&a,&b); scanf(\",%d\",&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    printf(\"%d\\n\",prim());\n    \n  }\n  return 0;\n}\n\nint prim(){\n  \n  //初期化\n  for(int i=0;i<m;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(true){\n    int v=-1;\n    //xに属さない頂点のうちxからの辺のコストが最小になる頂点を探す\n    for(int u=0;u<m;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    \n    used[v]=true; //頂点vをxに追加\n    res+=mincost[v]; //辺のコストを比べる\n    \n    for(int u=0;u<m;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INFTY 1000000000\n\nint n,M[101][101],color[101],d[101],p[101];\n\nvoid prim() {\n  for ( int i = 0; i < 101; i++ ) {\n    color[i] = WHITE;\n    d[i] = INFTY;\n    p[i] = -1;\n  }\n  \n  d[0] = 0;\n  int u;\n  while(1){\n    u = -1;\n    int mincost = INFTY;\n\n    for ( int i = 0; i < n; i++ ) {\n      if ( color[i] != BLACK && d[i] < mincost ) {\n\tmincost = d[i];\n\tu = i;\n      }\n    }\n\n    if ( u == -1 ) break;\n\n    color[u] = BLACK;\n    \n    for ( int v = 0; v < n; v++ ) {\n      if ( color[v] != BLACK && M[u][v] != INFTY ) {\n\tif ( M[u][v] < d[v] ) {\n\t  d[v] = M[u][v];\n\t  p[v] = u;\n\t  color[v] = GRAY;\n\t}\n      }\n    }\n  }\n\n  int ans = 0;\n\n  for ( int i = 0; i < n; i++ ) {\n    if ( p[i] != -1 ) {\n      int tmp = d[i]/100-1;\n      ans += tmp;\n    }\n  }\n  cout << ans << endl;\n}\n\nint main() {\n\n  while( cin >> n,n) {\n    for ( int i = 0; i  < 101; i++ ) {\n      for ( int j = 0; j < 101; j++ ) {\n\tM[i][j] = INFTY;\n      }\n    }\n    int m; cin >> m;\n    char ch;\n    for ( int i = 0; i < m; i++ ) {\n      int a,b,distance;\n      cin >> a >> ch >> b >> ch >> distance;\n      M[a][b] = distance;\n      M[b][a] = distance;\n    }\n  \n    prim();\n\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdlib>\n#include <cstdio>\n#include <algorithm>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct Edge\n{\n    int src, dist, weight;\n    Edge( int src, int dist, int weight ): \\\n        src ( src ), dist ( dist ), weight ( weight ) { }\n    bool operator< ( const Edge &rhs ) const\n    {\n        if ( weight != rhs.weight ) {\n            return weight > rhs.weight;\n        }\n        if ( src != rhs.src ) {\n            return src < rhs.src;\n        }\n        return dist < rhs.dist;\n    }\n};\n\nvector< vector< Edge > > g;\nint m, n;\nconst int MAX = 100, INF = 1e9;\n\nvoid solve()\n{\n}\n\nint main()\n{\n    while ( true ) {\n        cin >> n;\n        if ( n == 0 )  {\n            break;\n        }\n\n        // init\n        g.resize( n );\n\n        cin >> m;\n        for ( int i = 0; i < m; i++ ) {\n            int a, b, dist;\n            scanf ( \"%d,%d,%d\", &a, &b, &dist );\n            g[a].push_back( Edge( a, b, ( dist / 100 ) - 1 ) );\n            g[b].push_back( Edge( b, a, ( dist / 100 ) - 1 ) );\n        }\n\n        vector< bool > visit( n, false );\n        priority_queue< Edge > que;\n        que.push( Edge( -1, 0, 0 ) );\n\n        int ans = 0;\n        while ( !que.empty() ) {\n            Edge edge = que.top();\n            que.pop();\n\n            if ( visit[edge.dist] ) {\n                continue;\n            }\n            visit[edge.dist] = true;\n\n            ans += edge.weight;\n            for ( int i = 0; i < g[edge.dist].size(); i++ ) {\n                if ( !visit[g[edge.dist][i].dist] ) {\n                    que.push( g[edge.dist][i] );\n                }\n            }\n        }\n        cout << ans << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define INF 100000\nusing namespace std;\n\nint main(){\n\tint n,m,a,b,d;\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>m;\n\t\tlong long dp[n][n];\n\t\trep(i,n)rep(j,n)dp[i][j]=(i==j?0:INF);\n\t\trep(i,m){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tdp[a][b]=dp[b][a]=d/100-1;\n\t\t}\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dp[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long num=INF;\n\t\trep(i,n){\n\t\t\tlong long sum=0;\n\t\t\trep(j,n)sum+=dp[i][j];\n\t\t\tif(sum<num)num=sum;\n\t\t}\n\t\tcout<<num<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef vector<int> vi;\n\nclass UF{\n  vi p,r;\n\npublic:\n  UF(int n):p(n,-1),r(n,0){ }\n\n  int find(int x){ return (p[x]<0)?x:(p[x] = find(p[x])); }\n\n  void unite(int x,int y){\n    x = find(x); y = find(y);\n    if(x==y)return;\n\n    if(r[x] < r[y])p[x] = y;\n    else p[y] = x;\n    if(r[x] == r[y])r[x]++;\n  }\n\n  bool same(int x,int y){return find(x)==find(y);}\n};\n\nconst int INF= 1e9;\n\nstruct edge{\n  int from, to, cost;\n  edge(int x,int y, int z):from(x),to(y),cost(z){}\n  bool operator<(const edge &x)const{ return cost<x.cost; }\n};\n\nclass Kruskal{\n  int n;\n  vector< vector<edge> > g;\npublic:\n  Kruskal(int a=0):n(a){ g.resize(n); }\n\n  void AddEdge(int a, int b, int cost){\n    g[a].push_back(edge(a,b,cost));\n    g[b].push_back(edge(b,a,cost));\n  }\n\n  int MinSpanningTree(){\n    UF connect(n);\n    vector<edge> edges;\n    for(int v=0;v<n;v++){\n      for(edge e.: g[v])edges.push_back(e);\n    }\n    sort(edges.begin(), edges.end());\n    \n    int res = 0;\n    for(edge e : edges){\n      if(!connect.same(e.from,e.to)){\n\tres += e.cost;\n\tconnect.unite(e.from,e.to);\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n,m;\n  while(scanf(\"%d\",&n),n){\n    Kruskal p(n);\n    cin >> m;\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      p.AddEdge(a,b,c/100-1);\n    }\n    cout << p.MinSpanningTree() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\n#define REP(i,num) for(int i=0;i<(num);++i)\n#define ALL(c) c.begin(),c.end()\n#define LOOP(i) while(i--)\n#define PRINTALL(c) for(auto& x:c){cout<<x<<' ';}cout<<endl;\n#define PAIRCOMP(c,comp) [](const pair<ll,ll>& lhs,const pair<ll,ll>& rhs){return lhs.c comp rhs.c;}\n\nusing namespace std;\nusing ll = long long;\n\nconstexpr ll atcoder_mod = 1e9+7;\n\ntemplate<typename T=int>\nT in(){T x; cin >> x; return (x);}\ntemplate<typename T=int,typename C=vector<T>>\nC vecin(int N){C x(N);REP(i,N){x[i]=in<T>();}return move(x);}\n\nvoid vout(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid vout(Head&& h,Tail&&... t){cout << ' ' << h;vout(forward<Tail>(t)...);}\nvoid out(){cout << endl;}\ntemplate<typename Head,typename... Tail>\nvoid out(Head&& h,Tail&&... t){cout << h;vout(forward<Tail>(t)...);}\n\nclass UnionFind{\n\tvector<ll> rank;\n\tvector<ll> diff_weight;\n\tvector<ll> num;\npublic:\n\tvector<ll> par;\n\n\tUnionFind(ll N):par(N),num(N),rank(N),diff_weight(N){\n\t\tfor(ll i=0;i<N;i++){\n\t\t\tpar[i]=i;\n\t\t\tnum[i]=1;\n\t\t\trank[i]=0;\n\t\t\tdiff_weight[i]=0;\n\t\t}\n\t}\n\n\tll root(ll x){\n\t\tif(par[x]==x){\n\t\t\treturn x;\n\t\t}\n\t\tll r = root(par[x]);\n\t\tdiff_weight[x]+=diff_weight[par[x]];\n\t\treturn par[x]=r;\n\t}\n\n\tvoid unite(ll x,ll y){\n\t\tll rx = root(x);\n\t\tll ry = root(y);\n\t\tif (rx == ry) return;\n\t\tif(rank[rx]<rank[ry]) swap(rx,ry);\n\t\tif(rank[rx]==rank[ry]) ++rank[rx];\n\t\tpar[ry] = rx;\n\t\tnum[rx] += num[ry];\n\t}\n\n\tvoid relate(ll x,ll y,ll w){\n\t\tw+=weight(x),w-=weight(y);\n\t\tll rx = root(x);\n\t\tll ry = root(y);\n\t\tif (rx == ry) return;\n\t\tif(rank[rx]<rank[ry]){\n\t\t\tswap(rx,ry);\n\t\t\tw = -w;\n\t\t}\n\t\tif(rank[rx]==rank[ry]) ++rank[rx];\n\t\tpar[ry] = rx;\n\t\tdiff_weight[ry] = w;\n\t\tnum[rx] += num[ry];\n\t}\n\n\tbool same(ll x,ll y){\n\t\tll rx = root(x);\n\t\tll ry = root(y);\n\t\treturn rx == ry;\n\t}\n\n\tll getsize(ll x){\n\t\treturn num[root(x)];\n\t}\n\n\tll weight(ll x){\n\t\troot(x);\n\t\treturn diff_weight[x];\n\t}\n\n\tll diff(ll x,ll y){\n\t\treturn weight(y)-weight(x);\n\t}\n};\n\nclass Data{\npublic:\n\tint u,v,d;\n};\n\nint main(){\n\t//cin.tie(0);\n\t//ios::sync_with_stdio(false);\n\tcout<<fixed<<setprecision(10);\n\n\twhile(true){\n\t\tint N=in();\n\t\tif(!N) break;\n\t\tint M=in();\n\t\tUnionFind uf(N);\n\t\tvector<Data> D(M);\n\t\tREP(i,M){\n\t\t\tint u,v,d;\n\t\t\tscanf(\"%d,%d,%d\",&u,&v,&d);\n\t\t\tD[i].u=u,D[i].v=v,D[i].d=(d-100)/100;\n\t\t}\n\t\tsort(ALL(D),[](Data& l,Data& r){return l.d<r.d;});\n\t\tint sum = 0;\n\t\tREP(i,M){\n\t\t\tif(!uf.same(D[i].u,D[i].v)){\n\t\t\t\tuf.unite(D[i].u,D[i].v);\n\t\t\t\tsum += D[i].d;\n\t\t\t}\n\t\t}\n\t\tout(sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n#include <vector>\n#include <cassert>\n#include <algorithm>\n\nusing namespace std;\n\nclass Prim {\n#define MAX_V 101\n\nprivate:\n  const int INF = 1e9 + 10;\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n  int mincost[MAX_V];\n  bool used[MAX_V];\n\npublic:\n\n  Prim(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  int Solve() {\n    for (int i = 0; i < V; i++) {\n      mincost[i] = INF;\n      used[i]    = false;\n    }\n\n    mincost[0] = 0;\n    int res = 0;\n\n    while (true) {\n      int v = -1;\n      for (int u = 0; u < V; u++) {\n        if (!used[u] && (v == -1 || mincost[u] < mincost[v])) {\n          v = u;\n        }\n      }\n      if (v == -1) {\n        break;\n      }\n      used[v] = true;\n      res += mincost[v];\n\n      for (auto &e : G[v]) {\n        mincost[e.to] = min(mincost[e.to], e.cost);\n      }\n    }\n\n    return res;\n  }\n};\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    cin >> m;\n    Prim prim(n);\n    for (int i = 0; i < m; i++) {\n      int a, b, d;\n      char s;\n      cin >> a >> s >> b >> s >> d;\n      prim.AddEdge(a, b, d);\n      prim.AddEdge(b, a, d);\n    }\n    cout << prim.Solve() / 100 - (n - 1) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define int long long\n#define for0(i, n) for(int i = 0; i < (n); i++)\n#define for1(i, n) for(int i = 1; i <= (n);i++)\n#define mp make_pair\n#define all(x) x.begin(),x.end()\nusing namespace std;\nint pt[1234], n, m, a, b, d;\nvector<pair<int, pair<int, int>>>v;\nvoid f() {\n\tfor0(i, n)pt[i] = i;\n\treturn;\n}\nint root(int i) {\n\tif (pt[i] == i)return i;\n\telse return pt[i] = root(pt[i]);\n}\nvoid unite(int a, int b) {\n\tpt[root(b)] = root(a);\n\troot(b);\n\treturn;\n}\nvoid input() {\n\tstring s; cin >> s;\n\tint p = 0; bool b00l = 0;\n\tfor (char ch : s) {\n\t\tif (ch == ',') {\n\t\t\tif (b00l)b = p; else a = p;\n\t\t\tp = 0; b00l = 1;\n\t\t}\n\t\telse { p *= 10; p += ch - '0'; }\n\t}\n\td = p;\n\tv.push_back(mp(d / 100 - 1, mp(a, b)));\n}\nsigned main() {\n\twhile (cin >> n, n) {\n\t\tint ans = 0;\n\t\tcin >> m;\n\t\tv.clear(); f();\n\t\tfor0(i, m)input(); sort(all(v));\n\t\tfor (pair<int, pair<int, int>>p : v) {\n\t\t\ta = p.second.first;\n\t\t\tb = p.second.second;\n\t\t\tif (root(a) != root(b)) {\n\t\t\t\tunite(a, b);\n\t\t\t\tans += p.first;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <utility>\n#include <queue>\n#define INF 100000000\nusing namespace std;\ntypedef pair<int,int> P;\nstruct edge {\n  int to,cost;\n};\n\nint n,m;\nvector<edge> G[100];\nint mincost[100];\nbool used[100];\n\nint prim() {\n  for(int i=0;i<n;i++) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(true) {\n    int v = -1;\n    for(int i=0;i<n;i++) {\n      if(!used[i] && (v == -1 || mincost[i] < mincost[v] ) ) v = i;\n    }\n\n    if(v == -1) break;\n    res += mincost[v];\n    used[v] = true;\n\n    for(int i=0;i<G[v].size();i++) {\n      edge e = G[v][i];\n      if(mincost[e.to] > e.cost) {\n\tmincost[e.to] = e.cost;\n      }\n    }\n  }\n  return (res/100) - n + 1;\n}\n\nint main() {\n  while(cin >> n) {\n    if(n==0) break;\n    cin >> m;\n    for(int i=0;i<m;i++) {\n      int f,t,c;\n      scanf(\"%d,%d,%d\",&f,&t,&c);\n      //      cout << f << \" \" << t << \" \" << c << endl;\n      edge temp;\n      temp.to = t;\n      temp.cost = c;\n      G[f].push_back(temp);\n      temp.to = f;\n      G[t].push_back(temp);\n    }\n    cout << prim() << endl;\n    for(int i=0;i<n;i++) {\n      G[i].clear();\n    }\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\n#include <limits.h>\nusing namespace std;\n\nstruct place{\n\tint id;\n\tint weight;\n};\n\nconst int unseen = -INT_MAX;\n\nint update(vector<place>& vi, int k, int w){\n\tvector<place>::iterator iter = vi.begin();\n\twhile(iter != vi.end() && (*iter).id != k) iter++;\n\tif(iter == vi.end()){\n\t\tplace p;\n\t\tp.id = k;\n\t\tp.weight = w;\n\t\tvi.push_back(p);\n\t\treturn 1;\n\t}else{\n\t\tif((*iter).weight == w){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tif(w < (*iter).weight){\n\t\t\t\t(*iter).weight = w;\n\t\t\t\treturn 1;\n\t\t\t}else return 0;\n\t\t}\n\t}\n}\n\nvoid swap(vector<place>& vp, int i, int j){\n\tplace p;\n\tp.id = vp[i].id; p.weight = vp[i].weight;\n\tvp[i].id = vp[j].id; vp[i].weight = vp[j].weight;\n\tvp[j].id = p.id; vp[j].weight = p.weight;\n}\n\nplace remove(vector<place>& vp){\n\tint min = 0;\n\tfor(int i = 0; i < vp.size(); i++){\n\t\tif(vp[i].weight < vp[min].weight)\n\t\t\tmin = i;\n\t}\n\tswap(vp, min, vp.size() - 1);\n\tplace p = vp[vp.size() - 1];\n\tvp.pop_back();\n\treturn p;\n}\n\nint visit(int route[100][100], int k, int n){\n\tint weight = 0;\n\tint val [100];\n\tfor(int i = 0; i < 100; i++) val[i] = unseen;\n\tvector<place> vp;\n\tupdate(vp, k, -unseen);\n\twhile(!vp.empty()){\n\t\tplace p = remove(vp);\n\t\tk = p.id;\n\t\tval[k] =-val[k];\n\t\tif(val[k] == -unseen) val[k] = 0;\n\t\tweight += val[k];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(route[k][i] != 0)\n\t\t\t\tif(val[i] < 0)\n\t\t\t\t\tif(update(vp, i, route[k][i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tval[i] = -route[k][i];\n\t\t\t\t\t}\n\t\t}\n\t}\n\treturn weight;\n}\n\nint main(){\n\tconst int nmax = 100;\n\tint n;\n\tint m;\n\tint route[nmax][nmax];\n\tint a, b;\n\tint dis;\n\tchar c;\n\twhile(cin >> n){\n\t\tfor(int i = 0;i < nmax; i++){\n\t\t\tfor(int j = 0; j < nmax; j++){\n\t\t\t\troute[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tif(n == 0) break;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> a >> c >> b >> c >> dis;\n\t\t\tdis = dis / 100 - 1;\n\t\t\troute[a][b] = dis;\n\t\t\troute[b][a] = dis;\n\t\t}\n\t\tcout << visit(route, 0, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Road {\n    int a, b;\n    int dist;\n\n    bool operator < (const Road &other) const {\n        return dist < other.dist;\n    }\n};\n\nint getroot(int i, vector<int> &roots) {\n    if(roots[i] == i) return i;\n    return roots[i] = getroot(roots[i], roots);\n}\n\nvoid unite(int i, int j, vector<int> &roots) {\n    roots[i] = getroot(j, roots);\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N >> M;\n        if(!N) break;\n\n        vector<Road> roads(M);\n        char comma;\n        for(int i = 0; i < M; ++i) \n            cin >> roads[i].a >> comma >> roads[i].b >> comma >> roads[i].dist;\n        sort(roads.begin(), roads.end());\n\n        int ans = 0;\n        vector<int> roots(N);\n        for(int i = 0; i < N; ++i) roots[i] = i;\n        for(int i = 0; i < M; ++i) {\n            const Road &r = roads[i];\n            if(getroot(r.a, roots) == getroot(r.b, roots)) continue;\n            unite(r.a, r.b, roots);\n            ans += r.dist/100 - 1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nclass Edge{\npublic:\n\tint edge_dist;\n\tint cost;\n\tEdge() : edge_dist(0), cost(0) {}\n\tEdge(int _dist, int _cost) : edge_dist(_dist), cost(_cost) {}\n};\n\nbool operator==(const Edge &a, const Edge &b){\n\treturn (a.cost == b.cost);\n}\nbool operator!=(const Edge &a, const Edge &b){\n\treturn !(a == b);\n}\nbool operator<(const Edge &a, const Edge &b){\n\treturn (a.cost < b.cost);\n}\nbool operator>=(const Edge &a, const Edge &b){\n\treturn !(a < b);\n}\nbool operator>(const Edge &a, const Edge &b){\n\treturn (a.cost > b.cost);\n}\nbool operator<=(const Edge &a, const Edge &b){\n\treturn !(a > b);\n}\n\nint main(){\n\tint v, e, s, t, w, sum = 0;\n\tvector< int > vlist; //??¢?´¢?????? -> 1 / else -> 0\n\tvector< vector< Edge > > edge;\n\tvector< Edge > tree;\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > priq;\n\t\n\twhile(cin >> v, v){\n\t\tcin >> e;\n\t\t\n\t\tvlist.resize(v);\n\t\tedge.resize(v);\n\t\t\n\t\tfor(int i = 0; i < e; ++i){\n\t\t\tscanf(\"%d,%d,%d\", &s, &t, &w);\n\t\t\tw /= 100;\n\t\t\t\n\t\t\tedge[s].push_back(Edge(t, w - 1));\n\t\t\tedge[t].push_back(Edge(s, w - 1));\n\t\t}\n\t\t\n\t\tvlist[0] = 1;\n\t\tfor(vector< Edge >::iterator it = edge[0].begin(); it != edge[0].end(); ++it){\n\t\t\tpriq.push(*it);\n\t\t}\n\t\t\n\t\twhile(!priq.empty()){\n\t\t\t\n\t\t\tEdge ed = priq.top();\n\t\t\tpriq.pop();\n\t\t\t\n\t\t\tif(vlist[ed.edge_dist])continue;\n\t\t\t\n\t\t\ttree.push_back(ed);\n\t\t\tvlist[ed.edge_dist] = 1;\n\t\t\tsum += ed.cost;\n\t\t\t\n\t\t\tfor(vector< Edge >::iterator it = edge[ed.edge_dist].begin(); it != edge[ed.edge_dist].end(); ++it){\n\t\t\t\tif(vlist[(*it).edge_dist] == 0){\n\t\t\t\t\tpriq.push(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\ntypedef vector <int> vi;\n#define REP(i,n) for(i=0;i<n;i++)\n\nstruct branch{\n\tint n1,n2,w;\n};\nbool f(branch i, branch j){\n\treturn (i.w>j.w);\n}\nint main(){\n\twhile (1){\n\t\tint n,i;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int>T(n);\n\t\tREP(i,n)T[i]=i;\n\n\t\tbranch tmp;\n\t\tint m; cin>>m;\n\t\tvector<branch>S(m);\n\t\tREP(i,m) cin>>S[i].n1>>c>>S[i].n2>>c>>S[i].w;\n\t\tsort(S.begin(),S.end(),f);\n\n\t\tint a=0;\n\t\twhile(S.size()){\n\t\t\ttmp=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[tmp.n1],c=T[tmp.n2];\n\t\t\tif (b!=c){\n\t\t\t\tfor(i=b+1;i<n;i++)\n\t\t\t\t\tif(T[i]==c)T[i]=b;\n\t\t\t\ta+=tmp.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdlib>\nusing namespace std;\n\nstruct place{\n\tint id;\n\tint weight;\n};\n\nconst int unseen = -INT_MAX;\n\nint update(vector<place>& vi, int k, int w){\n\tvector<place>::iterator iter = vi.begin();\n\twhile(iter != vi.end() && (*iter).id != k) iter++;\n\tif(iter == vi.end()){\n\t\tplace p;\n\t\tp.id = k;\n\t\tp.weight = w;\n\t\tvi.push_back(p);\n\t\treturn 1;\n\t}else{\n\t\tif((*iter).weight == w){\n\t\t\treturn 0;\n\t\t}else{\n\t\t\tif(w < (*iter).weight){\n\t\t\t\t(*iter).weight = w;\n\t\t\t\treturn 1;\n\t\t\t}else return 0;\n\t\t}\n\t}\n}\n\nvoid swap(vector<place>& vp, int i, int j){\n\tplace p;\n\tp.id = vp[i].id; p.weight = vp[i].weight;\n\tvp[i].id = vp[j].id; vp[i].weight = vp[j].weight;\n\tvp[j].id = p.id; vp[j].weight = p.weight;\n}\n\nplace remove(vector<place>& vp){\n\tint min = 0;\n\tfor(int i = 0; i < vp.size(); i++){\n\t\tif(vp[i].weight < vp[min].weight)\n\t\t\tmin = i;\n\t}\n\tswap(vp, min, vp.size() - 1);\n\tplace p = vp[vp.size() - 1];\n\tvp.pop_back();\n\treturn p;\n}\n\nint visit(int route[100][100], int k, int n){\n\tint weight = 0;\n\tint val [100];\n\tfor(int i = 0; i < 100; i++) val[i] = unseen;\n\tvector<place> vp;\n\tupdate(vp, k, -unseen);\n\twhile(!vp.empty()){\n\t\tplace p = remove(vp);\n\t\tk = p.id;\n\t\tval[k] =-val[k];\n\t\tif(val[k] == -unseen) val[k] = 0;\n\t\tweight += val[k];\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif(route[k][i] != 0)\n\t\t\t\tif(val[i] < 0)\n\t\t\t\t\tif(update(vp, i, route[k][i]))\n\t\t\t\t\t{\n\t\t\t\t\t\tval[i] = -route[k][i];\n\t\t\t\t\t}\n\t\t}\n\t}\n\treturn weight;\n}\n\nint main(){\n\tconst int nmax = 100;\n\tint n;\n\tint m;\n\tint route[nmax][nmax];\n\tint a, b;\n\tint dis;\n\tchar c;\n\twhile(cin >> n){\n\t\tfor(int i = 0;i < nmax; i++){\n\t\t\tfor(int j = 0; j < nmax; j++){\n\t\t\t\troute[i][j] = 0;\n\t\t\t}\n\t\t}\n\t\tif(n == 0) break;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tcin >> a >> c >> b >> c >> dis;\n\t\t\tdis = dis / 100 - 1;\n\t\t\troute[a][b] = dis;\n\t\t\troute[b][a] = dis;\n\t\t}\n\t\tcout << visit(route, 0, n) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n#define INF 10e6\nint cost[100][100];\nbool used[100];\nint mincost[100];\nint n,m;\n\nint prim(){\n\tfor(int i=0;i<n;i++){\n\t\tmincost[i]=INF;\n\t\tused[100]=false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\twhile(true){\n\t\tint v=-1;\n\t\tfor(int i=0;i<n;i++)\n\t\t\tif(!used[i]&&(v==-1||mincost[i]<mincost[v])) v=i;\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tfor(int i=0;i<n;i++)\n\t\t\tmincost[i]=min(mincost[i],cost[i][v]);\n\t}\n\treturn res;\n}\n\nint main(void){\n\tint a,b,d,result;\n\tchar tem;\n\twhile(cin >> n,n){\n\t\tfor(int i=0;i<n;i++)\n\t\t\tfor(int j=0;j<n;j++)\n\t\t\t\tcost[i][j]=(i==j)?0:INF;\n\t\tcin >> m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin >> a >> tem >> b >> tem >> d;\n\t\t\tcost[a][b]=cost[b][a]=d/100-1;\n\t\t}\n\t\tresult=prim();\t\n\t\tcout << result << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include \"stdio.h\"\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge{\n    Edge(int t, int c)\n        : to(t), cost(c) {}\n\n    int to;\n    int cost;\n};\n\nint cnt;\nbool visited[100];\nvector<Edge> G[100];\ntypedef pair<int, int> PII;\n\nint prim(int start){\n    int ans = 0;\n    cnt = 0;\n    fill(visited, visited+100, false);\n\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n\n    que.push(PII(0, start));\n    while (!que.empty()){\n        int cst = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        cnt++;\n        ans += cst;\n        for (int i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            que.push(PII(G[v][i].cost, G[v][i].to));\n        }\n    }\n\n    return ans;\n} \n\nint main(int argc, char const *argv[]){\n    int n, m;\n\n    while (cin>>n, n){\n        cin>>m;\n        for (int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            d = (d-100) / 100;\n            G[a].push_back(Edge(b, d));\n            G[b].push_back(Edge(a, d));\n        }\n\n        cout<<prim(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INFTY 1000000000\n\nint n,M[101][101],color[101],d[101],p[101];\n\nvoid prim() {\n  for ( int i = 0; i < 101; i++ ) {\n    color[i] = WHITE;\n    d[i] = INFTY;\n    p[i] = -1;\n  }\n  \n  d[0] = 0;\n  int u;\n  while(1){\n    u = -1;\n    int mincost = INFTY;\n\n    for ( int i = 0; i < n; i++ ) {\n      if ( color[i] != BLACK && d[i] < mincost ) {\n\tmincost = d[i];\n\tu = i;\n      }\n    }\n\n    if ( u == -1 ) break;\n\n    color[u] = BLACK;\n    \n    for ( int v = 0; v < n; v++ ) {\n      if ( color[v] != BLACK && M[u][v] != INFTY ) {\n\tif ( M[u][v] < d[v] ) {\n\t  d[v] = M[u][v];\n\t  p[v] = u;\n\t  color[v] = GRAY;\n\t}\n      }\n    }\n  }\n  int ans = 0;\n\n  for ( int i = 1; i < n; i++ ) {\n    // cout << d[i] << \" \" ;\n    int tmp = d[i]/100-1;\n    //   cout << tmp  << endl;\n    ans += tmp;\n  }\n  // cout << endl;\n  cout << ans << endl;\n}\n\nint main() {\n\n  while(1) {\n    cin >> n;\n    if ( n == 0 ) break;\n    for ( int i = 0; i  < 101; i++ ) {\n      for ( int j = 0; j < 101; j++ ) {\n\tM[i][j] = INFTY;\n      }\n    }\n    int m; cin >> m;\n    char ch;\n    for ( int i = 0; i < m; i++ ) {\n      int a,b,distance;\n      cin >> a >> ch >> b >> ch >> distance;\n      M[a][b] = distance;\n    }\n  \n    prim();\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nvector<int> par,rank;\nvector<pair<int,pair<int,int> > > edge;\nint find(int n){\n    if(par[n]==n) return n;\n    else return par[n]=find(par[n]);\n}\nvoid unite(int a,int b){\n    int pa=find(a),pb=find(b);\n    par[pa]=pb;\n//    if(pa==pb) return;\n//    if(rank[pa]>rank[pb]) swap(pa,pb);\n//    par[pa]=pb;\n//    if(rank[pa]==rank[pb]) rank[pb]++;\n}\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d\\n\",&n);\n        if(n==0) break;\n        scanf(\"%d\\n\",&m);\n        int a,b,d;\n        edge=vector<pair<int,pair<int,int> > >(n);\n        for(int i=0;i<m;i++){\n            scanf(\"%d,%d,%d\\n\",&a,&b,&d);\n            d=d/100-1;\n            edge[i]=MP(d,MP(a,b));\n        }\n        par=vector<int>(n);\n        rank=vector<int>(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n        sort(ALL(edge));\n        int ret=0;\n        for(int i=0;i<edge.size();i++){\n            int a=edge[i].second.first,b=edge[i].second.second,d=edge[i].first;\n            if(find(a)!=find(b)){\n                ret+=d;\n                unite(a,b);\n            }\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 100000000\nusing namespace std;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\nint n;\nint prim();\nmain(){\n  int m;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    cin >> m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      c/=100;\n      cost[a][b]=cost[b][a]=c;\n    }\n    \n    cout << prim()-(n-1) << endl;\n  }\n  return 0;\n}\n\nint prim(){\n  for(int i=1;i<n;i++){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  mincost[0]=0;\n  int res=0;\n\n  while(true){\n    int v=-1;\n    for(int u=0;u<n;u++){\n      if(!used[u] && (v==-1 || mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=0;u<n;u++){\n      mincost[u]=min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int INF = 1ll<<60ll;\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\nint n,m;\nint ans;\nint cost[150];\nint used[150];\nint V[150][150];\n\nint prim(){\n    int res=0;\n    cost[0]=0;\n    while(1){\n        int v=-1;\n        rep(i,n){\n            if(used[i]!=1&&v==-1)v=i;\n            else if(used[i]!=1&&cost[i]<cost[v])v=i;\n        }\n        if(v==-1)break;\n        used[v]=1;\n        res+=cost[v];\n        rep(i,n){\n            cost[i]=min(cost[i],V[v][i]);\n        }\n    }\n    return res;\n}\n\nsigned main(){\n    while(1){\n        rep(i,150){\n            used[i]=0;\n            cost[i]=INF;\n        }\n        rep(i,150)rep(j,150)V[i][j]=INF;\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            V[x][y]=z/100-1;\n            V[y][x]=z/100-1;\n        }\n        cout<<prim()<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <climits>\nusing namespace std;\n#define rep2(x,from,to) for(int x = (from); x < (to); ++(x))\n#define rep(x,to) rep2(x,0,to)\nint main() {\n\tint n, m;\n\twhile(cin >> n, n) {\n\t\tcin >> m;\n\t\tint cost[100][100];\n\t\trep(i,100) {\n\t\t\trep(j,100) {\n\t\t\t\tcost[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\trep(i,m) {\n\t\t\tint s, t, len;\n\t\t\tscanf(\"%d,%d,%d\", &s, &t, &len);\n\t\t\tlen /= 100;\n\t\t\tcost[s][t] = len;\n\t\t\tcost[t][s] = len;\n\t\t}\n\t\tint dist[100];\n\t\tbool visited[100];\n\t\trep(i,n) {\n\t\t\tdist[i] = INT_MAX;\n\t\t\tvisited[i] = 0;\n\t\t}\n\t\tdist[0] = 0;\n\t\tvisited[0] = 1;\n\t\tint ret = 0;\n\t\twhile(1) {\n\t\t\tbool flag = true;\n\t\t\trep(i,n) {\n\t\t\t\tif(!visited[i]) {\n\t\t\t\t\tflag = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(flag) break;\n\t\t\tint min = INT_MAX;\n\t\t\tint to;\n\t\t\trep(i,n) {\n\t\t\t\tif(visited[i]) {\n\t\t\t\t\trep(j,n) {\n\t\t\t\t\t\tif(!visited[j]) {\n\t\t\t\t\t\t\tif(cost[i][j] < min) {\n\t\t\t\t\t\t\t\tmin = cost[i][j];\n\t\t\t\t\t\t\t\tto = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tvisited[to] = 1;\n\t\t\tret += min;\n\t\t}\n\t\tcout << ret - n + 1 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <queue>\n\n#define INF 1e9\n\nstruct Edge {\n\tint to, cost;\n};\nstruct Node {\n\tint now, cost, pCost;\n};\nbool operator <(const Node& n1, const Node& n2) {\n\treturn n1.cost < n2.cost;\n}\nbool operator >(const Node& n1, const Node& n2) {\n\treturn n1.cost > n2.cost;\n}\n\nusing namespace std;\n\nint main() {\n\tint n;\n\twhile (cin >> n, n) {\n\t\tvector<Edge> edge[100];\n\t\tint m; cin >> m;\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\n\t\t\tint c = d / 100 - 1;\n\t\t\tedge[a].push_back( (Edge){ b, c } );\n\t\t\tedge[b].push_back( (Edge){ a, c } );\n\t\t}\n\n\t\tpriority_queue<Node, vector<Node>, greater<Node> > Q; Q.push( (Node){ 0, 0, 0 } );\n\t\tbool f[100] = {0};\n\t\tint ans = 0;\n\t\twhile ( !Q.empty() ) {\n\t\t\tNode node = Q.top(); Q.pop();\n\t\t\tif (f[node.now]) continue;\n\t\t\tf[node.now] = true;\n\n\t\t\tans += node.pCost;\n\n\t\t\tfor (int i = 0; i < edge[node.now].size(); ++i) {\n\t\t\t\tEdge& e = edge[node.now][i];\n\t\t\t\tQ.push( (Node){ e.to, e.cost, e.cost } );\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\nstruct Edge { int from, to, cost; };\nbool comp(const Edge& e1, const Edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nstruct UnionFind {\n\tvector<int> par, rank;\n\t\n\tUnionFind() {}\n\tUnionFind(int n) {\n\t\tinit(n);\n\t}\n\t\n\tint init(int n) {\n\t\tpar.resize(n);\n\t\trank.resize(n, 0);\n\t\tREP(i, n) par[i] = i;\n\t}\n\t\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\telse return par[x] = find(par[x]);\n\t}\n\t\n\tvoid unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y) return;\n\t\t\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t}\n\t\n\tbool same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n};\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tcin >> m;\n\t\t\n\t\tUnionFind uf(n);\n\t\tvector<Edge> v(m);\n\t\t\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tv[i].from = a;\n\t\t\tv[i].to = b;\n\t\t\tv[i].cost = c;\n\t\t}\n\t\tsort(v.begin(), v.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tREP(i, m) {\n\t\t\tEdge e = v[i];\n\t\t\tif (! uf.same(e.from, e.to)) {\n\t\t\t\tuf.unite(e.from, e.to);\n\t\t\t\tans += e.cost / 100 - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\nconst int MAX = 1000;\n\nint par[MAX],rank[MAX],n,m;\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x); y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint kruskal(pair<int,pair<int,int> > es[MAX]){\n  sort(es,es + m);\n  init(n);\n  int res = 0;\n  for(int i = 0 ; i < m ; i++){\n    int a = es[i].second.first;\n    int b = es[i].second.second;\n    if(!same(a,b)){\n      res += es[i].first;\n      unite(a,b);\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> n,n){\n    cin >> m;\n    pair<int,pair<int,int> > es[MAX];\n    for(int i = 0 ; i < m ; i++){\n      scanf(\"%d,%d,%d\", &es[i].second.first, &es[i].second.second,&es[i].first);\n    }\n    for(int i = 0 ; i < m ; i++){\n      es[i].first = es[i].first/100-1;\n    }\n\n    cout << kruskal(es) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n\n#define MAX_V 101\n#define INF 10000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\n\nint V,mincost[MAX_V];\nvector<edge>G[MAX_V];\n\nint Prim(void){\n  priority_queue<P, vector<P>, greater<P> >que;\n  fill(mincost, mincost+V, INF);\n\n  mincost[0]=0;\n  que.push(P(0,0));\n  \n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    \n    int v = p.second;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(mincost[e.to] > e.cost){\n\tmincost[e.to] = e.cost;\n\tque.push(P(mincost[e.to], e.to));\n      }\n    }\n  }\n  int res=0;\n  for(int i=0;i<V;i++)res+=mincost[i];\n \n  return res;\n}\n\n\n\nint main(void){\n  int m,a,b,c;\n  char ch1,ch2;\n  edge e;\n\n  while(cin >> V,V){\n\n    for(int i=0;i<V;i++)G[i].clear();\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> a >> ch1 >> b >> ch2 >> c;\n      c=c/100-1;\n      e.to=b,e.cost=c;\n      G[a].push_back(e);\n    }\n      cout << Prim() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <map>\nusing namespace std;\nint cost[100][100];\nconst int INF = 1000000;\nint prim(int n,int s){\n\ttypedef pair<int,int> P;\n\tbool ischeck[n];\n\tint mincost = 0;\n\tpriority_queue<P,vector<P>,greater<P> > pq;\n\tP p,tp;\n\tfor(int i = 0;i < n;++i){\n\t\tischeck[i] = false;\n\t\tif(cost[s][i] != INF){\n\t\t\tp.first = cost[s][i];\n\t\t\tp.second = i;\n\t\t\tpq.push(p);\n\t\t}\n\t}\n\tischeck[s] = true;\n\twhile(!pq.empty()){\n\t\tp = pq.top();\n\t\tpq.pop();\n\t\tif(ischeck[p.second]) continue;\n\t\telse{\n\t\t\tischeck[p.second] = true;\n\t\t\tmincost += p.first;\n\t\t\tfor(int i = 0;i < n;++i){\n\t\t\t\tif(cost[p.second][i] != INF){\n\t\t\t\t\ttp.first = cost[p.second][i];\n\t\t\t\t\ttp.second = i;\n\t\t\t\t\tpq.push(tp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mincost;\n}\nint main(){\n\tint n,m,a,b,c;\n\twhile(cin >> n,n){\n\t\tfor(int i = 0;i < 100;++i){\n\t\t\tfor(int j = 0;j < 100;++j){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tfor(int i = 0;i < m;++i){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tcost[a][b] = c / 100 - 1;\n\t\t}\n\t\tcout << prim(n,0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int maxn = 101,maxm = 5500;\n#define inf 10000\n\nint cost[maxn][maxn]={};\nint mincost[maxn] = {};\nbool used[maxn] = {};\nint n,m,a,b,temp;\nchar t;\n\nint main()\n{\n\twhile(cin >> n && n)\n\t{\n\t\tcin >> m;\n\t\tmemset(cost, inf, sizeof(cost));\n\t\tmemset(mincost, inf, sizeof(int)*maxn);\n\t\tmemset(used, false, sizeof(used));\n\t\tmincost[0] = 0;\n\t\t\n\t\tint ans = 0;\n\t\tREP(m)\n\t\t{\n\t\t\tcin >> a >> t >> b >> t >> temp;\n\t\t\tcost[a][b] = (temp/100)-1;\n\t\t\tcost[b][a] = cost[a][b];\n\t\t\t//cout << a << \"to\" << b << \" \" << cost[b][a]<< endl;\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tint minv = inf;\n\t\t\trep(i,n)if(!used[i] &&(mincost[minv] == inf ||mincost[i] < mincost[minv])) minv = i;\n\t\t\tif(minv == inf) break;\n\n\t\t\tused[minv] = true;\n\t\t\tans += mincost[minv];\n\t\t\t//cout << minv << \":\"<< mincost[minv] << endl;\n\n\t\t\tREP(n) mincost[i] = min(mincost[i], cost[minv][i]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#define INF 2147483647\nusing namespace std;\n\nclass Lantern{\npublic:\n\tbool vector_find(vector<int> v,int key){\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(v[i]==key){return 1;}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Solve(int n, int roadlist[100][100] ){\n\t\tint ans=0,i,j;\n\t\tvector<int> V;\n\t\tV.push_back(0);\n\t\twhile(V.size()!=n){\n\t\t\tint u,v,min=INF;\n\t\t\tfor(i=0;i<V.size();i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(!vector_find(V,j)&&roadlist[V[i]][j]<min){\n\t\t\t\t\t\tu=i,v=j;\n\t\t\t\t\t\tmin=roadlist[V[i]][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=min;\n\t\t\tV.push_back(v);\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\nint main(){\n\tint n,m;\n\tint rlist[100][100];\n\tLantern lantern;\n\twhile(1){\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\trlist[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){break;}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\trlist[a][b]=rlist[b][a]=c/100-1;\n\t\t}\n\t\tprintf(\"%d\\n\",lantern.Solve(n,rlist));\n\t\t\n\t}\n\t\n\t\n\t\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nvector<int> par,rank;\nvector<pair<int,pair<int,int> > > edge;\nint find(int n){\n    if(par[n]==n) return n;\n    else return par[n]=find(par[n]);\n}\nvoid unite(int a,int b){\n    int pa=find(a),pb=find(b);\n    par[pa]=pb;\n//    if(pa==pb) return;\n//    if(rank[pa]>rank[pb]) swap(pa,pb);\n//    par[pa]=pb;\n//    if(rank[pa]==rank[pb]) rank[pb]++;\n}\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d\\n\",&n);\n        if(n==0) break;\n        scanf(\"%d\\n\",&m);\n        int a,b,d;\n        edge=vector<pair<int,pair<int,int> > >(m);\n        for(int i=0;i<m;i++){\n            scanf(\"%d,%d,%d\\n\",&a,&b,&d);\n            d=d/100-1;\n            edge[i]=MP(d,MP(a,b));\n        }\n        par=vector<int>(n);\n        rank=vector<int>(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n        sort(ALL(edge));\n        int ret=0;\n        for(int i=0;i<edge.size();i++){\n            int a=edge[i].second.first,b=edge[i].second.second,d=edge[i].first;\n            if(find(a)!=find(b)){\n                ret+=d;\n                unite(a,b);\n            }\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n\nusing namespace std;\n\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\ntypedef long long ll;\n\n#define rep(i,n) for(ll i=0;i<(ll)(n);i++)\n#define all(a)  (a).begin(),(a).end()\n#define pb push_back\n#define  INF 999999999\n\n#ifdef Debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl\n#else\n#define dump(x)\n#endif\n\nbool used[5000];\nint mincost[5000];\nint edge[1000][1000];\n\nint main(){\n\tint n,m;\n\twhile(cin>>n){\n\t\tif(n==0)break;\n\t\trep(i,200)rep(j,200)edge[i][j]=INF;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tchar ch;\n\t\t\tcin>>a>>ch>>b>>ch>>c;\n\t\t\tedge[a][b]=edge[b][a]=max(0,(int)(c/100)-1);\n\t\t}\n\t\trep(i,m){\n\t\t\tmincost[i]=INF;\n\t\t\tused[i]=false;\n\t\t}\n\t\tmincost[0]=0;\n\t\tint res=0;\n\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\trep(u,m){\n\t\t\t\tif(used[u]==false && ( v==-1 || mincost[u]<mincost[v] ))\n\t\t\t\t\tv=u;\n\t\t\t}\n\t\t\tif(v==-1)break;\n\t\t\tused[v]=true;\n\t\t\tres+=mincost[v];\n\n\t\t\trep(u,m){\n\t\t\t\tmincost[u]=min(mincost[u],edge[v][u]);\n\t\t\t}\n\t\t}\n\t\tcout<<res<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nstd::pair<Weight, Edges> prim(const Graph &g, const int &root = 0) {\n  struct comp {\n    bool operator()(const Edge &e, const Edge &f) const { return e.weight > f.weight; }\n  };\n  Edges tree;\n  Weight total = 0;\n  std::vector<int> vs(g.size());\n  std::priority_queue<Edge, std::vector<Edge>, comp> q;\n  q.emplace(-1, root, 0);\n  while (q.size()) {\n    Edge e = q.top();\n    q.pop();\n    if (vs[e.dst]) continue;\n    vs[e.dst] = true;\n    total += e.weight;\n    if (e.src != -1) tree.emplace_back(e);\n    for (auto &f : g[e.dst]) {\n      if (!vs[f.dst]) q.emplace(f);\n    }\n  }\n  return {total, tree};\n}\n\nmain {\n  int n, m;\n  cin >> n >> m;\n  Graph g(n);\n  while (m--) {\n    int a, b, d;\n    char gomi;\n    cin >> a >> gomi >> b >> gomi >> d;\n    g.addEdge(a, b, d);\n  }\n  Edges es = prim(g, 0).second;\n  int c = 0;\n  for (auto &e : es) c += e.weight / 100 - 1;\n  cout << c << endl;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nvector<Edge> g[100000],rg[100000];\nconst int MAX_V = 105;\n//inf??§?????????\nvector<vector<ll>> cost;\nll mincost[MAX_V];\nbool used[MAX_V];\nll V;\nll prim(){\n  ll res = 0;\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  priority_queue<NODE> q;\n  q.push({0,0});\n  while(q.size()){\n    auto v = q.top();q.pop();\n    if(mincost[v.pos] == inf){\n      mincost[v.pos] = v.cost;\n      res += v.cost;\n      for(auto n : g[v.pos]){\n        q.push({n.to,n.cost});\n      }\n    }\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin >> n && n){\n    V = n;\n    cin >> m;\n    ll a,b,c;\n    char d;\n    rep(i,m){\n      cin >> a >> d >> b >> d >> c;\n      g[a].push_back({b,c});\n      g[b].push_back({a,c});\n    }\n    ll ans = prim();\n    cout << ans/100-(n-1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct LINE {\n\tint a;\n\tint b;\n\tint d;\n\tbool use;\n};\n\nvector<int> getconnect(vector<LINE> &lines,int n)\n{\n\tvector<int>\tr;\n\tfor(int i=0;i<lines.size();i++){\n\t\tif( lines[i].a != lines[i].b && (lines[i].a==n || lines[i].b==n) ){\n\t\t\tr.push_back(i);\n\t\t}\n\t}\n\treturn r;\n}\n\nint main() {\n\n\tint n,m;\n\tcin >> n >> m;\n\tvector<LINE> lines;\n\t\n\tfor(int i=0;i<m;i++){\n\t\tLINE l;\n\t\tchar c;\n\t\tcin >> l.a >> c >> l.b >> c >> l.d;\n\t\tl.use=false;\n\t\tlines.push_back(l);\n\t}\n\n\twhile( true ){\n\n\t\tint count=0;\n\t\tfor(int i=0;i<n;i++){\n\t\t\tauto idxs=getconnect(lines,i);\n\t\t\tif( idxs.empty() ) continue;\n\n\t\t\tcount++;\n\t\t\t\n\t\t\tint mini = idxs[0];\n\t\t\tint mind = lines[mini].d;\n\t\t\tfor(int idx : idxs){\n\t\t\t\tif( lines[idx].d < mind ){\n\t\t\t\t\tmini = idx;\n\t\t\t\t\tmind = lines[idx].d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint t = lines[mini].a!=i?lines[mini].a:lines[mini].b;\n\t\t\t\n\t\t\tauto idxs2=getconnect(lines,t);\n\t\t\tfor(int idx : idxs2){\n\t\t\t\tif( lines[idx].a==t){\n\t\t\t\t\tlines[idx].a = i;\n\t\t\t\t}\n\t\t\t\tif( lines[idx].b==t){\n\t\t\t\t\tlines[idx].b = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlines[mini].use=true;\n\t\t}\n\t\tif( count==0) break;\n\t\tcount=0;\n\t}\n\n\tint ans=0;\n\tfor( auto l : lines){\n\t\tif( l.use){\n\t\t\tans += l.d/100-1;\n\t\t}\n\t}\n\tcout << ans;\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <stdlib.h>\n#define INF 0x7fffffff\n#define MAX_V 100\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V; // V<=100\n\nint prim(){\n  for( int i=0;i<V;++i ){\n    mincost[i]=INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while( true ){\n    int v=-1;\n    for( int u=0;u<V;u++ ){\n      if( !used[u] && (v==-1 || mincost[u] < mincost[v])) v=u;\n    }\n    if( v==-1 ) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for( int u=0;u<V;u++ )\n      mincost[u] = min( mincost[u], cost[v][u] );\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  string line;\n  char buf[256];\n\n  while(  cin >> V,V ){\n    cin >> m;\n    //    cout << \"V=\"<<V <<\" m=\"<<m<<endl;\n\n    int x,y;\n    int k;\n    for( int i=0;i<V;i++ )\n      for( int j=0;j<V;j++ )\n\tcost[i][j] = INF;\n    for( int i=0,j;i<m;i++ ){\n      cin >> line;\n      for( j=0;j<line.size();j++ ) buf[j] = line.at(j);\n      buf[j] = '\\0';\n      x = atoi( buf );\n      for( j=0; buf[j]!=',';j++ );\n      y = atoi( ++j+buf );\n      for( ; buf[j]!=',';j++ );\n      k = atoi( ++j+buf );\n      //       cout << x <<\"_\"<<y<<\"_\"<<k<< endl;\n      k = k/100 -1; // ÂÂÂUÂÃÂÂ\n      cost[x][y] = k;\n      cost[y][x] = k;\n    }\n    cout << prim() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cmath>\n#include <vector>\n#include <string>\n#include <map>\n#include <queue>\n#include <stack>\n#include <algorithm>\n\n#define rep(i,j) REP((i), 0, (j))\n#define REP(i,j,k) for(int i=(j);(i)<(k);++i)\n#define between(a,x,b) ((a)<=(x)&&(x)<=(b))\n#define MAX_N 100\n#define INF 1 << 30\n\nusing namespace std;\n\n\nint cost[MAX_N][MAX_N];\nint mincost[MAX_N];\nbool used[MAX_N];\nint n, m;\n\nint prim(){\n  for(int i = 0; i < n; ++i){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true){\n    int v = -1;\n    for(int u = 0; u < n; ++u)\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for(int u = 0; u < n; ++u)\n      mincost[u] = min(mincost[u], cost[v][u]);\n  }\n  return res;\n}\n\nint main(){\n  int from, to, c;\n  while(scanf(\"%d\", &n) && n){\n    rep(i, n) rep(j, n) cost[i][j] = INF;\n    scanf(\"%d\", &m);\n    rep(i, m){\n      scanf(\"%d,%d,%d\", &from, &to, &c);\n      cost[from][to] = cost[to][from] = c;\n    }\n    printf(\"%d\\n\", prim()/100-(n-1));\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d\",&m);\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost + n,numeric_limits<int>::max());\n\t\tint** cost = new int*[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcost[i] = new int[n];\n\t\t\tfor(int j=0;j<n;j++)cost[i][j]=numeric_limits<int>::max();\n\t\t}\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from,to,dist;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&dist);\n\t\t\tcost[from][to] = min(cost[from][to],dist / 100 - 1);\n\t\t\tcost[to][from] = min(cost[to][from],dist / 100 - 1);\n\t\t}\n\t\tmincost[0]=0;\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int u=0;u<n;u++)\n\t\t\t\tif(!used[u] && (v==-1 || mincost[u] < mincost[v]))\n\t\t\t\t\tv = u;\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\n\t\t\tres+=mincost[v];\n\t\t\tfor(int u=0;u<n;u++)mincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t\tcout << res << endl;\n\t\tfor(int i=0;i<n;i++)delete[] cost[i];\n\t\tdelete[] cost;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n\n#define MAX_V 101\n#define INF 10000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\n\nint V,mincost[MAX_V];\nvector<edge>G[MAX_V];\n\nint Prim(void){\n  priority_queue<P, vector<P>, greater<P> >que;\n  fill(mincost, mincost+V, INF);\n\n  mincost[0]=0;\n  que.push(P(0,0));\n\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    int v = p.second;\n    if(mincost[v] < p.first)continue;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(mincost[e.to] > e.cost){\n\tmincost[e.to] = e.cost;\n\tque.push(P(mincost[e.to], e.to));\n      }\n    }\n  }\n  int res=0;\n  for(int i=0;i<V;i++)res+=mincost[i];\n \n  return res;\n}\n\n\n\nint main(void){\n  int m,a;\n  char d,f;\n  edge e;\n\n  while(cin >> V,V){\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> a >> d >> e.to >> f >> e.cost;\n      e.cost=e.cost/100-1;\n      G[a].push_back(e);\n    }\n      cout << Prim() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Prim\n#include <iostream>\n#include <cstdio>\n#include <algorithm>\n#include <climits>\n#define MAX_N 200\nusing namespace std;\n\nconst int INF = 1e+9;\n\nint main(){\n\tint n, m;\n\tint from, to, d;\n\tint cost[MAX_N][MAX_N];\n\tint minCost[MAX_N];\n\tbool used[MAX_N];\n\tint ans;\n\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> m;\n\t\t// initialize\n\t\tfor (int y = 0; y < n; y++) {\n\t\t\tminCost[y] = INF;\n\t\t\tused[y] = false;\n\t\t\tfor (int x = 0; x < n; x++) {\n\t\t\t\tcost[y][x] = INF;\n\t\t\t}\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &d);\n\t\t\tcost[to][from] = cost[from][to] = d / 100 -1;\n\t\t\t//cout << from << ',' << to << ',' << d << endl;\n\t\t}\n\t\tminCost[0] = 0;\n\t\tans = 0;\n\t\t// Prim\n\t\twhile (1) {\n\t\t\tint v = -1;\n\t\t\t// find minNode\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tif(!used[i] && (v == -1 || minCost[i] < minCost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (v == -1) { // all noses are used?\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused[v] = true;\n\t\t\tans += minCost[v];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tminCost[i] = min(minCost[i], cost[v][i]);\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define all(c) (c).begin(),(c).end()\n#define rrep(i,n) for(int i=(int)(n)-1;i>=0;i--)\n#define REP(i,m,n) for(int i=(int)(m);i<(int)(n);i++)\n#define rep(i,n) REP(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define tr(it,c) for(iter(c) it=(c).begin();it!=(c).end();it++)\n#define pb(a) push_back(a)\n#define pr(a) cout<<(a)<<endl\n#define PR(a,b) cout<<(a)<<\" \"<<(b)<<endl\n#define F first\n#define S second\n#define ll long long\nbool check(int n,int m,int x,int y){return (x<0||x>=n||y<0||y>=m)?false:true;}\nconst ll MAX=1000000007,MAXL=1LL<<60,dx[4]={-1,0,1,0},dy[4]={0,-1,0,1};\ntypedef pair<int,int> P;\n\nint main() {\n  int n,m;\n  while(cin >> n && n) {\n    cin >> m;\n    vector<P> v[n];\n    while(m--) {\n      int x,y,d;\n      scanf(\"%d%*c%d%*c%d\",&x,&y,&d);\n      v[x].pb(P(y,d));\n      v[y].pb(P(x,d));\n    }\n    int ans=0;\n    priority_queue<P,vector<P>,greater<P> > que;\n    que.push(P(0,0));\n    bool d[n];\n    fill(d,d+n,false);\n    while(!que.empty()) {\n      P p=que.top();que.pop();\n      int x=p.S,cost=p.F;\n      if(d[x]) continue;\n      d[x]=true;\n      ans+=cost/100-1;\n      for(int i=0; i<v[x].size(); i++) {\n\tif(!d[v[x][i].F]) {\n\t  que.push(P(v[x][i].S,v[x][i].F));\n\t}\n      }\n    }\n    pr(ans+1);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef struct{\n\tint cost,v,u,par;\n}wa;\nwa way[300];\nint compare(const wa& a,const wa& b){\n\treturn a.cost<b.cost;\n}\nint find(int t){\n\tif(way[t].par==t)\n\treturn t;\n\telse return find(way[t].par);\n}\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tway[x].par=find(way[y].par);\n}\nint main(){\n\tint n,m,ans,x,y,c,num;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\tans=0;\n\t\tnum=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&x,&y,&c);\n\t\t\tway[i].v=x;\n\t\t\tway[i].u=y;\n\t\t\tway[i].cost=c;\n\t\t}\n\t\tsort(way,way+m,compare);\n\t\tfor(int i=0;i<m;i++)\n\t\t\tway[i].par=i;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!same(way[i].v,way[i].u)){\n\t\t\tunite(way[i].v,way[i].u);\n\t\t\t\tnum++;\n\t\t\tans+=way[i].cost;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\n\t\tcout<<ans/100-num<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <set>\n#define INF 1e8\n\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>n,n){\n  \tcin>>m;\n    vector<vector<int> > g(n);\n    for(int i=0;i<n;++i){\n      g[i].reserve(n);\n      for(int j=0;j<n;++j) g[i][j]=INF;\n    }\n    for(int i=0,a,b,d;i<m;++i){\n      scanf(\"%d,%d,%d\",&a,&b,&d);\n      g[a][b]=d/100-1;\n      g[b][a]=d/100-1;\n    }\n    int ans=0;\n    set<int> v;\n    v.insert(0);\n    while(v.size()!=n){\n      int min_cost=INF,to=0;\n      for(set<int>::iterator vit=v.begin();vit!=v.end();++vit){\n        for(int i=0;i<n;++i){\n          if(v.find(i)==v.end()&&g[*vit][i]<min_cost){\n            to=i;\n            min_cost=g[*vit][i];\n          }\n        }\n      }\n      ans+=min_cost;\n      v.insert(to);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint n, m;\n\nconst int INF = 1e+9;\nconst int MAX_V = 100;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint prim(){\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\t\n\twhile( true ){\n\t\tint v = -1;\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tif( !used[u] && (v == -1 || mincost[u] < mincost[v]) ){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tmincost[u] = min( mincost[u] , cost[v][u] );\n\t\t}\n\t}\n\treturn res;\n}\n\n// ?????????s?????????c???????????§??????????????????\nvector<string> split_string(string s, char c){\n\tstring str;\n\tvector<string> vs;\n\ts.push_back( c );\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == c ){\n\t\t\tif( !str.empty() ){\n\t\t\t\tvs.push_back( str );\n\t\t\t\tstr.clear();\n\t\t\t}\n\t\t}else{\n\t\t\tstr.push_back( s[i] );\n\t\t}\n\t}\n\treturn vs;\n}\n\n// string???int?????????\nint s_to_i(string s){\n\tint n=0;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tn *= 10;\n\t\tn += s[i] - '0';\n\t}\n\treturn n;\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tfor(int v=0 ; v < n ; v++ ){\n\t\t\t\tcost[u][v] = cost[v][u] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> m;\n\t\tcin.ignore();\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tstring s;\n\t\t\tgetline(cin,s);\n\t\t\tvector<string> vs = split_string( s , ',' );\n\t\t\tint u = s_to_i( vs[0] );\n\t\t\tint v = s_to_i( vs[1] );\n\t\t\tint c = (s_to_i( vs[2] ) - 100) / 100;\n\t\t\tcost[u][v] = cost[v][u] = c;\n\t\t}\n\t\tint ans = prim();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Road {\n    int a, b;\n    int dist;\n\n    bool operator < (const Road &other) const {\n        return dist < other.dist;\n    }\n};\n\n/*\nint getroot(int i, vector<int> &roots) {\n    if(roots[i] == i) return i;\n    return roots[i] = getroot(roots[i], roots);\n}\n\nvoid unite(int i, int j, vector<int> &roots) {\n    roots[i] = getroot(j, roots);\n}\n*/\n\n//Verified PKU 2524\nint getroot(int i, vector<int> &roots) {\n    if(roots[i] == i) return i;\n    else return (roots[i] = getroot(roots[i], roots));\n}\n\n//Verified PKU 2524\nbool unite(int i, int j, vector<int> &roots, vector<int> &levels) {\n    i = getroot(i, roots);\n    j = getroot(j, roots);\n    if(i == j) return false;\n\n    if(levels[i] < levels[j]) {\n        roots[i] = j;\n    }\n    else {\n        roots[j] = i;\n        if(levels[i] == levels[j]) ++levels[i];\n    }\n    return true;\n}\n\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N;\n        if(!N) break;\n        cin >> M;\n\n        vector<Road> roads(M);\n        char comma;\n        for(int i = 0; i < M; ++i) \n            cin >> roads[i].a >> comma >> roads[i].b >> comma >> roads[i].dist;\n        sort(roads.begin(), roads.end());\n\n        int ans = 0;\n        vector<int> roots(N), levels(N, 0);\n        for(int i = 0; i < N; ++i) roots[i] = i;\n        for(int i = 0; i < M; ++i) {\n            const Road &r = roads[i];\n            if(getroot(r.a, roots) == getroot(r.b, roots)) continue;\n            unite(r.a, r.b, roots, levels);\n            ans += r.dist/100 - 1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <complex>\n#include <cstring>\n#include <cstdlib>\n#include <string>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\nconst int INF = 1<<29;\n\n\ntypedef int Weight;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push( Edge(-1, r, 0) );\n  while (!Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    FOR(f, g[e.dst]) if (!visited[f->dst]) Q.push(*f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main() {\n  int n, m;\n  while (cin >> n, n) {\n    cin >> m;\n    Graph g(n);\n    cin.ignore();\n    REP(i,m) {\n      int a,b,c;\n      scanf(\"%d,%d,%d\\n\", &a,&b,&c);\n      g[a].push_back(Edge(a,b,c));\n      g[b].push_back(Edge(b,a,c));\n    }\n    cout << prim(g).first / 100 - n + 1 << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define sc(x) cin >> x\n#define sc2(x, y) cin >> x >> y\n#define sc3(x, y, z) cin >> x >> y >> z\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define debugn(i, n, a) rep(i, n)cout << \" --- \" << a[i] << \"\\n\";\n#define debugin(i, n, a) rep(i, n)printf(\" --- %10d\\n\", a[i])\n#define debugi2n(i, n, a, b) rep(i, n)printf(\" --- %10d %10d\\n\", a[i], b[i])\n#define debugiin(i, n, a) rep(i, n)printf(\" --- %10d %10d\\n\", a[i].first, a[i].second)\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct unionfind{\n\tvector<int> data;\n\tvoid use(int n){ data.assign(n, -1); }\n\tbool unionset(int x, int y){\n\t\tx = root(x); y = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x])swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findset(int x, int y){ return root(x) == root(y); }\n\tint root(int x){ return (data[x] < 0) ? x : data[x] = root(data[x]); }\n\tint size(int x){ return -data[root(x)]; }\n};\n\nstruct edge{\n  int to, cost;\n};\n\nvector<edge> G[100];\n\nbool mycom(pair<edge, int> a, pair<edge, int> b){\n  return a.X.cost < b.X.cost;\n}\n\nll kruskal(int v, int e){\n  ll res = 0;\n  int i, j;\n  unionfind U; U.use(v);\n  vector< pair<edge, int> > lis;\n  rep(i, v)rep(j, G[i].size())lis.pb(mp(G[i][j], i));\n  sort(all(lis), mycom);\n  for(i = 0;i < e;i++){\n    pair<edge, int> tmp = lis[i];\n    if(!U.findset(tmp.X.to, tmp.Y)){\n      res += tmp.X.cost;\n      U.unionset(tmp.X.to, tmp.Y);\n    }\n  }\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;;testcase++){\n    int(n);\n    if(n == 0)break;\n    rep(i, n)G[i].clear();\n    int(m);\n    rep(i, m){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      d = (d - 100) / 100;\n      G[a].pb((edge){b, d});\n      G[b].pb((edge){a, d});\n    }\n    pri(kruskal(n, m * 2));\n\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct br{\n\tint n1,n2,w;\n};\nbool f(br i,br j){\n\treturn(i.w>j.w);\n}\nint main(){\n\twhile(1){\n\t\tint m,n,i,x=0;\n\t\tchar c;\n\t\tcin>>n; if(n==0)break;\n\t\tvector<int>T(n);\n\t\tfor(i=0;i<n;i++) T[i]=i;\n\n\t\tcin>>m;\n\t\tvector<br>S(m);\n\t\tfor(i=0;i<m;i++) cin>>S[i].n1>>c>>S[i].n2>>c>>S[i].w;\n\t\tsort(S.begin(),S.end(),f);\n\n\t\twhile (S.size()){\n\t\t\tbr B=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[B.n1],c=T[B.n2],a;\n\t\t\tb>c?(a=c,c=b):a=b;\n\t\t\tif(b!=c){\n\t\t\t\tfor(i=c;i<n;i++)\n\t\t\t\t\tif(T[i]==c)T[i]=a;\n\t\t\t\tx+=B.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<map>\n#include<string>\nusing namespace std;\n  \nstruct Edge{\n    int a,b,d;\n    bool operator < (const Edge a)const{\n        return d < a.d;\n    }\n};\n  \nint par[100],rank_[100];\nvoid init(int n){ for(int i = 0; i < n; i++) par[i] = i, rank_[i] = 1;}\nint find(int x){  if(par[x] == x) return x;return par[x] = find(par[x]);}\nbool unite(int _a,int _b){\n    int a = find(_a), b = find(_b);\n    if(a == b) return false;\n    if(rank_[a]>rank_[b]) par[b] = a;\n    else{par[a] = b;if(rank_[a]==rank_[b]) rank_[b]++;}\n    return true;\n}\n  \nint main(){\n    int N,M;\n    while(cin >> N , N){\n        init( N );\n        cin >> M;\n        Edge e[10000];\n        for(int i = 0;i < M; i++) scanf(\"%d,%d,%d\",&e[i].a,&e[i].b,&e[i].d);\n        sort(e,e+M);\n        int ans = 0;\n        for(int i = 0; i < M; i++){\n            if(unite(e[i].a, e[i].b)) ans += e[i].d/100-1;\n            \n        }\n        printf(\"%d\\n\" ,ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n#include<cmath>\n#define MAX 1000\n#define INF 1<<30\nusing namespace std;\nint V,E,cost[MAX][MAX],from,to,Cost;\nbool used[MAX];\nint mincost[MAX];\n\nint prim(){\n  int ans = 0;\n  for(int i=0;i<V;i++){\n    used[i] = false;\n    mincost[i] = INF;\n  }\n  mincost[0] = 0;\n\n  while(true){\n    int v = -1;\n    for(int i=0;i<V;i++){\n      if(!used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n    }\n    if(v == -1)break;\n    used[v] = true;\n    ans += mincost[v];\n\n    for(int i=0;i<V;i++){\n      mincost[i] = min(mincost[i],cost[v][i]);\n    }\n  }\n\n\n  return ans;\n\n}\n\nint main(){\n  \n\n  for(int i=0;i<MAX;i++)for(int j=0;j<MAX;j++)cost[i][j] = INF;\n\n  while(cin >> V && V){\n    cin >> E;\n    for(int i=0;i<V;i++){\n      scanf(\"%d,%d,%d\\n\",&from,&to,&Cost);\n      cost[from][to] = cost[to][from] =  Cost;\n    }\n\n    cout <<  prim()/100 - (V-1) << endl;\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\ninline int to_int(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string to_str(T x) {ostringstream sout; sout << x; return sout.str();}\n\ntypedef long long ll;\n\nstruct edge{\n\tint to, from, cost;\n};\nint par[101], rank[101];\n\nvoid init(int n)\n{\n\t//初期化して、すべての要素を親にする\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\t//要素の親を辿って、根を見つける\n\t//グループである証\n\tif(par[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nbool same(int x, int y)\n{\n\t//同じグループに所属しているかどうか\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\t//同じグループならすでに結合している。\n\tif(x == y)\n\t{\n\t\treturn;\n\t}\n\t//高さがxのほうが大きい時は\n\t//yのグループをxにする。\n\t//逆もまたSIKARI\n\tif(rank[x] > rank[y])\n\t{\n\t\tpar[y] = x;\n\t}\n\telse\n\t{\n\t\tpar[x] = y;\n\t\t\n\t\t//同じ高さの時は、\n\t\t//xの高さを増やす。\n\t\tif(rank[x] == rank[y])\n\t\t{\n\t\t\trank[x]++;\n\t\t}\n\t}\n}\n\nbool comp(const edge &a, const edge &b)\n{\n\treturn a.cost < b.cost;\n}\n\nint main()\n{\n\tint n, m, c, total;\n\twhile(cin >> n, n)\n\t{\n\t\ttotal = 0;\n\t\tcin >> m;\n\n\t\tinit(n);\n\n\t\tedge dis[m];\n\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d,%d,%d\", &dis[i].from, &dis[i].to, &c);\n\t\t\tc /= 100; c--;\n\t\t\tdis[i].cost = c;\n\t\t}\n\t\tsort(dis, dis+m, comp);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tedge a = dis[i];\n\t\t\tif(!same(a.to, a.from))\n\t\t\t{\n\t\t\t\tunite(a.to, a.from);\n\t\t\t\ttotal += a.cost;\n\t\t\t}\n\t\t}\n\t\tcout << total << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000000;\nconst int MAX_V = 10000;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint V;\n\nint prim() {\n  for ( int i = 0; i < V; ++i ) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true) {\n    int v = -1;\n    for ( int u = 0; u < V; u++ ) {\n      if ( !used[u] && ( v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n     \n    if ( v == -1 ) break;\n    used[v] = true;\n    res += mincost[v];\n\n    for ( int u = 0; u < V; u++ ) {\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\n\nint main() {\n  int m;\n  while( cin >> V >> m,V ) {\n    for ( int i = 0; i < V; i++ ) {\n      for ( int j = 0; j < m; j++ ) {\n\tcost[i][j] = INF;\n      }\n    }\n    for ( int i = 0; i < m; i++ ) {\n      char ch; int a,b,c;\n      cin >> a >> ch >> b >> ch >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    int ans = prim();\n    cout << (ans/100) - (V-1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#define INF 10000\nusing namespace std;\nint n;\nint c[100][100],mi[100];\nbool ud[100];\nint pr(){\n  int r=0;\n  while(1){\n    int v=-1;\n    for(int u=0;u<n;++u){\n      if(!ud[u]&&(v==-1||mi[u]<mi[v])) v=u;\n    }\n    if(v==-1)break;\n    ud[v]=true;\n    r+=mi[v];\n    for(int u=0;u<n;++u) mi[u]=min(mi[u],c[v][u]);\n  }\n  return r;\n}\nint main(){\n  int m,x,y,z;\n  while(scanf(\"%d\",&n)&&n){\n    for(int i=0;i<n;++i){\n      mi[i]=INF;ud[i]=false;\n      for(int j=0;j<n;++j) c[i][j]=INF;\n    }\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d,%d,%d\",&x,&y,&z);\n      c[y][x]=c[x][y]=z/100-1;\n    }\n    mi[0]=0;\n    printf(\"%d\\n\",pr());\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include \"stdio.h\"\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge{\n    Edge(int t, int c)\n        : to(t), cost(c) {}\n\n    int to;\n    int cost;\n};\n\nbool visited[100];\nvector<Edge> G[100];\ntypedef pair<int, int> PII;\n\nint prim(int start){\n    int ans = 0;\n    fill(visited, visited+100, false);\n\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n\n    que.push(PII(0, start));\n    while (!que.empty()){\n        PII p = que.top();\n        int v = p.second;\n        int cst = p.first;\n        que.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        ans += cst;\n        for (int i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            que.push(PII(G[v][i].cost, G[v][i].to));\n        }\n    }\n\n    return ans;\n} \n\nint main(int argc, char const *argv[]){\n    int n, m;\n\n    while (cin>>n, n){\n        cin>>m;\n        for (int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            d = (d-100) / 100;\n            G[a].push_back(Edge(b, d));\n            G[b].push_back(Edge(a, d));\n        }\n\n        cout<<prim(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\n#define INF 10000000\n#define MAX_V 100\nusing namespace std;\nint n,m;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint prim(){\n  int res = 0;\n  fill(mincost,mincost + n,INF);\n  fill(used,used + n,false);\n\n  mincost[0] = 0;\n  while(1){\n\n    int v = -1;\n\n    for(int u = 0 ; u < n ; u++ ){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v]))v = u;\n    }\n    if(v == -1)break;\n    cout << 1 << endl;\n    used[v] = true;\n    res += mincost[v];\n    for(int i = 0 ; i < n ; i++ ){\n      mincost[i] = min(mincost[i],cost[i][v]);\n    }\n  }\n  return res;\n}\n\nint main(){\n\n  char ch;\n  while(cin >> n,n){\n    cin >> m;\n    for(int i = 0 ; i < n ; i++ ){\n      for(int j = 0 ; j < n ; j++ ){\n\tcost[i][j] = INF;\n      }\n    }\n    for(int i = 0 ; i < m ; i++ ){\n      int a,b,c;\n      cin >> a >> ch >> b >> ch >> c;\n      cost[a][b] = cost[b][a] = (c-100)/100;\n    }\n    cout <<  prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<stdio.h>\n#include<string>\n#include<stdlib.h>\n#include<math.h>\n#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<numeric>\n#include<string.h>\n#include<map>\n#include<queue>\n\nusing namespace std;\n\ntypedef pair<int,int> pii;\n\n#define rep(i,j) for(int i=0;i<(j);i++)\n#define reps(i,j,k) for(int i=j;i<=k;i++)\n#define in(i,j,k) ((i)>=(j)&&(i)<=(k))\n#define N 100\n\nconst char dx[]={0,1,0,-1},dy[]={1,0,-1,0};\n\nint u[N],r[N];\n\nint find(int x){\n\treturn x == u[x] ? x : find(u[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)return;\n\tif(r[x]<r[y])u[x]=y;\n\telse u[y]=x;\n\tr[x] += r[x] == r[y];\n}\n\nint main(){\n\tint n, m, a, b, d, c;\n\tfor(;;){\n\t\tscanf(\"%d\", &n);\n\t\tif(!n) break;\n\t\tscanf(\"%d\", &m);\n\t\tvector< pair<int, pair<int, int> > > v;\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tu[i] = i;\n\t\t\tr[i] = 0;\n\t\t}\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tv.push_back( make_pair(d / 100 - 1, make_pair(min(a, b), max(a, b))));\n\t\t}\n\t\tsort(v.begin(), v.end());\n\t\t\n\t\tc = 0;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\ta = v[i].second.first;\n\t\t\tb = v[i].second.second;\n\t\t\tif(find(a) != find(b)){\n\t\t\t\tunite(a, b);\n\t\t\t\tc += v[i].first;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",c);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <map>\nusing namespace std;\nint cost[100][100];\nconst int INF = 1000000;\nint prim(int n,int s){\n\ttypedef pair<int,int> P;\n\tbool ischeck[n];\n\tint mincost = 0;\n\tpriority_queue<P,vector<P>,greater<P> > pq;\n\tP p,tp;\n\tfor(int i = 0;i < n;++i){\n\t\tischeck[i] = false;\n\t\tif(cost[s][i] != INF){\n\t\t\tp.first = cost[s][i];\n\t\t\tp.second = i;\n\t\t\tpq.push(p);\n\t\t}\n\t}\n\tischeck[s] = true;\n\twhile(!pq.empty()){\n\t\tp = pq.top();\n\t\tpq.pop();\n\t\tif(ischeck[p.second]) continue;\n\t\telse{\n\t\t\tischeck[p.second] = true;\n\t\t\tmincost += p.first;\n\t\t\tfor(int i = 0;i < n;++i){\n\t\t\t\tif(cost[p.second][i] != INF){\n\t\t\t\t\ttp.first = cost[p.second][i];\n\t\t\t\t\ttp.second = i;\n\t\t\t\t\tpq.push(tp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn mincost;\n}\nint main(){\n\tint n,m,a,b,c;\n\twhile(cin >> n,n){\n\t\tfor(int i = 0;i < 100;++i){\n\t\t\tfor(int j = 0;j < 100;++j){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tfor(int i = 0;i < m;++i){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tcost[a][b] = cost[b][a] = c / 100 - 1;\n\t\t}\n\t\tcout << prim(n,0) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <vector>\n#include <set>\n#include <algorithm>\n#include <functional>\n#include <cstdio>\nusing namespace std;\n\ntypedef pair<int,int> P;\n\nconst int MAX = 10000;\nconst int INF = 999999;\n\nint V;\nint m;\n\nint prim (vector<vector<P> > G) {\n    set<int> used;\n    priority_queue<P, vector<P>, greater<P> > que;\n    for (int i = 0; i < V; i++) {\n        used.insert(i);\n    }\n    int res = 0;\n    int v = 0;\n    while (!used.empty()) {\n        for (auto i : G[v])   que.push(i);\n        P p;\n        while (used.find(que.top().second) == used.end()) {\n            que.pop();\n        }\n        if (que.empty() || que.top().second == v) break;\n        used.erase(used.find(v));\n        p = que.top(); que.pop();\n        v = p.second;\n        res += p.first;\n    }\n\n    return res;\n}\n\nint main ()\n{\n    while (cin >> V, V) {\n        cin >> m;\n        vector<vector<P> >  G(V); // toEadge isCost\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            c /= 100;\n            G[a].push_back(P(c,b));\n            G[b].push_back(P(c,a));\n        }\n\n        cout << prim(G) - V + 1 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(i=0;i<n;i++)\nstruct branch{\n\tint n1, n2, w;\n};\nbool greater(branch i, branch j){\n\treturn (i.w > j.w);\n}\nint main(){\n\twhile (1){\n\t\tint n,i;\n\t\tchar c;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tvector <int> T(n);\n\t\tREP(i,n) T[i] = i;\n\n\t\tint m;\n\t\tcin >> m;\n\t\tvector <branch> S(m);\n\t\tREP(i,m) cin >> S[i].n1 >> c>>S[i].n2 >> c>>S[i].w;\n\n\t\tsort(S.begin(), S.end(),greater);\n\n\t\tint a = 0;\n\t\twhile (S.size()){\n\t\t\tbranch tmp = S.back();\n\t\t\tS.pop_back();\n\t\t\tint b = T[tmp.n1], c = T[tmp.n2];\n\t\t\tif (b != c){\n\t\t\t\tREP(i,n)\n\t\t\t\t\tif (T[i] == c) T[i] = b;\n\t\t\t\ta += tmp.w / 100 - 1;\n\t\t\t}\n\t\t}\n\t\tcout << a << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  \n \nusing namespace std;\n \n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define repr(i, j) for(int i = j; i >= 0; -i)\n#define INF (1 << 30)\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\nint par[100001], Rank[100001];\n\n//n????´???§?????????\nvoid init(int n) {\n\trep(i, n) {\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//??¨??????????±???????\nint find(int x) {\n\tif(par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\n//x??¨y????±??????????????????????\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(Rank[x] < Rank[y]) par[x] = y;\n\telse par[y] = x;\n\tif(Rank[x] == Rank[y]) ++Rank[x];\n}\n\n//x??¨y???????????????????±????????????????\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nstruct edge {int u, v, cost; };\nint N, M;\nedge es[100000];\n\nbool comp(const edge &a, const edge &b){\n\treturn a.cost < b.cost;\n}\n\nint kruskal() {\n\tsort(es, es + M, comp);\n\tinit(N);\n\tint res = 0;\n\trep(i, M) {\n\t\tedge &e = es[i];\n\t\tif(!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n    while(scanf(\"%d\", &N), N) {\n    \tscanf(\"%d\", &M);\n    \trep(i, M) {\n    \t\tint a, b, c;\n    \t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n    \t\tc = c / 100 - 1;\n    \t\tedge tmp = {a, b, c};\n    \t\tes[i] = tmp;\n    \t}\n        printf(\"%d\\n\", kruskal());\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\n#include<vector>\n#include<string>\n#include<iostream>\n#include<queue>\n#include<map>\n#include<set>\n#include<complex>\n#include<stack>\n#include<cmath>\n \nusing namespace std;\n \n#define reps(i,f,n) for(int i=f;i<int(n);i++)\n#define rep(i,n) reps(i,0,n)\n\n#ifdef __BORLANDC__\n\ttypedef __int64 ll;\n#else\n\ttypedef long long ll;\n#endif\n\n\n\n\nclass Prim{\n\tpublic:\n\tstatic const int PN = 1000;\n\ttypedef pair<int,int> pii;\n\t\n\t\n\tvector<pii> edge[PN];\n\tPrim(){\n\t\trep(i,PN)edge[i].clear();\n\t}\n\t\n\tvoid add_edge(int a,int b, int c){\n\t\tedge[a].push_back(pii(b,c));\n\t}\n\t\n\tclass Q{\n\t\tpublic:\n\t\tint pos;\n\t\tint val;\n\t\tQ(int pos,int val):pos(pos),val(val){};\n\t\tbool operator<(const Q& a)const{\n\t\t\tif(val!=a.val)return val>a.val;\n\t\t\treturn pos>a.pos;\n\t\t}\n\t};\n\t\n\tint visit[PN];\n\tint solve(int st){\n\t\trep(i,PN)visit[i]=0;\n\t\tpriority_queue<Q> que;\n\t\tque.push(Q(st,0));\n\t\t\n\t\tint ret = 0;\n\t\twhile(!que.empty()){\n\t\t\tQ u = que.top();\n\t\t\tque.pop();\n\t\t\t\n\t\t\tif(visit[u.pos]==1)continue;\n\t\t\tvisit[u.pos]=1;\n\t\t\t\n\t\t\tret += u.val;\n\t\t\t\n\t\t\trep(i,edge[u.pos].size()){\n\t\t\t\tpii e = edge[u.pos][i];\n\t\t\t\tque.push(Q(e.first, e.second));\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\t\n};\n\nint main(){\n\tint n,m;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\t\n\t\tPrim prim;\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tint d = (c+99)/100-1;\n\t\t\tprim.add_edge(a,b,d);\n\t\t\tprim.add_edge(b,a,d);\n\t\t\t\n\t\t}\n\t\t\n\t\tcout<<prim.solve(0)<<endl;\n\t\t\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 999999;\nstruct SEdge\n{\n\tint To;\n\tint Cost;\n};\nint V, E;\nvector<int> mincost;\nvector< vector<SEdge> > G;\nbool used[128];\n\nint Prim()\n{\n\tfill(used, used + V, false);\n\tfill(mincost.begin(), mincost.end(), INF);\n\tmincost[0] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > PQue;\n\tPQue.push(P(0, 0));\n\tint res = 0;\n\twhile(!PQue.empty())\n\t{\n\t\tP p = PQue.top();\n\t\tPQue.pop();\n\t\tint v = p.second;\n\t\tif(mincost[v] < p.first || used[v])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tused[v] = true;\n\t\tres += p.first;\n\t\tfor(int i = 0; i < G[v].size(); ++i)\n\t\t{\n\t\t\tSEdge e = G[v][i];\n\t\t\tif(mincost[e.To] > e.Cost)\n\t\t\t{\n\t\t\t\tmincost[e.To] = e.Cost;\n\t\t\t\tPQue.push(P(mincost[e.To], e.To));\n\t\t\t}\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> V, V)\n\t{\n\t\tcin >> E;\n\t\tmincost.resize(V);\n\t\tG.resize(V);\n\t\tfor(int i = 0; i < E; ++i)\n\t\t{\n\t\t\tint From, To, Cost;\n\t\t\tscanf(\"%d,%d,%d\", &From, &To, &Cost);\n\t\t\tSEdge e1, e2;\n\t\t\te1.To = To;\n\t\t\te2.To = From;\n\t\t\te1.Cost = e2.Cost = Cost / 100 - 1;\n\t\t\tG[From].push_back(e1);\n\t\t\tG[To].push_back(e2);\n\t\t}\n\t\tcout << Prim() << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = 1000000000;\nconst double PI = acos(-1);\nLL n, m, a[100000] = {}, x[10000][3] = {}, ans = 0;\nstruct edge { int cost, to; };\nint  par[100000];  // ?????????????????????????´? \nint find(int x) { if (par[x] == x)return x; par[x] = find(par[x]); return par[x]; }\nvoid unite(int x, int y) { x = find(x); y = find(y); if (x == y)return; par[x] = y; }\nbool same(int x, int y) { return find(x) == find(y); }\nvector<edge>vec[10000];\nstring S[100],str1,str2;\nint main() {\n\twhile (cin >> n&&n) {\n\t\tans = 0;\n\tfor(int i=0;i<100000;i++)par[i]=i;  // ????????????????????????\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint  a, b, c;\n\t\t\tchar z;\n\t\t\tcin >> a >> z >> b >> z >> c;\n\t\t\tx[i][0] = min(a, b), x[i][1] = max(a, b), x[i][2] = c / 100 - 1;\n\t\t}\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tif (x[i][2] > x[j][2]) {\n\t\t\t\t\tfor (int h = 0; h < 3; h++) {\n\t\t\t\t\t\tint a = x[i][h];\n\t\t\t\t\t\tx[i][h] = x[j][h];\n\t\t\t\t\t\tx[j][h] = a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (find(x[i][0]) != find(x[i][1])) {\n\t\t\t\tunite(x[i][0], x[i][1]);\n\t\t\t\tans += x[i][2];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\nstruct edge{\n  int a,b,c;\n  bool operator<(const edge &e) const {\n    return c < e.c;\n  }\n};\n\nstruct uni{\n  int d[111];\n  void init(){\n    memset(d,-1,sizeof(d));\n  }\n  int find(int a){ return d[a]<0?a:(d[a]=find(d[a])); }\n  void marge(int a,int b){\n    a = find(a); b = find(b);\n    if( a == b ) return;\n    if( d[a] > d[b] ) swap(a,b);\n    d[a]+=d[b]; d[b] = a;\n  }  \n  bool same(int a,int b){\n    return find(a) == find(b);\n  }\n};\n\nint N,M;\nint main(){\n  while( ~scanf(\"%d\",&N) && N ){\n    scanf(\"%d\",&M);\n    vector<edge> E;    \n    for(int i=0;i<M;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      c/=100; c--;\n      E.push_back( (edge){a,b,c} );\n    }\n    sort(E.begin(),E.end());\n    uni U; U.init();\n    int res = 0;\n    for(int i=0;i<M;i++){\n      edge &e=E[i];\n      if( U.same(e.a,e.b) ) continue;\n      U.marge(e.a,e.b);\n      res+=e.c;\n    }\n    cout << res << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nconst int INF= 1e9;\n\nstruct edge{\n  int from, to, cost;\n  edge(int x,int y, int z):from(x),to(y),cost(z){}\n  bool operator<(const edge &x)const{ return cost<x.cost; }\n};\n\n\nclass Prim{\n  int n;\n  vector< vector<edge> > g;\npublic:\n  Prim(int a=0):n(a){ g.resize(n); }\n\n  void AddEdge(int a, int b, int cost){\n    g[a].push_back(edge(a,b,cost));\n    g[b].push_back(edge(b,a,cost));\n  }\n\n  int MinSpanningTree(){\n    int res = 0;\n    vector<int> d(n,INF); d[0] = 0;\n    vector<bool> use(n,0);\n\n    for(;;){\n      int v = -1;\n      for(int u=0;u<n;u++){\n\tif(!use[u] && (v<0 || d[v] > d[u]))v = u;\n      }\n      if(v<0)break;\n      use[v] = 1; res += d[v];\n\n      for(int i=0;i<(int)g[v].size();i++){\n\td[g[v][i].to] = min( d[g[v][i].to], g[v][i].cost);\n      }\n    }\n    return res;\n  }\n};\n\nint main(){\n  int n,m;\n  while(scanf(\"%d\",&n),n){\n    Prim p(n);\n    cin >> m;\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      p.AddEdge(a,b,c/100-1);\n    }\n    cout << p.MinSpanningTree() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <map>\nusing namespace std;\n\nclass UnionFind {\nprivate:\n  int n;\n  int *par, *rank;\npublic:\n  UnionFind(int _n) : n(_n) {\n    par = new int[n];\n    rank = new int[n];\n    for(int i = 0; i < n; ++i) {\n      par[i] = i;\n      rank[i] = 0;\n    }\n  }\n\n  int find(int x) {\n    return par[x] == x ? x : par[x] = find(par[x]);\n  }\n\n  bool same(int x, int y) {\n    return find(x) == find(y);\n  }\n\n  void unite(int x, int y) {\n    x = find(x);\n    y = find(y);\n    if(rank[x] < rank[y]) {\n      par[x] = y;\n    } else {\n      par[y] = x;\n      if(rank[x] == rank[y]) ++rank[x];\n    }\n  }\n};\n\nconst int MAXN = 101;\nint N, M;\n\nint main() {\n  while(cin >> N && N) {\n    cin >> M;\n    vector<pair<int,pair<int,int> > > v;\n    while(M--) {\n      string s;\n      cin >> s;\n      replace(s.begin(), s.end(), ',', ' ');\n      stringstream ss(s);\n      int a, b, c;\n      ss >> a >> b >> c;\n      v.push_back(make_pair(c/100-1, make_pair(a,b)));\n    }\n    sort(v.begin(), v.end());\n    UnionFind uf(N);\n    int res = 0;\n    for(int i = 0; i < v.size(); ++i) {\n      if(!uf.same(v[i].second.first, v[i].second.second)) {\n        uf.unite(v[i].second.first, v[i].second.second);\n        res += v[i].first;\n      }\n    }\n    cout << res << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\n#define INF 1e9\n#define MAX_N 100\n\nint n, m;\nint cost[MAX_N][MAX_N];\nbool used[MAX_N];\nint mincost[MAX_N];\n\nusing namespace std;\n\nint prim(void)\n{\n    //init\n    REP(i,n){\n        used[i] = false;\n        mincost[i] = INF;\n    }\n    //start from 0th vertex\n    mincost[0] = 0; \n    //search\n    int dist = 0;\n    while(true){\n        //search the edge with minimum cost\n        int v = -1;\n        REP(u,n) if(!used[u] && (v==-1||mincost[u]<mincost[v])) v = u;\n        if(v == -1) break;\n        //set v as used vertex\n        used[v] = true;\n        dist += mincost[v];\n        //update minimum cost\n        REP(u,n) mincost[u] = min(mincost[u], cost[v][u]);\n    }\n    return dist;\n}\n\nvoid solve(void)\n{\n    while(true){\n        scanf(\"%d\", &n);\n        if(n==0) return;\n        scanf(\"%d\", &m);\n        REP(i,n) REP(j,n) cost[i][j] = INF;\n        REP(i,m){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            cost[a][b] = d/100-1;\n        } \n        printf(\"%d\\n\", prim());\n    }\n}\n\nint main(void)\n{\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint e[100][100];\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tint m;\n\t\tint ans=0;\n\t\tcin>>m;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\te[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\twhile(m--) \n\t\t{\n\t\t\tint l,r,c;\n\t\t\tscanf(\"%d,%d,%d\",&l,&r,&c);\n\t\t\te[l][r]=e[r][l]=c;\n\t\t}\n\n\t\tbool f[n];\n\t\tfill(f,f+n,0);\n\n\t\tint cnt=1;\n\t\tf[0]=true;\n\t\twhile(cnt<n)\n\t\t{\n\t\t\tint mn=INT_MAX,num;\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (f[i])\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!f[j]&&e[i][j]!=-1&&e[i][j]<mn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmn=e[i][j];\n\t\t\t\t\t\t\tnum=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tans+=mn-100;\n\t\t\tf[num]=true;\n\t\t}\n\t\tcout<<ans/100<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\n#define rep(i,j) for(int i=0; i<j; i++ )\n#define INF 10000000\n\nint main(){\n    int n;\n    while( scanf(\"%d\",&n), n ){\n        int m;\n        int map[100][100];\n        scanf(\"%d\", &m);\n        rep(i,100) rep(j,100) map[i][j] = INF;\n        rep(i,m){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            map[a][b] = map[b][a] = d;\n        }\n        int count=0, memo[100], minIndex = 0;\n\t\tbool used[100];\n        rep(i,n){\n\t\t\tmemo[i] = map[0][i];\n\t\t\tused[i] = false;\n\t\t}\n\t\tmemo[0] = INF;\n\t\tused[0] = true;\n        rep(i,n-1){\n            rep(j,n){\n                if( memo[j] < memo[minIndex] ){\n                    minIndex = j;\n                }\n            }\n\t\t\tcount += memo[minIndex]/100-1;\n\t\t\tused[minIndex] = true;\n\t\t\tmemo[minIndex] = INF;\n\t\t\trep(j,n)\n\t\t\t\tif( !used[j] )\n\t\t\t\t\tmemo[j] = min( memo[j], map[minIndex][j] );\n        }\n\t\tprintf(\"%d\\n\", count);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n#define REP(i,n) for(i=0;i<n;i++)\n\nstruct branch{\n\tint n1, n2, w;\n};\nbool f(branch i, branch j){\n\treturn (i.w > j.w);\n}\nint main(){\n\twhile (1){\n\t\tint n,i;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int>T(n);\nT.clear();\n\n\t\tbranch tmp;\n\t\tint m; cin>>m;\n\t\tvector<branch>S(m);\n\t\tREP(i,m){\n\t\t\tcin>>tmp.n1>>c>>tmp.n2>>c>>tmp.w;\n\t\t\tS[i]=tmp;\n\t\t\tT[tmp.n1]=tmp.n1;\n\t\t\tT[tmp.n2]=tmp.n2;\n\t\t}\n\n\t\tsort(S.begin(), S.end(),f);\n\n\t\tint a = 0;\n\t\twhile(S.size()){\n\t\t\ttmp=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[tmp.n1], c=T[tmp.n2];\n\t\t\tif (b!=c){\n\t\t\t\tfor(i=b+1;i<n;i++)\n\t\t\t\t\tif (T[i]==c)T[i]=b;\n\t\t\t\ta += tmp.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<a<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_V = 100000;\n\n//union-find tree defenition\n\nint par[MAX_V];\n\nvoid init(int n){\n    for(int x = 0; x < n;x++){\n        par[x] = -1;\n    }\n}\n\nint find(int x){\n    if(par[x] < 0) return x;\n    return par[x] = find(par[x]);\n}\n\nbool same(int a, int b){\n    return find(a) == find(b);\n}\n\nbool unite(int a, int b){\n    int xa = find(a), xb = find(b);\n    if(xa == xb) return false;\n    if(par[xa] < par[xb]){\n        par[xb] = xa;\n    }else{\n        if(par[xa] == par[xb]){\n            par[xb]--;\n        }\n        par[xa] = xb;\n    }\n    return true;\n}\n\n//END union-find tree definition\n\nstruct edge{\n    int from;\n    int to;\n    int cost;\n    edge(){}\n    ~edge(){}\n    edge(int a, int b, int c) : from(a), to(b), cost(c){}\n    bool operator < (const edge& r) const {\n        return cost > r.cost;\n    }\n};\n\nvector<edge> G;\nint V;\n\nvoid append_edge(int from, int to, int cost){\n    G.push_back(edge(from, to, cost));\n}\n\nvoid append_edge_u(int from, int to, int cost){\n    G.push_back(edge(from, to, cost));\n    G.push_back(edge(to, from, cost));\n}\n\nint kruskal(void){\n    init(V);\n    priority_queue<edge> que;\n    for(int i = 0; i < G.size(); i++){\n        que.push(G[i]);\n    }\n    int ret = 0;\n    while(true){\n        edge e = que.top(); que.pop();\n        if(!unite(e.from, e.to)) break;\n        ret += (e.cost - 2) / 100;\n    }\n    return ret;\n}\n\nint main(){\n    int m, a, b, c;\n    while(scanf(\"%d%d\", &V, &m) != EOF && V){\n        for(int x = 0; x < m; x++){\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            append_edge(a, b, c);\n        }\n        int res = kruskal();\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <cstdio>\n#include <cstring>\n#include <map>\nusing namespace std;\ntypedef pair<int,int>PAIR;//cost/pos\nint main(){\n\tint N,M;\n\twhile(cin>>N,N){\n\t\tcin>>M;\n\t\tint ans=0,cnt=0;\n\t\tbool flag[100]={0};\n\t\tint load[100][100];\n\t\tmemset(load,-1,sizeof(load));\n\t\tfor(int i=0,A,B,C;i<M;i++){\n\t\t\tscanf(\"%d,%d,%d\",&A,&B,&C);\n\t\t\tC=C/100-1;\n\t\t\tload[A][B]=load[B][A]=C;\n\t\t}\n\t\tpriority_queue<PAIR,vector<PAIR>,greater<PAIR> > Q;\n\t\tQ.push(make_pair(0,0));\n\t\tfor(int now,cost;!Q.empty();){\n\t\t\tcost=Q.top().first;\n\t\t\tnow=Q.top().second;\n\t\t\tQ.pop();\n\t\t\tif(flag[now]==0){\n\t\t\t\tflag[now]=1;\n\t\t\t\tans+=cost;\n\t\t\t\tcnt++;\n\t\t\t\tfor(int i=0;i<N;i++)if(load[now][i]>0&&flag[i]==0)Q.push(make_pair(load[now][i],i));\n\t\t\t}\n\t\t\tif(cnt==N)break;\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\t\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n#define INF (1 << 21)\n\nint main(){\n  int n,m;\n  int a,b,ab;\n  int cost[101][101];\n  int min_cost[101];\n  bool used[101];\n  while(1){\n    cin >> n;\n    if(n == 0) break;\n    cin >> m;\n    for(int i=0;i<101;i++){\n      for(int j=0;j<101;j++){\n\tcost[i][j] = INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&ab);\n      cost[a][b] = ab / 100 - 1;\n      cost[b][a] = ab / 100 - 1;\n    }\n    for(int i=0;i<n;i++){\n      min_cost[i] = INF;\n      used[i] = false;\n    }\n    min_cost[0] = 0;\n    int ans = 0;\n    while(1){\n      int v = -1;\n      for(int i=0;i<n;i++){\n\tif(!used[i] && (v == -1 || min_cost[i] < min_cost[v])){\n\t  v = i;\n\t}\n      }\n      if(v == -1) break;\n      used[v] = true;\n      ans += min_cost[v];\n      for(int i=0;i<n;i++){\n\tmin_cost[i] = min(min_cost[i],cost[v][i]);\n      }\n    }\n    cout << ans << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <string>\n#include <cstring>\n#include <complex>\n#include <ctime>\n#include <cstdlib>\n\nusing namespace std;\n\ninline int to_int(string s) {int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string to_str(T x) {ostringstream sout; sout << x; return sout.str();}\n\ntypedef long long ll;\n\nstruct edge{\n\tint to, from, cost;\n};\nint par[101], rank[101];\n\nvoid init(int n)\n{\n\t//初期化して、すべての要素を親にする\n\tfor(int i = 0; i < n; i++)\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x)\n{\n\t//要素の親を辿って、根を見つける\n\t//グループである証\n\tif(par[x] == x)\n\t{\n\t\treturn x;\n\t}\n\telse\n\t{\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nbool same(int x, int y)\n{\n\t//同じグループに所属しているかどうか\n\treturn find(x) == find(y);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\t//同じグループならすでに結合している。\n\tif(x == y)\n\t{\n\t\treturn;\n\t}\n\t//高さがxのほうが大きい時は\n\t//yのグループをxにする。\n\t//逆もまたSIKARI\n\tif(rank[x] > rank[y])\n\t{\n\t\tpar[y] = x;\n\t}\n\telse\n\t{\n\t\tpar[x] = y;\n\t\t\n\t\t//同じ高さの時は、\n\t\t//xの高さを増やす。\n\t\tif(rank[x] == rank[y])\n\t\t{\n\t\t\trank[x]++;\n\t\t}\n\t}\n}\n\nbool comp(const edge &a, const edge &b)\n{\n\treturn a.cost < b.cost;\n}\n\nint main()\n{\n\tint n, m, c, total;\n\twhile(cin >> n, n)\n\t{\n\t\ttotal = 0;\n\t\tcin >> m;\n\n\t\tinit(m);\n\n\t\tedge dis[m];\n\n\t\tfor(int i = 0; i < m; i++)\n\t\t{\n\t\t\tscanf(\"%d,%d,%d\", &dis[i].from, &dis[i].to, &c);\n\t\t\tc /= 100; c--;\n\t\t\tdis[i].cost = c;\n\t\t}\n\t\tsort(dis, dis+m, comp);\n\n\t\tfor(int i = 0; i < n; i++)\n\t\t{\n\t\t\tedge a = dis[i];\n\t\t\tif(!same(a.to, a.from))\n\t\t\t{\n\t\t\t\tunite(a.to, a.from);\n\t\t\t\ttotal += a.cost;\n\t\t\t}\n\t\t}\n\t\tcout << total << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d\",&m);\n\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost + n,numeric_limits<int>::max());\n\n\n\t\tint** cost = new int*[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcost[i] = new int[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcost[i][j]=numeric_limits<int>::max();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from,to,dist;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&dist);\n\t\t\tcost[from][to] = min(cost[from][to],dist / 100 - 1);\n\t\t\tcost[to][from] = min(cost[to][from],dist / 100 - 1);\n\t\t}\n\n\t\tmincost[0]=0;\n\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tif(!used[u] && (v==-1 || mincost[u] < mincost[v])){\n\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\t\t\n\t\t\tres+=mincost[v];\n\t\t\t\n\t\t\tfor(int u=0;u<n;u++){\n\t\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tcout << res << endl;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdelete[] cost[i];\n\t\t}\n\n\t\tdelete[] cost;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#define _CRT_SECURE_NO_WARNINGS\n#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nint par[120];\nint rnk[120];\nstruct edge { int u, v, cost; };\nbool comp(const edge&e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nvoid init(int n) {\n\tfor (int i = 0;i < n;i++) {\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t}\n}\n\nint find(int a) {\n\tif (par[a] == a)return a;\n\telse return par[a] = find(par[a]);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\n\tif (rnk[x] < rnk[y])par[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif (rnk[x] == rnk[y])rnk[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\nint main() {\n\tint n, m;\n\twhile (cin >> n, n) {\n\t\tcin >> m;\n\t\tedge es[10000];\n\t\tfor (int i = 0;i < m;i++) {\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tes[i].cost = c;\n\t\t\tes[i].u = b;\n\t\t\tes[i].v = a;\n\t\t}\n\t\tint ans =0;\n\t\tsort(es, es + m, comp);\n\t\tinit(n);\n\t\tfor (int i = 0;i < m;i++) {\n\t\t\tedge e = es[i];\n\t\t\tif (!same(e.u, e.v)) {\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tans += e.cost / 100 - 1;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define REP(i,n) FOR(i,0,n)\n\ntypedef pair<int, int> pii;\ntypedef vector<pii> vp;\n\nint main() {\n\twhile (true) {\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif (n == 0) break;\n\t\tcin >> m;\n\t\t\n\t\tvector<vp> g(n);\n\t\tREP(i, m) {\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tg[a].push_back(pii(c / 100, b));\n\t\t}\n\t\n\t\tpriority_queue<pii, vector<pii>, greater<pii> > qu;\n\t\tvector<bool> used(n);\n\t\tint ans = 0;\n\t\t\n\t\tqu.push(pii(0, 0));\n\t\twhile (! qu.empty()) {\n\t\t\tint cost = qu.top().first;\n\t\t\tint pos = qu.top().second;\n\t\t\tqu.pop();\n\t\t\t\n\t\t\tif (used[pos]) continue;\n\t\t\tused[pos] = true;\n\t\t\t\n\t\t\tans += cost;\n\t\t\t\n\t\t\tREP(i, g[pos].size()) {\n\t\t\t\tqu.push(pii(g[pos][i].first, g[pos][i].second));\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans - (n-1) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n//\n//int Kruskal(Graph& g,Edges& e)\n//{\n//\te.clear();\n//\t\n//\tUnionFind uf(g.size());\n//\tset<Edge> s;\n//\trep(i,g.size())\n//\t\trep(j,g[i].size())\n//\t\t\ts.insert(g[i][j]);\n//\t\n//\tint res=0;\n//\tforeach(i,s){\n//\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n//\t\t\tuf.Union(i->src,i->dst);\n//\t\t\tres+=i->weight;\n//\t\t\te.push_back(*i);\n//\t\t}\n//\t}\n//\t\n//\treturn res;\n//}\n\n//typedef int Weight;\n//struct Edge {\n//  int src, dst;\n//  Weight weight;\n//  Edge(int src, int dst, Weight weight) :\n//    src(src), dst(dst), weight(weight) { }\n//};\n//bool operator < (const Edge &e, const Edge &f) {\n//  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n//    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n//}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\n//struct UnionFind {\n//  vector<int> data;\n//  UnionFind(int size) : data(size, -1) { }\n//  bool unionSet(int x, int y) {\n//    x = root(x); y = root(y);\n//    if (x != y) {\n//      if (data[y] < data[x]) swap(x, y);\n//      data[x] += data[y]; data[y] = x;\n//    }\n//    return x != y;\n//  }\n//  bool findSet(int x, int y) {\n//    return root(x) == root(y);\n//  }\n//  int root(int x) {\n//    return data[x] < 0 ? x : data[x] = root(data[x]);\n//  }\n//  int size(int x) {\n//    return -data[root(x)];\n//  }\n//};\n\n//pair<Weight, Edges> minimumSpanningForest(const Graph &g) {\npair<int, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  //priority_queue<Edge> Q;\n  priority_queue<Edge,vector<Edge>,greater<Edge> > Q;\n  rep(u, n) foreach(e, g[u]) if (u < e->dst) Q.push(*e);\n\n  //Weight total = 0;\n  int total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n    //if (uf.unionSet(e.src, e.dst)) {\n    //  F.push_back(e);\n    //  total += e.weight;\n    //}\n\tif(uf.Find(e.src)!=uf.Find(e.dst)){\n\t\tuf.Union(e.src,e.dst);\n\t\tF.push_back(e);\n\t\ttotal+=e.weight;\n\t}\n  }\n  //return pair<Weight, Edges>(total, F);\n  return pair<int, Edges>(total, F);\n}\n\nostream& operator<<(ostream& os,const vi& a)\n{\n\trep(i,a.size())\n\t\tprintf(\"%d%s\",a[i],i==a.size()-1?\"\":\" \");\n\treturn os;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\t//Edges e;\n\t\t//int sum=Kruskal(g,e);\n\t\t////cout<<sum/100-e.size()<<endl;\n\t\t//cout<<sum<<endl;\n\t\t\n\t\tcout<<minimumSpanningForest(g).first<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nstruct Edge {\n\tint a, b, cost;\n};\n\nint n, m;\nint root[100], high[100];\nEdge e[10000];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++)root[i] = i, high[i] = 1;\n}\n\nint getroot(int n) {\n\tif (n == root[n])return n;\n\treturn root[n] = getroot(root[n]);\n}\n\nbool issame(int a, int b) {\n\treturn getroot(a) == getroot(b);\n}\n\nvoid unite(int a, int b) {\n\ta = getroot(a), b = getroot(b);\n\tif (a == b)return;\n\tif (high[a] > high[b])root[b] = a;\n\telse if (high[a] < high[b])root[a] = b;\n\telse root[a] = b, high[a]++;\n}\n\nint main() {\n\twhile(cin >> n ,n ){\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tchar c;\n\t\t\tcin >> e[i].a >> c >> e[i].b >> c >> e[i].cost;\n\t\t\te[i].cost = e[i].cost / 100 - 1;\n\t\t}\n\t\tsort(e, e + m, [](Edge &l, Edge &r) {\n\t\t\treturn l.cost < r.cost;\n\t\t});\n\t\tint ans = 0;\n\t\tinit(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (!issame(e[i].a, e[i].b)) {\n\t\t\t\tunite(e[i].a, e[i].b);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\n\n\nclass union_find{\nprivate:\n  vector<int> parents;\n  vector<int> rank;\npublic:\n  union_find(int n){\n    parents.resize(n);\n    rank.resize(n);\n    for(int i=0;i<n;i++){\n      parents[i]=i;\n      rank[i]=0;\n    }\n  }\n  int find(int x){\n    if(parents[x]==x){\n      return x;\n    }else{\n      return parents[x]=find(parents[x]);\n    }\n  }\n  void unite(int x,int y){\n    x=find(x);\n    y=find(y);\n    if(x==y)return;\n    if(rank[x]<rank[y]){\n      parents[x]=y;\n    }else{\n      parents[y]=x;\n      if(rank[x]==rank[y])rank[x]++;\n    }\n  }\n  bool same(int x,int y){\n    return (find(x)==find(y));\n  }\n};\n\nstruct E{\n  int from,to,cost;\n};\nbool operator<(E a, E b){\n  return a.cost>b.cost;\n}\nint n;\nvector<vector<E>> edge;\n\nbool input(){\n  cin>>n;\n  if(n==0)return false;\n  int m;\n  cin>>m;\n  edge.resize(n);\n  for(int i=0;i<m;i++){\n    int a,b,c;\n    char cc;\n    cin>>a>>cc>>b>>cc>>c;\n    edge[a].push_back(E{a,b,c});\n    edge[b].push_back(E{b,a,c});\n  }\n  return true;\n}\n\nint solve(){\n  priority_queue<E> que;\n  union_find uf(n);\n  for(int i=0;i<edge[0].size();i++){\n    que.push(edge[0][i]);\n  }\n  int ans =0;\n  while(!que.empty()){\n    E now = que.top();que.pop();\n    if(uf.same(now.from,now.to))continue;\n    uf.unite(now.from,now.to);\n    ans += now.cost/100-1;\n    for(int i=0;i<edge[now.to].size();i++){\n      que.push(edge[now.to][i]);\n    }\n  }\n  return ans;\n}\n\n\nint main(){\n  while(input()){\n    cout<<solve()<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<map>\n#include<set>\n#include<algorithm>\n#include<functional>\n#include<cstdio>\n#include<cstdlib>\n#include<cmath>\nusing namespace std;\n\n#define mind(a,b) (a>b?b:a)\n#define maxd(a,b) (a>b?a:b)\n#define absd(x) (x<0?-(x):x)\n#define pow2(x) ((x)*(x))\n#define rep(i,n) for(int i=0; i<n; ++i)\n#define repr(i,n) for(int i=n-1; i>=0; --i)\n#define repl(i,s,n) for(int i=s; i<=n; ++i)\n#define replr(i,s,n) for(int i=n; i>=s; --i)\n#define repf(i,s,n,j) for(int i=s; i<=n; i+=j)\n#define repe(e,obj) for(auto e : obj)\n\n#define SP << \" \" <<\n#define COL << \" : \" <<\n#define COM << \", \" <<\n#define ARR << \" -> \" <<\n#define PNT(STR) cout << STR << endl\n#define POS(X,Y) \"(\" << X << \", \" << Y << \")\"\n#define DEB(A) \" (\" << #A << \") \" << A\n#define DEBREP(i,n,val) for(int i=0; i<n; ++i) cout << val << \" \"; cout << endl\n#define ALL(V) (V).begin(), (V).end()\n#define INF 1000000007\n#define INFLL 10000000000000000007LL\n#define EPS 1e-9\n\ntypedef unsigned int uint;\ntypedef unsigned long ulong;\ntypedef unsigned long long ull;\ntypedef long long ll;\ntypedef long double ld;\ntypedef pair<int, int> P;\n//typedef pair<ll, ll> P;\ntypedef pair<P, int> PI;\ntypedef pair<int, P> IP;\ntypedef pair<P, P> PP;\ntypedef priority_queue<P, vector<P>, greater<P> > pvqueue;\n\nclass UnionFind {\n  vector<int> parent;\npublic:\n  UnionFind(int n) : parent(n) {\n    rep(i, n) parent[i] = i;\n  }\n\n  int root(int x) {\n    if(x == parent[x]) return x;\n    return parent[x] = root(parent[x]);\n  }\n\n  void unite(int x, int y) {\n    if(root(x) == root(y)) return;\n    if(root(x) < root(y)) {\n      parent[y] = root(x);\n    }else {\n      parent[x] = root(y);\n    }\n  }\n\n  bool is_same(int x, int y) {\n    return root(x) == root(y);\n  }\n};\n\nint main() {\n  int n, m;\n  while(cin >> n && n) {\n    cin >> m;\n    UnionFind uf(n);\n    vector<IP> v;\n    rep(i, m) {\n      int a, b, c; char d;\n      cin >> a;\n      while(cin >> d && d!=',');\n      cin >> b;\n      while(cin >> d && d!=',');\n      cin >> c;\n      v.push_back(IP(c/100, P(a, b)));\n    }\n    sort(ALL(v));\n    int ans = 0;\n    rep(i, m) {\n      IP &e = v[i];\n      int c = e.first, a = e.second.first, b = e.second.second;\n      if(!uf.is_same(a, b)) {\n        uf.unite(a, b);\n        ans += c - 1;\n      }\n    }\n    cout << ans << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nconst int INF = 1000000000;\n\nint route[100][100];\nint n, m;\n\nint min_cost();\n\nint main()\n{\n\twhile (scanf(\"%d\", &n) * n != 0){\n\t\tscanf(\"%d\", &m);\n\t\tfill(&route[0][0], &route[99][99], INF);\n\t\tfor (int i = 0; i < m; i++){\n\t\t\tint a, b, cost;\n\t\t\t\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &cost);\n\t\t\tcost = cost / 100 - 1;\n\t\t\troute[a][b] = cost;\n\t\t\troute[b][a] = cost;\n\t\t}\n\t\tprintf(\"%d\\n\", min_cost());\n\t}\n\t\n\treturn 0;\n}\n\nint min_cost()\n{\n\tpriority_queue<P, vector<P>, greater<P> > prim_route;\n\tbool point[100] = {false};\n\tint sum = 0;\n\t\n\tprim_route.push(P(0, 0));\n\twhile (!prim_route.empty()){\n\t\tpair<int, int> p = prim_route.top();\n\t\tprim_route.pop();\n\t\tint from = p.second;\n\t\t\n\t\tif (point[from]){\n\t\t\tcontinue;\n\t\t}\n\t\tpoint[p.second] = true;\n\t\tsum += p.first;\n\t\tfor (int i = 0; i < n; i++){\n\t\t\tif (route[from][i] != INF){\n\t\t\t\tprim_route.push(P(route[from][i], i));\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn sum;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstatic const int INF = 99999999;\nint cost[101][101];\nint mincost[101];\nbool used[101];\nint n;\n\nint prim()\n{\n\tfor(int i = 0; i < n; ++i)\n\t{\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v]))\n\t\t\t{\n\t\t\t\tv = i;\n\t\t\t}\n\t\t}\n\t\tif(v == -1)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tmincost[i] = min(mincost[i], cost[v][i]);\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i = 0; i < 101; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 101; ++j)\n\t\t\t{\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, dist;\n\t\t\tchar c;\n\t\t\tcin >> a >> c >> b >> c >> dist;\n\t\t\tcost[a][b] = dist / 100 - 1;\n\t\t\tcost[b][a] = dist / 100 - 1;\n\t\t}\n\t\t\n\t\tcout << prim() << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<utility>\n\nusing namespace std;\n\n#define NMAX 100*2\n#define NOT -1\n\nstruct mini{\n\tint fr,to,cost;\n};\n\n\nint main(){\n\n\tint n,m;\n\tint a,b,d;\n\tchar gav;\n\tint e[NMAX][NMAX];\n\tbool use[NMAX];\n\tint cost;\n\tmini min;\n\n\twhile(1){\n\n\t\tcin>>n;\n\t\tif(n==0) break;\n\t\tcin>>m;\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\te[i][j]=NOT;\n\t\t\t}\n\t\t}\n\n\t\tfor(int i=0;i<m;i++){\n\t\t\tcin>>a>>gav>>b>>gav>>d;\n\t\t\te[a][b]=d;\n\t\t\te[b][a]=d;\n\t\t}\n\n\t\tfor(int i=0;i<m;i++) use[i]=false;\n\t\tuse[0]=true;\n\t\tcost=0;\n\n\t\twhile(1){\n\t\t\tmin.fr=NOT,min.to=NOT,min.cost=NOT;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tif(use[i]==true){\n\t\t\t\t\tfor(int j=0;j<m;j++){\n\t\t\t\t\t\tif(use[j]==false){\n\t\t\t\t\t\t\tif(e[i][j]!=NOT){\n\t\t\t\t\t\t\t\tif(min.fr==NOT||min.cost>e[i][j]) min.fr=i,min.to=j,min.cost=e[i][j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min.fr==NOT) break;\n\t\t\tuse[min.to]=true;\n\t\t\tcost+=(min.cost)/100-1;\n\t\t}\n\t\tcout<<cost<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_V = 100000;\n\n//union-find tree defenition\n\nint par[MAX_V];\n\nvoid init(int n){\n    for(int x = 0; x < n;x++){\n        par[x] = -1;\n    }\n}\n\nint find(int x){\n    if(par[x] < 0) return x;\n    return par[x] = find(par[x]);\n}\n\nbool same(int a, int b){\n    return find(a) == find(b);\n}\n\nbool unite(int a, int b){\n    int xa = find(a), xb = find(b);\n    if(xa == xb) return false;\n    if(par[xa] < par[xb]){\n        par[xb] = xa;\n    }else{\n        if(par[xa] == par[xb]){\n            par[xb]--;\n        }\n        par[xa] = xb;\n    }\n    return true;\n}\n\n//END union-find tree definition\n\nstruct edge{\n    int from;\n    int to;\n    int cost;\n    edge(){}\n    ~edge(){}\n    edge(int a, int b, int c) : from(a), to(b), cost(c){}\n    bool operator < (const edge& r) const {\n        return cost > r.cost;\n    }\n};\n\nvector<edge> G;\nint V;\n\nvoid append_edge(int from, int to, int cost){\n    G.push_back(edge(from, to, cost));\n}\n\nvoid append_edge_u(int from, int to, int cost){\n    G.push_back(edge(from, to, cost));\n    G.push_back(edge(to, from, cost));\n}\n\nint kruskal(void){\n    init(V);\n    priority_queue<edge> que;\n    for(int i = 0; i < G.size(); i++){\n        que.push(G[i]);\n    }\n    int ret = 0;\n    while(true){\n        edge e = que.top(); que.pop();\n        if(!unite(e.from, e.to)) break;\n        ret += e.cost / 100 - 1;\n    }\n    return ret;\n}\n\nint main(){\n    int m, a, b, c;\n    while(scanf(\"%d%d\", &V, &m) != EOF && V){\n        for(int x = 0; x < m; x++){\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            append_edge(a, b, c);\n        }\n        int res = kruskal();\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_M = MAX_N * MAX_N;\nint par[MAX_N];\nint myrank[MAX_N];\nint n, m;\n\n\nstruct edge {\n    int a, b, d;\n\n    bool operator<(const edge &r) {\n      return d < r.d;\n    }\n};\n\narray<edge, MAX_M> e;\n\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init() {\n  for (int i = 0; i < MAX_N; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nbool unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y)\n    return false;\n\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n\n  return true;\n}\n\nint main() {\n  int count, t;\n\n  while (cin >> n, n) {\n    cin >> m;\n    init();\n\n    t = 0;\n    for (int i = 0; i < m; i++)\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n\n    sort(e.begin(), e.begin() + m);?\\\n    for (int i = 0; i < m; ++i) {\n      if (unite(e[i].a, e[i].b))\n        t += e[i].d - 100 ;\n    }\n    cout << t / 100 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct edge {\n\tint u, v, cost;\n\tedge (int from, int to, int d )\n\t\t: u(from), v(to), cost(d) { }\n};\n\nconst int MAX_N = 100;\nconst int MAX_E = 100*99/2;\nint par[MAX_N];\nint rank[MAX_N];\nvector<edge> es;\n\nint V, E;\t//  頂点数と辺数\n\n// n要素で初期化\nint init_union_find (int n )\n{\n\trep (i, n ){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t} // end for\n}\n\n// 木の根を求める\nint find (int x )\n{\n\tif (par[x] == x )\n\t\treturn x;\n\n\t// 親を遡る\n\treturn par[x] = find (par[x] );\n}\n\n// xとyの属する集合をマージ\nvoid unite (int x, int y )\n{\n\tx = find (x);\n\ty = find (y);\n\n\t// 親が一緒なら何もしない\n\tif (x == y )\n\t\treturn;\n\n\t// ランクが小さい方の木をぶら下げる\n\tif (rank[x] < rank[y] ){\n\t\t// x を y にぶら下げる\n\t\tpar[x] = y;\n\t}else{\n\t\t// ランクが同じか rank[x] > rank[y]\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y] )\n\t\t\trank[x]++;\n\t} // end if\n}\n\n// xとyが同じ集合に属するか否か\nbool same (int x, int y )\n{\n\treturn (find (x) == find (y) );\n}\n\nbool comp (const edge& e1, const edge& e2 )\n{\n\treturn e1.cost < e2.cost;\n}\n\nint kruskal (void )\n{\n\tsort (ALL (es ), comp );\n\tinit_union_find (V );\n\tint res = 0;\n\trep (i, E ){\n\t\tedge e = es[i];\n\t\tif (!same (e.u, e.v ) ){\n\t\t\tunite (e.u, e.v );\n\t\t\tres += e.cost;\n\t\t} // end if\n\t} // end rep\n\n\treturn res;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.carden_lentern\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tes.clear();\n\t\tint m;\n\t\tscanf (\"%d\", &m );\n\t\trep (i, m ){\n\t\t\tint from, to, cost;\n\t\t\tscanf (\"%d,%d,%d\", &from, &to, &cost );\n\t\t\tes.push_back (edge (from, to, cost ) );\n\t\t} // end rep\n\t\tE = m;\n\t\tV = n;\n\t\tint ans = kruskal();\t// 最小全域木の経路の長さ\n\t\tint res = ans/100 - (V-1);\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\nusing namespace std;\nusing LL = long long;\nconstexpr int MOD = 1000000000 + 7;\nconstexpr int INF = 2000000000;\nconst double PI = acos(-1);\n\nint V;\nint E;\nstruct edge { int from, to, cost; };\n\ntypedef pair<int, int> PP;\n\nvector<edge> e;\n\nint Par[100000];\nint Rank[100000];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile (cin >> V&&V) {\n\t\te.erase(e.begin(), e.end());\n\t\tcin >> E;\n\t\tint a, b, c;\n\t\tchar C;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tcin >> a >> C >> b >> C >> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tcout << kruskal() / 100 - V + 1 << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1000000000000000000LL\nusing namespace std;\nlong long prim(int V, vector<pair<long long, long long>> X[]) {\n\tqueue<pair<long long, long long> > Q; long long dist[100], color[100];\n\tfor (int i = 0; i < V; i++) { dist[i] = INF; color[i] = WHITE; }\n\tdist[0] = 0; color[0] = GRAY; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<long long, long long>pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; color[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first, leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && color[to] < BLACK) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < V; i++) { sum += dist[i]; }//0-indexed\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<long long, long long> > g[100];\nint main() {\n\twhile(cin >> n >> m) {\n\t\tfor(int i = 0; i < n; i++) g[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", u, v, w);\n\t\t\tg[u].push_back(make_pair(v, w / 100 - 1));\n\t\t\tg[v].push_back(make_pair(u, w / 100 - 1));\n\t\t}\n\t\tcout << prim(n, g) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<queue>\n#include<algorithm>\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n#define rep(i,n) REP(i,0,n)\n#define inf (1<<29)\n#define MAX_V 10100\n#define MAX_E 101000\nusing namespace std;\n\nstruct P\n{\n  int to,cost;\n  P(int to=inf,int cost=inf):to(to),cost(cost){}\n  bool operator < (const P &a)const\n  {\n    return cost > a.cost;\n  }\n};\n\nint V,E;\nvector<P> G[MAX_V];\nbool used[MAX_V];\nint mincost[MAX_V];\n\nint prim()\n{\n  rep(i,V)used[i] = false,mincost[i] = inf;\n  mincost[0] = 0;\n\n  priority_queue<P> Q;\n  Q.push(P(0,0));\n\n  int ans = 0;\n  while(!Q.empty())\n    {\n      P p = Q.top(); Q.pop();\n      int cur = p.to;\n\n      if(used[cur])continue;\n      used[cur] = true;\n\n      ans += p.cost;\n\n      for(int i=0;i<G[cur].size();i++)\n\t{\n\t  int next = G[cur][i].to;\n\t  if(used[next])continue;\n\t  if(mincost[next] > G[cur][i].cost)\n\t    {\n\t      mincost[next] = G[cur][i].cost;\n\t      Q.push(P(next,mincost[next]));\n\t    }\n\t}\n    }\n  return ans;\n}\n\nint main()\n{\n  while(cin >> V,V)\n    {\n      rep(i,V)G[i].clear();\n      cin >> E;\n      rep(i,E)\n\t{\n\t  int from,to,w;\n\t  //cin >> from >> to >> w;\n\t  scanf(\"%d,%d,%d\",&from,&to,&w);\n\t  G[from].push_back(P(to,w));\n\t  G[to].push_back(P(from,w));\n\t}\n      \n      cout << prim()/100 - (V-1) << endl;\n      \n    }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<cstring>\n#include<algorithm>\nusing namespace std;\nint e[100][100];\nint main()\n{\n\tint n;\n\twhile(cin>>n,n)\n\t{\n\t\tint m;\n\t\tint ans=0;\n\t\tcin>>m;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\te[i][j]=-1;\n\t\t\t}\n\t\t}\n\t\twhile(m--) \n\t\t{\n\t\t\tint l,r,c;\n\t\t\tscanf(\"%d,%d,%d\",&l,&r,&c);\n\t\t\te[l][r]=e[r][l]=c;\n\t\t}\n\n\t\tbool f[n];\n\t\tfill(f,f+n,0);\n\n\t\tint cnt=1;\n\t\tf[0]=true;\n\t\twhile(cnt<n)\n\t\t{\n\t\t\tint mn=1000000,num;\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tif (f[i])\n\t\t\t\t{\n\t\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(!f[j]&&e[i][j]!=-1&&e[i][j]<mn)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmn=e[i][j];\n\t\t\t\t\t\t\tnum=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tcnt++;\n\t\t\tans+=mn-100;\n\t\t\tf[num]=true;\n\t\t}\n\t\tcout<<ans/100<<endl;\n\t}\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost + n,numeric_limits<int>::max());\n\n\n\t\tint** cost = new int*[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcost[i] = new int[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcost[i][j]=numeric_limits<int>::max();\n\t\t\t}\n\t\t}\n\n\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from,to,dist;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&dist);\n\t\t\tcost[from][to] = min(cost[from][to],dist / 100 - 1);\n\t\t}\n\n\t\tmincost[0]=0;\n\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!used[i] && (v==-1 || mincost[i] < mincost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmincost[v] = min(mincost[v],cost[i][v]);\n\t\t\t}\n\t\t\t\n\t\t\tres+=mincost[v];\n\t\t}\n\n\t\tcout << res << endl;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdelete[] cost[i];\n\t\t}\n\n\t\tdelete[] cost;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <functional>\nusing namespace std;\n#define P pair<int, int>\n\npriority_queue<P, vector<P>, greater<P> > pq;\nbool f[100];\nvector<P> v[100];\n\nint prim()\n{\n\tint cost = 0;\n\tf[0] = 1;\n\tfor (int i = 0; i < v[0].size(); i++) {\n\t\tpq.push(v[0][i]);\n\t}\n\tP p;\n\twhile (!pq.empty()) {\n\t\tp = pq.top(); pq.pop();\n\t\tif (f[p.second]) continue;\n\t\tf[p.second] = 1;\n\t\tcost += p.first;\n\t\tfor (int i = 0; i < v[p.second].size(); i++) {\n\t\t\tpq.push(v[p.second][i]);\n\t\t}\n\t}\n\t\n\treturn cost;\n}\n\nint main()\n{\t\n\tint n, m;\n\twhile (cin >> n, n) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tv[i].clear();\n\t\t\tf[i] = 0;\n\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint from, to, cost;\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &cost);\n\t\t\tcost = cost / 100 - 1;\n\t\t\tv[from].push_back(P(cost, to));\n\t\t\tv[to].push_back(P(cost, from));\n\t\t}\n\t\tcout << prim() << endl;\n\t}\n\t\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef  pair < int , pair<int , int> > PP;\n\ntemplate<typename T>\nclass UF\n{\npublic:\n\tUF ()\n\t{\n\t\tcount = 0;\n\t}\n\n\tvoid push ( T a )\n\t{\n\t\tM[a] = count;\n\t\tV.push_back ( count );\n\t\trank.push_back ( 0 );\n\t\tcount++;\n\t}\n\n\tvoid unite ( T a , T b )\n\t{\n\t\tlong long int x = find ( M[a] );\n\t\tlong long int y = find ( M[b] );\n\t\tif( x == y )return;\n\t\tif( rank[x] < rank[y] )\n\t\t{\n\t\t\tV[x] = y;\n\t\t} else\n\t\t{\n\t\t\tV[y] = x;\n\t\t\tif( rank[x] == rank[y] )rank[x]++;\n\t\t}\n\t}\n\tvoid merge ( T a , T b )\n\t{\n\t\tunite ( a , b );\n\t}\n\tbool same ( T a , T b )\n\t{\n\t\treturn find ( M[a] ) == find ( M[b] );\n\t}\n\tlong long int group ()\n\t{\n\t\tset<long long int>S;\n\t\tfor( long long int i = 0; i < V.size (); i++ )\n\t\t{\n\t\t\tS.insert ( find ( V[i] ) );\n\t\t}\n\t\treturn S.size ();\n\t}\n\nprivate:\n\tvector<long long int> V , rank;\n\tmap < T , long long int>M;\n\tlong long int count;\n\n\tlong long int find ( long long int x )\n\t{\n\t\tif( V[x] == x )return x;\n\t\telse return V[x] = find ( V[x] );\n\t}\n};\n\nint main ()\n{\n\tint N , M;\n\twhile( cin >> N , N )\n\t{\n\t\tcin >> M;\n\t\tpriority_queue < PP , vector<PP> , greater<PP>>que;\n\t\tUF<int> uf;\n\t\tfor( size_t i = 0; i < N; i++ )\n\t\t{\n\t\t\tuf.push ( i );\n\t\t}\n\t\tfor( size_t i = 0; i < M; i++ )\n\t\t{\n\t\t\tchar x;\n\t\t\tint a , b , c;\n\t\t\tcin >> a >> x >> b >> x >> c;\n\t\t\tque.push ( PP ( c , pair<int , int> ( a , b ) ) );\n\t\t}\n\t\tint count = 0;\n\t\twhile( que.size () )\n\t\t{\n\t\t\tPP now = que.top (); que.pop ();\n\t\t\tif( uf.same ( now.second.first , now.second.second ) )continue;\n\t\t\tuf.merge ( now.second.first , now.second.second );\n\t\t\tcount += now.first / 100 - 1;\n\n\t\t}\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\n// ????????????????????£?¨?\nint prim(vector<vector<pair<int, int> > > adjlist, int v);\n\n// ?????????\nint main(void){\n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n;\n    if(n == 0){ break; }\n    cin >> m;\n\n    // ???????????±????????????????????£??\\??????????????????\n    vector<vector<pair<int, int> > > adjlist(n);\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      adjlist[a].push_back(make_pair(d, b));\n      adjlist[b].push_back(make_pair(d, a));\n    }\n  \n    // ????°???¨?????¨????????????????±??????????????????????\n    int length = prim(adjlist, n);\n    cout << length / 100 - n + 1 << endl;\n  }\n\n  return 0;\n}\n\n// ????????????\n// ?????°: ??£??\\?????????(first: ???????????????, second: ????????????), ????????°\n// ?????????: ??¨????????????\nint prim(vector<vector<pair<int, int> > > adjlist, int v){\n  priority_queue<pair<int, int> > mincost;  // ?????§???????????????????????¨?????§???????°??????????\n  vector<bool> used(v, false);  // ??????i?????¨????????????????????????\n  int length = 0;  // ??¨????????????\n\n  // ???????????????\n  mincost.push(make_pair(0, 0));\n  while(!mincost.empty()){\n    // ????£?????????????????°?????????????????????????\n    int newmember = mincost.top().second;\n    int newcost = -mincost.top().first;\n    mincost.pop();\n    if(used[newmember]){ continue; }\n\n    // ???newmember?????¨?????????\n    used[newmember] = true;\n    length += newcost;\n\n    // ???newmember????????\\?¶???????????????????????????????????????? \n    for(int i = 0; i < adjlist[newmember].size(); i++){\n      // ????????¨??????????????????????????????queue?????????\n      if(!used[adjlist[newmember][i].second]){\n        mincost.push(make_pair(-adjlist[newmember][i].first, adjlist[newmember][i].second));\n      }\n    }\n  }\n  \n  return length;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind() {}\n  UnionFind(int n) : data(n, -1) {}\n\n  bool same(int x, int y) { return root(x) == root(y); }\n  int root(int x) { return (data[x] < 0) ? x : data[x] = root(data[x]); }\n  int rank(int x) { return -data[root(x)]; }\n  bool unite(int x, int y) {\n    x = root(x);\n    y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y];\n      data[y] = x;\n    }\n    return x != y;\n  }\n};\ntemplate<typename T> struct Graph {\n  struct Edge { int s, t; T cost; };\n  int sz;\n  vector<Edge> es;\n  Graph(int n = 0) : sz(n) {}\n\n  void addEdge(int u, int v, T w) {\n    sz = max(sz, max(u, v) + 1);\n    es.push_back({u, v, w});\n  }\n  T kruskal() {\n    UnionFind uf(sz);\n    sort(begin(es), end(es), [](Edge e1, Edge e2) {\n      return e1.cost < e2.cost;\n    });\n    T res = 0;\n    for (auto&& e : es) {\n      if (uf.unite(e.s, e.t)) res += e.cost;\n    }\n    return res;\n  }\n};\n\nint main() {\n  int n;\n  while (cin >> n, n) {\n    int m; cin >> m;\n    Graph<int> g;\n    for (int i = 0; i < m; ++i) {\n      int a, b, d;\n      char c;\n      cin >> a >> c >> b >> c >> d;\n      g.addEdge(a, b, d / 100);\n    }\n    cout << g.kruskal() - (n - 1) << endl;\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].emplace_back(Edge(a, b, d));\n\t\t\tg[b].emplace_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = kruskal(g);\n\t\t//cout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <climits>\n\nusing namespace std;\n\nconst int size = 100;\n\nint main() {\n  while (true) {\n    int n, m, w[size][size];\n    cin >> n >> m;\n\n    if (n == 0)\n      break;\n\n    fill( w[0], w[size] , INT_MAX);\n    for (int i = 0; i < m; ++i) {\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      w[b][a] = w[a][b] = d;\n    }\n\n    int status[size] = { 1 };\n    int sum = 0;\n\n    for (int i = 0; i < n-1; ++i) {\n      int mincost = INT_MAX;\n      int as, bs;\n\n      for (int a = 0; a < n; ++a) {\n        for (int b = 0; b < n; ++b) {\n          if (status[a] + status[b] == 1 && w[a][b] < mincost) {\n            mincost = w[a][b];\n            as = a;\n            bs = b;\n          }\n        }\n      }\n\n      status[as] = status[bs] = 1;\n      sum += (w[as][bs] - 100) / 100;\n    }\n    cout << sum << endl;\n  }\n}\n"
  },
  {
    "language": "C++",
    "code": "#define _GLIBCXX_DEBUG\n\n#include <bits/stdc++.h>\n\n\nusing namespace std;\n\nconst int INF = 1e9 + 10;\n\nclass Dijkstra {\n#define MAX_V 101\n  typedef pair<int, int> P;\n\nprivate:\n  struct Edge {\n    int to, cost;\n    Edge(int to, int cost): to(to), cost(cost) { }\n  };\n\n  int V;\n  vector<Edge> G[MAX_V];\n\npublic:\n\n  Dijkstra(int V): V(V) { \n    if (V >= MAX_V) {\n      assert(false);\n    }\n  }\n\n  void AddEdge(int from, int to, int cost) {\n    G[from].push_back(Edge(to, cost));\n  }\n\n  vector<int> Solve(int s) {\n    priority_queue<P, vector<P>, greater<P>> que;\n    vector<int> d(V, INF);\n    d[s] = 0;\n    que.push(P(0, s));\n\n    while (!que.empty()) {\n      P p = que.top(); que.pop();\n      int v = p.second;\n      if (d[v] < p.first) {\n        continue;\n      }\n      for (int i = 0; i < G[v].size(); i++) {\n        Edge e = G[v][i];\n        if (d[e.to] > d[v] + e.cost) {\n          d[e.to] = d[v] + e.cost;\n          que.push(P(d[e.to], e.to));\n        }\n      }\n    }\n\n    return d;\n  }\n};\n\n\n\nint main() {\n  while (true) {\n    int n, m;\n    cin >> n;\n    if (n == 0) {\n      break;\n    }\n    Dijkstra dijkstra(n);\n    cin >> m;\n    for (int i = 0; i < m; i++) {\n      int a, b, d;\n      char split;\n      cin >> a >> split >> b >> split >> d;\n      dijkstra.AddEdge(a, b, d);\n      dijkstra.AddEdge(b, a, d);\n    }\n\n    int ans = INF;\n    for (int i = 0; i < n; i++) {\n      vector<int> d = dijkstra.Solve(i);\n      int tmp = accumulate(d.begin(), d.end(), 0);\n      ans = min(ans, tmp);\n    }\n\n    cout << ans / 100 - (n - 1) << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <algorithm>\n#include <complex>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cctype>\n#include <cmath>\n#include <memory.h>\n#include <cassert>\n#include <limits>\n\nusing namespace std;\n\n\n#define all(c) ((c).begin()), ((c).end())\n#define debug(c) cerr << \"> \" << #c << \" = \" << (c) << endl;\n#define iter(c) __typeof((c).begin())\n#define present(c, e) ((c).find((e)) != (c).end())\n#define cpresent(c, e) (find(all(c), (e)) != (c).end())\n#define tr(i, c) for (iter(c) i = (c).begin(); i != (c).end(); i++)\n#define rep(i, n) for (int i = 0; i < (int)(n); i++)\n#define REP(i, a, b) for (int i = (int)(a); i <= (int)(b); i++)\n\n#define mp make_pair\n#define fst first\n#define snd second\n#define pb push_back\n\n\nconst double EPS = 1e-10;\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\ntypedef complex<double> P;\n\n\nconst int MAX_V = 110;\nconst int INF = 9999999;\n\n\ntypedef int w_t;\nstruct e_t { int from, to; w_t cost; };\nbool operator>(const e_t & a, const e_t & b) { return a.cost > b.cost; };\n\npair<w_t, vector<e_t> > prim(int N, vector<e_t> adj[MAX_V]) {\n\tvector<e_t> es;\n\tpriority_queue<e_t, vector<e_t>, greater<e_t> > que;\n\tque.push((e_t){-1, 0, 0});\n\tbool visited[MAX_V];\n\tmemset(visited, 0, sizeof(visited));\n\tvector<e_t> tree;\n\tw_t wgh = 0;\n\twhile (!que.empty()) {\n\t\te_t e = que.top();\n\t\tque.pop();\n\t\tif (visited[e.to]) continue;\n\t\tvisited[e.to] = true;\n\t\tif (e.from >= 0) {\n\t\t\ttree.pb(e);\n\t\t\twgh += e.cost;\n\t\t}\n\t\ttr(i, adj[e.to]) que.push(*i);\n\t}\n\t\n\treturn mp(wgh, tree);\n}\n\n\nint main() {\n\tfor (int n, m; cin >> n, n != 0; ) {\n\t\tcin >> m;\n\t\tvector<e_t> adj[MAX_V];\n\t\trep(i, m) {\n\t\t\tchar c; int a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tadj[a].pb((e_t){a, b, d});\n\t\t\tadj[b].pb((e_t){b, a, d});\n\t\t}\n\t\tvector<e_t> es = prim(n, adj).snd;\n\t\tint ans = 0;\n\t\trep(i, es.size()) ans += es[i].cost / 100 - 1;\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define M 99999\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;scanf(\"%d%d\",&n,&m)>1;printf(\"%d\\n\",s/100-n+1)){\n\t\tfor(i=0;i<m;i++)scanf(\"%d,%d,%d\",a+i,b+i,&node[i].first),node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <math.h>\n#include <algorithm>\n#include <climits>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector< bool > BVI;\ntypedef vector< int > VI;\ntypedef vector< VI > VVI;\n\nint main() {\n\tint n, m;\t\n\n\twhile( true ) {\n\n\t\tcin >> n;\n\n\t\tif( n == 0 ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcin >> m;\n\n\t\tVVI map(n, VI(n, INT_MAX / 4));\n\t\tVI mincost(n, INT_MAX / 4);\n\t\tBVI used(n, false);\n\t\tint res = 0;\n\t\tint a, b, c;\n\t\tchar dummy;\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> a >> dummy >> b >> dummy >> c;\n\t\t\tmap[a][b] = (c / 100) - 1;\n\t\t\tmap[b][a] = (c / 100) - 1;\n\t\t}\n\n\t\twhile( true ) {\n\t\t\tint v = -1;\n\t\t\tfor(int u = 0; u < n; u++) {\n\t\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) {\n\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( v == -1 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused[v] = true;\n\n\t\t\tfor(int u = 0; u < n; u++) {\n\t\t\t\tmincost[u] = min(mincost[u], map[v][u]);\n\t\t\t}\n\t\t}\n\n\t\tfor(int i = 0; i < n - 1; i++) {\n\t\t\tres += mincost[i];\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nconst int INF = 1e9;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s,\n                  vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n    for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n        Edge e = Q.top(); Q.pop();\n        if (prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight) {\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\nvector<int> buildPath(const vector<int> &prev, int t) {\n    vector<int> path;\n    for (int u = t; u >= 0; u = prev[u])\n        path.push_back(u);\n    reverse(path.begin(), path.end());\n    return path;\n}\n\nint main()\n{\n    int n, m;\n    char ch;\n\n    while (cin >> n, n) {\n        Graph g(n);\n        vector<Weight> d;\n        vector<int> prev, path;\n        cin >> m;\n\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n\n            cin >> u >> ch >> v >> ch >> w;\n            w /= 100;\n            g[u].push_back(Edge(u, v, w));\n            g[v].push_back(Edge(v, u, w));\n        }\n        shortestPath(g, 0, d, prev);\n        path = buildPath(prev, n - 1);\n        cout << d[n - 1] + path.size() << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <cstdio>\n#include <map>\n#define fr first\n#define sc second\n#define INF (2 << 28)\nusing namespace std;\n\ntypedef pair<int, int> iiP;\nstruct edge{\n  int to, cost; edge(){}\n  edge(int to, int cost):to(to), cost(cost){}\n}; \n\t\t\t      \nvector<vector<edge> > Graph;\n\nint n, m;\n\nvoid init(int n){\n  \n  Graph.resize(0), Graph.resize(n);\n\n}\n\nint Prim(){\n  \n  int ret = 0;\n  vector <int> used(n, 0); \n  priority_queue<iiP, vector<iiP>, greater<iiP> > que;\n  que.push(iiP(0, 0));\n  while(!que.empty()){\n    iiP p = que.top(); que.pop();\n    if(used[p.sc]++) continue;\n    ret += p.fr;\n    for(int i = 0; i < Graph[p.sc].size(); i++){\n      que.push(iiP(Graph[p.sc][i].cost, Graph[p.sc][i].to));\n    }\n  }\n  return ret;\n\n}\n\nint main(){\n  \n  while(cin >> n, n){\n    cin >> m;\n    init(n);\n\n    for(int i = 0; i < m; i++){\n      int a, b, c; scanf(\"%d, %d, %d\", &a, &b, &c);\n      Graph[a].push_back(edge(b, c/100-1));\n      Graph[b].push_back(edge(a, c/100-1));\n    }\n\n    cout << Prim() << endl;\n  }\n\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_M = MAX_N * MAX_N;\nint par[MAX_N];\nint myrank[MAX_N];\nint n, m;\n\n\nstruct edge {\n    int a, b, d;\n\n    bool operator<(const edge &r) {\n      return d < r.d;\n    }\n};\n\narray<edge, MAX_M> e;\n\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init() {\n  for (int i = 0; i < MAX_N; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nbool unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y)\n    return false;\n\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n\n  return true;\n}\n\nint main() {\n  int count, t;\n\n  while (cin >> n, n) {\n    cin >> m;\n    init();\n\n    t = 0;\n    for (int i = 0; i < m; i++)\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n\n    sort(e.begin(), e.begin() + m);\n    for (int i = 0; i < n; ++i) {\n      if (unite(e[i].a, e[i].b))\n        t += e[i].d - 100 ;\n    }\n    cout << t / 100 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\ntypedef pair<int,pair<int,int> > PII;\nint n,m;\nint ans;\nint E[150];\nPII V[150];\n\nsigned main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            V[i].first=z;\n            V[i].second.first=x;\n            V[i].second.second=y;\n        }\n        sort(V,V+m);\n        rep(i,m){\n            if(E[V[i].second.first]==1&&E[V[i].second.second]==1)continue;\n            ans+=V[i].first-100;\n            E[V[i].second.first]=1;\n            E[V[i].second.second]=1;\n        }\n        cout<<ans/100<<endl;\n        ans=0;\n        rep(i,n)E[i]=0;\n        rep(i,m){\n            V[i].first=0;\n            V[i].second.first=0;\n            V[i].second.second=0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nstruct edge{ int from,to,cost; };\n\nbool comp( const edge& left, const edge& right ) {\n    return left.cost < right.cost;\n}\n\nint rnk[100],par[100];\n\nvoid init(int n){\n\tfor(int i = 0;i < n;i++){\n\t\trnk[i] = 0;\n\t\tpar[i] = i;\n\t}\n}\n\nint find(int x){\n\tif(par[x] == x) return x;\n\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int a,int b){\n\ta = find(a);\n\tb = find(b);\n\tif(a == b) return;\n\tif(rnk[a] > rnk[b]){\n\t\tpar[b] = a;\n\t}else{\n\t\tpar[a] = b;\n\t\tif(rnk[a] == rnk[b]) rnk[b]++;\n\t}\n}\n\nint main(){\n\tint n,m;\n\twhile(cin >> n,n){\n\t\tcin >> m;\n\t\tvector<edge> v;\n\t\tinit(n);\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tv.push_back({a,b,c / 100 - 1});\n\t\t}\n\t\tsort(v.begin(),v.end(),comp);\n\t\tint res = 0;\n\t\tfor(int i = 0;i < m;i++){\n\t\t\tedge e = v[i];\n\t\t\tif(find(e.to) == find(e.from)) continue;\n\t\t\tunite(e.to,e.from);\n\t\t\tres += e.cost;\n\t\t}\n\t\tcout << res << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std ;\n\n#define pb(n) push_back(n)\n#define fi first\n#define se second\n#define all(r) (r).begin(),(r).end()\n#define vmax(ary) *max_element(all(ary))\n#define vmin(ary) *min_element(all(ary))\n#define debug(x) cout<<#x<<\": \"<<x<<endl\n#define fcout(n) cout<<fixed<<setprecision((n))\n#define scout(n) cout<<setw(n)\n#define vary(type,name,size,init) vector< type> name(size,init)\n#define vvl(v,w,h,init) vector<vector<ll>> v(w,vector<ll>(h,init))\n#define mp(a,b) make_pair(a,b)\n\n#define rep(i,n) for(int i = 0; i < (int)(n);++i)\n#define REP(i,a,b) for(int i = (a);i < (int)(b);++i)\n#define repi(it,array) for(auto it = array.begin(),end = array.end(); it != end;++it)\n#define repa(n,array) for(auto &n :(array))\n\nusing ll = long long;\nusing vi = vector<int>;\nusing vl = vector<ll>;\nusing dict = map<string,int>;\nusing pii = pair<int,int> ;\nusing pll = pair<ll,ll> ;\n\nconst int mod = 1000000007;\nconstexpr int inf = ((1<<30)-1)*2+1 ;\nconstexpr double PI = acos(-1.0) ;\ndouble eps = 1e-10 ;\nconst int dy[] = {-1,0,1,0,1,-1,1,-1};\nconst int dx[] = {0,-1,0,1,1,-1,-1,1};\n\nstruct Edge{\n  int to;\n  long long cost;\n};\n\nstruct NODE{\n  int pos;\n  long long cost;\n};\nbool operator < (const NODE &a,const NODE &b){\n  return a.cost > b.cost;\n}\nvector<Edge> g[100000],rg[100000];\nconst int MAX_V = 105;\n//inf??§?????????\nvector<vector<ll>> cost;\nll mincost[MAX_V];\nbool used[MAX_V];\nll V,path;\nll prim(){\n  ll res = 0;\n  path = 0;\n  for(ll i = 0; i < V; ++i){\n    mincost[i] = inf;\n    used[i] = false;\n  }\n  priority_queue<NODE> q;\n  q.push({0,0});\n  while(q.size()){\n    auto v = q.top();q.pop();\n    if(mincost[v.pos] == inf){\n      mincost[v.pos] = v.cost;\n      res += v.cost;\n      if(v.cost)\n        path += v.cost/100 - 1;\n      for(auto n : g[v.pos]){\n        q.push({n.to,n.cost});\n      }\n    }\n  }\n  while(q.size()){\n    q.pop();\n  }\n  rep(i,V){\n    g[i].clear();\n  }\n  return res;\n}\n\nint main(){\n  cin.tie(0);\n  ios::sync_with_stdio(false);\n  ll n,m;\n  while(cin >> n && n){\n    V = n;\n    cin >> m;\n    int a,b,c;\n    char d;\n    rep(i,m){\n      cin >> a >> d >> b >> d >> c;\n      g[a].push_back({b,c});\n      g[b].push_back({a,c});\n    }\n    ll ans = prim();\n    cout << ans/100-n+1 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> tree_size;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\ttree_size.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\ttree_size[i] = 1;\n\t\t}\n\t}\n\n\t//??¨???????????????\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\t//????????¨????±????????????????\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\t//a???????????¨??¨b???????????¨?????????\n\tvoid marge(int a, int b) {\n\t\tif (same(a, b)) return;\n\n\t\ttree_size[find(a)] += tree_size[find(b)];\n\t\tpar[find(b)] = par[find(a)];\n\t}\n\n\tvoid show_info() {\n\t\tfor (int i = 0; i < par.size(); i++) {\n\t\t\tcout << par[i] << \",\" << tree_size[i] << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\t//a???????????¨?????§??????\n\tint size(int a) {\n\t\treturn tree_size[find(a)];\n\t}\n\n\n};\n\nauto comp = [](pair<pair<int, int>, int > a, pair<pair<int, int>, int > b) {return a.second > b.second; };\npriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, decltype(comp) > que(comp);\nint N;\nint kraskal() {\n\tint sum = 0;\n\tUnionFind tree = UnionFind(N);\n\n\tfor (; tree.size(0) != N;) {\n\t\t//tree.show_info();\n\t\twhile (tree.same(que.top().first.first, que.top().first.second))\n\t\t\tque.pop();\n\n\t\ttree.marge(que.top().first.first, que.top().first.second);\n\t\tsum += que.top().second;\n\t}\n\n\treturn sum;\n}\n\nvoid q72() {\n\tint m;\n\tfor (; cin >> N >> m;) {\n\t\tfor (; !que.empty();) que.pop();\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s, t, c;\n\t\t\tchar tmp;\n\t\t\tcin >> s >> tmp >> t >> tmp >> c;\n\t\t\tque.push(make_pair(make_pair(s, t), c));\n\t\t}\n\t\tcout << kraskal() / 100 - N + 1 << endl;\n\t}\n}\n\nint main() {\n\tq72();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\nconst int MAX = 1000;\n\nint par[MAX],rank[MAX],n,m;\n\nvoid init(int n){\n  for(int i = 0 ; i < n ; i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\nint find(int x){\n  if(par[x] == x) return x;\n    return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x); y = find(y);\n  if(x == y) return;\n\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if(rank[x] == rank[y]) rank[x]++;\n  }\n}\n\nbool same(int x,int y){\n  return find(x) == find(y);\n}\n\nint kruskal(pair<int,pair<int,int> > es[MAX]){\n  sort(es,es + m);\n  init(n);\n  int res = 0;\n  for(int i = 0 ; i < m ; i++){\n    int a = es[i].second.first;\n    int b = es[i].second.second;\n    if(!same(a,b)){\n      res += es[i].first;\n      unite(a,b);\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> n,n){\n    cin >> m;\n    pair<int,pair<int,int> > es[MAX];\n    for(int i = 0 ; i < m ; i++){\n      scanf(\"%d,%d,%d\", &es[i].second.first, &es[i].second.second,&es[i].first);\n    }\n    for(int i = 0 ; i < m ; i++){\n      es[i].first = es[i].first/100-1;\n    }\n\n    cout << kruskal(es) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].emplace_back(Edge(a, b, d));\n\t\t\tg[b].emplace_back(Edge(b, a, d));\n\t\t}\n\t\t//pair<Weight, Edges> k = kruskal(g);\n\t\t//cout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<climits>\nusing namespace std;\n\n#define ROOT (-1)\n#define INV (-1)\n#define INFTY INT_MAX\n#define MAX_NODES 100\n\nint prim(int n, int dist[][MAX_NODES]){\n\tint ans = 0; // problem answer\n\tbool vis[MAX_NODES];\n\tint cost[MAX_NODES];\n\tint pi[MAX_NODES];\n\n\tfor(int i = 0; i < n; i++){\n\t\tvis[i] = false;\n\t\tcost[i] = INFTY;\n\t}\n\n\tcost[0] = 0;\n\tpi[0] = ROOT;\n\n\twhile( true ){\n\t\tint mincost = INFTY;\n\t\tint nmin;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif( !vis[i] && mincost > cost[i] ){\n\t\t\t\tmincost = cost[i];\n\t\t\t\tnmin = i;\n\t\t\t}\n\t\t}\n\n\t\t// end\n\t\tif( mincost == INFTY ) break;\n\n\t\tvis[nmin] = true;\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tif( vis[i] || dist[nmin][i] == INV ) continue; // skip\n\t\t\tif( dist[nmin][i] < cost[i] ){\n\t\t\t\tcost[i] = dist[nmin][i];\n\t\t\t\tpi[i] = nmin;\n\t\t\t}\n\t\t}\n\t}\n\n\t// calc\n\tfor(int i = 1; i < n; i++){\n\t\tans += ( (cost[i] == INFTY ? 100 : cost[i]) - 100) / 100;\n\t}\n\treturn ans;\n}\n\nint main(void){\n\twhile( true ){\n\t\tint dist[MAX_NODES][MAX_NODES];\n\t\tint n;\n\t\tint m;\n\n\t\tcin >> n;\n\t\tif( n == 0 ) break;\n\t\tcin >> m;\n\t\t\n\t\t// init\n\t\tfor(int i = 0; i < sizeof(dist)/sizeof(*dist); i++){\n\t\t\tfor(int j = 0; j < sizeof(dist[i])/sizeof(*dist[i]); j++){\n\t\t\t\tdist[ i ][ j ] = INV;\n\t\t\t}\n\t\t}\n\n\t\t// input\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a, b, d;\n\t\t\tchar dum;\n\t\t\tcin >> a >> dum >> b >> dum >> d;\n\t\t\tdist[a][b] = d;\n\t\t}\n\n\t\t// prim algorithm\n\t\tcout << prim(n, dist) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n#include <string.h>\n#include <string>\n#include <algorithm>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <random>\n#include<cstdlib>\n#define _USE_MATH_DEFINES\n#include <math.h>\n\n#define INF (1<<21)\n#define swap(a,b) {a=a+b; b=a-b; a=a-b;}\n#define abs(a) (a > 0 ? a:-a)\n#define min(a,b) {a > b ? b:a}\nusing namespace std;\n\nstruct UnionFind {\n\tvector<int> par;\n\tvector<int> tree_size;\n\n\tUnionFind(int n) {\n\t\tpar.resize(n);\n\t\ttree_size.resize(n);\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\ttree_size[i] = 1;\n\t\t}\n\t}\n\n\t//??¨???????????????\n\tint find(int x) {\n\t\tif (par[x] == x) return x;\n\t\treturn par[x] = find(par[x]);\n\t}\n\n\t//????????¨????±????????????????\n\tbool same(int a, int b) {\n\t\treturn find(a) == find(b);\n\t}\n\n\t//a???????????¨??¨b???????????¨?????????\n\tvoid marge(int a, int b) {\n\t\tif (same(a, b)) return;\n\n\t\ttree_size[find(a)] += tree_size[find(b)];\n\t\tpar[find(b)] = par[find(a)];\n\t}\n\n\tvoid show_info() {\n\t\tfor (int i = 0; i < par.size(); i++) {\n\t\t\tcout << par[i] << \",\" << tree_size[i] << endl;\n\t\t}\n\t\tcout << endl;\n\t}\n\n\t//a???????????¨?????§??????\n\tint size(int a) {\n\t\treturn tree_size[find(a)];\n\t}\n\n\n};\n\nauto comp = [](pair<pair<int, int>, int > a, pair<pair<int, int>, int > b) {return a.second > b.second; };\npriority_queue<pair<pair<int, int>, int>, vector<pair<pair<int, int>, int> >, decltype(comp) > que(comp);\nint N;\nint kraskal() {\n\tint sum = 0;\n\tUnionFind tree = UnionFind(N);\n\n\tfor (; tree.size(0) != N;) {\n\t\t//tree.show_info();\n\t\twhile (tree.same(que.top().first.first, que.top().first.second))\n\t\t\tque.pop();\n\n\t\ttree.marge(que.top().first.first, que.top().first.second);\n\t\tsum += que.top().second;\n\t}\n\n\treturn sum;\n}\n\nvoid q72() {\n\tint m;\n\tfor (; cin >> N >> m;) {\n\t\tfor (; !que.empty();) que.pop();\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint s, t, c;\n\t\t\tchar tmp;\n\t\t\tcin >> s >> tmp >> t >> tmp >> c;\n\t\t\tque.push(make_pair(make_pair(s, t), c));\n\t\t}\n\t\tcout << kraskal() / 100 - N + 1 << endl;\n\t}\n}\n\nint main() {\n\tq72();\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].emplace_back(Edge(a, b, d));\n\t\t\tg[b].emplace_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = kruskal(g);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\n#define rep(i, n) for ( int i = 0; i < n; i++)\n#define MAX 100\n#define INFTY (1<<21)\nint G[MAX][MAX], n;\n\nvoid prim(){\n    int D[MAX], V[MAX], P[MAX], sum = 0;\n    rep(i, n) { D[i] = INFTY; V[i] = 0; }\n    D[0] = 0;\n\n    while(1){\n\tint u, minv = INFTY;\n\trep(i, n) if ( !V[i] && minv > D[i]) { \n\t    minv = D[i], u = i; \n\t}\n\tif ( minv == INFTY ) break;\n\tV[u] = 1;\n\tif ( u ) sum += G[u][P[u]];\n\trep(v, n){\n\t    if ( !V[v] && G[u][v] < D[v] ){\n\t\tD[v] = G[u][v];\n\t\tP[v] = u;\n\t    }\n\t}\n    }\n\n    cout << sum<< endl;\n}\n\nmain(){\n    int m, s, t, c;\n    char ch;\n    while( cin >> n >> m && n ){\n\trep(i, n) rep(j, n) G[i][j] = INFTY;\n\trep(i, m) {\n\t    cin >> s >> ch >> t >> ch >> c; \n\t    G[s][t] = G[t][s] = c/100-1;\n\t}\n\tprim();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string.h>\n\n#define X first\n#define Y second\n#define MP make_pair\ntypedef long long ll;\nusing namespace std;\nconst int MAX = 101;\n\nint root[101];\nint ranks[101];\n\nstruct E{\n\tE(int from, int to, int cost):from(from), to(to), cost(cost){}\n\tint from, to, cost;\n\tbool operator < (const E & e){\n\t\treturn cost < e.cost;\n\t}\n};\n\nvoid Init(){\n\tfor(int i = 0; i < MAX; i++){\n\t\troot[i] = i;\n\t\tranks[i] = 1;\n\t}\n}\n\nint find(int x){\n\tif(root[x] == x) return x;\n\telse return root[x] = find(root[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(ranks[x] < ranks[y]){\n\t\troot[x] = y;\n\t}else{\n\t\troot[y] = x;\n\t\tif(ranks[x] == ranks[y]) ranks[x]++;\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n && n != 0){\n\t\tcin >> m;\n\t\tInit();\n\t\tvector<E> tb;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a, b, cost;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &cost);\n\t\t\ttb.push_back(E(a, b, cost));\n\t\t}\n\n\t\tsort(tb.begin(), tb.end());\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < tb.size(); i++){\n\t\t\tif(find(tb[i].from) != find(tb[i].to)){\n\t\t\t\tans += (tb[i].cost/100) - 1;\n\t\t\t\tunite(tb[i].from, tb[i].to);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<set>\n#include<climits>\nusing namespace std;\n#define NONE -1\n\nint prim(int n, vector< vector<int> >v)\n{\n  set<int>selected;\n  set<int>::iterator it;\n  int mincost,mini;\n  int i;\n  int ans=0;\n\n  selected.insert(0);\n\n  while(selected.size()!=n){\n    mincost=INT_MAX;\n    mini=NONE;\n\n    for(it=selected.begin();it!=selected.end();it++){\n      for(i=0;i<n;i++){\n\tif(selected.find(i)!=selected.end())continue;\n\tif(v[*it][i]==NONE)continue;\n\tif(v[*it][i]>=mincost)continue;\n\tmincost=v[*it][i];\n\tmini=i;\n      }\n    }\n\n    if(mini==NONE)break;\n    selected.insert(mini);\n    ans+=mincost;\n  }\n\n  return ans;\n}\n\nint main()\n{\n  int n,m;\n  int a,b,d;\n  char c;\n  while(cin>>n>>m,n){\n    vector< vector<int> >v(n,vector<int>(n,NONE));\n    while(m-->0){\n      cin>>a>>c>>b>>c>>d;\n      v[a][b]=v[b][a]=(d/100>0)?d/100-1:0;\n    }\n    cout<<prim(n,v)<<endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#define INF 2147483647\nusing namespace std;\n\nclass Lantern{\npublic:\n\tbool vector_find(vector<int> v,int key){\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(v[i]==key){return 1;}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Solve(int n, int roadlist[100][100] ){\n\t\tint ans=0,i,j;\n\t\tvector<int> V;\n\t\tV.push_back(0);\n\t\twhile(V.size()!=n){\n\t\t\tint u,v,min=INF;\n\t\t\tfor(i=0;i<V.size();i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(!vector_find(V,j)){\n\t\t\t\t\t\tif(roadlist[i][j]<min){\n\t\t\t\t\t\t\tu=i,v=j;\n\t\t\t\t\t\t\tmin=roadlist[i][j];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=min-100;\n\t\t\tV.push_back(v);\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\n\n\nint main(){\n\tint n,m;\n\tint rlist[100][100];\n\twhile(1){\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\trlist[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){break;}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\trlist[a][b]=rlist[b][a]=c;\n\t\t}\n\t\tLantern lantern;\n\t\tprintf(\"%d\\n\",lantern.Solve(n,rlist)/100);\n\t}\n\t\n\t\n\t\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n#define MAX_N 100\nint par[MAX_N];\nint myrank[MAX_N];\nint n,m;\n\n\nstruct edge {\n    int a, b, d;\n\n    /*\n    bool operator <(const edge& r) {\n      return this->d < r.d;\n    }\n     */\n};\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n) {\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) {\n    return;\n  }\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n}\n\n// x,y????±?????????????????????????????????????\nint same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid Tree_print() {\n  int i;\n  for (i = 0; i < n; i++) cout << par[i];\n  cout << endl;\n\n}\n\nint compare_edge(const void *a,const void * b){\n  edge temp1 = *(edge *)a;\n  edge temp2 = *(edge *)b;\n\n  return temp1.d-temp2.d;\n}\nint main() {\n  int count ,t ;\n  while (1){\n    cin >> n ;\n    if(n == 0) break;\n    cin >> m;\n    init(n);\n\n    edge e[n];\n\n\n    t =0;\n    count =0;\n    for(int i = 0; i < m; i ++){\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n    }\n\n    qsort(e,n, sizeof(*e),compare_edge);\n    while(count != m-1) {\n      for (int i = 0; i < n; ++i) {\n        if(same(e[i].a,e[i].b) != 1) {\n          count++;\n          t = t + (int) e[i].d /100 - 1;\n          unite(e[i].a,e[i].b);\n        }\n      }\n      cout << t<<endl;\n    }\n\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#define INF 1000000000\nusing namespace std;\n\nint cost[100][100];\nint mincost[100];\nbool used[100];\nint n;\nint prim();\nmain(){\n  int m;\n  while(1){\n    cin >> n;\n    if(n==0) break;\n    cin >> m;\n    for(int i=0;i<n;i++){\n      for(int j=0;j<n;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    for(int i=0;i<m;i++){\n      int a, b, c;\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      c/=100;\n      cost[a][b]=cost[b][a]=c;\n    }\n    \n    cout << prim()-(n-1) << endl;\n  }\n  return 0;\n}\n\nint prim(){\n  for(int i=1;i<n;i++){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  mincost[0]=0;\n  int res=0;\n\n  while(true){\n    int v=-1;\n    for(int u=0;u<n;u++){\n      if(!used[u] && (v==-1 || mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    used[v]=true;\n    res+=mincost[v];\n    for(int u=0;u<n;u++){\n      mincost[u]=min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\n#define MAX_V 110\nconst int INF = 1e9;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\nint prim(){\n  for(int i = 0 ; i < V ; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n    for(int u = 0 ; u < V ; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    \n    used[v] = true;\n    res += mincost[v];\n    for(int u = 0 ; u < V ; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nvoid init(){\n  for(int i = 0 ; i < MAX_V ; i++){\n    mincost[i] = used[i] = 0;\n    for(int j = 0 ; j < MAX_V ; j++){\n      cost[i][j] = INF;\n    }\n  }  \n}\n\nint main(){\n  int n, m;\n  while(cin >> n, n){\n    init();\n    cin >> m;\n    V = n;\n    int from, to, C;\n    for(int i = 0 ; i < m ; i++){\n      scanf(\"%d,%d,%d\", &from, &to, &C);\n      cost[from][to] = C - 100;\n      cost[to][from] = C - 100;\n    }\n    \n    int ans = prim();\n    cout << ans / 100 << endl;    \n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include \"stdio.h\"\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge{\n    Edge(int t, int c)\n        : to(t), cost(c) {}\n\n    int to;\n    int cost;\n};\n\nint cnt;\nbool visited[100];\nvector<Edge> G[100];\ntypedef pair<int, int> PII;\n\nint prim(int start){\n    int ans = 0;\n    cnt = 0;\n    fill(visited, visited+100, false);\n\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n\n    que.push(PII(0, start));\n    while (!que.empty()){\n        int cst = que.top().first;\n        int v = que.top().second;\n        que.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        cnt++;\n        ans += cst;\n        for (int i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            que.push(PII(G[v][i].cost, G[v][i].to));\n        }\n    }\n\n    cnt--;\n    return ans;\n} \n\nint main(int argc, char const *argv[]){\n    int n, m;\n\n    while (cin>>n, n){\n        cin>>m;\n        for (int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            G[a].push_back(Edge(b, d));\n            G[b].push_back(Edge(a, d));\n        }\n\n        cout<<(prim(0)-cnt*100)/100<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <cstring>\n#include <string>\n#include <cctype>\n#include <sstream>\n#include <cmath>\n#include <climits>\n#include <set>\n#include <iostream>\n#include <map>\n#include <functional>\n#include <cstdlib>\n#include <numeric>\n#include <queue>\n\nusing namespace std;\n\n#define reep(i,f,n) for(int i=f; i<int(n); ++i)\n#define rep(i,n) reep(i,0,n)\n\ntypedef vector<int> vi;\ntypedef pair<int, int> pii;\n\nstruct Edge {\n\tint src, dst, cost;\n\tEdge(int s, int d, int c) : src(s), dst(d), cost(c) {}\n\tEdge() {}\n\tbool operator<(const Edge& e)const {\n\t\treturn cost > e.cost;\n\t}\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nEdges prim(const Graph& g)\n{\n\tEdges T;\n\tvector<int> visited(g.size(), 0);\n\tvisited[0] = 1;\n\n\tpriority_queue<Edge> Q;\n\trep(i, g[0].size())\n\t\tQ.push(g[0][i]);\n\n\twhile(!Q.empty()){\n\t\tEdge e = Q.top();\n\t\tQ.pop();\n\t\tif(visited[e.dst])\n\t\t\tcontinue;\n\t\tT.push_back(e);\n\t\tvisited[e.dst] = 1;\n\t\trep(i, g[e.dst].size()){\n\t\t\tif(!visited[g[e.dst][i].dst])\n\t\t\t\tQ.push(g[e.dst][i]);\n\t\t}\n\t}\n\treturn T;\n}\n\nint main()\n{\n\tint n, m;\n\twhile(scanf(\"%d\", &n), n){\n\t\tscanf(\"%d\", &m);\n\t\tGraph g(n);\n\t\trep(i, m){\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tg[a].push_back(Edge(a, b, d));\n\t\t\tg[b].push_back(Edge(b, a, d));\n\t\t}\n\t\tEdges t = prim(g);\n\t\tint ans = 0;\n\t\trep(i, t.size())\n\t\t\tans += t[i].cost / 100 - 1;\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<vector>\n#include<queue>\nusing namespace std;\ntypedef pair<int,int> P;\nvector<P> v[110];\nbool vis[110];\npriority_queue<P,vector<P>,greater<P> > Q;\nint n,m;\nint main(){\n\twhile(cin>>n&&n){\n\tcin>>m;\n\tfor(int i=0;i<n;i++){\n\t\tv[i].clear();\n\t\tvis[i]=false;\n\t}\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,c;char z;cin>>a>>z>>b>>z>>c;c=c/100-1;\n\t\tv[a].push_back(make_pair(c,b));\n\t\tv[b].push_back(make_pair(c,a));\n\t}\n\tQ.push(make_pair(0,0));int ans=0;\n\twhile(!Q.empty()){\n\t\tint x=Q.top().first,y=Q.top().second;//y???x??§?????????\n\t\tQ.pop();\n\t\tif(vis[y])continue;vis[y]=true;ans+=x;\n\t\tfor(int i=0;i<v[y].size();i++){\n\t\t\tQ.push(make_pair(v[y][i].first,v[y][i].second));\n\t\t}\n\t}\n\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1145141919810\n\nint x[1000][1000];\nint color[10000];\nint MIN[10000];\nint sum;\nint sum_min = INF;\n\nint main() {\n\twhile (true) {\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(color, 0, sizeof(color));\n\t\tmemset(MIN, 0, sizeof(MIN));\n\t\tint n, a, b, c, m, e, f, g;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tx[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", &e, &f, &g);\n\t\t\tx[e][f] = g;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tMIN[j] = INF;\n\t\t\t\tcolor[j] = WHITE;\n\t\t\t}\n\t\t\tb = INF;\n\t\t\ta = n;\n\t\t\tcolor[i] = GRAY;\n\t\t\tMIN[i] = 0;\n\t\t\twhile (a != 0) {\n\t\t\t\tb = INF;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\t\tc = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolor[c] = BLACK;\n\t\t\t\ta -= 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (color[k] != BLACK && x[c][k] != -1) {\n\t\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tsum += MIN[j];\n\t\t\t}\n\t\t\tsum_min = min(sum_min, sum);\n\t\t}\n\t\tcout << sum_min / 100 << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nconst int MAX_N = 110;\nconst int MAX_E = 110*110;\n\nint par[MAX_N];\nint rnk[MAX_N];\n\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trnk[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t} else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) {\n\t\treturn;\n\t}\n\tif (rnk[x] < rnk[y]) {\n\t\tpar[x] = y;\n\t} else {\n\t\tpar[y] = x;\n\t\tif (rnk[x] == rnk[y]) rnk[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tint u, v, cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\nedge es[MAX_E];\nint V, E;\n\nint kruskal(void) {\n\tsort(es, es+E, comp);\n\tinit(V);\n\tint res = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += (e.cost-100)/100;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n\tint n, m;\n\twhile (cin >> n) {\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> m;\n\t\tV = n;\n\t\tE = m;\n\t\tint a, b, c;\n\t\tchar cc;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> cc >> b >> cc >> c;\n\t\t\tes[i].u = a;\n\t\t\tes[i].v = b;\n\t\t\tes[i].cost = c;\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int, int> P;\n\nstruct edge {\n\tint u, v, cost;\n};\n\nconst int MAX_N = 100;\nconst int MAX_E = 100*99/2;\nint par[MAX_N];\nint rank[MAX_N];\nedge es[MAX_E];\n\nint V, E;\t//  頂点数と辺数\n\n// n要素で初期化\nint init_union_find (int n )\n{\n\trep (i, n ){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t} // end for\n}\n\n// 木の根を求める\nint find (int x )\n{\n\tif (par[x] == x )\n\t\treturn x;\n\n\t// 親を遡る\n\treturn par[x] = find (par[x] );\n}\n\n// xとyの属する集合をマージ\nvoid unite (int x, int y )\n{\n\tx = find (x);\n\ty = find (y);\n\n\t// 親が一緒なら何もしない\n\tif (x == y )\n\t\treturn;\n\n\t// ランクが小さい方の木をぶら下げる\n\tif (rank[x] < rank[y] ){\n\t\t// x を y にぶら下げる\n\t\tpar[x] = y;\n\t}else{\n\t\t// ランクが同じか rank[x] > rank[y]\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y] )\n\t\t\trank[x]++;\n\t} // end if\n}\n\n// xとyが同じ集合に属するか否か\nbool same (int x, int y )\n{\n\treturn (find (x) == find (y) );\n}\n\nbool comp (const edge& e1, const edge& e2 )\n{\n\treturn e1.cost < e2.cost;\n}\n\nint kruskal (void )\n{\n\tsort (es, es + E, comp );\n\tinit_union_find (V );\n\tint res = 0;\n\trep (i, E ){\n\t\tedge e = es[i];\n\t\tif (!same (e.u, e.v ) ){\n\t\t\tunite (e.u, e.v );\n\t\t\tres += e.cost;\n\t\t} // end if\n\t} // end rep\n\n\treturn res;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.carden_lentern\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tint m;\n\t\tscanf (\"%d\", &m );\n\t\trep (i, m ){\n\t\t\tint from, to, cost;\n\t\t\tscanf (\"%d,%d,%d\", &from, &to, &cost );\n\t\t\tes[i].u = from; es[i].v = to; es[i].cost = cost; \n\t\t} // end rep\n\t\tE = m;\n\t\tV = n;\n\t\tint ans = kruskal();\t// 最小全域木の経路の長さ\n\t\tint res = ans/100 - (V-1);\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "\n//include\n//------------------------------------------\n#include <vector>\n#include <list>\n#include <map>\n#include <set>\n#include <deque>\n#include <queue>\n#include <stack>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <numeric>\n#include <utility>\n#include <sstream>\n#include <iostream>\n#include <iomanip>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <tuple>\n\nusing namespace std;\n\n//conversion\n//------------------------------------------\ninline int toInt(string s) {int v; istringstream sin(s);sin>>v;return v;}\ntemplate<class T> inline string toString(T x) {ostringstream sout;sout<<x;return sout.str();}\n\n//math\n//-------------------------------------------\ntemplate<class T> inline T sqr(T x) {return x*x;}\n\n//typedef\n//------------------------------------------\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<vector<PII> > VVPII;\ntypedef priority_queue<PII, vector<PII>, greater<PII> > PQPII;\n\n//container util\n//------------------------------------------\n#define ALL(a)  (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define PB push_back\n#define MP make_pair\n#define MT make_tuple\n#define SZ(a) int((a).size())\n#define EACH(i,c) for(typeof((c).begin()) i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n\n//repetition\n//------------------------------------------\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n\n//constant\n//--------------------------------------------\nconst double EPS = 1e-10;\nconst double PI  = acos(-1.0);\nconst int DX[] = {0, 1, 0, -1};\nconst int DY[] = {-1, 0, 1, 0};\n\n//other\n//--------------------------------------------\n#define RANGE(a, c, b) ((a <= b) && (b < c))\n\n//clear memory\n#define CLR(a) memset((a), 0 ,sizeof(a))\n\n//debug\n#define dump(x)  cerr << #x << \" = \" << (x) << endl;\n#define debug(x) cerr << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << endl;\n\nconst int INF = (int) 10e9;\n\nint solve(int n, int m){\n\tVVPII node(n);\n\tvector<bool> done(n, false);\n\tchar comma;\n\tREP(i, m){\n\t\tint from, to, cost;\n\t\tcin >> from >> comma >> to >> comma >> cost;\n\t\tnode[from].PB(MP(cost, to));\n\t\tnode[to].PB(MP(cost, from));\n\t}\n\tPQPII q;\n\tint result = 0;\n\tq.emplace(0, 0);\n\tVI costs(n, INF);\n\twhile(!q.empty()){\n\t\tint w = q.top().first, u = q.top().second;\n\t\tq.pop();\n\t\tif(costs[u] < w) continue;\n\t\tresult += w > 0 ? (w / 100) - 1 : 0 ;\n\t\tfor(PII p : node[u]){\n\t\t\tif(p.first < costs[p.second] && !done[p.second]){\n\t\t\t\tdone[u] = true;\n\t\t\t\tcosts[p.second] = p.first;\n\t\t\t\tq.emplace(p.first, p.second);\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nint main(int argc, char const *argv[])\n{\n\tfor(int n, m; cin >> n, n;){\n\t\tcin >> m;\n\t\tcout << solve(n, m) << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<cctype>\n#include<cstdio>\n#include<cmath>\n#include<utility>\n#include<string>\n\n#define REP(n) for(int i = 0;i < n;i++)\n#define LLREP(n) for(long long int  i = 0;i < n;i++)\ntypedef long long int ll;\nusing namespace std;\n#define MAX_A 1000000\n\nint main(){\n\n    int n,m;\n    while(cin >> n,n != 0){\n        cin >> m;\n        //cout << n << m << endl;\n        int a,b,length;\n        char c;\n        int ans = 0;\n        vector<int> map(m+1,MAX_A);\n        for(int i = 0;i < m;i++){\n            cin >> a >> c >> b >> c >> length;\n            //cout << a << \" \" << b << \" \" << length << endl;\n            map[b] = min(map[b],length);\n            //cout << map[b] << endl;\n        }\n        /*REP(m){\n            cout << map[i] << endl;\n        }*/\n\n        for(int i = 1;i < m;i++){\n            ans += map[i]/100-1;\n            //cout << ans << endl;\n        }\n        cout << ans << endl;\n    }\n\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<vector>\n#include<cstdio>\n#include<cstring>\n#include<cmath>\nusing namespace std;\n\n#define rep(i,n) for(int i=0;i<n;i++)\n#define REP(n) rep(i,n)\n\nconst int maxn = 101,maxm = 5500;\n#define inf 10000\n\nint cost[maxn][maxn]={};\nint mincost[maxn] = {};\nbool used[maxn] = {};\nint n,m,a,b,temp;\nchar t;\n\nint main()\n{\n\twhile(cin >> n && n)\n\t{\n\t\tcin >> m;\n\t\tmemset(cost, inf, sizeof(cost));\n\t\tmemset(mincost, inf, sizeof(mincost));\n\t\tmemset(used, false, sizeof(used));\n\t\tmincost[0] = 0;\n\t\t\n\t\tint ans = 0;\n\t\tREP(m)\n\t\t{\n\t\t\tcin >> a >> t >> b >> t >> temp;\n\t\t\tcost[a][b] = (temp/100)-1;\n\t\t\tcost[b][a] = cost[a][b];\n\t\t}\n\t\t\n\t\twhile(1)\n\t\t{\n\t\t\tint minv = inf;\n\t\t\trep(i,n)if(!used[i] &&(mincost[minv] == inf ||mincost[i] < mincost[minv])) minv = i;\n\t\t\tif(minv == inf) break;\n\n\t\t\tused[minv] = true;\n\t\t\tans += mincost[minv];\n\n\t\t\tREP(n) mincost[i] = min(mincost[i], cost[minv][i]);\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <set>\n#include <map>\n#include <list>\n#include <iterator>\n#include <queue>\n#include <stack>\n#include <deque>\n#include <sstream>\n#include <algorithm>\n#include <numeric>\n#include <string>\n#include <cmath>\n#include <complex>\n#include <functional>\n#include <cstdio>\n#include <cstring>\n#include <cstdlib>\n#include <cassert>\n#include <cstdlib>\n#include <cctype>\n\n#define REP(i,m,n) for(int i=m;i<(int)n;i++)\n#define rep(i,n) for(int i=0;i<(int)n;i++)\n#define rrep(i,n) for(int i = 1; i <= n; i++)\n#define drep(i,n) for(int i = n; i >= 0; i--)\n#define rp(i,c) rep(i,(int)c.size())\n#define fr(i,c) for(__typeof((c).begin()) i=(c).begin();i!=(c).end();i++)\n#define mp make_pair\n#define pb push_back\n#define all(c) (c).begin(),(c).end()\n#define rall(u) (u).rbegin(),(u).rend()\n#define dbg(x) cerr<<#x<<\" = \"<<(x)<<endl\n#define v_delete(a,b) (a).erase(remove((a).begin(), (a).end(), b), (a).end())\n#define v_unique(a) (a).erase(unique((a).begin(), (a).end()), (a).end())\n#define VV(T) vector<vector< T > >\nusing namespace std;\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef pair<int,int> pii;\nconst int inf=1<<28;\nconst double INF=1e10,EPS=1e-9;\n\n\ntemplate<class T>int SIZE(T a){return a.size();}\ntemplate<class T>string IntToString(T num){string res;stringstream ss;ss<<num;return ss.str();}\ntemplate<class T>T StringToInt(string str){T res=0;for(int i=0;i<SIZE(str);i++)res=(res*10+str[i]-'0');return res;}\ntemplate<class T>T gcd(T a,T b){if(b==0)return a;return gcd(b,a%b);}\ntemplate<class T>T lcm(T a,T b){return a/gcd(a,b)*b;}\n\ntemplate <class T> void input(T& a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\ntemplate <class T> void input(T* a, int n) { for (int i = 0; i < n; ++i) cin >> a[i]; }\n\nint chmax(int& a,int b){\n\tif(b > a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nint chmin(int& a,int b){\n\tif(b < a){\n\t\ta=b;\n\t}\n\treturn a;\n}\nstruct uf{\nprivate:\n\tvector<int> par;\n\tvector<int> rank;\n\npublic:\n\tuf(int n){\n\t\tfor (int i=0;i<n;i++){\n\t\t\tpar.pb(i);\n\t\t}\n\t\trank.resize(n,0);\n\t}\n\n\tint find(int x){\n\t\tif (par[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\n\tvoid unite(int x,int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif ( x== y ) return;\n\n\t\tif (rank[x] < rank[y] ) {\n\t\t\tpar[x]=y;\n\t\t}else{\n\t\t\tpar[y]=x;\n\t\t\tif(rank[x]==rank[y]) rank[x]++;\n\t\t}\n\t}\n\n\tbool same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n};\n\nstruct edge{\n\tint u,v,cost;\n\tedge(int ui,int vi,int costi):u(ui),v(vi),cost(costi){}\n};\nbool comp(const edge& l,const edge& r){\n\treturn l.cost < r.cost;\n}\nint N,M;\nvector<edge> es;\nint main () {\n\twhile(cin >> N,N){\n\t\tcin >> M;\n\t\trep(i,M){\n\t\t\tint a,b,c;\n\t\t\tchar t;\n\t\t\tcin >> a >> t >> b >>t >> c;\n\t\t\tes.pb(edge(a,b,c/100-1));\n\t\t\tes.pb(edge(b,a,c/100-1));\n\t\t}\n\t\tsort(all(es),comp);\n\t\tuf U(101);\n\t\tint ans=0;\n\t\trep(i,es.size()){\n\t\t\tedge &e = es [i];\n\t\t\tif(!U.same(e.u,e.v)){\n\t\t\t\tU.unite(e.u,e.v);\n\t\t\t\tans += e.cost;\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include \"stdio.h\"\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge{\n    Edge(int t, int c)\n        : to(t), cost(c) {}\n\n    int to;\n    int cost;\n};\n\nbool visited[100];\ntypedef pair<int, int> PII;\nvector<Edge> G[100];\n\nint prim(int start){\n    int ans = 0;\n    fill(visited, visited+100, false);\n\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n\n    que.push(PII(0, start));\n    while (!que.empty()){\n        PII p = que.top();\n        int v = p.second;\n        int cst = p.first;\n        que.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        ans += cst;\n        for (int i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            if (!visited[e.to]){\n                que.push(PII(e.cost, e.to));\n            }\n        }\n    }\n\n    for (int i = 0; i < 100; i++){\n        G[i].clear();\n    }\n    \n    return ans;\n} \n\nint main(int argc, char const *argv[]){\n    int n, m;\n\n    while (cin>>n, n){\n        cin>>m;\n        for (int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            d = (d-100) / 100;\n            G[a].push_back(Edge(b, d));\n            G[b].push_back(Edge(a, d));\n        }\n\n        cout<<prim(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n  \nusing namespace std;\n  \ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\n#define REP(i,n) for(ll i=0;i<n;++i)\n#define REPR(i,n) for(ll i=1;i<n;++i)\n#define FOR(i,a,b) for(ll i=a;i<b;++i)\n  \n#define DEBUG(x) cout<<#x<<\": \"<<x<<endl\n#define DEBUG_VEC(v) cout<<#v<<\":\";REP(i,v.size())cout<<\" \"<<v[i];cout<<endl\n#define ALL(a) (a).begin(),(a).end()\n  \n#define MOD (ll)(1e9+7)\n#define ADD(a,b) a=((a)+(b))%MOD\n#define FIX(a) ((a)%MOD+MOD)%MOD\n\n#define INF 1000000000\n\ntypedef long double Real;\n#define EPS 1e-11\n#define EQ(x) (-EPS<x && x<EPS)\ntypedef complex<Real> P;\nReal dot(P a,P b){return real(conj(a)*b);}\nReal cross(P a,P b){return imag(conj(a)*b);}\n\nint data[252];\nvoid init(){\n  REP(i,252)data[i]=-1;\n}\nint root(int a){\n  return data[a]<0?a:data[a]=root(data[a]);\n}\nvoid unite(int a,int b){\n  a=root(a);b=root(b);\n  if(a!=b){\n    if(data[a]<data[b])swap(a,b);\n    data[a]+=data[b]; data[b]=a;\n  }\n}\nbool same(int a,int b){\n  return root(a)==root(b);\n}\n\nint main(){\n  while(true){\n    int n,m;\n    cin>>n; if(!n)break;\n    cin>>m;\n    pair<int,pii> es[m];\n    REP(i,m){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      es[i].first = c;\n      es[i].second.first = a;\n      es[i].second.second = b;\n    }\n    sort(es,es+m);\n    init();\n    int res = 0;\n    REP(i,m){\n      int a,b,c;\n      a=es[i].second.first;\n      b=es[i].second.second;\n      c=es[i].first;\n      if(!same(a,b)){\n        unite(a,b);\n        res += (c-100)/100;\n      }\n    }\n    cout<<res<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 0072\n#include <iostream>\n#include <vector>\n#include <stdio.h>\n#include <stdlib.h>\nusing namespace std;\n\nstruct road{\n\tint dis;\n\tint v1;\n\tint v2;\n};\n\n\nint findSet(int x, vector<int> &p){\n\tif(x != p[x])\n\t\tp[x] = findSet(p[x], p);\n\treturn p[x];\n}\n\nbool isSameSet(int x, int y, vector<int> &p){\n\treturn findSet(x, p) == findSet(y, p);\n}\n\nvoid link(int x, int y, vector<int> &p, vector<int> &rank){\n\tif(rank[x] > rank[y]){\n\t\tp[y] = x;\n\t}else{\n\t\tp[x] = y;\n\t\tif(rank[x] == rank[y])\n\t\t\trank[y]++;\n\t}\n}\n\nvoid unite(int x, int y, vector<int> &p, vector<int> &rank){\n\tlink(findSet(x, p), findSet(y, p), p, rank);\n}\n\nvoid Sort(vector<road> &ver){\n\troad r;\n\tfor(int i=0;i<ver.size();i++){\n\t\tfor(int j=1;j<ver.size()-i;j++){\n\t\t\tif(ver[j-1].dis > ver[j].dis){\n\t\t\t\tr = ver[j-1];\n\t\t\t\tver[j-1] = ver[j];\n\t\t\t\tver[j] = r;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint lantern(vector<road> ver){\n\tvector<int> rank, p;\n\tfor(int i=0;i<ver.size();i++){\n\t\tp.push_back(i);\n\t\trank.push_back(0);\n\t}\n\n\tint lan = 0;\n\tfor(int i=0;i<ver.size();i++){\n\t\tif(!isSameSet(ver[i].v1, ver[i].v2, p)){\n\t\t\tlan += ver[i].dis/100-1;\n\t\t\tunite(ver[i].v1, ver[i].v2, p, rank);\n\t\t}\n\t}\n\n\treturn lan;\n}\n\nint main(){\n\twhile(1){\n\t\tint n, m, a, b, d;\n\t\tvector<road> ver;\n\t\troad v;\n\n\t\tcin>>n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tv.v1 = a;\n\t\t\tv.v2 = b;\n\t\t\tv.dis = d;\n\t\t\tver.push_back(v);\n\t\t}\n\n\t\tSort(ver);\n\t\t\n\t\tcout<<lantern(ver)<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\nusing namespace std;\n\nvector<vector<int> >vec;\n\nint main(){\n    int n,m,s,g,d;\n    while(cin>>n,n){\n        vector<int>cost(n,100000);\n        vector<bool>used(n,0);\n        for(int i=0;i<n;i++)\n            vec.push_back(cost);\n        cin>>m;\n        int ans=0;\n        char c;\n        for(int i=0;i<m;i++){\n            cin>>s>>c>>g>>c>>d;\n            vec[s][g]=d/100-1;\n            vec[g][s]=d/100-1;\n        }\n        cost[0]=0;\n        while(1){\n            int u=-1;\n            for(int i=0;i<n;i++)\n                if(!used[i]&&(u==-1||cost[i]<cost[u]))u=i;\n            if(u==-1)break;\n            used[u]=1;\n            for(int i=0;i<n;i++)\n                cost[i]=min(cost[i],vec[u][i]);\n            ans+=cost[u];\n        }\n        cout<<ans<<endl;\n        vec.clear();\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <array>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_M = MAX_N * MAX_N;\nint par[MAX_N];\nint myrank[MAX_N];\nint n, m;\n\n\nstruct edge {\n    int a, b, d;\n\n    bool operator<(const edge &r) {\n      return d < r.d;\n    }\n};\n\narray<edge, MAX_M> e;\n\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init() {\n  for (int i = 0; i < MAX_N; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nbool unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y)\n    return false;\n\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n\n  return true;\n}\n\nint main() {\n  int count, t;\n\n  while (cin >> n, n) {\n    cin >> m;\n    init();\n\n    t = 0;\n    for (int i = 0; i < m; i++)\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n\n    sort(e.begin(), e.begin() + m);\n    for (int i = 0; i < m; ++i) {\n      if (unite(e[i].a, e[i].b))\n        t += e[i].d - 100 ;\n    }\n    cout << t / 100 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\n#define MAX_V 111\n#define INF (1<<21)\n\nint cost[MAX_V][MAX_V]={{0}};\nint mincost[MAX_V]={};\nbool used[MAX_V]={};\nint V;\n\n\nint prim(void);\nint min(int a,int b);\n\nint main(){\n  int m;\n  \n  scanf(\"%d\",&V);\n  \n  while(1){\n    if(V==0) break;\n    scanf(\"%d\",&m);\n    \n    \n    for(int i=0;i<V;i++){\n      for(int j=0;j<V;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    \n\n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b] = c/100 - 1;\n      cost[b][a] = c/100 - 1;\n    }\n    \n    printf(\"%d\\n\",prim());\n    \n    scanf(\"%d\",&V);\n  }\n  \n  return 0;\n}\n\nint min(int a,int b){\n  if(a>b) return b;\n  return a;\n}\n\nint prim(void){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(!used[u] && (v==-1 || mincost[u] <  mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for(int u = 0;u < V;u++){\n      //if(cost[v][u]==0);\n      //else{\n\tmincost[u] = min(mincost[u], cost[v][u]);\n\t//     }\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<queue>\n#include<cstdio>\n#include<vector>\n#include<climits>\n#include<iostream>\n#include<algorithm>\n\n#define\tmp(a,b)\tmake_pair((a),(b))\n#define\tdis\t\tfirst\n#define\tnode\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tpair<int,pii>\tpipii;\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tvector<bool> chk(n,false);\n\n\t\tint m;\tcin>>m;\n\t\tvector<pipii> mst;\n\t\twhile(m--){\n\t\t\tint a,b,dis;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&dis);\n\t\t\tmst.push_back(mp(dis,mp(a,b)));\n\t\t}\n\n\t\tsort(mst.begin(),mst.end());\n\n\t\tint total=0;\n\t\tfor(int i=0;i<mst.size();i++){\n\t\t\tif(!chk[mst[i].node.first] || !chk[mst[i].node.second]){\n\t\t\t\tchk[mst[i].node.first]=true;\n\t\t\t\tchk[mst[i].node.second]=true;\n\t\t\t\ttotal+=mst[i].dis/100-1;\n\t\t\t}\n\t\t}\n\n\t\tcout<<total<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <vector>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <set>\n#include <bitset>\n#include <map>\n#include <unordered_map>\n#include <ctime>\n#include <list>\n#include <numeric>\n#include <utility>\n#include <ctime>\n#define INF 1000000000\n#define LINF 9000000000000000000\n#define mod 1000000007\n\n#define rep(i,n) for(int i=0;i<int(n);i++)\n#define rrep(i,n) for(int i=n-1;i>=0;i--)\n#define REP(i,a,b) for(int i=(a);i<int(b);i++)\n#define all(x) (x).begin(),x.end()\n#define pb push_back\n#define mp make_pair\n#define MOD(x) (x%(mod))\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef pair<int,int> pi;\n\nint dx[4]={1,0,-1,0};\nint dy[4]={0,1,0,-1};\nint ddx[8]={-1,-1,0,1,1,1,0,-1};\nint ddy[8]={0,1,1,1,0,-1,-1,-1};\nbool debug=false;\n\n/*---------------------------------------------------*/\n\n#define MAX_N 105\n\nint par[MAX_N]; // 親\nint Rank[MAX_N]; // 木の深さ\n\nvoid init_union_find(int n){\n  for(int i=0;i<n;i++){\n    par[i]=i;\n    Rank[i]=0;\n  }\n}\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else{\n    return par[x]=find(par[x]);\n  }\n}\nvoid unite(int x,int y){\n  x=find(x);\n  y=find(y);\n  if(x==y)return;\n\n  if(Rank[x]<Rank[y]){\n    par[x]=y;\n  }else{\n    par[y]=x;\n    if(Rank[x]==Rank[y])Rank[x]++;\n  }\n}\nbool same(int x,int y){\n  return find(x)==find(y);\n}\n\nstruct edge{int u,v,cost;};\nbool comp(const edge& e1,const edge& e2){\n  return e1.cost<e2.cost;\n}\n\nedge es[10005];\nint V,E;\n\nint kruskall(){\n  sort(es,es+E,comp);\n  init_union_find(V);\n  int res=0;\n  for(int i=0;i<E;i++){\n    edge e=es[i];\n    if(!same(e.u,e.v)){\n      unite(e.u,e.v);\n      res+=e.cost;\n    }\n  }\n  return res;\n}\n\nint main(){\n  int n,m;\n  while(cin>>n){\n    if(n==0)break;\n    cin>>m;\n    V=n;E=m;\n    rep(i,m){\n      scanf(\"%d,%d,%d\",&es[i].u,&es[i].v,&es[i].cost);\n      es[i].cost=es[i].cost/100-1;\n    }\n    cout<<kruskall()<<endl;\n  }\n  return 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n\n\nusing namespace std;\n\nstring bom[8];\n\nclass Graph{\npublic:\n    int a;\n    int b;\n    int ab;\n};\n\n\nbool asc( const Graph& left, const Graph& right ) {\n    return left.ab<right.ab;\n}\n\n\n\n\nint main(void) {\n    Graph gr[100];\n    \n    while(1){\n        int n,m;\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        for(int i=0; i<m; i++){\n            scanf(\"%d,%d,%d\",&gr[i].a,&gr[i].b,&gr[i].ab);\n            if(gr[i].a>gr[i].b)swap(gr[i].a,gr[i].b);\n            //cin>>gr[i].a>>gr[i].b>>gr[i].ab;\n        }\n        sort(gr, gr+m, asc);\n        /*for(int i=0; i<m; i++){\n            cout<<gr[i].a<<\" \"<<gr[i].b<<\" \"<<gr[i].ab<<endl;\n        }*/\n        int check[100]={0};\n        int dist=0;\n        check[gr[0].a]++;\n        check[gr[0].b]++;\n        dist+=gr[0].ab-200;\n        while(1){\n            int count=0;\n            for(int i=0; i<m; i++)count+=check[i];\n            if(count==m)break;\n            for(int i=0; i<m; i++){\n                if(check[gr[i].a]==1&&check[gr[i].b]==1);\n                else if(check[gr[i].a]==1){\n                    check[gr[i].b]++;\n                    dist+=gr[i].ab;\n                    break;\n                }else if(check[gr[i].b]==1){\n                    check[gr[i].a]++;\n                    dist+=gr[i].ab-100;\n                    break;\n                }\n            }\n            \n        }\n        cout<<dist/100<<endl;\n        \n        \n        \n    }\n    \n    \n    \n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <string>\n#include <bitset>\n#include <map>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <string.h>\n\n#define X first\n#define Y second\n#define MP make_pair\ntypedef long long ll;\nusing namespace std;\nconst int MAX = 101;\n\nint root[101];\nint ranks[101];\n\nstruct E{\n\tE(int from, int to, int cost):from(from), to(to), cost(cost){}\n\tint from, to, cost;\n\tbool operator < (const E & e)const{\n\t\treturn cost < e.cost;\n\t}\n};\n\nvoid Init(){\n\tfor(int i = 0; i < MAX; i++){\n\t\troot[i] = i;\n\t\tranks[i] = 1;\n\t}\n}\n\nint find(int x){\n\tif(root[x] == x) return x;\n\telse return root[x] = find(root[x]);\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\tif(ranks[x] < ranks[y]){\n\t\troot[x] = y;\n\t}else{\n\t\troot[y] = x;\n\t\tif(ranks[x] == ranks[y]) ranks[x]++;\n\t}\n}\n\nint main(){\n\tint n, m;\n\twhile(cin >> n && n != 0){\n\t\tcin >> m;\n\t\tInit();\n\t\tvector<E> tb;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint a, b, cost;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &cost);\n\t\t\ttb.push_back(E(a, b, cost));\n\t\t}\n\n\t\tsort(tb.begin(), tb.end());\n\n\t\tint ans = 0;\n\t\tfor(int i = 0; i < tb.size(); i++){\n\t\t\tif(find(tb[i].from) != find(tb[i].to)){\n\t\t\t\tans += (tb[i].cost/100) - 1;\n\t\t\t\tunite(tb[i].from, tb[i].to);\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_V 100\n#define INF 1e9\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];//集合Xからの辺の最小コスト\nbool used[MAX_V];//頂点iがXに含まれてるか\nint V;\n\nint prim(){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res=0;\n  while(true){\n    int v = -1;\n    \n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true; //頂点vをXに追加\n    res += mincost[v]; //円のコストを加える\n    for(int u=0;u<V;u++) mincost[u] = min(mincost[u],cost[v][u]);\n  }\n  return res;\n}\n\n\nint main(){\n  int E;\n  while(cin >> V){\n    if(V==0) break;\n    cin >> E;\n    for(int i=0;i<E;i++){\n      for(int j=0;j<E;j++){\n        cost[i][j] = cost[j][i] = (i==j ? 0 : INF);\n      }\n    }\n\n    int a,b,dist;\n    char camma;\n    for(int i=0;i<E;i++){\n      cin >> a >> camma >> b >> camma >> dist;\n      a; b;\n      cost[a][b] = cost[b][a] = dist;\n    }\n    \n    int sum_of_costs = prim();\n    int lanterns = sum_of_costs/100 - (V - 1); \n    //n00mを100mで分割すると分割点はn-1個\n    cout << lanterns << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define FOR(i, s, n) for(int i = s; i < (int)n; i++)\n#define per(i, n) for(int i = n; i >= 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(), (a).rend()\n#define MP make_pair\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define dump(x) cout << #x << \" = \" << (x) << \"\\n\";\n#define debug(x) cout << #x << \" = \" << (x) << \" (L\" << __LINE__ << \")\" << \" \" << __FILE__ << \"\\n\";\n#define sq(n) (n) * (n)\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int, int> PII;\ntypedef long long LL;\ntypedef vector<LL> VLL;\ntypedef vector<VLL> VVLL;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\ntypedef priority_queue<int> maxpq;\ntypedef priority_queue< int, vector<int>, greater<int> > minpq;\ntypedef complex<double> P;\nstatic const double EPS = 1e-10;\nstatic const double PI = acos( -1.0 );\nstatic const int mod = 1000000007;\nstatic const int INF = 1 << 29;\nstatic const LL LL_INF = 1152921504606846976;\nstatic const int dx[] = { -1, 0, 1, 0, 1, -1, 1, -1 };\nstatic const int dy[] = { 0, -1, 0, 1, 1, 1, -1, -1 };\n\nstruct Union_Find {\n\tvector<int> par;\n\tvector<int> rank;\n\n\tvoid init( int n ) {\n\t\tfor ( int i = 0; i < n; ++i ) {\n\t\t\tpar.push_back( i );\n\t\t\trank.push_back( 0 );\n\t\t}\n\t}\n\n\tint find( int s ) {\n\t\tif ( par[ s ] == s ) {\n\t\t\treturn s;\n\t\t}\n\t\treturn par[ s ] = find( par[ s ] );\n\t}\n\n\tvoid unite( int x, int y ) {\n\t\tint a = find( x ), b = find( y );\n\t\tif ( a == b ) {\n\t\t\treturn;\n\t\t}\n\t\tif ( rank[ x ] < rank[ y ] ) {\n\t\t\tpar[ x ] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[ y ] = x;\n\t\t\tif ( rank[ x ] == rank[ y ] ) {\n\t\t\t\t++rank[ x ];\n\t\t\t}\n\t\t}\n\t}\n\n\tbool same( int x, int y ) {\n\t\treturn find( x ) == find( y );\n\t}\n};\n\nint main() {\n\tint n, m;\n\twhile ( ~scanf( \"%d\", &n ) && n ) {\n\t\tscanf( \"%d\", &m );\n\t\tVVI root( n, VI( n, INF ) );\n\t\tfor ( int i = 0; i < m; i++ ) {\n\t\t\tint a, b, c;\n\t\t\tscanf( \"%d,%d,%d\", &a, &b, &c );\n\t\t\troot[ a ][ b ] = root[ b ][ a ] = c / 100 - 1;\n\t\t}\n\t\tUnion_Find u;\n\t\tu.init( n );\n\t\tint ans = 0;\n\t\tfor ( int i = 1; i < n; i++ ) {\n\t\t\tint _min = INF, add;\n\t\t\tfor ( int j = 0; j < n; j++ ) {\n\t\t\t\tif ( !u.same( 0, j ) ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tfor ( int k = 1; k < n; k++ ) {\n\t\t\t\t\tif ( !u.same( 0, k ) && _min >= root[ j ][ k ] ) {\n\t\t\t\t\t\tadd = k;\n\t\t\t\t\t\t_min = root[ j ][ k ];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tu.unite( 0, add );\n\t\t\tans += _min;\n\t\t}\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <queue>\n#include <utility>\nusing namespace std;\n\nconst int inf = 1 << 29;\n\nclass Edge {\npublic:\n    int c, i;\n    Edge(int cc, int ii) {\n        c = cc;\n        i = ii;\n    }\n    friend bool operator< (const Edge &e1, const Edge &e2) {\n        return (e1.c > e2.c) || (e1.c == e2.c && e1.i > e2.i);\n    }\n};\n\nclass Node {\npublic:\n    vector<pair<int, int> > tos;\n    int i;\n    bool d;\n};\n\nint n;\nvector<Node> ns;\n\nint run() {\n    for (int i = 0; i < n; i++) {\n        ns[i].i = i;\n        ns[i].d = false;\n    }\n    priority_queue<Edge> q;\n    q.push(Edge(0, 0));\n    int ans = 0;\n    while (!q.empty()) {\n        Edge e = q.top();\n        q.pop();\n        int i = e.i;\n        if (ns[i].d) {\n            continue;\n        }\n        ns[i].d = true;\n        ans += e.c;\n        for (vector<pair<int, int> >::iterator it = ns[i].tos.begin(); it != ns[i].tos.end(); it++) {\n            int to = it->first;\n            int c = it->second;\n            if (!ns[to].d) {\n                q.push(Edge(c, ns[to].i));\n            }\n        }\n    }\n    return ans;\n}\n\nint main() {\n    while (cin >> n, n) {\n        int m;\n        cin >> m;\n        ns.resize(n);\n        for (int i = 0; i < m; i++) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            c = c / 100 - 1;\n            ns[a].tos.push_back(make_pair(b, c));\n            ns[b].tos.push_back(make_pair(a, c));\n        }\n        cout << run() << endl;;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<cassert>\n#include<cctype>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<cstring>\n#include<iostream>\n#include<iomanip>\n#include<map>\n#include<numeric>\n#include<queue>\n#include<vector>\n#include<set>\n#include<string>\n#include<stack>\n#include<sstream>\n#include<complex>\n\n#define pb push_back\n#define clr clear()\n#define sz size()\n#define fs first\n#define sc second\n\n#define rep(i,a) for(int i=0;i<(int)(a);i++)\n#define rrep(i,a) for(int i=(int)(a)−1;i>=0;i−−)\n#define all(a) (a).begin(),(a).end()\n#define EQ(a,b) (abs((a)−(b)) < EPS)\n#define INIT(a) memset(a,0,sizeof(a))\n\nusing namespace std;\ntypedef double D;\ntypedef pair<int,int> P;\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<string> vs;\n\nconst D EPS = 1e-8;\nconst int INF = 1e8;\nconst D PI = acos(-1);\n\nint par[10000]; //親ノート&#12441;\nint r[10000]; //木の高さ\n\nvoid init(int n){\n  for(int i=0;i<n;i++){par[i] = i;r[i] = 0;}\n}\n\nint find(int x){\n  if(par[x] == x) return x;\n  return par[x] = find(par[x]);\n}\n\nvoid unite(int x,int y){\n  x = find(x);\n  y = find(y);\n  if(x==y)return;\n  if(r[x] < r[y])par[x] = y;\n  else par[y] = x;\n  if(r[x] == r[y])r[x]++;\n}\n\nbool same(int x,int y){return find(x)==find(y);}\n\nint v; //頂点数\nint m;\nint a,b,c;\n//辺の定義。必要に応し&#12441;て削る\nstruct edge{\n  int from,to,cost;\n  bool operator<(const edge x)const{return cost>x.cost;}\n};\n\nvector<edge> G[10000];\nvoid AddEdge(int s,int g,int p){\n  G[s].pb((edge){s,g,p});\n}\n\nint Kruskal(){\n  init(v);\n  priority_queue<edge> q;\n  rep(i,v)rep(j,G[i].sz)q.push(G[i][j]);\n\n  int res = 0;\n  while(q.size()){\n    edge e = q.top(); q.pop();\n    if(!same(e.from,e.to)){\n      res += e.cost;\n      unite(e.from,e.to);\n    }\n  }\n  return res;\n}\n\nint main(){\n  while(cin >> v,v){\n    cin >> m;\n    rep(i,v)G[i].clr;\n    rep(i,m){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      AddEdge(a,b,c/100-1);\n    }\n\n    cout << Kruskal() <<  endl;\n  }\n    \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define MAX_V 100\n#define INF (1<<21)\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\nint prim(){\n  for(int i = 0; i < V; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(1){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u = 0; u < V; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  while(1){\n    cin >> V;\n    if(V == 0) break;\n    for(int i = 0; i < V; i++){\n      for(int j = 0; j < V; j++){\n\tcost[i][j] = INF;\n      }\n    }\n    cin >> m;\n    for(int i = 0; i < V; i++){\n      int a, b, c;\n      char d, e;\n      cin >> a >> d >> b >> e >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    int t = prim();\n    t = t / 100 - m + 1;\n    cout << t << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\t//rep(i, 0, n) {\n\t\t//\tchar c;\n\t\t//\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t//\tg[a].emplace_back(Edge(a, b, d));\n\t\t//\tg[b].emplace_back(Edge(b, a, d));\n\t\t//}\n\t\t//pair<Weight, Edges> k = kruskal(g);\n\t\t//cout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<string>\n#include<cmath>\n#include<queue>\n#include<vector>\n#include<functional>\nusing namespace std;\nstruct P {\n\tint from, to, cost;\n};\nint parent[10000];\nint root(int x) {\n\tif (parent[x] == x) return x;\n\treturn parent[x] = root(parent[x]);\n}\nvoid unite(int x, int y) {\n\tx = parent[x];\n\ty = parent[y];\n\tparent[x] = y;\n}\nbool same(int x, int y) {\n\treturn root(x) == root(y);\n}\nbool operator<(P a, P b) {\n\treturn a.cost < b.cost;\n}\nbool operator>(P a, P b) {\n\treturn a.cost > b.cost;\n}\nint main() {\n\tint n, m;\n\twhile (cin >> n&&n != 0) {\n\t\tcin >> m;\n\t\tpriority_queue<P, vector<P>, greater<P>>p;\n\t\tint a, b, c;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf_s(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tp.push(P{ a,b,c });\n\t\t}\n\t\tfor (int i = 0; i < n; i++) parent[i] = i;\n\t\tint d = 0,sum=0;\n\t\twhile (d != n - 1) {\n\t\t\tP t = p.top(); p.pop();\n\t\t\tif (!same(t.from, t.to)) {\n\t\t\t\tunite(t.from, t.to);\n\t\t\t\td++;\n\t\t\t\tsum += t.cost;\n\t\t\t}\n\t\t}\n\t\tsum /= 100;\n\t\tsum = sum - n + 1;\n\t\tcout << sum << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\n\nusing namespace std;\n\nint graph[100][100];\nint near[100];\nbool is_not_use[100];\nint n,m;\nint l;\n\nvoid ini(){\n    l=0;\n    for(int i=0; i<100; i++){\n        for(int j=0; j<100; j++){\n            graph[i][j]=2147483647;\n        }\n    }\n    for(int i=0; i<100; i++){\n        near[i]=2147483647;\n        is_not_use[i]=true;\n    }\n}\n\nvoid prim(){\n    int v=0;\n    int min_cost=2147483647-1;\n    for(int i=0; i<n; i++){\n        if(min_cost>near[i]&&is_not_use[i]){\n            min_cost=near[i];\n            v=i;\n        }\n    }\n    is_not_use[v]=false;\n    l+=min_cost;\n    for(int i=0; i<n; i++){\n        if(near[i]>graph[v][i]){\n            near[i]=graph[v][i];\n        }\n    }\n    bool flag=false;\n    for(int i=0; i<n; i++){\n        if(is_not_use[i])flag=true;\n    }\n    if(flag)prim();\n}\n\n\n\nint main(void)\n{\n    while(1){\n        ini();\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        for(int i=0; i<m; i++){\n            int a,b,c;\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            graph[a][b]=c;\n            graph[b][a]=c;\n        }\n        is_not_use[0]=false;\n        for(int i=0; i<n; i++){\n            near[i]=graph[0][i];\n        }\n        prim();\n        cout<<l/100-n+1<<endl;\n        \n        \n        \n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<ios>\n#include<algorithm>\nusing namespace std;\n#include<vector>\nstruct UF{\n\tint n;\n\tvector<int>parent,rank;\n\tUF(int n_=0):n(n_),parent(n_),rank(n_,0)\n\t{\n\t\tfor(int i=0;i<n_;i++)parent[i]=i;\n\t}\n\tint find(int a)\n\t{\n\t\treturn parent[a]!=a?parent[a]=find(parent[a]):a;\n\t}\n\tbool same(int a,int b)\n\t{\n\t\treturn find(a)==find(b);\n\t}\n\tbool unite(int a,int b)\n\t{\n\t\ta=find(a),b=find(b);\n\t\tif(a==b)return false;\n\t\tif(rank[a]<rank[b])\n\t\t{\n\t\t\tparent[a]=b;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tparent[b]=a;\n\t\t\tif(rank[a]==rank[b])rank[a]++;\n\t\t}\n\t\treturn true;\n\t}\n};\nmain()\n{\n    int n;\n    while(cin>>n,n)\n    {\n        int m;cin>>m;\n        int ans=0;\n        vector<pair<int,pair<int,int> > >e;\n        for(;m--;)\n        {\n            int a,b,c;scanf(\"%d,%d,%d\",&a,&b,&c);\n            c=c/100-1;\n            e.push_back(make_pair(c,make_pair(a,b)));\n        }\n        UF uf(n);\n        sort(e.begin(),e.end());\n        for(int i=0;i<e.size();i++)\n        {\n            int a=e[i].second.first,b=e[i].second.second,c=e[i].first;\n            if(uf.same(a,b))continue;\n            uf.unite(a,b);\n            ans+=c;\n        }\n        cout<<ans<<endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\n\nstruct P{\n    int edge;\n    int cost;\n};\n\nint n,m;\nint ans;\nint E[150];\nvector<P> V[150];\nP p;\n\nsigned main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            p={y,z};\n            V[x].PB(p);\n            p={x,z};\n            V[y].PB(p);\n        }\n        rep(i,n){\n            P res;\n            res.cost=INT_MAX;\n            rep(j,V[i].size()){\n                if(E[i]==1&&E[V[i][j].edge]==1)continue;\n                //cout<<V[i][j].cost<<\" \"<<V[i][j].edge<<endl;\n                if(res.cost>V[i][j].cost){\n                    res.cost=V[i][j].cost;\n                    res.edge=V[i][j].edge;\n                }\n            }\n            if(res.cost==INT_MAX)continue;\n            ans+=res.cost-100;\n            E[i]=1;\n            E[res.edge]=1;\n        }\n        cout<<ans/100<<endl;\n        rep(i,n)V[i].clear();\n        memset(E,0,sizeof(E));\n\n        ans=0;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <math.h>\n#include <algorithm>\n#include <climits>\n#include <vector>\n\nusing namespace std;\n\ntypedef vector< bool > BVI;\ntypedef vector< int > VI;\ntypedef vector< VI > VVI;\n\nint main() {\n\tint n, m;\t\n\n\twhile( true ) {\n\n\t\tcin >> n;\n\n\t\tif( n == 0 ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tcin >> m;\n\n\t\tVVI map(n, VI(n, INT_MAX / 4));\n\t\tVI mincost(n, INT_MAX / 4);\n\t\tBVI used(n, false);\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\t\tint a, b, c;\n\t\tchar dummy;\n\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tcin >> a >> dummy >> b >> dummy >> c;\n\t\t\tmap[a][b] = (c / 100) - 1;\n\t\t\tmap[b][a] = (c / 100) - 1;\n\t\t}\n\n\t\twhile( true ) {\n\t\t\tint v = -1;\n\t\t\tfor(int u = 0; u < n; u++) {\n\t\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) {\n\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif( v == -1 ) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v];\n\n\t\t\tfor(int u = 0; u < n; u++) {\n\t\t\t\tmincost[u] = min(mincost[u], map[v][u]);\n\t\t\t}\n\t\t}\n\n\n\t\tcout << res << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\nusing namespace std;\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INFTY 1000000000\n\nint n,M[101][101],color[101],d[101],p[101];\n\nvoid prim() {\n  for ( int i = 0; i < 101; i++ ) {\n    color[i] = WHITE;\n    d[i] = INFTY;\n    p[i] = -1;\n  }\n  \n  d[0] = 0;\n  int u;\n  while(1){\n    u = -1;\n    int mincost = INFTY;\n\n    for ( int i = 0; i < n; i++ ) {\n      if ( color[i] != BLACK && d[i] < mincost ) {\n\tmincost = d[i];\n\tu = i;\n      }\n    }\n\n    if ( u == -1 ) break;\n\n    color[u] = BLACK;\n    \n    for ( int v = 0; v < n; v++ ) {\n      if ( color[v] != BLACK && M[u][v] != INFTY ) {\n\tif ( M[u][v] < d[v] ) {\n\t  d[v] = M[u][v];\n\t  p[v] = u;\n\t  color[v] = GRAY;\n\t}\n      }\n    }\n  }\n  int ans = 0;\n\n  for ( int i = 1; i < n; i++ ) {\n    // cout << d[i] << \" \" ;\n    int tmp = d[i]/100-1;\n    //   cout << tmp  << endl;\n    ans += tmp;\n  }\n  // cout << endl;\n  cout << ans << endl;\n}\n\n  int main() {\n    while(1) {\n    for ( int i = 0; i  < 101; i++ ) {\n      for ( int j = 0; j < 101; j++ ) {\n\tM[i][j] = INFTY;\n      }\n    }\n    cin >> n;\n    if ( n == 0 ) break;\n    int m; cin >> m;\n    char ch;\n    for ( int i = 0; i < m; i++ ) {\n      int a,b,distance;\n      cin >> a >> ch >> b >> ch >> distance;\n      M[a][b] = distance;\n    }\n  \n    prim();\n    }\n    return 0;\n  }"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <cassert>\n#include <algorithm>\n#include <functional>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <stack>\n#include <queue>\n#include <map>\n#include <bitset>\n#include <sstream>\n#include <istream>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define vci vector<int>\n#define vcs vector<string>\n#define pb push_back\n#define sz size()\n#define mapii map<int, int>\n#define mapci map<char, int>\n#define mapsi map<string, int>\n#define all(x) x.begin(), x.end()\n#define minit(a, i) memset(a, i, sizeof(a));\n\n#define for_(i, a, b) for (int i=(int)a; i<(int)b; i++)\n#define for_d(i, a, b) for (int i=(int)a-1; i>=b; i--)\n#define for_r(i, a, b, c) for (int i=(int)a; i<(int)b; i += c)\n#define for_dr(i, a, b, c) for (int i=(int)a-1; i>=b; i -= c)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n\ntemplate <class T> int __builtin_popcount(T n) { return n ? 1 + __builtin_popcount(n & (n - 1)) : 0; }\n\ntypedef long long ll;\ntypedef double D;\n\nconst int iINF = 2147483647;\nconst ll lINF = 9223372036854775807;\n\ntemplate <class T> inline void dbg(T t) { cout << t << endl; }\n\n\n\ntypedef int Weight;\n\nstruct Edge {\n\tint from, to;\n\tWeight weight;\n\tEdge(int f, int t, int w) : from(f), to(t), weight(w) { }\n};\n\nbool operator < (const Edge& e, const Edge& f) {\n\treturn e.weight != f.weight ? e.weight > f.weight : \n\t\t\te.from != f.from ? e.from < f.from : e.to < f.to;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\ntypedef vector<Weight> Array;\t// vector<int>\ntypedef vector<Array> Matrix;\t//vector< vector<int> >\n\n// prim\npair<Weight, Edges> prim(const Graph&g, int r = 0) {\n\tint n = g.size();\n\tEdges T;\n\tWeight total = 0;\n\t\n\tvector<bool> visited(n, false);\n\tpriority_queue<Edge> q;\n\tq.push(Edge(-1, r, 0));\n\t\n\twhile (!q.empty()) {\n\t\tEdge e = q.top(); q.pop();\n\t\tif (visited[e.to])continue;\n\t\tT.push_back(e);\n\t\ttotal += e.weight;\n\t\tvisited[e.to] = true;\n\t\tFOR(f, g[e.to]) if (!visited[f->to]) q.push(*f);\n\t}\n\t\n\treturn pair<Weight, Edges>(total, T);\n}\n\nint main() {\n\tint n, m;\n\t\n\twhile (1) {\n\t\tcin >> n; if (n==0) break;\n\t\tcin >> m;\n\t\t\n\t\tGraph g(n);\n\t\t\n\t\tint a, b, w;\n\t\tfor_(i, 0, m) {\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &w);\n\t\t\tg[a].pb(Edge(a,b,w/100-1));\n\t\t\tg[b].pb(Edge(b,a,w/100-1));\n\t\t}\n\t\t\n\t\tpair<Weight, Edges> ret = prim(g, 0);\n\t\tcout << ret.first << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass UnionFind\n{\npublic:\n    UnionFind(int n) : parent(n), rank(n)\n    {\n        for(int i = 0; i < n; ++i) parent[i] = i;\n    }\n    \n    int root(int x)\n    {\n        if(parent[x] == x) return x;\n        else return parent[x] = root(parent[x]);\n    }\n    \n    bool same(int x, int y)\n    {\n        return root(x) == root(y);\n    }\n    \n    void unite(int x, int y)\n    {\n        x = root(x);\n        y = root(y);\n        if(x == y) return;\n        if(rank[x] < rank[y]){\n            parent[x] = y;\n        } else {\n            parent[y] = x;\n            if(rank[x] == rank[y]){\n                rank[x]++;\n            }\n        }\n    }\n\nprivate:\n    vector<int> parent, rank;\n};\n\nstruct Edge\n{\n    int u, v, cost;\n    bool operator<(const Edge& rhs) const\n    {\n        return cost < rhs.cost;\n    }\n};\n\nvector<Edge> E;\n\nint main()\n{\n    int n, m, a, b, c;\n    while(1){\n        scanf(\"%d\", &n);\n        if(n == 0) break;\n        scanf(\"%d\", &m);\n        for(int i = 0; i < m; ++i){\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            Edge e = {a, b, c / 100 - 1};\n            E.push_back(e);\n        }\n        \n        sort(E.begin(), E.end());\n        \n        UnionFind uf(n);\n        int ans = 0;\n        for(int i = 0; i < E.size(); ++i){\n            if(!uf.same(E[i].u, E[i].v)){\n                ans += E[i].cost;\n                uf.unite(E[i].u, E[i].v);\n            }\n        }\n        printf(\"%d\\n\", ans);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint V, E;\nvector<vector<edge>> es;\nbool used[10000];\n\npair<int, vector<edge>> prim()\n{\n\tmemset(used, false, sizeof(used));\n\tvector<edge> res;\n\tint sum = 0;\n\n\tpriority_queue<edge, vector<edge>, greater<edge>> que;\n\tque.push(edge{ -1, 0, 0 });\n\n\twhile (!que.empty())\n\t{\n\t\tedge e = que.top(); que.pop();\n\t\tif (used[e.to]) continue;\n\t\tif (e.from >= 0) res.push_back(e);\n\t\tsum += e.cost;\n\t\tused[e.to] = true;\n\t\tfor (edge i : es[e.to])\n\t\t{\n\t\t\tif (!used[i.to]) que.push(i);\n\t\t}\n\t}\n\treturn pair<int, vector<edge>>(sum, res);\n}\n\nint main()\n{\n\twhile (cin >> V >> E, V)\n\t{\n\t\tes.resize(V);\n\t\tREP(i, E)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tes[a].push_back(edge{ a, b, c });\n\t\t\tes[b].push_back(edge{ b, a, c });\n\t\t}\n\t\tcout << prim().first / 100 - (V - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w > e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\n//????°???¨?????¨\n//Prim O(ElogV)\n//r????????°?????????????????????????±?\n//Edge??? bool operator<(const Edge &e)const { return w > e.w; } ????????????????????????\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n\tEdges T; Weight total = 0; vector<int> v(g.size());\n\tpriority_queue <Edge> q;\n\tq.emplace(-1, r, 0);\n\twhile (q.size()) {\n\t\tEdge e = q.top(); q.pop();\n\t\tif (v[e.d]) continue;\n\t\tv[e.d] = true;\n\t\ttotal += e.w; if (e.s != -1) T.emplace_back(e);\n\t\tfor (auto &f : g[e.d]) if (!v[f.d]) q.emplace(f);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].emplace_back(Edge(a, b, d));\n\t\t\tg[b].emplace_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = prim(g, 0);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <algorithm>\n\n#define REP(i,n) for(int i=0;i<(n);i++)\n\n#define INF 1e9\n#define MAX_N 100\n\nint n, m;\nint cost[MAX_N][MAX_N];\nbool used[MAX_N];\nint mincost[MAX_N];\n\nusing namespace std;\n\nint prim(void)\n{\n    //init\n    REP(i,n){\n        used[i] = false;\n        mincost[i] = INF;\n    }\n    //start from 0th vertex\n    mincost[0] = 0; \n    //search\n    int dist = 0;\n    while(true){\n        //search the edge with minimum cost\n        int v = -1;\n        REP(u,n) if(!used[u] && (v==-1||mincost[u]<mincost[v])) v = u;\n        if(v == -1) break;\n        //set v as used vertex\n        used[v] = true;\n        dist += mincost[v];\n        //update minimum cost\n        REP(u,n) mincost[u] = min(mincost[u], cost[v][u]);\n    }\n    return dist;\n}\n\nvoid solve(void)\n{\n    while(true){\n        scanf(\"%d\", &n);\n        if(n==0) return;\n        scanf(\"%d\", &m);\n        REP(i,n) REP(j,n) cost[i][j] = INF;\n        REP(i,m){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            cost[b][a] = cost[a][b] = d/100-1;\n        } \n        printf(\"%d\\n\", prim());\n    }\n}\n\nint main(void)\n{\n    solve();\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<string>\n#include<algorithm>\n#include<cmath>\n#include<queue>\ntypedef long long int ll;\n#define FOR(i,a,n) for(int i=a;i<n;++i)\n#define TFOR(i,n)FOR(i,0,n)\n#define ALL(x) x.begin(),x.end();\nconst int INF = 1LL << 30;\nconst ll LLINF = 1LL << 60;\nint V;//??????\nint E;//???\nstruct edge { int from, to, cost; };\ntypedef std::pair<int, int> PP;\nstd::vector<edge> e;\nint Par[100000];\nint Rank[100000];\nvoid init(int n) {\n\tfor (int i = 0; i < n; i++) {\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\nint find(int x) {\n\tif (Par[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\nvoid unite(int  x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\tif (Rank[x] < Rank[y]) {\n\t\tPar[x] = y;\n\t}\n\telse {\n\t\tPar[y] = x;\n\t\tif (Rank[x] == Rank[y])Rank[x]++;\n\t}\n}\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n// ??????????????????????????????????????¢??° \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\nint kruskal() {\n\tinit(V);\n\tsort(e.begin(), e.end(), comp);\n\tint ans = 0;\n\tfor (int i = 0; i<E; i++) {\n\t\tif (!same(e[i].from, e[i].to)) {\n\t\t\tunite(e[i].from, e[i].to);\n\t\t\tans += e[i].cost;\n\t\t}\n\t}\n\treturn ans;\n}\nint main() {\n\twhile (std::cin >> V&&V) {\n\t\tstd::cin >> E;\n\t\tint a, b, c;\n\t\tchar aa, bb;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tstd::cin >> a >> aa >> b >> bb >> c;\n\t\t\te.push_back(edge{ a,b,c });\n\t\t}\n\t\tstd::cout << kruskal() / 100 - V + 1 << std::endl;\n\t\te = {};\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n#include <algorithm>\n\n// Union Find\ntemplate<class T=int>\nclass UnionFind\n{\n    std::vector<T> p;\n    std::vector<T> r;\n    T find(const T x)\n    {\n        if(x==p[x]) return x;\n        return p[x]=find(p[x]);\n    }\n    void unite_(T x, T y)\n    {\n        if(x==y) return;\n        if(r[x]>r[y]) std::swap(x,y);\n        else if(r[x]==r[y]) ++r[y];\n        p[x]=y;\n    }\npublic:\n    explicit UnionFind(const T n):p(n),r(n,0)\n    {\n        for(T i=0; i<n; ++i)\n            p[i]=i;\n    }\n    bool same(const T x, const T y)\n    {\n        // assert(0<=x && x<p.size())\n        // assert(0<=y && y<p.size())\n        return find(x)==find(y);\n    }\n    void unite(const T x, const T y)\n    {\n        // assert(0<=x && x<p.size())\n        // assert(0<=y && y<p.size())\n        unite_(find(x),find(y));\n    }\n};\n\n// Kruskal's algorithm\ntemplate<class T, class U>\nT& kruskal(T& edges, U max_v)\n{\n    typedef typename T::value_type Edge;\n    std::sort(edges.begin(),edges.end());\n    UnionFind<U> uf(max_v);\n    edges.erase(\n        std::remove_if(edges.begin(),edges.end(),\n            [&uf](const Edge& e){\n                const auto& a = std::get<1>(e);\n                const auto& b = std::get<2>(e);\n                if(uf.same(a,b)) return true;\n                uf.unite(a,b);\n                return false;\n            }),\n        edges.end());\n    return edges;\n}\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios_base::sync_with_stdio(false);\n    for(int n,m; (std::cin >> n >> m) && n; )\n    {\n        typedef std::tuple<int,int,int> T;\n        std::vector<T> edges(m);\n        for(auto& v: edges)\n        {\n            int a,b,d; char c; std::cin >> a >> c >> b >> c >> d;\n            v = T(d,a,b);\n        }\n        int c=0;\n        for(auto& e: kruskal(edges, n))\n            c+=std::get<0>(e)/100-1;\n        std::cout << c << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "// clang-format off\n#include <bits/stdc++.h>\n#define int long long\n#define main signed main()\n#define loop(i, a, n) for (int i = (a); i < (n); i++)\n#define rep(i, n) loop(i, 0, n)\n#define forever for (;;)\n#define all(v) (v).begin(), (v).end()\n#define rall(v) (v).rbegin(), (v).rend()\n#define prec(n) fixed << setprecision(n)\ntemplate<typename A> using V = std::vector<A>;\ntemplate<typename A> using F = std::function<A>;\ntemplate<typename A, typename B> using P = std::pair<A, B>;\nusing pii = P<int, int>;\nusing vi = V<int>;\nusing vd = V<double>;\nusing vs = V<std::string>;\nusing vpii = V<pii>;\nusing vvi = V<vi>;\nusing vvpii = V<vpii>;\nconstexpr int INF = sizeof(int) == sizeof(long long) ? 1000000000000000000LL : 1000000000;\nconstexpr int MOD = 1000000007;\nconstexpr double PI = acos(-1);\ntemplate<typename A, typename B> bool cmin(A &a, const B &b) { return a > b ? (a = b, true) : false; }\ntemplate<typename A, typename B> bool cmax(A &a, const B &b) { return a < b ? (a = b, true) : false; }\ntemplate<typename T> std::istream &operator>>(std::istream &is, std::vector<T> &v) { for (T &x : v) is >> x; return is; }\ntemplate<typename A, typename B> std::istream &operator>>(std::istream &is, std::pair<A, B> &p) { is >> p.first; is >> p.second; return is; }\nusing namespace std;\n// clang-format on\n\nusing Weight = int;\nstruct Edge {\n  int src, dst;\n  Weight weight;\n  Edge(const int &s = 0, const int &d = 0, const Weight &w = 0) : src(s), dst(d), weight(w) {}\n};\n\nusing Edges = std::vector<Edge>;\nusing Array = std::vector<Weight>;\nusing Matrix = std::vector<Array>;\n\nclass Graph {\n  std::vector<Edges> g;\n  using iterator = std::vector<Edges>::iterator;\n  using const_iterator = std::vector<Edges>::const_iterator;\n\npublic:\n  Graph(const int &size = 0) : g(size) {}\n  int size() const { return g.size(); }\n  const Edges &operator[](const int &i) const { return g[i]; }\n  void addArc(const int &src, const int &dst, const Weight &w = 1) { g[src].emplace_back(src, dst, w); }\n  void addEdge(const int &node1, const int &node2, const Weight &w = 1) {\n    addArc(node1, node2, w);\n    addArc(node2, node1, w);\n  }\n  iterator begin() { return g.begin(); }\n  const_iterator begin() const { return g.begin(); }\n  iterator end() { return g.end(); }\n  const_iterator end() const { return g.end(); }\n};\n\nstd::pair<Weight, Edges> prim(const Graph &g, const int &root = 0) {\n  struct comp {\n    bool operator()(const Edge &e, const Edge &f) const { return e.weight > f.weight; }\n  };\n  Edges tree;\n  Weight total = 0;\n  std::vector<int> vs(g.size());\n  std::priority_queue<Edge, std::vector<Edge>, comp> q;\n  q.emplace(-1, root, 0);\n  while (q.size()) {\n    Edge e = q.top();\n    q.pop();\n    if (vs[e.dst]) continue;\n    vs[e.dst] = true;\n    total += e.weight;\n    if (e.src != -1) tree.emplace_back(e);\n    for (auto &f : g[e.dst]) {\n      if (!vs[f.dst]) q.emplace(f);\n    }\n  }\n  return {total, tree};\n}\n\nmain {\n  int n, m;\n  while (cin >> n >> m, n) {\n    Graph g(n);\n    while (m--) {\n      int a, b, d;\n      char gomi;\n      cin >> a >> gomi >> b >> gomi >> d;\n      g.addEdge(a, b, d);\n    }\n    auto k = prim(g);\n    cout << k.first / 100 - k.second.size() << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n\nusing namespace std;\nstatic const int INF = 99999999;\nint d[101][101];\n\nvoid solve()\n{\n\tint n;\n\twhile(cin >> n, n)\n\t{\n\t\tfor(int i = 0; i < 101; ++i)\n\t\t{\n\t\t\tfor(int j = 0; j < 101; ++j)\n\t\t\t{\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t\td[i][i] = 0;\n\t\t}\n\t\tint m;\n\t\tcin >> m;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint a, b, dist;\n\t\t\tchar c;\n\t\t\tcin >> a >> c >> b >> c >> dist;\n\t\t\td[a][b] = dist;\n\t\t\td[b][a] = dist;\n\t\t}\n\t\tfor(int k = 0; k < n; ++k)\n\t\t{\n\t\t\tfor(int i = 0; i < n; ++i)\n\t\t\t{\n\t\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t\t{\n\t\t\t\t\td[i][j] = min(d[i][j], d[i][k] + d[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint min_sum_dist = INF;\n\t\tfor(int i = 0; i < n; ++i)\n\t\t{\n\t\t\tint sum = 0;\n\t\t\tfor(int j = 0; j < n; ++j)\n\t\t\t{\n\t\t\t\tif(d[i][j] != INF)\n\t\t\t\t{\n\t\t\t\t\tsum += d[i][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min_sum_dist > sum)\n\t\t\t{\n\t\t\t\tmin_sum_dist = sum;\n\t\t\t}\n\t\t}\n\t\tcout << min_sum_dist / 100 - 3 << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define MAX_V 100\n#define INF (1<<21)\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\nint prim(){\n  for(int i = 0; i < V; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(1){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u = 0; u < V; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  while(1){\n    for(int i = 0; i < MAX_V; i++){\n      for(int j = 0; j < MAX_V; j++){\n\tcost[i][j] = INF;\n      }\n    }\n    cin >> V;\n    if(V == 0) break;\n    cin >> m;\n    for(int i = 0; i < V; i++){\n      int a, b, c;\n      char d, e;\n      cin >> a >> d >> b >> e >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    int t = prim();\n    t = t / 100 - m + 1;\n    cout << t << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n\nusing namespace std;\n\nconst int MAX = 101;\nconst int INF = (1<<20);\n\nint cost[MAX][MAX];\nint mincost[MAX];\nbool used[MAX];\nint V;\n\nint prim(){\n  mincost[0] = 0;\n  int res = 0;\n\n  while(1){\n\n    int v = -1;\n    for(int i = 0; i < V; i++)\n      if(!used[i] && (v == -1 || mincost[i] < mincost[v])) v = i;\n\n    if(v == -1) break;\n\n    used[v] = true;\n    res+=mincost[v]/100-1;\n    for(int i = 0; i < V; i++)\n      mincost[i] = min(mincost[i],cost[v][i]);\n\n  }\n  return res+1;\n}\n\nvoid init(){\n  fill(mincost,mincost+MAX,INF);\n  fill(used,used+MAX,false);\n  for(int i = 0; i < MAX; i++)\n    for(int j = 0; j < MAX; j++)\n      cost[i][j] = INF;\n}\nint main(){\n  while(cin >> V && V){\n    init();\n    int m;\n    cin >> m;\n    while(m--){\n      char c;\n      int f,t,cos;\n      cin >> f >> c >> t >> c >> cos;\n      cost[f][t] = cost[t][f] = cos;\n    }\n    cout << prim() << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\nusing namespace std;\n\ntypedef pair<int, int> Pair;\n\nstruct Edge {\n  int len;\n  int to;\n};\n\nint n;\nint m;\nbool used[10000];\nvector<Edge> es[10000];\npriority_queue<Pair, vector<Pair>, greater<Pair> > q;\n\nint CalcMSTCost() {\n  int ret = 0;\n\n  fill(used, used+n, false);\n  q.push(Pair(0, 0));\n  while (!q.empty()) {\n    Pair p = q.top(); q.pop();\n    int d = p.first;\n    int v = p.second;\n\n    if (used[v]) continue;\n    used[v] = true;\n    ret += d;\n    for (int i=0; i<es[v].size(); i++) {\n      q.push(Pair(es[v][i].len, es[v][i].to));\n    }\n  }\n\n  return ret;\n}\n\nint main() {\n  while (1) {\n    scanf(\"%d\", &n);\n    if (n == 0) return 0;\n\n    for (int i=0; i<n; i++) {\n      es[i].clear();\n    }\n  \n    scanf(\"%d\", &m);\n    for (int i=0; i<m; i++) {\n      int a, b;\n      struct Edge e;\n      scanf(\"%d,%d,%d\", &a, &b, &e.len);\n      e.len -= 100;\n      e.to = b;\n      es[a].push_back(e);\n      e.to = a;\n      es[b].push_back(e);\n    }\n\n    printf(\"%d\\n\", CalcMSTCost()/100);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstring>\n#include <algorithm>\n#include <string>\n#include <cmath>\n#include <stack>\n#include <vector>\n#include <map>\n#include <set>\n#include <queue>\n#include <list>\n#include <iostream>\n#include <climits>\n#include <cfloat>\n\nusing namespace std;\n\n//int main()\n//{\n//\tint n, m;\n//\tint pos[100][100];\n//\n//\twhile (true)\n//\t{\n//\t\tscanf(\"%d\", &n);\n//\t\tif (n == 0)\n//\t\t\tbreak;\n//\t\tscanf(\"%d\", &m);\n//\t\tmemset(pos, -1, sizeof(pos));\n//\t\tint a, b, c;\n//\t\tfor (int i = 0; i < m; ++i)\n//\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n//\t\tpos[a-1][b-1] = c;\n//\t}\n//\n//\treturn 0;\n//}\n\ntypedef pair<int, int> edge;\n\nint main()\n{\n\twhile (true)\n\t{\n\t\tint n, m;\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tvector<edge> edges[100];\n\t\tbool inTree[100];\n\t\tfill(inTree, inTree+100, false);\n\n\t\tscanf(\"%d\", &m);\n\t\tfor (int i = 0; i < m; ++i)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tedges[a].push_back(edge(c, b));\n\t\t\tedges[b].push_back(edge(c, a));\n\t\t}\n\n\t\tint res = 0;\n\n\t\tpriority_queue<int, vector<edge>, greater<edge>> q;\n\t\tinTree[0] = true;\n\t\tfor (int i = 0; i < edges[0].size(); ++i)\n\t\t\tq.push(edges[0][i]);\n\n\t\twhile (!q.empty())\n\t\t{\n\t\t\tedge e = q.top();\n\t\t\tq.pop();\n\t\t\tif (inTree[e.second])\n\t\t\t\tcontinue;\n\n\t\t\tinTree[e.second] = true;\n\t\t\tres += e.first / 100 - 1;\n\t\t\tfor (int i = 0; i < edges[e.second].size(); ++i)\n\t\t\t\tq.push(edges[e.second][i]);\n\t\t}\n\n\t\tprintf(\"%d\\n\", res);\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\ntypedef struct{\n\tint cost,v,u,par;\n}wa;\nwa way[10000];\nint compare(const wa& a,const wa& b){\n\treturn a.cost<b.cost;\n}\nint find(int t){\n\tif(way[t].par==t)\n\treturn t;\n\telse return find(way[t].par);\n}\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\nvoid unite(int x,int y){\n\tway[x].par=find(way[y].par);\n}\nint main(){\n\tint n,m,ans,x,y,c,num;\n\twhile(cin>>n,n){\n\t\tcin>>m;\n\t\tans=0;\n\t\tnum=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&x,&y,&c);\n\t\t\tway[i].v=x;\n\t\t\tway[i].u=y;\n\t\t\tway[i].cost=c/100-1;\n\t\t}\n\t\tsort(way,way+m,compare);\n\t\tfor(int i=0;i<m;i++)\n\t\t\tway[i].par=i;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tif(!same(way[i].v,way[i].u)){\n\t\t\tunite(way[i].v,way[i].u);\n\t\t\t\tnum++;\n\t\t\tans+=way[i].cost;\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define INF 1e9\n#define LINF 1e18\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> Pi;\ntypedef pair<P, P> PP;\n\nconst int MOD = 1e9 + 7;\nconst int dy[] = { 0, 0, 1, -1 };\nconst int dx[] = { 1, -1, 0, 0 };\n\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\n\ntypedef pair<int, int> P;\nstruct edge{int to, cost;};\nint n, m;\nbool used[101];\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> n) {\n        if(n == 0) break;\n        cin >> m;\n        vector<edge> G[100];\n        rep(i, m) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            G[a].push_back(edge{b, c - 100});\n            G[b].push_back(edge{a, c - 100});\n        }\n        priority_queue<P, vector<P>, greater<P> > que;\n        memset(used, 0, sizeof(used));\n        que.push(P(0, 0));\n        int res = 0;\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            int cst = p.first, v = p.second;\n            if(used[v]) continue;\n            used[v] = true;\n            res += cst;\n            rep(i, G[v].size()) {\n                que.push(P(G[v][i].cost, G[v][i].to));\n            }\n        }\n        cout << res / 100 << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass data {\n\tpublic:\n\t\tint a, b;\n\t\tint c;\n\n\t\tdata(int p1, int p2, int cost) {\n\t\t\ta = p1;\n\t\t\tb = p2;\n\t\t\tc = cost;\n\t\t}\n\n\t\tbool operator<(const data & c_) const {\n\t\t\treturn c < c_.c;\n\t\t}\n};\n\nint n, m;\nvector<data> cost;\nvector<data> modefied_cost;\nvector<vector<int> > used_point;\n\nvoid init() {\n\tcost.clear();\n\tmodefied_cost.clear();\n\tused_point.clear();\n}\n\nbool input() {\n\tcin >> n;\n\tif(!n)\n\t\treturn false;\n\n\tcin >> m;\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\tcost.push_back(data(a, b, c));\n\t}\n\n\treturn true;\n}\n\nvoid modefy_cost() {\n\tfor(int i = 0; i < cost.size(); i++) {\n\t\tmodefied_cost.push_back(data(cost[i].a, cost[i].b, cost[i].c / 100 - 1));\n\t}\n}\n\npair<pair<int,int>,pair<int,int> > find_point(const data & d) {\n\tpair<pair<int, int>, pair<int, int> > ij_pair(pair<int,int>(-1, -1), pair<int,int>(-2, -2));\n\tfor(int i = 0; i < used_point.size(); i++) {\n\t\tfor(int j = 0; j < used_point[i].size(); j++) {\n\t\t\tif(used_point[i][j] == d.a) {\n\t\t\t\tij_pair.first.first = i;\n\t\t\t\tij_pair.first.second = j;\n\t\t\t}\n\t\t\telse if(used_point[i][j] == d.b) {\n\t\t\t\tij_pair.second.first = i;\n\t\t\t\tij_pair.second.second = j;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ij_pair;\n}\n\nint solve() {\n\tmodefy_cost();\n\tsort(modefied_cost.begin(), modefied_cost.end());\n\tint ans = 0;\n\n\tfor(int i = 0; i < modefied_cost.size(); i++) {\n\t\tpair<pair<int,int>,pair<int,int> > tmp;\n\t\ttmp = find_point(modefied_cost[i]);\n\n\t\tif(tmp.first.first == tmp.second.first) {\n\t\t\tcontinue;\n\t\t}\n\n\t\telse if(tmp.first.first > -1 && tmp.second.first < 0) {\n\t\t\tused_point[tmp.first.first].push_back(modefied_cost[i].b);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse if(tmp.first.first < 0 && tmp.second.first > -1) {\n\t\t\tused_point[tmp.second.first].push_back(modefied_cost[i].a);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse if(tmp.first.first > -1 && tmp.second.first > -1) {\n\t\t\tused_point[tmp.first.first].insert(used_point[tmp.first.first].end(),\n\t\t\t\t\tused_point[tmp.second.first].begin(), used_point[tmp.second.first].end());\n\t\t\tused_point.erase(used_point.begin() + tmp.second.first, used_point.begin() + tmp.second.first + 1);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse {\n\t\t\tused_point.push_back(vector<int>(2));\n\t\t\tused_point[used_point.size() - 1][0] = modefied_cost[i].a;\n\t\t\tused_point[used_point.size() - 1][1] = modefied_cost[i].b;\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile(init(), input()) {\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef long long ll;\n//struct edge {int to, cost;};\ntypedef pair<int, int> P;\ntypedef complex<double> C;\n\nconst int INF = 99999999;\nconst int MAX_V = 110;\nconst int MAX_E = 10000;\n\ntypedef pair<int, int> edge;    //cost, to\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nint V, E;\nint flag;\n\nint prim() {\n    REP(i, V) used[i] = false;\n    used[0] = true;\n\n    priority_queue<edge, vector<edge>, greater<edge>> que;\n    REP(j, G[0].size()) que.push(G[0][j]);\n\n    int res = 0;\n\n    while (!que.empty()) {\n        int cost = que.top().first, to = que.top().second;\n        que.pop();\n        if (!used[to]) {\n            res += cost;\n            used[to] = true;\n            REP(j, G[to].size()) que.push(G[to][j]);\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    printf(\"%d\\n\", prim() - (V - 1) );\n}\n\nint main() {\n    while (scanf(\"%d\", &V),  V) {\n        scanf(\"%d\", &E);\n        REP(i, E) {\n            int f, t, c;\n            scanf(\"%d,%d,%d\\n\", &f, &t, &c);\n            c /= 100;\n            G[f].pb(edge(c, t));\n            G[t].pb(edge(c, f));\n        }\n        if (V == 1) {\n            printf(\"0\\n\");\n            continue;\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "//0072\n//vñFÅ¬SæØ\n//QlFhttp://www.deqnotes.net/acmicpc/prim/\n\n#include<stdio.h>\n#include<vector>\n#include<queue>\n#include<utility>\n#include<functional>\nusing namespace std;\n\n\nint main(void)\n{\n\tint n, m;\n\tconst int N = 100;\n\tconst int INVALID_VALUE = -1;\n\tint cost[N][N];\n\n\twhile(scanf(\"%d\", &n), n)\n\t{\n\t\tscanf(\"%d\", &m);\n\t\tint a, b, d;\n\t\tint i, j;\n\t\t//¢Á½ñ·×ÄÌ¹Ìèðú»·é\n\t\t//©ª©gÖÌ¹ÌèÍ0¾¯ÇA¡ñÍl¶·éKvÍ³¢H\n\t\tfor(i = 0; i < N; ++i)\n\t\t\tfor(j = 0; j < N; ++j)\n\t\t\t\tcost[i][j] = INVALID_VALUE;\n\t\tfor(i = 0; i < m; ++i)\n\t\t{\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d;\n\t\t}\n\n\t\ttypedef pair<int, int> P;\t//<distance, toIndex>@£Å\\[g·é½ßOÉ\n\t\t//¸ÉDæxÂ«ÌL[\n\t\t//½ÅftHgÍ~ÈÌæ\n\t\tpriority_queue<P, vector<P>, greater<P> > q;\t//>>¾ÆAOJÉG[Hç¢Üµ½BÆ¢¤©AÊÍG[Hç¤àÌ¶áH\n\t\t//»Ì¸_ÍÚ±³êÄ¢Ü·©H\n\t\tbool isConnected[N] = {false};\n\n\t\tint totalDistance = 0;\t//Å¬ØÌ£\n\n\t\t//Æè ¦¸ê0©çnßæ¤\n\t\tq.push(P(0, 0));\t//make_pairÅâÁ½çB¾Æ¢íê½B0Ì¹¢H\n\t\twhile(!q.empty())\n\t\t{\n\t\t\tP p = q.top();\n\t\t\tq.pop();\n\t\t\t//·ÅÉÂÈªÁÄ¢é¸_¾Á½ç½àµÈ¢\n\t\t\tif(isConnected[p.second])\n\t\t\t\tcontinue;\n\t\t\t//»ÌÓðÚ±µÜ·\n\t\t\tisConnected[p.second] = true;\n\t\t\ttotalDistance += p.first;\n\t\t\t//ÌÓðÚ±µÜ·\n\t\t\tfor(i = 0; i < N; ++i)\n\t\t\t{\n\t\t\t\tif(cost[p.second][i] != INVALID_VALUE)\t//»ÌæÖÌ¹Í¶ÝµÜ·©\n\t\t\t\t\tq.push( P(cost[p.second][i], i) );\t//±±Ímake_pair()ÅàG[ÉÈçÈ¢¯êÇ\n\t\t\t}\n\t\t}\n\n\t\t//UÌÂÍAijÕÌÓ|1jÂ­È­A»µÄ100m¨«ÉÉu©êÄ¢é\n\t\tprintf(\"%d\\n\", (totalDistance/100)-(n-1));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdlib>\n\nusing namespace std;\n\nconstexpr int MAX_N = 100;\nconstexpr int MAX_M = MAX_N * MAX_N;\nint par[MAX_N];\nint myrank[MAX_N];\nint n,m;\n\n\nstruct edge {\n    int a, b, d;\n\n    /*\n    bool operator <(const edge& r) {\n      return this->d < r.d;\n    }\n     */\n\n\n};\nedge e[MAX_M];\n\n\n// Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n) {\n  for (int i = 0; i < n; i++) {\n    par[i] = i;\n    myrank[i] = 0;\n  }\n}\n\n// x?????????????´?????±??????????????????£??¨????????????\nint find(int x) {\n  if (par[x] == x) {\n    return x;\n  } else {\n    return par[x] = find(par[x]);\n  }\n}\n\n// x,y????±?????????????????????¨??????\nvoid unite(int x, int y) {\n  x = find(x);\n  y = find(y);\n  if (x == y) {\n    return;\n  }\n  if (myrank[x] < myrank[y]) {\n    par[x] = y;\n  } else {\n    par[y] = x;\n    if (myrank[x] == myrank[y]) myrank[x]++;\n  }\n}\n\n// x,y????±?????????????????????????????????????\nint same(int x, int y) {\n  return find(x) == find(y);\n}\n\nvoid Tree_print() {\n  int i;\n  for (i = 0; i < n; i++) cout << par[i];\n  cout << endl;\n\n}\n\nint compare_edge(const void *a,const void * b){\n  edge temp1 = *(edge *)a;\n  edge temp2 = *(edge *)b;\n\n  return temp1.d-temp2.d;\n}\nint main() {\n  int count ,t ;\n\n  while (1){\n    cin >> n ;\n    if(n == 0) break;\n    cin >> m;\n    init(n);\n\n    t =0;\n    count =0;\n    for(int i = 0; i < m; i ++){\n      scanf(\"%d,%d,%d\", &(e[i].a), &(e[i].b), &(e[i].d));\n    }\n\n    qsort(e,n, sizeof(*e),compare_edge);\n    while(count != m-1) {\n      for (int i = 0; i < n; ++i) {\n        if(same(e[i].a,e[i].b) != 1) {\n          count++;\n          t = t + (int) e[i].d /100 - 1;\n          unite(e[i].a,e[i].b);\n        }\n      }\n      cout << t<<endl;\n    }\n  }\n\n\n\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n\n#define MAX_V 101\n#define INF 10000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\n\nint V,mincost[MAX_V];\nvector<edge>G[MAX_V];\n\nint Prim(void){\n  priority_queue<P, vector<P>, greater<P> >que;\n  fill(mincost, mincost+V, INF);\n  vector<bool> visited(V);\n  fill(visited.begin(),visited.end(),false);\n\n  mincost[0]=0;\n  que.push(P(0,0));\n  \n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    \n    int v = p.second;\n    if(visited[v])continue;\n    visited[v]=true;\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(mincost[e.to] > e.cost && !visited[e.to]){\n\tmincost[e.to] = e.cost;\n\tque.push(P(mincost[e.to], e.to));\n      }\n    }\n  }\n  int res=0;\n  for(int i=0;i<V;i++)res+=mincost[i];\n \n  return res;\n}\n\n\n\nint main(void){\n  int m,a,b,c;\n  char ch1,ch2;\n  edge e;\n\n  while(cin >> V,V){\n    for(int i=0;i<V;i++)G[i].clear();\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> a >> ch1 >> b >> ch2 >> c;\n      c=c/100-1;\n      e.to=b,e.cost=c;\n      G[a].push_back(e);\n      e.to=a;\n      G[b].push_back(e);\n    }\n      cout << Prim() << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\n#include<queue>\n#include<climits>\n\n#define MAX_V 101\n#define INF 10000000\n\nusing namespace std;\n\n\nstruct edge{int to, cost; };\ntypedef pair<int, int> P;\n\nint V,mincost[MAX_V];\nvector<edge>G[MAX_V];\n\nint Prim(int s){\n  priority_queue<P, vector<P>, greater<P> >que;\n  fill(mincost, mincost+V, INF);\n\n  vector<bool> visited(V);\n  fill(visited.begin(),visited.end(),false);\n\n  mincost[s]=0;\n  que.push(P(0,s));\n  int res=0;\n  while(!que.empty()){\n    P p = que.top();\n    que.pop();\n    \n    int v = p.second;\n    if(visited[v])continue;\n    visited[v]=true;\n    res+=mincost[v];\n\n    for(int i=0; i < G[v].size(); i++){\n      edge e = G[v][i];\n      if(mincost[e.to] > e.cost && !visited[e.to]){\n\tmincost[e.to] = e.cost;\n\tque.push(P(mincost[e.to], e.to));\n      }\n    }\n  }\n \n  return res;\n}\n\n\nint main(void){\n  int m,a,b,c;\n  char ch1,ch2;\n  edge e;\n\n  while(cin >> V,V){\n    for(int i=0;i<V;i++)G[i].clear();\n    cin >> m;\n    for(int i=0;i<m;i++){\n      cin >> a >> ch1 >> b >> ch2 >> c;\n      c=c/100-1;\n      e.to=b,e.cost=c;\n      G[a].push_back(e);\n      e.to=a;\n      G[b].push_back(e);\n    }\n      cout << Prim(0) << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Carden Lantern [AOJ 0072]\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\ntypedef vector <PIP>    Edges;\n\nconst int size = 101;\nint P[size];\n\nvoid init( int n ) {\n    for ( int i = 0; i < n; i++ ) {\n        P[i] = -1;\n    }\n}\n\nint find( int a ) {\n    if ( P[a] == -1 ) {\n        return a;\n    }\n    return P[a] = find( P[a] );\n}\n\nvoid merge( int a, int b ) {\n    int fa = find( a ), fb = find( b );\n\n    if ( P[a] == -1 && P[b] == -1 ) {\n        P[a] = b;\n    } else if ( fa != fb ) {\n        if ( P[a] == -1 ) {\n            P[a] = fb;\n        } else {\n            P[b] = fa;\n        }\n    }\n}\n\nbool same_set( int a, int b ) {\n    return find( a ) == find( b );\n}\n\nint main( void ) {\n    string line;\n    while ( getline( cin, line ) ) {\n        // init\n        int n, m;\n        Edges E;\n\n        // input\n        if ( line == \"0\" ) {\n            break;\n        }\n        {\n            istringstream is( line );\n            is >> n;\n        }\n        {\n            getline( cin, line );\n            istringstream is( line );\n            is >> m;\n        }\n        for ( int i = 0; i < m; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            int a, b, c;\n            istringstream is( line );\n            is >> a >> b >> c;\n            PIP edge( c, PII( a, b ) );\n            E.push_back( edge );\n        }\n\n        // proc\n        int answer = 0;\n        init( n );\n\n        sort( E.begin(), E.end() );\n        for ( int i = 0; i < m; i++ ) {\n            int a = E[i].second.first;\n            int b = E[i].second.second;\n            int c = E[i].first;\n\n            if ( !same_set( a, b ) ) {\n                answer += ( c - 1 ) / 100;\n                merge( a, b );\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_V 100\n#define INF 1e9\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];//集合Xからの辺の最小コスト\nbool used[MAX_V];//頂点iがXに含まれてるか\nint V;\n\nint prim(){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res=0;\n  while(true){\n    int v = -1;\n    \n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true; //頂点vをXに追加\n    res += mincost[v]; //円のコストを加える\n    for(int u=0;u<V;u++) mincost[u] = min(mincost[u],cost[v][u]);\n  }\n  return res;\n}\n\n\nint main(){\n  int E;\n  while(true){\n    cin >> V;\n    if(V==0) break;\n    cin >> E;\n    for(int i=0;i<E;i++){\n      for(int j=0;j<E;j++){\n        cost[i][j] = cost[j][i] = (i==j ? 0 : INF);\n      }\n    }\n\n    int a,b,dist;\n    char camma;\n    for(int i=0;i<E;i++){\n      cin >> a >> camma >> b >> camma >> dist;\n      a; b;\n      cost[a][b] = cost[b][a] = dist;\n    }\n    \n    int sum_of_costs = prim();\n    int lanterns = sum_of_costs/100 - (V - 1); \n    //n00mを100mで分割すると分割点はn-1個\n    cout << lanterns << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\nclass Segment { \npublic:\n\tint u, v, distance; \n};\n\n\nint point[101];\nint height[101];\nSegment arr[10001];\n\nint find(int root) {\n\twhile (root != point[root]) {\n\t\troot = point[root];\n\t}\n\treturn root;\n}\n\nbool unit(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) {\n\t\treturn false;\n\t}\n\n\tif (height[x]<height[y]) {\n\t\tpoint[x] = y;\n\t}\n\telse {\n\t\tpoint[y] = x;\n\t\tif (height[x] == height[y]) {\n\t\t\theight[x]++;\n\t\t}\n\t}\n\treturn true;\n}\n\n\nbool comp(const Segment& e1, const Segment& e2) {\n\treturn e1.distance < e2.distance;\n}\n\nint kruskal(int n, int m) {\n\tsort(arr, arr + m, comp);\n\tfor (int i = 0; i < n; i++) {\n\t\tpoint[i] = i;\n\t\theight[i] = 1;\n\t}\n\n\tint sum = 0, cnt = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tif (cnt == n - 1) {\n\t\t\tbreak;\n\t\t}\n\t\tif (unit(arr[i].u, arr[i].v)) {\n\t\t\tsum += arr[i].distance;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn sum / 100 - cnt;\n}\n\nint main(void) {\n\tint n, m;\n\twhile (cin >> n, n) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tscanf(\"%d,%d,%d\", &arr[i].u, &arr[i].v, &arr[i].distance);\n\t\tcout << kruskal(n,m) << endl;\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define MAX_V 100\n#define INF (1<<21)\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\nint prim(){\n  for(int i = 0; i < V; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(1){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u = 0; u < V; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  while(1){\n    cin >> V;\n    if(V == 0) break;\n    for(int i = 0; i < V; i++){\n      for(int j = 0; j < V; j++){\n\tcost[i][j] = INF;\n      }\n    }\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int a, b, c;\n      char d, e;\n      cin >> a >> d >> b >> e >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    int t = prim();\n    t = t / 100 - V + 1;\n    cout << t << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Road {\n    int a, b;\n    int dist;\n\n    bool operator < (const Road &other) const {\n        return dist < other.dist;\n    }\n};\n\nint getroot(int i, vector<int> &roots) {\n    if(roots[i] == i) return i;\n    return roots[i] = getroot(roots[i], roots);\n}\n\nvoid unite(int i, int j, vector<int> &roots) {\n    roots[i] = getroot(roots[j], roots);\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N;\n        if(!N) break;\n        cin >> M;\n\n        vector<Road> roads(M);\n        char comma;\n        for(int i = 0; i < M; ++i) \n            cin >> roads[i].a >> comma >> roads[i].b >> comma >> roads[i].dist;\n        sort(roads.begin(), roads.end());\n\n        int ans = 0;\n        vector<int> roots(N);\n        for(int i = 0; i < N; ++i) roots[i] = i;\n        for(int i = 0; i < M; ++i) {\n            const Road &r = roads[i];\n            if(getroot(r.a, roots) == getroot(r.b, roots)) continue;\n            unite(r.a, r.b, roots);\n            ans += r.dist/100 - 1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#define MAX_V 200\n#define INF 1e6\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];//集合Xからの辺の最小コスト\nbool used[MAX_V];//頂点iがXに含まれてるか\nint V;\n\nint prim(){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res=0;\n  while(true){\n    int v = -1;\n    \n    for(int u=0;u<V;u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true; //頂点vをXに追加\n    res += mincost[v]; //円のコストを加える\n    for(int u=0;u<V;u++) mincost[u] = min(mincost[u],cost[v][u]);\n  }\n  return res;\n}\n\n\nint main(){\n  int E;\n  while(true){\n    cin >> V;\n    if(V==0) break;\n    cin >> E;\n    for(int i=0;i<E;i++){\n      for(int j=0;j<E;j++){\n        cost[i][j] = cost[j][i] = (i==j ? 0 : INF);\n      }\n    }\n\n    int a,b,dist;\n    char camma;\n    for(int i=0;i<E;i++){\n      cin >> a >> camma >> b >> camma >> dist;\n      a; b;\n      cost[a][b] = cost[b][a] = dist;\n    }\n    \n    int sum_of_costs = prim();\n    int lanterns = sum_of_costs/100 - (V - 1); \n    //n00mを100mで分割すると分割点はn-1個\n    cout << lanterns << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#include<stdio.h>\nusing namespace std;\n#define FOR(i,k,n) for(int i = (k); i < (n); i++)\n#define REP(i,n) FOR(i,0,n)\n#define ALL(a) begin(a),end(a)\n#define MS(m,v) memset(m,v,sizeof(m))\n#define D10  fixed<<setprecision(10)\ntypedef vector<int> vi;\ntypedef vector<string> vs;\ntypedef pair<int, int> P;\ntypedef long long ll;\nconst ll INF = 114514810;\nconst ll MOD = 1000000007;\nconst double EPS = 1e-8;\nconst double PI = acos(-1.0);\nstruct edge\n{\n\tint from, to, cost;\n\tbool operator < (const edge& e) const { return cost < e.cost; }\n\tbool operator >(const edge& e) const { return cost > e.cost; }\n};\nint dx[] = { -1, 0, 0, 1 }; int dy[] = { 0, -1, 1, 0 };\nbool valid(int x, int y, int h, int w) { return (x >= 0 && y >= 0 && x < h&&y < w); }\n///*************************************************************************************///\n///*************************************************************************************///\n///*************************************************************************************///\n\nint V, E;\nvector<vector<edge>> es;\nbool used[10000];\n\npair<int, vector<edge>> prim()\n{\n\tmemset(used, false, sizeof(used));\n\tvector<edge> res;\n\tint sum = 0;\n\n\tpriority_queue<edge, vector<edge>, greater<edge>> que;\n\tque.push(edge{ -1, 0, 0 });\n\n\twhile (!que.empty())\n\t{\n\t\tedge e = que.top(); que.pop();\n\t\tif (used[e.to]) continue;\n\t\tif (e.from >= 0) res.push_back(e);\n\t\tsum += e.cost;\n\t\tused[e.to] = true;\n\t\tfor (edge i : es[e.to])\n\t\t{\n\t\t\tif (!used[i.to]) que.push(i);\n\t\t}\n\t}\n\treturn pair<int, vector<edge>>(sum, res);\n}\n\nint main()\n{\n\twhile (cin >> V >> E)\n\t{\n\t\tes.resize(V);\n\t\tREP(i, E)\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\tes[a].push_back(edge{ a, b, c });\n\t\t\tes[b].push_back(edge{ b, a, c });\n\t\t}\n\n\t\tcout << prim().first / 100 - (V - 1) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\nstruct EDGE\n{\n    int to, cost;\n    EDGE(int a, int b){\n        to = a;\n        cost = b;\n    }\n    bool operator < (const EDGE& t) const {\n        return cost > t.cost;\n    }\n};\nvector<EDGE> v[100]; \nbool f[100];\nint search()\n{\n    int res = 0;\n    priority_queue<EDGE> que;\n    que.push(EDGE(0, 0));\n    while (!que.empty()){\n        EDGE e = que.top(); que.pop();\n        if (f[e.to]) continue;\n        f[e.to] = true;\n        res += e.cost;\n        rep(i, v[e.to].size()){\n            if (!f[v[e.to][i].to]){\n                que.push(v[e.to][i]);\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d\", &n), n){\n        scanf(\"%d\", &m);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            c = c / 100 - 1;\n            v[a].pb(EDGE(b, c));\n            v[b].pb(EDGE(a, c));\n        }\n        printf(\"%d\\n\", search());\n        memset(f, false, sizeof(f));\n        rep(i, n) v[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\n#define rep(i,n)for(int i=0;i<n;i++)\nusing namespace std;\ntypedef pair<int, int>P;\n\nint main() {\n\tint n, m;\n\twhile (scanf(\"%d\", &n), n) {\n\t\tscanf(\"%d\", &m);\n\t\tvector<P>E[100];\n\t\tbool used[100]{};\n\t\trep(i, m) {\n\t\t\tint a, b, d; scanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tE[a].push_back(P(d, b)); E[b].push_back(P(d, a));\n\t\t}\n\t\tpriority_queue<P, vector<P>, greater<P>>que;\n\t\tint ans = 0;\n\t\tque.push(P(0, 0));\n\t\twhile (!que.empty()) {\n\t\t\tP p = que.top(); que.pop();\n\t\t\tif (used[p.second])continue;\n\t\t\tused[p.second] = true;\n\t\t\tans += max(0, p.first / 100 - 1);\n\t\t\tfor (P v : E[p.second])que.push(P(v.first, v.second));\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge { int from, to, dis; };\n\nbool comp(const Edge& e1, const Edge& e2) {\n\treturn e1.dis < e2.dis;\n}\n\nvector<Edge> es;\nint V, E;\n\nint *par;\nint *rank_;\n\nvoid init(int n) {\n\tpar = new int[n];\n\trank_ = new int[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank_[i] = 0;\n\t}\n}\n\nvoid fin() {\n\tdelete[] par;\n\tdelete[] rank_;\n}\n\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t} else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\n\tif (rank_[x] < rank_[y]) {\n\t\tpar[x] = y;\n\t} else {\n\t\tpar[y] = x;\n\t\tif (rank_[x] == rank_[y]) rank_[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nll kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tll res = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tEdge e = es[i];\n\t\tif (!same(e.from, e.to)) {\n\t\t\tunite(e.from, e.to);\n\t\t\tres += e.dis;\n\t\t}\n\t}\n\tfin();\n\treturn res;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> V;\n\t\tif (V == 0)\n\t\t\tbreak;\n\t\tcin >> E;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tEdge e;\n\t\t\tscanf(\"%d,%d,%d\\n\", &e.from, &e.to, &e.dis);\n\t\t\tes.push_back(e);\n\t\t}\n\t\tcout << kruskal() / 100 - (V - 1) << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\n\nconst int MAX_N = 10000;\nint Par[MAX_N];\nint Rank[MAX_N];\n\nvoid init_union_find(int n){\n\tfor(int i=0; i<n; ++i){\n\t\tPar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(Par[x] == x){\n\t\treturn x;\n\t}else {\n\t\treturn Par[x] = find(Par[x]);\n\t}\n}\n\nvoid unite(int x, int y){\n\tx = find(x);\n\ty = find(y);\n\n\tif(x == y)\n\t\treturn ;\n\n\tif(Rank[x] < Rank[y]){\n\t\tPar[x] = y;\n\t} else{\n\t\tPar[y] = x;\n\t\tif(Rank[x] == Rank[y]){\n\t\t\t++Rank[x];\n\t\t}\n\t}\n}\n\nbool same(int x, int y){\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tint from,\n\t\tto,\n\t\tcost;\n};\n\nbool comp(const edge& e1, const edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int MAX_E = 10000;\nedge es[MAX_E];\nint V, E;\n\nint kruskal(void){\n\tsort(es, es + E, comp);\n\tinit_union_find(V);\n\n\tint res = 0;\n\tfor(int i=0; i<E; ++i){\n\t\tedge e = es[i];\n\t\tif(!same(e.from, e.to)){\n\t\t\tunite(e.from, e.to);\n\t\t\tres += e.cost / 100 - 1;\n\t\t}\n\t}\n\n\treturn res;\n}\n\nint main(void){\n\twhile(true){\n\t\tcin >> V;\n\t\tif(V == 0)\n\t\t\tbreak;\n\t\tcin >> E;\n\n\t\tchar d;\n\t\tfor(int i=0; i<E; i++){\n\t\t\tcin >> es[i].from >> d >> es[i].to >> d >> es[i].cost;\n\t\t}\n\n\t\tcout << kruskal() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<cstring>\nusing namespace std;\nint main()\n{\n  int n;\n  for(;cin>>n,n;)\n    {\n      int edge[n][n];\n      int m;\n      cin>>m;\n      memset(edge,-1,sizeof(edge));\n      for(int i=0;i<m;i++)\n\t{\n\t  int a,b,road;\n\t  char buf;\n\t  cin>>a>>buf>>b>>buf>>road;\n\t  edge[a][b]=road/100-1;\n\t  edge[b][a]=road/100-1;\n\t}\n      bool closed[n];\n      int cnt=n;\n      int ans=0;\n      memset(closed,true,sizeof(closed));\n      priority_queue<pair<int,int>,vector<pair<int,int> >,greater<pair<int,int> > > qu;\n      closed[0]=false;\n      for(int i=0;i<n;i++)\n\tif(edge[0][i]!=-1)\n\t  {\n\t    qu.push(make_pair(edge[0][i],i));\n\t  }\n      //      cout<<\"start\"<<endl;\n      for(;!qu.empty();)\n\t{\n\t  int node=qu.top().second;\n\t  int cost=qu.top().first;\n\t  qu.pop();\n\t  if(!closed[node])\n\t    continue;\n\t  //\t  cout<<node<<\" \"<<cost<<endl;\n\t  // cout<<cnt<<\" \"<<ans<<endl;\n\t  closed[node]=false;\n\t  ans+=cost;\n\t  cnt--;\n\t  if(cnt<=0)\n\t    break;\n\t  for(int i=0;i<n;i++)\n\t    if(edge[node][i]!=-1)\n\t      qu.push(make_pair(edge[node][i],i));\n\t}\n      cout<<ans<<endl;\n    }\n  \n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<queue>\n#include<stack>\n#include<vector>\nusing namespace std;\nclass union_find{\nprivate:\nvector<int> parents;\nvector<int> rank;\npublic:\nunion_find(int n){\nparents.resize(n);\nrank.resize(n);\nfor(int i=0;i<n;i++){\nparents[i]=i;\nrank[i]=0;\n}\n}\nint find(int x){\nif(parents[x]==x){\nreturn x;\n}else{\nreturn parents[x]=find(parents[x]);\n}\n}\nvoid unite(int x,int y){\nx=find(x);\ny=find(y);\nif(x==y)return;\nif(rank[x]<rank[y]){\nparents[x]=y;\n}else{\nparents[y]=x;\nif(rank[x]==rank[y])rank[x]++;\n}\n}\nbool same(int x,int y){\nreturn (find(x)==find(y));\n}\n};\nstruct E{\nint from,to,cost;\n};\nbool operator<(E a, E b){\nreturn a.cost>b.cost;\n}\nint n;\nvector<vector<E>> edge;\nbool input(){\ncin>>n;\nif(n==0)return false;\nint m;\ncin>>m;\nedge.clear();\nedge.resize(n);\nfor(int i=0;i<m;i++){\nint a,b,c;\nchar cc;\ncin>>a>>cc>>b>>cc>>c;\nedge[a].push_back(E{a,b,c});\nedge[b].push_back(E{b,a,c});\n}\nreturn true;\n}\nint solve(){\npriority_queue<E> que;\nunion_find uf(n);\nfor(int i=0;i<edge[0].size();i++){\nque.push(edge[0][i]);\n}\nint ans =0;\nwhile(!que.empty()){\nE now = que.top();que.pop();\nif(uf.same(now.from,now.to))continue;\nuf.unite(now.from,now.to);\nans += now.cost/100-1;\nfor(int i=0;i<edge[now.to].size();i++){\nque.push(edge[now.to][i]);\n}\n}\nreturn ans;\n}\nint main(){\nwhile(input()){\ncout<<solve()<<endl;\n}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nconst int MAX_V = 100;\nconst int INF = 100000;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint prim(int V) {\n  for (int i = 0; i < V; i++) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true) {\n    int v = -1;\n    for (int u = 0; u < V; u++) {\n      if (! used[u] and (v == -1 or mincost[u] < mincost[v]))\n        v = u;\n    }\n\n    if (v == -1)\n      break;\n\n    used[v] = true;\n\n    res += mincost[v];\n\n    for (int u = 0; u < V; u++)\n      mincost[u] = min(mincost[u], cost[v][u]);\n  }\n\n  return res;\n}\n\nint main() {\n  int n;\n  while (cin >> n and n != 0) {\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++)\n        cost[i][j] = INF;\n\n    int m, a, b, dist;\n    cin >> m;\n\n    for(int i = 0; i < m; i++) {\n      scanf(\"%d,%d,%d\", &a, &b, &dist);\n      dist = dist / 100 - 1;\n      cost[a][b] = cost[b][a] = dist;\n    }\n\n    int val = prim(n);\n\n    cout << val << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<climits>\n#include<cmath>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\n#include<cfloat>\n#include<functional>\n#include<map>\n#include<string>\n#include<cstring>\n#include<vector>\n#include<queue>\n#include<stack>\n#include<deque>\n#include<set>\n#include<bitset>\n#include<list>\n#include<numeric>\n#include<complex>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> i_i;\ntypedef pair<long long, int> ll_i;\ntypedef pair<double, int> d_i;\ntypedef pair<long long, long long> ll_ll;\ntypedef pair<double, double> d_d;\n\n#define PI 3.141592653589793238462643383279\n#define mod 1000000007LL\n#define rep(i, n) for(i = 0;i < n;++i)\n#define rep1(i, n) for(i = 1;i < n;++i)\n#define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j)\n#define per(i, n) for(i = n - 1;i > -1;--i)\n#define int(x) int x; scanf(\"%d\",&x)\n#define int2(x, y) int x, y; scanf(\"%d%d\",&x, &y)\n#define int3(x, y, z) int x, y, z; scanf(\"%d%d%d\",&x, &y, &z)\n#define sc(x) cin >> x\n#define sc2(x, y) cin >> x >> y\n#define sc3(x, y, z) cin >> x >> y >> z\n#define scn(n, a) rep(i, n)cin >> a[i]\n#define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i]\n#define pri(x) cout << x << \"\\n\"\n#define pri2(x, y) cout << x << \" \" << y << \"\\n\"\n#define pri3(x, y, z) cout << x << \" \" << y << \" \" << z << \"\\n\"\n#define pb push_back\n#define mp make_pair\n#define all(a) (a).begin(),(a).end()\n#define kabe puts(\"---------------------------\")\n#define kara puts(\"\")\n#define debug(x) cout << \" --- \" << x << \"\\n\"\n#define debug2(x, y) cout << \" --- \" << x << \" \" << y << \"\\n\"\n#define debug3(x, y, z) cout << \" --- \" << x << \" \" << y << \" \" << z << \"\\n\"\n#define debugn(i, n, a) rep(i, n)cout << \" --- \" << a[i] << \"\\n\";\n#define debugin(i, n, a) rep(i, n)printf(\" --- %10d\\n\", a[i])\n#define debugi2n(i, n, a, b) rep(i, n)printf(\" --- %10d %10d\\n\", a[i], b[i])\n#define debugiin(i, n, a) rep(i, n)printf(\" --- %10d %10d\\n\", a[i].first, a[i].second)\n#define X first\n#define Y second\n#define eps 0.0001\n#define prid(x) printf(\"%.15lf\\n\", x)\n\nstruct unionfind{\n\tvector<int> data;\n\tvoid use(int n){ data.assign(n, -1); }\n\tbool unionset(int x, int y){\n\t\tx = root(x); y = root(y);\n\t\tif(x != y){\n\t\t\tif(data[y] < data[x])swap(x, y);\n\t\t\tdata[x] += data[y]; data[y] = x;\n\t\t}\n\t\treturn x != y;\n\t}\n\tbool findset(int x, int y){ return root(x) == root(y); }\n\tint root(int x){ return (data[x] < 0) ? x : data[x] = root(data[x]); }\n\tint size(int x){ return -data[root(x)]; }\n};\n\nstruct edge{\n  int to, cost;\n};\n\nvector<edge> G[100];\n\nbool mycom(pair<edge, int> a, pair<edge, int> b){\n  return a.X.cost < b.X.cost;\n}\n\nll kruskal(int v, int e){\n  ll res = 0;\n  int i, j;\n  unionfind U; U.use(v);\n  vector< pair<edge, int> > lis;\n  rep(i, v)rep(j, G[i].size())lis.pb(mp(G[i][j], i));\n  sort(all(lis), mycom);\n  for(i = 0;i < e;i++){\n    pair<edge, int> tmp = lis[i];\n    if(!U.findset(tmp.X.to, tmp.Y)){\n      res += tmp.X.cost;\n      U.unionset(tmp.X.to, tmp.Y);\n    }\n  }\n  return res;\n}\n\nsigned main(void){\n  int i, j;\n  for(int testcase = 0;;testcase++){\n    int(n);\n    if(n == 0)break;\n    int(m);\n    rep(i, m){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      d = (d - 100) / 100;\n      G[a].pb((edge){b, d});\n      G[b].pb((edge){a, d});\n    }\n    pri(kruskal(n, m * 2));\n\n\n//*/\n\n//*/ break;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 100;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tstring str;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tint abc[3] = {};\n\t\t\tcin >> str;\n\t\t\tint count = 0;\n\t\t\tfor(size_t i = 0; i != str.size(); ++i){\n\t\t\t\tif(str[i] == ',')\n\t\t\t\t\tcount++;\n\t\t\t\telse {\n\t\t\t\t\tabc[count] *= 10;\n\t\t\t\t\tabc[count] += str[i] - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*cout << abc[0] << endl;\n\t\t\tcout << abc[1] << endl;\n\t\t\tcout << abc[2] << endl;*/\n\t\t\te.push_back(Edge{abc[0], abc[1], abc[2] / 100 - 1});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<math.h>\n#include<cmath>\n#include<bitset>\n#include<stdio.h>\n#include<string>\n#include<map>\n#include<algorithm>\n#include<vector>\n#include<iostream>\n#include<utility>\nusing namespace std;\nstruct unionfind{\n  int par[100010]; // 親ノード  必要に応じて要素数を変えよう\n  int rank[100010]; // ランク　必要に応じて要素数を変えよう\n  unionfind(int n){\n    init(n);\n  }\n  void init(int n){\n    for(int i=0;i<=n;i++){\n      par[i]=i;\n      rank[i]=1;\n    }\n  }\n  int root(int x) {\n    if (par[x] == x) {\n      return x;\n    }\n    else {\n      return par[x] = root(par[x]);\n    }\n  }\n  int size(int x){\n    return rank[root(x)];\n  }\n  bool same(int x,int y) {\n    return root(x) == root(y);\n  }\n  void unite(int x,int y) {\n    x=root(x);\n    y=root(y);\n    if(x==y){\n      return;\n    }\n    if(rank[x]<rank[y]){\n      swap(x,y);\n    }\n    rank[x]=rank[x]+rank[y];\n    par[y]=x;\n  }\n};\nstruct edge{\n    int from;\n    int to;\n    int cost;\n    edge(int f,int t, int w) :from(f), to(t), cost(w) { }\n};\nbool comp(const edge& e1,const edge& es){\n  return e1.cost<es.cost;\n}\nint main(){\n  while(1){\n    int n;\n    scanf(\"%d\\n\",&n);\n    if(n==0){\n      break;\n    }\n  int i,m,a,b,d,ans=0;\n  vector<edge> g;\n    unionfind tree(110);\n  scanf(\"\\n%d\\n\",&m);\n  for(i=0;i<m;i++){\n    scanf(\"%d,%d,%d\\n\",&a,&b,&d);\n    g.push_back(edge(a,b,d));\n  }\n  sort(g.begin(),g.end(),comp);\n  for(i=0;i<m;i++){\n    if(tree.same(g[i].to,g[i].from)==0){\n      tree.unite(g[i].to,g[i].from);\n      ans+=g[i].cost/100-1;\n    }\n  }\n    printf(\"%d\\n\",ans);\n  }\n  return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "//\n// Carden Lantern [AOJ 0072]\n// URL: http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072\n//\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\ntypedef vector <PIP>    Edges;\n\nconst int size = 101;\nint P[size];\n\nvoid init( int n ) {\n    for ( int i = 0; i < n; i++ ) {\n        P[i] = -1;\n    }\n}\n\nint find( int a ) {\n    if ( P[a] == -1 ) {\n        return a;\n    }\n    return P[a] = find( P[a] );\n}\n\nvoid merge( int a, int b ) {\n    int fa = find( a ), fb = find( b );\n\n    if ( fa != fb ) {\n        if ( P[a] == -1 ) {\n            P[a] = fb;\n        } else {\n            P[b] = fa;\n        }\n    }\n}\n\nbool same_set( int a, int b ) {\n    return find( a ) == find( b );\n}\n\nbool check( int n, int a ) {\n    for ( int i = 0; i < n; i++ ) {\n        if ( i == a ) {\n            continue;\n        }\n        if ( same_set( i, a ) ) {\n            return true;\n        }\n    }\n    return false;\n}\n\nint main( void ) {\n    string line;\n\n    while ( getline( cin, line ) ) {\n        // init\n        int n, m;\n        Edges E;\n\n        // input\n        if ( line == \"0\" ) {\n            break;\n        }\n        {\n            istringstream is( line );\n            is >> n;\n        }\n        {\n            getline( cin, line );\n            istringstream is( line );\n            is >> m;\n        }\n        for ( int i = 0; i < m; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            int a, b, c;\n            istringstream is( line );\n            is >> a >> b >> c;\n\n            PIP edge( c / 100, PII( a, b ) );\n            E.push_back( edge );\n        }\n\n        // proc\n        int answer = 0;\n        init( n );\n\n        sort( E.begin(), E.end() );\n        for ( int i = 0; i < m; i++ ) {\n            int a = E[i].second.first;\n            int b = E[i].second.second;\n            int c = E[i].first;\n\n            if ( !same_set( a, b ) ) {\n                if ( !check( n, a ) || !check( n, b ) ) {\n                    answer += c - 1;\n                    merge( a, b );\n                }\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "// Carden Lantern [AOJ 0072]\n#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\ntypedef vector <PIP>    Edges;\n\nconst int size = 101;\nint P[size];\n\nvoid init( int n ) {\n    for ( int i = 0; i < n; i++ ) {\n        P[i] = -1;\n    }\n}\n\nint find( int a ) {\n    if ( P[a] == -1 ) {\n        return a;\n    }\n    return P[a] = find( P[a] );\n}\n\nvoid merge( int a, int b ) {\n    int fa = find( a ), fb = find( b );\n    if ( fa != fb ) {\n        P[b] = fa;\n    }\n}\n\nbool same_set( int a, int b ) {\n    return find( a ) == find( b );\n}\n\nint main( void ) {\n    string line;\n    while ( getline( cin, line ) ) {\n        // init\n        int n, m;\n        Edges E;\n\n        // input\n        if ( line == \"0\" ) {\n            break;\n        }\n        {\n            istringstream is( line );\n            is >> n;\n        }\n        {\n            getline( cin, line );\n            istringstream is( line );\n            is >> m;\n        }\n        for ( int i = 0; i < m; i++ ) {\n            getline( cin, line );\n            replace( line.begin(), line.end(), ',', ' ' );\n            int a, b, c;\n            istringstream is( line );\n            is >> a >> b >> c;\n            PIP edge( c, PII( a, b ) );\n            E.push_back( edge );\n        }\n\n        // proc\n        int answer = 0;\n        init( n );\n\n        sort( E.begin(), E.end() );\n        for ( int i = 0; i < m; i++ ) {\n            int a = E[i].second.first;\n            int b = E[i].second.second;\n            int c = E[i].first;\n            if ( !same_set( a, b ) ) {\n                answer += ( c - 1 ) / 100;\n                merge( a, b );\n            }\n        }\n\n        // output\n        cout << answer << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n\n\nusing namespace std;\n\nstring bom[8];\n\nclass Graph{\npublic:\n    int a;\n    int b;\n    int ab;\n};\n\n\nbool asc( const Graph& left, const Graph& right ) {\n    return left.ab<right.ab;\n}\n\n\n\n\nint main(void) {\n    Graph gr[1000];\n    \n    while(1){\n        int n,m;\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        for(int i=0; i<m; i++){\n            scanf(\"%d,%d,%d\",&gr[i].a,&gr[i].b,&gr[i].ab);\n            if(gr[i].a>gr[i].b)swap(gr[i].a,gr[i].b);\n            //cin>>gr[i].a>>gr[i].b>>gr[i].ab;\n        }\n        sort(gr, gr+m, asc);\n        /*for(int i=0; i<m; i++){\n            cout<<gr[i].a<<\" \"<<gr[i].b<<\" \"<<gr[i].ab<<endl;\n        }*/\n        int check[1000]={0};\n        int dist=0;\n        check[gr[0].a]++;\n        check[gr[0].b]++;\n        dist+=gr[0].ab-200;\n        while(1){\n            int count=0;\n            for(int i=0; i<m; i++)count+=check[i];\n            if(count==m)break;\n            for(int i=0; i<m; i++){\n                if(check[gr[i].a]==1&&check[gr[i].b]==0){\n                    check[gr[i].b]++;\n                    dist+=gr[i].ab;\n                    break;\n                }else if(check[gr[i].b]==1&&check[gr[i].a]==0){\n                    check[gr[i].a]++;\n                    dist+=gr[i].ab-100;\n                    break;\n                }\n            }\n            \n        }\n        cout<<dist/100<<endl;\n        \n        \n        \n    }\n    \n    \n    \n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <algorithm>\n#include <complex>\n#include <queue>\n#include <map>\nusing namespace std;\n\n#define REP(i,n) for(int i = 0; i < (int)(n); ++i)\n#define pb push_back\n#define ALL(a) (a).begin(),(a).end()\n\n#define EPS (1e-10)\n#define EQ(a,b) (abs((a)-(b)) < EPS)\n\ntypedef long long ll;\n//struct edge {int to, cost;};\ntypedef pair<int, int> P;\ntypedef complex<double> C;\n\nconst int INF = 99999999;\nconst int MAX_V = 110;\nconst int MAX_E = 10000;\n\ntypedef pair<int, int> edge;    //cost, to\nvector<edge> G[MAX_V];\nbool used[MAX_V];\nint V, E;\nint flag;\n\nint prim() {\n    REP(i, V) used[i] = false;\n    used[0] = true;\n\n    priority_queue<edge, vector<edge>, greater<edge>> que;\n    REP(j, G[0].size()) que.push(G[0][j]);\n\n    int res = 0;\n\n    while (!que.empty()) {\n        int cost = que.top().first, to = que.top().second;\n        que.pop();\n        if (!used[to]) {\n            res += cost;\n            used[to] = true;\n            REP(j, G[to].size()) que.push(G[to][j]);\n        }\n    }\n    return res;\n}\n\nvoid solve() {\n    printf(\"%d\\n\", prim() - (V - 1) );\n}\n\nint main() {\n    while (scanf(\"%d\", &V),  V) {\n        scanf(\"%d\", &E);\n        REP(i, E) {\n            int f, t, c;\n            scanf(\"%d,%d,%d\\n\", &f, &t, &c);\n            c /= 100;\n            G[f].pb(edge(c, t));\n            G[t].pb(edge(c, f));\n        }\n        solve();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include \"stdio.h\"\nusing namespace std;\n\nconst int INF = 10000000;\n\nstruct Edge{\n    Edge(int t, int c)\n        : to(t), cost(c) {}\n\n    int to;\n    int cost;\n};\n\nbool visited[100];\nvector<Edge> G[100];\ntypedef pair<int, int> PII;\n\nint prim(int start){\n    int ans = 0;\n    fill(visited, visited+100, false);\n\n    priority_queue<PII, vector<PII>, greater<PII> > que;\n\n    que.push(PII(0, start));\n    while (!que.empty()){\n        PII p = que.top();\n        int v = p.second;\n        int cst = p.first;\n        que.pop();\n        if (visited[v]) continue;\n        visited[v] = true;\n        ans += cst;\n        for (int i = 0; i < G[v].size(); i++){\n            Edge e = G[v][i];\n            que.push(PII(G[v][i].cost, G[v][i].to));\n        }\n    }\n\n    return ans;\n} \n\nint main(int argc, char const *argv[]){\n    int n, m;\n\n    while (cin>>n, n){\n        cin>>m;\n        for (int i = 0; i < m; i++){\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            d = (d-100) / 100;\n            G[a].push_back(Edge(b, d));\n            G[b].push_back(Edge(a, d));\n        }\n\n        cout<<prim(0)<<endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <string>\n#include <sstream>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <cstring>\n#include <cmath>\n#include <cstdio>\n\nusing namespace std;\n\n#define FOR(i,a,b) for(int i=(a);i<(b);++i)\n#define REP(i,n)  FOR(i,0,n)\n#define ALL(c) (c).begin(),(c).end()\n#define MP make_pair\n#define PB push_back\n\ntypedef long long ll;\ntypedef unsigned int uint;\ntypedef unsigned long long ull;\nconst double EPS = 1e-9;\nconst int INF = 1<<28;\nconst double PI = acos(-1.0);\nconst int dx[] = {0,1,0,-1};\nconst int dy[] = {1,0,-1,0};\n\nbool vpos(int x,int y,int w,int h){return 0<=x&&x<w&&y>=0&&y<h;}\n\ntypedef pair<int,pair<int,int> > E;\n\nstruct UnionFind{\n    vector<int> par;\n    UnionFind(int n){\n        REP(i,n)par.push_back(i);\n    }\n\n    int find(int x){\n        if(par[x]==x)return x;\n        return par[x] = find(par[x]);\n    }\n\n    void union_(int x,int y){\n        x = find(x);\n        y = find(y);\n        par[x] = y;\n    }\n\n    bool same(int x,int y){\n        return find(x) == find(y);\n    }\n};\n\nint main(){\n    for(;;){\n        int n,m;\n        vector<E> es;\n        cin >> n >> m;\n        if(!n)break;\n        UnionFind uf(n);\n        REP(i,m){\n            char conma;\n            int a,b,d;\n            cin >> a >> conma >> b >> conma >> d;\n            es.PB(MP(d,MP(a,b)));\n        }\n        int sum = 0;\n        sort(ALL(es));\n        for(int i=0;i<m;i++){\n            E e = es[i];\n            int a = e.second.first;\n            int b = e.second.second;\n            int d = e.first;\n            if(uf.same(a,b))continue;\n            uf.union_(a,b);\n            sum+=d/100-1;\n        }\n        cout << sum << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct br{\n\tint n1,n2,w;\n};\nbool f(br i,br j){\n\treturn(i.w>j.w);\n}\nint main(){\n\twhile(1){\n\t\tint m,n,i,x=0;\n\t\tchar c;\n\t\tcin>>n; if(n==0)break;\n\t\tvector<int>T(n);\n\t\tfor(i=0;i<n;i++) T[i]=i;\n\n\t\tcin>>m;\n\t\tvector<br>S(m);\n\t\tfor(i=0;i<m;i++) cin>>S[i].n1>>c>>S[i].n2>>c>>S[i].w;\n\t\tsort(S.begin(),S.end(),f);\n\n\t\twhile (S.size()){\n\t\t\tbr B=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[B.n1],c=T[B.n2],a;\n\t\t\tb>c?(a=c,c=b):a=b;\n\t\t\tif(b!=c){\n\t\t\t\tfor(i=a;i<n;i++)\n\t\t\t\t\tif(T[i]==c)T[i]=a;\n\t\t\t\tx+=B.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 100;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tint a1, a2, a3;\n\t\tchar b1, b2;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tcin >> a1 >> b1 >> a2 >> b2 >> a3;\n\t\t\te.push_back(Edge{a1, a2, a3 / 100});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans - n + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\nusing namespace std;\n\n#define INF 1000000000\n#define MAX_V 102\n\n// ?????°: ??£??\\??????, ????????°\nint prim(int adjmatrix[MAX_V][MAX_V], int v){\n  // ?????§???????????????????????¨?????§???????°??????????\n  int mincost[v];\n  // ??????i?????¨????????????????????????\n  bool used[v];\n\n  // ?????????\n  for(int i = 0; i < v; i++){\n    mincost[i] = INF;\n    used[i] = false; \n  }\n  mincost[0] = 0;\n  int length = 0;\n\n  while(true){\n    // ??¨????±??????????????????????????????¨?????§?????????????????????????°?????????????????????¢???\n    // newmember???????¬??????¨????????????????£??????????(-1??§?????????)\n    int newmember = -1;\n    for(int u = 0; u < v; u++){\n      // if(???u???????????¨???????±?????????????????????? && ?????¶???????£??????????u?????¨?????????){ u???????£??????????; }\n      if(!used[u] && (newmember == -1 || mincost[u] < mincost[newmember])){ newmember = u; }\n    }\n\n    // ????????????????????£??????newmember???-1??¨???????????¨???\n    // ???????????????????????¨???????±???????????????¨???????????¨????????§?????¢?´¢??????\n    if(newmember == -1){ break; }\n    \n    // ???newmember?????¨?????????\n    used[newmember] = true;\n    length += mincost[newmember];\n\n    // ??¨?????§???????°??????????????¨?????????´???\n    // ??°?????????newmember?????¨???????±????????????¨????????£????????§???????????§???????°???¨???newmember?????§??????????????¢???????????????????????°??????\n    for(int u = 0; u < v; u++){\n      mincost[u] = min(mincost[u], adjmatrix[newmember][u]);\n    }\n  }\n  \n  return length;\n}\n\n\nint main(void){\n  \n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n;\n    if(n == 0){ break; }\n    cin >> m;\n    \n    // ??£??\\???????????£?¨???¨?????????\n    int adjmatrix[MAX_V][MAX_V];\n    for(int i = 0; i < MAX_V; i++){\n      for(int j = 0; j < MAX_V; j++){\n        adjmatrix[i][j] = INF;\n      }\n    }\n\n    // ???????????±????????????????????£??\\???????????????\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      adjmatrix[a][b] = d;\n      adjmatrix[b][a] = d;\n    }\n  \n    // ????°???¨?????¨????????????????±???????\n    int length = prim(adjmatrix, n);\n\n    // ???????????????\n    cout << length / 100 - n + 1 << endl;\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\nclass Edge{\npublic:\n\tint edge_dist;\n\tint cost;\n\tEdge() : edge_dist(0), cost(0) {}\n\tEdge(int _dist, int _cost) : edge_dist(_dist), cost(_cost) {}\n};\n\nbool operator==(const Edge &a, const Edge &b){\n\treturn (a.cost == b.cost);\n}\nbool operator!=(const Edge &a, const Edge &b){\n\treturn !(a == b);\n}\nbool operator<(const Edge &a, const Edge &b){\n\treturn (a.cost < b.cost);\n}\nbool operator>=(const Edge &a, const Edge &b){\n\treturn !(a < b);\n}\nbool operator>(const Edge &a, const Edge &b){\n\treturn (a.cost > b.cost);\n}\nbool operator<=(const Edge &a, const Edge &b){\n\treturn !(a > b);\n}\n\nint main(){\n\tint v, e, s, t, w, sum = 0;\n\tvector< int > vlist; //??¢?´¢?????? -> 1 / else -> 0\n\tvector< vector< Edge > > edge;\n\tpriority_queue< Edge, vector< Edge >, greater< Edge > > priq;\n\t\n\twhile(cin >> v, v){\n\t\tcin >> e;\n\t\t\n\t\tvlist.resize(v);\n\t\tedge.resize(v);\n\t\t\n\t\tfor(int i = 0; i < v; ++i) vlist[i] = 0;\n\t\t\n\t\tfor(int i = 0; i < e; ++i){\n\t\t\tscanf(\"%d,%d,%d\", &s, &t, &w);\n\t\t\tw /= 100;\n\t\t\t\n\t\t\tedge[s].push_back(Edge(t, w - 1));\n\t\t\tedge[t].push_back(Edge(s, w - 1));\n\t\t}\n\t\t\n\t\tvlist[0] = 1;\n\t\tfor(vector< Edge >::iterator it = edge[0].begin(); it != edge[0].end(); ++it){\n\t\t\tpriq.push(*it);\n\t\t}\n\t\t\n\t\twhile(!priq.empty()){\n\t\t\t\n\t\t\tEdge ed = priq.top();\n\t\t\tpriq.pop();\n\t\t\t\n\t\t\tif(vlist[ed.edge_dist])continue;\n\t\t\t\n\t\t\tvlist[ed.edge_dist] = 1;\n\t\t\tsum += ed.cost;\n\t\t\t\n\t\t\tfor(vector< Edge >::iterator it = edge[ed.edge_dist].begin(); it != edge[ed.edge_dist].end(); ++it){\n\t\t\t\tif(vlist[(*it).edge_dist] == 0){\n\t\t\t\t\tpriq.push(*it);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <algorithm>\n#include <stack>\n#include <queue>\n#include <vector>\n#include <map>\n#include <bitset>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n\nusing namespace std;\n\ntypedef long long ll;\n\nstruct Edge { int from, to, dis; };\n\nbool comp(const Edge& e1, const Edge& e2) {\n\treturn e1.dis < e2.dis;\n}\n\nvector<Edge> es;\nint V, E;\n\nint *par;\nint *rank_;\n\nvoid init(int n) {\n\tpar = new int[n];\n\trank_ = new int[n];\n\tfor (int i = 0; i < n; i++) {\n\t\tpar[i] = i;\n\t\trank_[i] = 0;\n\t}\n}\n\nvoid fin() {\n\tdelete[] par;\n\tdelete[] rank_;\n}\n\nint find(int x) {\n\tif (par[x] == x) {\n\t\treturn x;\n\t} else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y) return;\n\n\tif (rank_[x] < rank_[y]) {\n\t\tpar[x] = y;\n\t} else {\n\t\tpar[y] = x;\n\t\tif (rank_[x] == rank_[y]) rank_[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nll kruskal() {\n\tsort(es.begin(), es.end(), comp);\n\tinit(V);\n\tll res = 0;\n\tfor (int i = 0; i < E; i++) {\n\t\tEdge e = es[i];\n\t\tif (!same(e.from, e.to)) {\n\t\t\tunite(e.from, e.to);\n\t\t\tres += e.dis / 100 - 1;\n\t\t}\n\t}\n\tfin();\n\treturn res;\n}\n\nint main() {\n\twhile (1) {\n\t\tcin >> V;\n\t\tif (V == 0)\n\t\t\tbreak;\n\t\tcin >> E;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tEdge e;\n\t\t\tscanf(\"%d,%d,%d\\n\", &e.from, &e.to, &e.dis);\n\t\t\tes.push_back(e);\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\nusing ll = long long;\n#define rep(i,n) for(int (i)=0;(i)<(int)(n);++(i))\n#define all(x) (x).begin(),(x).end()\n#define pb push_back\n#define fi first\n#define se second\n\nusing pi = pair<int,int>;\nusing edge = pair<int,pi>;\n\nstruct UF{\n    int n;\n    //??£?????£????????????????????????,????????£???????????§??£?????????????????°\n    vector<int> d;\n    UF() {}\n    UF(int N):n(N), d(N,-1){}\n    int root(int v){\n        if(d[v]<0) return v;\n        return d[v]=root(d[v]);\n    }\n    bool unite(int X,int Y){\n        X=root(X); Y=root(Y);\n        if(X==Y) return false;\n        if(size(X) < size(Y)) swap(X,Y);\n        d[X]+=d[Y];\n        d[Y]=X;\n        return true;\n    }\n    int size(int v){ return -d[root(v)]; }\n    bool same(int X,int Y){ return root(X)==root(Y); }\n};\n\nint main()\n{\n    int n;\n    while(scanf(\" %d\", &n),n)\n    {\n        int m;\n        scanf(\" %d\", &m);\n\n        vector<edge> e(m);\n        rep(i,m)\n        {\n            int a,b,d;\n            scanf(\" %d,%d,%d\", &a, &b, &d);\n            e[i] = edge(d,pi(a,b));\n        }\n        sort(all(e));\n\n        UF uf(n);\n        ll ans = 0;\n        rep(i,m)\n        {\n            int a=e[i].se.fi, b=e[i].se.se, cost=e[i].fi;\n            if(!uf.same(a,b))\n            {\n                uf.unite(a,b);\n                ans += cost/100 - 1;\n            }\n        }\n\n        printf(\"%lld\\n\", ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\nusing namespace std;\n\nint main(){\n  int n,m;\n  int a[10000],b[10000],dis[10000];\n  bool use[10000];\n  int max[100][100];\n  int maxnum[100][100];\n  int ans;\n  int tmp;\n\n  while(1){\n    cin >> n;\n    if(!n)break;\n\n    for(int i=0;i<n;i++){\n      for(int j=i+1;j<n;j++){\n\tmax[i][j] = 0;\n\tmaxnum[i][j] = -1;\n      }\n    }\n\n    cin >> m;\n    for(int i=0;i<m;i++){\n      scanf(\"%d,%d,%d\",&a[i],&b[i],&dis[i]);\n      if(a[i]>b[i]){\n\ttmp = a[i];\n\ta[i] = b[i];\n\tb[i] = tmp;\n      }\n      use[i] = true;\n    }\n\n    for(int i=0;i<m;i++){\n      if(max[a[i]][b[i]]){\n\tif(max[a[i]][b[i]] < dis[i])use[i] = false;\n\telse use[maxnum[a[i]][b[i]]] = false;\n      }else{\n\tmax[a[i]][b[i]] = dis[i];\n\tmaxnum[a[i]][b[i]] = i;\n\tfor(int j=a[i];j<n;j++){\n\t  if(max[a[i]][j]){\n\t    if(j<b[i]){\n\t      if(max[a[i]][j]>dis[i]){\n\t\tmax[j][b[i]] = max[a[i]][j];\n\t\tmaxnum[j][b[i]] = maxnum[a[i]][j];\n\t      }else{\n\t\tmax[j][b[i]] = dis[i];\n\t\tmaxnum[j][b[i]] = i;\n\t      }\n\t    }else{\n\t      if(max[a[i]][j]>dis[i]){\n\t\tmax[b[i]][j] = max[a[i]][j];\n\t\tmaxnum[b[i]][j] = maxnum[a[i]][j];\n\t      }else{\n\t\tmax[b[i]][j] = dis[i];\n\t\tmaxnum[b[i]][j] = i;\n\t      }\n\t    }\n\t  }\n\t}\n\tfor(int j=0;j<a[i];j++){\n\t  if(max[j][a[i]]){\n\t    if(max[j][a[i]]>dis[i]){\n\t      max[j][b[i]] = max[j][a[i]];\n\t      maxnum[j][b[i]] = maxnum[j][a[i]];\n\t    }else{\n\t      max[j][b[i]] = dis[i];\n\t      maxnum[j][b[i]] = i;\n\t    }\n\t  }\n\t}\n\tfor(int j=0;j<b[i];j++){\n\t  if(max[j][b[i]]){\n\t    if(j<a[i]){\n\t      if(max[j][b[i]]>dis[i]){\n\t\tmax[j][a[i]] = max[j][b[i]];\n\t\tmaxnum[j][a[i]] = maxnum[j][b[i]];\n\t      }else{\n\t\tmax[j][a[i]] = dis[i];\n\t\tmaxnum[j][a[i]] = i;\n\t      }\n\t    }else{\n\t      if(max[j][b[i]]>dis[i]){\n\t\tmax[a[i]][j] = max[j][b[i]];\n\t\tmaxnum[a[i]][j] = maxnum[j][b[i]];\n\t      }else{\n\t\tmax[a[i]][j] = dis[i];\n\t\tmaxnum[a[i]][j] = i;\n\t      }\n\t    }\n\t  }  \n\t}\n\tfor(int j=b[i];j<n;j++){\n\t  if(max[b[i]][j]){\n\t    if(max[b[i]][j]>dis[i]){\n\t      max[a[i]][j] = max[b[i]][j];\n\t      maxnum[a[i]][j] = maxnum[b[i]][j];\n\t    }else{\n\t      max[a[i]][j] = dis[i];\n\t      maxnum[a[i]][j] = i;\n\t    }\n\t  }\n\t}\n      }\n    }\n\n    ans = 0;\n    for(int i=0;i<n;i++){\n      if(use[i])ans+=dis[i]-100;\n    }\n    cout << ans/100 << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n\n// Union Find\ntemplate<class T=int>\nclass UnionFind\n{\n    std::vector<T> p;\n    std::vector<T> r;\n    T find(const T x)\n    {\n        if(x==p[x]) return x;\n        return p[x]=find(p[x]);\n    }\n    void unite_(T x, T y)\n    {\n        if(x==y) return;\n        if(r[x]>r[y]) std::swap(x,y);\n        else if(r[x]==r[y]) ++r[y];\n        p[x]=y;\n    }\npublic:\n    explicit UnionFind(const T n):p(n),r(n,0)\n    {\n        for(T i=0; i<n; ++i)\n            p[i]=i;\n    }\n    bool same(const T x, const T y)\n    {\n        // assert(0<=x && x<p.size())\n        // assert(0<=y && y<p.size())\n        return find(x)==find(y);\n    }\n    void unite(const T x, const T y)\n    {\n        // assert(0<=x && x<p.size())\n        // assert(0<=y && y<p.size())\n        unite_(find(x),find(y));\n    }\n};\n\n// Kruskal's algorithm\ntemplate<class T, class U>\nT& kruskal(T& edges, U max_v)\n{\n    typedef typename T::value_type Edge;\n    std::sort(edges.begin(),edges.end());\n    UnionFind<U> uf(max_v);\n    edges.erase(\n        std::remove_if(edges.begin(),edges.end(),\n            [&uf](const Edge& e){\n                const auto& a = std::get<1>(e);\n                const auto& b = std::get<2>(e);\n                if(uf.same(a,b)) return true;\n                uf.unite(a,b);\n                return false;\n            }),\n        edges.end());\n    return edges;\n}\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios_base::sync_with_stdio(false);\n    for(int n,m; (std::cin >> n >> m) && n; )\n    {\n        typedef std::tuple<int,int,int> T;\n        std::vector<T> edges(m);\n        for(auto& v: edges)\n        {\n            int a,b,d; char c; std::cin >> a >> c >> b >> c >> d;\n            v = T(d,a,b);\n        }\n        int c=0;\n        for(auto& e: kruskal(edges, n))\n            c+=std::get<0>(e)/100-1;\n        std::cout << c << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <queue>\n#include <vector>\n#include <iostream>\n#include <algorithm>\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 1000000000000000000LL\nusing namespace std;\nlong long prim(int V, vector<pair<long long, long long>> X[]) {\n\tpriority_queue<pair<long long, long long>, vector<pair<long long, long long>>, greater<pair<long long, long long> > > Q;; long long dist[100], color[100];\n\tfor (int i = 0; i < V; i++) { dist[i] = INF; color[i] = WHITE; }\n\tdist[0] = 0; color[0] = GRAY; Q.push(make_pair(0, 0));\n\twhile (!Q.empty()) {\n\t\tpair<long long, long long>pa = Q.top(); Q.pop();\n\t\tlong long a1 = pa.first, a2 = pa.second; color[a2] = BLACK;\n\t\tfor (int i = 0; i < X[a2].size(); i++) {\n\t\t\tlong long to = X[a2][i].first, leng = X[a2][i].second;\n\t\t\tif (dist[to] > leng && color[to] < BLACK) {\n\t\t\t\tdist[to] = leng; Q.push(make_pair(dist[to], to));\n\t\t\t}\n\t\t}\n\t}\n\tlong long sum = 0; for (int i = 0; i < V; i++) { sum += dist[i]; }//0-indexed\n\treturn sum;\n}\nint n, m, u, v, w; vector<pair<long long, long long> > g[100];\nint main() {\n\twhile(cin >> n >> m) {\n\t\tfor(int i = 0; i < n; i++) g[i].clear();\n\t\tfor(int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", u, v, w);\n\t\t\tg[u].push_back(make_pair(v, w / 100 - 1));\n\t\t\tg[v].push_back(make_pair(u, w / 100 - 1));\n\t\t}\n\t\tcout << prim(n, g) << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\nstruct EDGE\n{\n    int to, cost;\n    bool operator < (const EDGE& t) const {\n        return cost > t.cost;\n    }\n};\nvector<EDGE> v[100]; \nbool f[100];\nint search()\n{\n    int res = 0;\n    priority_queue<EDGE> que;\n    que.push({0, 0});\n    while (!que.empty()){\n        EDGE e = que.top(); que.pop();\n        if (f[e.to]) continue;\n        f[e.to] = true;\n        res += e.cost;\n        rep(i, v[e.to].size()){\n            if (!f[v[e.to][i].to]){\n                que.push(v[e.to][i]);\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d\", &n), n){\n        scanf(\"%d\", &m);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            a--; b--;\n            c = c / 100 - 1;\n            v[a].pb({b, c});\n            v[b].pb({a, c});\n        }\n        printf(\"%d\", search());\n        memset(f, false, sizeof(f));\n        rep(i, n) v[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\nusing namespace std;\n\n#define MAX_V 100\n#define INF 1<<20\n\nint cost[MAX_V+1][MAX_V+1];\nint mincost[MAX_V+1];\nbool used[MAX_V+1];\nint V;\n\nint prim() {\n  for( int i=0; i<V; i++ ) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n\n  while( true ) {\n    int v = -1;\n    for( int u=0; u<V; u++ ) {\n      if( !used[u] && ( v == -1 || mincost[u] < mincost[v] ) ) v = u;\n    }\n    if( v == -1 ) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for( int u=0; u<V; u++ ) {\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main() {\n  int m;\n  int a, b, c;\n  char d;\n  \n  while( cin >> V >> m ) {\n    fill(cost[0], cost[V], INF);\n    while( m-- ) {\n      cin >> a >> d >> b >> d >> c; c/=100; c--;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    cout << prim() << endl;\n  }\n  \n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair <int, int> PII;\ntypedef pair <int, PII> PIP;\n\nconst int size = 101;\nint P[size];\nbool used[size];\nint cnt[size];\nint n, m;\nvector <PIP> E;\n\nvoid init( int n ) {\n  for ( int i = 0; i < n; i++ ) {\n    P[i] = -1;\n  }\n}\n\nint find( int a ) {\n  if ( P[a] == -1 ) return a;\n  return P[a] = find( P[a] );\n}\n\nvoid unite( int a, int b ) {\n  int fa = find( a ), fb = find( b );\n  if ( fa != fb ) {\n    P[fa] = fb;\n  }\n}\n\nbool same_set( int a, int b ) {\n  return find( a ) == find( b );\n}\n\nint main() {\n  string line;\n\n  while ( getline( cin, line ) ) {\n    if ( line == \"0\" ) break;\n\n    {\n      // n\n      istringstream is( line );\n      is >> n;\n    }\n    {\n      // m\n      getline( cin, line );\n      istringstream is( line );\n      is >> m;\n    }\n    for ( int i = 0; i < m; i++ ) {\n      // a, b, c\n      getline( cin, line );\n      replace( line.begin(), line.end(), ',', ' ' );\n      istringstream is( line );\n      int a, b, c;\n      is >> a >> b >> c;\n\n      // add edge\n      PIP edge( c, PII( a, b ) );\n      E.push_back( edge );\n    }\n\n    sort( E.begin(), E.end() );\n\n    init(n);\n    for ( int i = 0; i < n; i++ ) {\n      used[i] = false;\n      cnt[i] = 0;\n    }\n\n    int answer = 0;\n    for ( int i = 0; i < m; i++ ) {\n      int a = E[i].first;\n      int b = E[i].second.first;\n      int c = E[i].second.second;\n\n      if ( find( b ) != find( c ) ) {\n\tunite( b, c );\n\tanswer += ( a / 100 ) - 1;\n      }\n    }\n\n    cout << answer << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 1 << 30;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tint a1, a2, a3;\n\t\tchar b1, b2;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tcin >> a1 >> b1 >> a2 >> b2 >> a3;\n\t\t\te.push_back(Edge{a1, a2, a3 / 100});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans - n + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<vector>\n#include<algorithm>\n#include<queue>\nusing namespace std;\nstruct edge{\n    int to,cost;\n    edge(int a,int b):to(a),cost(b){}\n    edge(){}\n    bool operator>(const edge &d)const{\n        return cost>d.cost;\n    }\n};\nint main(){\n    int N;\n    while(scanf(\"%d\",&N),N){\n        int M;\n        scanf(\"%d\",&M);\n        vector<vector<edge> >V(N);\n        for(int i=0;i<M;i++){\n            int a,b,c;\n            scanf(\"%d,%d,%d\",&a,&b,&c);\n            c=c/100-1;\n            V[a].push_back(edge(b,c));\n            V[b].push_back(edge(a,c));\n        }\n\n        bool used[100];fill(used,used+100,false);\n        int res=0;\n        priority_queue<edge,vector<edge>,greater<edge> >Q;\n        Q.push(edge(0,0));\n        while(Q.size()){\n            int to=Q.top().to,cost=Q.top().cost;\n            Q.pop();\n            if(used[to])continue;\n            used[to]=true;\n            res+=cost;\n            for(int i=0;i<V[to].size();i++)Q.push(V[to][i]);\n        }\n        printf(\"%d\\n\",res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<cstdio>\n#include<map>\n#include<vector>\n#include<algorithm>\nusing namespace std;\nint main(){\n  int n;\n  while(cin >>n,n){\n    int m,ans = 0;\n    vector<pair<int,pair<int,int> > > P;\n    bool done[100]={false};\n    cin >>m;\n    for(int i=0,a,b,c; i<m; i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      P.push_back(make_pair(c,make_pair(a,b)));\n    }\n    sort(P.begin(),P.end());\n    ans+=(P[0].first/100)-1;\n    done[P[0].second.first] = done[P[0].second.second] = true;\n    for(int i=0; i<n-1; i++){\n      for(int j=0; j<m; j++){\n\tif(done[P[j].second.first]^done[P[j].second.second]){\n\t  ans+=(P[j].first/100)-1;\n\t  done[P[j].second.first] = done[P[j].second.second] = true;\n\t  break;\n\t}\n      }\n    }\n    cout <<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <complex>\n#include <sstream>\n#include <string>\n#include <algorithm>\n#include <deque>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <vector>\n#include <set>\n#include <limits>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\nusing namespace std;\n#define REP(i, j) for(int i = 0; i < (int)(j); ++i)\n#define FOR(i, j, k) for(int i = (int)(j); i < (int)(k); ++i)\n#define P pair<int, int>\n#define SORT(v) sort((v).begin(), (v).end())\n#define REVERSE(v) reverse((v).begin(), (v).end())\nconst int INF = (1 << 30);\n\nvoid setV(vector< vector<int> > &v){\n  string str, tmp; cin >>str;\n  vector<string> nums;\n  stringstream ss(str);\n  while(getline(ss, tmp, ',')) nums.push_back(tmp);\n  int from = atoi(nums[0].c_str()), to = atoi(nums[1].c_str()), cost = atoi(nums[2].c_str());\n  v[from][to] = cost;\n  v[to][from] = cost;\n}\n\nint main() {\n  int V, E; cin >>V >>E;\n  vector< vector<int> > v(V, vector<int>(V, INF));\n  REP(i, E) setV(v);\n\n  priority_queue< P, vector<P>, greater<P> > open;\n  open.push(P(100, 0));\n  vector<int> closed(V, INF);\n\n  int min_cost = 0;\n  while(!open.empty()){\n    P now = open.top();\n    open.pop();\n\n    if(closed[now.second] != INF) continue;\n    closed[now.second] = now.first;\n    min_cost += (now.first - 100) / 100;\n\n    REP(i, V){\n      if(closed[i] == INF && v[now.second][i] != INF){\n        open.push(P(v[now.second][i], i));\n      }\n    }\n\n  }\n  cout <<min_cost <<endl;\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n#include <functional>\n\nusing namespace std;\ntypedef pair<int, int> P;\nstatic const int INF = 999999;\nstruct SEdge\n{\n\tint To;\n\tint Cost;\n};\nint V, E;\nvector<int> mincost;\nvector< vector<SEdge> > G;\nbool used[128];\n\nint Prim()\n{\n\tfill(used, used + V, false);\n\tfill(mincost.begin(), mincost.end(), INF);\n\tmincost[0] = 0;\n\tpriority_queue<P, vector<P>, greater<P> > PQue;\n\tPQue.push(P(0, 0));\n\tint res = 0;\n\twhile(!PQue.empty())\n\t{\n\t\tP p = PQue.top();\n\t\tPQue.pop();\n\t\tint v = p.second;\n\t\tif(mincost[v] < p.first || used[v])\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\t\tused[v] = true;\n\t\tres += p.first;\n\t\tfor(int i = 0; i < G[v].size(); ++i)\n\t\t{\n\t\t\tSEdge e = G[v][i];\n\t\t\tif(mincost[e.To] > e.Cost)\n\t\t\t{\n\t\t\t\tmincost[e.To] = e.Cost;\n\t\t\t\tPQue.push(P(mincost[e.To], e.To));\n\t\t\t}\n\t\t}\n\t}\n\treturn(res);\n}\n\nvoid solve()\n{\n\twhile(cin >> V, V)\n\t{\n\t\tfor(int i = 0; i < G.size(); ++i)\n\t\t{\n\t\t\tG[i].clear();\n\t\t}\n\t\tG.clear();\n\t\tcin >> E;\n\t\tmincost.resize(V);\n\t\tG.resize(V);\n\t\tfor(int i = 0; i < E; ++i)\n\t\t{\n\t\t\tint From, To, Cost;\n\t\t\tscanf(\"%d,%d,%d\", &From, &To, &Cost);\n\t\t\tSEdge e1, e2;\n\t\t\te1.To = To;\n\t\t\te2.To = From;\n\t\t\te1.Cost = e2.Cost = Cost / 100 - 1;\n\t\t\tG[From].push_back(e1);\n\t\t\tG[To].push_back(e2);\n\t\t}\n\t\tcout << Prim() << endl;\n\t}\n}\n\nint main()\n{\n\tsolve();\n\treturn(0);\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\t\tscanf(\"%d\",&m);\n\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost + n,numeric_limits<int>::max());\n\n\n\t\tint** cost = new int*[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcost[i] = new int[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcost[i][j]=numeric_limits<int>::max();\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from,to,dist;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&dist);\n\t\t\tcost[from][to] = min(cost[from][to],dist / 100 - 1);\n\t\t}\n\n\t\tmincost[0]=0;\n\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!used[i] && (v==-1 || mincost[i] < mincost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\t\t\n\t\t\tres+=mincost[v];\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmincost[i] = min(mincost[i],cost[v][i]);\n\t\t\t}\n\t\t\t\n\t\t}\n\n\t\tcout << res << endl;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdelete[] cost[i];\n\t\t}\n\n\t\tdelete[] cost;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 100;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tstring str;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tint abc[3] = {};\n\t\t\tcin >> str;\n\t\t\tint count = 0;\n\t\t\tfor(size_t i = 0; i != str.size(); ++i){\n\t\t\t\tif(str[i] == ',')\n\t\t\t\t\tcount++;\n\t\t\t\telse {\n\t\t\t\t\tabc[count] *= 10;\n\t\t\t\t\tabc[count] += str[i] - '0';\n\t\t\t\t}\n\t\t\t}\n\t\t\t/*cout << abc[0] << endl;\n\t\t\tcout << abc[1] << endl;\n\t\t\tcout << abc[2] << endl;*/\n\t\t\te.push_back(Edge{abc[0], abc[1], abc[2]});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tif(e[i].cost % 100 == 0)\n\t\t\t\t\tans += e[i].cost / 100 -1;\n\t\t\t\telse\n\t\t\t\t\tans += e[i].cost / 100;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cctype>\n#include<cstring>\n#include<cstdlib>\n#include<algorithm>\n#include<stack>\n#include<queue>\n#include<deque>\n#include<vector>\n#include<list>\n#include<bitset>\n#include<set>\n\nusing namespace std;\n\n#define MAX_N 100\n#define INF 1 << 20\n\nint n, m, a, b, c, d[MAX_N][MAX_N], i, j, min[3], cnt, ans;\nbool array[MAX_N];\n\nint main(){\n\twhile (true){\n\t\tscanf(\"%d\", &n);\n\t\tif (n == 0) return 0;\n\t\tscanf(\"%d\", &m);\n\t\tcnt = 1;\n\t\tans = 0;\n\t\tfor (i = 0; i < n; i++){\n\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\tif (i == j){\n\t\t\t\t\td[i][j] = 0;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\td[i][j] = INF;\n\t\t\t}\n\t\t\tarray[i] = false;\n\t\t}\n\t\tarray[0] = true;\n\t\tfor (i = 0; i < m; i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\td[a][b] = c / 100 - 1;\n\t\t\td[b][a] = c / 100 - 1;\n\t\t}\n\t\tfor (cnt = 1; cnt < n; cnt++){\n\t\t\tc = INF;\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tfor (j = 0; j < n; j++){\n\t\t\t\t\tif (array[i] && !array[j] && c > d[i][j]){\n\t\t\t\t\t\tc = d[i][j];\n\t\t\t\t\t\tb = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += c;\n\t\t\tarray[b] = true;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\nusing namespace std;\nstruct Edge{ int from, to, cost; };\n\nbool comp(const Edge& e1, const Edge& e2){\n\treturn e1.cost < e2.cost;\n}\n\nconst int N = 10000;\nvector<Edge> e;\n\nint par[N];\nint rank_[N];\n\nint find(int x)\n{\n\tif(x == par[x])\n\t\treturn x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y)\n{\n\tx = find(x);\n\ty = find(y);\n\tif(x == y)\n\t\treturn;\n\t\n\tif(rank_[x] < rank_[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif(rank_[x] == rank_[y])\n\t\t\trank_[x]++;\n\t}\n}\n\nbool same(int x, int y)\n{\n\treturn find(x) == find(y);\n}\n\nint main()\n{\n\tcin.tie(0);\n\tios::sync_with_stdio(false);\n\t\n\twhile(1){\n\t\tint n, m;\n\t\tcin >> n;\n\t\tif(n == 0)\n\t\t\tbreak;\n\t\tcin >> m;\n\t\t\n\t\tint a1, a2, a3;\n\t\tchar b1, b2;\n\t\tfor(int i = 0; i != m; ++i){\n\t\t\tcin >> a1 >> b1 >> a2 >> b2 >> a3;\n\t\t\te.push_back(Edge{a1, a2, a3 / 100});\n\t\t}\n\t\t\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tpar[i] = i;\n\t\t\trank_[i] = 0;\n\t\t}\n\t\t\n\t\tsort(e.begin(), e.end(), comp);\n\t\t\n\t\tint ans = 0;\n\t\tfor(int i = 0; i != n; ++i){\n\t\t\tif(!same(e[i].from, e[i].to)){\n\t\t\t\tunite(e[i].from, e[i].to);\n\t\t\t\tans += e[i].cost;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcout << ans - n + 1 << endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\n\nstruct P{\n    int edge;\n    int cost;\n};\n\nint n,m;\nint ans;\nint E[150];\nvector<P> V[150];\nP p;\n\nsigned main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            p={y,z};\n            V[x].PB(p);\n            p={x,z};\n            V[y].PB(p);\n        }\n        rep(i,n){\n            P res;\n            res.cost=INT_MAX;\n            rep(j,V[i].size()){\n                if(E[i]==1&&E[V[i][j].edge]==1)continue;\n                if(res.cost>V[i][j].cost){\n                    res=V[i][j];\n                }\n            }\n            if(res.cost==INT_MAX)continue;\n            ans+=res.cost-100;\n            E[i]=1;\n            E[res.edge]=1;\n        }\n        cout<<ans/100<<endl;\n        ans=0;\n        rep(i,150)V[i].clear();\n        memset(E,0,sizeof(E));\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Road {\n    int a, b;\n    int dist;\n\n    bool operator < (const Road &other) const {\n        return dist < other.dist;\n    }\n};\n\nint getroot(int i, vector<int> &roots) {\n    if(roots[i] == i) return i;\n    return roots[i] = getroot(roots[i], roots);\n}\n\nvoid unite(int i, int j, vector<int> &roots) {\n    roots[i] = getroot(j, roots);\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N;\n        if(!N) break;\n        cin >> M;\n\n        vector<Road> roads(M);\n        char comma;\n        for(int i = 0; i < M; ++i) \n            cin >> roads[i].a >> comma >> roads[i].b >> comma >> roads[i].dist;\n        sort(roads.begin(), roads.end());\n\n        int ans = 0;\n        vector<int> roots(N);\n        for(int i = 0; i < N; ++i) roots[i] = i;\n        for(int i = 0; i < M; ++i) {\n            const Road &r = roads[i];\n            if(getroot(r.a, roots) == getroot(r.b, roots)) continue;\n            unite(r.a, r.b, roots);\n            ans += r.dist/100 - 1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n\n//dx[i],dy[i]???i?????????????§???????????????¢???\n//  3\n// 2 0\n//  1\t\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nint X, Y;\n\n//xy??§?¨???§?????±???????????¢?´¢\nvoid dfs(int x, int y) {\n\t/* ?????? */\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\t//?§????4???????????¢?´¢\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < X && 0 <= ny&&ny < Y) {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n//xy??§?¨???§??????????????¢?´¢\n//???????????¢\nint bfs(int sx, int sy, int gx, int gy) {\n\tconst int MAX = 1; //????????´???\n\tqueue<pii> Q;\n\tQ.push(pii(sx, sy));\n\t//???????????¢\n\tint d[MAX][MAX];\n\tmemset(d, 0x3f, sizeof(d));\n\td[sx][sy] = 0;\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tfor (pii u; !Q.empty();) {\n\t\tu = Q.front(); Q.pop();\n\t\tif (u == pii(gx, gy))break; //??´??????????????¢?´¢????????????\n\t\tfor (int i = 0; i < 4; i++) {//?§????4???????????¢?´¢\n\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\tif (0 <= nx&&nx < X && 0 <= ny&&ny < Y) {\n\t\t\t\tif (d[nx][ny] != INF)continue; //??¢?´¢???????£???°???\n\t\t\t\td[nx][ny] = d[u.first][u.second] + 1;\n\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[gx][gy];\n}\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Dijkstra O( |E|log|V| )\n//dist: ?§????????????????????????§??????????????¢\n//?????????: ???????????¨????????????(??????-1)\nvector<int> dijkstra(const Graph &g, int s, vector<Weight> &dist) {\n\ttypedef tuple<Weight, int, int> State; //?§?????????????????°?????????? ??? ???\n\tpriority_queue<State, vector<State>, greater<State> >PQ;\n\tint n = g.size();\n\tvector<int> color(n, WHITE);\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INFG); //distance\n\tdist[s] = 0; PQ.push(State(0, s, -1)); color[s] = GRAY; //?§????\n\twhile (!PQ.empty()) {\n\t\tWeight d; int v; int u;\n\t\ttie(d, v, u) = PQ.top(); PQ.pop(); //dist???????°??????¨??????????´????????????????\n\t\tif (dist[v] < d) continue; //?????§???????????§???????????°??????\n\t\tcolor[v] = BLACK;\n\t\tprev[v] = u;\n\t\tfor (auto &e : g[v]) { //??£??\\????????????????????¨????????????\t\t\n\t\t\tif (color[e.d] == BLACK)continue; //??¢?´¢????????????\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tPQ.push(State(dist[e.d], e.d, v));\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Bellman Ford O(|V||E|)\n//dist: ?§????????????????????????§??????????????¢\n//prev: ???????????¨????????????\n//?????????: ???????????????:true ??????:false\nbool bellmanFord(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n\tint n = g.size();\n\tEdges es; for (int i = 0; i < n; i++) for (auto &e : g[i]) es.emplace_back(e);\n\tdist.assign(n, INFG); dist[s] = 0;\n\tprev.assign(n, -1);\n\tbool negative_cycle = false;\n\tfor (int i = 0;; i++) {\n\t\tbool update = false;\n\t\tfor (auto &e : es) {\n\t\t\tif (dist[e.s] != INFG && dist[e.d] > dist[e.s] + e.w) {\n\t\t\t\tdist[e.d] = dist[e.s] + e.w;\n\t\t\t\tprev[e.d] = e.s;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tif (!update) break;\n\t\tif (i > n) { negative_cycle = true; break; }\n\t}\n\treturn !negative_cycle;\n}\n\n//?§?????????????????????§??????????????????\n//???????????????????????°?????????????§??????????????????§?????????????????¢????????????\nvector<int> getPath(int s, int g, vector<int> prev) {\n\tvector<int> path;\n\tpath.push_back(g);\n\tfor (int i = g; i != s; ) path.push_back(i = prev[i]);\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n\n//??¨????????????????????? All Pairs Shortest Path\n//Warshall Floyd O(|V|^3)\n//?????????: ???????????????:true ??????:false\nbool warshallFloyd(const Graph &g, Matrix &dist) {\n\tbool negative_cycle = false;\n\tint n = g.size();\n\tdist.assign(n, Array(n, INFG));\n\tfor (int i = 0; i < n; i++) dist[i][i] = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto e : g[i])\n\t\t\tdist[e.s][e.d] = min(dist[e.s][e.d], e.w);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tif (dist[j][i] != INFG&&dist[i][k] != INFG)\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i][i] != 0)\n\t\t\tnegative_cycle = true;\n\treturn !negative_cycle;\n}\n\n//???????????????\nvoid printPath(vector<int> path) {\n\tcout << \"Path: \";\n\tfor (auto p : path) cout << p << \" \";\n\tcout << endl;\n}\n\n//???????????????????????????\n//??\\?¬???°???0????????¨???????????????????????????ret????????£??????\nvector<int> topologicalSort(const Graph &g) {\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), indeg(n); //??\\?¬???°\n\tfor (auto &es : g) for (auto &e : es) indeg[e.d]++;\n\tqueue<int> Q;\n\tfor (int i = 0; i < n; i++) if (indeg[i] == 0) Q.push(i);\n\twhile (!Q.empty()) {\n\t\tint v = Q.front(); Q.pop(); ord[k++] = v;\n\t\tfor (auto &e : g[v]) if (--indeg[e.d] == 0) Q.push(e.d);\n\t}\n\treturn *max_element(indeg.begin(), indeg.end()) == 0 ? ord : vector<int>();\n}\n\n//??¨?????´???\nEdge diameter(const Graph &g, int s = 0) {\n\tvector<Weight> dist;\n\tdijkstra(g, s, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++) if (dist[i] != INFG && (u == -1 || dist[i] > dist[u])) u = i;\n\tdijkstra(g, u, dist);\n\tfor (int i = 0; i < n; i++) if (dist[i] != INFG && (v == -1 || dist[i] > dist[v])) v = i;\n\tWeight d = dist[v];\n\tif (u > v) swap(u, v);\n\treturn Edge(u, v, d);\n}\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].emplace_back(Edge(a, b, d));\n\t\t\tg[b].emplace_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = kruskal(g);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\ntypedef pair<int,pair<int,int> > P;\n\nvector<int> uni;\nint find(int at){\n    if(at==uni[at]) return at;\n    else return uni[at]=find(uni[at]);\n}\nvoid unite(int a,int b){\n    uni[find(a)]=find(b);\n}\nint main(){\n    for(;;){\n        int N,M;\n        scanf(\"%d\\n%d\\n\",&N,&M);\n        if(N==0) break;\n        uni=vector<int>(N);\n        for(int i=0;i<N;i++) uni[i]=i;\n        vector<P> ros;\n        int a,b,dis;\n        for(int i=0;i<M;i++){\n            scanf(\"%d,%d,%d\\n\",&a,&b,&dis);\n            dis=dis/100-1;\n            ros.push_back(make_pair(dis,make_pair(a,b)));\n        }\n        sort(ros.begin(),ros.end());\n        int ret=0;\n        for(int i=0;i<M;i++){\n            dis=ros[i].first,a=ros[i].second.first,b=ros[i].second.second;\n            if(find(a)!=find(b)){\n                unite(a,b);\n                ret+=dis;\n            }\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define FOR(i,a,b) for(int i=(a);i<(b);i++)\n#define RFOR(i,a,b) for(int i=(b) - 1;i>=(a);i--)\n#define REP(i,n) for(int i=0;i<(n);i++)\n#define RREP(i,n) for(int i=n-1;i>=0;i--)\n\n#define PB push_back\n#define INF (1<<29)\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define CLR(a) memset(a,0,sizeof(a))\nconst int dx[] = {-1,0,0,1},dy[] = {0,1,-1,0};\n\ntypedef long long int ll;\n\nusing namespace std;\n\nvector<int> split(string s){\n    vector<int> ret;\n    s += ',';\n    int x = -1;\n    REP(i,s.size()){\n\tif(s[i] == ','){\n\t    ret.PB( stoi(s.substr(x+1,i-x-1)) );\n\t    x = i;\n\t}\n    }\n    return ret;\n}\n\nint main(){\n    while(true){\n\tint n,m;\n\tint d[101][101];\n\tint dd[101];\n\tmemset(d,-1,sizeof(d));\n\tmemset(dd,-1,sizeof(dd));\n\tcin >> n;\n\tif(n == 0) break;\n\tcin >> m;\n\tvector< vector<int> > vec(n,vector<int>(0));\n\tREP(i,m){\n\t    string s;\n\t    cin >> s;\n\t    vector<int> sl = split(s);\n\t    vec[sl[0]].PB(sl[1]);\n\t    vec[sl[1]].PB(sl[0]);\n\t    d[sl[0]][sl[1]] = sl[2];\n\t    d[sl[1]][sl[0]] = sl[2];\n\t}\n\tint ans = 0;\n\tint count = 0;\n\tint t = 0;\n\tint v = 0;\n\tvector<bool> used(n,false);\n\tused[0] = true;\n\tpriority_queue< pair<int,int>,vector< pair<int,int> >, greater< pair<int,int> > > q;\n\tREP(i,vec[0].size()){\n\t    q.push( pair<int,int>(d[0][vec[0][i]],vec[0][i]));\n\t}\n\twhile(!q.empty()){\n\t    v = q.top().first;\n\t    t = q.top().second;\n\t    q.pop();\n\t    if(!used[t]){\n\t\tused[t] = true;\n\t\tdd[t] = v;\n\t\tans += v/100 - 1;\n\t\tREP(i,vec[t].size()){\n\t\t    q.push( pair<int,int>(d[t][vec[t][i]],vec[t][i]));\n\t\t}\n\t    }else if(dd[t] > v){\n\t    }\n\t}\n\tREP(i,n){\n\t}\n\tcout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <stdio.h>\nusing namespace std;\n\nint main() {\n    int n,m,i,j,sum,a,b,c,x,y;\n\tint da[100][100],use[100];\n\twhile(cin >> n) {\n\t\tif (n==0) break;\n\t\tfor (i=0;i<n;i++) { use[i]=0; for (j=0;j<n;j++) da[i][j]=0; }\n        cin >> m;\n\t\tfor (i=0;i<m;i++) {\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tda[a][b]=c; da[b][a]=c;\n\t\t}\n\t\tuse[0]=1; sum=0;\n\t\tfor (a=0; a<n-1; a++) {\n         b=600000000;\n\t\t for (i=0;i<n;i++) if (use[i]==1) for (j=0;j<n;j++) if (da[i][j]>0) if (da[i][j]<b) { b=da[i][j]; x=j; y=i;}\n\t\t use[x]=1; sum+=b/100-1;\n         da[y][x]=0; da[x][y]=0;\n\t\t}\n\t\tcout << sum << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nstruct branch{\n\tint n1,n2,w;\n};\nbool f(branch i,branch j){\n\treturn(i.w>j.w);\n}\nint main(){\n\twhile(1){\n\t\tint m,n,i,x=0;\n\t\tchar c;\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tvector<int>T(n);\n\t\tfor(i=0;i<n;i++) T[i]=i;\n\n\t\tcin>>m;\n\t\tvector<branch>S(m);\n\t\tfor(i=0;i<m;i++) cin>>S[i].n1>>c>>S[i].n2>>c>>S[i].w;\n\t\tsort(S.begin(),S.end(),f);\n\n\t\tbranch tmp;\n\t\twhile(S.size()){\n\t\t\ttmp=S.back();\n\t\t\tS.pop_back();\n\t\t\tint b=T[tmp.n1],c=T[tmp.n2],a=(b>c?b:c);\n\t\t\tif(b!=c){\n\t\t\t\tfor(i=a;i<n;i++)\n\t\t\t\t\tif(T[i]==c)T[i]=b;\n\t\t\t\tx+=tmp.w/100-1;\n\t\t\t}\n\t\t}\n\t\tcout<<x<<endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <map>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nconst int INF = 1e9;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind {\n  vector<int> data;\n  UnionFind(int size) : data(size, -1) { }\n  bool unionSet(int x, int y) {\n    x = root(x); y = root(y);\n    if (x != y) {\n      if (data[y] < data[x]) swap(x, y);\n      data[x] += data[y]; data[y] = x;\n    }\n    return x != y;\n  }\n  bool findSet(int x, int y) {\n    return root(x) == root(y);\n  }\n  int root(int x) {\n    return data[x] < 0 ? x : data[x] = root(data[x]);\n  }\n  int size(int x) {\n    return -data[root(x)];\n  }\n};\n\npair<Weight, Edges> minimumSpanningForest(const Graph &g) {\n    int n = g.size();\n    UnionFind uf(n);\n    priority_queue<Edge> Q;\n    REP(u, n) FOR(e, g[u]) if (u < e->dst) Q.push(*e);\n\n    Weight total = 0;\n    Edges F;\n    while (F.size() < n-1 && !Q.empty()) {\n        Edge e = Q.top(); Q.pop();\n        if (uf.unionSet(e.src, e.dst)) {\n            F.push_back(e);\n            total += e.weight;\n        }\n    }\n    return pair<Weight, Edges>(total, F);\n}\n\nint main()\n{\n    int n, m;\n    char ch;\n\n    while (cin >> n, n) {\n        Graph g(n);\n        pair<Weight, Edges> ans;\n\n        cin >> m;\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n\n            cin >> u >> ch >> v >> ch >> w;\n            w = w / 100 - 1;\n            g[u].push_back(Edge(u, v, w));\n            g[v].push_back(Edge(v, u, w));\n        }\n        ans = minimumSpanningForest(g);\n\n        cout << ans.first << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n\nstruct edge {\n    int u, v, cost;\n    bool operator<(edge const& other) const {\n        return cost < other.cost;\n    }\n};\n\nclass union_find {\npublic:\n    union_find(int n)\n        : par_(n, -1)\n    {}\n    void init(int n) {\n        par_.assign(n, -1);\n    }\n\n    int root(int x) {\n        return par_[x] < 0 ? x : par_[x] = root(par_[x]);\n    }\n\n    bool unite(int x, int y) {\n        x = root(x); y = root(y);\n        if(x == y) {\n            return false;\n        } else {\n            if(par_[x] < par_[y]) {\n                par_[x] += par_[y];\n                par_[y] = x;\n            } else {\n                par_[y] += par_[x];\n                par_[x] = y;\n            }\n            return true;\n        }\n    }\n\n    bool same(int x, int y) {\n        return root(x) == root(y);\n    }\n\n    int size(int x) {\n        return -par_[root(x)];\n    }\n\nprivate:\n    std::vector<int> par_;\n};\n\nint main() {\n    int n;\n    while(cin >> n, n) {\n        int m;\n        cin >> m;\n        vector<edge> es;\n        for(int i=0; i<m; ++i) {\n            int a, b, d;\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            es.push_back((edge){a, b, d / 100 - 1});\n        }\n        sort(es.begin(), es.end());\n        union_find uf(n);\n        int res = 0;\n        for(int i=0; i<m; ++i) {\n            if(!uf.same(es[i].u, es[i].v)) {\n                res += es[i].cost;\n                uf.unite(es[i].u, es[i].v);\n            }\n        }\n        cout << res << endl;\n    }\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint Kruskal(Graph& g,Edges& e)\n{\n\te.clear();\n\t\n\tUnionFind uf(g.size());\n\tmultiset<Edge> s;\n\trep(i,g.size())\n\t\trep(j,g[i].size())\n\t\t\ts.insert(g[i][j]);\n\t\n\tint res=0;\n\tforeach(i,s){\n\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n\t\t\tuf.Union(i->src,i->dst);\n\t\t\tres+=i->weight;\n\t\t\te.push_back(*i);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint Prim(Graph& g,Edges& tree,int root=0)\n{\n\ttree.clear();\n\t\n\tint size=g.size();\n\tvector<int> visited(size);\n\t\n\tpriority_queue<Edge,vector<Edge>,greater<Edge> > pq;\n\tpq.push(Edge(-1,root,0));\n\tint res=0;\n\twhile(!pq.empty()){\n\t\tEdge e=pq.top();\n\t\tpq.pop();\n\t\tif(visited[e.dst])\n\t\t\tcontinue;\n\t\tif(e.src!=-1)\n\t\t\ttree.push_back(e);\n\t\tvisited[e.dst]=1;\n\t\tres+=e.weight;\n\t\trep(i,g[e.dst].size()){\n\t\t\tEdge cand=g[e.dst][i];\n\t\t\tif(!visited[cand.dst])\n\t\t\t\tpq.push(cand);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(dst,src,weight/100-1));\n\t\t}\n\t\tEdges e;\n\t\t//int sum=Kruskal(g,e);\n\t\tint sum=Prim(g,e);\n\t\tcout<<sum<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1<<29;\n\nconst int MAX_V = 100000;\n\n//union-find tree defenition\n\nint par[MAX_V];\n\nvoid init(int n){\n    fill(par, par+n, -1);\n}\n\nint find(int x){\n    if(par[x] < 0) return x;\n    return par[x] = find(par[x]);\n}\n\nbool same(int a, int b){\n    return find(a) == find(b);\n}\n\nbool unite(int a, int b){\n    int xa = find(a), xb = find(b);\n    if(xa == xb) return false;\n    if(par[xa] < par[xb]){\n        par[xb] = xa;\n    }else{\n        if(par[xa] == par[xb]){\n            par[xb]--;\n        }\n        par[xa] = xb;\n    }\n    return true;\n}\n\n//END union-find tree definition\n\nstruct edge{\n    int from;\n    int to;\n    int cost;\n    edge(){}\n    ~edge(){}\n    edge(int a, int b, int c) : from(a), to(b), cost(c){}\n    bool operator < (const edge& r) const {\n        return cost < r.cost;\n    }\n};\n\nvector<edge> G;\nint V;\n\nvoid append_edge(int from, int to, int cost){\n    G.push_back(edge(from, to, cost));\n}\n\nint kruskal(void){\n    init(V);\n    sort(G.begin(), G.end());\n    int ret = 0;\n    for(int i = 0; i < G.size(); i++){\n        if(unite(G[i].from, G[i].to)){\n            ret += G[i].cost;\n        }\n    }\n    return ret;\n}\n\nint main(){\n    int m, a, b, c;\n    while(scanf(\"%d%d\", &V, &m) && V){\n        G.clear();\n        for(int x = 0; x < m; x++){\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            append_edge(a, b, c / 100 - 1);\n        }\n        int res = kruskal();\n        printf(\"%d\\n\", res);\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <queue>\n#include <algorithm>\n\nusing namespace std;\n\n#define REP(i,n) for(int i=0;i<(int)n;++i)\n#define FOR(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define ALL(c) (c).begin(), (c).end()\n\ntypedef int Weight;\nconst int INF = 1e9;\nstruct Edge {\n    int src, dst;\n    Weight weight;\n    Edge(int src, int dst, Weight weight) :\n        src(src), dst(dst), weight(weight) { }\n};\n\nbool operator < (const Edge &e, const Edge &f) {\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!!\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nvoid shortestPath(const Graph &g, int s,\n                  vector<Weight> &dist, vector<int> &prev) {\n    int n = g.size();\n    dist.assign(n, INF); dist[s] = 0;\n    prev.assign(n, -1);\n    priority_queue<Edge> Q; // \"e < f\" <=> \"e.weight > f.weight\"\n    for (Q.push(Edge(-2, s, 0)); !Q.empty(); ) {\n        Edge e = Q.top(); Q.pop();\n        if (prev[e.dst] != -1) continue;\n        prev[e.dst] = e.src;\n        FOR(f,g[e.dst]) {\n            if (dist[f->dst] > e.weight+f->weight) {\n                dist[f->dst] = e.weight+f->weight;\n                Q.push(Edge(f->src, f->dst, e.weight+f->weight));\n            }\n        }\n    }\n}\n\nvector<int> buildPath(const vector<int> &prev, int t) {\n    vector<int> path;\n    for (int u = t; u >= 0; u = prev[u])\n        path.push_back(u);\n    reverse(path.begin(), path.end());\n    return path;\n}\n\nint main()\n{\n    int n, m;\n    char ch;\n\n    while (cin >> n, n) {\n        Graph g(n);\n        vector<Weight> d;\n        vector<int> prev, path;\n        cin >> m;\n\n        for (int i = 0; i < m; i++) {\n            int u, v, w;\n\n            cin >> u >> ch >> v >> ch >> w;\n            w = w / 100 - 1;\n            g[u].push_back(Edge(u, v, w));\n            g[v].push_back(Edge(v, u, w));\n        }\n        shortestPath(g, 0, d, prev);\n        path = buildPath(prev, n - 1);\n\n        cout << d[n - 1] + path.size() + 2 << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <stdio.h>\n\n\nusing namespace std;\n\nstring bom[8];\n\nclass Graph{\npublic:\n    int a;\n    int b;\n    int ab;\n};\n\n\nbool asc( const Graph& left, const Graph& right ) {\n    return left.ab<right.ab;\n}\n\n\n\n\nint main(void) {\n    Graph gr[100];\n    \n    while(1){\n        int n,m;\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        for(int i=0; i<m; i++){\n            scanf(\"%d,%d,%d\",&gr[i].a,&gr[i].b,&gr[i].ab);\n            if(gr[i].a>gr[i].b)swap(gr[i].a,gr[i].b);\n            //cin>>gr[i].a>>gr[i].b>>gr[i].ab;\n        }\n        sort(gr, gr+m, asc);\n        /*for(int i=0; i<m; i++){\n            cout<<gr[i].a<<\" \"<<gr[i].b<<\" \"<<gr[i].ab<<endl;\n        }*/\n        int check[100]={0};\n        int dist=0;\n        check[gr[0].a]++;\n        check[gr[0].b]++;\n        dist+=gr[0].ab-200;\n        while(1){\n            int count=0;\n            for(int i=0; i<m; i++)count+=check[i];\n            if(count==m)break;\n            for(int i=0; i<m; i++){\n                if(check[gr[i].a]==1&&check[gr[i].b]==1);\n                else if(check[gr[i].a]==1){\n                    check[gr[i].b]++;\n                    dist+=gr[i].ab;\n                    break;\n                }else if(check[gr[i].b]==1){\n                    check[gr[i].a]++;\n                    dist+=gr[i].ab-100;\n                    break;\n                }\n            }\n        }\n        cout<<dist/100<<endl;\n        \n        \n        \n    }\n    \n    \n    \n    \n    \n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef long double ld;\nusing P   = pair<ll, ll>;\nusing mat = vector<vector<ll>>;\ntypedef string::const_iterator State;\nclass ParseError {};\n\nvoid IOS() { ios::sync_with_stdio(false), cin.tie(0); }\n\nconst ll INF = 1e16;\nconst ll MOD = 1e9 + 7;\nconst ld EPS = 1e-12;\n\ntemplate <typename T>\nvoid dump(T x) { cout << x << endl; }\nvoid dumpf(ld x, int t) { cout << setprecision(t) << fixed << x << endl; }\ntemplate <typename A, size_t N, typename T>\nvoid Fill(A (&array)[N], const T &val) {\n\tfill((T *)array, (T *)(array + N), val);\n}\ninline ll mod(ll a, ll b) {\n\tif (a > 0) return a % b;\n\tif (a % b == 0) return 0;\n\tll x = -a / b + 1;\n\ta += x * b;\n\treturn a % b;\n}\nll powm(ll a, ll b, ll c) {\n\tif (b == 0)\n\t\treturn 1;\n\telse if (b % 2 == 0) {\n\t\tll d = powm(a, b / 2, c);\n\t\treturn (d * d) % c;\n\t} else\n\t\treturn (a * powm(a, b - 1, c)) % c;\n}\nll gcd(ll a, ll b) {\n\tif (b == 0) return a;\n\treturn gcd(b, a % b);\n}\nll lcm(ll a, ll b) { return a / gcd(a, b) * b; }\n//ll dx[4] = {1, 0, -1, 0};\n//ll dy[4] = {0, 1, 0, -1};\n\nstruct UnionFind {\n  private:\n\tstd::vector<int> rank, par, col;\n\tint n_;\n\n  public:\n\tUnionFind(int n) : n_(n) {\n\t\trank.resize(n, 1);\n\t\tpar.resize(n);\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tpar[i] = i;\n\t\t}\n\t\tcol.resize(n, 1);\n\t}\n\tint root(int i) {\n\t\twhile (par[i] != i) {\n\t\t\ti = par[i];\n\t\t}\n\t\treturn i;\n\t}\n\tbool isSame(int x, int y) { return root(x) == root(y); }\n\tvoid unite(int x, int y) {\n\t\tif (isSame(x, y)) return;\n\t\tx = root(x), y = root(y);\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t\tcol[y] += col[x];\n\t\t} else {\n\t\t\tif (rank[x] == rank[y]) rank[x]++;\n\t\t\tpar[y] = x;\n\t\t\tcol[x] += col[y];\n\t\t}\n\t}\n\tint cnt(int x) {\n\t\tx = root(x);\n\t\treturn col[x];\n\t}\n};\n\nusing T = tuple<ll, ll, ll>;\n\nint main() {\n\tll n, m;\n\twhile (1) {\n\t\tscanf(\"%lld\", &n);\n\t\tif (n == 0) break;\n\t\tscanf(\"%lld\", &m);\n\t\tvector<T> e(m);\n\t\tUnionFind uf(n + 1);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tll a, b, d;\n\t\t\tscanf(\"%lld,%lld,%lld\", &a, &b, &d);\n\t\t\td\t= d / 100 - 1;\n\t\t\te[i] = make_tuple(d, a, b);\n\t\t}\n\t\tsort(e.begin(), e.end());\n\t\tll ans = 0;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tll d, a, b;\n\t\t\ttie(d, a, b) = e[i];\n\t\t\tif (!uf.isSame(a, b)) {\n\t\t\t\tuf.unite(a, b);\n\t\t\t\tans += d;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%lld\\n\", ans);\n\t}\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w > e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\n//????°???¨?????¨\n//Prim O(ElogV)\n//r????????°?????????????????????????±?\n//Edge??? bool operator<(const Edge &e)const { return w > e.w; } ????????????????????????\npair<Weight, Edges> prim(const Graph &g, int r = 0) {\n\tEdges T; Weight total = 0; vector<int> vis(g.size());\n\tpriority_queue <Edge> q;\n\tq.emplace(-1, r, 0);\n\twhile (q.size()) {\n\t\tEdge e = q.top(); q.pop();\n\t\tif (vis[e.d]) continue;\n\t\tvis[e.d] = true;\n\t\ttotal += e.w; if (e.s != -1) T.emplace_back(e);\n\t\tfor (auto &f : g[e.d]) if (!vis[f.d]) q.emplace(f);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].emplace_back(Edge(a, b, d));\n\t\t\tg[b].emplace_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = prim(g, 0);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\nusing namespace std;\nstatic const int INFTY = (1 << 21);\nstatic const int MAX = 100;\t\t\t\t//史跡の数\nstatic const int WHITE = 0;\nstatic const int GRAY = 1;\nstatic const int BLACK = 2;\t\t\t\t\n\nint n, M[MAX][MAX];\n\nint prim() {\n\tint d[MAX], p[MAX], vmin, u, color[MAX];\n\tfor (int i = 0; i < n; i++) {\n\t\td[i] = INFTY;\n\t\tp[i] = -1;\n\t\tcolor[i] = WHITE;\n\t}\n\td[0] = 0;\n\twhile (true) {\n\t\tvmin = INFTY;\n\t\tu = -1;\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tif (d[i] < vmin && color[i] != BLACK) {\n\t\t\t\tvmin = d[i];\n\t\t\t\tu = i;\n\t\t\t}\n\t\t}\n\t\tif (u == -1) {\n\t\t\tbreak;\n\t\t}\n\t\tcolor[u] = BLACK;\n\t\tfor (int v = 0; v < n; v++) {\n\t\t\tif (M[u][v] != INFTY && color[v] != BLACK) {\n\t\t\t\tif (M[u][v] < d[v]) {\n\t\t\t\t\td[v] = M[u][v];\n\t\t\t\t\tp[v] = u;\n\t\t\t\t\tcolor[v] = GRAY;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\t}\n\tint sum = 0;\n\tfor (int i = 0; i < n; i++) {\n\t\tif (p[i] != -1) {\n\t\t\tsum += M[i][p[i]];\n\t\t}\n\t}\n\treturn sum;\n}\n\n\nint main() {\n\tint m;\n\twhile (true) {\n\t\tcin >> n;\n\t\tif (n == 0) {\n\t\t\tbreak;\n\t\t}\n\t\tcin >> m;\n\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tM[i][j] = INFTY;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint a, b, c;\n\t\t\tchar d, e;\n\t\t\tcin >> a >> d >> b >> e >> c;\n\t\t\tM[a][b] = c / 100 - 1;\n\t\t\tM[b][a] = c / 100 - 1;\n\t\t}\n\n\t\tcout << prim() << endl;\n\t}\n\treturn 0;\n\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\n//int Kruskal(Graph& g,Edges& e)\n//{\n//\te.clear();\n//\t\n//\tUnionFind uf(g.size());\n//\tset<Edge> s;\n//\trep(i,g.size())\n//\t\trep(j,g[i].size())\n//\t\t\ts.insert(g[i][j]);\n//\t\n//\tint res=0;\n//\tforeach(i,s){\n//\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n//\t\t\tuf.Union(i->src,i->dst);\n//\t\t\tres+=i->weight;\n//\t\t\te.push_back(*i);\n//\t\t}\n//\t}\n//\t\n//\treturn res;\n//}\n\nostream& operator<<(ostream& os,const vi& a)\n{\n\trep(i,a.size())\n\t\tprintf(\"%d%s\",a[i],i==a.size()-1?\"\":\" \");\n\treturn os;\n}\n\n//pair<Weight, Edges> minimumSpanningForest(const Graph &g) {\npair<int, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  //priority_queue<Edge> Q;\n  priority_queue<Edge,vector<Edge>,greater<Edge> > Q;\n  //rep(u, n) foreach(e, g[u]) if (u < e->dst) Q.push(*e);\n  rep(u, n) foreach(e, g[u]) Q.push(*e);\n  multiset<Edge> s;\n  rep(i,g.size())rep(j,g[i].size())s.insert(g[i][j]);\n  //puts(\"#s:\");\n  //foreach(i,s)\n  //  printf(\"%d %d %d\\n\",i->src,i->dst,i->weight);\n\n  //Weight total = 0;\n  int total = 0;\n  Edges F;\n  //while (F.size() < n-1 && !Q.empty()) {\n  //  Edge e = Q.top(); Q.pop();\n  foreach(i,s){\n    if(F.size()>=n)\n    \tbreak;\n    Edge e=*i;\n    //if (uf.unionSet(e.src, e.dst)) {\n    //  F.push_back(e);\n    //  total += e.weight;\n    //}\n\tif(uf.Find(e.src)!=uf.Find(e.dst)){\n\t\tuf.Union(e.src,e.dst);\n\t\tF.push_back(e);\n\t\ttotal+=e.weight;\n\t}\n  }\n  //puts(\"#F:\");\n  //rep(i,F.size())\n  //  printf(\"%d %d %d\\n\",F[i].src,F[i].dst,F[i].weight);  \n  //return pair<Weight, Edges>(total, F);\n  return pair<int, Edges>(total, F);\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\t//Edges e;\n\t\t//int sum=Kruskal(g,e);\n\t\t////cout<<sum/100-e.size()<<endl;\n\t\t//cout<<sum<<endl;\n\t\t\n\t\tcout<<minimumSpanningForest(g).first<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nint cost[101][101];\nint n,m;\nint mincost[101];\nbool used[101];\nint V;\n\nconst int INF=10000000;\n\nint prim(){\n\tfor(int i = 0; i < V; i++){\n\t\tmincost[i]=INF;\n\t\tused[i]=false;\n\t}\n\tmincost[0]=0;\n\tint res=0;\n\n\twhile(1){\n\t\tint v=-1;\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tif(!used[u]&&(v==-1||mincost[u]<mincost[v]))\n\t\t\t\tv=u;\n\t\t}\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\tfor(int u = 0; u < V; u++){\n\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\n\twhile(cin>>n&&n!=0){\n\t\tcin>>m;\n\t\tfor(int i = 0; i < n; i++)\n\t\t\tfor(int j = 0; j < n; j++)\n\t\t\t\tcost[i][j]=INF;\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tint from,to,ct;\n\t\t\tchar c;\n\t\t\tcin>>from>>c>>to>>c>>ct;\n\t\t\tct-=100;\n\t\t\tcost[from][to]=ct;\n\t\t\tcost[to][from]=ct;\n\t\t}\n\t\tV=n;\n\t\tcout<<prim()/100<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "//kruskal tree\n#include <cstdio>\n#include <algorithm>\nusing namespace std;\n#define M 999\nint parent[M],a[M],b[M];\npair<int,int>node[M];\nint root(int a){return parent[a]==a?a:parent[a]=root(parent[a]);}\nint unite(int a,int b){\n\tint x=root(a),y=root(b);\n\tif(x==y)return 0;\n\tparent[x]=y;\n\treturn 1;\n}\nint main(){\n\tint i,s,n,m;\n\tfor(;scanf(\"%d%d\",&n,&m)>1;printf(\"%d\\n\",s/100-n+1)){\n\t\tfor(i=0;i<m;i++)scanf(\"%d,%d,%d\",a+i,b+i,&node[i].first),node[i].second=i;\n\t\tsort(node,node+m);\n\t\tfor(i=0;i<n;i++)parent[i]=i;\n\t\tfor(s=i=0;i<m;i++)if(unite(a[node[i].second],b[node[i].second]))s+=node[i].first;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#define X 1111\n#define INF 1<<30\nusing namespace std;\nint n,m;\nint purimu(int cost[][X]);\nint main(){\n  int a,b,c;\n  int ans=0;\n  int cost[X][X];\n  cin >> n >> m;\n  for(int i=0;i<n;i++){\n    for(int j=0;j<n;j++){\n      cost[i][j]=INF;\n    }\n  } \n  for(int i=0;i<m;i++){\n    scanf(\"%d,%d,%d\",&a,&b,&c);\n    cost[a][b]=c/100-1;\n  }\n  ans=purimu(cost);\n  cout << ans << endl;\n}\n\nint purimu(int cost[][X]){\n  int mincost[X];\n  bool used[X];\n  for(int i=0;i<n;i++){\n    mincost[i]=INF;//min関数での回避\n    used[i]=false;//まだいっていないところ用\n  }\n  mincost[0]=0;//出発点のコストは0\n  int res=0;\n  while(1){\n    int v=-1;//最初のために\n    for(int i=0;i<n;i++){\n      if(!used[i] && (v==-1 || mincost[i]<mincost[v])){//まだそこの町に行けない\n\tv=i;\n      } \n    }\n    if(v==-1)break;//全部見終わった\n    used[v]=true;\n    res+=mincost[v];\n    for(int i=0;i<n;i++){\n      mincost[i]=min(mincost[i],cost[v][i]);\n    }\n  }\n  return res;\n}\n\t\n    "
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\n#define INF INT_MAX\n#define ll long long\n#define REP(i,n) for(int i=0;i<n;i++)\n\nusing namespace std;\n\nclass Node{\npublic:\n\tint index;\n\tbool used;\t//????°???¨?????¨????????????????????????\n\tvector< pair<Node*,int> > road;\t//first:?????°???????????????second:?????°?????????????????????\n};\n\nint main(){\n\tcin.tie(0);\n    ios::sync_with_stdio(false);\n\n\tint n,m;\t//n:???????????°,m:??????????£?????????¶????????¬??°\n\twhile(scanf(\"%d %d\",&n,&m)  != EOF && n != 0){\n\t\tvector<Node> x;\t\t//????°???¨?????¨(MST)\n\t\tvector<Node> t(n);\t//??°????????¨???\n\t\tREP(i,n){t[i].index = i;t[i].used = false;}\t//??????????????????????????£?????????\n\t\tint cost,a,b;\n\t\tREP(i,m){\n\t\t\t//cin >> a >> b >> cost;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&cost);\n\t\t\tt[a].road.push_back(make_pair(&t[b],cost));\n\t\t\tt[b].road.push_back(make_pair(&t[a],cost));\n\t\t}\n\t\t//???????????????????????????????????????a?????????MST???\n\t\tt[0].used = true;\n\t\tx.push_back(t[0]);\n\t\t//MST????????°?????¨?????????????????°n??????????????§??°?????????\n\t\tint ans = 0;\n\t\twhile(x.size() < n){\n\t\t\tint min_cost = INF;\n\t\t\tNode* min_node;\n\t\t\t//?????¨???MST????????????MST??\\???????????????????????°??????????°???????????????¨???????????¢???\n\t\t\tREP(i,x.size()){\n\t\t\t\t//?????????i???????????°????????¨??????????????????????°????????????????????????¢???\n\t\t\t\tREP(j,x[i].road.size()){\n\t\t\t\t\tif(x[i].road[j].first->used)continue;\t//??????MST??????????????????????????´???\n\t\t\t\t\tif(min_cost > x[i].road[j].second){\n\t\t\t\t\t\tmin_node = x[i].road[j].first;\n\t\t\t\t\t\tmin_cost = x[i].road[j].second;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tmin_node->used = true;\n\t\t\tx.push_back(*min_node);\t//????°???????????????¨???????????????????????????MST?????????\n\t\t\tans += min_cost / 100 - 1;\n\t\t}\n\t\tcout << ans << endl;\n\t\t\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define INF 1e6\nusing namespace std;\n\nint main(){\n\tint n,m,a,b,d;\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>m;\n\t\tint dist[n][n],dp[n][n];\n\t\trep(i,n)rep(j,n)dist[i][j]=dp[i][j]=(i==j?0:INF);\n\t\trep(i,m){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tdist[a][b]=dist[b][a]=d/100-1;\n\t\t}\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint num=INF;\n\t\trep(i,n){\n\t\t\tint sum=0;\n\t\t\trep(j,n)sum+=dp[i][j];\n\t\t\tif(sum<num)num=sum;\n\t\t}\n\t\tcout<<num<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<vector>\n#include<utility>\n#include<algorithm>\nusing namespace std;\nint main(){\n\tfor(;;){\n\t\tint n,m,sum = 0;\n\t\tcin >>n;\n\t\tif(!n){break;}\n\t\tcin >>m;\n\t\tvector<pair<int, pair<int,int> > > edge;\n\t\tbool done[100] = {false};\n\t\tfor(int i=0; i<m ;i++){\n\t\t\tint a,b,cost;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&cost);\n\t\t\tedge.push_back(make_pair(cost,make_pair(a,b)));\n\t\t}\n\t\tsort(edge.begin(),edge.end());\n\t\tdone[edge[0].second.first] = true;\n\t\tdone[edge[0].second.second] = true;\n\t\tsum += edge[0].first/100;\n\t\tif(!(edge[0].first%100)){sum--;}\n\t\tfor(int i=0; i<n-1; i++){\n\t\t\tfor(int k=0; k<m; k++){\n\t\t\t\tif(done[edge[k].second.first]^done[edge[k].second.second]){\n\t\t\t\t\tsum += edge[k].first/100;\n\t\t\t\t\tif(!(edge[k].first%100)){sum--;}\n\t\t\t\t\tdone[edge[k].second.first] = true;\n\t\t\t\t\tdone[edge[k].second.second] = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcout<<sum<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#define _USE_MATH_DEFINES\n#include <iostream>\n#include <sstream>\n#include <cmath>\n#include <algorithm>\n#include <queue>\n#include <stack>\n#include <limits>\n#include <map>\n#include <string>\n#include <cstring>\n#include <set>\n#include <deque>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<int,int> P;\n\nstatic const int INF = 100000000;\n\nint main(){\n\tint n,m;\n\twhile(~scanf(\"%d\",&n)){\n\t\tif(n==0) break;\n\n\t\tint* mincost = new int[n];\n\t\tbool* used = new bool[n];\n\n\t\tfill((bool*)used,(bool*)used + n,false);\n\t\tfill((int*)mincost,(int*)mincost + n,INF);\n\n\n\t\tint** cost = new int*[n];\n\t\tfor(int i=0;i<n;i++){\n\t\t\tcost[i] = new int[n];\n\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\n\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint from,to,dist;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&dist);\n\t\t\tcost[from][to] = min(cost[from][to],dist / 100 - 1);\n\t\t}\n\n\t\tmincost[0]=0;\n\n\t\tint res=0;\n\t\twhile(1){\n\t\t\tint v=-1;\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tif(!used[i] && (v==-1 || mincost[i] < mincost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1) break;\n\t\t\tused[v] = true;\t\t\n\t\t\t\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tmincost[v] = min(mincost[v],cost[i][v]);\n\t\t\t}\n\t\t\t\n\t\t\tres+=mincost[v];\n\t\t}\n\n\t\tcout << res << endl;\n\n\t\tfor(int i=0;i<n;i++){\n\t\t\tdelete[] cost[i];\n\t\t}\n\n\t\tdelete[] cost;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <climits>\nusing namespace std;\n\n#define SAFE_DELETE( x ) { if ( x ){ delete x; x = NULL; } }\n\nstruct tCell{\n\ttCell() : x( 0 ), prev( NULL ), next( NULL ){}\n\tint x;\n\ttCell *prev, *next;\n};\n\n\nclass MyArray{\npublic:\n\tMyArray() : mSize( 0 ), head( NULL ), tail( NULL ){\n\t\thead = new tCell;\n\t\ttail = new tCell;\n\t\thead->next = tail;\n\t\ttail->prev = head;\n\t}\n\t~MyArray(){\n\t\tinit();\n\t\tSAFE_DELETE( head );\n\t\tSAFE_DELETE( tail );\n\t}\n\n\tvoid init(){\n\t\tfor ( int i = mSize; i > 0; --i ){\n\t\t\ttCell* it = tail->prev;\n\t\t\tit->prev->next = it->next;\n\t\t\tit->next->prev = it->prev;\n\t\t\tSAFE_DELETE( it );\n\t\t}\n\t\tmSize = 0;\n\t}\n\n\tvoid pushBack( int x ){\n\t\ttCell* it = new tCell;\n\t\tit->x = x;\n\t\tit->prev = tail->prev;\n\t\tit->next = tail;\n\t\tit->prev->next = it;\n\t\tit->next->prev = it;\n\t\t++mSize;\n\t}\n\tvoid pushAsc( int x ){\n\t\t\n\t}\n\tint size(){ return mSize; }\n\n\ttCell operator[]( int index ){\n\t\ttCell* it = head->next;\n\t\tfor ( int i = 0; i < index; ++i ){\n\t\t\tit = it->next;\n\t\t}\n\t\treturn *it;\n\t}\n\nprivate:\n\tint mSize;\n\ttCell *head, *tail;\n};\n\nstruct tData{\n\ttData() : done( false ){}\n\n\tbool done;\n\tMyArray to;\n\tMyArray dis;\n};\n\n\nclass Route{\npublic:\n\tRoute( int m ) : list( NULL ), mSize( m ){\n\t\tlist = new tData[ mSize ];\n\t}\n\t~Route(){\n\t\tdelete[] list;\n\t}\n\n\tint calc(){\n\t\tbool end;\n\t\tint ret = 0;\n\t\tlist[ 0 ].done = true;\n\t\tdo{\n\t\t\tend = true;\n\t\t\tint nextTo, nextDis = INT_MAX;\n\t\t\tfor ( int i = 0; i < mSize; ++i ){\n\t\t\t\tif ( list[ i ].done ){\n\t\t\t\t\tfor ( int j = 0; j < list[ i ].to.size(); ++j ){\n\t\t\t\t\t\tint to = list[ i ].to[ j ].x;\n\t\t\t\t\t\tif ( !list[ to ].done && list[ i ].dis[ j ].x < nextDis ){\n\t\t\t\t\t\t\tnextTo = to;\n\t\t\t\t\t\t\tnextDis = list[ i ].dis[ j ].x;\n\t\t\t\t\t\t\tend = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( !end ){\n\t\t\t\tret += nextDis / 100 - 1;\n\t\t\t\tlist[ nextTo ].done = true;\n\t\t\t}\n\t\t}while ( !end );\n\n\t\treturn ret;\n\t}\n\n\tint mSize;\n\ttData* list;\n};\n\nint main(){\n\tint n, m, p1, p2, d;\n\tchar c;\n\n\twhile ( cin >> n && n ){\n\t\tRoute* route = new Route( n );\n\t\tcin >> m;\n\t\tfor ( int i = 0; i < m; ++i ){\n\t\t\tcin >> p1 >> c >> p2 >> c >> d;\n\t\t\troute->list[ p1 ].to.pushBack( p2 );\n\t\t\troute->list[ p1 ].dis.pushBack( d );\n\t\t\troute->list[ p2 ].to.pushBack( p1 );\n\t\t\troute->list[ p2 ].dis.pushBack( d );\n\t\t}\n\n\t\tcout << route->calc() << endl;\n\n\n\t\tSAFE_DELETE( route );\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define FORALL(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FOREACH(i,c) for(auto (i) : (c))\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cout<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\n\ntypedef int Weight;\nstruct Edge\n{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nbool operator < (const Edge &e, const Edge &f)\n{\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!! ???????????????????????????\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0)\n{\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push(Edge(-1,r,0));\n  while (!Q.empty())\n  {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    for(auto f: g[e.dst]) if(!visited[f.dst]) Q.push(f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n  {\n    Graph g(n);\n    int m; cin >> m;\n    REP(i,m)\n    {\n      int s,d,w;scanf(\"%d,%d,%d\\n\",&s,&d,&w);\n      g[s].push_back(Edge(s,d,w/100-1));\n    }\n    cout << minimumSpanningTree(g).first << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\n//int Kruskal(Graph& g,Edges& e)\n//{\n//\te.clear();\n//\t\n//\tUnionFind uf(g.size());\n//\tset<Edge> s;\n//\trep(i,g.size())\n//\t\trep(j,g[i].size())\n//\t\t\ts.insert(g[i][j]);\n//\t\n//\tint res=0;\n//\tforeach(i,s){\n//\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n//\t\t\tuf.Union(i->src,i->dst);\n//\t\t\tres+=i->weight;\n//\t\t\te.push_back(*i);\n//\t\t}\n//\t}\n//\t\n//\treturn res;\n//}\n\n//pair<Weight, Edges> minimumSpanningForest(const Graph &g) {\npair<int, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  //priority_queue<Edge> Q;\n  //priority_queue<Edge,vector<Edge>,greater<Edge> > Q;\n  //rep(u, n) foreach(e, g[u]) if (u < e->dst) Q.push(*e);\n  set<Edge> s;\n  rep(i,g.size())rep(j,g[i].size())s.insert(g[i][j]);\n\n  //Weight total = 0;\n  int total = 0;\n  Edges F;\n  //while (F.size() < n-1 && !Q.empty()) {\n  //  Edge e = Q.top(); Q.pop();\n  foreach(i,s){\n\t  Edge e=*i;\n    //if (uf.unionSet(e.src, e.dst)) {\n    //  F.push_back(e);\n    //  total += e.weight;\n    //}\n\tif(uf.Find(e.src)!=uf.Find(e.dst)){\n\t\tuf.Union(e.src,e.dst);\n\t\tF.push_back(e);\n\t\ttotal+=e.weight;\n\t}\n  }\n  //return pair<Weight, Edges>(total, F);\n  return pair<int, Edges>(total, F);\n}\n\nostream& operator<<(ostream& os,const vi& a)\n{\n\trep(i,a.size())\n\t\tprintf(\"%d%s\",a[i],i==a.size()-1?\"\":\" \");\n\treturn os;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\t//Edges e;\n\t\t//int sum=Kruskal(g,e);\n\t\t////cout<<sum/100-e.size()<<endl;\n\t\t//cout<<sum<<endl;\n\t\t\n\t\tcout<<minimumSpanningForest(g).first<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\n#define REP(i, n) for(int i = 0; i < int(n); i++)\n#define FOR(i,n,m) for(int i = int(n); i < int(m); i++)\nusing namespace std;\ntypedef long long ll;\nconst int MOD = 1e9 + 7;\nconst int INF = 1e9 + 6;\nconst ll LLINF = 1e18 + 1;\n\n// 最小全域木 O(ElogV)?\n// verify : https://onlinejudge.u-aizu.ac.jp/problems/GRL_2_A\ntemplate<typename T>\nstruct Prim {\nprivate:\n    struct Edge {\n        T cost;\n        int to;\n        bool operator>(const Edge e)const {\n            return this->cost > e.cost;\n        }\n        bool operator<(const Edge e)const {\n            return this->cost < e.cost;\n        }\n    };\n    int V; // 頂点数\n    vector<vector<Edge>> G;\npublic:\n    Prim(int V) : V(V) {\n        G.resize(V);\n    }\n\n    void add_edge(int from, int to, T weight) {\n        G[from].push_back({weight,to});\n        G[to].push_back({weight,from});\n    }\n\n    T build() {\n        T res = 0;\n        vector<bool> used(V, false);\n        priority_queue<Edge, vector<Edge>, greater<Edge>> pq;\n        for (const Edge &e : G[0]) {\n            pq.push(e);\n        }\n        used[0] = true;\n        while (!pq.empty()) {\n            Edge e = pq.top(); pq.pop();\n            if (used[e.to]) continue;\n            used[e.to] = true;\n            res += e.cost;\n            for (const Edge &u : G[e.to]) {\n                if (used[u.to]) continue;\n                pq.push(u);\n            }\n        }\n        return res;\n    }\n};\n\nint main() {\n    while (true) {\n        int n, m; cin >> n;\n        if (n == 0) break;\n        cin >> m;\n        Prim<ll> G(n);\n        REP(i, m) {\n            int a, b; ll c;\n            char p;\n            scanf(\"%d%c%d%c%lld\", &a, &p, &b, &p, &c);\n            G.add_edge(a, b, c / 100);\n        }\n        cout << G.build() - (n - 1) << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\nusing namespace std;\nint G[102][102];\nint NG[102][102];\nbool used[102];\nconst int INF=9999999;\nint main(){\n\tint n,m,ans=0;\n\twhile(true){\n\tcin>>n;\n\tif(n==0)break;\n\tcin>>m;\n\tans=0;\n\tfor(int i=0;i<102;i++)for(int j=0;j<102;j++)G[i][j]=INF,used[i]=false,NG[i][j]=INF;\n\tfor(int i=0;i<n;i++){\n\t\tint a,b,c;\n\t\tchar x;\n\t\tcin>>a>>x>>b>>x>>c;\n\t\tG[a][b]=c;\n\t}\n\tint u,v,a,b;\n\tused[0]=1;\n\tfor(int i=0;i<n;i++){\n\t\tv=-1;\n\t\tfor(int j=0;j<n;j++)if(!used[j])v=1;\n\t\tif(v==-1)break;\n\t\tint mi=INF;\n\t\tfor(int j=0;j<n;j++){\n\t\t\tfor(int k=0;k<n;k++){\n\t\t\tif(mi>G[j][k]&&used[j]==1&&used[k]==0)mi=G[j][k],a=j,b=k;\n\t\t\t}\n\t\t}\n\t\tused[b]=1;\n\t\t//cout<<a<<\" \"<<b<<endl;\n\t\t//for(int i=0;i<n;i++)cout<<used[i]<<\" \";cout<<endl;\n\t\tNG[a][b]=G[a][b];\n\t\tans+=G[a][b]-100;\n\t}\n//for(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<G[i][j]<<\" \";cout<<endl;}\n//\tfor(int i=0;i<n;i++){for(int j=0;j<n;j++)cout<<NG[i][j]<<\" \";cout<<endl;}\n\t//for(int i=0;i<n;i++)for(int j=0;j<n;j++)ans+=NG[i][j];\n\tcout<<ans/100<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n//#define int long long\n#define DEBUG 0\n#define rep(i,a,b) for(int i=(a);i<(b);i++)\n#define rrep(i,a,b) for(int i=(b)-1;i>=(a);i--)\n#define all(a) (a).begin(),(a).end()\n#define dump(o) if(DEBUG){cerr<<#o<<\" \"<<o<<endl;}\n#define dumpc(o) if(DEBUG){cerr<<#o; for(auto &e:(o))cerr<<\" \"<<e;cerr<<endl;}\nusing ll = long long; using ull = unsigned long long; using pii = pair<int, int>;\nstatic const int INF = 0x3f3f3f3f; static const long long INFL = 0x3f3f3f3f3f3f3f3fLL;\nstatic const int MOD = 1e9 + 7;\n\n\n//dx[i],dy[i]???i?????????????§???????????????¢???\n//  3\n// 2 0\n//  1\t\nint dx[] = { 1,0,-1,0 };\nint dy[] = { 0,1,0,-1 };\n\nint X, Y;\n\n//xy??§?¨???§?????±???????????¢?´¢\nvoid dfs(int x, int y) {\n\t/* ?????? */\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\t//?§????4???????????¢?´¢\n\tfor (int i = 0; i < 4; i++) {\n\t\tint nx = x + dx[i], ny = y + dy[i];\n\t\tif (0 <= nx&&nx < X && 0 <= ny&&ny < Y) {\n\t\t\tdfs(nx, ny);\n\t\t}\n\t}\n}\n\n//xy??§?¨???§??????????????¢?´¢\n//???????????¢\nint bfs(int sx, int sy, int gx, int gy) {\n\tconst int MAX = 1; //????????´???\n\tqueue<pii> Q;\n\tQ.push(pii(sx, sy));\n\t//???????????¢\n\tint d[MAX][MAX];\n\tmemset(d, 0x3f, sizeof(d));\n\td[sx][sy] = 0;\n\t//?§????4?????????????????????\n\tint dx[4] = { 1,0,-1,0 };\n\tint dy[4] = { 0,1,0,-1 };\n\tfor (pii u; !Q.empty();) {\n\t\tu = Q.front(); Q.pop();\n\t\tif (u == pii(gx, gy))break; //??´??????????????¢?´¢????????????\n\t\tfor (int i = 0; i < 4; i++) {//?§????4???????????¢?´¢\n\t\t\tint nx = u.first + dx[i], ny = u.second + dy[i];\n\t\t\tif (0 <= nx&&nx < X && 0 <= ny&&ny < Y) {\n\t\t\t\tif (d[nx][ny] != INF)continue; //??¢?´¢???????£???°???\n\t\t\t\td[nx][ny] = d[u.first][u.second] + 1;\n\t\t\t\tQ.push(pii(nx, ny));\n\t\t\t}\n\t\t}\n\t}\n\treturn d[gx][gy];\n}\n\n//??¶?´?????????£???????????? int:INF ll:INFL\n#define INFG INFL\nusing Weight = ll;//int;\n\nclass Edge {\npublic:\n\tint s; //source\n\tint d; //destination\n\tWeight w; //weight\n\tEdge(int s = 0, int d = 0, Weight w = INFG) : s(s), d(d), w(w) {};\n\tbool operator<(const Edge &e)const { return w < e.w; }\n};\nusing Edges = vector<Edge>;\n//???????????\\: g[u].push_back(Edge(u, v, c));\n//????????¨???????????????????????°??????????????\\?????????????????????\nusing Graph = vector<Edges>;\nusing Array = vector<Weight>;\nusing Matrix = vector<Array>;\n\n//?????¢?´¢, ??¢?´¢???, ??¢?´¢???\nenum { WHITE, GRAY, BLACK };\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Dijkstra O( |E|log|V| )\n//dist: ?§????????????????????????§??????????????¢\n//?????????: ???????????¨????????????(??????-1)\nvector<int> dijkstra(const Graph &g, int s, vector<Weight> &dist) {\n\ttypedef tuple<Weight, int, int> State; //?§?????????????????°?????????? ??? ???\n\tpriority_queue<State, vector<State>, greater<State> >PQ;\n\tint n = g.size();\n\tvector<int> color(n, WHITE);\n\tvector<int> prev(n, -1);\n\tdist.assign(n, INFG); //distance\n\tdist[s] = 0; PQ.push(State(0, s, -1)); color[s] = GRAY; //?§????\n\twhile (!PQ.empty()) {\n\t\tWeight d; int v; int u;\n\t\ttie(d, v, u) = PQ.top(); PQ.pop(); //dist???????°??????¨??????????´????????????????\n\t\tif (dist[v] < d) continue; //?????§???????????§???????????°??????\n\t\tcolor[v] = BLACK;\n\t\tprev[v] = u;\n\t\tfor (auto &e : g[v]) { //??£??\\????????????????????¨????????????\t\t\n\t\t\tif (color[e.d] == BLACK)continue; //??¢?´¢????????????\n\t\t\tif (dist[e.d] > dist[v] + e.w) {\n\t\t\t\tdist[e.d] = dist[v] + e.w;\n\t\t\t\tPQ.push(State(dist[e.d], e.d, v));\n\t\t\t\tcolor[e.d] = GRAY;\n\t\t\t}\n\t\t}\n\t}\n\treturn prev;\n}\n\n//???????§?????????????(???????????????) Single Source Shortest Path\n//Bellman Ford O(|V||E|)\n//dist: ?§????????????????????????§??????????????¢\n//prev: ???????????¨????????????\n//?????????: ???????????????:true ??????:false\nbool bellmanFord(const Graph &g, int s, vector<Weight> &dist, vector<int> &prev) {\n\tint n = g.size();\n\tEdges es; for (int i = 0; i < n; i++) for (auto &e : g[i]) es.emplace_back(e);\n\tdist.assign(n, INFG); dist[s] = 0;\n\tprev.assign(n, -1);\n\tbool negative_cycle = false;\n\tfor (int i = 0;; i++) {\n\t\tbool update = false;\n\t\tfor (auto &e : es) {\n\t\t\tif (dist[e.s] != INFG && dist[e.d] > dist[e.s] + e.w) {\n\t\t\t\tdist[e.d] = dist[e.s] + e.w;\n\t\t\t\tprev[e.d] = e.s;\n\t\t\t\tupdate = true;\n\t\t\t}\n\t\t}\n\t\tif (!update) break;\n\t\tif (i > n) { negative_cycle = true; break; }\n\t}\n\treturn !negative_cycle;\n}\n\n//?§?????????????????????§??????????????????\n//???????????????????????°?????????????§??????????????????§?????????????????¢????????????\nvector<int> getPath(int s, int g, vector<int> prev) {\n\tvector<int> path;\n\tpath.push_back(g);\n\tfor (int i = g; i != s; ) path.push_back(i = prev[i]);\n\treverse(path.begin(), path.end());\n\treturn path;\n}\n\n//??¨????????????????????? All Pairs Shortest Path\n//Warshall Floyd O(|V|^3)\n//?????????: ???????????????:true ??????:false\nbool warshallFloyd(const Graph &g, Matrix &dist) {\n\tbool negative_cycle = false;\n\tint n = g.size();\n\tdist.assign(n, Array(n, INFG));\n\tfor (int i = 0; i < n; i++) dist[i][i] = 0;\n\tfor (int i = 0; i < n; i++)\n\t\tfor (auto e : g[i])\n\t\t\tdist[e.s][e.d] = min(dist[e.s][e.d], e.w);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tfor (int k = 0; k < n; k++)\n\t\t\t\tif (dist[j][i] != INFG&&dist[i][k] != INFG)\n\t\t\t\t\tdist[j][k] = min(dist[j][k], dist[j][i] + dist[i][k]);\n\tfor (int i = 0; i < n; i++)\n\t\tif (dist[i][i] != 0)\n\t\t\tnegative_cycle = true;\n\treturn !negative_cycle;\n}\n\n//???????????????\nvoid printPath(vector<int> path) {\n\tcout << \"Path: \";\n\tfor (auto p : path) cout << p << \" \";\n\tcout << endl;\n}\n\n//???????????????????????????\n//??\\?¬???°???0????????¨???????????????????????????ret????????£??????\nvector<int> topologicalSort(const Graph &g) {\n\tint n = g.size(), k = 0;\n\tvector<int> ord(n), indeg(n); //??\\?¬???°\n\tfor (auto &es : g) for (auto &e : es) indeg[e.d]++;\n\tqueue<int> Q;\n\tfor (int i = 0; i < n; i++) if (indeg[i] == 0) Q.push(i);\n\twhile (!Q.empty()) {\n\t\tint v = Q.front(); Q.pop(); ord[k++] = v;\n\t\tfor (auto &e : g[v]) if (--indeg[e.d] == 0) Q.push(e.d);\n\t}\n\treturn *max_element(indeg.begin(), indeg.end()) == 0 ? ord : vector<int>();\n}\n\n//??¨?????´???\nEdge diameter(const Graph &g, int s = 0) {\n\tvector<Weight> dist;\n\tdijkstra(g, s, dist);\n\tint n = g.size(), u = -1, v = -1;\n\tfor (int i = 0; i < n; i++) if (dist[i] != INFG && (u == -1 || dist[i] > dist[u])) u = i;\n\tdijkstra(g, u, dist);\n\tfor (int i = 0; i < n; i++) if (dist[i] != INFG && (v == -1 || dist[i] > dist[v])) v = i;\n\tWeight d = dist[v];\n\tif (u > v) swap(u, v);\n\treturn Edge(u, v, d);\n}\n\n//?´?????????????????§????\n//Union-Find??¨\nstruct UnionFind {\n\tvector<int> p; //parent\n\tint s; //size ???????????°\n\tUnionFind(int n) :p(n, -1), s(n) {}\n\tbool unite(int x, int y) {\n\t\tx = root(x); y = root(y);\n\t\tif (x == y) return false;\n\t\tif (size(x) < size(y)) swap(x, y);\n\t\tp[x] += p[y]; p[y] = x; s--;\n\t\treturn true;\n\t}\n\tbool same(int x, int y) { return root(x) == root(y); }\n\tint root(int x) { return p[x] < 0 ? x : p[x] = root(p[x]); }\n\t//?????????????´???°\n\tint size(int x) { return -p[root(x)]; }\n};\n\n//????°???¨?????¨\n//Kruskal O(|E|log|E|)\npair<Weight, Edges> kruskal(const Graph &g) {\n\tUnionFind UF(g.size());\n\tEdges es;\n\tfor (int i = 0; i < g.size(); i++) for (auto &e : g[i]) es.emplace_back(e);\n\tsort(es.begin(), es.end());\n\tWeight total = 0;\n\tEdges T;\n\tfor (auto &e : es) if (!UF.same(e.s, e.d)) {\n\t\tT.push_back(e); total += e.w; UF.unite(e.s, e.d);\n\t}\n\treturn make_pair(total, T);\n}\n\nsigned main() {\n\tfor (int n; cin >> n&&n;) {\n\t\tint m; cin >> m;\n\t\tGraph g(n);\n\t\trep(i, 0, n) {\n\t\t\tchar c;\n\t\t\tint a, b, d; cin >> a >> c >> b >> c >> d;\n\t\t\tg[a].emplace_back(Edge(a, b, d));\n\t\t\tg[b].emplace_back(Edge(b, a, d));\n\t\t}\n\t\tpair<Weight, Edges> k = kruskal(g);\n\t\tcout << k.first / 100 - k.second.size() << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#include<algorithm>\n\n#define MAX_V 100\n#define INF 9999\n\nint prim(void);\n\nint cost[MAX_V][MAX_V]; //cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint mincost[MAX_V]; //集合Xからの最小コスト\nbool used[MAX_V]; //頂点iがxに含まれているか\nint V; //頂点数\n\nusing namespace std;\n\nint main(){\n  int n,i,c,j,a,b;\n  \n  while(1){\n    scanf(\"%d\",&n);\n    if(n==0) break;\n    scanf(\"%d\",&V);\n    for(j=0;j<V;j++){\n      for(i=0;i<V;++i){\n\tcost[j][i]=INF;\n      }\n    }\n    for(i=0;i<V;i++){\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    printf(\"%d\\n\",prim());\n    \n  }\n  return 0;\n}\n\nint prim(){\n  \n  //初期化\n  for(int i=0;i<V;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(true){\n    int v=-1;\n    //xに属さない頂点のうちxからの辺のコストが最小になる頂点を探す\n    for(int u=0;u<V;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    \n    used[v]=true; //頂点vをxに追加\n    res+=mincost[v]; //辺のコストを比べる\n    \n    for(int u=0;u<V;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>  \n \nusing namespace std;\n \n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define repr(i, j) for(int i = j; i >= 0; --i)\n#define INF (1 << 30)\n \ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\n\nint par[100001], Rank[100001];\n\n//n????´???§?????????\nvoid init(int n) {\n\trep(i, n) {\n\t\tpar[i] = i;\n\t\tRank[i] = 0;\n\t}\n}\n\n//??¨??????????±???????\nint find(int x) {\n\tif(par[x] == x) return x;\n\telse return par[x] = find(par[x]);\n}\n\n//x??¨y????±??????????????????????\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif(x == y) return;\n\n\tif(Rank[x] < Rank[y]) par[x] = y;\n\telse par[y] = x;\n\tif(Rank[x] == Rank[y]) ++Rank[x];\n}\n\n//x??¨y???????????????????±????????????????\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nstruct edge {int u, v, cost; };\nint N, M;\nedge es[100000];\n\nbool comp(const edge &a, const edge &b){\n\treturn a.cost < b.cost;\n}\n\nint kruskal() {\n\tsort(es, es + M, comp);\n\tinit(N);\n\tint res = 0;\n\trep(i, M) {\n\t\tedge &e = es[i];\n\t\tif(!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main() {\n    while(scanf(\"%d\", &N), N) {\n    \tscanf(\"%d\", &M);\n    \trep(i, M) {\n    \t\tint a, b, c;\n    \t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n    \t\tc = c / 100 - 1;\n    \t\tedge tmp = {a, b, c};\n    \t\tes[i] = tmp;\n    \t}\n        printf(\"%d\\n\", kruskal());\n    }\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <queue>\n#include <stack>\n#include <vector>\n#include <stdio.h>\n#include <algorithm>\n#include <string>\n#include <cstring>\n#include <cmath>\n#include <complex>\n#include <map>\n#include <climits>\nusing namespace std;\n\n#define reep(i,a,b) for(int i=(a);i<(b);++i)\n#define rep(i,n) reep(i,0,n)\n#define ALL(v) (v).begin(),(v).end()\n#define PB push_back\n#define EPS 1e-8\n#define F first\n#define S second\n\nstatic const double PI=6*asin(0.5);\ntypedef long long ll;\ntypedef complex<double> CP;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\ntypedef vector<int> vint;\nstatic const int INF=1<<24;\n\n\nint cost[110][110];\nint mincost[110];\nbool used[110];\nint V;\n\nint prim(){\n\trep(i,V){\n\t\tmincost[i]=INF;\n\t\tused[i]=false;\n\t}\n\tmincost[0]=0;\n\tint res = 0;\n\t\n\twhile(1){\n\t\tint v=-1;\n\t\trep(u,V){\n\t\t\tif(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n\t\t}\n\t\t\n\t\tif(v==-1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v]=true;\n\t\tres+=mincost[v];\n\t\trep(u,V){\n\t\t\tmincost[u]=min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\t\t\t\t\t\n\nint main(){\n\t\n\twhile(cin>>V,V!=0){\n\t\trep(i,V){\n\t\t\trep(j,V){\n\t\t\t\tcost[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\tint m;\n\t\tcin>>m;\n\t\trep(i,m){\n\t\t\tint a,b;\n\t\t\tchar t;\n\t\t\tcin>>a>>t>>b>>t;\n\t\t\tint c;\n\t\t\tcin>>c;\n\t\t\tc/=100;\n\t\t\tc--;\n\t\t\tcost[a][b]=cost[b][a]=c;\n\t\t\t//cout<<cost[a][b]<<\" \"<<cost[b][a]<<endl;\n\t\t}\n\t\t\n\t\tcout<<prim()<<endl;\n\t}\n\treturn 0;\n}\n\t"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <queue>\n\nstatic const size_t n_max = 100;\n\nint main() {\n  for (;;) {\n    size_t n, m;\n    std::vector<std::pair<int, size_t>> edges[n_max];\n    bool visited[n_max] = {};\n    scanf(\"%zu\", &n);\n    if (!n)\n      break;\n    scanf(\"%zu\", &m);\n    for (size_t i = 0; i < m; i++) {\n      size_t a, b;\n      int d;\n      scanf(\"%zu,%zu,%d\", &a, &b, &d);\n      d = -(d / 100 - 1);\n      edges[a].push_back(std::make_pair(d, b));\n      edges[b].push_back(std::make_pair(d, a));\n    }\n    std::priority_queue<std::pair<int, size_t>> pq;\n    visited[0] = true;\n    for (auto&& p : edges[0])\n      pq.push(p);\n    int c = 0;\n    for (size_t i = 1; i < n;) {\n      auto p = pq.top();\n      pq.pop();\n      auto d = p.first;\n      auto a = p.second;\n      if (visited[a])\n        continue;\n      visited[a] = true;\n      i++;\n      c += d;\n      for (auto&& p : edges[a])\n        pq.push(p);\n    }\n    printf(\"%d\\n\", -c);\n  }\n}"
  },
  {
    "language": "C++",
    "code": "/* Minimum Spanning Tree */\n\n#include<queue>\n#include<cstdio>\n#include<vector>\n#include<climits>\n#include<iostream>\n\n#define\tmp(a,b)\tmake_pair((a),(b))\n#define\tdis\t\tfirst\n#define\tnode\tsecond\n\nusing namespace std;\n\ntypedef\tpair<int,int>\tpii;\ntypedef\tpair<int,pii>\tpipii;\n\nvector<int> mst;\n\nint UF_root(int i)\n{\n\tif(mst[i]==-1)\treturn i;\n\treturn mst[i]=UF_root(mst[i]);\n}\n\nbool UF_find(int i,int j)\n{\n\treturn UF_root(i)==UF_root(j);\n}\n\nvoid UF_union(int i,int j)\n{\n\tmst[j]=i;\n}\n\nint main()\n{\n\tfor(int n;cin>>n,n;){\n\t\tmst=vector<int>(n,-1);\t// initial forest has n trees\n\n\t\tpriority_queue< pipii,vector<pipii>,greater<pipii> > pq;\n\t\tint m;\tcin>>m;\n\t\twhile(m--){\n\t\t\tint a,b,dis;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&dis);\n\t\t\tpq.push(mp(dis,mp(a,b)));\n\t\t}\n\n\t\tint total=0;\n\t\twhile(!pq.empty()){\n\t\t\tpipii path=pq.top();\tpq.pop();\n\t\t\tif(!UF_find(path.node.first,path.node.second)){\n\t\t\t\tUF_union(path.node.first,path.node.second);\n\t\t\t\ttotal+=path.dis/100-1;\n\t\t\t}\n\t\t}\n\n\t\tcout<<total<<endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\ntypedef pair<int,pair<int,int> > PII;\nint n,m;\nint ans;\nint E[15000];\nPII V[15000];\nbool is;\n\nsigned main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            V[i].first=z;\n            V[i].second.first=x;\n            V[i].second.second=y;\n        }\n        sort(V,V+m);\n        rep(i,m){\n            if(E[V[i].second.first]==1&&E[V[i].second.second]==1)continue;\n            ans+=V[i].first-100;\n            E[V[i].second.first]=1;\n            E[V[i].second.second]=1;\n            rep(i,n){\n                if(E[i]!=1){\n                    is=false;\n                    break;\n                }\n                is=true;\n            }\n            if(is)break;\n        }\n        cout<<ans/100<<endl;\n        ans=0;\n        rep(i,n)E[i]=0;\n        rep(i,m){\n            V[i].first=0;\n            V[i].second.first=0;\n            V[i].second.second=0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\nusing namespace std;\n\n#pragma warning (disable:4996)\n\n#define WHITE 0\n#define GRAY 1\n#define BLACK 2\n#define INF 114514\n\nint x[1000][1000];\nint color[10000];\nint MIN[10000];\nint sum;\nint sum_min = INF;\n\nint main() {\n\twhile (true) {\n\t\tsum_min = INF;\n\t\tsum = 0;\n\t\tmemset(x, 0, sizeof(x));\n\t\tmemset(color, 0, sizeof(color));\n\t\tmemset(MIN, 0, sizeof(MIN));\n\t\tint n, a, b, c, m, e, f, g;\n\t\tcin >> n;\n\t\tif (n == 0) { break; }\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tx[i][j] = -1;\n\t\t\t}\n\t\t}\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tscanf(\"%d,%d,%d\", &e, &f, &g);\n\t\t\tx[e][f] = g / 100 - 1;\n\t\t\tx[f][e] = g / 100 - 1;\n\t\t}\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tMIN[j] = INF;\n\t\t\t\tcolor[j] = WHITE;\n\t\t\t}\n\t\t\tb = INF;\n\t\t\ta = n;\n\t\t\tcolor[i] = GRAY;\n\t\t\tMIN[i] = 0;\n\t\t\twhile (a != 0) {\n\t\t\t\tb = INF;\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tif (color[j] == GRAY) {\n\t\t\t\t\t\tif (b > MIN[j]) {\n\t\t\t\t\t\t\tb = MIN[j];\n\t\t\t\t\t\t\tc = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tcolor[c] = BLACK;\n\t\t\t\ta -= 1;\n\t\t\t\tfor (int k = 0; k < n; k++) {\n\t\t\t\t\tif (color[k] != BLACK && x[c][k] != -1) {\n\t\t\t\t\t\tcolor[k] = GRAY;\n\t\t\t\t\t\tMIN[k] = min(x[c][k], MIN[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum = 0;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tsum += MIN[j];\n\t\t\t}\n\t\t\tsum_min = min(sum_min, sum);\n\t\t}\n\t\tcout << sum_min << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// 2014/09/22 Tazoe\n\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\nusing namespace std;\n\nconst int INF = 1000000000;\n\nint main()\n{\n\twhile(true){\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif(n==0)\n\t\t\tbreak;\n\n\t\tint W[100][100];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tW[i][j] = INF;\n\t\t\t}\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\tfor(int i=0; i<m; i++){\n\t\t\tstring s;\n\t\t\tcin >> s;\n\n\t\t\tfor(int j=0; j<s.size(); j++){\n\t\t\t\tif(s[j]==','){\n\t\t\t\t\ts[j] = ' ';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tistringstream is(s);\n\t\t\tint a, b, d;\n\t\t\tis >> a >> b >> d;\n\n\t\t\tW[a][b] = W[b][a] = d;\n\t\t}\n/*\n\t\tfor(int i=0; i<n; i++){\n\t\t\tfor(int j=0; j<n; j++){\n\t\t\t\tif(W[i][j]==INF){\n\t\t\t\t\tcout << \"INF\" << ' ';\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tcout << W[i][j] << ' ';\n\t\t\t\t}\n\t\t\t}\n\t\t\tcout << endl;\n\t\t}\n*/\n\n\t\tint mincost[100];\n\t\tbool used[100];\n\n\t\tfor(int i=0; i<n; i++){\n\t\t\tmincost[i] = INF;\n\t\t\tused[i] = false;\n\t\t}\n\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\n\t\twhile(true){\n\t\t\tint v = -1;\n\t\t\tfor(int u=0; u<n; u++){\n\t\t\t\tif(!used[u] && (v==-1 || mincost[u]<mincost[v])){\n\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(v==-1)\n\t\t\t\tbreak;\n\n\t\t\tused[v] = true;\n\t\t\tif(v!=0){\n\t\t\t\tres += (mincost[v]/100-1);\n\t\t\t}\n\n\t\t\tfor(int u=0; u<n; u++){\n\t\t\t\tmincost[u] = min(mincost[u], W[v][u]);\n\t\t\t}\n\t\t}\n\n\t\tcout << res << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\nint Kruskal(Graph& g,Edges& e)\n{\n\te.clear();\n\t\n\tUnionFind uf(g.size());\n\tset<Edge> s;\n\trep(i,g.size())\n\t\trep(j,g[i].size())\n\t\t\ts.insert(g[i][j]);\n\t\n\tint res=0;\n\tforeach(i,s){\n\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n\t\t\tuf.Union(i->src,i->dst);\n\t\t\tres+=i->weight;\n\t\t\te.push_back(*i);\n\t\t}\n\t}\n\t\n\treturn res;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\tEdges e;\n\t\tint sum=Kruskal(g,e);\n\t\t//cout<<sum/100-e.size()<<endl;\n\t\tcout<<sum<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\nusing namespace std;\n#define rep(i,n) for(int i=0;i<n;i++)\n#define pb push_back\nstruct EDGE\n{\n    int to, cost;\n    bool operator < (const EDGE& t) const {\n        return cost > t.cost;\n    }\n};\nvector<EDGE> v[100]; \nbool f[100];\nint search()\n{\n    int res = 0;\n    prioritiy_queue<EDGE> que;\n    que.push({0, 0});\n    while (!que.empty()){\n        EDGE e = que.top(); que.pop();\n        if (f[e.to]) continue;\n        f[e.to] = true;\n        res += e.cost;\n        rep(i, v[e.to].size()){\n            if (!f[v[e.to][i].to]){\n                que.push(v[e.to][i]);\n            }\n        }\n    }\n    return res;\n}\n\nint main()\n{\n    int n, m;\n    while (scanf(\"%d\", &n), n){\n        scanf(\"%d\", &m);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d%d%d\",&a,&b,&c);\n            a--; b--;\n            c = c / 100 - 1;\n            v[a].pb({b, c});\n            v[b].pb({a, c});\n        }\n        printf(\"%d\", search());\n        memset(f, false, sizeof(f));\n        rep(i, n) v[i].clear();\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "/* {{{ Shinobu kawaii */\n/*\n  ______   __        _                  __                 \n.' ____ \\ [  |      (_)                [  |                \n| (___ \\_| | |--.   __   _ .--.   .--.  | |.--.   __   _   \n _.____`.  | .-. | [  | [ `.-. |/ .'`\\ \\| '/'`\\ \\[  | | |  \n| \\____) | | | | |  | |  | | | || \\__. ||  \\__/ | | \\_/ |, \n \\______.'[___]|__][___][___||__]'.__.'[__;.__.'  '.__.'_/ \n\n*/\n// clang-format off\n/* }}} */\n\n#include <bits/stdc++.h>\nusing namespace std;\n\n// #define int long long\nstruct Fast {Fast(){std::cin.tie(0);ios::sync_with_stdio(false);}} fast;\n\n/* cpp template {{{ */\n\n/* short */\n#define pb push_back\n#define eb emplace_back\n#define mp make_pair\n#define Fi first\n#define Se second\n#define ALL(v) begin(v), end(v)\n#define RALL(v) rbegin(v), rend(v)\n#define X real()\n#define Y imag()\n\n/* REPmacro */\n#define REPS(i, a, n) for (ll i = (a); i < (ll)(n); ++i)\n#define REP(i, n) REPS(i, 0, n)\n#define RREP(i, n) REPS(i, 1, n + 1)\n#define DEPS(i, a, n) for (ll i = (a); i >= (ll)(n); --i)\n#define DEP(i, n) DEPS(i, n, 0)\n\n/* debug */\n#define debug(x) cerr << x << \" \" << \"(L:\" << __LINE__ << \")\" << '\\n';\n\n/* alias */\nusing ll = long long;\nusing ull = unsigned long long;\nusing vi = vector<int>;\nusing vvi = vector<vi>;\nusing vvvi = vector<vvi>;\nusing pii = pair<int, int>;\nusing D = double;\nusing P = complex<D>;\nusing vs = vector<string>;\ntemplate <typename T> using PQ = priority_queue<T>;\ntemplate <typename T> using minPQ = priority_queue<T, vector<T>, greater<T>>;\n\n/* const */\nconst int INF = 1001001001;\nconst ll LINF = 1001001001001001001ll;\nconst int MOD = 1e9 + 7;\nconst D EPS = 1e-9;\nconst int dx[] = {0, 1, 0, -1, 1, -1, 1, -1}, dy[] = {1, 0, -1, 0, 1, -1, -1, 1};\n\n/* func */\ninline bool inside(int y, int x, int H, int W) {return y >= 0 && x >= 0 && y < H && x < W;}\ninline int in() {int x; cin >> x; return x;}\ninline ll IN() {ll x; cin >> x; return x;}\ninline vs split(const string& t, char c) {vs v; stringstream s(t); string b; while(getline(s, b, c)) v.eb(b); return v;}\ntemplate <typename T> inline bool chmin(T& a, const T& b) {if (a > b) a = b; return a > b;}\ntemplate <typename T> inline bool chmax(T& a, const T& b) {if (a < b) a = b; return a < b;}\ntemplate <typename T, typename S> inline void print(const pair<T, S>& p) {cout << p.first << \" \" << p.second << endl;}\ntemplate <typename T> inline void print(const T& x) {cout << x << '\\n';}\ntemplate <typename T, typename S> inline void print(const vector<pair<T, S>>& v) {for (auto&& p : v) print(p);}\ntemplate <typename T> inline void print(const vector<T>& v, string s = \" \") {REP(i, v.size()) cout << v[i] << (i != (ll)v.size() - 1 ? s : \"\\n\");}\n// clang-format on\n/* }}} */\n\nstruct Edge {\n  Edge() {}\n  Edge(int a, int c) {to = a; cost = c;}\n  int to, cost;\n};\n\nint n, m;\nvector<Edge> g[100];\n\nint prim() {\n  minPQ<pii> q;\n  bool used[100] = {};\n\n  q.emplace(0, 0);\n  int res = 0;\n  while (q.size()) {\n    auto t = q.top(); q.pop();\n    int cost = t.Fi, v = t.Se;\n    if (used[v]) continue;\n    used[v] = true;\n    res += cost;\n    for (auto e : g[v]) {\n      q.emplace(e.cost, e.to);\n    }\n  }\n\n  return res;\n}\n\nsigned main() {\n  while (cin >> n, n) {\n    fill(ALL(g), vector<Edge>());\n    cin >> m;\n    REP(i, m) {\n      int a, b, cost;\n      char c;\n      cin >> a >> c >> b >> c >> cost;\n      g[a].eb(b, cost - 100);\n      g[b].eb(a, cost - 100);\n    }\n    print(prim() / 100);\n  }\n\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <tuple>\n\n// Union Find\ntemplate<class T=int>\nclass UnionFind\n{\n    std::vector<T> p;\n    std::vector<T> r;\n    T find(const T x)\n    {\n        if(x==p[x]) return x;\n        return p[x]=find(p[x]);\n    }\n    void unite_(T x, T y)\n    {\n        if(x==y) return;\n        if(r[x]>r[y]) std::swap(x,y);\n        else if(r[x]==r[y]) ++r[y];\n        p[x]=y;\n    }\npublic:\n    explicit UnionFind(const T n):p(n),r(n,0)\n    {\n        for(T i=0; i<n; ++i)\n            p[i]=i;\n    }\n    bool same(const T x, const T y)\n    {\n        // assert(0<=x && x<p.size())\n        // assert(0<=y && y<p.size())\n        return find(x)==find(y);\n    }\n    void unite(const T x, const T y)\n    {\n        // assert(0<=x && x<p.size())\n        // assert(0<=y && y<p.size())\n        unite_(find(x),find(y));\n    }\n};\n\n// Kruskal's algorithm\ntemplate<class T, class U>\nT& kruskal(T& edges, U max_v)\n{\n    typedef typename T::value_type Edge;\n    std::sort(edges.begin(),edges.end());\n    UnionFind<U> uf(max_v);\n    edges.erase(\n        std::remove_if(edges.begin(),edges.end(),\n            [&uf](const Edge& e){\n                const auto& a = std::get<1>(e);\n                const auto& b = std::get<2>(e);\n                if(uf.same(a,b)) return true;\n                uf.unite(a,b);\n                return false;\n            }),\n        edges.end());\n    return edges;\n}\n\nint main()\n{\n    std::cin.tie(0);\n    std::ios_base::sync_with_stdio(false);\n    for(int n,m; (std::cin >> n >> m) && n; )\n    {\n        typedef std::tuple<int,int,int> T;\n        std::vector<T> edges(m);\n        for(auto& v: edges)\n        {\n            int a,b,d; char c; std::cin >> a >> c >> b >> c >> d;\n            v = T(d,a,b);\n        }\n        int c=0;\n        for(auto& e: kruskal(edges, n))\n            c+=std::get<0>(e)/100-1;\n        std::cout << c << \"\\n\";\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\n#define loop(i,a,b) for(int i=(a); i<(int)(b); i++)\n#define rep(i,b) loop(i,0,b)\n\nstruct edge {\n    int to, cost;\n    edge(int t, int c) : to(t), cost(c) { }\n};\n\ntypedef pair<int, int> P;\n\nint prim(int n, vector<vector<edge>> const& E ){\n    vector<bool> used(n, false);\n\n    priority_queue<P, vector<P>, greater<P> > que;\n    que.push(P(0, 0));\n\n    int res = 0;\n    while (!que.empty()) {\n        P p = que.top(); que.pop();\n        int v = p.second;\n        if (used[v]) { continue; }\n        used[v] = true;\n        res += max(0, p.first / 100 - 1);\n\n        vector<edge> es = E[v];\n        rep(i,es.size()){\n            edge const& e = es[i];\n            if (!used[e.to]){\n                que.push(P(e.cost, e.to));\n            }\n        }\n    }\n    return res;\n}\n\nint main(){\n    int n;\n    while(cin >> n, n) {\n        int m; cin >> m;\n        vector<vector<edge> > E(n);\n        rep(i,m){\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            E[a].push_back(edge(b, c));\n            E[b].push_back(edge(a, c));\n        }\n        cout << prim(n,E) << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <map>\n#include <cstdio>\n#include <set>\n#define INF 1e8\n\nusing namespace std;\nint main(){\n  int n,m;\n  while(cin>>n>>m,n||m){\n    vector<vector<int> > g(n);\n    for(int i=0;i<n;++i){\n      g[i].reserve(n);\n      for(int j=0;j<n;++j) g[i][j]=INF;\n    }\n    for(int i=0,a,b,d;i<m;++i){\n      scanf(\"%d,%d,%d\",&a,&b,&d);\n      g[a][b]=d/100-1;\n      g[b][a]=d/100-1;\n    }\n    int ans=0;\n    set<int> v;\n    v.insert(0);\n    while(v.size()!=n){\n      int min_cost=INF,to;\n      for(set<int>::iterator vit=v.begin();vit!=v.end();++vit){\n        for(int i=0;i<n;++i){\n          if(v.find(i)==v.end()&&g[*vit][i]<min_cost){\n            to=i;\n            min_cost=g[*vit][i];\n          }\n        }\n      }\n      ans+=min_cost;\n      v.insert(to);\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define SIZE 300005\n#define MOD 1000000007LL\n#define INF 1 << 30\n#define LLINF 1LL << 60\n#define REP(i,n) for(int i=0;i<n;i++)\n#define FOR(i,a,b) for(int i=a;i<=b;i++)\n#define DOWN(i,b,a) for(int i=b;i>=a;i--)\n#define SET(a,c) memset(a,c,sizeof a)\n#define FORALL(i,c) for(__typeof((c).begin())i=(c).begin();i!=(c).end();++i)\n#define FOREACH(i,c) for(auto (i) : (c))\n#define BIT(i,j) ((i)>>(j))&1\n#define ALL(o) (o).begin(), (o).end()\n#define ERASE(o) (o).erase(unique((o).begin(),(o).end()), (o).end())\n#define SQ(x) ((x)*(x))\nusing namespace std;\ntypedef long long ll;\ntypedef pair<ll,ll> Pll;\ntypedef pair<int, int> Pii;\ntypedef pair<double, double> Pdd;\ntemplate<typename T> inline void priv(vector<T>a){REP(i,a.size()){cout<<a[i]<<((i==a.size()-1)?\"\\n\":\" \");}}\nll gcd(ll a,ll b){int c=max(a,b);int d=min(a,b);return c==0||d==0?c:gcd(c%d,d);}\nll lcm(ll a,ll b){return a==0||b==0?0:a*b/gcd(a,b);}\n\ntypedef int Weight;\nstruct Edge\n{\n  int src, dst;\n  Weight weight;\n  Edge(int src, int dst, Weight weight) :\n    src(src), dst(dst), weight(weight) { }\n};\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\ntypedef vector<Weight> Array;\ntypedef vector<Array> Matrix;\nbool operator < (const Edge &e, const Edge &f)\n{\n  return e.weight != f.weight ? e.weight > f.weight : // !!INVERSE!! ???????????????????????????\n    e.src != f.src ? e.src < f.src : e.dst < f.dst;\n}\n\npair<Weight, Edges> minimumSpanningTree(const Graph &g, int r = 0)\n{\n  int n = g.size();\n  Edges T;\n  Weight total = 0;\n  vector<bool> visited(n);\n  priority_queue<Edge> Q;\n  Q.push(Edge(-1,r,0));\n  while (!Q.empty())\n  {\n    Edge e = Q.top(); Q.pop();\n    if (visited[e.dst]) continue;\n    T.push_back(e);\n    total += e.weight;\n    visited[e.dst] = true;\n    for(auto f: g[e.dst]) if(!visited[f.dst]) Q.push(f);\n  }\n  return pair<Weight, Edges>(total, T);\n}\n\nint main()\n{\n  int n;\n  while(cin >> n,n)\n  {\n    Graph g(n);\n    int m; cin >> m;\n    REP(i,m)\n    {\n      int s,d,w;scanf(\"%d,%d,%d\\n\",&s,&d,&w);\n      g[s].push_back(Edge(s,d,w/100-1));\n      g[d].push_back(Edge(d,s,w/100-1));\n    }\n    cout << minimumSpanningTree(g).first << endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\ntypedef pair<int,pair<int,int> > PII;\nint n,m;\nint ans;\nint E[15000];\nPII V[15000];\nbool is;\n\nsigned main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            V[i].first=z/100-1;\n            V[i].second.first=x;\n            V[i].second.second=y;\n        }\n        sort(V,V+m);\n        rep(i,m){\n            if(E[V[i].second.first]==1&&E[V[i].second.second]==1)continue;\n            ans+=V[i].first;\n            E[V[i].second.first]=1;\n            E[V[i].second.second]=1;\n            rep(i,n){\n                if(E[i]!=1){\n                    is=false;\n                    break;\n                }\n                is=true;\n            }\n            if(is)break;\n        }\n        cout<<ans<<endl;\n        ans=0;\n        rep(i,n)E[i]=0;\n        rep(i,m){\n            V[i].first=0;\n            V[i].second.first=0;\n            V[i].second.second=0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "int mincost[MAX_V]; //集合Xからの最小コスト\nbool used[MAX_V]; //頂点iがxに含まれているか\nint m; //頂点数\n\nusing namespace std;\n\nint main(){\n  int n,i,c,j,a,b;\n  \n  while(1){\n    scanf(\"%d\",&n); if(n==0) break;\n scanf(\"%d\",&m);\n    for(j=0;j<m;j++){\n      for(i=0;i<m;++i){\n\tcost[j][i]=INF;\n      }\n    }\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d\",&a,&b); scanf(\",%d\",&c);\n      cost[a][b]=c/100-1;\n      cost[b][a]=c/100-1;\n    }\n    printf(\"%d\\n\",prim());\n    \n  }\n  return 0;\n}\n\nint prim(){\n  \n  //初期化\n  for(int i=0;i<m;++i){\n    mincost[i]=INF;\n    used[i]=false;\n  }\n  \n  mincost[0]=0;\n  int res=0;\n  \n  while(true){\n    int v=-1;\n    //xに属さない頂点のうちxからの辺のコストが最小になる頂点を探す\n    for(int u=0;u<m;u++){\n      if(!used[u]&&(v==-1||mincost[u]<mincost[v])) v=u;\n    }\n    if(v==-1) break;\n    \n    used[v]=true; //頂点vをxに追加\n    res+=mincost[v]; //辺のコストを比べる\n    \n    for(int u=0;u<m;u++){\n      mincost[u]=min(mincost[u],cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <climits>\n#include <cfloat>\n#include <map>\n#include <utility>\n#include <set>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <functional>\n#include <sstream>\n#include <fstream>\n#include <complex>\n#include <stack>\n#include <queue>\n\nusing namespace std;\ntypedef long long LL;\ntypedef pair<int, int> PII;\nstatic const double EPS = 1e-5;\n\n#define FOR(i,k,n) for (int i=(k); i<(int)(n); ++i)\n#define REP(i,n) FOR(i,0,n)\nint arive[101][101];\nint main(void){\n  int n,m;\n  while(cin>>n>>m){\n    if(n==0) break;\n    int ans = 0;\n    vector<pair<int,PII> > route;\n    REP(i,n)REP(j,n)arive[i][j] = 1;\n    REP(i,m){\n      int a,b,l;\n      scanf(\"%d,%d,%d\",&a,&b,&l);\n      l = (l-1)/100;\n      route.push_back(pair<int,PII>(l,PII(a,b)));\n    }\n    sort(route.begin(),route.end());\n    REP(i,route.size()){\n      int a = route[i].second.first;\n      int b = route[i].second.second;\n      if(arive[a][b]){\n        arive[a][b] = arive[b][a] = 0;\n        REP(k,n)REP(i2,n)REP(j,n) arive[i2][j] = min(arive[i2][j]\n            ,arive[i2][k] + arive[k][j]);\n        ans += route[i].first;\n      }\n    }\n    cout<<ans<<endl;\n  }\n  return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\n//#define int long long\n#define FOR(i, j, k) for(int i = j; i < k; ++i)\n#define rep(i, j) FOR(i, 0, j)\n#define INF 1e9\n#define LINF 1e18\n\ntypedef unsigned long long ull;\ntypedef pair<int, int> P;\ntypedef pair<P, int> Pi;\ntypedef pair<P, P> PP;\n\nconst int MOD = 1e9 + 7;\nconst int dy[] = { 0, 0, 1, -1 };\nconst int dx[] = { 1, -1, 0, 0 };\n\ntemplate <class T> void chmin(T& a, const T& b) { a = min(a, b); }\ntemplate <class T> void chmax(T& a, const T& b) { a = max(a, b); }\n\ntypedef pair<int, int> P;\nstruct edge{int to, cost;};\nint n, m;\nbool used[101];\n\nsigned main() {\n    cin.tie(0);\n    ios::sync_with_stdio(false);\n\n    while(cin >> n) {\n        if(n == 0) break;\n        cin >> m;\n        vector<edge> G[100];\n        rep(i, m) {\n            int a, b, c;\n            scanf(\"%d,%d,%d\", &a, &b, &c);\n            G[a].push_back(edge{b, c / 100 - 1});\n            G[b].push_back(edge{a, c / 100 - 1});\n        }\n        priority_queue<P, vector<P>, greater<P> > que;\n        memset(used, 0, sizeof(used));\n        que.push(P(0, 0));\n        int res = 0;\n        while(!que.empty()) {\n            P p = que.top(); que.pop();\n            int cst = p.first, v = p.second;\n            if(used[v]) continue;\n            used[v] = true;\n            res += cst;\n            rep(i, G[v].size()) {\n                que.push(P(G[v][i].cost, G[v][i].to));\n            }\n        }\n        cout << res << endl;\n    }\n    return 0;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint INF = 1 << 29;\n\nint main(void)\n{\n\tint n,d;\n\tint path[200][200];\n\tint x,y,cost; // 飾り\n\tint used[200]; // 木に入ったか\n\tint mincost; // 最安値\n\tint minnum; // 安い点\n\tint ans;\n\n\tscanf(\"%d\", &n);\n\twhile(n != 0){\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tpath[i][j] = INF;\n\t\t\t}\n\t\t\tused[i] = 0;\n\t\t}\n\t\tused[0] = 1;\n\n\t\tscanf(\"%d\", &d);\n\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tscanf(\"%d,%d,%d\", &x, &y, &cost);\n\t\t\tpath[x][y] = cost;\n\t\t\tpath[y][x] = cost;\n\t\t}\n\t\tmincost = INF + 1;\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(used[j]){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(path[j][k] < mincost){\n\t\t\t\t\t\t\tif(!used[k]){\n\t\t\t\t\t\t\t\tminnum = k;\n\t\t\t\t\t\t\t\tmincost = path[j][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (mincost - 100) / 100;\n\t\t\tused[minnum] = 1;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tscanf(\"%d\", &n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<map>\n#include<set>\n#include<list>\n#include<cmath>\n#include<queue>\n#include<stack>\n#include<cstdio>\n#include<string>\n#include<vector>\n#include<complex>\n#include<cstdlib>\n#include<cstring>\n#include<numeric>\n#include<sstream>\n#include<iostream>\n#include<algorithm>\n#include<functional>\n\n#define mp       make_pair\n#define pb       push_back\n#define all(x)   (x).begin(),(x).end()\n#define rep(i,n) for(int i=0;i<(n);i++)\n\nusing namespace std;\n\ntypedef    long long          ll;\ntypedef    unsigned long long ull;\ntypedef    vector<bool>       vb;\ntypedef    vector<int>        vi;\ntypedef    vector<vb>         vvb;\ntypedef    vector<vi>         vvi;\ntypedef    pair<int,int>      pii;\n\nconst int INF=1<<29;\nconst double EPS=1e-9;\n\nconst int dx[]={1,0,-1,0},dy[]={0,-1,0,1};\nint m;//辺の数\n/*プリム法*/\nconst int MAX_V = 110;\nint cost[MAX_V][MAX_V];//cost[u][v]は辺e=(u,v)のコスト(存在しない場合はINF)\nint mincost[MAX_V];//集合Xからの辺の最小コスト\nbool used[MAX_V];//頂点iがXに含まれているか\nint V;//頂点の数\n\nint prim(){\n\tfor(int i = 0;i < V;i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true){\n\t\tint v = -1;\n\t\t//Xに属さない頂点のうちXからの辺のコストが最小になる頂点を探す\n\t\tfor(int u = 0;u < V;u++){\n\t\t\tif(!used[u]&&(v==-1||mincost[u]<mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\tif(v==-1)\n\t\t\tbreak;\n\t\tused[v] = true;//頂点vをXに追加\n\t\tres +=mincost[v];//辺のコストを加える\n\t\tfor(int u = 0;u < V;u++){\n\t\t\tmincost[u] = min(mincost[u],cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\nint main(){\n\twhile(cin>>V,V){\n\t\tcin>>m;\n\t\trep(i,V){\n\t\t\trep(j,V){\n\t\t\t\tcost[i][j] =INF;\n\t\t\t\tif(i==j){\n\t\t\t\t\tcost[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\trep(i,m){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\tcost[a][b] =(c-100)/100;\n\t\t\tcost[b][a] =(c-100)/100;\n\t\t}\n\t\tcout <<prim()<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <iomanip>\n#include <sstream>\n#include <cstdio>\n#include <cstdlib>\n#include <cmath>\n#include <cstring>\n#include <climits>\n#include <cfloat>\n#include <string>\n#include <vector>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <algorithm>\n#include <functional>\n#include <utility>\n#include <numeric>\n\nusing namespace std;\n\ntypedef unsigned int UI;\ntypedef long long LL;\ntypedef unsigned long long ULL;\ntypedef vector<int> VI;\ntypedef vector<VI> VVI;\ntypedef vector<string> VS;\ntypedef pair<int,int> PII;\ntypedef istringstream ISS;\ntypedef ostringstream OSS;\n\n#define REP( i, m, n ) for ( int i = (int)( m ); i < (int)( n ); ++i )\n#define EACH( v, c ) for ( auto &v : c )\n\n#define ITER( c ) __typeof( (c).begin() )\n#define IREP( c, it ) for ( ITER(c) it = c.begin(); it != c.end(); ++it )\n#define ALL( c ) (c).begin(), (c).end()\n\n#define PB( n ) push_back( n )\n#define MP( a, b ) make_pair( ( a ), ( b ) )\n#define EXIST( c, e ) ( (c).find( e ) != (c).end() )\n\n#define fst first\n#define snd second\n\n#define DUMP( x ) cerr << #x << \" = \" << ( x ) << endl\n#define DEBUG( x ) cerr << __FILE__ << \":\" << __LINE__ << \": \" << #x << \" = \" << ( x ) << endl\n\nclass UnionFind\n{\nprivate:\n\tvector<int> ary;\n\tvector<int> rank;\n\npublic:\n\tUnionFind( int n ) : ary( n ), rank( n, 0 )\n\t{\n\t\tREP( i, 0, n )\n\t\t{\n\t\t\tary[i] = i;\n\t\t}\n\n\t\treturn;\n\t}\n\n\tint find( int x )\n\t{\n\t\tif ( ary[x] == x )\n\t\t{\n\t\t\treturn x;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn ary[x] = find( ary[x] );\n\t\t}\n\t}\n\n\tbool same( int x, int y )\n\t{\n\t\treturn find( x ) == find( y );\n\t}\n\n\tvoid unite( int x, int y )\n\t{\n\t\tx = find( x );\n\t\ty = find( y );\n\n\t\tif ( x == y )\n\t\t{\n\t\t\treturn;\n\t\t}\n\n\t\tif ( rank[x] < rank[y] )\n\t\t{\n\t\t\tary[x] = y;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tary[y] = x;\n\n\t\t\tif ( rank[x] == rank[y] )\n\t\t\t{\n\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\n\t\treturn;\n\t}\n};\n\nstruct Edge\n{\n\tint cost, from, to;\n\n\tEdge( int c, int f, int t ) : cost( c ), from( f ), to( t )\n\t{\n\t\treturn;\n\t}\n\n\tbool operator < ( const Edge &a ) const\n\t{\n\t\treturn cost < a.cost;\n\t}\n};\n\nint main()\n{\n\tcin.tie( 0 );\n\tios::sync_with_stdio( false );\n\n\twhile ( true )\n\t{\n\t\tint n;\n\t\tcin >> n;\n\n\t\tif ( !n )\n\t\t{\n\t\t\tbreak;\n\t\t}\n\n\t\tint m;\n\t\tcin >> m;\n\n\t\tvector< Edge > E;\n\n\t\tfor ( int i = 0; i < m; i++ )\n\t\t{\n\t\t\tint cost, from, to;\n\t\t\tchar dummy;\n\n\t\t\tcin >> from >> dummy >> to >> dummy >> cost;\n\n\t\t\tcost = cost / 100 - 1;\n\n\t\t\tE.PB( Edge( cost, from, to ) );\n\t\t\tE.PB( Edge( cost, to, from ) );\n\t\t}\n\n\t\tsort( ALL( E ) );\n\n\t\tint res = 0;\n\t\tUnionFind uf( n );\n\n\t\tfor ( int i = 0; i < E.size(); i++ )\n\t\t{\n\t\t\tif ( uf.same( E[i].from, E[i].to ) )\n\t\t\t{\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tuf.unite( E[i].from, E[i].to );\n\t\t\tres += E[i].cost;\n\t\t}\n\n\t\tcout << res << endl;\n\t}\t\t\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n\nint INF = 1 << 30;\n\nint main(void)\n{\n\tint n,d;\n\tint path[200][200];\n\tint x,y,cost; // 飾り\n\tint used[200]; // 木に入ったか\n\tint mincost; // 最安値\n\tint minnum; // 安い点\n\tint ans;\n\n\tscanf(\"%d\", &n);\n\twhile(n != 0){\n\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tpath[i][j] = INF;\n\t\t\t}\n\t\t\tused[i] = 0;\n\t\t}\n\t\tused[0] = 1;\n\n\t\tscanf(\"%d\", &d);\n\n\t\tfor(int i = 0; i < d; i++){\n\t\t\tscanf(\"%d,%d,%d\", &x, &y, &cost);\n\t\t\tpath[x][y] = cost;\n\t\t\tpath[y][x] = cost;\n\t\t}\n\t\tmincost = INF + 1;\n\t\tans = 0;\n\n\t\tfor(int i = 0; i < n - 1; i++){\n\t\t\tfor(int j = 0; j < n; j++){\n\t\t\t\tif(used[j]){\n\t\t\t\t\tfor(int k = 0; k < n; k++){\n\t\t\t\t\t\tif(path[j][k] < mincost){\n\t\t\t\t\t\t\tif(!used[k]){\n\t\t\t\t\t\t\t\tminnum = k;\n\t\t\t\t\t\t\t\tmincost = path[j][k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += (mincost - 100) / 100;\n\t\t\tused[minnum] = 1;\n\t\t}\n\n\t\tprintf(\"%d\\n\",ans);\n\t\tscanf(\"%d\", &n);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n\nusing namespace std;\n\ntypedef  pair < int , pair<int , int> > PP;\n\nint main ()\n{\n\tint N , M;\n\twhile( cin >> N , N )\n\t{\n\t\tcin >> M;\n\t\tpriority_queue < PP , vector<PP> , greater<PP>>que;\n\t\tfor( size_t i = 0; i < M; i++ )\n\t\t{\n\t\t\tchar x;\n\t\t\tint a , b , c;\n\t\t\tcin >> a >> x >> b >> x >> c;\n\t\t\tque.push ( PP ( c , pair<int , int> ( a , b ) ) );\n\t\t}\n\t\tvector<bool>data(N);\n\t\tint count = 0;\n\t\twhile( que.size () )\n\t\t{\n\t\t\tPP now = que.top (); que.pop ();\n\t\t\tif( data[now.second.first] == false || data[now.second.second] == false )\n\t\t\t{\n\t\t\t\tdata[now.second.first] = true;\n\t\t\t\tdata[now.second.second] = true;\n\t\t\t\tcount += now.first / 100 - 1;\n\t\t\t}\n\t\t}\n\t\tcout << count << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdio>\n#include <functional>\n#include <numeric>\n#include <stack>\n#include <queue>\n#include <map>\n#include <set>\n#include <utility>\n#include <sstream>\n#include <complex>\n#include <fstream>\n#include <bitset>\n\nusing namespace std;\n\ntypedef long long ll;\ntypedef pair<ll, ll> P;\ntypedef vector<ll> V;\ntypedef complex<double> Point;\n\n#define PI acos(-1.0)\n#define EPS 1e-10\nconst ll INF = 1e9 + 7;\nconst ll MOD = 1e9 + 7;\n\n#define FOR(i,a,b) for(long long i=(a);i<(b);i++)\n#define REP(i,N) for(long long i=0;i<(N);i++)\n#define ALL(s) (s).begin(),(s).end()\n#define EQ(a,b) (abs((a)-(b))<EPS)\n#define EQV(a,b) ( EQ((a).real(), (b).real()) && EQ((a).imag(), (b).imag()) )\n#define fi first\n#define se second\n\nint n, m;\n\nstruct edge{ int to; int cost; };\nvector<edge> G[110];\nint mincost[110];\nint res = 0;\nbool used[110];//?????????????±???????????????????\n\nint prim(){\n\tfor (int i = 0; i < n; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\n\tpriority_queue<P, vector<P>, greater<P>> que;\n\tque.push(P(0, 0));\n\n\t//cout << '!' << que.size() << endl;\n\twhile (que.size()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\n\t\tif (used[v])continue;\n\n\t\tused[v] = 1;\n\n\t\tfor (int i = 0; i < G[v].size(); i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif (used[e.to])continue;\n\t\t\tif (mincost[e.to] > e.cost){\n\t\t\t\tmincost[e.to] = e.cost;\n\t\t\t\tque.push(P(e.cost, e.to));\n\t\t\t}\n\t\t}\n\t}\n\n\tREP(i, n){\n\t\t//cout << mincost[i] << endl;\n\t\tres += mincost[i];\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile (cin >> n&&n){\n\t\tcin >> m;\n\t\tREP(i, m){\n\t\t\tint a, b, c;\n\t\t\tchar k;\n\t\t\tcin >> a >> k >> b >> k >> c;\n\t\t\tG[a].push_back({ b, c });\n\t\t\tG[b].push_back({ a, c });\n\t\t}\n\t\tprim();\n\t\tint ans = 0;\n\t\tREP(i, n){\n\t\t\tcout << mincost[i] << endl;\n\t\t\tans += (mincost[i] / 100 - 1);\n\t\t}\n\t\tcout << ans + 1 << endl;\n\t\tREP(i, 110)G[i].clear();\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <cstdio>\n\nusing namespace std;\n\nstruct edge {\n\tint to, cost;\n\tedge(int t, int c) : to(t), cost(c) { }\n};\ntypedef pair<int, int> P;\n\nint prim ( int n, vector<vector<edge> >* E )\n{\n\tvector<bool> used(n, false);\n\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tque.push(P(0, 0));\n\n\tint res = 0;\n\twhile (!que.empty()) {\n\t\tP p = que.top(); que.pop();\n\n\t\tint v = p.second;\n\t\tif (used[v]) { continue; }\n\t\tused[v] = true;\n\t\tres += max(0, p.first / 100 - 1);\n\t\tcout << \"cost=\" << p.first << endl;\n\t\t\n\t\tvector<edge> es = (*E)[v];\n\t\tfor (int i = 0; i < es.size(); ++i) {\n\t\t\tedge& e = es[i];\n\t\t\tif (!used[e.to]) { que.push(P(e.cost, e.to)); }\n\t\t}\n\t}\n\treturn res;\n}\n\nint main ( void )\n{\n\tint n;\n\n\twhile (cin >> n, n) {\n\t\tint m;\n\t\tcin >> m;\n\n\t\tvector<vector<edge> > E(n);\n\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\n\t\t\tE[a].push_back(edge(b, c));\n\t\t\tE[b].push_back(edge(a, c));\n\t\t}\n\n\t\tcout << prim(n, &E) << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<vector>\n#include<algorithm>\nusing namespace std;\n\n#define MAX_N 100\nint par[MAX_N];\nint rank[MAX_N];\nvoid init(int n){\n\tfor(int i=0;i<n;i++){\n\t\tpar[i]=i;\n\t\trank[i]=0;\n\t}\n}\nint find(int x){\n\tif(par[x]==x)return x;\n\treturn par[x]=find(par[x]);\n}\nvoid unite(int x,int y){\n\tx=find(x);\n\ty=find(y);\n\tif(rank[x]<rank[y]){\n\t\tpar[x]=y;\n\t}else{\n\t\tpar[y]=x;\n\t\tif(rank[x]==rank[y])rank[x]++;\n\t}\n}\nbool same(int x,int y){\n\treturn find(x)==find(y);\n}\nstruct Edge{\n\tint a,b,c;\n\tEdge(){}\n\tEdge(int a,int b,int c):a(a),b(b),c(c){}\n\tbool operator<(const Edge &e)const{return c<e.c;}\n};\n\nint main(){\n\tint n,m;\n\tvector<Edge> edge;\n\twhile(cin>>n&&n){\n\t\tedge.clear();\n\t\tcin>>m;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tchar _;\n\t\t\tcin>>a>>_>>b>>_>>c;\n\t\t\tedge.push_back(Edge(a,b,c/100-1));\n\t\t}\n\t\tinit(n);\n\t\tsort(edge.begin(),edge.end());\n\t\tint ans=0;\n\t\tfor(int i=0;i<m;i++){\n\t\t\tEdge &e=edge[i];\n\t\t\tif(!same(e.a,e.b)){\n\t\t\t\tunite(e.a,e.b);\n\t\t\t\tans+=e.c;\n\t\t\t}\n\t\t}\n\t\tcout<<ans<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "// {{{\n// vim:filetype=cpp foldmethod=marker foldmarker={{{,}}}\n#include <algorithm>\n#include <bitset>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <ctime>\n#include <climits>\n#include <complex>\n#include <deque>\n#include <functional>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <numeric>\n#include <queue>\n#include <set>\n#include <sstream>\n#include <stack>\n#include <string>\n#include <utility>\n#include <vector>\n#define ALL(A)\t\t(A).begin(),(A).end()\n#define DUMP(A)    cout<<#A<<\"=\"<<(A)<< endl\n#define SIZE(A)    (int)((A).size())\n#define MP  make_pair\n#define PB  push_back\nusing namespace std;\ntypedef long long ll;\n\nint vx[]={1,0,-1,0},vy[]={0,1,0,-1};\n// }}}\n\nvector<int> par,rank;\nvector<pair<int,pair<int,int> > > edge;\nint find(int n){\n    if(par[n]==n) return n;\n    else return par[n]=find(par[n]);\n}\nvoid unite(int a,int b){\n    int pa=find(a),pb=find(b);\n    if(pa==pb) return;\n    if(rank[pa]>rank[pb]) swap(pa,pb);\n    par[pa]=pb;\n    if(rank[pa]==rank[pb]) rank[pb]++;\n}\nint main(){\n    int n,m;\n    for(;;){\n        scanf(\"%d\\n\",&n);\n        if(n==0) break;\n        scanf(\"%d\\n\",&m);\n        int a,b,d;\n        edge=vector<pair<int,pair<int,int> > >(m);\n        for(int i=0;i<m;i++){\n            scanf(\"%d,%d,%d\\n\",&a,&b,&d);\n            d=d/100-1;\n            edge[i]=MP(d,MP(a,b));\n        }\n        par=vector<int>(n);\n        rank=vector<int>(n);\n        for(int i=0;i<n;i++){\n            par[i]=i;\n            rank[i]=0;\n        }\n        sort(ALL(edge));\n        int ret=0;\n        for(int i=0;i<edge.size();i++){\n            int a=edge[i].second.first,b=edge[i].second.second,d=edge[i].first;\n            if(find(a)!=find(b)){\n                ret+=d;\n                unite(a,b);\n            }\n        }\n        printf(\"%d\\n\",ret);\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <string>\n#include <sstream>\n#include <algorithm>\n#include <vector>\n#include <utility>\n#include <cstdio>\n#include <cstring>\n#include <cmath>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n \nusing namespace std;\n \n#define pb(n)\tpush_back(n)\n#define mp(n,m) make_pair(n,m)\n#define fi \tfirst\n#define se \tsecond\n#define all(r) (r).begin(),(r).end()\n \n#define REP(i,s,e)\tfor(int i=(s); i<(e); i++)\n#define rep(i,n)\tREP(i,0,n)\n#define REPE(i,s,e)\tfor(int i=s; i>e; i--)\n#define repe(i,n)\tREPE(i,n,-1)\n\n\ntypedef long long ll;\ntypedef vector<int> vi;\ntypedef vector<ll> vl;\ntypedef pair<int,int> pii;\ntypedef pair<ll,ll> pll;\n \ntypedef vector<vi> vii;\n \nconst int IMAX=((1<<30)-1)*2+1;\nconst int INF=100000000;\nconst double EPS=1e-10;\n//int mod=1000000007\n \n\nconst int MAX_E = 300100;\nconst int MAX_V = 100100;\n \nint par_uft[MAX_V];\nint rank_uft[MAX_V];\n \nvoid init_uft(int n) {\n\tint i;\n\tfor (i = 0; i < n; i++) {\n\t\tpar_uft[i] = i;\n\t\trank_uft[i] = 0;\n\t}\n}\n \nint find_uft(int x) {\n\tif (par_uft[x] == x) {\n\t\treturn x;\n\t}\n\telse {\n\t\treturn par_uft[x] = find_uft(par_uft[x]);\n\t}\n}\n \nvoid unite_uft(int x, int y) {\n\tx = find_uft(x);\n\ty = find_uft(y);\n\tif (x == y)return;\n \n\tif (rank_uft[x] < rank_uft[y]) {\n\t\tpar_uft[x] = y;\n\t}\n\telse {\n\t\tpar_uft[y] = x;\n\t\tif (rank_uft[x] == rank_uft[y]) {\n\t\t\trank_uft[x]++;\n\t\t}\n\t}\n}\n \nbool same_uft(int x, int y) {\n\treturn find_uft(x) == find_uft(y);\n}\n \n \n \nstruct edge { int u, v, cost; };\n \nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n \nedge es[MAX_E];\nint V, E;\n \nll kruskal() {\n\tsort(es, es + E, comp);\n\tinit_uft(V);\n\tll res = 0LL;\n\tfor (int i = 0; i < E; i++) {\n\t\tedge e = es[i];\n\t\tif (!same_uft(e.u, e.v)) {\n\t\t\tunite_uft(e.u, e.v);\n\t\t\tres += e.cost;\n\t\t}\n\t}\n\treturn res;\n}\n\n\nint main(){\n\tchar c;\n\tint a,b,d;\n\twhile(cin>>E>>V){\n\t\tif(E==0)break;\n\t\trep(i,E){\n\t\t\tcin>>a>>c>>b>>c>>d;\n\t\t\td/=100;\n\t\t\td--;\n\t\t\tif(a>b){\n\t\t\t\tint t=a;\n\t\t\t\ta=b;\n\t\t\t\tb=t;\n\t\t\t}\n\t\t\tes[i].u=a;\n\t\t\tes[i].v=b;\n\t\t\tes[i].cost=d;\n\t\t}\n\t\tcout<<kruskal()<<endl;\n\t}\n\n}"
  },
  {
    "language": "C++",
    "code": "#include \"bits/stdc++.h\"\nusing namespace std;\n\n#define INF 1000000\nusing namespace std;\n\nint n,m;\nint cost[100][100];\nint mincost[100];\nbool used[100];\n\nint Prim(){\n\tfor(int i = 0; i < n; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true){\n\t\tint v = -1;\n\t\tfor(int u = 0; u < n;u++){\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n\t\t}\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v] / 100;\n\t\tfor(int u = 0; u < n; u++){\n\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main(){\n\twhile(scanf(\"%d\",&n)){\n\tif(n == 0)break;\n\tscanf(\"%d\", &m);\n\tfor(int i = 0; i < n; i++){\n\t\tfor(int j = 0; j < n;j++){\n\t\t\tcost[i][j] = INF;\n\t\t}\n\t}\n\tfor(int i = 0; i < n; i++) cost[i][i] = 0;\n\tfor(int i = 0; i < m; i++){\n\t\tint a,b,c;\n\t\tscanf(\"%d,%d,%d\", &a,&b,&c);\n\t\tcost[a][b] = cost[b][a] = c;\n\t}\n\tprintf(\"%d\\n\", Prim()-n+1);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <cstdio>\nusing namespace std;\n\nstruct edge{int u, v, cost;};\n\n#define MAX_N 100001\n#define MAX_E 100001\n\nint par[MAX_N];\nint rank[MAX_N];\nedge es[MAX_E];\nint V, E;\n\nint kruskal();\nvoid init(int n);\nint find(int x);\nvoid unite(int x, int y);\nbool same(int x, int y);\nbool comp(const edge& e1, const edge& e2);\n\nint main()\n{\n    cin >> V;\n    while (V) {\n        cin >> E;\n        for (int i = 0; i < E; i++) {\n            scanf(\"%d,%d,%d\", &es[i].u, &es[i].v, &es[i].cost);\n        }\n        cout << kruskal() << endl;\n        cin >> V;\n    }\n\n    return 0;\n}\n\n\nint kruskal()\n{\n    sort(es, es + E, comp);\n    init(V);\n    int res = 0;\n    for (int i = 0; i < E; i++) {\n        edge e = es[i];\n        if (!same(e.u, e.v)) {\n            unite(e.u, e.v);\n            if (e.cost < 100) {\n                res += 1;\n            } else {\n                res += (e.cost-1) / 100;\n            }\n        }\n    }\n    return res;\n}\n\nvoid init(int n) \n{\n    for (int i = 0; i < n; i++) {\n        par[i] =  i;\n        rank[i] = 0;\n    }\n}\n\nint find(int x)\n{\n    if (par[x] == x) {\n        return x;\n    } else {\n        return par[x] = find(par[x]);\n    }\n}\n\nvoid unite(int x, int y) \n{\n    x = find(x);\n    y = find(y);\n    if (x == y) {\n        return ;\n    }\n\n    if (rank[x] < rank[y]) {\n        par[x] = y;\n    } else {\n        par[y] = x;\n        if (rank[x] == rank[y]) {\n            rank[x]++;\n        }\n    }\n}\n\nbool same(int x, int y) \n{\n    return find(x) == find(y);\n}\n\nbool comp(const edge& e1, const edge& e2)\n{\n    return e1.cost < e2.cost;\n}"
  },
  {
    "language": "C++",
    "code": "# include <iostream>\n# include <algorithm>\n# include <vector>\n# include <string>\n# include <set>\n# include <map>\n# include <cmath>\n# include <iomanip>\n# include <functional>\n# include <utility>\n# include <stack>\n# include <queue>\n# include <list>\n# include <bitset>\n# include <complex>\n#include<limits.h>\n#include<unordered_map>\n#include<unordered_set>\n#include<deque>\n#include<cstdio>\nint  par[100000];  // ?????????????????????????´? \nint find(int x) { if (par[x] == x)return x; par[x] = find(par[x]); return par[x]; }\nvoid unite(int x, int y) { x = find(x); y = find(y); if (x == y)return; par[x] = y; }\nbool same(int x, int y) { return find(x) == find(y); }\nusing namespace std;\nusing LL = long long;\nusing ULL = unsigned long long;\nconstexpr long long MOD = 1000000000 + 7;\nconstexpr long long INF = 1000000000;\nconst double PI = acos(-1);\nLL n, m, a[100000] = {}, x[10000][3] = {}, ans = 0;\nstruct edge { int cost, to; };\nstruct add { int x, y, z; };\nvector<edge>vec[10000];\nstring S[100],str1,str2;\nint main() {\n\twhile (cin >> n&&n) {\n\tfor(int i=0;i<100000;i++)par[i]=i;  // ????????????????????????\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tint  a, b, c;\n\t\t\tchar z;\n\t\t\tcin >> a >> z >> b >> z >> c;\n\t\t\tx[i][0] = min(a, b), x[i][1] = max(a, b), x[i][2] = c / 100 - 1;\n\t\t}\n\t\tfor (int i = 0; i < m; i++)\n\t\t\tfor (int j = i + 1; j < m; j++) {\n\t\t\t\tif (x[i][2] > x[j][2]) {\n\t\t\t\t\tfor (int h = 0; h < 3; h++) {\n\t\t\t\t\t\tint a = x[i][h];\n\t\t\t\t\t\tx[i][h] = x[j][h];\n\t\t\t\t\t\tx[j][h] = a;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tif (find(x[i][0]) != find(x[i][1])) {\n\t\t\t\tunite(x[i][0], x[i][1]);\n\t\t\t\tans += x[i][2];\n\t\t\t}\n\t\t}\n\t\tcout << ans << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n#define rep(i, n) for(int i = 0; i < n; i++)\n#define FOR(i, s, n) for(int i = s; i <= (int)n; ++i)\n#define per(i, n) for(int i = n; i > 0; i--)\n#define ROF(i, s, n) for(int i = s; i >= (int)n; i--)\n#define FORIT(i, A) for (auto i : A)\n#define PRINT(x) cout << (x) << \"\\n\"\n#define MP make_pair\n#define PB push_back\n#define EACH(i, n) for (__typeof((n).begin()) i = (n).begin(); i != (n).end(); ++i)\n#define SZ(a) int((a).size())\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define SORT(c) sort((c).begin(),(c).end())\n#define CLR(a) memset((a), 0 ,sizeof(a))\n#define NCLR(a) memset((a), -1 ,sizeof(a))\n#define int long long\nstatic const int dx[] = { -1, 0, 1, 0 };\nstatic const int dy[] = { 0, -1, 0, 1 };\ntypedef pair<int,pair<int,int> > PII;\nint n,m;\nint ans;\nint E[15000];\nPII V[150];\n\nsigned main(){\n    while(1){\n        cin>>n;\n        if(n==0)break;\n        cin>>m;\n        rep(i,m){\n            int x,y,z;\n            char c;\n            cin>>x>>c>>y>>c>>z;\n            V[i].first=z;\n            V[i].second.first=x;\n            V[i].second.second=y;\n        }\n        sort(V,V+m);\n        rep(i,m){\n            if(E[V[i].second.first]==1&&E[V[i].second.second]==1)continue;\n            ans+=V[i].first-100;\n            E[V[i].second.first]=1;\n            E[V[i].second.second]=1;\n        }\n        cout<<ans/100<<endl;\n        ans=0;\n        rep(i,n)E[i]=0;\n        rep(i,m){\n            V[i].first=0;\n            V[i].second.first=0;\n            V[i].second.second=0;\n        }\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\n#include<algorithm>\n#include<string>\n#include<queue>\n#include<vector>\n#include<functional>\n#include<cmath>\n#include<map>\n#include<stack>\n#include<set>\n#include<numeric>\n#include<limits>\n#include<iterator>\n\n#define all(x) (x).begin(),(x).end()\n#define rall(x) (x).rbegin(),(x).rend()\n\nusing namespace std;\ntypedef long long ll;\ntypedef pair<int, int> pi;\ntypedef pair<ll, ll> pl;\ntypedef pair<ll, char> plc;\n\nint par[110], rk[110];\nvoid init(int n) {\n\tfor (int i = 1; i <= n; i++) {\n\t\tpar[i] = i;\n\t\trk[i] = 0;\n\t}\n}\n\nint find(int x) {\n\tif (par[x] == x)return x;\n\telse\n\t\treturn par[x] = find(par[x]);\n}\n\nvoid unite(int x, int y) {\n\tx = find(x);\n\ty = find(y);\n\tif (x == y)return;\n\n\tif (rk[x] < rk[y])\n\t\tpar[x] = y;\n\telse {\n\t\tpar[y] = x;\n\t\tif (rk[x] == rk[y])rk[x]++;\n\t}\n}\n\nbool same(int x, int y) {\n\treturn find(x) == find(y);\n}\n\nstruct edge {\n\tll u, v, cost;\n};\n\nbool comp(const edge& e1, const edge& e2) {\n\treturn e1.cost < e2.cost;\n}\n\n\nedge es[110];\nint n, m;\n\nll kruskal() {\n\tsort(es, es + m, comp);\n\tinit(n);\n\tll res = 0;\n\tfor (int i = 0; i < m; i++) {\n\t\tedge e = es[i];\n\t\tif (!same(e.u, e.v)) {\n\t\t\tunite(e.u, e.v);\n\t\t\tres += (e.cost) / 100 - 1;\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\twhile (cin >> n, n) {\n\t\tcin >> m;\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tll a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tes[i].u = a, es[i].v = b, es[i].cost = d;\n\t\t}\n\t\tcout << kruskal() << endl;\n\t}\n\treturn\t0; \n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <iomanip>\n#include <complex>\n#include <string>\n#include <vector>\n#include <list>\n#include <deque>\n#include <stack>\n#include <queue>\n#include <set>\n#include <map>\n#include <bitset>\n#include <functional>\n#include <utility>\n#include <algorithm>\n#include <numeric>\n#include <typeinfo>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cmath>\n#include <climits>\n#include <ctime>\n\nusing namespace std;\n\n#define dump(n) cout<<\"# \"<<#n<<\"=\"<<(n)<<endl\n#define debug(n) cout<<__FILE__<<\",\"<<__LINE__<<\": #\"<<#n<<\"=\"<<(n)<<endl\n#define repi(i,a,b) for(int i=int(a);i<int(b);i++)\n#define rep(i,n) repi(i,0,n)\n#define iter(c) __typeof((c).begin())\n#define foreach(i,c) for(iter(c) i=(c).begin();i!=(c).end();i++)\n#define allof(c) (c).begin(),(c).end()\n#define mp make_pair\n\ntypedef unsigned int uint;\ntypedef long long ll;\ntypedef unsigned long long ull;\ntypedef vector<int> vi;\ntypedef vector<vi> vvi;\ntypedef vector<string> vs;\ntypedef pair<int,int> pii;\n\nstruct Edge{\n\tint src,dst,weight;\n\tEdge(){}\n\tEdge(int s,int d,int w):src(s),dst(d),weight(w){}\n};\n\nbool operator<(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight<rhs.weight;\n}\n\nbool operator>(const Edge& lhs,const Edge& rhs)\n{\n\treturn lhs.weight>rhs.weight;\n}\n\ntypedef vector<Edge> Edges;\ntypedef vector<Edges> Graph;\n\nstruct UnionFind{\n\tvi data;\n\tUnionFind(int size):data(size,-1){}\n\tint Find(int n){\n\t\treturn data[n]<0?n:(data[n]=Find(data[n]));\n\t}\n\tvoid Union(int n1,int n2){\n\t\tint d1=Find(n1);\n\t\tint d2=Find(n2);\n\t\tif(d1!=d2){\n\t\t\tif(-data[d1]<-data[d2])\n\t\t\t\tswap(d1,d2);\n\t\t\tdata[d1]+=data[d2];\n\t\t\tdata[d2]=d1;\n\t\t}\n\t}\n\tint Size(int n){\n\t\treturn -data[Find(n)];\n\t}\n};\n\n//int Kruskal(Graph& g,Edges& e)\n//{\n//\te.clear();\n//\t\n//\tUnionFind uf(g.size());\n//\tset<Edge> s;\n//\trep(i,g.size())\n//\t\trep(j,g[i].size())\n//\t\t\ts.insert(g[i][j]);\n//\t\n//\tint res=0;\n//\tforeach(i,s){\n//\t\tif(uf.Find(i->src)!=uf.Find(i->dst)){\n//\t\t\tuf.Union(i->src,i->dst);\n//\t\t\tres+=i->weight;\n//\t\t\te.push_back(*i);\n//\t\t}\n//\t}\n//\t\n//\treturn res;\n//}\n\n//pair<Weight, Edges> minimumSpanningForest(const Graph &g) {\npair<int, Edges> minimumSpanningForest(const Graph &g) {\n  int n = g.size();\n  UnionFind uf(n);\n  //priority_queue<Edge> Q;\n  priority_queue<Edge,vector<Edge>,greater<Edge> > Q;\n  //rep(u, n) foreach(e, g[u]) if (u < e->dst) Q.push(*e);\n  rep(u, n) foreach(e, g[u]) Q.push(*e);\n  //set<Edge> s;\n  //rep(i,g.size())rep(j,g[i].size())s.insert(g[i][j]);\n\n  //Weight total = 0;\n  int total = 0;\n  Edges F;\n  while (F.size() < n-1 && !Q.empty()) {\n    Edge e = Q.top(); Q.pop();\n  //foreach(i,s){\n  //  Edge e=*i;\n    //if (uf.unionSet(e.src, e.dst)) {\n    //  F.push_back(e);\n    //  total += e.weight;\n    //}\n\tif(uf.Find(e.src)!=uf.Find(e.dst)){\n\t\tuf.Union(e.src,e.dst);\n\t\tF.push_back(e);\n\t\ttotal+=e.weight;\n\t}\n  }\n  //return pair<Weight, Edges>(total, F);\n  return pair<int, Edges>(total, F);\n}\n\nostream& operator<<(ostream& os,const vi& a)\n{\n\trep(i,a.size())\n\t\tprintf(\"%d%s\",a[i],i==a.size()-1?\"\":\" \");\n\treturn os;\n}\n\nint main()\n{\n\tfor(int n,m;cin>>n>>m,n;){\n\t\tGraph g(n);\n\t\trep(i,m){\n\t\t\tint src,dst,weight;\n\t\t\tscanf(\"%d,%d,%d\",&src,&dst,&weight);\n\t\t\tg[src].push_back(Edge(src,dst,weight/100-1));\n\t\t\tg[dst].push_back(Edge(src,dst,weight/100-1));\n\t\t}\n\t\t//Edges e;\n\t\t//int sum=Kruskal(g,e);\n\t\t////cout<<sum/100-e.size()<<endl;\n\t\t//cout<<sum<<endl;\n\t\t\n\t\tcout<<minimumSpanningForest(g).first<<endl;\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <vector>\n#include <map>\n#include <set>\n#include <stack>\n#include <queue>\n#include <algorithm>\n#include <utility>\n#include <functional>\n#include <sstream>\n#include <iostream>\n#include <cstdio>\n#include <cmath>\n#include <cstdlib>\n#include <cctype>\n#include <string>\n#include <cstring>\n#include <ctime>\n#include <climits>\nusing namespace std;\ninline int toInt(string s) { int v; istringstream sin(s); sin >> v; return v;}\ntemplate<class T> inline string toString(T x) { ostringstream sout; sout << x; return sout.str();}\ntypedef vector<int> vi;\ntypedef vector<vi>  vvi;\ntypedef vector<string> vs;\ntypedef pair<int, int> pii;\ntypedef long long ll;\n#define ALL(a) (a).begin(),(a).end()\n#define RALL(a) (a).rbegin(),(a).rend()\n#define EACH(t,i,c) for(t::iretator i=(c).begin(); i!=(c).end(); ++i)\n#define EXIST(s,e) ((s).find(e)!=(s).end())\n#define FOR(i,a,b) for(int i=(a);i<=(b);++i)\n#define REP(i,n) FOR(i,0,(n)-1)\nconst double EPS = 1e-12;\nconst double PI = acos(-1.0);\n\ntypedef vector<double> vd;\nconst int INF = INT_MAX/2-1;\n\nstruct state {\n\tint p, c;\n\tstate(int p, int c) : p(p), c(c) {};\n\tbool operator<(const state &o)const {\n\t\treturn c>o.c;\n\t}\n};\n\nint main() {\n\tint n;\n\twhile(cin >> n, n) {\n\t\tint m;\n\t\tcin >> m;\n\t\tvvi cost(n, vi(n, INF));\n\t\tint a, b, d;\n\t\tchar c;\n\t\tREP(i, m) {\n\t\t\tcin >> a >> c >> b >> c >> d;\n\t\t\tcost[a][b] = d/100-1;\n\t\t\tcost[b][a] = d/100-1;\n\t\t}\n\n\t\tvi used(n, 0);\n\t\tpriority_queue<state> Q;\n\t\tQ.push(state(0, 0));\n\t\tint ans = 0;\n\t\twhile(!Q.empty()) {\n\t\t\tstate st = Q.top();\n\t\t\tQ.pop();\n\t\t\t\n\t\t\tif(used[st.p]) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tused[st.p] = true;\n\t\t\tans += st.c;\n\n\t\t\tREP(i, n) {\n\t\t\t\tif(cost[st.p][i] != INF && st.p != i) {\n\t\t\t\t\tQ.push(state(i, cost[st.p][i]));\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcout << ans << endl;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <sstream>\n#include <algorithm>\n#include <queue>\n#include <utility>\n#include <vector>\n#include <string>\nusing namespace std;\n\nconst int N_MAX = 100;\nconst int INF = (int)1e9;\n\nstruct Edge {\n    int to, cost;\n    Edge(int t, int c) : to(t), cost(c) {}\n    bool operator <(const Edge &e) const {\n        return cost > e.cost;\n    }\n};\n\nbool used[N_MAX];\n\nint main() {\n    for(int N; cin >> N, N; ) {\n        int M; cin >> M;\n        cin.ignore();\n\n        vector<Edge> D[N_MAX];\n\n        for(int i = 0; i < M; i++) {\n            string s; getline(cin, s);\n            for(int j = 0; j < (int)s.length(); j++) if(s[j] == ',') s[j] = ' ';\n            istringstream is(s);\n            int a, b, cost;\n            is >> a >> b >> cost;\n\n            D[a].push_back(Edge(b, cost / 100 - 1));\n            D[b].push_back(Edge(a, cost / 100 - 1));\n        }\n\n        fill(used, used + N, false);\n\n        priority_queue<Edge> Q;\n        Q.push(Edge(0, 0));\n\n        int total = 0;\n\n        while(!Q.empty()) {\n            Edge e = Q.top(); Q.pop();\n\n            if(used[e.to]) continue;\n\n            used[e.to] = true;\n            total += e.cost;\n\n            for(Edge ne : D[e.to]) {\n                if(used[ne.to]) continue;\n                Q.push(ne);\n            }\n\n        }\n\n        cout << total << endl;\n    }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <algorithm>\n#include <vector>\n#include <queue>\n#include <string>\n\nusing namespace std;\n\nstruct edge { int to, cost; };\ntypedef pair<int, int> P;\n\nconst int INF = 1e+9;\nconst int MAX_V = 100;\n\nint n, m;\n\nint V;\nvector<edge> G[MAX_V];\nint d[MAX_V];\n\nint prim(){\n\tbool vis[MAX_V];\n\tV = n;\n\tint res = 0;\n\tpriority_queue<P, vector<P>, greater<P> > que;\n\tfill(d, d + V, INF);\n\tfill(vis, vis + V, false);\n\td[0] = 0;\n\tque.push(P(0, 0));\n\twhile(!que.empty()){\n\t\tP p = que.top(); que.pop();\n\t\tint v = p.second;\n\t\tif(vis[v]) continue;\n\t\tvis[v] = true;\n\t\tres += p.first;\n\t\tfor(int i=0;i<G[v].size();i++){\n\t\t\tedge e = G[v][i];\n\t\t\tif(d[e.to] > e.cost){\n\t\t\t\td[e.to] = e.cost;\n\t\t\t\tque.push(P(e.cost, e.to));\n\t\t\t}\n\t\t}\n\t}\n\treturn res;\n}\n\n\n/*\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint prim(){\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\t\n\twhile( true ){\n\t\tint v = -1;\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tif( !used[u] && (v == -1 || mincost[u] < mincost[v]) ){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tmincost[u] = min( mincost[u] , cost[v][u] );\n\t\t}\n\t}\n\treturn res;\n}\n*/\n// 文字列sを文字c区切りで分割して返す\nvector<string> split_string(string s, char c){\n\tstring str;\n\tvector<string> vs;\n\ts.push_back( c );\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == c ){\n\t\t\tif( !str.empty() ){\n\t\t\t\tvs.push_back( str );\n\t\t\t\tstr.clear();\n\t\t\t}\n\t\t}else{\n\t\t\tstr.push_back( s[i] );\n\t\t}\n\t}\n\treturn vs;\n}\n\n// stringをintに変換\nint s_to_i(string s){\n\tint n=0;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tn *= 10;\n\t\tn += s[i] - '0';\n\t}\n\treturn n;\n}\n\nvoid add_edge(int u, int v, int c){\n\tG[u].push_back((edge){v, c});\n\tG[v].push_back((edge){u, c});\n\t//cost[u][v] = cost[v][u] = c;\n}\n\nvoid init(){\n\tfor(int i=0;i<MAX_V;i++) G[i].clear();\n\t//fill(cost[0], cost[MAX_V], INF);\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tinit();\n\t\tcin >> m;\n\t\tcin.ignore();\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tstring s;\n\t\t\tgetline(cin,s);\n\t\t\tvector<string> vs = split_string( s , ',' );\n\t\t\tint u = s_to_i( vs[0] );\n\t\t\tint v = s_to_i( vs[1] );\n\t\t\tint c = (s_to_i( vs[2] ) - 100) / 100;\n\t\t\tadd_edge(u, v, c);\n\t\t}\n\t\tint ans = prim();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <algorithm>\nusing namespace std;\n\nint n, m;\n\nconst int INF = 1e+9;\nconst int MAX_V = 100;\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint prim(){\n\tfor(int i=0 ; i < n ; i++ ){\n\t\tmincost[i] = INF;\n\t\tused[i] = false;\n\t}\n\tmincost[0] = 0;\n\tint res = 0;\n\t\n\twhile( true ){\n\t\tint v = -1;\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tif( !used[u] && (v == -1 || mincost[u] < mincost[v]) ){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(v == -1) break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\t\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tmincost[u] = min( mincost[u] , cost[v][u] );\n\t\t}\n\t}\n\treturn res;\n}\n\n// ツ閉カツ篠堋療アsツづーツ閉カツ篠喞ツ凝ヲツ静伉づィツづ閉ェツ環つオツづ陛板つキ\nvector<string> split_string(string s, char c){\n\tstring str;\n\tvector<string> vs;\n\ts.push_back( c );\n\t\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tif( s[i] == c ){\n\t\t\tif( !str.empty() ){\n\t\t\t\tvs.push_back( str );\n\t\t\t\tstr.clear();\n\t\t\t}\n\t\t}else{\n\t\t\tstr.push_back( s[i] );\n\t\t}\n\t}\n\treturn vs;\n}\n\n// stringツづーintツづ可陛渉環キ\nint s_to_i(string s){\n\tint n=0;\n\tfor(int i=0 ; i < s.size() ; i++ ){\n\t\tn *= 10;\n\t\tn += s[i] - '0';\n\t}\n\treturn n;\n}\n\nint main(){\n\twhile( cin >> n , n ){\n\t\tfor(int u=0 ; u < n ; u++ ){\n\t\t\tfor(int v=0 ; v < n ; v++ ){\n\t\t\t\tcost[u][v] = cost[v][u] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tcin >> m;\n\t\tcin.ignore();\n\t\tfor(int i=0 ; i < m ; i++ ){\n\t\t\tstring s;\n\t\t\tgetline(cin,s);\n\t\t\tvector<string> vs = split_string( s , ',' );\n\t\t\tint u = s_to_i( vs[0] );\n\t\t\tint v = s_to_i( vs[1] );\n\t\t\tint c = (s_to_i( vs[2] ) - 100) / 100;\n\t\t\tcost[u][v] = cost[v][u] = c;\n\t\t}\n\t\tint ans = prim();\n\t\tcout << ans << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\n#define loop(i,a,b) for(int i=a;i<b;i++)\n#define rep(i,a) loop(i,0,a)\n#define INF 100000LL\nusing namespace std;\n\nint main(){\n\tint n,m,a,b,d;\n\twhile(1){\n\t\tcin>>n;\n\t\tif(n==0)break;\n\t\tcin>>m;\n\t\tlong long dist[n][n],dp[n][n];\n\t\trep(i,n)rep(j,n)dist[i][j]=dp[i][j]=(i==j?0:INF);\n\t\trep(i,m){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\t\tdist[a][b]=dist[b][a]=d/100-1;\n\t\t}\n\t\trep(k,n){\n\t\t\trep(i,n){\n\t\t\t\trep(j,n){\n\t\t\t\t\tdp[i][j]=min(dp[i][j],dp[i][k]+dist[k][j]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tlong long num=INF;\n\t\trep(i,n){\n\t\t\tlong long sum=0;\n\t\t\trep(j,n)sum+=dp[i][j];\n\t\t\tif(sum<num)num=sum;\n\t\t}\n\t\tcout<<num<<endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <utility>\n#include <algorithm>\nusing namespace std;\n\nclass data {\n\tpublic:\n\t\tint a, b;\n\t\tint c;\n\n\t\tdata(int p1, int p2, int cost) {\n\t\t\ta = p1;\n\t\t\tb = p2;\n\t\t\tc = cost;\n\t\t}\n\n\t\tbool operator<(const data & c_) const {\n\t\t\treturn c > c_.c;\n\t\t}\n};\n\nint n, m;\nvector<data> cost;\nvector<data> modefied_cost;\nvector<vector<int> > used_point;\n\nvoid init() {\n\tcost.clear();\n\tmodefied_cost.clear();\n\tused_point.clear();\n}\n\nbool input() {\n\tcin >> n;\n\tif(!n)\n\t\treturn false;\n\n\tcin >> m;\n\tfor(int i = 0; i < m; i++) {\n\t\tint a, b, c;\n\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\tcost.push_back(data(a, b, c));\n\t}\n\n\treturn true;\n}\n\nvoid modefy_cost() {\n\tfor(int i = 0; i < cost.size(); i++) {\n\t\tmodefied_cost.push_back(data(cost[i].a, cost[i].b, cost[i].c / 100 - 1));\n\t}\n}\n\npair<pair<int,int>,pair<int,int> > find_point(data d) {\n\tpair<pair<int, int>, pair<int, int> > ij_pair(pair<int,int>(-1, -1), pair<int,int>(-2, -2));\n\tfor(int i = 0; i < used_point.size(); i++) {\n\t\tfor(int j = 0; j < used_point[i].size(); j++) {\n\t\t\tif(used_point[i][j] == d.a) {\n\t\t\t\tij_pair.first.first = i;\n\t\t\t\tij_pair.first.second = j;\n\t\t\t}\n\t\t\telse if(used_point[i][j] == d.b) {\n\t\t\t\tij_pair.second.first = i;\n\t\t\t\tij_pair.second.second = j;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn ij_pair;\n}\n\nint solve() {\n\tmodefy_cost();\n\tsort(modefied_cost.begin(), modefied_cost.end());\n\tint ans = 0;\n\n\tfor(int i = 1; i < modefied_cost.size(); i++) {\n\t\tpair<pair<int,int>,pair<int,int> > tmp;\n\t\ttmp = find_point(modefied_cost[i]);\n\n\t\tif(tmp.first.first == tmp.second.first)\n\t\t\tcontinue;\n\n\t\telse if(tmp.first.first > -1 && tmp.second.first < 0) {\n\t\t\tused_point[tmp.first.first].push_back(modefied_cost[i].b);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse if(tmp.first.first < 0 && tmp.second.first > -1) {\n\t\t\tused_point[tmp.second.first].push_back(modefied_cost[i].a);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse if(tmp.first.first > -1 && tmp.second.first > -1) {\n\t\t\tused_point[tmp.first.first].insert(used_point[tmp.first.first].end(),\n\t\t\t\t\tused_point[tmp.second.first].begin(), used_point[tmp.second.first].end());\n\t\t\tused_point.erase(used_point.begin() + tmp.second.first, used_point.begin() + tmp.second.first + 1);\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t\telse {\n\t\t\tused_point.push_back(vector<int>(modefied_cost[i].a, modefied_cost[i].b));\n\t\t\tans += modefied_cost[i].c;\n\t\t}\n\t}\n\treturn ans;\n}\n\nint main() {\n\twhile(init(), input()) {\n\t\tcout << solve() << endl;\n\t}\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<cstdlib>\n#include<cmath>\n#include<cstring>\n#include<cctype>\n#include<complex>\n#include<iostream>\n#include<sstream>\n#include<algorithm>\n#include<functional>\n#include<vector>\n#include<string>\n#include<stack>\n#include<queue>\n#include<map>\n\nusing namespace std;\nconst int dx[] = {1,0,-1,0},dy[] = {0,1,0,-1};\n#define INF 1e+8\n#define rep(i,j) for(int i = 0; i < (j); i++)\n#define reps(i,j,k) for(int i = j; i < k; i++)\ntypedef long long ll;\ntypedef unsigned long long ull;\nint cost[128][128];\nint mincost[128];\nbool used[128];\nint V,E;\nvoid init(){\n\trep(i,V)rep(j,V)cost[i][j] = INF;\n\tfill(mincost,mincost+V,INF);\n\tfill(used,used+V,false);\n}\nint prim(){\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile(true){\n\t\tint v = -1;\n\t\trep(u,V)if(!used[u] && (v == -1 || mincost[u] < mincost[v]))v = u;\n\t\tif(v == -1)break;\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\trep(u,V)mincost[u] = min(mincost[u],cost[v][u]);\n\t}\n\treturn res;\n}\nint main(){\n\tint n,m;\n\twhile(scanf(\"%d\",&n),n){\n\t\tscanf(\"%d\",&m);\n\t\tV = n;\n\t\tinit();\n\t\trep(i,m){\n\t\t\tint from,to,pay;\n\t\t\tscanf(\"%d,%d,%d\",&from,&to,&pay);\n\t\t\tcost[from][to] = pay-100;\n\t\t\tcost[to][from] = pay-100;\n\t\t}\n\t\tint ans = prim();\n\t\tprintf(\"%d\\n\",ans/100);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <numeric>\n#include <algorithm>\nusing namespace std;\n\nint ma[100][100];\n\nint main() {\n\tint n, m, a, b, d;\n\tchar t;\n\twhile (cin >> n) {\n\t\tif (n == 0) break;\n\t\tcin >> m;\n\n\t\tfill(ma[0], ma[100], 114514810);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tcin >> a >> t >> b >> t >> d;\n\t\t\tma[a][b] = ma[b][a] = (d - 100) / 100;\n\t\t}\n\n\t\tbool v[100] = {false};\n\t\tv[0] = true;\n\t\td = 0;\n\t\tfor (int i = 0; i < n - 1; i++) {\n\t\t\tm = 114514810;\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tif (ma[0][j] < m && !v[j]) {\n\t\t\t\t\tm = ma[0][j];\n\t\t\t\t\tb = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv[b] = true;\n\t\t\td += ma[0][b];\n\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\tma[0][j] = min(ma[0][j], ma[b][j]);\n\t\t\t}\n\t\t}\n\t\tcout << d << endl;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\n\nint inf=1<<21;\nint mst[20][20];\nint n;\n\nint prim_souwa(int G[20][20]){\n    int d[n],vstd[n];\n    int u=0,sum=0;\n    fill(d,d+n,inf);\n    fill(vstd,vstd+n,0);\n    d[0]=0;\n    while(true){\n        int mini=inf;\n        for(int i=0; i<n; i++){\n            if(mini>d[i]&&vstd[i]==0){\n                mini=d[i];\n                u=i;\n            }\n        }\n        if(mini==inf)break;\n        sum+=mini;\n        vstd[u]=1;\n        for(int i=0; i<n; i++){\n            if(G[u][i]<d[i]){\n                d[i]=G[u][i];\n            }\n        }\n    }\n    return sum;\n}\n\nint main(){\n    int m;\n    int G[20][20];\n    while(cin>>n,n){\n        cin>>m;\n        fill(G[0],G[20],inf);\n        for(int i=0; i<m; i++){\n            int in1,in2,in3;\n            scanf(\"%d,%d,%d\",&in1,&in2,&in3);\n            G[in1][in2]=in3;\n            G[in2][in1]=in3;\n        }\n        cout<<prim_souwa(G)/100-(n-1)<<endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <bits/stdc++.h>\n#define range(i, a, n) for(int (i) = (a); (i) < (n); (i)++)\n#define rep(i, n) for(int (i) = 0; (i) < (n); (i)++)\nusing namespace std;\n\ntypedef pair<int, int> P;\n\nint V; // the number of node\n\nint prim (vector<vector<P> > G) {\n    set<int> used;\n    priority_queue<P, vector<P>, greater<P> > que;\n    for (int i = 0; i < V; i++) {\n        used.insert(i);\n    }\n    int res = 0;\n    int v = 0;\n    while (!used.empty()) {\n        for (auto i : G[v])   que.push(i);\n        P p;\n        while (used.find(que.top().second) == used.end() || que.top().second == v) {\n            que.pop();\n            if (que.empty()) break;\n        }\n        if (que.empty()) break;\n        used.erase(used.find(v));\n        p = que.top(); que.pop();\n        v = p.second;\n        res += p.first;\n    }\n \n    return res;\n}\n\nint main(void){\n    for(; cin >> V, V;){\n        int m; cin >> m;\n        vector<vector<P>> p(V);\n        rep(loop, m){\n            int a, b, d; char c;\n            cin >> a >> c >> b >> c >> d;\n\n            p[a].push_back(P(d, b));\n            p[b].push_back(P(d, a));\n        }\n\n        cout << prim(p) / 100 - (V - 1) << endl;\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nunsigned int G[100][100];\nchar use_v[100];\n\nint main(void)\n{\n\tint v, e;\n\tint ans;\n\t\n\twhile (1){\n\t\tmemset(G, -1, sizeof(G));\n\t\tmemset(use_v, 0, sizeof(use_v));\n\t\t\n\t\tscanf(\"%d\", &v);\n\t\tif (v == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &e);\n\t\tfor (int i = 0; i < e; i++){\n\t\t\tint a, b, c;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &c);\n\t\t\t\n\t\t\tG[a][b] = c / 100 - 1;\n\t\t\tG[b][a] = c / 100 - 1;\n\t\t}\n\t\t/*\n\t\tfor (int i = 0; i < v; i++){\n\t\t\tfor (int j = 0; j < v; j++){\n\t\t\t\tprintf(\"%d \", G[i][j]);\n\t\t\t}\n\t\t\tputs(\"\");\n\t\t}*/\n\t\tans = 0;\n\t\tuse_v[0] = 1;\n\t\twhile (1){\n\t\t\tint i, j;\n\t\t\tint min;\n\t\t\tint min_e;\n\t\t\t\n\t\t\tfor (i = 0; i < v; i++){\n\t\t\t\tif (use_v[i] == 0){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == v){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tmin = 100000000;\n\t\t\tfor (i = 0; i < v; i++){\n\t\t\t\tif (use_v[i] == 1){\n\t\t\t\t\tfor (j = 0; j < v; j++){\n\t\t\t\t\t\tif (min > G[i][j] && use_v[j] == 0){\n\t\t\t\t\t\t\tmin = G[i][j];\n\t\t\t\t\t\t\tmin_e = j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tuse_v[min_e] = 1;\n\t\t\tans += min;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <queue>\n#include <deque>\n#include <set>\n#include <map>\n#include <algorithm>\t// require sort next_permutation count __gcd reverse etc.\n#include <cstdlib>\t// require abs exit atof atoi \n#include <cstdio>\t\t// require scanf printf\n#include <functional>\n#include <numeric>\t// require accumulate\n#include <cmath>\t\t// require fabs\n#include <climits>\n#include <limits>\n#include <cfloat>\n#include <iomanip>\t// require setw\n#include <sstream>\t// require stringstream \n#include <cstring>\t// require memset\n#include <cctype>\t\t// require tolower, toupper\n#include <fstream>\t// require freopen\n#include <ctime>\t\t// require srand\n#define rep(i,n) for(int i=0;i<(n);i++)\n#define ALL(A) A.begin(), A.end()\n\nusing namespace std;\n\nstruct edge {\n\tint u, v, cost;\n};\n\n\ntypedef long long ll;\ntypedef pair<int, int> P;\nconst int MAX_N = 100;\nconst int MAX_E = 100*99/2;\nint par[MAX_N];\nint rank[MAX_N];\nedge es[MAX_E];\n\nint V, E;\t//  頂点数と辺数\n\n// n要素で初期化\nint init_union_find (int n )\n{\n\trep (i, n ){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t} // end for\n}\n\n// 木の根を求める\nint find (int x )\n{\n\tif (par[x] == x )\n\t\treturn x;\n\n\t// 親を遡る\n\treturn par[x] = find (par[x] );\n}\n\n// xとyの属する集合をマージ\nvoid unite (int x, int y )\n{\n\tx = find (x);\n\ty = find (y);\n\n\t// 親が一緒なら何もしない\n\tif (x == y )\n\t\treturn;\n\n\t// ランクが小さい方の木をぶら下げる\n\tif (rank[x] < rank[y] ){\n\t\t// x を y にぶら下げる\n\t\tpar[x] = y;\n\t}else{\n\t\t// ランクが同じか rank[x] > rank[y]\n\t\tpar[y] = x;\n\t\tif (rank[x] == rank[y] )\n\t\t\trank[x]++;\n\t} // end if\n}\n\n// xとyが同じ集合に属するか否か\nbool same (int x, int y )\n{\n\treturn (find (x) == find (y) );\n}\n\n\n\nbool comp (const edge& e1, const edge& e2 )\n{\n\treturn e1.cost < e2.cost;\n}\n\nint kruskal (void )\n{\n\tsort (es, es + E, comp );\n\tinit_union_find (V );\n\tint res = 0;\n\trep (i, E ){\n\t\tedge e = es[i];\n\t\tif (!same (e.u, e.v ) ){\n\t\t\tunite (e.u, e.v );\n\t\t\tres += e.cost;\n\t\t} // end if\n\t} // end rep\n\n\treturn res;\n}\n\nint main()\n{\n//\tcut here before submit \n//\tfreopen (\"testcase.carden_lentern\", \"r\", stdin );\n\tint n;\n\twhile (scanf (\"%d\", &n ), n ){\n\t\tint m;\n\t\tscanf (\"%d\", &m );\n\t\tset<int> cnt_V; cnt_V.clear();\n\t\trep (i, m ){\n\t\t\tint from, to, cost;\n\t\t\tscanf (\"%d,%d,%d\", &from, &to, &cost );\n\t\t\tcnt_V.insert (from ); cnt_V.insert (to );\n\t\t\tes[i].u = from; es[i].v = to; es[i].cost = cost; \n\t\t} // end rep\n\t\tE = m;\n\t\tV = cnt_V.size();\n\t\tint ans = kruskal();\t// 最小全域木の経路の長さ\n\t\tint res = ans/100 - (V-1);\n\t\tprintf (\"%d\\n\", res );\n\t} // end loop\n\n\treturn 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nstruct Road {\n    int a, b;\n    int dist;\n\n    bool operator < (const Road &other) const {\n        return dist < other.dist;\n    }\n};\n\nint getroot(int i, vector<int> &roots) {\n    if(roots[i] == i) return i;\n    return roots[i] = getroot(roots[i], roots);\n}\n\nvoid unite(int i, int j, vector<int> &roots) {\n    roots[getroot(i, roots)] = getroot(j, roots);\n}\n\nint main() {\n    while(true) {\n        int N, M;\n        cin >> N;\n        if(!N) break;\n        cin >> M;\n\n        vector<Road> roads(M);\n        char comma;\n        for(int i = 0; i < M; ++i) \n            cin >> roads[i].a >> comma >> roads[i].b >> comma >> roads[i].dist;\n        sort(roads.begin(), roads.end());\n\n        int ans = 0;\n        vector<int> roots(N);\n        for(int i = 0; i < N; ++i) roots[i] = i;\n        for(int i = 0; i < M; ++i) {\n            const Road &r = roads[i];\n            if(getroot(r.a, roots) == getroot(r.b, roots)) continue;\n            unite(r.a, r.b, roots);\n            ans += r.dist/100 - 1;\n        }\n        cout << ans << endl;\n    }\n    return 0;\n}"
  },
  {
    "language": "C++",
    "code": "#include<cstdio>\n#include<iostream>\nusing namespace std;\n\n#define MAX_V 111\n#define INF 11111111\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\n\n\nint prim(void);\nint min(int a,int b);\n\nint main(){\n  int m;\n\n  scanf(\"%d\",&V);\n\n  while(1){\n    if(V==0) break;\n    scanf(\"%d\",&m);\n    \n    for(int i=0;i<m;i++){\n      for(int j=0;j<m;j++){\n\tcost[i][j]=INF;\n      }\n    }\n    \n    for(int i=0;i<m;i++){\n      int a,b,c;\n      scanf(\"%d,%d,%d\",&a,&b,&c);\n      cost[a][b] = c/100 - 1;\n      cost[b][a] = c/100 - 1;\n    }\n    \n    printf(\"%d\\n\",prim());\n    \n    scanf(\"%d\",&V);\n  }\n  \n  return 0;\n}\n\nint min(int a,int b){\n  if(a>b) return b;\n  return a;\n}\n\nint prim(void){\n  for(int i=0;i<V;i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  \n  mincost[0] = 0;\n\n  int res = 0;\n  \n  while(true){\n    int v = -1;\n    for(int u=0;u<V;u++){\n      if(!used[u] && (v==-1 || mincost[u] < mincost[v])) v = u;\n    }\n    \n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    \n    for(int u = 0;u < V;u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<stdio.h>\n#include<vector>\n#define INF 2147483647\nusing namespace std;\n\nclass Lantern{\npublic:\n\tbool vector_find(vector<int> v,int key){\n\t\tfor(int i=0;i<v.size();i++){\n\t\t\tif(v[i]==key){return 1;}\n\t\t}\n\t\treturn 0;\n\t}\n\tint Solve(int n, int roadlist[100][100] ){\n\t\tint ans=0,i,j;\n\t\tvector<int> V;\n\t\tV.push_back(0);\n\t\twhile(V.size()!=n){\n\t\t\tint u,v,min=INF;\n\t\t\tfor(i=0;i<V.size();i++){\n\t\t\t\tfor(j=0;j<n;j++){\n\t\t\t\t\tif(!vector_find(V,j)&&roadlist[i][j]<min){\n\t\t\t\t\t\tu=i,v=j;\n\t\t\t\t\t\tmin=roadlist[i][j];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tans+=min;\n\t\t\tV.push_back(v);\n\t\t}\n\t\treturn ans;\n\t}\n\n};\n\nint main(){\n\tint n,m;\n\tint rlist[100][100];\n\tLantern lantern;\n\twhile(1){\n\t\tfor(int i=0;i<100;i++){\n\t\t\tfor(int j=0;j<100;j++){\n\t\t\t\trlist[i][j]=INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0){break;}\n\t\tscanf(\"%d\",&m);\n\t\tfor(int i=0;i<m;i++){\n\t\t\tint a,b,c;\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&c);\n\t\t\trlist[a][b]=rlist[b][a]=c/100-1;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\",lantern.Solve(n,rlist));\n\t\t\n\t}\n\t\n\t\n\t\n}\n\t\n\t"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<algorithm>\n#define MAX_V 100\n#define INF (1<<21)\nusing namespace std;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\nint V;\nint prim(){\n  for(int i = 0; i < V; i++){\n    mincost[i] = INF;\n    used[i] = false;\n  }\n  mincost[0] = 0;\n  int res = 0;\n  while(1){\n    int v = -1;\n    for(int u = 0; u < V; u++){\n      if(!used[u] && (v == -1 || mincost[u] < mincost[v])) v = u;\n    }\n    if(v == -1) break;\n    used[v] = true;\n    res += mincost[v];\n    for(int u = 0; u < V; u++){\n      mincost[u] = min(mincost[u], cost[v][u]);\n    }\n  }\n  return res;\n}\n\nint main(){\n  int m;\n  while(1){\n    cin >> V;\n    if(V == 0) break;\n    for(int i = 0; i < V; i++){\n      for(int j = 0; j < V; j++){\n\tcost[i][j] = INF;\n      }\n    }\n    cin >> m;\n    for(int i = 0; i < m; i++){\n      int a, b, c;\n      char d, e;\n      cin >> a >> d >> b >> e >> c;\n      cost[a][b] = c;\n      cost[b][a] = c;\n    }\n    int t = prim();\n    t = t / 100 - V + 1;\n    cout << t << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<iostream>\n#include<cstdio>\nusing namespace std;\n\nconst int MAX_V = 100;\nconst int INF = 100000;\n\nint cost[MAX_V][MAX_V];\nint mincost[MAX_V];\nbool used[MAX_V];\n\nint prim(int V) {\n  for (int i = 0; i < V; i++) {\n    mincost[i] = INF;\n    used[i] = false;\n  }\n\n  mincost[0] = 0;\n  int res = 0;\n\n  while(true) {\n    int v = -1;\n    for (int u = 0; u < V; u++) {\n      if (! used[u] and (v == -1 or mincost[u] < mincost[v]))\n        v = u;\n    }\n\n    if (v == -1)\n      break;\n\n    used[v] = true;\n\n    res += mincost[v];\n\n    for (int u = 0; u < V; u++)\n      mincost[u] = min(mincost[u], cost[v][u]);\n  }\n\n  return res;\n}\n\nint main() {\n  int n;\n  while (cin >> n and n != 0) {\n    for (int i = 0; i < n; i++)\n      for (int j = 0; j < n; j++)\n        cost[i][j] = INF;\n\n    int m, a, b, dist;\n    cin >> m;\n\n    for(int i = 0; i < m; i++) {\n      scanf(\"%d,%d,%d\", &a, &b, &dist);\n      dist = dist / 100 - 1;\n      cost[a][b] = cost[b][a] = dist;\n    }\n\n    int val = prim(n);\n\n    cout << val << endl;\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <string>\n#include <stack>\n#include <map>\n#include <algorithm>\n#include <iomanip>\n#include <cmath>\n#include <queue>\nusing namespace std;\n\n#define MAXV 1000000000\n#define MOD 1000000007\nusing ll = long long;\n\nbool operator<(const pair<int, int>& a, const pair<int, int>& b) {\n\tif (a.first == b.first) {\n\t\treturn a.second < b.second;\n\t}\n\treturn a.first < b.first;\n}\n\nstruct Node {\n\tint to, cost;\n};\n\nint main() {\n\n\tint N;\n\twhile (cin >> N) {\n\t\tif (N == 0) break;\n\n\t\tint m; cin >> m;\n\t\tvector<vector<Node>> G(110);\n\t\tint mincost[110];\n\t\tbool used[110];\n\n\t\tfor (int i = 0; i < N; ++i) {\n\t\t\tmincost[i] = 1e9;\n\t\t\tused[i] = false;\n\t\t}\n\t\tfor (int i = 0; i < m; ++i) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\n\t\t\tNode e1, e2;\n\t\t\te1.to = a;\n\t\t\te2.to = b;\n\t\t\t\n\t\t\td /= 100;\n\t\t\td--;\n\t\t\te1.cost = e2.cost = d;\n\n\t\t\tG[a].push_back(e2);\n\t\t\tG[b].push_back(e1);\n\t\t}\n\n\t\tpriority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;\n\n\t\tmincost[0] = 0;\n\n\t\tq.push({ 0, 0 }); //最小コスト 現在位置\n\t\tint res = 0;\n\n\t\twhile (q.size()) {\n\t\t\tpair<int, int> p = q.top();\n\t\t\tq.pop();\n\n\t\t\tint v = p.second;\n\t\t\tif (used[v]) continue;\n\n\t\t\tused[v] = true;\n\t\t\tres += p.first;\n\t\t\tfor (int i = 0; i < G[v].size(); ++i) {\n\t\t\t\tNode e = G[v][i];\n\t\t\t\tif (used[e.to]) continue;\n\t\t\t\tq.push({ e.cost, e.to });\n\t\t\t}\n\t\t}\n\t\tcout << res << endl;\n\t}\n\tint a; cin >> a;\n}\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <cstdio>\n#include <queue>\nusing namespace std;\n\n// ????????????????????£?¨?\nint kruskal(int v, vector<vector<pair<int, int> > > adjlist);\n\n// ?????????\nint main(void){\n  while(true){\n    // ???????????°??¨???????????°???????????????\n    int n, m;\n    cin >> n;\n    if(n == 0){ break; }\n    cin >> m;\n\n    // ???????????±????????????????????£??\\??????????????????\n    vector<vector<pair<int, int> > > adjlist(n);\n    for(int i = 0; i < m; i++){\n      int a, b, d;\n      scanf(\"%d,%d,%d\", &a, &b, &d);\n      adjlist[a].push_back(make_pair(d, b));\n      adjlist[b].push_back(make_pair(d, a));\n    }\n  \n    // ????°???¨?????¨????????????????±??????????????????????\n    int length = kruskal(n, adjlist);\n    cout << length / 100 - n + 1 << endl;\n  }\n\n  return 0;\n}\n\n// UnionFind??¨\nclass UnionFindTree{\nprivate:\n  int m_size;\n  vector<int> parent;\n  vector<int> rank;\n  vector<int> vertices;\n  int find(int a);\npublic:\n  void init(int s);\n  void unite(int a, int b);\n  bool same(int a, int b);\n  bool isConnected(void);\n};\n\n// UF??¨????????????\nvoid UnionFindTree::init(int size){\n  parent.clear();\n  rank.clear();\n  vertices.clear();\n  m_size = size;\n  for(int i = 0; i < size; i++){\n    parent.push_back(i);\n    rank.push_back(0);\n    vertices.push_back(1);\n  }\n  return;\n}\n\n// UF??¨?????????????????????\nint UnionFindTree::find(int a){\n  if(parent[a] != a){ parent[a] = find(parent[a]); }\n  return parent[a];\n}\n\n// UF??¨??§???????????£?????????\nvoid UnionFindTree::unite(int a, int b){\n  int x = find(a);\n  int y = find(b);\n  // ?????§???????????£???????????????????????????\n  if(x == y){ return; }\n\n  if(rank[x] < rank[y]){\n    parent[x] = y;\n    vertices[y] += vertices[x];\n  }\n  else{\n    parent[y] = x;\n    vertices[x] += vertices[y];\n    if(rank[x] == rank[y]){ rank[x]++; }\n  }\n  return;\n}\n\n// UF??¨??§???????????????????????????????????????\nbool UnionFindTree::same(int a, int b){\n  return find(a) == find(b);\n}\n\n// UF??¨??§?????????????????????????????¨???????????????????????????\nbool UnionFindTree::isConnected(void){\n  return vertices[find(0)] == m_size;\n}\n\n// ??????????????????\n// v: ????????°, adjlist: ??£??\\?????????(first: ???????????????, second: ?????????)\nint kruskal(int v, vector<vector<pair<int, int> > > adjlist){\n  int length = 0; // ??¨????????????\n\n  // ??????????????????????????????????????\\????????????\n  priority_queue<pair<int, pair<int, int> > > edge;\n  for(int i = 0; i < v; i++){\n    for(int j = 0; j < adjlist[i].size(); j++){\n      edge.push(make_pair(-adjlist[i][j].first, make_pair(i, adjlist[i][j].second)));\n    }\n  }\n\n  // UF??¨?????£?¨???¨?????????\n  UnionFindTree uf;\n  uf.init(v);\n\n  // ???????????????????????????????????????????????????????????£?????????????????§?????????\n  while(!edge.empty() && !uf.isConnected()){\n    // ????£????????????????????°?????????????????????????\n    int cost = -edge.top().first;\n    int a = edge.top().second.first;\n    int b = edge.top().second.second;\n    edge.pop();\n    // ????????????????????????????????£????????????????£???°???\n    if(uf.same(a, b)){ continue; }\n\n    // UF??¨?????£??????????????????????????´??°\n    uf.unite(a, b);\n    length += cost;\n  }\n\n  // ?????????: ??¨????????????\n  return length;\n}"
  },
  {
    "language": "C++",
    "code": "#include<bits/stdc++.h>\nusing namespace std;\ntypedef long long int ll;\ntypedef pair<ll,ll> mp;\n#define inf 1e9\n\n\nint main(){\t\n\twhile(1){\n\tint n;\n\tint m;\n\tcin>>n;\n\tif(n==0)break;\n\tcin>>m;\n\tvector<vector<mp> > g(n);\n\tvector<bool> used(n,true);\n\tint cnt = 0;\n\tfor(int i=0;i<m;i++){\n\t\tint a,b,d;\n\t\tscanf(\"%d,%d,%d\",&a,&b,&d);\n\t\td/=100;\n\t\td--;\n\t\tg[a].push_back(mp(d,b));\n\t\tg[b].push_back(mp(d,a));\n\t}\n\tpriority_queue<mp,vector<mp>,greater<mp> > q;\n\tused[0] = false;\n\tfor(int i=0;i<g[0].size();i++){\n\t\tq.push(g[0][i]);\n\t}\n\tll res = 0;\n\twhile(!q.empty()){\n\t\tmp now = q.top();\n\t\tq.pop();\n\t\tif(!used[now.second])continue;\n\t\tres+=now.first;\n\t\tll next = now.second;\n\t\tused[next] = false;\n\t\tfor(int i=0;i<g[next].size();i++){\n\t\tif(used[g[next][i].second])q.push(g[next][i]);\n\t\t}\n\n\t}\n\tcout<<res<<endl;\n\t}\n\n\treturn 0;\n}\n\n"
  },
  {
    "language": "C++",
    "code": "#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <cstdlib>\n#include <cstring>\n\nusing namespace std;\n\ntypedef int Weight;\nstruct Edge {\n  int src, dest;\n  Weight weight;\n  Edge(int src, int dest, Weight weight): src(src), dest(dest), weight(weight) {;}\n  bool operator<(const Edge &rhs) const {\n    return weight < rhs.weight;\n  }\n};\n\nstruct UnionFind {\n  int parent[100];\n  UnionFind() {\n    memset(parent, -1, sizeof(parent));\n  }\n\n  bool unite(int x, int y) \n  {\n    x = root(x); y = root(y);\n    if (x == y) return false;\n    if (parent[y] < parent[x]) { swap(x, y); }\n    parent[x] += parent[y];\n    parent[y] = x;\n    return true;\n  }\n\n  bool find(int x, int y) \n  {\n    return root(x) == root(y);\n  }\n\n  int root(int x) \n  {\n    return parent[x] < 0 ? x : parent[x] = root(parent[x]);\n  }\n};\n\nint M, N;\nvector<Edge> es;\nvoid Solve() \n{\n  sort(es.begin(), es.end());\n  UnionFind uf;\n  int res = 0;\n  for (int i = 0; i < M; i++) {\n    Edge e = es[i];\n    if (!uf.find(e.src, e.dest)) {\n      uf.unite(e.src, e.dest);\n      res += (int)(e.weight / 100) - 1;\n    }\n  \n  }\n  cout << res << endl;\n}\n\nint main() \n{\n  int u, v, w;\n  while (cin >> N && N) {\n    cin >> M;\n    es.clear();\n    for (int i = 0; i < M; i++) {\n      scanf(\"%d,%d,%d\", &u, &v, &w);\n      es.push_back(Edge(u, v, w));\n    }\n\n    Solve();\n  }\n}"
  },
  {
    "language": "C++",
    "code": "#include<algorithm>\n#include<vector>\n#include<cstdio>\n\nint par[100], rank[100];\n\nvoid init( int n )\n{\n\tfor( int i = 0; i != n; ++i )\n\t{\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n\n\treturn;\n}\n\nint find( int x )\n{\n\tif( x == par[x] )\n\t\treturn x;\n\telse\n\t\treturn par[x] = find( par[x] );\n}\n\nvoid unite( int x, int y )\n{\n\tx = find( x );\n\ty = find( y );\n\tif( x == y )\n\t\treturn;\n\n\tif( rank[x] < rank[y] )\n\t\tpar[x] = y;\n\telse\n\t{\n\t\tpar[y] = x;\n\t\tif( rank[x] == rank[y] )\n\t\t\t++rank[x];\n\t}\n\n\treturn;\n}\n\nbool same( int x, int y )\n{\n\treturn find( x ) == find( y );\n}\n\nstruct edge{ int from, to, cost; };\n\nstd::vector<edge> es;\n\nbool compare( const edge& lhs, const edge& rhs )\n{\n\treturn lhs.cost < rhs.cost;\n}\n\nint main()\n{\n\tint n, m;\n\twhile( scanf( \"%d\", &n ), n )\n\t{\n\t\tscanf( \"%d\", &m );\n\n\t\tfor( int i = 0; i != m; ++i )\n\t\t{\n\t\t\tint a, b, c;\n\t\t\tscanf( \"%d,%d,%d\", &a, &b, &c );\n\t\t\tedge e = { a, b, c / 100 - 1 };\n\t\t\tes.push_back( e );\n\t\t}\n\n\t\tstd::sort( es.begin(), es.end(), compare );\n\n\t\tinit( n );\n\n\t\tint ans = 0;\n\t\tfor( int i = 0; i != es.size(); ++i )\n\t\t{\n\t\t\tif( !same( es[i].from, es[i].to ) )\n\t\t\t{\n\t\t\t\tunite( es[i].from, es[i].to );\n\t\t\t\tans += es[i].cost;\n\t\t\t}\n\t\t}\n\n\t\tprintf( \"%d\\n\", ans );\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport Data.Ord\n\nmain = interact $ unlines . map (show . carden_lantern . read') . parse . lines\n where\n  parse (\"0\":_) = []\n  parse (_:m:str) = take (read m) str : parse (drop (read m) str)\n  read' = map ((\\[a,b,d]->((a,b),d)) . map read . splitOn ',')\n\ncarden_lantern = count_lantern . cut . reverse . sortBy (comparing snd)\n where\n  cut [] = []\n  cut (abd@((a,b),d):rs)\n   | elem a (map (fst.fst) rs) && elem b (map (snd.fst) rs) =  cut rs\n   | otherwise = abd : cut rs\n  count_lantern rs = sum $ map ((\\d -> div d 100 - 1) . snd) rs\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>))\nimport Control.Monad\nimport Data.List\nimport Data.Array\nimport Data.List.Split (splitOn)\n\nmain :: IO ()\nmain = do\n  n <- getl toInt\n  when (n /= 0) $ do\n    m <- getl toInt\n    xs <- rgetl m $ map toInt . splitOn \",\"\n    print $ solve n xs\n    main\n    \nsolve :: Int -> [[Int]] -> Int\nsolve n xs = mst adj 0 [0] [1..n-1]\n  where\n    adj = foldl (\\ar [i,j,l] -> ar // [((i,j),l),((j,i),l)]) (listArray ((0,0),(n-1,n-1)) $ repeat infty) xs\n    \nmst :: Array (Int,Int) Int -> Int -> [Int] -> [Int] -> Int\nmst adj s us vs\n  | null vs = s\n  | otherwise = mst adj (s + l `div` 100 - 1) (i:us) (delete i vs)\n  where\n    (l,(_,i)) = minimum [(adj ! (u,v),(u,v)) | u <- us, v <- vs]\n\ninfty :: Int\ninfty = 2000000000\n\ntoInt :: String -> Int\ntoInt s = read s\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine\n\nrgetl :: Int -> (String -> a) -> IO [a]\nrgetl n f = map f <$> replicateM n getLine"
  },
  {
    "language": "Haskell",
    "code": "import Data.Ord\nimport Data.List\n\nmain = interact $ unlines . map (show . carden_lantern) . read' . lines\n where\n  read' (\"0\":_) = []\n  read' (n:m:xs) = (read n, map (parse . map read . splitOn ',') edge) : read' xs'\n   where\n    (edge,xs') = splitAt (read m) xs\n    parse [a,b,d] = ((a,b), div d 100)\n\ncarden_lantern (n,edge) = count $ kruskal n $ sortBy (comparing snd) edge\n where count abd =  sum (map snd abd) - length abd\n\nkruskal n edge = makepath (map return [0..n-1]) [] edge\n where\n  makepath ts acc [] = acc\n  makepath ts acc (((a,b),d):abd)\n   | disjoint a b ts = makepath (link a b ts) ((((a,b),d)):acc) abd\n   | otherwise = makepath ts acc abd\n   where\n    disjoint a b = not . any (\\t -> elem a t && elem b t)\n    link a b ts = let (ab,ts') = partition (\\t -> elem a t || elem b t) ts in concat ab : ts'\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport Data.Foldable (foldMap)\nimport Data.List.Split\nimport Data.Char\nimport Data.Ratio\nimport Data.Ord\nimport Data.Array.IO\nimport Data.IORef\n \nreadInt = read :: String -> Int\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napplyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\napplyBin op f g x = op (f x) $ g x\napplyUni :: (a -> b -> c) -> (a -> b) -> a -> c\napplyUni op f x = op x $ f x\napplyTuple :: (a -> b, a -> c) -> a -> (b, c)\napplyTuple (f,g) a = (f a, g a)\n-- end of templete\n\ntype UnionFind = IOUArray Int Int\nnewUnionFind :: Int -> IO UnionFind\nnewUnionFind n = newArray (0,n-1) (-1)\nroot :: UnionFind -> Int -> IO Int\nroot uf i = do\n    p <- readArray uf i\n    if p<0 then return i else root uf p\nsame :: UnionFind -> Int -> Int -> IO Bool\nsame uf i j = (==) <$> root uf i <*> root uf j\nunite :: UnionFind -> Int -> Int -> IO ()\nunite uf i j = root uf i >>= writeArray uf j\n\nmain = do\n    n <- getInt\n    when (n/=0) $ do\n        m <- getInt\n        list <- sortBy (on compare (!!2)) . map (map readInt . wordsBy (==',')) <$> replicateM m getLine\n        ref <- newIORef 0\n        uf <- newUnionFind n\n        forM_ list $ \\[a,b,d] -> do\n            c <- not <$> same uf a b\n            when c $ do\n                unite uf a b\n                modifyIORef ref (+(div d 100 - 1))\n        readIORef ref >>= print\n        main"
  },
  {
    "language": "Haskell",
    "code": "import Data.Ord\nimport Data.List\n\nmain = interact $ unlines . map (show . carden_lantern) . read' . lines\n where\n  read' (\"0\":_) = []\n  read' (_:m:xs) = map (parse . map read . splitOn ',') edge : read' xs'\n   where\n    (edge,xs') = splitAt (read m) xs\n    parse [a,b,d] = ((a,b), div d 100)\n\ncarden_lantern = count . foldl foldpath [] . sortBy (comparing snd)\n where\n  count abd =  sum (map snd abd) - length abd\n  foldpath acc abd@((a,b),_) = if disjoint a b (map fst acc) then (abd:acc) else acc\n  disjoint a b ab\n   | null ab = True\n   | a == b = False\n   | otherwise = and $ map (\\(_,a') -> disjoint a' b (tail ab)) (filter ((==a).fst) ab)\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Applicative ((<$>), (<*>))\nimport Control.Monad\nimport Data.List\nimport Data.Array\nimport Data.List.Split (splitOn)\n\nmain :: IO ()\nmain = do\n  n <- getl toInt\n  when (n /= 0) $ do\n    m <- getl toInt\n    xs <- rgetl m $ map toInt . splitOn \",\"\n    print $ solve n xs\n\nsolve :: Int -> [[Int]] -> Int\nsolve n xs = mst adj 0 [0] [1..n-1]\n  where\n    adj = foldl (\\ar [i,j,l] -> ar // [((i,j),l),((j,i),l)]) (listArray ((0,0),(n-1,n-1)) $ repeat infty) xs\n    \nmst :: Array (Int,Int) Int -> Int -> [Int] -> [Int] -> Int\nmst adj s us vs\n  | null vs = s\n  | otherwise = mst adj (s + l `div` 100 - 1) (i:us) (delete i vs)\n  where\n    (l,(_,i)) = minimum [(adj ! (u,v),(u,v)) | u <- us, v <- vs]\n\ninfty :: Int\ninfty = 2000000000\n\ntoInt :: String -> Int\ntoInt s = read s\n\ngetl :: (String -> a) -> IO a\ngetl f = f <$> getLine\n\nrgetl :: Int -> (String -> a) -> IO [a]\nrgetl n f = map f <$> replicateM n getLine"
  },
  {
    "language": "Haskell",
    "code": "import Data.Ord\nimport Data.List\n\nmain = interact $ unlines . map (show . carden_lantern) . read' . lines\n where\n  read' (\"0\":_) = []\n  read' (_:m:xs) = map (parse . map read . splitOn ',') edge : read' xs'\n   where\n    (edge,xs') = splitAt (read m) xs\n    parse [a,b,d] = ((a,b), div d 100)\n\ncarden_lantern = count . foldl' foldpath [] . sortBy (comparing snd)\n where\n  count abd =  sum (map snd abd) - length abd\n  foldpath acc abd@((a,b),_) = if disjoint a b (map fst acc) then (abd:acc) else acc\n  disjoint a b ab\n   | null ab = True\n   | a == b = False\n   | otherwise = and $ map (\\(_,a') -> disjoint a' b (tail ab)) (filter ((==a).fst) ab)\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)"
  },
  {
    "language": "Haskell",
    "code": "import Data.Ord\nimport Data.List\n\nmain = interact $ unlines . map (show . carden_lantern) . read' . lines\n where\n  read' (\"0\":_) = []\n  read' (_:m:xs) = map (parse . map read . splitOn ',') edge : read' xs'\n   where\n    (edge,xs') = splitAt (read m) xs\n    parse [a,b,d] = ((a,b), div d 100)\n\ncarden_lantern = count . foldl' foldpath [] . sortBy (comparing snd)\n where\n  count abd =  sum (map snd abd) - length abd\n  foldpath acc abd@((a,b),_) = if disjoint a b (map fst acc) then (abd:acc) else acc\n  disjoint a b ab\n   | null ab = True\n   | a == b = False\n   | otherwise = and $ map (\\(a,a') -> disjoint a' b (delete (a,a') ab)) from_a\n   where from_a = filter ((==a).fst) ab\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)"
  },
  {
    "language": "Haskell",
    "code": "import Data.List\nimport Data.Ord\n\nmain = interact $ unlines . map (show . carden_lantern . read') . parse . lines\n where\n  parse (\"0\":_) = []\n  parse (_:m:str) = take (read m) str : parse (drop (read m) str)\n  read' = map ((\\[a,b,d]->((a,b),d)) . map read . splitOn ',')\n\ncarden_lantern = count_lantern . cut . reverse . sortBy (comparing snd)\n where\n  cut [] = []\n  cut (abd@((a,b),d):rs)\n   | elem a sites && elem b sites =  cut rs\n   | otherwise = abd : cut rs\n   where sites = map (fst.fst) rs ++ map (snd.fst) rs\n  count_lantern rs = sum $ map ((\\d -> div d 100 - 1) . snd) rs\n\nsplitOn c xs\n | null xs = []\n | head xs == c = splitOn c (tail xs)\n | otherwise = (takeWhile (/= c)) xs : splitOn c (dropWhile (/= c) xs)"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Control.Applicative\nimport Data.Functor\nimport Data.Function\nimport Data.Monoid\nimport Data.Maybe\nimport Data.List\nimport Data.Foldable (foldMap)\nimport Data.List.Split\nimport Data.Char\nimport Data.Ratio\nimport Data.Ord\nimport Data.Array.IO\nimport Data.IORef\n \nreadInt = read :: String -> Int\nreadDouble = read :: String -> Double\ngetInt = readLn :: IO Int\ngetInts = map readInt . words <$> getLine\nsjoin :: (Show a) => [a] -> String\nsjoin = unwords . map show\ncond :: a -> a -> Bool -> a\ncond t f c = if c then t else f\napplyBin :: (b -> c -> d) -> (a -> b) -> (a -> c) -> a -> d\napplyBin op f g x = op (f x) $ g x\napplyUni :: (a -> b -> c) -> (a -> b) -> a -> c\napplyUni op f x = op x $ f x\napplyTuple :: (a -> b, a -> c) -> a -> (b, c)\napplyTuple (f,g) a = (f a, g a)\n-- end of templete\n\ntype UnionFind = IOUArray Int Int\nnewUnionFind :: Int -> IO UnionFind\nnewUnionFind n = newArray (0,n-1) (-1)\nroot :: UnionFind -> Int -> IO Int\nroot uf i = do\n    p <- readArray uf i\n    if p<0 then return i else root uf p\nsame :: UnionFind -> Int -> Int -> IO Bool\nsame uf i j = (==) <$> root uf i <*> root uf j\nunite :: UnionFind -> Int -> Int -> IO ()\nunite uf i j = root uf i >>= writeArray uf j\n\nmain = do\n    n <- getInt\n    when (n/=0) $ do\n        m <- getInt\n        list <- sortBy (on compare (!!2)) . map (map readInt . wordsBy (==',')) <$> replicateM m getLine\n        ref <- newIORef 0\n        uf <- newUnionFind n\n        forM_ list $ \\[a,b,d] -> do\n            c <- not <$> same uf a b\n            when c $ do\n                unite uf a b\n                modifyIORef ref (+(div d 100 - 1))\n        readIORef ref >>= print"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\nimport Text.Printf\n\ninf :: Int\ninf = 1000000000\n\ninitCost :: [(Int,Int,Int)]->((Int,Int)->Int)\ninitCost [] = cost\n    where cost edge = inf\ninitCost ((a,b,d):xs) = cost\n    where cost edge = if edge==(a,b) || edge==(b,a) then d \n                      else (initCost xs) edge\n\nsolvePrim :: ((Int,Int)->Int)->\n             [Int]->[(Int,Int)]->\n             [Int]->[(Int,Int)]->\n             [(Int,Int)]\nsolvePrim cost vnew enew v e \n    | vnew==v   = enew\n    | otherwise = solvePrim cost vnew' enew' v e\n        where fltrfunc (x,y) = ((elem x vnew)&&(not $ elem y vnew))||\n                               ((elem y vnew)&&(not $ elem x vnew))\n              filtered = filter fltrfunc e\n              mincost = minimum $ map cost filtered\n              (x,y) = head $ filter (\\x->(cost x)==mincost) filtered\n              vnew' = sort $ nub $ (x:y:vnew)\n              enew' = (x,y):enew\n\nsolve :: ((Int,Int)->Int)->\n         [Int]->[(Int,Int)]->\n         Int\nsolve cost v e = sum $ map (\\x->(cost x)`div`100-1) res\n    where res = solvePrim cost [0] [] v e \n\nreadInput :: IO ()\nreadInput = do\n    ln <- getLine\n    let n = read ln :: Int\n    if n==0 then return () else return =<< readInput' n\n\nreadInput' :: Int->IO ()\nreadInput' n = do\n    lm <- getLine\n    let m = read lm :: Int\n    str <- replicateM m getLine\n    let myread s = read (\"(\"++s++\")\")::(Int,Int,Int)\n    let list = map myread str\n    let cost = initCost list\n    let e = map (\\(a,b,d)->(a,b)) list\n    let v = [0..(n-1)]\n    printf \"%d\\n\" (solve cost v e)\n    return =<< readInput\n\nmain :: IO ()\nmain = do\n    readInput"
  },
  {
    "language": "Haskell",
    "code": "import Control.Monad\nimport Data.List\n\nsolve :: Int->[(Int,Int,Int)]->[(Int,Int,Int)]->Int\nsolve n list1 list2\n    | hasall   = sum $ map (\\(a,b,d)->d`div`100-1) list1\n    | otherwise = head $ sort $ map (\\l->solve n (l:list1) (delete l list2)) list2\n        where la = map (\\(a,b,d)->a) list1\n              lb = map (\\(a,b,d)->b) list1\n              hasall = and $ map (\\x->elem x (la++lb)) [0..(n-1)]\n\nreadInput :: IO ()\nreadInput = do\n    ln <- getLine\n    let n = read ln :: Int\n    if n==0 then return () else return =<< readInput' n\n\nreadInput' :: Int->IO ()\nreadInput' n = do\n    lm <- getLine\n    let m = read lm :: Int\n    str <- replicateM m getLine\n    let myread s = read (\"(\"++s++\")\")::(Int,Int,Int)\n    let list = map myread str\n    print (solve n [] list)\n    return =<< readInput\n\nmain :: IO ()\nmain = do\n    readInput"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nint main(void){\n\tint n,m,a,b,x,i,j,path[1000][3],pot[100];\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tfor(i=0;i<n;i++)pot[i]=1;\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&x);\n\t\t\tfor(j=i;j>0;j--){\n\t\t\t\tif(path[j-1][2]>x){\n\t\t\t\t\tpath[j][2]=path[j-1][2];\n\t\t\t\t\tpath[j][1]=path[j-1][1];\n\t\t\t\t\tpath[j][0]=path[j-1][0];\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tpath[j][2]=x;\n\t\t\tpath[j][1]=b;\n\t\t\tpath[j][0]=a;\n\t\t}\n\t\tx=0;\n\t\tfor(i=0;i<m && n>0;i++){\n\t\t\ta=path[i][0];\n\t\t\tb=path[i][1];\n\t\t\tif(pot[a]==1 || pot[b]==1){\n\t\t\t\tn-=pot[a]+pot[b];\n\t\t\t\tpot[a]=0;pot[b]=0;\n\t\t\t\tx+=path[i][2]/100-1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m+1;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        if(x==0){\n            break;\n        }\n        a[x][y]=1;\n        a[y][x]=1;\n        b[x][y]=z;\n        b[y][x]=z;\n    }\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 200\nint par[MAX_N];\nint rank[MAX_N];\n\ntypedef struct{int p1; int p2; int leng;}map;\n\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx =find(x);\n\ty =find(y);\n\tif(x==y){\n\t\treturn ;\n\t}\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\n\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint comp(const void* c1,const void* c2);\n\nint main(){\n\tint n,m,i,count,num;\n\tmap* road;\n\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tinit(n);\n\n\t\tscanf(\"%d\",&m);\n\t\troad=(map*)malloc(m*sizeof(map));\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&road[i].p1,&road[i].p2,&road[i].leng);\n\t\t}\n\n\t\tqsort(road,m,sizeof(map),comp);\n\t\ti=0; count=0; num=0;\n\t\twhile(count!=n-1){\n\t\t\tif(!same(road[i].p1,road[i].p2)){\n\t\t\t\tcount++;\n\t\t\t\tnum+=(road[i].leng/100)-1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\\n\",num);\n\t\tfree(road);\n\t}\n\treturn 0;\n}\n\nint comp(const void *c1,const void *c2){\n\tmap data1=*(map*)c1;\n\tmap data2=*(map*)c2;\n\n\tint temp1=data1.leng;\n\tint temp2=data2.leng;\n\n\treturn temp1-temp2;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\nint n,m,a,b,x,i,pot[100];\ntypedef struct path{\n\tint a;\n\tint b;\n\tint x;\n\tstruct path* next;\n}Path;\nPath *first,*look,*prev;\nPath* newpath(int a,int b,int x,Path* next){\n\tPath* p=(Path*)malloc(sizeof(Path));\n\tp->a=a;\n\tp->b=b;\n\tp->x=x;\n\tp->next=next;\n\treturn p;\n}\nvoid connect(int from,int to){\n\tint i;\n\tfor(i=0;i<m;i++){\n\t\tif(pot[i]==from){pot[i]=to;if(to==0)n--;}\n\t}\n}\nint main(void){\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++)pot[i]=i+1;\n\t\tscanf(\"%d\",&m);\n\t\tfirst=NULL;\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&x);\n\t\t\tif(first==NULL)first=newpath(a,b,x,NULL);\n\t\t\telse if(first->x > x)first=newpath(a,b,x,first);\n\t\t\telse{\n\t\t\t\tprev=first;look=first->next;\n\t\t\t\twhile(look!=NULL){\n\t\t\t\t\tif(look->x > x){prev->next=newpath(a,b,x,look);break;}\n\t\t\t\t\telse{prev=look;look=look->next;}\n\t\t\t\t}\n\t\t\t\tif(look==NULL)prev->next=newpath(a,b,x,look);\n\t\t\t}\n\t\t}\n\t\tlook=first;x=0;m=n;\n\t\twhile(look!=NULL){\n\t\t\ta=pot[look->a];b=pot[look->b];\n\t\t\tif(a!=b){\n\t\t\t\tif(x==0){pot[look->a]=0;pot[look->b]=0;n-=2;}\n\t\t\t\telse{if(a<b)connect(b,a); else connect(a,b);}\n\t\t\t\tx+=look->x/100-1;\n\t\t\t}\n\t\t\tlook=look->next;\n\t\t}\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint data[10000];\nint init(void){ memset(data, -1, sizeof(data)); }\nint root(int x){ return data[x] < 0 ? x : (data[x] = root(data[x])); }\nint size(int x){ return -data[root(x)]; }\nint find(int x, int y){ return root(x) == root(y); }\nint merge(int x, int y){\n\tx = root(x);\n\ty = root(y);\n\tif (x != y){\n\t\tif (data[y] < data[x]) x ^= y ^= x ^= y;\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t}\n\treturn x != y;\n}\n\ntypedef struct { int from, to; int v; } Edge;\nint cmp_edge(Edge *a, Edge *b){ return a->v - b->v; }\nEdge V[10000];\n\nint main(void)\n{\n\tint n;\n\n\twhile (scanf(\"%d\", &n), n){\n\t\tint m, i;\n\t\tint minv;\n\t\tint count;\n\n\t\tinit();\n\n\t\tscanf(\"%d\", &m);\n\t\tfor (i = 0; i < m; i++){\n\t\t\tint from, to, v;\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &v);\n\t\t\tV[i] = (Edge){from, to, v / 100 - 1};\n\t\t}\n\t\t\n\t\tqsort(V, m, sizeof(Edge), cmp_edge);\n\n\t\tminv = count = 0;\n\t\tfor (i = 0; i < m; i++){\n\t\t\tif (count >= n) break;\n\t\t\tif (!find(V[i].from, V[i].to)){\n\t\t\t\tif (merge(V[i].from, V[i].to)) minv += V[i].v, count++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", minv);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint V, n;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid prim(int start) {\n    int x, p, step;\n\n    for (x = 0; x < V; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= V; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < V; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tfor (x = 0 ; x < V; x++)\n\t    if (vertex[x].state == 0)\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m, sum;\n     \n    while (1) {\n\tscanf(\"%d\", &V);\n        if (V == 0) break;\n\tscanf(\"%d\", &n);\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d,%d,%d\", &from, &to, &m);\n            W[from][to] = (m / 100) - 1;\n\t    W[to][from] = (m / 100) - 1;\n        }\n\n        prim(0);\n\n\tsum = 0;\n\tfor (i = 1; i < n; i++) {\n\t    sum += (vertex[i].distance);\n\t}\n\tprintf(\"%d\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint W[100][100];\nint dist[100];\nint prev[100];\nint U[100];\n\nmain(){\n  int i, j, n, m, a, b, c, min, p, ans, count, temp;\n\n  while(1){\n    scanf(\"%d\", &n);\n    if(n==0) break;\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tW[i][j]=10000000;\n      }\n    }\n    scanf(\"%d\", &m);\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      W[a][b]=W[b][a]=c;\n    }\n    ans=10000001;\n    for(count=0;count<n;count++){\n      for(i=0;i<n;i++){\n\tdist[i]=10000000;\n\tU[i]=1;\n\tprev[i]=0;\n      }\n      \n      dist[count]=0;\n      \n      for(i=0;i<n;i++){\n\tmin=10000001;\n\tfor(j=0;j<n;j++){\n\t  if(U[j]==1 && min>dist[j]){\n\t    p=j;\n\t    min=dist[j];\n\t  }\n\t}\n\tU[p]=0;\n\tfor(j=0;j<n;j++){\n\t  if(U[j]==1 && (dist[j]>dist[p]+W[p][j])){\n\t    dist[j]=dist[p]+W[p][j];\n\t    prev[j]=p;\n\t  }\n\t}\n      }\n      \n      temp=0;\n      for(i=0;i<n;i++){\n\ttemp+=dist[i];\n      }\n      temp/=100;\n      if(temp<ans) ans=temp;\n    }\n    printf(\"%d\\n\", ans-n+1);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint n, m;\n\t\n\twhile (scanf(\"%d\", &n) * n != 0){\n\t\tint map[100][100] = {0};\n\t\tint distance[100][100] = {0};\n\t\tint a, b, d;\n\t\tint lantern = 0;\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\twhile (m-- > 0){\n\t\t\tint i, j;\n\t\t\t\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tdistance[a][b] = d;\n\t\t\tmap[a][b] = 1;\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (map[i][b] == 1 && d < distance[i][b]){\n\t\t\t\t\tlantern -= distance[i][b] / 100 - 1;\n\t\t\t\t\tlantern += d / 100 - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n){\n\t\t\t\tlantern += d / 100 - 1;\n\t\t\t}\n\t\t}\n\t\tif (map[n - 1][0] == 1){\n\t\t\tlantern -= distance[n - 1][b] / 100 - 1;\n\t\t}\n\t\tprintf(\"%d\\n\", lantern);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "/* AOJ 0072\n *\n * http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072\n *\n */\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#define DEBUG 0\n\n#define MAX 100\n/* 市内の史跡は100 箇所以内です */\n\n\ntypedef struct TStreet Street;\nstruct TStreet{\n    int fA;\n    int fB;\n    int fCost;\n};\n\nint parent[MAX];\nint rank[MAX];\n\nvoid MakeSet(int loc){\n    parent[loc] = loc;\n    rank[loc] = 0;\n};\n\n\nint find(int loc){\n    int found;\n    if(parent[loc]==loc){\n        return loc;\n    }else{\n        found = find(parent[loc]);\n        parent[loc] = found;\n        return found;\n    }\n}\n\n\nvoid merge(int x, int y){\n    int xr, yr;\n    xr = find(x);\n    yr = find(y);\n    if(rank[xr] > rank[yr]){\n        parent[yr] = xr;\n    }else if( rank[xr] < rank[yr]){\n        parent[xr] = yr;\n    }else if (xr != yr) {\n        parent[yr] = xr;\n        rank[xr] += 1;\n    }\n}\n\n\nint Kruskal(int nodecount, Street* network, int path){\n    int i;\n    int a, b;\n    int cost;\n    cost = 0;\n    for(i=0; i<nodecount;i++){\n        MakeSet(i);\n    }\n    for(i=0; i < path; i++){\n        if(DEBUG)\n            printf(\"Working on %d <-> %d  (%d)\\n\", network[i].fA, network[i].fB, network[i].fCost);\n        a = network[i].fA;\n        b = network[i].fB;\n        if(DEBUG){\n            printf(\"%d in  %d\\n\", a, find(a));\n            printf(\"%d in  %d\\n\", b, find(b));\n        }\n        if(find(a) != find(b)){\n            merge(a, b);\n            cost += network[i].fCost;\n        }\n    }\n    return cost;\n}\n\n\nint comp(const void*a, const void*b){\n    return ((Street*)a)->fCost - ((Street*)b)->fCost;\n}\n\n\nint main(){\n    /* 最小全域木問題 */\n    int n, path;\n    int i;\n    int a, b, d;\n    int cost;\n    Street* network;\n    \n\n    while(scanf(\"%d\", &n)==1 && n){\n        /* n <= 100 */\n        scanf(\"%d\", &path);\n\n        /* path <= n! */\n        network = (Street*)malloc(path*sizeof(Street));\n\n        for(i=0;i<path;i++){\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            network[i].fA = a;\n            network[i].fB = b;\n            network[i].fCost = d/100 - 1 ;\n        }\n\n        qsort(network, path, sizeof(Street), comp);\n        if(DEBUG){\n            for(i=0;i<path;i++){\n                printf(\"%d <-> %d  (%d)\\n\", network[i].fA, network[i].fB, network[i].fCost);\n            }\n        }\n\n        cost = Kruskal(n, network, path);\n        printf(\"%d\\n\", cost);\n\n        free((void*)network);\n    }\n\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint n, m;\n\t\n\twhile (scanf(\"%d\", &n) * n != 0){\n\t\tint map[100][100] = {0};\n\t\tint distance[100][100] = {0};\n\t\tint a, b, d;\n\t\tint lantern = 0;\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\twhile (m-- > 0){\n\t\t\tint i, j;\n\t\t\t\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tdistance[a][b] = d;\n\t\t\tmap[a][b] = 1;\n\t\t\tfor (i = 0; i < n; i++){\n\t\t\t\tif (map[i][b] == 1 && d < distance[i][b]){\n\t\t\t\t\tlantern -= distance[i][b] / 100 - 1;\n\t\t\t\t\tlantern += d / 100 - 1;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (i == n){\n\t\t\t\tlantern += d / 100 - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", lantern);\n\t}\n\t\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nint main(void){\n\tint n,m,a,b,x,i,j,path[5000][3],pot[100];\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++)pot[i]=1;\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&x);\n\t\t\tfor(j=i;j>0;j--){\n\t\t\t\tif(path[j-1][2]>x){\n\t\t\t\t\tpath[j][2]=path[j-1][2];\n\t\t\t\t\tpath[j][1]=path[j-1][1];\n\t\t\t\t\tpath[j][0]=path[j-1][0];\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tpath[j][2]=x;\n\t\t\tpath[j][1]=b;\n\t\t\tpath[j][0]=a;\n\t\t}\n\t\tx=0;\n\t\tfor(i=0;i<m && n>0;i++){\n\t\t\ta=path[i][0];\n\t\t\tb=path[i][1];\n\t\t\tif(pot[a]==1 || pot[b]==1){\n\t\t\t\tn-=pot[a]+pot[b];\n\t\t\t\tpot[a]=0;pot[b]=0;\n\t\t\t\tx+=path[i][2]/100-1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "// Aizu Vol-0 0072: Carden Lanternl\n// 2017.8.6\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar *gets(char *);\nchar buf[100], *p;\nint getInt(void)\n{\n\tint n = 0;\n\twhile (isspace(*p) || *p == ',') p++;\n\twhile (isdigit(*p)) n = 10 * n + (*p++ - '0');\n\treturn n;\n}\n\n#define INF 0x77777777\n#define MAX 100\nint N;\nint d[MAX + 2][MAX + 2];\nint visited[MAX];\nint Q[MAX + 2], end;\n\nint main()\n{\n\tint a, b, i, j, k, n, m, min, ans;\n\n\twhile (1) {\n\t\tgets(p = buf); if (!(N = getInt())) break;\n\t\tgets(p = buf); m = getInt();\n\t\tmemset(d, 0x77, sizeof(d));\n\t\tfor (i = 0; i < m; i++) {\n\t\t\tgets(p = buf); a = getInt(), b = getInt(), j = getInt()/100-1;\n\t\t\tif (j < d[a][b]) d[a][b] = d[b][a] = j;\n\t\t}\n\t\tmemset(visited, 0, sizeof(visited));\n\t\tans = 0, visited[0] = 1, n = 1, Q[0] = 0, end = 1;\n\t\twhile (n < N) {\n\t\t\tfor (k = end-1, min = INF; k >= 0; k--) {\n\t\t\t\ti = Q[k];\n\t\t\t\tfor (j = 0; j < N; j++) {\n\t\t\t\t\tif (!visited[j] && d[i][j] < min) min = d[i][j], a = i, b = j;\n\t\t\t\t}\n\t\t\t}\n\t\t\tans += min, visited[b] = 1, n++, Q[end++] = b;\n\t\t}\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        if(a[x][y]==0){\n            a[x][y]=1;\n            a[y][x]=1;\n            b[x][y]=z;\n            b[y][x]=z;\n        }\n        if(a[x][y]==1){\n            if(b[x][y]>z){\n                a[x][y]=1;\n                a[y][x]=1;\n                b[x][y]=z;\n                b[y][x]=z;\n            }\n        }\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>=r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "d[150][120];b,i,j,s,t,m,n,*p;main(a){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",s)){for(memset(d,9,7e4);t=m--;d[a][b]=d[b][a]=i/100)scanf(\"%d,%d,%d\",&a,&b,&i);for(s=i=1-n;i++;s+=d[n][t=m])for(d[j=m=n][t]=0;j--;*p&&d[n][m]>*p?m=j:0)p=d[n]+j,*p=fmin(*p,d[t][j]);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 1000000000\nvoid MST(int);\n\nint edge[101][101],v[101],d[101],sum=0,n;\n\nint main(void){\n\n  int m,a,b,i,j, cost;\n\n  while(1){\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++){\n\t  for(j=0;j<101;j++){\n\t      edge[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d,%d,%d\",&a,&b,&cost);\n\tedge[a][b]=cost;\n\tedge[b][a]=cost;\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n      sum = 0;\n      MST(0);\n\n      printf(\"%d\\n\",sum);\n    }\n\n  return 0;\n}\n\nvoid MST(int u){\n  int x=0,i;\n\n  while(1){\n    int minv=INF;\n\n    for(i=0;i<n;i++){\n      if(v[i]==0 &&  d[i]<minv){\n\tx=i;\n\tminv=d[i];\n      }\n    }\n    if(minv==INF)break;  \n\n    v[x]=1;\n    if ( x != u ) sum+=(d[x]/100-1);\n    \n    for(i=0;i<n;i++){\n      if ( v[i] ) continue;\n      d[i]=min(d[i],edge[x][i]);\n    }\n  }\n}\n\nint min(int x,int y){\n  return x < y ? x : y;\n }"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1000000000\n\nint cost[1000][1000];\nint mincost[1000];\nchar used[1000];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint ans;\n\tint i, j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tfor (j = 0; j < num; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d%*c%d%*c%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\tans = prim();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,mi,c[110],d[110][110],f[110]={0};\n  while(scanf(\"%d\",&n),n){\n    for(i=0;i<110*110;i++)d[i/110][i%110]=1e9;\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d,%d,%d\",&i,&j,&k);\n      d[i][j]=d[j][i]=k/100-1;\n    }\n    for(i=mi=k=0;i<110;i++)c[i]=1e9;\n    for(i=c[0]=0;i<n;i++){\n      f[mi]=1;\n      k+=c[mi];\n      for(j=0;j<n;j++){\n\tif(c[j]>d[mi][j])c[j]=d[mi][j];\n      }\n      for(mi=0;f[mi];mi++);\n      for(j=0;j<n;j++){\n\tif(f[j]==0&&c[mi]>c[j])mi=j;\n      }\n    }\n    printf(\"%d\\n\",k);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main(){\n\tint n, m;\n\tint i, j;\n\twhile(scanf(\"%d%d\", &n, &m), n) {\n\t\tint cost[100][100] = {0};\n\t\tint determined[100] = {0}, undeterminednodes;\n\t\tint mincost[100] = {0};\n\t\tint costsum = 0;\n\t\tint minnode, minnodecost;\n\n\t\t// initialize cost table\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tfor(j = 0; j < m; j ++) {\n\t\t\t\tcost[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\t// load\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d/100-1;\n\t\t}\n\n\t\t// node 0 is determined\n\t\tdetermined[0] = 1;\n\t\tundeterminednodes = m-1;\n\n\t\t// initialize mincost\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tif(!determined[i]) {\n\t\t\t\tmincost[i] = cost[0][i];\n\t\t\t} else {\n\t\t\t\tmincost[i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\twhile(undeterminednodes > 0) {\n\t\t\t// select the nearest undetermined node\n\t\t\tminnodecost = INT_MAX;\n\t\t\tfor(i = 0; i < m; i ++) {\n\t\t\t\tif(mincost[i] < minnodecost) {\n\t\t\t\t\tminnode = i;\n\t\t\t\t\tminnodecost = mincost[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// the node is determined\n\t\t\tdetermined[minnode] = 1;\n\t\t\tcostsum += minnodecost;\n\t\t\tundeterminednodes --;\n\t\t\tmincost[minnode] = INT_MAX;\n\n\t\t\t// update mincost\n\t\t\tfor(i = 0; i < m; i ++) {\n\t\t\t\tif(!determined[i]) {\n\t\t\t\t\tif(cost[minnode][i] < mincost[i])\n\t\t\t\t\t\tmincost[i] = cost[minnode][i];\n\t\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", costsum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1000000\n\nint cost[100][100];\nint mincost[100];\nchar used[100];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint i,j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tfor (j = 0; j < num; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", prim());\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint connected;\n\tint distance[100];\n}onesiseki;\n\nint main(void) {\n\tonesiseki siseki[100];\n\tint sisekinum;\n\tint i,j;\n\tint roadnum;\n\tint a,b,dist;\n\tint distancesum;\n\tint minsiseki,minsisekito,mindist;\n\twhile(1) {\n\t\tscanf(\"%d\",&sisekinum);\n\t\tif(sisekinum==0)break;\n\t\tfor(i=0;i<sisekinum;i++) {\n\t\t\tsiseki[i].connected=0;\n\t\t\tfor(j=0;j<sisekinum;j++)siseki[i].distance[j]=-1;\n\t\t}\n\t\tscanf(\"%d\",&roadnum);\n\t\tfor(i=0;i<roadnum;i++) {\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&dist);\n\t\t\tsiseki[a].distance[b]=dist;\n\t\t\tsiseki[b].distance[a]=dist;\n\t\t}\n\t\tsiseki[0].connected=1;\n\t\tdistancesum=0;\n\t\twhile(1) {\n\t\t\tminsiseki=minsisekito=mindist=-1;\n\t\t\tfor(i=0;i<sisekinum;i++) {\n\t\t\t\tif(siseki[i].connected) {\n\t\t\t\t\tfor(j=0;j<sisekinum;j++) {\n\t\t\t\t\t\tif(siseki[j].connected==0 && siseki[i].distance[j]>0) {\n\t\t\t\t\t\t\tif(mindist<0 || siseki[i].distance[j]<mindist) {\n\t\t\t\t\t\t\t\tmindist=siseki[i].distance[j];\n\t\t\t\t\t\t\t\tminsiseki=i;\n\t\t\t\t\t\t\t\tminsisekito=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minsiseki==-1)break;\n\t\t\tdistancesum+=mindist-100;\n\t\t\tsiseki[minsisekito].connected=1;\n\t\t}\n\t\tprintf(\"%d\\n\",distancesum/100);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n\n#define N 100\n#define M 4950\n#define INT(X) \\\n  ( *( (const int *)(X) ) )\n#define MIN(A,B) \\\n  ( (A) < (B) ? (A) : (B) )\n#define MAX(A,B) \\\n  ( (A) > (B) ? (A) : (B) )\n\nint compare (\n  const void  * a,\n  const void  * b\n  )\n{\n  return ( INT( a ) - INT( b ) );\n}\n\n/** Application main entry point. */\nint main (\n  int     argc,\n  char  * argv[ ]\n  )\n{\n  int i, j;\n\n  for ( ; ; )\n  {\n    int r[ N ], res = 0;\n    struct\n    {\n      int d;\n      int a;\n      int b;\n    } d[ M ];\n    int n, m;\n\n    scanf ( \" %d\", &n );\n    if ( !( n ) ) break ;\n\n    scanf ( \" %d\", &m );\n    for ( i = 0; i < n; ++i )\n    {\n      r[ i ] = i;\n    }\n    for ( i = 0; i < m; ++i )\n    {\n      scanf ( \" %d,%d,%d\", &d[ i ].a, &d[ i ].b, &d[ i ].d );\n      d[ i ].d = ( d[ i ].d / 100 ) - 1;\n    }\n    qsort ( d, m, sizeof ( d[ 0 ] ), compare );\n\n    for ( j = 0; j < m; ++j )\n    {\n      if ( r[ d[ j ].a ] != r[ d[ j ].b ] )\n      {\n        int t = MIN( r[ d[ j ].a ], r[ d[ j ].b ] );\n        int u = MAX( r[ d[ j ].a ], r[ d[ j ].b ] );\n\n        for ( i = 0; i < n; ++i )\n        {\n          if ( r[ i ] == u )\n          {\n            r[ i ] = t;\n          }\n        }\n\n        res += d[ j ].d;\n      }\n    }\n\n    printf ( \"%d\\n\", res );\n  }\n\n  return ( 0 );\n}"
  },
  {
    "language": "C",
    "code": "/*\nAizuOnline A0072\nTitle Lantern\n\n*/\n#include <stdio.h>\n// Select Below\n#include <stdlib.h>\n#include <string.h>\n//#include <float.h>\n//#include <math.h>\n//#include <limits.h>\n//Global data section\n#define TOWN 100\n#define MAXBRIDGE (TOWN*(TOWN-1)/2)\nint n,m;\nstruct b_st {int a;  //from\n  int b;             //to\n  int cost;} bridge[MAXBRIDGE];\nint c_f[TOWN];\n//\ncomp(void *a,void *b)\n{\n  return(((struct b_st *)a)->cost - ((struct b_st *)b)->cost);\n}\nint nearest(int * t_cost)\n{\n  int i;\n\n  for(i=0;i<m;i++)\n    if(c_f[bridge[i].a]+c_f[bridge[i].b]==1)\n      {\n\t*t_cost += (bridge[i].cost/100-1);\n#ifdef DEBUG\n\tprintf(\"%d %d %d\\n\",bridge[i].a,bridge[i].b,bridge[i].cost);\n#endif\n\tif(c_f[bridge[i].a])\n\t  return(bridge[i].b);\n\telse\n\t  return(bridge[i].a);\n     }\n}\nint total_cost()\n{\n  int i,t,t_cost;\n  \n  c_f[0]=1;t_cost=0;\n  for(i=1;i<n;i++)\n    {\n      t=nearest(&t_cost);\n      c_f[t]=1;\n    }\n  return(t_cost);\n}\nmain()\n{\n  int i;\n  int ret;\n\n  while(EOF!=scanf(\"%d \",&n) && n)\n    {\n      scanf(\"%d \",&m);\n      for(i=0;i<m;i++)\n\tscanf(\"%d,%d,%d\",&(bridge[i].a),&(bridge[i].b),&(bridge[i].cost));\n      memset(c_f,0,sizeof(c_f));\n      qsort(bridge,m,sizeof(struct b_st),(__compar_fn_t)comp);\n      ret=total_cost();\n      printf(\"%d\\n\",ret);\n    }\nreturn(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main(){\n\tint n, m;\n\tint i, j;\n\twhile(scanf(\"%d%d\", &n, &m), n) {\n\t\tint cost[100][100] = {0};\n\t\tint determined[100] = {0}, undeterminednodes = n;\n\t\t//int mincost[100] = {0};\n\t\tint *mincost = cost[0];\n\t\tint costsum = 0;\n\t\tint minnode, minnodecost, nextminnode;\n\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tfor(j = 0; j < n; j ++) {\n\t\t\t\tcost[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\t\t/*for(i = 0; i < n; i ++) {\n\t\t\tmincost[i] = INT_MAX;\n\t\t}*/\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d/100-1;\n\t\t}\n\t\tminnode = 0;\n\t\tminnodecost = 0;\n\n\t\twhile(undeterminednodes > 0) {\n\t\t\tdetermined[minnode] = 1;\n\t\t\tcostsum += minnodecost;\n\t\t\tundeterminednodes --;\n\t\t\tmincost[minnode] = INT_MAX;\n\t\t\tminnodecost = INT_MAX;\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(!determined[i]) {\n\t\t\t\t\tif(cost[minnode][i] < mincost[i])\n\t\t\t\t\t\tmincost[i] = cost[minnode][i];\n\t\t\t\t}\n\t\t\t\tif(mincost[i] < minnodecost) {\n\t\t\t\t\tnextminnode = i;\n\t\t\t\t\tminnodecost = mincost[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tminnode = nextminnode;\n\t\t}\n\t\tprintf(\"%d\\n\", costsum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint V, n, sum;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid prim(int start) {\n    int x, p, step;\n\n    for (x = 0; x < V; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= V; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < V; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tsum += minimum;\n\tfor (x = 0 ; x < V; x++)\n\t    if (vertex[x].state == 0)\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m;\n     \n    while (1) {\n\tscanf(\"%d\", &V);\n        if (V == 0) break;\n\tscanf(\"%d\", &n);\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d,%d,%d\", &from, &to, &m);\n            W[from][to] = (m / 100) - 1;\n\t    W[to][from] = (m / 100) - 1;\n        }\n\n\tsum = 0;\n\n        prim(0);\n\n\tprintf(\"%d\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        if(a[x][y]==0){\n            a[x][y]=1;\n            a[y][x]=1;\n            b[x][y]=z;\n            b[y][x]=z;\n        }\n        if(a[x][y]==1){\n            if(b[x][y]>z){\n                a[x][y]=1;\n                a[y][x]=1;\n                b[x][y]=z;\n                b[y][x]=z;\n            }\n        }\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>=r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        a[x][y]=1;\n        a[y][x]=1;\n        b[x][y]=z;\n        b[y][x]=z;\n    }\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n\nint data[10000];\nint init(void){ memset(data, -1, sizeof(data)); }\nint root(int x){ return data[x] < 0 ? x : (data[x] = root(data[x])); }\nint size(int x){ return -data[root(x)]; }\nint find(int x, int y){ return root(x) == root(y); }\nint merge(int x, int y){\n\tx = root(x);\n\ty = root(y);\n\tif (x != y){\n\t\tif (data[y] < data[x]) x ^= y ^= x ^= y;\n\t\tdata[x] += data[y];\n\t\tdata[y] = x;\n\t}\n\treturn x != y;\n}\n\ntypedef struct { int from, to; int v; } Edge;\nint cmp_edge(Edge *a, Edge *b){ return a->v - b->v; }\nEdge V[10000];\n\nint main(void)\n{\n\tint n;\n\n\twhile (scanf(\"%d\", &n), n){\n\t\tint m, i;\n\t\tint minv;\n\t\tint count;\n\n\t\tinit();\n\n\t\tscanf(\"%d\", &m);\n\t\tfor (i = 0; i < m; i++){\n\t\t\tint from, to, v;\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &v);\n\t\t\tV[i] = (Edge){from, to, v / 100 - 1};\n\t\t}\n\t\t\n\t\tqsort(V, m, sizeof(Edge), cmp_edge);\n\n\t\tminv = count = 0;\n\t\tfor (i = 0; i < m; i++){\n\t\t\tif (count >= n) break;\n\t\t\tif (merge(V[i].from, V[i].to)){\n\t\t\t\tminv += V[i].v, count++;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", minv);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nint n,m,a,b,x,i,j,path[5000][3],pot[100],size;\nvoid connect(int from,int to){\n    int i;\n    for(i=0;i<m;i++){if(pot[i]==from){pot[i]=to;if(to==0)n--;}}\n}\nvoid swap(int *x,int *y){int z; z=*x;*x=*y;*y=z;}\nvoid heapify(int i){\n\tint p;\n\tif(i*2+1>=size)return;\n\tif(i*2+2>=size)p=i*2+1;\n\telse a=(path[i*2+1][2]>path[i*2+2][2]?(i*2+2):(i*2+1));\n\tif(path[a][2]<path[i][2]){\n\tswap(&path[a][0],&path[i][0]);\n\tswap(&path[a][1],&path[i][1]);\n\tswap(&path[a][2],&path[i][2]);\n\theapify(a);\n\t}\n}\nint main(void){\n    while(scanf(\"%d\",&n)*n){\n        for(i=0;i<n;i++)pot[i]=i+1;\n        scanf(\"%d\",&m);size=m;\n        for(i=0;i<m;i++){\n            scanf(\"%d,%d,%d\",&a,&b,&x);\n            path[i][2]=x;\n            path[i][1]=b;\n            path[i][0]=a;\n        }\n\t\tfor(i=(size-1)/2;i>=0;i--)heapify(i);\n\t\tx=0;m=n;\n\t\tfor(;size>0;){\n\t\t\ta=pot[path[0][0]];b=pot[path[0][1]];\n\t\t\tif(a!=b){\n\t\t\t\tif(x==0){pot[path[0][0]]=0;pot[path[0][1]]=0;n-=2;}\n\t\t\t\telse{if(a<b)connect(b,a); else connect(a,b);}\n\t\t\t\tx+=path[0][2]/100-1;\n\t\t\t}\n\t\t\tswap(&path[0][0],&path[size-1][0]);\n\t\t\tswap(&path[0][1],&path[size-1][1]);\n\t\t\tswap(&path[0][2],&path[size-1][2]);\n\t\t\tsize--;\n\t\t\theapify(0);\n\t\t}\n        printf(\"%d\\n\",x);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 200\nint par[MAX_N];\nint rank[MAX_N];\n\ntypedef struct{int p1; int p2; int leng;}map;\n\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx =find(x);\n\ty =find(y);\n\tif(x==y){\n\t\treturn ;\n\t}\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\n\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint comp(const void* c1,const void* c2);\n\nint main(){\n\tint n,m,i,count,num;\n\tmap* road;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\t\tinit(n);\n\n\t\tscanf(\"%d\\n\",&m);\n\t\troad=(map*)malloc(m*sizeof(map));\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\\n\",&road[i].p1,&road[i].p2,&road[i].leng);\n\t\t}\n\n\t\tqsort(road,m,sizeof(map),comp);\n\t\ti=0; count=0;\n\t\twhile(count!=n-1){\n\t\t\tif(!same(road[i].p1,road[i].p2)){\n\t\t\t\tcount++;\n\t\t\t\tnum+=(road[i].leng/100)-1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\\n\",num);\n\t\tfree(road);\n\t}\n\treturn 0;\n}\n\nint comp(const void *c1,const void *c2){\n\tmap data1=*(map*)c1;\n\tmap data2=*(map*)c2;\n\n\tint temp1=data1.leng;\n\tint temp2=data2.leng;\n\n\treturn temp1-temp2;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint V, n;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid prim(int start) {\n    int x, p, step;\n\n    for (x = 0; x < V; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= V; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < V; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tfor (x = 0 ; x < V; x++)\n\t    if (vertex[x].state == 0) {\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n\t    }\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m, sum;\n     \n    while (1) {\n\tscanf(\"%d\", &V);\n        if (V == 0) break;\n\tscanf(\"%d\", &n);\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d,%d,%d\", &from, &to, &m);\n            W[from][to] = m / 100;\n\t    W[to][from] = m / 100;\n        }\n         \n        prim(0);\n\n\tsum = 0;\n\tfor (i = 1; i < n; i++) {\n\t    sum += (vertex[i].distance - 1);\n\t}\n\tprintf(\"%d\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 1000000000\nvoid MST(int);\n\nint edge[101][101],v[101],d[101],sum=0,n,count;\n\nint main(void){\n\n  int m,a,b,i,j, cost;\n\n  while(1){\n      count=0;\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++){\n\t  for(j=0;j<101;j++){\n\t      edge[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d,%d,%d\",&a,&b,&cost);\n\tedge[a][b]=cost;\n\tedge[b][a]=cost;\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n      sum = 0;\n      MST(0);\n\n      printf(\"%d\\n\",sum);\n    }\n\n  return 0;\n}\n\nvoid MST(int u)\n{\n  int x=0,i;\n\n  while(1){\n    int minv=INF;\n\n    for(i=0;i<n;i++){\n      if(v[i]==0 &&  d[i]<minv){\n\t//d[i]=edge[x][i];\n\tx=i;\n\tminv=d[i];\n      }\n    }\n    if(minv==INF)break;  \n\n    v[x]=1;\n    if ( x != u ) sum+=(d[x]/100-1);\n    \n    for(i=0;i<n;i++){\n      if ( v[i] ) continue;\n      d[i]=min(d[i],edge[x][i]);\n    }\n  }\n}\n\nint min(int x,int y)\n{\n  return x < y ? x : y;\n }"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nmain(){\n  char g;\n  int n,m,i,j,a,b,u,t,s;\n  int d[100],p[100],v[100],r[100][100];\n  \n  while(1){\n    scanf(\"%d\",&n);    \n    if(n==0){break;}\n    scanf(\"%d\",&m);  \n    \n    for(i=0;i<n;i++){\n      d[i]=10000000;\n      v[i]=0;\n    }  \n    \n    for(i=0;i<m;i++){\n      p[i]=-1;\n\n      scanf(\"%d%c%d\",&a,&g,&b);  \n      scanf(\"%c%d\",&g,&r[a][b]);\n     }\n    \n    /*MST*/\n    d[0]=0;\n\n    for(i=0;i<n;i++){ \n    u=10000000;\n      for(j=0;j<n;j++){\n\tif(u>d[j]&& v[j]==0){  \n\t  u=j;\n\t}\n \n      }\n     \n      for(j=0;j<m;j++){\n\tif(r[u][j]!=0&& v[j]==0){\n\t  d[j]=r[u][j]; \n\t  if(p[j]==-1){p[j]=d[j];}\n\t  else if(p[j]>d[j]){p[j]=d[j]; }\n\t}\n      }\n      v[u]=1;\n    }\n    /**/\n\n    s=0;\n    for(i=0;i<m;i++){\n      if(p[i]!=-1){\n\ts+=p[i];\n      }\n    } \n\n    s/=100;\n    printf(\"%d\\n\",s-n+1); \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint V, n;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nint prim(int start) {\n    int x, p, step, sum = 0;\n\n    for (x = 0; x < V; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= V; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < V; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tsum += minimum;\n\tfor (x = 0 ; x < V; x++)\n\t    if (vertex[x].state == 0)\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n    }\n    return sum;\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m;\n     \n    while (1) {\n\tscanf(\"%d\", &V);\n        if (V == 0) break;\n\tscanf(\"%d\", &n);\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d,%d,%d\", &from, &to, &m);\n            W[from][to] = (m / 100) - 1;\n\t    W[to][from] = (m / 100) - 1;\n        }\n\n\n\tprintf(\"%d\\n\", prim(0));\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n#define MAX_N 100\n\n//???????????????\nstruct TLine{\n  int dist;\n  int a,b;\n};\n\ntypedef struct TLine Line;\n\nLine *line;\n\nint par[MAX_N];\nint rank[MAX_N];\n\n//Union Find Tree?????????????????????\n//????????¶?????§??????????????????????????§???\n//?????¨??????????´???????????????????\nvoid init(int n){\n  int i;\n  for(i=0;i<n;i++){\n    par[i] = i;\n    rank[i] = 0;\n  }\n}\n\n\n//x?????????????´?????±??????????????????£??¨????????????\nint find(int x){\n  if(par[x]==x){\n    return x;\n  }else {\n    return par[x] = find(par[x]);\n  }\n}\n\n//x,y????±?????????????????????¨??????\nvoid unite(int x,int y){\n  x =find(x);\n  y =find(y);\n  if(x==y){\n    return ;\n  }\n  if(rank[x] < rank[y]){\n    par[x] = y;\n  }else {\n    par[y] = x;\n    if(rank[x] == rank[y])rank[x]++;\n  }\n}\n\n//x,y????±?????????????????????????????????????\nint same(int x,int y){\n  return find(x)==find(y);\n}\n\n//?????????????????????(Line.dist?????????)\nvoid LineSort(int s,int e,Line* array){\n  int i,j,k;\n  i=s-1;\n  j=e;\n  while(i<j){\n    while(++i<e&&array[i].dist<array[e].dist);\n    while(--j>=s&&array[j].dist>=array[e].dist);\n    if(i<j){\n      //??¢??°????????¨??????????????????\n      array[i].dist+=array[j].dist;\n      array[j].dist=array[i].dist-array[j].dist;\n      array[i].dist-=array[j].dist;\n\n      array[i].a+=array[j].a;\n      array[j].a=array[i].a-array[j].a;\n      array[i].a-=array[j].a;\n\n      array[i].b+=array[j].b;\n      array[j].b=array[i].b-array[j].b;\n      array[i].b-=array[j].b;\n\n    }\n  }\n  if(i<e){\n    //?????????????????????\n\n    array[e].dist+=array[i].dist;\n    array[i].dist=array[e].dist-array[i].dist;\n    array[e].dist-=array[i].dist;\n\n    array[e].a+=array[i].a;\n    array[i].a=array[e].a-array[i].a;\n    array[e].a-=array[i].a;\n\n    array[e].b+=array[i].b;\n    array[i].b=array[e].b-array[i].b;\n    array[e].b-=array[i].b;\n\n    i++;\n  }\n  if(s<j)LineSort(s,j,array);\n  if(e>i)LineSort(i,e,array);\n}\n\nint main(){\n  int n,m;\n  char s[16];\n  int i,j,a,b,d;\n  long long int res;\n  while(1){\n    if(!fgets(s,16,stdin))break;\n    sscanf(s,\"%d\",&n);\n    if(n==0)break;\n    if(!fgets(s,16,stdin))break;\n    sscanf(s,\"%d\",&m);\n    line=(Line*)malloc(sizeof(Line)*m);\n    init(n);\n    for(i=0;i<m;i++){\n      fgets(s,16,stdin);\n      sscanf(s,\"%d,%d,%d\",&a,&b,&d);\n      line[i].a=a;\n      line[i].b=b;\n      line[i].dist=d;\n    }\n    \n    LineSort(0,m-1,line);\n    res=0;\n    for(i=j=0;i<n-1&&j<m;j++){\n      if(!same(line[j].a,line[j].b)){\n        unite(line[j].a,line[j].b);\n        res+=line[j].dist/100-1;\n        i++;\n      }\n    }\n    free(line);\n    printf(\"%lld\\n\",res);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\nint rootnode[100];\nint rnk[100];\n\ntypedef struct _node {\n        int n1;\n        int n2;\n        int dist;\n} node_t;\n\nvoid sort( node_t * nd, int i );\nint unite( int n1, int n2 );\nint find( int n1 );\nvoid init_union_find_tree( int n );\nint kruskal( node_t * nd, int size, int sidenum );\n\nvoid sort( node_t * nd, int i )\n{\n        int j, k;\n        node_t tmp;\n\n        for ( j = 0 ; j < i ; j++ ) {\n                for ( k = i-1 ; k > j ; k-- ) {\n                        if ( nd[j].dist > nd[k].dist )  {\n                                tmp.dist = nd[j].dist;\n                                tmp.n1 = nd[j].n1;\n                                tmp.n2 = nd[j].n2;\n\n                                nd[j].dist = nd[k].dist;\n                                nd[j].n1 = nd[k].n1;\n                                nd[j].n2 = nd[k].n2;\n\n                                nd[k].dist = tmp.dist;\n                                nd[k].n1 = tmp.n1;\n                                nd[k].n2 = tmp.n2;\n                        }\n                }\n        }\n}\n\nint unite( int n1, int n2 )\n{\n        int n1_par = find( n1 );\n        int n2_par = find( n2 );\n\n        if ( n1_par == n2_par ) return 0;\n        if ( rnk[n1_par] < rnk[n2_par] ) {\n                rootnode[n1_par] = n2_par;\n        } else {\n                rootnode[n2_par] = n1_par;\n                if ( rnk[n1_par] == rnk[n2_par] ) rnk[n1_par]++;\n        }\n        return 0;\n}\n\nint find( int n1 )\n{\n        if ( n1 == rootnode[n1] ) {\n                return n1;\n        } else {\n                return rootnode[n1] = find( rootnode[n1] );\n        }\n}\n\nvoid init_union_find_tree( int n )\n{\n        for ( int i = 0 ; i < n ; i++ ) {\n                rootnode[i] = i;\n                rnk[i] = 0;\n        }\n}\n\nint sameroot( int n1, int n2 )\n{\n        int n1root, n2root;\n        n1root = find( n1 );\n        n2root = find( n2 );\n        if ( n1root == n2root ) {\n                return 1;\n        } else {\n                return 0;\n        }\n}\n\nint kruskal( node_t * nd, int size, int sidenum )\n{\n        int ans = 0;\n        int tmp_ans = 0;\n        int i;\n        for ( i = 0 ; i < sidenum ; i++ ) {\n                if ( sameroot( nd[i].n1, nd[i].n2 ) == 0 ){\n                        //printf( \"node%4d, node%4d sides%4d\\n\", nd[i].n1, nd[i].n2, nd[i].dist );\n                        //printf( \"=======\\n\" );\n                        //printf( \"root%4d, root%4d \\n\", find( nd[i].n1 ), find( nd[i].n2 ) );\n                        unite( nd[i].n1, nd[i].n2 );\n                        //printf( \"root%4d, root%4d \\n\", find( nd[i].n1 ), find( nd[i].n2 ) );\n                        //printf( \"---------\\n\" );\n                        tmp_ans += nd[i].dist;\n                        ans += nd[i].dist / 100 - 1;\n                }\n        }\n        return ans;\n}\n\nint main()\n{\n        int n, m, i, j;\n        char *tp, instr[50];\n        node_t nd[ (100*99) / 2 ];\n\n        while ( scanf( \"%d\", &n ) == 1 ) {\n                if ( n == 0 ) break;\n                scanf( \"%d\", &m );\n\n                /* データセット入力部分 */\n                for ( i = 0 ; i < m ; i++ ) {\n                        scanf( \"%s\", instr );\n                        /* カンマ区切りの文字列から数値を取得する */\n                        tp = strtok( instr, \",\" );\n                        nd[i].n1 = atoi( tp );\n                        tp = strtok( NULL, \",\" );\n                        nd[i].n2 = atoi( tp );\n                        tp = strtok( NULL, \",\" );\n                        nd[i].dist = atoi( tp );\n                }\n                sort( nd, m );\n                init_union_find_tree( n );\n                printf( \"%d\\n\", kruskal( nd, n, m ) );\n        }\n\n        return 0;\n}\n\n"
  },
  {
    "language": "C",
    "code": "// AOJ Volume0 0072\n// v@ÉæÁÄððßé\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_N   (100)\n\nint main(void)\n{\n    int n, m;\n    int i, j, loop;\n    int a, b, d;\n    int path[MAX_N][MAX_N];\n    int flag[MAX_N];\n    int min_s, min_e;\n    int lantern;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        if (n == 0){\n            break;\n        }\n    \n        // data init\n        memset(path, -1, sizeof(path));\n        memset(flag, 0, sizeof(flag));\n    \n        // data input\n        scanf(\"%d\", &m);\n        for (i = 0; i < m; i++){\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            path[a][b] = path[b][a] = d;\n        }\n        \n        lantern = 0;\n        flag[0] = 1;\n        \n        for (loop = 0; loop < n; loop++){\n            min_s = min_e = 0;\n            for (i = 0; i < n; i++){\n                if (flag[i] == 1){\n                    for (j = 0; j < n; j++){\n                        if (flag[j] == 0){\n                            if (path[i][j] > 0){\n                                if (path[min_s][min_e] == -1){\n                                    min_s = i;\n                                    min_e = j;\n                                }\n                                else if (path[min_s][min_e] > path[i][j]){\n                                    min_s = i;\n                                    min_e = j;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (path[min_s][min_e] != -1){\n                printf(\"<%d-%d (%d)>\\n\", min_s, min_e,path[min_s][min_e]);\n                lantern += (path[min_s][min_e] / 100 - 1);\n                path[min_s][min_e] = path[min_e][min_s] = -1;\n                flag[min_e] = 1;\n            }\n        }\n        \n        printf(\"%d\\n\", lantern);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        a[x][y]=1;\n        a[y][x]=1;\n        b[x][y]=z;\n        b[y][x]=z;\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]=>r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint V, n, sum;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid prim(int start) {\n    int x, p, step;\n\n    for (x = 0; x < V; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= V; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < V; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tsum += minimum;\n\tfor (x = 0 ; x < V; x++)\n\t    //\t    if (vertex[x].state == 0)\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m;\n     \n    while (1) {\n\tscanf(\"%d\", &V);\n        if (V == 0) break;\n\tscanf(\"%d\", &n);\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d,%d,%d\", &from, &to, &m);\n            W[from][to] = (m / 100) - 1;\n\t    W[to][from] = (m / 100) - 1;\n        }\n\n\tsum = 0;\n\n        prim(0);\n\n\tprintf(\"%d\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        a[x][y]=1;\n        a[y][x]=1;\n        b[x][y]=z;\n        b[y][x]=z;\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "c[100][100];n,m;u,t,l,x,y;main(){for(;scanf(\"%d%d\",&n,&m),n;printf(\"%d\\n\",l)){int d[100]={0};for(memset(c,9,40000);m--;c[u][l]=c[l][u]=t/100-1)scanf(\"%d,%d,%d\",&u,&l,&t);x=y=l=0;for(u=n;u--;x=t)for(d[x]=1,l+=y,y=x[*c]=**c,m=n;m--;m[*c]<y&&(t=m,y=m[*c]))!d[m]&&c[x][m]<m[*c]&&(m[*c]=c[x][m]);}exit(0);}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m,a[10000],b[10000],c[10000],f,pr,s,t,i,j,r[10000];\nint main(){\n  while(scanf(\"%d\",&n),n){\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      r[i]=i;\n      scanf(\"%d,%d,%d\",&a[i],&b[i],&c[i]);\n      a[i]++;\n      b[i]++;\n      for(j=i;j;j--){\n\tif(c[r[j-1]]>c[r[j]]){\n\t  t=r[j-1];\n\t  r[j-1]=r[j];\n\t  r[j]=t;\n\t}\n      }\n    }\n    int p[10010]={0};\n    int pi[10010]={0};//for(i=0;i<m;i++)printf(\"%d \",c[r[i]]);printf(\"\\n\");\n    for(i=s=pr=0;i<m;i++){\n      f=0;\n      if(pi[a[r[i]]])f+=1;\n      if(pi[b[r[i]]])f+=2;//printf(\"\\n%d\\n\",f);\n      if(f!=3||p[pi[a[r[i]]]]-p[pi[b[r[i]]]])s+=c[r[i]]/100-1;\n      if(f==0)pi[a[r[i]]]=pi[b[r[i]]]=p[++pr]=pr;\n      if(f==1)pi[b[r[i]]]=pi[a[r[i]]];\n      if(f==2)pi[a[r[i]]]=pi[b[r[i]]];\n      if(f==3&&p[pi[a[r[i]]]]-p[pi[b[r[i]]]])p[pi[a[r[i]]]]=p[pi[b[r[i]]]];\n      //for(j=0;j<=m;j++)printf(\"%d %d %d\\n\",j,pi[j],p[j]);\n    }\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1000000\n\nint cost[1000][1000];\nint mincost[1000];\nchar used[1000];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint i, j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tfor (j = 0; j < num; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d%*c%d%*c%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", prim());\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define min(x,y) ((x<y)?(x):(y))\nint main(){\n\tint n,m,d[105][105],f[105],u[105],i,j,x,y,ans;\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tif(n==0)break;\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<n;i++){\n\t\t\tf[i]=1000000;\n\t\t\tu[i]=0;\n\t\t\tfor(j=0;j<n;j++){\n\t\t\t\td[i][j]=1000000;\n\t\t\t}\n\t\t}\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,\",&x,&y);\n\t\t\tscanf(\"%d\",&d[x][y]);\n\t\t\td[y][x]=d[x][y];\n\t\t}\n\t\tans=1;f[0]=0;\n\t\twhile(1){\n\t\t\tx=-1;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tif(u[i]==0 && (x==-1 || f[i]<f[x]))x=i;\n\t\t\t}\n\t\t\tif(x==-1)break;\n\t\t\tu[x]=1;\n\t\t\tans+=f[x]/100-1;\n\t\t\tfor(i=0;i<n;i++){\n\t\t\t\tf[i]=min(f[i],d[x][i]);\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",ans);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint cost[1000][1000];\nint mincost[1000];\nchar used[1000];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = 1000000000;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint ans;\n\tint i, j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < V; i++){\n\t\t\tfor (j = 0; j < V; j++){\n\t\t\t\tcost[i][j] = 1000000000;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\tans = prim();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint V, n;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid prim(int start) {\n    int x, p, step;\n\n    for (x = 0; x < V; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= V; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < V; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tfor (x = 0 ; x < V; x++)\n\t    if (vertex[x].state == 0) {\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n\t    }\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m, sum;\n     \n    while (1) {\n\tscanf(\"%d\", &V);\n        if (V == 0) break;\n\tscanf(\"%d\", &n);\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d,%d,%d\", &from, &to, &m);\n            W[from][to] = m / 100 - 1;\n\t    W[to][from] = m / 100 - 1;\n        }\n\n        prim(0);\n\n\tsum = 0;\n\tfor (i = 1; i < n; i++) {\n\t    sum += (vertex[i].distance);\n\t}\n\tprintf(\"%d\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 1000000000\nvoid MST(int);\n\nint edge[101][101],v[101],d[101],sum=0,n;\n\nint main(void){\n\n  int m,a,b,i,j, cost;\n\n  while(1){\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++){\n\t  for(j=0;j<101;j++){\n\t      edge[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d,%d,%d\",&a,&b,&cost);\n\tedge[a][b]=cost;\n\tedge[b][a]=cost;\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n      sum = 0;\n      MST(0);\n\n      printf(\"%d\\n\",sum);\n    }\n\n  return 0;\n}\n\nvoid MST(int u)\n{\n  int x=0,i;\n\n  while(1){\n    int minv=INF;\n\n    for(i=0;i<n;i++){\n      if(v[i]==0 &&  d[i]<minv){\n\t//d[i]=edge[x][i];\n\tx=i;\n\tminv=d[i];\n      }\n    }\n    if(minv==INF)break;  \n\n    v[x]=1;\n    if ( x != u ) sum+=(d[x]/100-1);\n    \n    for(i=0;i<n;i++){\n      if ( v[i] ) continue;\n      d[i]=min(d[i],edge[x][i]);\n    }\n  }\n}\n\nint min(int x,int y)\n{\n  return x < y ? x : y;\n }"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    while(1){\n        scanf(\"%d\",&n);\n        if(n==0){\n            break;\n        }\n        scanf(\"%d\",&m);\n        for(h=0;h<m;h++){\n            scanf(\"%d,%d,%d\",&x,&y,&z);\n            a[x][y]=1;\n            a[y][x]=1;\n            b[x][y]=z;\n            b[y][x]=z;\n        }\n        while(1){\n            e=0;\n            for(h=0;h<n;h++){//????¢????\n                d=0;\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        c[0]=h;\n                        c[1]=i;\n                        d++;\n                    }\n                }\n                if(d==1){\n                    ans=ans+b[c[0]][c[1]];\n                    a[c[0]][c[1]]=0;\n                    a[c[1]][c[0]]=0;\n                    e++;\n                }\n            }\n            if(e==0){//?????????\n                r[0]=0;\n                r[1]=0;\n                r[2]=0;\n                for(h=0;h<n;h++){\n                    for(i=0;i<n;i++){\n                        if(a[h][i]==1){\n                            if(b[h][i]>=r[2]){\n                                r[0]=h;\n                                r[1]=i;\n                                r[2]=b[h][i];\n                            }\n                        }\n                    }\n                }\n                a[r[0]][r[1]]=0;\n                a[r[1]][r[0]]=0;\n            }\n            f=0;\n            for(h=0;h<n;h++){//break\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        f++;\n                    }\n                }\n            }\n            if(f==0){\n                break;\n            }\n        }\n        ans=ans/100-n+1;\n        printf(\"%d\\n\",ans);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        if(a[x][y]==0){\n            a[x][y]=1;\n            a[y][x]=1;\n            b[x][y]=z;\n            b[y][x]=z;\n        }\n        if(a[x][y]==1){\n            if(b[x][y]>z){\n                a[x][y]=1;\n                a[y][x]=1;\n                b[x][y]=z;\n                b[y][x]=z;\n            }\n        }\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>=r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "d[150][120];j,s,t,m,n,*p;main(i){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",s)){for(memset(d,9,7e4);t=m--;d[i][j]=d[j][i]=s/100)scanf(\"%d,%d,%d\",&i,&j,&s);for(s=i=1-n;i++;s+=d[t=m][n])for(d[t][j=m=n]=0;j--;*p&&d[m][n]>*p?m=j:0)p=d[j]+n,*p=fmin(*p,p[t-n]);}}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 100\nint par[MAX_N];\nint rank[MAX_N];\n\ntypedef struct{int p1; int p2; int leng;}map;\n\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx =find(x);\n\ty =find(y);\n\tif(x==y){\n\t\treturn ;\n\t}\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\n\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint comp(const void* c1,const void* c2);\n\nint main(){\n\tint n,m,i,count,num;\n\tmap* road;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\t\tinit(n);\n\n\t\tscanf(\"%d\\n\",&m);\n\t\troad=(map*)malloc(m*sizeof(map));\n\t\tfor(i=0;i<n;i++){\n\t\t\tscanf(\"%d,%d,%d\\n\",&road[i].p1,&road[i].p2,&road[i].leng);\n\t\t}\n\n\t\tqsort(road,m,sizeof(map),comp);\n\t\ti=0;\n\t\twhile(count!=n-1){\n\t\t\tif(!same(road[i].p1,road[i].p2)){\n\t\t\t\tcount++;\n\t\t\t\tnum+=(road[i].leng/100)-1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\\n\",num);\n\t}\n\treturn 0;\n}\n\nint comp(const void *c1,const void *c2){\n\tmap data1=*(map*)c1;\n\tmap data2=*(map*)c2;\n\n\tint temp1=data1.leng;\n\tint temp2=data2.leng;\n\n\treturn temp1-temp2;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint W[100][100];\nint dist[100];\nint prev[100];\nint U[100];\n\nmain(){\n  int i, j, n, m, a, b, c, min, p, ans, count, temp;\n\n  while(1){\n    scanf(\"%d\", &n);\n    if(n==0) break;\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tW[i][j]=10000000;\n      }\n    }\n    scanf(\"%d\", &m);\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      W[a][b]=W[b][a]=c;\n    }\n    ans=10000001;\n    for(count=0;count<n;count++){\n      for(i=0;i<n;i++){\n\tdist[i]=10000000;\n\tU[i]=1;\n\tprev[i]=0;\n      }\n      \n      dist[count]=0;\n      \n      for(i=0;i<n;i++){\n\tmin=10000001;\n\tfor(j=0;j<n;j++){\n\t  if(U[j]==1 && min>dist[j]){\n\t    p=j;\n\t    min=dist[j];\n\t  }\n\t}\n\tU[p]=0;\n\tfor(j=0;j<n;j++){\n\t  if(U[j]==1 && (dist[j]>dist[p]+W[p][j])){\n\t    dist[j]=dist[p]+W[p][j];\n\t    prev[j]=p;\n\t  }\n\t}\n      }\n      \n      temp=0;\n      for(i=0;i<n;i++){\n\tif(i==count) temp+=dist[i];\n\telse temp+=dist[i]-100;\n      }\n      temp/=100;\n      if(temp<ans) ans=temp;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nint main(void){\n\tint n,m,a,b,x,i,j,path[10000][3],pot[110];\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tfor(i=0;i<n;i++)pot[i]=1;\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&x);\n\t\t\tfor(j=i;j>0;j--){\n\t\t\t\tif(path[j-1][2]>x){\n\t\t\t\t\tpath[j][2]=path[j-1][2];\n\t\t\t\t\tpath[j][1]=path[j-1][1];\n\t\t\t\t\tpath[j][0]=path[j-1][0];\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tpath[j][2]=x;\n\t\t\tpath[j][1]=b;\n\t\t\tpath[j][0]=a;\n\t\t}\n\t\tx=0;\n\t\tfor(i=0;i<m && n>0;i++){\n\t\t\ta=path[i][0];\n\t\t\tb=path[i][1];\n\t\t\tif(pot[a]==1 || pot[b]==1){\n\t\t\t\tn-=pot[a]+pot[b];\n\t\t\t\tpot[a]=0;pot[b]=0;\n\t\t\t\tx+=path[i][2]/100-1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,a[100],b[100],c[100],f,pr,s,t,i,j,r[100];\n  while(scanf(\"%d\",&n),n){\n    scanf(\"%d\",&m);\n    for(i=0;i<n;i++){\n      r[i]=i;\n      scanf(\"%d,%d,%d\",&a[i],&b[i],&c[i]);\n      a[i]++;\n      b[i]++;\n      for(j=i;j;j--){\n\tif(c[r[j-1]]>c[r[j]]){\n\t  t=r[j-1];\n\t  r[j-1]=r[j];\n\t  r[j]=t;\n\t}\n      }\n    }\n    int p[101]={0};\n    int pi[101]={0};//for(i=0;i<m;i++)printf(\"%d \",c[r[i]]);printf(\"\\n\");\n    for(i=s=pr=0;i<m;i++){\n      f=0;\n      if(pi[a[r[i]]])f+=1;\n      if(pi[b[r[i]]])f+=2;//printf(\"\\n%d\\n\",f);\n      if(f!=3||p[pi[a[r[i]]]]-p[pi[b[r[i]]]])s+=c[r[i]]/100-1;\n      if(f==0)pi[a[r[i]]]=pi[b[r[i]]]=p[++pr]=pr;\n      if(f==1)pi[b[r[i]]]=pi[a[r[i]]];\n      if(f==2)pi[a[r[i]]]=pi[b[r[i]]];\n      if(f==3&&p[pi[a[r[i]]]]-p[pi[b[r[i]]]])p[pi[a[r[i]]]]=p[pi[b[r[i]]]];\n      //for(j=0;j<=m;j++)printf(\"%d %d %d\\n\",j,pi[j],p[j]);\n    }\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,i,j,k,mi,c[110],d[110][110],f[110]={0};\n  while(scanf(\"%d\",&n),n){\n    for(i=0;i<110*110;i++)d[i/110][i%110]=1e9;\n    scanf(\"%d\",&m);\n    while(m--){\n      scanf(\"%d,%d,%d\",&i,&j,&k);\n      d[i][j]=d[j][i]=k/100-1;\n    }\n    for(i=0;i<110;i++)f[i]=0;\n    for(i=mi=k=0;i<110;i++)c[i]=1e9;\n    for(i=c[0]=0;i<n;i++){\n      f[mi]=1;\n      k+=c[mi];\n      for(j=0;j<n;j++){\n\tif(c[j]>d[mi][j])c[j]=d[mi][j];\n      }\n      for(mi=0;f[mi];mi++);\n      for(j=0;j<n;j++){\n\tif(f[j]==0&&c[mi]>c[j])mi=j;\n      }\n    }\n    printf(\"%d\\n\",k);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 0x09090909\nint main(){\n\tint n, m;\n\tint i, j;\n\twhile(scanf(\"%d%d\", &n, &m), n) {\n\t\tint cost[100][100] = {0};\n\t\tint determined[100] = {0}, undeterminednodes = n;\n\t\tint costsum = 0;\n\t\tint minnode, minnodecost, nextminnode;\n\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tfor(j = 0; j < n; j ++) {\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d/100-1;\n\t\t}\n\t\tminnode = 0;\n\t\tminnodecost = 0;\n\n\t\twhile(undeterminednodes > 0) {\n\t\t\tdetermined[minnode] = 1;\n\t\t\tcostsum += minnodecost;\n\t\t\tundeterminednodes --;\n\t\t\tcost[0][minnode] = INF;\n\t\t\tminnodecost = INF;\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(!determined[i]) {\n\t\t\t\t\tif(cost[minnode][i] < cost[0][i])\n\t\t\t\t\t\tcost[0][i] = cost[minnode][i];\n\t\t\t\t}\n\t\t\t\tif(cost[0][i] < minnodecost) {\n\t\t\t\t\tnextminnode = i;\n\t\t\t\t\tminnodecost = cost[0][i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tminnode = nextminnode;\n\t\t}\n\t\tprintf(\"%d\\n\", costsum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 100000000\nvoid MST(int);\n\n\nint node[101][101],v[101],d[101],sum,n,count;\n\nint main(void)\n{\n  int m,a,b,i,j;\n\n  while(1)\n    {\n      count=0;\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++)\n\t{\n\t  for(j=0;j<101;j++)\n\t    {\n\t      node[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d,%d,%d\",&a,&b,&d[i]);\n\tnode[a][b]=d[i];\n\tnode[b][a]=d[i];\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n\n      //for(i=0;i<n;i++)\n\tif(v[i]==0)MST(i);\n\n      for(i=0;i<5;i++){\n\t//printf(\"%d %d\\n\",v[i],i);\n      }\n      printf(\"%d\\n\",sum/100-count+1);\n    }\n\n  return 0;\n}\n\n\nvoid MST(int u)\n{\n  int x,i;\n  v[u]=1;\n    for(i=0;i<n;i++){\n      if(d[i]>node[u][i] &&v[i]==0){\n\td[i]=node[u][i];\n\tx=i;\n      }\n      //if(u==1)printf(\"%d\\n\",node[u][j]);\n  }\n\n    if(d[u]<INF){\nsum+=d[u];\n count++;\n}\n\n  for(i=0;i<n;i++)\nd[i]=min(d[i],node[u][i]);\n\n  if(v[x]==0 && x<n)MST(x);\n}\n\nint min(int x,int y)\n{\n  return x < y ? y : x;\n  }"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main(){\n\tint n, m;\n\tint i, j;\n\twhile(scanf(\"%d%d\", &n, &m), n) {\n\t\tint cost[100][100] = {0};\n\t\tint determined[100] = {0}, undeterminednodes;\n\t\tint mincost[100] = {0};\n\t\tint costsum = 0;\n\t\tint minnode, minnodecost;\n\n\t\t// initialize cost table\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tfor(j = 0; j < n; j ++) {\n\t\t\t\tcost[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\t// load\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d/100-1;\n\t\t}\n\n\t\t// node 0 is determined\n\t\tdetermined[0] = 1;\n\t\tundeterminednodes = n-1;\n\n\t\t// initialize mincost\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tif(!determined[i]) {\n\t\t\t\tmincost[i] = cost[0][i];\n\t\t\t} else {\n\t\t\t\tmincost[i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\twhile(undeterminednodes > 0) {\n\t\t\t// select the nearest undetermined node\n\t\t\tminnodecost = INT_MAX;\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(mincost[i] < minnodecost) {\n\t\t\t\t\tminnode = i;\n\t\t\t\t\tminnodecost = mincost[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// the node is determined\n\t\t\tdetermined[minnode] = 1;\n\t\t\tcostsum += minnodecost;\n\t\t\tundeterminednodes --;\n\t\t\tmincost[minnode] = INT_MAX;\n\n\t\t\t// update mincost\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(!determined[i]) {\n\t\t\t\t\tif(cost[minnode][i] < mincost[i])\n\t\t\t\t\t\tmincost[i] = cost[minnode][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", costsum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint W[100][100];\nint dist[100];\nint prev[100];\nint U[100];\n\nmain(){\n  int i, j, n, m, a, b, c, min, p, ans, count, temp;\n\n  while(1){\n    scanf(\"%d\", &n);\n    if(n==0) break;\n\n    for(i=0;i<n;i++){\n      for(j=0;j<n;j++){\n\tW[i][j]=10000000;\n      }\n    }\n    scanf(\"%d\", &m);\n    for(i=0;i<m;i++){\n      scanf(\"%d,%d,%d\", &a, &b, &c);\n      W[a][b]=W[b][a]=c;\n    }\n    ans=10000001;\n    for(count=0;count<n;count++){\n      for(i=0;i<n;i++){\n\tdist[i]=10000000;\n\tU[i]=1;\n\tprev[i]=0;\n      }\n      \n      dist[count]=0;\n      \n      for(i=0;i<n;i++){\n\tmin=10000001;\n\tfor(j=0;j<n;j++){\n\t  if(U[j]==1 && min>dist[j]){\n\t    p=j;\n\t    min=dist[j];\n\t  }\n\t}\n\tU[p]=0;\n\tfor(j=0;j<n;j++){\n\t  if(U[j]==1 && (dist[j]>dist[p]+W[p][j])){\n\t    dist[j]=dist[p]+W[p][j];\n\t    prev[j]=p;\n\t  }\n\t}\n      }\n      \n      temp=0;\n      for(i=0;i<n;i++){\n\tif((dist[i]-100)>=0 && i!=count)temp+=dist[i]-100;\n\telse temp+=dist[i];\n      }\n      temp/=100;\n      if(temp<ans) ans=temp;\n    }\n    printf(\"%d\\n\", ans);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<stdlib.h>\n\nint n,v,e[100001][3],i,p[10001],r=0;\n\nint c(const void *x,const void *y)\n{\n\treturn ((int*)x)[2]-((int*)y)[2];\n}\n\nint a(int x)\n{\n\treturn p[x]==x?x:a(p[x]);\n}\n\nint main()\n{\n\tfor(;~scanf(\"%d%d\",&n,&v),n;)\n\t{\n\t\tfor(i=0;i<=n;i++)\n\t\t\tp[i]=i;\n\t\tfor(i=0;i<v;e[i][2]=e[i][2]/100-1,i++)\n\t\t\tscanf(\"%d,%d,%d\",&e[i][0],&e[i][1],&e[i][2]);\n\t\tqsort(e,v,sizeof(int[3]),c);\n\t\tfor(i=r=0;i<v;i++)\n\t\t\tif(a(e[i][0])!=a(e[i][1]))\n\t\t\t{\n\t\t\t\tr+=e[i][2];\n\t\t\t\tp[a(e[i][0])]=p[a(e[i][1])];\n\t\t\t}\n\t\tprintf(\"%d\\n\",r);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define LIMIT_NODES (100)\n\nint compare(const void *a, const void *b) {\n\treturn ((int*)a)[2] - ((int*)b)[2];\n}\n\nint solve(int num_node) {\n\tint i, k, num_edge, answer, node1, node2;\n\tchar forest[LIMIT_NODES][LIMIT_NODES];\n\n\tscanf(\"%d \", &num_edge);\n\tint S[num_edge][3];\n\n\tfor (i = 0; i < num_edge; i++) {\n\t\tscanf(\"%d,%d,%d \", S[i]+0, S[i]+1, S[i]+2);\n\t}\n\tqsort(S, num_edge, sizeof(S[0]), compare);\n\n\tmemset(forest, 0, sizeof(forest[0]) * LIMIT_NODES);\n\tfor (i = 0; i < num_node; i++) {\n\t\tforest[i][i] = 1;\n\t}\n\n\tanswer = 0;\n\tfor (i = 0; i < num_edge; i++) {\n\t\tnode1 = node2 = 0;\n\t\tfor (k = 0; k < num_node; k++) {\n\t\t\tif (forest[k][S[i][0]]) {\n\t\t\t\tnode1 = k;\n\t\t\t}\n\t\t\tif (forest[k][S[i][1]]) {\n\t\t\t\tnode2 = k;\n\t\t\t}\n\t\t}\n\t\tif (node1 != node2) {\n\t\t\tfor (k = 0; k < LIMIT_NODES; k++) {\n\t\t\t\tforest[node1][k] |= forest[node2][k];\n\t\t\t\tforest[node2][k] = 0;\n\t\t\t}\n\t\t\tanswer += (S[i][2] / 100) - 1;\n\t\t}\n\t}\n\treturn answer;\n}\n\nint main(void) {\n\tint num_node;\n\n\twhile (1) {\n\t\tscanf(\"%d \", &num_node);\n\t\tif (!num_node)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(num_node));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "d[150][120];j,s,t,m,n,*p;main(i){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",s)){for(memset(d,9,7e4);t=m--;d[i][j]=d[j][i]=s/100)scanf(\"%d,%d,%d\",&i,&j,&s);for(s=i=1-n;i++;s+=d[n][t=m])for(d[j=m=n][t]=0;j--;*p&&d[n][m]>*p?m=j:0)p=d[n]+j,*p=fmin(*p,d[t][j]);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define MM\t10000000\nint main(void)\n{\n\tint a[500][500];\n\tint n,m,i,j,k;\n\tint x,y,leng,minx,miny,minl;\n\tint flg[500];\n\tint cnt;\n\tint sum;\n\t\n\twhile(1)\t{\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)\tbreak;\n\t\tfor(i=0;i<n;i++)\t{\n\t\t\tfor(j=0;j<n;j++)\t{\n\t\t\t\ta[i][j]=MM;\n\t\t\t}\n\t\t}\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++)\t{\n\t\t\tscanf(\"%d,%d,%d\",&x,&y,&leng);\n\t\t\tleng=leng/100-1;\n\t\t\ta[x][y]=leng;\n\t\t\ta[y][x]=leng;\n\t\t}\n\n\t\tfor(i=0;i<n;i++)\t{\n\t\t\tflg[i]=0;\n\t\t}\n\t\tflg[0]=1;\n\t\tcnt=1;\n\t\tsum=0;\n\t\twhile(cnt<n)\t{\n\t\t\tminl=MM;\n\t\t\tfor(i=0;i<n;i++)\t{\n\t\t\t\tif(flg[i]==1)\t{\n\t\t\t\t\tfor(j=0;j<n;j++)\t{\n\t\t\t\t\t\tif(flg[j]==0 && a[i][j]<minl)\t{\n\t\t\t\t\t\t\tminl=a[i][j];\n\t\t\t\t\t\t\tminx=i;\n\t\t\t\t\t\t\tminy=j;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tsum+=minl;\n\t\t\tflg[miny]=1;\n\t\t\tcnt++;\n\t\t}\n\t\tprintf(\"%d\\n\",sum);\n\t}\n\treturn 0;\n}\n"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        if(a[x][y]==0){\n            a[x][y]=1;\n            a[y][x]=1;\n            b[x][y]=z;\n            b[y][x]=z;\n        }\n        if(a[x][y]==1){\n            if(b[x][y]>z){\n                a[x][y]=1;\n                a[y][x]=1;\n                b[x][y]=z;\n                b[y][x]=z;\n            }\n        }\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>=r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 1000000000\nvoid MST(int);\n\nint node[101][101],v[101],d[101],sum,n,count;\n\nint main(void)\n{\n  int m,a,b,i,j;\n\n  while(1)\n    {\n      count=0;\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++)\n\t{\n\t  for(j=0;j<101;j++)\n\t    {\n\t      node[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d,%d,%d\",&a,&b,&d[i]);\n\tnode[a][b]=d[i];\n\tnode[b][a]=d[i];\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n\n\tif(v[i]==0)MST(i);\n\n      printf(\"%d\\n\",sum/100-count+1);\n    }\n\n  return 0;\n}\n\nvoid MST(int u)\n{\n  int x,i;\n  v[u]=1;\n    for(i=0;i<n;i++){\n      if(d[i]>node[u][i] &&v[i]==0){\n\td[i]=node[u][i];\n\tx=i;\n      }\n  }\n\n    if(d[u]<INF){\nsum+=d[u];\n count++;\n}\n\n  for(i=0;i<n;i++)\nd[i]=min(d[i],node[u][i]);\n\n  if(v[x]==0 && x<n)MST(x);\n}\n\nint min(int x,int y)\n{\n  return x < y ? y : x;\n  }"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        a[x][y]=1;\n        a[y][x]=1;\n        b[x][y]=z;\n        b[y][x]=z;\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 1000000000\nvoid MST(int);\n\nint edge[101][101],v[101],d[101],sum=0,n;\n\nint main(void){\n\n  int m,a,b,i,j, cost;\n\n  while(1){\n      count=0;\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++){\n\t  for(j=0;j<101;j++){\n\t      edge[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d,%d,%d\",&a,&b,&cost);\n\tedge[a][b]=cost;\n\tedge[b][a]=cost;\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n      sum = 0;\n      MST(0);\n\n      printf(\"%d\\n\",sum);\n    }\n\n  return 0;\n}\n\nvoid MST(int u)\n{\n  int x=0,i;\n\n  while(1){\n    int minv=INF;\n\n    for(i=0;i<n;i++){\n      if(v[i]==0 &&  d[i]<minv){\n\t//d[i]=edge[x][i];\n\tx=i;\n\tminv=d[i];\n      }\n    }\n    if(minv==INF)break;  \n\n    v[x]=1;\n    if ( x != u ) sum+=(d[x]/100-1);\n    \n    for(i=0;i<n;i++){\n      if ( v[i] ) continue;\n      d[i]=min(d[i],edge[x][i]);\n    }\n  }\n}\n\nint min(int x,int y)\n{\n  return x < y ? x : y;\n }"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <limits.h>\n\n#define MAX_V\t(100)\n\nint main(int argc, char const *argv[])\n{\n\tint E[MAX_V][MAX_V], V;\n\n\twhile (scanf(\"%d\", &V), V){\n\t\tint used[MAX_V] = {0};\n\t\tint m;\n\t\tint count, min_c, min_v;\n\t\tint lantern;\n\t\tint i, j;\n\t\t\n\t\t// init\n\t\tfor (i = 0; i < V; i++){\n\t\t\tfor (j = 0; j < V; j++){\n\t\t\t\tE[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\tscanf(\"%d\", &m);\n\t\tfor (i = 0; i < m; i++){\n\t\t\tint from, to, cost;\n\t\t\tscanf(\"%d,%d,%d\", &from, &to, &cost);\n\t\t\tE[from][to] = E[to][from] = cost / 100 - 1;\n\t\t}\n\n\t\tused[0] = 1;\n\t\tcount = 1;\n\t\tlantern = 0;\n\n\t\twhile (count < V){\n\t\t\tmin_v = INT_MAX;\n\t\t\tfor (i = 0; i < V; i++){\n\t\t\t\tif (!used[i]) continue;\n\t\t\t\tfor (j = 0; j < V; j++){\n\t\t\t\t\tif (used[j]) continue;\n\t\t\t\t\tif (min_v > E[i][j]){\n\t\t\t\t\t\tmin_v = E[i][j];\n\t\t\t\t\t\tmin_c = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tlantern += min_v;\n\t\t\tused[min_c] = 1;\n\t\t\tcount++;\n\t\t}\n\t\tprintf(\"%d\\n\", lantern);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main(){\n\tint n, m;\n\tint i, j;\n\twhile(scanf(\"%d%d\", &n, &m), n) {\n\t\tint cost[100][100] = {0};\n\t\tint determined[100] = {0}, undeterminednodes = n;\n\t\tint mincost[100] = {0};\n\t\tint costsum = 0;\n\t\tint minnode, minnodecost;\n\n\t\t// initialize cost table\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tfor(j = 0; j < n; j ++) {\n\t\t\t\tcost[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\t// load\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d/100-1;\n\t\t}\n\n\t\t// node 0 is determined\n\t\tminnode = 0;\n\t\tminnodecost = 0;\n\n\t\t// initialize mincost\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tmincost[i] = INT_MAX;\n\t\t}\n\n\t\twhile(undeterminednodes > 0) {\n\t\t\t// the node is determined\n\t\t\tdetermined[minnode] = 1;\n\t\t\tcostsum += minnodecost;\n\t\t\tundeterminednodes --;\n\t\t\tmincost[minnode] = INT_MAX;\n\n\t\t\t// update mincost\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(!determined[i]) {\n\t\t\t\t\tif(cost[minnode][i] < mincost[i])\n\t\t\t\t\t\tmincost[i] = cost[minnode][i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// select the nearest undetermined node\n\t\t\tminnodecost = INT_MAX;\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(mincost[i] < minnodecost) {\n\t\t\t\t\tminnode = i;\n\t\t\t\t\tminnodecost = mincost[i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", costsum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>          // printf(), scanf()\n#include <stdbool.h>\n\n#define MAX_V 100\n#define min(a, b) ((a) < (b) ? (a) : (b))\n\nconst int INF = 100000000;\nint cost[MAX_V][MAX_V];\nint V;\n\nint\nprim()\n{\n\tint mincost[MAX_V];\n\tbool used[MAX_V];\n\tint u;\n\n\tfor (u = 0; u < V; ++u)\n\t{\n\t\tmincost[u] = INF;\n\t\tused[u] = false;\n\t}\n\n\tmincost[0] = 0;\n\tint res = 0;\n\twhile (true)\n\t{\n\t\tint v = -1;\n\t\tfor (u = 0; u < V; ++u)\n\t\t{\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\tv = u;\n\t\t}\n\n\t\tif (v == -1)\n\t\t\tbreak;\n\n\t\tused[v] = true;\n\t\tres += mincost[v];\n\t\tfor (u = 0; u < V; ++u)\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t}\n\n\treturn res;\n}\n\nint\nmain(int argc, char **argv)\n{\n\tint E;\n\tint a, b, d;\n\tint u, v;\n\tint i;\n\n\twhile (true)\n\t{\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0)\n\t\t\tbreak;\n\n\t\tfor (v = 0; v < V; ++v)\n\t\t{\n\t\t\tfor (u = 0; u < V; ++u)\n\t\t\t\tcost[v][u] = INF;\n\t\t}\n\n\t\tscanf(\"%d\", &E);\n\t\tfor (i = 0; i < E; ++i)\n\t\t{\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = d / 100 - 1;\n\t\t\tcost[b][a] = d / 100 - 1;\n\t\t}\n\n\t\tprintf(\"%d\\n\", prim());\n\t}\n\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 100000000\nvoid MST(int);\n\n\nint node[101][101],v[101],d[101],sum,n;\n\nint main(void)\n{\n  int m,a,b,i,j;\n  char w,z;\n\n  while(1)\n    {\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++)\n\t{\n\t  for(j=0;j<101;j++)\n\t    {\n\t      node[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d%c%d%c%d\",&a,&w,&b,&z,&d[i]);\n\tnode[a][b]=d[i];\n\tnode[b][a]=d[i];\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n\n      //for(i=0;i<n;i++)\n\tif(v[i]==0)MST(i);\n\n      for(i=0;i<5;i++){\n\t//printf(\"%d %d\\n\",v[i],i);\n      }\n      printf(\"%d\\n\",sum/100-n+1);\n    }\n\n  return 0;\n}\n\n\nvoid MST(int u)\n{\n  int x,i;\n  v[u]=1;\n    for(i=0;i<n;i++){\n      if(d[i]>node[u][i] &&v[i]==0){\n\td[i]=node[u][i];\n\tx=i;\n      }\n      //if(u==1)printf(\"%d\\n\",node[u][j]);\n  }\n\n  if(d[u]<INF)sum+=d[u];\n\n  for(i=0;i<n;i++)\nd[i]=min(d[i],node[u][i]);\n\n  if(v[x]==0 && x<n)MST(x);\n}\n\nint min(int x,int y)\n{\n  return x < y ? y : x;\n  }"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\nint main(void)\n{\n\tint n;\n\t\n\twhile (scanf(\"%d\", &n)*n){\n\t\tint m;\n\t\tint lantern = 0;\n\t\t\n\t\tscanf(\"%d\", &m);\n\t\twhile (m-- > 0){\n\t\t\tint a, b, d;\n\t\t\t\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tlantern += d / 100 - 1;\n\t\t}\n\t\tprintf(\"%d\\n\", lantern);\n\t}\n\t\n\treturn n;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<limits.h>\nint main(){\n\tint n, m;\n\tint i, j;\n\twhile(scanf(\"%d%d\", &n, &m), n) {\n\t\tint cost[100][100] = {0};\n\t\tint determined[100] = {0}, undeterminednodes;\n\t\tint mincost[100] = {0};\n\t\tint costsum = 0;\n\t\tint minnode, minnodecost;\n\n\t\t// initialize cost table\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tfor(j = 0; j < n; j ++) {\n\t\t\t\tcost[i][j] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\t// load\n\t\tfor(i = 0; i < m; i ++) {\n\t\t\tint a, b, d;\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &d);\n\t\t\tcost[a][b] = cost[b][a] = d/100-1;\n\t\t}\n\n\t\t// node 0 is determined\n\t\tdetermined[0] = 1;\n\t\tundeterminednodes = m-1;\n\n\t\t// initialize mincost\n\t\tfor(i = 0; i < n; i ++) {\n\t\t\tif(!determined[i]) {\n\t\t\t\tmincost[i] = cost[0][i];\n\t\t\t} else {\n\t\t\t\tmincost[i] = INT_MAX;\n\t\t\t}\n\t\t}\n\n\t\twhile(undeterminednodes > 0) {\n\t\t\t// select the nearest undetermined node\n\t\t\tminnodecost = INT_MAX;\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(mincost[i] < minnodecost) {\n\t\t\t\t\tminnode = i;\n\t\t\t\t\tminnodecost = mincost[i];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// the node is determined\n\t\t\tdetermined[minnode] = 1;\n\t\t\tcostsum += minnodecost;\n\t\t\tundeterminednodes --;\n\t\t\tmincost[minnode] = INT_MAX;\n\n\t\t\t// update mincost\n\t\t\tfor(i = 0; i < n; i ++) {\n\t\t\t\tif(!determined[i]) {\n\t\t\t\t\tif(cost[minnode][i] < mincost[i])\n\t\t\t\t\t\tmincost[i] = cost[minnode][i];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\", costsum);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define N 100\n\n/* global */\nint marked[N]; // as it's name\n\nvoid recursiveSearch( int map[N][N], int n, int start ){\n  int i;\n\n  if( marked[ start ] == 1 ){\n    return;\n  }\n\n  marked[ start ] = 1; // mark\n\n  for( i = 0; i < n; i++ ){\n    if( start != i ){ // \n      if( map[ start ][ i ] > 0 ){\n        recursiveSearch( map, n, i );\n      }\n    }\n  }\n}\n\nint main( void ){\n  int i, j; // counter\n  int n, m;\n  int a[N], b[N], dis[N];\n  char hoge;\n  int map[N][N]; // Matrix\n  int ans;\n  int minDis, minDisIndex;\n  int num;\n\n  while( 1 ){\n    scanf( \"%d\", &n );\n    if( !n ) break;\n    scanf( \"%d\", &m );\n\n    for( i = 0; i < n; i++ ){\n      for( j = 0; j < n; j++ ){\n        map[ i ][ j ] = 0; // not connected\n      }\n    }\n\n    for( i = 0; i < m; i++ ){\n      scanf( \"%d%c%d%c%d\", &a[i], &hoge, &b[i], &hoge, &dis[i] );\n    }\n\n    num = 0; // final ans\n\n    while( 1 ){\n      minDis = 0;\n      for( i = 0; i < m; i++ ){\n        if( dis[ i ] > 0 ){\n          minDis = dis[ i ];\n          minDisIndex = i;\n          break;\n        }\n      }\n\n      if( i == m ){\n        break;\n      }\n\n      for( i++; i < m; i++ ){\n        if( dis[ i ] > 0 && minDis > dis[ i ] ){\n          minDis = dis[ i ];\n          minDisIndex = i;\n        }\n      }\n\n      /* addition */\n      map[ a[ minDisIndex ] ][ b[ minDisIndex ] ] = dis[ minDisIndex ];\n      map[ b[ minDisIndex ] ][ a[ minDisIndex ] ] = dis[ minDisIndex ];\n\n      num += dis[ minDisIndex ] / 100 - 1;\n      dis[ minDisIndex ] = 0;\n\n      /* connected judge */\n      for( i = 0; i < n; i++ ){\n        marked[i] = 0; // not marked( initialize )\n      }\n      recursiveSearch( map, n, 0 );\n      ans = 1; // connected\n      for( i = 0; i < n; i++ ){\n        if( marked[i] == 0 ){\n          ans = 0; // not connected\n          break;\n        }\n      }\n\n      if( ans == 1 ){\n        printf( \"%d\\n\", num );\n        break;\n      }\n    }\n  }\n\n  return( 0 );\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint from, to;\n\tint weight;\n} Edge;\n\nconst int INF = 10000000000;\n\nint main(void)\n{\n\tEdge edges[10000];\n\tint n, m; \n\tint i, j;\n\tint a, b, v;\n\tint min, sum;\n\tint ch[105], ind;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &n);\n\t\t\n\t\tif (n == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &m);\n\t\t\n\t\tfor (i = 0; i < m; i++){\n\t\t\tscanf(\"%d,%d,%d\", &a, &b, &v);\n\t\t\tedges[i].from = a;\n\t\t\tedges[i].to = b;\n\t\t\tedges[i].weight = (v / 100) - 1;\n\t\t}\n\t\tfor (i = 0; i < n; i++) ch[i] = 0;\n\t\t\n\t\tsum = 0;\n\t\tch[0] = 1;\n\t\t\n\t\tfor (i = 0; i < n; i++){\n\t\t\tmin = INF;\n\t\t\tfor (j = 0; j < m; j++){\n\t\t\t\t\n\t\t\t\tif ( (ch[edges[j].from] == 1 && ch[edges[j].to] == 0) || (ch[edges[j].from] == 0 && ch[edges[j].to] == 1)){\n\t\t\t\t\tif (edges[j].weight < min){\n\t\t\t\t\t\tmin = edges[j].weight;\n\t\t\t\t\t\tind = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif (min == INF){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (ch[edges[ind].from] == 1 && ch[edges[ind].to] == 0){\n\t\t\t\tch[edges[ind].to] = 1;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tch[edges[ind].from] = 1;\n\t\t\t}\n\t\t\tsum += edges[ind].weight;\n\t\t}\n\t\t\n\t\tprintf(\"%d\\n\", sum);\n\t}\n\t\n\t\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\ntypedef struct {\n\tint connected;\n\tint distance[100];\n}onesiseki;\n\nint main(void) {\n\tonesiseki siseki[100];\n\tint sisekinum;\n\tint i,j;\n\tint roadnum;\n\tint a,b,dist;\n\tint distancesum;\n\tint minsiseki,minsisekito,mindist;\n\twhile(1) {\n\t\tscanf(\"%d\",&sisekinum);\n\t\tif(sisekinum==0)break;\n\t\tfor(i=0;i<sisekinum;i++) {\n\t\t\tsiseki[i].connected=0;\n\t\t\tfor(j=0;j<sisekinum;j++)siseki[i].distance[j]=-1;\n\t\t}\n\t\tscanf(\"%d\",&roadnum);\n\t\tfor(i=0;i<roadnum;i++) {\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&dist);\n\t\t\tsiseki[a].distance[b]=dist;\n\t\t\tsiseki[b].distance[a]=dist;\n\t\t}\n\t\tsiseki[0].connected=1;\n\t\tdistancesum=0;\n\t\twhile(1) {\n\t\t\tminsiseki=minsisekito=mindist=-1;\n\t\t\tfor(i=0;i<sisekinum;i++) {\n\t\t\t\tif(siseki[i].connected) {\n\t\t\t\t\tfor(j=0;j<sisekinum;j++) {\n\t\t\t\t\t\tif(siseki[j].connected==0 && siseki[i].distance[j]>0) {\n\t\t\t\t\t\t\tif(mindist<0 || siseki[i].distance[j]<mindist) {\n\t\t\t\t\t\t\t\tmindist=siseki[i].distance[j];\n\t\t\t\t\t\t\t\tminsiseki=i;\n\t\t\t\t\t\t\t\tminsisekito=j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(minsiseki==-1)break;\n\t\t\tdistancesum+=mindist;\n\t\t\tsiseki[minsisekito].connected=1;\n\t\t}\n\t\tprintf(\"%d\\n\",distancesum/100);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,a[100],b[100],c[100],f,pr,s,t,i,j,r[100];\n  while(scanf(\"%d\",&n),n){\n    scanf(\"%d\",&m);\n    for(i=0;i<n;i++){\n      r[i]=i;\n      scanf(\"%d,%d,%d\",&a[i],&b[i],&c[i]);\n      a[i]++;\n      b[i]++;\n      for(j=i;j;j--){\n\tif(c[r[j-1]]>c[r[j]]){\n\t  t=r[j-1];\n\t  r[j-1]=r[j];\n\t  r[j]=t;\n\t}\n      }\n    }\n    int p[100]={0};\n    int pi[100]={0};//for(i=0;i<m;i++)printf(\"%d \",c[r[i]]);printf(\"\\n\");\n    pr=0;\n    for(i=s=0;i<m;i++){\n      f=0;\n      if(pi[a[r[i]]])f+=1;\n      if(pi[b[r[i]]])f+=2;//printf(\"\\n%d\\n\",f);\n      if(f!=3||p[pi[a[r[i]]]]-p[pi[b[r[i]]]])s+=c[r[i]]/100-1;\n      if(f==0)pi[a[r[i]]]=pi[b[r[i]]]=p[++pr]=pr;\n      if(f==1)pi[b[r[i]]]=pi[a[r[i]]];\n      if(f==2)pi[a[r[i]]]=pi[b[r[i]]];\n      if(f==3&&p[pi[a[r[i]]]]-p[pi[b[r[i]]]])p[pi[a[r[i]]]]=p[pi[b[r[i]]]];\n      //for(j=0;j<=m;j++)printf(\"%d %d %d\\n\",j,pi[j],p[j]);\n    }\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 200\nint par[MAX_N];\nint rank[MAX_N];\n\ntypedef struct{int p1; int p2; int leng;}map;\n\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx =find(x);\n\ty =find(y);\n\tif(x==y){\n\t\treturn ;\n\t}\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\n\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint comp(const void* c1,const void* c2);\n\nint main(){\n\tint n,m,i,count,num;\n\tmap* road;\n\n\twhile(1){\n\t\tscanf(\"%d\",&n);\n\t\tif(n==0)break;\n\t\tinit(n);\n\n\t\tscanf(\"%d\",&m);\n\t\troad=(map*)malloc(m*sizeof(map));\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&road[i].p1,&road[i].p2,&road[i].leng);\n\t\t}\n\n\t\tqsort(road,m,sizeof(map),comp);\n\t\ti=0; count=0; num=0;\n\t\twhile(count<n-1){\n\t\t\tif(!same(road[i].p1,road[i].p2)){\n\t\t\t\tunite(road[i].p1,road[i].p2);\n\t\t\t\tcount++;\n\t\t\t\tnum+=(road[i].leng/100)-1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\\n\",num);\n\t\tfree(road);\n\t}\n\treturn 0;\n}\n\nint comp(const void *c1,const void *c2){\n\tmap data1=*(map*)c1;\n\tmap data2=*(map*)c2;\n\n\tint temp1=data1.leng;\n\tint temp2=data2.leng;\n\n\treturn temp1-temp2;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#define LIMIT_NODES (100)\n\nint compare(const void *a, const void *b) {\n\treturn ((int*)a)[2] - ((int*)b)[2];\n}\n\nint solve(int num_node) {\n\tint i, k, num_edge, answer, node1, node2;\n\tint S[LIMIT_NODES][3];\n\tchar forest[LIMIT_NODES][LIMIT_NODES];\n\n\tscanf(\"%d \", &num_edge);\n\tfor (i = 0; i < num_edge; i++) {\n\t\tscanf(\"%d,%d,%d \", S[i]+0, S[i]+1, S[i]+2);\n\t}\n\tqsort(S, num_edge, sizeof(S[0]), compare);\n\n\tmemset(forest, 0, sizeof(forest[0]) * LIMIT_NODES);\n\tfor (i = 0; i < num_node; i++) {\n\t\tforest[i][i] = 1;\n\t}\n\n\tanswer = 0;\n\tfor (i = 0; i < num_edge; i++) {\n\t\tnode1 = node2 = 0;\n\t\tfor (k = 0; k < num_node; k++) {\n\t\t\tif (forest[k][S[i][0]]) {\n\t\t\t\tnode1 = k;\n\t\t\t}\n\t\t\tif (forest[k][S[i][1]]) {\n\t\t\t\tnode2 = k;\n\t\t\t}\n\t\t}\n\t\tif (node1 != node2) {\n\t\t\tfor (k = 0; k < LIMIT_NODES; k++) {\n\t\t\t\tforest[node1][k] |= forest[node2][k];\n\t\t\t\tforest[node2][k] = 0;\n\t\t\t}\n\t\t\tanswer += (S[i][2] / 100) - 1;\n\t\t}\n\t}\n\treturn answer;\n}\n\nint main(void) {\n\tint num_node;\n\n\twhile (1) {\n\t\tscanf(\"%d \", &num_node);\n\t\tif (!num_node)\n\t\t\tbreak;\n\n\t\tprintf(\"%d\\n\", solve(num_node));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n\n#define MAX 100000000\n\nstruct NODE {\n    int distance;\n    int state;\n} vertex[101];\n\nint W[101][101];\nint V, n;\n\nint min(int a, int b) {\n    return (a > b ? b : a);\n}\n\nvoid prim(int start) {\n    int x, p, step;\n\n    for (x = 0; x < V; x++) {\n\tvertex[x].distance = MAX; vertex[x].state = 0;\n    }\n    vertex[start].distance = 0; \n    for (step = 1; step <= V; step++) {\n\tint minimum = MAX;\n\tfor (x = 0; x < V; x++)\n\t    if (vertex[x].state == 0 && vertex[x].distance < minimum) {\n\t\tp = x; minimum = vertex[x].distance;\n\t    }\n\tvertex[p].state = 1;\n\tfor (x = 0 ; x < V; x++)\n\t    if (vertex[x].state == 0) {\n\t\tvertex[x].distance = min(vertex[x].distance, W[p][x]);\n\t    }\n    }\n}\n\nint main(void) {\n    int i, j;\n    int from, to, m, sum;\n     \n    while (1) {\n\tscanf(\"%d\", &V);\n        if (V == 0) break;\n\tscanf(\"%d\", &n);\n         \n        for (i = 0; i <= V; i++)\n            for (j = 0; j <= V; j++)\n                W[i][j] = MAX;\n         \n\tfor (i = 0; i < n; i++) {\n            scanf(\"%d,%d,%d\", &from, &to, &m);\n            W[from][to] = m / 100;\n\t    W[to][from] = m / 100;\n        }\n         \n        prim(0);\n\n\tsum = 1;\n\tfor (i = 0; i < n; i++) {\n\t    sum += (vertex[i].distance - 1);\n\t}\n\tprintf(\"%d\\n\", sum);\n    }\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "d[150][120];b,i,j,s,t,u,m,n,*p;main(a){for(;scanf(\"%d%d\",&n,&m)*n;printf(\"%d\\n\",s)){for(memset(d,9,7e4);t=m--;d[a][b]=d[b][a]=i/100)scanf(\"%d,%d,%d\",&a,&b,&i);for(s=i=1-n;i++;s+=d[n][t=u])for(d[j=u=n][t]=0;j--;*p&&d[n][u]>*p?u=j:0)p=d[n]+j,*p=fmin(*p,d[t][j]);}}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        a[x][y]=1;\n        a[y][x]=1;\n        b[x][y]=z;\n        b[y][x]=z;\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]=>r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nint n,m,a,b,x,i,j,path[5000][3],pot[100];\nvoid connect(int from,int to){\n\tint i;\n\tfor(i=0;i<m;i++){\n\t\tif(pot[i]==from){pot[i]=to;if(to==0)n--;}\n\t}\n}\nint main(void){\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tif(n==0)break;\n\t\tfor(i=0;i<n;i++)pot[i]=i+1;\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&x);\n\t\t\tfor(j=i;j>0;j--){\n\t\t\t\tif(path[j-1][2]>x){\n\t\t\t\t\tpath[j][2]=path[j-1][2];\n\t\t\t\t\tpath[j][1]=path[j-1][1];\n\t\t\t\t\tpath[j][0]=path[j-1][0];\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tpath[j][2]=x;\n\t\t\tpath[j][1]=b;\n\t\t\tpath[j][0]=a;\n\t\t}\n\t\tx=0;m=n;\n\t\tfor(i=0;n>0;i++){\n\t\t\ta=pot[path[i][0]];b=pot[path[i][1]];\n\t\t\tif(a!=b){\n\t\t\t\tif(x==0){pot[path[i][0]]=0;pot[path[i][1]]=0;n-=2;}\n\t\t\t\telse{if(a<b)connect(b,a); else connect(a,b);}\n\t\t\t\tx+=path[i][2]/100-1;\n\t\t\t}\n\n\t\t}\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#define INF 1000000000\n\nint cost[1000][1000];\nint mincost[1000];\nchar used[1000];\nint V;\n\nint min(int a, int b){\n\tif (a > b){\n\t\treturn (b);\n\t}\n\treturn (a);\n}\n\nint prim(void)\n{\n\tint i;\n\tint res;\n\tint u, v;\n\t\n\tfor (i = 0; i < V; i++){\n\t\tmincost[i] = INF;\n\t\tused[i] = 0;\n\t}\n\t\n\tmincost[0] = 0;\n\tres = 0;\n\t\n\twhile (1){\n\t\tv = -1;\n\t\tfor (u = 0; u < V; u++){\n\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v])){\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (v == -1){\n\t\t\tbreak;\n\t\t}\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\t\n\t\tfor (u = 0; u < V; u++){\n\t\t\tmincost[u] = min(mincost[u], cost[v][u]);\n\t\t}\n\t}\n\treturn (res);\n}\n\nint main(void)\n{\n\tint num, from, to, dist;\n\tint ans;\n\tint i, j;\n\t\n\twhile (1){\n\t\tscanf(\"%d\", &V);\n\t\tif (V == 0){\n\t\t\tbreak;\n\t\t}\n\t\tscanf(\"%d\", &num);\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tfor (j = 0; j < num; j++){\n\t\t\t\tcost[i][j] = INF;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor (i = 0; i < num; i++){\n\t\t\tscanf(\"%d%*c%d%*c%d\", &from, &to, &dist);\n\t\t\tcost[from][to] = cost[to][from] = (dist / 100) - 1;\n\t\t}\n\t\tans = prim();\n\t\tprintf(\"%d\\n\", ans);\n\t}\n\treturn (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m,a[10000],b[10000],c[10000],d[10010],i,j,r[10010],t,s;\nint main(){\n  while(scanf(\"%d\",&n),n){\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      r[i]=i;\n      scanf(\"%d,%d,%d\",&a[i],&b[i],&c[i]);\n      a[i]++;\n      b[i]++;\n      for(j=i;j;j--){\n\tif(c[r[j-1]]>c[r[j]]){\n\t  t=r[j-1];\n\t  r[j-1]=r[j];\n\t  r[j]=t;\n\t}\n      }\n    }\n    int p[10010]={0};\n    for(i=s=0;i<m;i++){\n      for(;p[a[r[i]]];a[r[i]]=p[a[r[i]]]);\n      for(;p[b[r[i]]];b[r[i]]=p[b[r[i]]]);\n      if(b[r[i]]-a[r[i]]){\n\tif(d[a[r[i]]]< d[b[r[i]]])p[a[r[i]]]=b[r[i]];\n\tif(d[b[r[i]]]<=d[a[r[i]]])p[b[r[i]]]=a[r[i]];\n\tif(d[a[r[i]]]==d[b[r[i]]])d[b[r[i]]]++;\n\ts+=c[r[i]]-100;\n      }\n    }\n    printf(\"%d\\n\",s/100);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <math.h>\nint main(void){\n\tint n,m,a,b,x,i,j,path[600][3],pot[100];\n\twhile(scanf(\"%d\",&n)!=EOF){\n\t\tfor(i=0;i<n;i++)pot[i]=1;\n\t\tscanf(\"%d\",&m);\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\",&a,&b,&x);\n\t\t\tfor(j=i;j>0;j--){\n\t\t\t\tif(path[j-1][2]>x){\n\t\t\t\t\tpath[j][2]=path[j-1][2];\n\t\t\t\t\tpath[j][1]=path[j-1][1];\n\t\t\t\t\tpath[j][0]=path[j-1][0];\n\t\t\t\t}else break;\n\t\t\t}\n\t\t\tpath[j][2]=x;\n\t\t\tpath[j][1]=b;\n\t\t\tpath[j][0]=a;\n\t\t}\n\t\tx=0;\n\t\tfor(i=0;i<m && n>0;i++){\n\t\t\ta=path[i][0];\n\t\t\tb=path[i][1];\n\t\t\tif(pot[a]==1 || pot[b]==1){\n\t\t\t\tn-=pot[a]+pot[b];\n\t\t\t\tpot[a]=0;pot[b]=0;\n\t\t\t\tx+=path[i][2]/100-1;\n\t\t\t}\n\t\t}\n\t\tprintf(\"%d\\n\",x);\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "c[100][100];\nn,m;\nu,t,l,x,y;\nmain(){\n\twhile(scanf(\"%d%d\",&n,&m),n){\n\t\tint d[100]={0};\n\n\t\tmemset(c,9,40000);\n\t\tfor(;m--;){\n\t\t\tscanf(\"%d,%d,%d\",&u,&l,&t);\n\t\t\tc[u][l]=c[l][u]=t/100-1;\n\t\t}\n\n\t\tx=y=l=0;\n\t\tfor(u=n;u>0;){\n\t\t\td[x]=1;\n\t\t\tl+=y;\n\t\t\tu--;\n\t\t\ty=x[*c]=**c;\n\t\t\tfor(m=0;m<n;m++){\n\t\t\t\tif(!d[m]){\n\t\t\t\t\tif(c[x][m]<m[*c])\n\t\t\t\t\t\tm[*c]=c[x][m];\n\t\t\t\t}\n\t\t\t\tif(m[*c]<y){\n\t\t\t\t\tt=m;\n\t\t\t\t\ty=m[*c];\n\t\t\t\t}\n\t\t\t}\n\t\t\tx=t;\n\t\t}\n\t\tprintf(\"%d\\n\",l);\n\t}\n\texit(0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#include<string.h>\n#define rng(a,b,c) (min(b,c)<a&&a<max(b,c))\n#define min(a,b) (a<b?a:b)\n#define max(a,b) (a>b?a:b)\n#define rep(i,b,n) for(i=b;i<(n);i++)\nint f(int d[][100],int r[],int c,int nmax){\n  int i;\n  int sum=0;\n  if(r[c]==0){\n    r[c]=1;\n    sum++;\n    rep(i,0,nmax)\n      if(d[c][i])\n\tsum+=f(d,r,i,nmax);\n  }\n  return sum;\n}\nint g(int d[][100],int s[],int o[],int b[],int m,int n,int nmax,int mmin,int c,int t){\n  int i;\n  int p[nmax][nmax],q[m],r[nmax],u=1000000,v;\n  if(c==n){\n    memset(p,0,sizeof(p));\n    memset(r,0,sizeof(r));\n    rep(i,0,m){\n      if(b[i]){\n\tp[s[i]][o[i]]=d[s[i]][o[i]];\n\tp[o[i]][s[i]]=d[s[i]][o[i]];\n      }\n    }\n    for(i=0;b[i]==0;i++);\n    if(f(p,r,i,nmax)==n+1)\n      u=t;\n  }else{\n    rep(i,mmin,m){\n      if(b[i]==0){\n\tmemcpy(q,b,sizeof(q));\n\tq[i]=1;\n\tv=g(d,s,o,q,m,n,nmax,i+1,c+1,t+d[s[i]][o[i]]);\n\tu=min(u,v);\n      }\n    }\n  }\n  return u;\n}\nint main(){\n  int h,i,j,k,l;\n  int m,n,t,nmax;\n  for(;;){\n    scanf(\"%d\",&n);\n    if(n==0)\n      break;\n    scanf(\"%d\",&m);\n    int d[100][100],e[100],s[m],o[m],b[m];\n    memset(d,0,sizeof(d));\n    memset(e,0,sizeof(e));\n    t=0;\n    nmax=n;\n    rep(i,0,m){\n      scanf(\"%d,%d,%d\",&j,&k,&l);\n      if(d[j][k]){\n\tm--;\n\tif(d[j][k]>l/100-1){\n\t  d[j][k]=l/100-1;\n\t  d[k][j]=l/100-1;\n\t}\n      }else{\n\td[j][k]=l/100-1;\n\td[k][j]=l/100-1;\n\te[j]++;\n\te[k]++;\n      }\n    }\n\n    do{\n      h=0;\n      rep(i,0,nmax){\n\tif(e[i]==1){\n\t  for(j=0;d[i][j]==0;j++);\n\t  t+=d[i][j];\n\t  d[i][j]=0;\n\t  d[j][i]=0;\n\t  e[i]--;\n\t  e[j]--;\n\t  m--;\n\t  n--;\n\t  h=1;\n\t}else if(e[i]==2){\n\t  for(j=0;d[i][j]==0;j++);\n\t  for(k=j+1;d[i][k]==0;k++);\n\t  t+=min(d[i][j],d[i][k]);\n\t  if(d[j][k]){\n\t    m--;\n\t    if(d[j][k]>max(d[i][j],d[i][k])){\n\t      d[j][k]=max(d[i][j],d[i][k]);\n\t      d[k][j]=max(d[i][j],d[i][k]);\n\t    }\n\t    e[j]--;\n\t    e[k]--;\n\t  }else{\n\t      d[j][k]=max(d[i][j],d[i][k]);\n\t      d[k][j]=max(d[i][j],d[i][k]);\n\t  }\n\t  d[i][j]=0;\n\t  d[j][i]=0;\n\t  d[i][k]=0;\n\t  d[k][i]=0;\n\t  e[i]-=2;\n\t  m--;\n\t  n--;\n\t  h=1;\n\t}\n      }\n    }while(h);\n    \n    m=0;\n    rep(i,0,nmax-1){\n      rep(j,i+1,nmax){\n\tif(d[i][j]){\n\t  s[m]=i;\n\t  o[m]=j;\n\t  m++;\n\t}\n      }\n    }\n\n    if(n-1){\n      memset(b,0,sizeof(b));\n      printf(\"%d\\n\",g(d,s,o,b,m,n-1,nmax,0,0,t));\n    }else\n      printf(\"%d\\n\",t);\n\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint n,m,a[10000],b[10000],c[10000],d[10010],i,j,r[10010],t,s;\nint main(){\n  while(scanf(\"%d\",&n),n){\n    scanf(\"%d\",&m);\n    for(i=0;i<m;i++){\n      r[i]=i;\n      scanf(\"%d,%d,%d\",&a[i],&b[i],&c[i]);\n      a[i]++;\n      b[i]++;\n      for(j=i;j;j--){\n\tif(c[r[j-1]]>c[r[j]]){\n\t  t=r[j-1];\n\t  r[j-1]=r[j];\n\t  r[j]=t;\n\t}\n      }\n    }\n    int p[10010]={0};\n    for(i=s=0;i<m;i++){\n      for(;p[a[r[i]]];a[r[i]]=p[a[r[i]]]);\n      for(;p[b[r[i]]];b[r[i]]=p[b[r[i]]]);\n      if(b[r[i]]-a[r[i]]){\n\tif(d[a[r[i]]]< d[b[r[i]]])p[a[r[i]]]=b[r[i]];\n\tif(d[b[r[i]]]<=d[a[r[i]]])p[b[r[i]]]=a[r[i]];\n\tif(d[a[r[i]]]==d[b[r[i]]])d[b[r[i]]]++;\n\ts+=c[r[i]]-100;//printf(\"%d\",\n      }\n    }\n    printf(\"%d\\n\",s/100);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n\nmain(){\n  char g;\n  int n,m,i,j,a,b,u,t,s;\n  int d[100],p[100],v[100];\nstatic int r[100][100];\n  \n  while(1){\n    scanf(\"%d\",&n);    \n    if(n==0){break;}\n    scanf(\"%d\",&m);  \n    \n    for(i=0;i<n;i++){\n      d[i]=10000000;\n      v[i]=0;\n    }  \n    \n    for(i=0;i<m;i++){\n      p[i]=-1;\n\n      scanf(\"%d%c%d\",&a,&g,&b);  \n      scanf(\"%c%d\",&g,&r[a][b]);\n     }\n    \n    /*MST*/\n    d[0]=0;\n\n    for(i=0;i<n;i++){ \n    u=10000000;\n      for(j=0;j<n;j++){\n\tif(u>d[j]&& v[j]==0){  \n\t  u=j;\n\t}\n \n      }\n     \n      for(j=0;j<m;j++){\n\tif(r[u][j]!=0&& v[j]==0){\n\t  d[j]=r[u][j]; \n\t  if(p[j]==-1){p[j]=d[j];}\n\t  else if(p[j]>d[j]){p[j]=d[j]; }\n\t}\n      }\n      v[u]=1;\n    }\n    /**/\n\n    s=0;\n    for(i=0;i<m;i++){\n      if(p[i]!=-1){\n\ts+=p[i];\n      }\n    } \n\n    s/=100;\n    printf(\"%d\\n\",s-n+1); \n  }\n\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(){\n  int n,m,a[10000],b[10000],c[10000],f,pr,s,t,i,j,r[10000];\n  while(scanf(\"%d\",&n),n){\n    scanf(\"%d\",&m);\n    for(i=0;i<n;i++){\n      r[i]=i;\n      scanf(\"%d,%d,%d\",&a[i],&b[i],&c[i]);\n      a[i]++;\n      b[i]++;\n      for(j=i;j;j--){\n\tif(c[r[j-1]]>c[r[j]]){\n\t  t=r[j-1];\n\t  r[j-1]=r[j];\n\t  r[j]=t;\n\t}\n      }\n    }\n    int p[10010]={0};\n    int pi[10010]={0};//for(i=0;i<m;i++)printf(\"%d \",c[r[i]]);printf(\"\\n\");\n    for(i=s=pr=0;i<m;i++){\n      f=0;\n      if(pi[a[r[i]]])f+=1;\n      if(pi[b[r[i]]])f+=2;//printf(\"\\n%d\\n\",f);\n      if(f!=3||p[pi[a[r[i]]]]-p[pi[b[r[i]]]])s+=c[r[i]]/100-1;\n      if(f==0)pi[a[r[i]]]=pi[b[r[i]]]=p[++pr]=pr;\n      if(f==1)pi[b[r[i]]]=pi[a[r[i]]];\n      if(f==2)pi[a[r[i]]]=pi[b[r[i]]];\n      if(f==3&&p[pi[a[r[i]]]]-p[pi[b[r[i]]]])p[pi[a[r[i]]]]=p[pi[b[r[i]]]];\n      //for(j=0;j<=m;j++)printf(\"%d %d %d\\n\",j,pi[j],p[j]);\n    }\n    printf(\"%d\\n\",s);\n  }\n  return 0;\n}"
  },
  {
    "language": "C",
    "code": "// AOJ Volume0 0072\n// v@ÉæÁÄððßé\n\n#include <stdio.h>\n#include <string.h>\n\n#define MAX_N   (100)\n\nint main(void)\n{\n    int n, m;\n    int i, j, loop;\n    int a, b, d;\n    int path[MAX_N][MAX_N];\n    int flag[MAX_N];\n    int min_s, min_e;\n    int lantern;\n    \n    while (1){\n        scanf(\"%d\", &n);\n        if (n == 0){\n            break;\n        }\n    \n        // data init\n        memset(path, -1, sizeof(path));\n        memset(flag, 0, sizeof(flag));\n    \n        // data input\n        scanf(\"%d\", &m);\n        for (i = 0; i < m; i++){\n            scanf(\"%d,%d,%d\", &a, &b, &d);\n            path[a][b] = path[b][a] = d;\n        }\n        \n        lantern = 0;\n        flag[0] = 1;\n        \n        for (loop = 0; loop < n; loop++){\n            min_s = min_e = 0;\n            for (i = 0; i < n; i++){\n                if (flag[i] == 1){\n                    for (j = 0; j < n; j++){\n                        if (flag[j] == 0){\n                            if (path[i][j] > 0){\n                                if (path[min_s][min_e] == -1){\n                                    min_s = i;\n                                    min_e = j;\n                                }\n                                else if (path[min_s][min_e] > path[i][j]){\n                                    min_s = i;\n                                    min_e = j;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (path[min_s][min_e] != -1){\n//                printf(\"<%d-%d (%d)>\\n\", min_s, min_e,path[min_s][min_e]);\n                lantern += (path[min_s][min_e] / 100 - 1);\n                path[min_s][min_e] = path[min_e][min_s] = -1;\n                flag[min_e] = 1;\n            }\n        }\n        \n        printf(\"%d\\n\", lantern);\n    }\n    \n    return (0);\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 100000000\nvoid MST(int);\n\nint node[101][101],v[101],d[101],sum,n,count;\n\nint main(void)\n{\n  int m,a,b,i,j;\n\n  while(1)\n    {\n      count=0;\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++)\n\t{\n\t  for(j=0;j<101;j++)\n\t    {\n\t      node[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d,%d,%d\",&a,&b,&d[i]);\n\tnode[a][b]=d[i];\n\tnode[b][a]=d[i];\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n\n\tif(v[i]==0)MST(i);\n\n      printf(\"%d\\n\",sum/100-count+1);\n    }\n\n  return 0;\n}\n\nvoid MST(int u)\n{\n  int x,i;\n  v[u]=1;\n    for(i=0;i<n;i++){\n      if(d[i]>node[u][i] &&v[i]==0){\n\td[i]=node[u][i];\n\tx=i;\n      }\n  }\n\n    if(d[u]<INF){\nsum+=d[u];\n count++;\n}\n\n  for(i=0;i<n;i++)\nd[i]=min(d[i],node[u][i]);\n\n  if(v[x]==0 && x<n)MST(x);\n}\n\nint min(int x,int y)\n{\n  return x < y ? y : x;\n  }"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\nint main(void){\n    int n,m,o;\n    int a[101][101],b[101][101],c[2],r[3]={0};\n    int d=0,e=0,f=0,ans=0;\n    int x,y,z;\n    int h,i,j;\n    scanf(\"%d%d\",&n,&m);\n    for(h=0;h<m;h++){\n        scanf(\"%d,%d,%d\",&x,&y,&z);\n        a[x][y]=1;\n        a[y][x]=1;\n        b[x][y]=z;\n        b[y][x]=z;\n    }\n    scanf(\"%d\",&o);\n    while(1){\n        e=0;\n        for(h=0;h<n;h++){//????¢????\n            d=0;\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    c[0]=h;\n                    c[1]=i;\n                    d++;\n                }\n            }\n            if(d==1){\n                ans=ans+b[c[0]][c[1]];\n                a[c[0]][c[1]]=0;\n                a[c[1]][c[0]]=0;\n                e++;\n            }\n        }\n        if(e==0){//?????????\n            r[0]=0;\n            r[1]=0;\n            r[2]=0;\n            for(h=0;h<n;h++){\n                for(i=0;i<n;i++){\n                    if(a[h][i]==1){\n                        if(b[h][i]>=r[2]){\n                            r[0]=h;\n                            r[1]=i;\n                            r[2]=b[h][i];\n                        }\n                    }\n                }\n            }\n            a[r[0]][r[1]]=0;\n            a[r[1]][r[0]]=0;\n        }\n        f=0;\n        for(h=0;h<n;h++){//break\n            for(i=0;i<n;i++){\n                if(a[h][i]==1){\n                    f++;\n                }\n            }\n        }\n        if(f==0){\n            break;\n        }\n    }\n    ans=ans/100-n+1;\n    printf(\"%d\\n\",ans);\n    return 0;\n}"
  },
  {
    "language": "C",
    "code": "#include<stdio.h>\n#define INF 100000000\nvoid MST(int);\n\n\nint node[101][101],v[101],d[101],sum,n;\n\nint main(void)\n{\n  int m,a,b,i,j;\n  char w,z;\n\n  while(1)\n    {\n      scanf(\"%d\",&n);\n      if(n==0)break;\n\n      scanf(\"%d\",&m);\n\n      for(i=0;i<101;i++)\n\t{\n\t  for(j=0;j<101;j++)\n\t    {\n\t      node[i][j]=INF;\n\t    }\n\t}\n\n      for(i=0;i<m;i++){\n\tscanf(\"%d%c%d%c%d\",&a,&w,&b,&z,&d[i]);\n\tnode[a][b]=d[i];\n\tnode[b][a]=d[i];\n\t }\n\n      for(i=0;i<101;i++){\n\td[i]=INF;\n\tv[i]=0;\n      }\n\n      d[0]=0;\n\n      //for(i=0;i<n;i++)\n\tif(v[i]==0)MST(i);\n\n      for(i=0;i<5;i++){\n\t//printf(\"%d %d\\n\",v[i],i);\n      }\n    }\n      printf(\"%d\\n\",sum/100);\n\n  return 0;\n}\n\n\nvoid MST(int u)\n{\n  int x,i;\n  v[u]=1;\n    for(i=0;i<n;i++){\n      if(d[i]>node[u][i] &&v[i]==0){\n\td[i]=node[u][i];\n\tx=i;\n      }\n      //if(u==1)printf(\"%d\\n\",node[u][j]);\n  }\n    //printf(\"%d %d\\n\",mini,u);\n  if(d[u]<INF)sum+=d[u];\n\n  for(i=0;i<n;i++)\nd[i]=min(d[i],node[u][i]);\n\n  if(v[x]==0 && x<n)MST(x);\n}\n\nint min(int x,int y)\n{\n  return x < y ? y : x;\n  }"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint compare(const void *a, const void *b) {\n\treturn ((int*)a)[2] - ((int*)b)[2];\n}\n\nint solve(int num_node, int num_edge) {\n\tint i, k, answer, node1, node2;\n\tint S[num_edge][3];\n\tchar forest[num_node][num_node];\n\n\tfor (i = 0; i < num_edge; i++) {\n\t\tscanf(\"%d,%d,%d \", S[i]+0, S[i]+1, S[i]+2);\n\t}\n\tqsort(S, num_edge, sizeof(S[0]), compare);\n\n\tmemset(forest, 0, sizeof(forest[0]) * num_node);\n\tfor (i = 0; i < num_node; i++) {\n\t\tforest[i][i] = 1;\n\t}\n\n\tanswer = 0;\n\tfor (i = 0; i < num_edge; i++) {\n\t\tnode1 = node2 = 0;\n\t\tfor (k = 0; k < num_node; k++) {\n\t\t\tif (forest[k][S[i][0]]) {\n\t\t\t\tnode1 = k;\n\t\t\t}\n\t\t\tif (forest[k][S[i][1]]) {\n\t\t\t\tnode2 = k;\n\t\t\t}\n\t\t}\n\t\tif (node1 != node2) {\n\t\t\tfor (k = 0; k < num_node; k++) {\n\t\t\t\tforest[node1][k] |= forest[node2][k];\n\t\t\t\tforest[node2][k] = 0;\n\t\t\t}\n\t\t\tanswer += (S[i][2] / 100) - 1;\n\t\t}\n\t}\n\treturn answer;\n}\n\nint main(void) {\n\tint num_node, num_edge;\n\n\twhile (1) {\n\t\tscanf(\"%d \", &num_node);\n\t\tif (!num_node)\n\t\t\tbreak;\n\n\t\tscanf(\"%d \", &num_edge);\n\t\tprintf(\"%d\\n\", solve(num_node, num_edge));\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "C",
    "code": "#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#define MAX_N 200\nint par[MAX_N];\nint rank[MAX_N];\n\ntypedef struct{int p1; int p2; int leng;}map;\n\nvoid init(int n){\n\tint i;\n\tfor(i=0;i<n;i++){\n\t\tpar[i] = i;\n\t\trank[i] = 0;\n\t}\n}\n\nint find(int x){\n\tif(par[x]==x){\n\t\treturn x;\n\t}else {\n\t\treturn par[x] = find(par[x]);\n\t}\n}\n\nvoid unite(int x,int y){\n\tx =find(x);\n\ty =find(y);\n\tif(x==y){\n\t\treturn ;\n\t}\n\tif(rank[x] < rank[y]){\n\t\tpar[x] = y;\n\t}else {\n\t\tpar[y] = x;\n\t\tif(rank[x] == rank[y])rank[x]++;\n\t}\n}\n\nint same(int x,int y){\n\treturn find(x)==find(y);\n}\n\nint comp(const void* c1,const void* c2);\n\nint main(){\n\tint n,m,i,count,num;\n\tmap* road;\n\n\twhile(1){\n\t\tscanf(\"%d\\n\",&n);\n\t\tif(n==0)break;\n\t\tinit(n);\n\n\t\tscanf(\"%d\\n\",&m);\n\t\troad=(map*)malloc(m*sizeof(map));\n\t\tfor(i=0;i<m;i++){\n\t\t\tscanf(\"%d,%d,%d\\n\",&road[i].p1,&road[i].p2,&road[i].leng);\n\t\t}\n\n\t\tqsort(road,m,sizeof(map),comp);\n\t\ti=0;\n\t\twhile(count!=n-1){\n\t\t\tif(!same(road[i].p1,road[i].p2)){\n\t\t\t\tcount++;\n\t\t\t\tnum+=(road[i].leng/100)-1;\n\t\t\t}\n\t\t\ti++;\n\t\t}\n\t\tprintf(\"%d\\n\",num);\n\t}\n\treturn 0;\n}\n\nint comp(const void *c1,const void *c2){\n\tmap data1=*(map*)c1;\n\tmap data2=*(map*)c2;\n\n\tint temp1=data1.leng;\n\tint temp2=data2.leng;\n\n\treturn temp1-temp2;\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scan.nextInt();\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tedge[] e = new edge[m];\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\te[i] = new edge(Integer.parseInt(str[0]),Integer.parseInt(str[1]),Integer.parseInt(str[2]));\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = n-1;j > i;j--){\n\t\t\t\t\tif(e[j].cost < e[j-1].cost){\n\t\t\t\t\t\tswap(e,j,j-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = 0;\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tif(!uf.same(e[i].u,e[i].v)){\n\t\t\t\t\tuf.unite(e[i].u,e[i].v);\n\t\t\t\t\tmin += e[i].cost/100 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tpublic void swap(edge[] e,int i,int j){\n\t\tedge t = e[j];e[j] = e[i];e[i] = t;\n\t}\n\tpublic class UnionFind{\n\t\tint[] par;\n\t\tint[] rank;\n\t\tpublic UnionFind(int n){\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tpar[i] = i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else{\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic boolean same(int x,int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\tpublic class edge{\n\t\tint u;\n\t\tint v;\n\t\tint cost;\n\t\tpublic edge(int u,int v,int cost){\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader br = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tpoint = 0;\n\t\tString\ta = null;\n\t\tString\tb = \"\";\n\n\t\twhile ((a = parseStdin()) != null) {\n\t\t\tb += (\"#\" + a);\n\t\t}\n\t\tInteger.parseInt(b);\n\n\t\twhile ((point = parseNum()) != 0) {\n\t\t\tint[][]\tmap     = new int[point][point];\n\t\t\tint\t\troute   = parseNum();\n\t\t\tint\t\tlantern = 0;\n\t\t\tfor (int i = 0; i < point; i++) {\n\t\t\t\tfor (int j = 0; j < point; j++) {\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < route; n++) {\n\t\t\t\tint[]\tdist = parseDist();\n\t\t\t\tmap[dist[0]][dist[1]] = dist[2];\n\t\t\t\tmap[dist[1]][dist[0]] = dist[2];\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < point; n++) {\n\t\t\t\tint\ttmp = solve(1 << n, n, map);\n\t\t\t\tlantern = (lantern == 0) ? tmp : Math.min(tmp, lantern);\n\t\t\t}\n\t\t\tSystem.out.println(lantern);\n\t\t}\n\t}\n\n\tprivate static int solve(int cbit, int start, int[][] map) {\n\t\tint\t\tfbit    = 0;\n\t\tint\t\tlantern = 0;\n\t\tint\t\trest    = 0;\n\t\tboolean\tcomp    = true;\n\n\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\tif ((cbit & 1 << n) == 0) {\n\t\t\t\tif (map[start][n] != -1) {\n\t\t\t\t\tfbit |= 1 << n;\n\t\t\t\t\tlantern += map[start][n];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcomp = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!comp) {\n\t\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\t\tif (map[start][n] != -1 && (fbit & 1 << n) != 0) {\n\t\t\t\t\tint\ttmp = solve(cbit | fbit, n, map);\n\t\t\t\t\tif (tmp != 0) {\n\t\t\t\t\t\trest = (rest == 0) ? tmp : Math.min(tmp, rest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn lantern + rest;\n\t}\n\n\tprivate static int[] parseDist() {\n\t\tint[]\tdist  = null;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tString[]\tsplit = strIn.split(\",\");\n\t\t\tdist    = new int[3];\n\t\t\tdist[0] = Integer.parseInt(split[0]); \n\t\t\tdist[1] = Integer.parseInt(split[1]); \n\t\t\tdist[2] = Integer.parseInt(split[2]) / 100 - 1; \n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tnum   = 0;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(strIn); \n\t\t}\n\t\t\n\t\treturn num;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstrNum = null;\n\n\t\ttry {\n\t\t\tString line = br.readLine();\n\t\t\tif (line != null) {\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tstrNum = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn strNum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,r,b,c;(n=s.nextInt())>0;System.out.println(r>0?r:0)){long[][]a=new long[n+1][n];for(i=s.nextInt();i-->0;a[r=new Integer(z[0])][b=new Integer(z[1])]=a[b][r]=new Long(z[2])/100-1)z=s.next().split(\",\");Queue<long[]>l=new PriorityQueue<long[]>(n,new Comparator<long[]>(){public int compare(long[]a,long[]b){return (int)(a[1]-b[1]);}});long[]w={0,0};for(r=0,b=1,l.add(w);b>0;){w=l.poll();a[n][c=(int)w[0]]=1;r+=w[1];for(i=b=0;i<n;++i)if(a[n][i]<1&&a[c][i]>0)l.add(new long[]{i,a[c][i]});for(long m:a[n])if(m<1)b=1;}}}}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader br = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tpoint = 0;\n\t\tString\ta = null;\n\t\tString\tb = \"\";\n\n\t\twhile ((a = parseStdin()) != null) {\n\t\t\tb += a;\n\t\t}\n\t\tInteger.parseInt(b);\n\n\t\twhile ((point = parseNum()) != 0) {\n\t\t\tint[][]\tmap     = new int[point][point];\n\t\t\tint\t\troute   = parseNum();\n\t\t\tint\t\tlantern = 0;\n\t\t\tfor (int i = 0; i < point; i++) {\n\t\t\t\tfor (int j = 0; j < point; j++) {\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < route; n++) {\n\t\t\t\tint[]\tdist = parseDist();\n\t\t\t\tmap[dist[0]][dist[1]] = dist[2];\n\t\t\t\tmap[dist[1]][dist[0]] = dist[2];\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < point; n++) {\n\t\t\t\tint\ttmp = solve(1 << n, n, map);\n\t\t\t\tlantern = (lantern == 0) ? tmp : Math.min(tmp, lantern);\n\t\t\t}\n\t\t\tSystem.out.println(lantern);\n\t\t}\n\t}\n\n\tprivate static int solve(int cbit, int start, int[][] map) {\n\t\tint\t\tfbit    = 0;\n\t\tint\t\tlantern = 0;\n\t\tint\t\trest    = 0;\n\t\tboolean\tcomp    = true;\n\n\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\tif ((cbit & 1 << n) == 0) {\n\t\t\t\tif (map[start][n] != -1) {\n\t\t\t\t\tfbit |= 1 << n;\n\t\t\t\t\tlantern += map[start][n];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcomp = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!comp) {\n\t\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\t\tif (map[start][n] != -1 && (fbit & 1 << n) != 0) {\n\t\t\t\t\tint\ttmp = solve(cbit | fbit, n, map);\n\t\t\t\t\tif (tmp != 0) {\n\t\t\t\t\t\trest = (rest == 0) ? tmp : Math.min(tmp, rest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn lantern + rest;\n\t}\n\n\tprivate static int[] parseDist() {\n\t\tint[]\tdist  = null;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tString[]\tsplit = strIn.split(\",\");\n\t\t\tdist    = new int[3];\n\t\t\tdist[0] = Integer.parseInt(split[0]); \n\t\t\tdist[1] = Integer.parseInt(split[1]); \n\t\t\tdist[2] = Integer.parseInt(split[2]) / 100 - 1; \n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tnum   = 0;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(strIn); \n\t\t}\n\t\t\n\t\treturn num;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstrNum = null;\n\n\t\ttry {\n\t\t\tString line = br.readLine();\n\t\t\tif (line != null) {\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tstrNum = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn strNum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\n\npublic class Main {\n\t\n\tpublic static class Path implements Comparable<Path>{\n\t\tprivate int to,from,len;\n\t\t\n\t\tpublic Path(int f,int t,int l){\n\t\t\tfrom = f;\n\t\t\tto = t;\n\t\t\tlen = l;\n\t\t}\n\t\t\n\t\tpublic int get_from(){\n\t\t\treturn from;\n\t\t}\n\t\t\n\t\tpublic int get_to(){\n\t\t\treturn to;\n\t\t}\n\t\t\n\t\tpublic int get_len(){\n\t\t\treturn len;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Path p){\n\t\t\treturn this.get_len() - p.get_len(); \t\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"From \" + from + \". To \" + to + \". len \" + len +\".\";\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\t\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0){break;}\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tSet<Path> paths = new TreeSet<Path>();\n\t\t\tSet<Integer> visited_place = new HashSet<Integer>(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString strs[] = sc.next().split(\",\");\n\t\t\t\tpaths.add(new Path(Integer.parseInt(strs[0]),Integer.parseInt(strs[1]),Integer.parseInt(strs[2])));\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\t\n\t\t\tIterator<Path> ite = paths.iterator();\n\t\t\twhile(visited_place.size() != n){\n\t\t\t\tif(!ite.hasNext()){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tPath p = ite.next();\n\t\t\t\tif(visited_place.contains(p.get_from()) && visited_place.contains(p.get_to())){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited_place.add(p.get_from());\n\t\t\t\tvisited_place.add(p.get_to());\n\t\t\t\tsum += p.get_len()/100 - 1;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in).useDelimiter(\"[\\\\s,]+\");\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tm = scanner.nextInt();\n\t\t\te = new Edge[n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint from = scanner.nextInt();\n\t\t\t\tint to = scanner.nextInt();\n\t\t\t\tint cost = scanner.nextInt() / 100 - 1;\n\t\t\t\te[i] = new Edge(from, to, cost);\n\t\t\t}\n\t\t\tSystem.out.println(kruskal());\n\t\t}\n\t}\n\n\tprivate int kruskal() {\n\t\tArrays.sort(e);\n\t\tint ans = 0;\n\t\tUnion union = new Union(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tEdge edge = e[i];\n\t\t\tif (union.isSame(edge.from, edge.to))\n\t\t\t\tcontinue;\n\t\t\tans += edge.cost;\n\t\t\tunion.unit(edge.from, edge.to);\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tint n, m;\n\tEdge[] e;\n\n\tclass Union {\n\t\tint[] par, rank;\n\n\t\tpublic Union(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tpar[i] = i;\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] == x)\n\t\t\t\treturn x;\n\t\t\treturn par[x] = find(par[x]);\n\n\t\t}\n\n\t\tboolean isSame(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tvoid unit(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (rank[x] < rank[y])\n\t\t\t\tpar[x] = y;\n\t\t\telse {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tsuper();\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [from=\" + from + \", to=\" + to + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn cost - o.cost;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport static java.lang.Math.*;\n\nclass Edge implements Comparable<Edge> {\n\n    final int from;\n    final int to;\n    final int len;\n\n    Edge( final int from, final int to, final int len ) {\n\tthis.from = from;\n\tthis.to = to;\n\tthis.len = len;\n    }\n\n    public int compareTo( Edge e ) {\n\treturn len - e.len;\n    }    \n}\n\nclass Main {\n\n    static int find( final int x, final int[] root ) {\n\tif ( x == root[ x ] ) {\n\t    return x;\n\t} else {\n\t    final int parents = find( root[ x ], root );\n\t    root[ x ] = parents;\n\t    return parents;\n\t}\n    }\n\n    static void union( final int x, final int y, final int[] root ) {\n\tfinal int parents = find( x, root );\n\troot[ parents ] = y;\n    }\n\n    static boolean same( final int x, final int y, final int[] root ) {\n\tfinal int parentsX = find( x, root );\n\tfinal int parentsY = find( y, root );\n\treturn parentsX == parentsY;\n    }\n    \n    public static void main( final String[] args ) {\n\n\tfinal Scanner stdin = new Scanner( System.in );\n\n\twhile ( true ) {\n\n\t    ArrayList<Edge> list = new ArrayList<Edge>();\n\t    \n\t    final int n = Integer.parseInt( stdin.nextLine() );\n\t    if ( n == 0 ) {\n\t\tbreak;\n\t    }\n\t    final int m = Integer.parseInt( stdin.nextLine() );\n\t    for ( int i = 0; i < m; i++ ) {\n\t\tfinal String[] input = stdin.nextLine().split( \",\" );\n\t\tfinal int from = Integer.parseInt( input[ 0 ] );\n\t\tfinal int to = Integer.parseInt( input[ 1 ] );\n\t\tfinal int len = Integer.parseInt( input[ 2 ] );\n\t\tlist.add( new Edge( from, to, len ) );\n\t    }\n\n\t    Collections.sort( list );\n\t    \n\t    final int[] root = new int[ n ];\n\t    for ( int i = 0; i < n; i++ ) {\n\t\troot[ i ] = i;\n\t    }\n\t    Set<Integer> set = new HashSet<Integer>();\n\n\t    int ans = 0;\n\t    for ( Edge e : list ) {\n\t\tif ( !same( e.from, e.to, root ) ){\n\t\t    union( e.from, e.to, root );\n\t\t    ans += e.len / 100 - 1;\n\t\t}\n\t    }\n\t    System.out.println( ans );\n\t}\t\n    }    \n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scan.nextInt();\n\t\t\tint[][] cost = new int[n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(str[0]);\n\t\t\t\tint b = Integer.parseInt(str[1]);\n\t\t\t\tint c = Integer.parseInt(str[2]);\n\t\t\t\tcost[a][b] = c;\n\t\t\t\tcost[b][a] = c;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tint min = 0;\n\t\t\tint ti = 0;\n\t\t\tint tj = 0;\n\t\t\tboolean[] fl = new boolean[n];\n\t\t\tfor(int i = 0;i < n-1;i++){\n\t\t\t\tmin = 0;\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(cost[i][j] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(min == 0 || min > cost[i][j]){\n\t\t\t\t\t\tmin = cost[i][j];\n\t\t\t\t\t\tti = i;\n\t\t\t\t\t\ttj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(min != 0){\n\t\t\t\t\tcount += min/100 - 1;\n\t\t\t\t\tfl[ti] = true;\n\t\t\t\t\tfl[tj] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(fl[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmin = 0;\n\t\t\t\tfor(int j = 0;j < i;j++){\n\t\t\t\t\tif(cost[j][i] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(min == 0 || min > cost[j][i]){\n\t\t\t\t\t\tmin = cost[j][i];\n\t\t\t\t\t\tti = i;\n\t\t\t\t\t\ttj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(min != 0){\n\t\t\t\t\tcount += min/100 - 1;\n\t\t\t\t\tfl[ti] = true;\n\t\t\t\t\tfl[tj] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static int[][][] getAdjecentListWithCounter(int n, int[] from, int[] to, int[] w) {\n\t\tint[][][] e = new int[n][][];\n\t\tint[] d = new int[n];\n\t\tfor (int f : from)\n\t\t\td[f]++;\n\t\tfor (int t : to)\n\t\t\td[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\te[i] = new int[d[i]][2];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\t--d[from[i]];\n\t\t\te[from[i]][d[from[i]]][0] = to[i];\n\t\t\te[from[i]][d[from[i]]][1] = w[i];\n\t\t\t--d[to[i]];\n\t\t\te[to[i]][d[to[i]]][0] = from[i];\n\t\t\te[to[i]][d[to[i]]][1] = w[i];\n\t\t}\n\t\treturn e;\n\t}\n\n\tpublic static int prim(int[][][] adj, int nodes, int s) {\n\t\tfinal int[] d = new int[nodes];\n\t\tArrays.fill(d, 0);\n\t\tTreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn (d[a[0]] != d[b[0]]) ? (d[a[0]] - d[b[0]]) : (a[1] - b[1]);\n\t\t\t}\n\t\t});\n\t\td[s] = 1;\n\t\tfor (int[] e : adj[s]) {\n\t\t\tts.add(e);\n\t\t}\n\t\tint w = 0;\n\t\twhile (!ts.isEmpty()) {\n\t\t\tint[] ne = ts.pollFirst();\n\t\t\tif (d[ne[0]] == 1)\n\t\t\t\tbreak;\n\t\t\td[ne[0]] = 1;\n\t\t\tw += ne[1];\n\t\t\tfor (int[] e : adj[ne[0]]) {\n\t\t\t\tts.add(e);\n\t\t\t}\n\t\t}\n\t\treturn w;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = sc.nextInt();\n\t\t\tint[] f = new int[m];\n\t\t\tint[] t = new int[m];\n\t\t\tint[] w = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tf[i] = sc.nextInt();\n\t\t\t\tt[i] = sc.nextInt();\n\t\t\t\tw[i] = (sc.nextInt() - 1) / 100;\n\t\t\t}\n\t\t\tint[][][] g = getAdjecentListWithCounter(n, f, t, w);\n\t\t\tSystem.out.println(prim(g, n, 0));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\n\tpublic void run() {\n\t\twhile(true){\n\t\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tNode[] nodes=new Node[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString[] str=sc.next().split(\",\");\n\t\t\t\tnodes[i]=new Node(Integer.parseInt(str[0]),Integer.parseInt(str[1]),Integer.parseInt(str[2]));\n\t\t\t}\n\t\t\tUnionFind uf=new UnionFind(n);\n\t\t\tArrays.sort(nodes);\n\t\t\tint res=0;int node=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tif(!uf.find(nodes[i].p1,nodes[i].p2)){\n\t\t\t\t\tuf.unite(nodes[i].p1,nodes[i].p2);\n\t\t\t\t\tres+= nodes[i].dist;\n\t\t\t\t\tnode++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(res/100-node);\n\t\t}\n\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint p1,p2,dist;\n\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn dist-o.dist;\n\t\t}\n\t\tNode(int a,int b,int c){\n\t\t\tp1=a;p2=b;dist=c;\n\t\t}\n\t}\n\tpublic class UnionFind {\n\t    private int[] id;\n\t    private int[] sz;\n\t    private int components;\n\n\t    public UnionFind(int N) {\n\t        id = new int[N];\n\t        sz = new int[N];\n\t        components = N;\n\t        for (int i = 0; i < N; i++) {\n\t            id[i] = i;\n\t            sz[i] = 1;\n\t        }\n\t    }\n\t    public int find(int x) {\n\t        while (x != id[x])\n\t            x = id[x];\n\t        return x;\n\t    }\n\t    public int components() {\n\t        return components;\n\t    }\n\t    public boolean find(int p, int q) {\n\t        return find(p) == find(q);\n\t    }\n\t    public void unite(int p, int q) {\n\t        int i = find(p);\n\t        int j = find(q);\n\t        if (i == j) return;\n\t        if   (sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i]; }\n\t        else                 { id[j] = i; sz[i] += sz[j]; }\n\t        components--;\n\t    }\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "package net.dolpen.sandbox;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] makeadj(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj) {\n        final int[] d = new int[adj.length];\n        Arrays.fill(d, 0);\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if (d[a[1]] != d[b[1]]) {\n                    return (d[a[1]] - d[b[1]]);\n                } else if (a[2] != b[2]) {\n                    return a[2] - b[2];\n                }\n                return 1;\n            }\n        });\n\n        d[0] = 1;\n        for (int[] e : adj[0]) {\n            ts.add(new int[]{0, e[0], e[1]});\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[1]] == 1)\n                break;\n            d[ne[1]] = 1;\n            w += ne[2];\n            for (int[] e : adj[ne[1]]) {\n                ts.add(new int[]{ne[1], e[0], e[1]});\n            }\n        }\n        return w;\n    }\n\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = (sc.nextInt() - 1) / 100;\n            }\n            int[][][] g = makeadj(n, f, t, w);\n            System.out.println(prim(g));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        Prim prim = new Prim(V, E);\n\n        for (int i = 0; i < E; i++) {\n            String line = sc.next();\n            String[] data = line.split(\",\");\n            int s = Integer.valueOf(data[0]);\n            int t = Integer.valueOf(data[1]);\n            int w = Integer.valueOf(data[2]) / 100 - 1;\n            prim.set(s, t, w);\n            prim.set(t, s, w);\n        }\n\n        int res = prim.run();\n        System.out.println(res);\n    }\n\n    public static class Prim {\n        int V, E;\n        ArrayList<Edge>[] edges;\n\n        @SuppressWarnings(\"unchecked\")\n        Prim(int V, int E) {\n            this.V = V;\n            this.E = E;\n            edges = new ArrayList[V];\n            for (int i = 0; i < V; i++) {\n                edges[i] = new ArrayList<>();\n            }\n        }\n\n        void set(int from, int to, int cost) {\n            edges[from].add(new Edge(to, cost));\n        }\n\n        int run() {\n            boolean[] done = new boolean[V];\n            Arrays.fill(done, false);\n            Queue<Edge> q = new PriorityQueue<>();\n            q.add(new Edge(0, 0));\n            int costSum = 0;\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                if (done[e.t]) {\n                    continue;\n                }\n                done[e.t] = true;\n                costSum += e.w;\n                q.addAll(edges[e.t]);\n            }\n            return costSum;\n        }\n\n    }\n\n    public static class Edge implements Comparable<Edge> {\n        public int t, w;\n\n        Edge(int t, int w) {\n            this.t = t;\n            this.w = w;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return this.w - o.w;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader br = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tpoint = 0;\n\n\t\twhile ((point = parseNum()) != 0) {\n\t\t\tint[][]\tmap     = new int[point][point];\n\t\t\tint\t\troute   = parseNum();\n\t\t\tfor (int i = 0; i < point; i++) {\n\t\t\t\tfor (int j = 0; j < point; j++) {\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < route; n++) {\n\t\t\t\tint[]\tdist = parseDist();\n\t\t\t\tmap[dist[0]][dist[1]] = dist[2];\n\t\t\t\tmap[dist[1]][dist[0]] = dist[2];\n\t\t\t}\n\n\t\t\tSystem.out.println(dijkstra(0, map));\n\t\t}\n\t}\n\n\tprivate static int dijkstra(int start, int[][] map) {\n\t\tint\t\t\tres  = 0;\n\t\tint[]\t\tcost = new int[map.length];\n\t\tboolean[]\tused = new boolean[map.length];\n\n\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\tcost[n] = Integer.MAX_VALUE;\n\t\t}\n\t\tcost[start] = 0;\n\n\t\twhile(true) {\n\t\t\tint\tcur = -1;\n\t\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\t\tif (!used[n] && (cur == -1 || cost[n] < cost[cur])) {\n\t\t\t\t\tcur = n;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cur == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tused[cur]  = true;\n\t\t\tres       += cost[cur];\n\n\t\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\t\tif (map[n][cur] != -1) {\n\t\t\t\t\tcost[n] = Math.min(cost[n], map[n][cur]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tprivate static int[] parseDist() {\n\t\tint[]\tdist  = null;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tString[]\tsplit = strIn.split(\",\");\n\t\t\tdist    = new int[3];\n\t\t\tdist[0] = Integer.parseInt(split[0]); \n\t\t\tdist[1] = Integer.parseInt(split[1]); \n\t\t\tdist[2] = Integer.parseInt(split[2]) / 100 - 1; \n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tnum   = 0;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(strIn); \n\t\t}\n\t\t\n\t\treturn num;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstrNum = null;\n\n\t\ttry {\n\t\t\tString line = br.readLine();\n\t\t\tif (line != null) {\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tstrNum = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn strNum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew aoj0072().doIt();\n\t}\n\n\tclass aoj0072 {\n\t\tint cost[][];\n\t\tint mincost[];\n\t\tboolean used[];\n\t\tint V;\n\n\t\tint prim() {\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tmincost[i] = Integer.MAX_VALUE;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\tmincost[0] = 0;\n\t\t\tint res = 0;\n\t\t\twhile (true) {\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int u = 0; u < V; u++) {\n\t\t\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t\tif (v == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tused[v] = true;\n\t\t\t\tres += mincost[v];\n\n\t\t\t\tfor (int u = 0; u < V; u++) {\n\t\t\t\t\tmincost[u] = Math.min(mincost[u], cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tV = sc.nextInt();\n\t\t\t\tif (V == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcost = new int[V][V];\n\t\t\t\tmincost = new int[V];\n\t\t\t\tused = new boolean[V];\n\t\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\t\tfor (int j = 0; j < V; j++) {\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tString[] node = sc.next().split(\",\");\n\t\t\t\t\tint nodea = Integer.valueOf(node[0]);\n\t\t\t\t\tint nodeb = Integer.parseInt(node[1]);\n\t\t\t\t\tint abcost = Integer.parseInt(node[2]);\n\t\t\t\t\tcost[nodea][nodeb] = abcost;\n\t\t\t\t}\n\t\t\t\tint ans = prim();\n\t\t\t\tans = (ans / 100) - V + 1;\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,i,r,b,c;(n=s.nextInt())>0;System.out.println(r>0?r:0)){int[][]a=new int[n+1][n];for(i=s.nextInt();i-->0;a[r=new Integer(z[0])][b=new Integer(z[1])]=a[b][r]=new Integer(z[2])/100-1)z=s.next().split(\",\");Queue<int[]>l=new PriorityQueue<int[]>(n,new Comparator<int[]>(){public int compare(int[]a,int[]b){return a[1]-b[1];}});int[]w={0,0};for(r=0,b=1,l.add(w);b>0;){w=l.poll();a[n][c=w[0]]=1;r+=w[1];for(i=b=0;i<n;++i)if(a[n][i]<1&&a[c][i]>0)l.add(new int[]{i,a[c][i]});for(int m:a[n])if(m<1)b=1;}}}}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] getAdjecentListWithCounter(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj, int nodes, int s) {\n        final int[] d = new int[nodes]; Arrays.fill(d, 0);//到達フラグ\n        // 距離優先\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return (a[1] - b[1]);\n            }\n        });\n        // 適当に始点を決める\n        d[s] = 1;\n        // 枝集合追加\n        for (int[] e : adj[s]) {\n            ts.add(e);\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[0]] == 1)continue;\n            d[ne[0]] = 1;\n            w += ne[1];\n            // 枝集合追加\n            for (int[] e : adj[ne[0]]) {\n                ts.add(e);\n            }\n        }\n        return w;\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = (sc.nextInt() - 1) / 100;\n            }\n            int[][][] g = getAdjecentListWithCounter(n, f, t, w);\n            System.out.println(prim(g, n, 0));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Comparator;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        doit(args, System.in, System.out);\n    }\n\n    static void doit(String[] args, InputStream in, PrintStream out)\n            throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            if (line.isEmpty()) {\n                continue;\n            }\n            int n = Integer.parseInt(line);\n            if (n == 0) {\n                break;\n            }\n            int m = Integer.parseInt(reader.readLine());\n            int[][] graph = new int[m][3];\n            for (int i = 0; i < m; i++) {\n                String[] values = reader.readLine().split(\",\");\n                graph[i][0] = Integer.parseInt(values[0]);\n                graph[i][1] = Integer.parseInt(values[1]);\n                graph[i][2] = Integer.parseInt(values[2]) / 100 - 1;\n            }\n            Arrays.sort(graph, new Comparator<int[]>() {\n                @Override\n                public int compare(int[] o1, int[] o2) {\n                    return o1[2] - o2[2];\n                }\n            });\n            int result = solve(n, graph);\n            out.println(result);\n        }\n    }\n\n    private static int solve(int n, int[][] graph) {\n        int[] treeNumbers = new int[n];\n        int lastTreeNumber = 0;\n        int result = 0;\n        for (int i = 0; i < graph.length; i++) {\n            int[] edge = graph[i];\n            int treeNumber0 = treeNumbers[edge[0]];\n            int treeNumber1 = treeNumbers[edge[1]];\n            if (treeNumber0 == 0) {\n                if (treeNumber1 == 0) {\n                    lastTreeNumber++;\n                    treeNumbers[edge[0]] = lastTreeNumber;\n                    treeNumbers[edge[1]] = lastTreeNumber;\n                } else {\n                    treeNumbers[edge[0]] = treeNumber1;\n                }\n            } else {\n                if (treeNumber1 == 0) {\n                    treeNumbers[edge[1]] = treeNumber0;\n                } else if (treeNumber1 == treeNumber0) {\n                    continue;\n                } else {\n                    for (int j = 0; j < n; j++) {\n                        if (treeNumbers[j] == treeNumber1) {\n                            treeNumbers[j] = treeNumber0;\n                        }\n                    }\n                }\n            }\n            result += edge[2];\n        }\n        return result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static int[][][] getAdjecentListWithCounter(int n, int[] from, int[] to, int[] w) {\n\t\tint[][][] e = new int[n][][];\n\t\tint[] d = new int[n];\n\t\tfor (int f : from)\n\t\t\td[f]++;\n\t\tfor (int t : to)\n\t\t\td[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\te[i] = new int[d[i]][2];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\t--d[from[i]];\n\t\t\te[from[i]][d[from[i]]][0] = to[i];\n\t\t\te[from[i]][d[from[i]]][1] = w[i];\n\t\t\t--d[to[i]];\n\t\t\te[to[i]][d[to[i]]][0] = from[i];\n\t\t\te[to[i]][d[to[i]]][1] = w[i];\n\t\t}\n\t\treturn e;\n\t}\n\n\tpublic static int prim(int[][][] adj, int nodes, int s) {\n\t\tfinal int[] d = new int[nodes];\n\t\tArrays.fill(d, 0);\n\t\tTreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn (d[a[0]] != d[b[0]]) ? (d[a[0]] - d[b[0]]) : (a[1] - b[1]);\n\t\t\t}\n\t\t});\n\t\td[s] = 1;\n\t\tfor (int[] e : adj[s]) {\n\t\t\tts.add(e);\n\t\t}\n\t\tint w = 0;\n\t\twhile (!ts.isEmpty()) {\n\t\t\tint[] ne = ts.pollFirst();\n\t\t\tif (d[ne[0]] == 1)\n\t\t\t\tbreak;\n\t\t\td[ne[0]] = 1;\n\t\t\tw += ne[1];\n\t\t\tfor (int[] e : adj[ne[0]]) {\n\t\t\t\tts.add(e);\n\t\t\t}\n\t\t}\n\t\treturn w;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = sc.nextInt();\n\t\t\tint[] f = new int[m];\n\t\t\tint[] t = new int[m];\n\t\t\tint[] w = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tf[i] = sc.nextInt();\n\t\t\t\tt[i] = sc.nextInt();\n\t\t\t\tw[i] = sc.nextInt() / 100 - 1;\n\t\t\t}\n\t\t\tint[][][] g = getAdjecentListWithCounter(n, f, t, w);\n\t\t\tSystem.out.println(prim(g, n, 0));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.lang.*;\nimport java.math.*;\nimport java.io.*;\n\nimport static java.lang.Math.*;\nimport static java.util.Arrays.*;\n\npublic class Main{\n\n\tScanner sc=new Scanner(System.in);\n\n\tint INF=1<<28;\n\tdouble EPS=1e-9;\n\n\tint n, m;\n\tint[][] w;\n\n\tvoid run(){\n\t\tsc.useDelimiter(\"[,]|(\\\\s)+\");\n\t\tfor(; sc.hasNext();){\n\t\t\tn=sc.nextInt();\n\t\t\tif(n==0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tm=sc.nextInt();\n\t\t\tw=new int[n][n];\n\t\t\tfor(int i=0; i<n; i++){\n\t\t\t\tArrays.fill(w[i], -1);\n\t\t\t}\n\t\t\tfor(int i=0; i<m; i++){\n\t\t\t\tint a=sc.nextInt();\n\t\t\t\tint b=sc.nextInt();\n\t\t\t\tint c=sc.nextInt()/100;\n\t\t\t\tw[a][b]=w[b][a]=c;\n\t\t\t}\n\t\t\tsolve();\n\t\t}\n\t}\n\n\t// w[i][j]=w[j][i]\n\t// w[i][j]=-1 -> E(i, j) not exist\n\tvoid solve(){\n\t\tinit();\n\t\tLinkedList<E> list=new LinkedList<E>();\n\n\t\tfor(int j=0; j<n-1; j++)\n\t\t\tfor(int i=j+1; i<n; i++)\n\t\t\t\tif(w[j][i]!=-1)\n\t\t\t\t\tlist.add(new E(j, i, w[j][i]));\n\n\t\tE[] es=list.toArray(new E[0]);\n\t\tArrays.sort(es, new Comparator<E>(){\n\t\t\t@Override\n\t\t\tpublic int compare(E e1, E e2){\n\t\t\t\treturn e1.w-e2.w;\n\t\t\t}\n\t\t});\n\n\t\tlist.clear();\n\t\tint ans=0;\n\t\tfor(E e : es){\n\t\t\tif(find(e.v1)!=find(e.v2)){\n\t\t\t\tunion(e.v1, e.v2);\n\t\t\t\tans+=e.w-1;\n\t\t\t\tlist.add(e);\n\t\t\t}\n\t\t}\n\t\tprintln(\"\"+ans);\n\t}\n\n\tint[] p, rank;\n\n\tvoid init(){\n\t\tp=new int[n];\n\t\trank=new int[n];\n\t\tfor(int i=0; i<n; i++){\n\t\t\tp[i]=i;\n\t\t\trank[i]=0;\n\t\t}\n\t}\n\n\tint find(int x){\n\t\tif(p[x]==x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn p[x]=find(p[x]);\n\t}\n\n\tvoid union(int x, int y){\n\t\tx=find(x);\n\t\ty=find(y);\n\t\tif(rank[x]>rank[y]){\n\t\t\tp[y]=x;\n\t\t}else{\n\t\t\tp[x]=y;\n\t\t\tif(rank[x]==rank[y])\n\t\t\t\trank[y]++;\n\t\t}\n\t}\n\n\tclass E{\n\t\tint v1, v2, w;\n\n\t\tE(int v1, int v2, int w){\n\t\t\tthis.v1=v1;\n\t\t\tthis.v2=v2;\n\t\t\tthis.w=w;\n\t\t}\n\t}\n\n\tvoid debug(Object... os){\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tvoid print(String s){\n\t\tSystem.out.print(s);\n\t}\n\n\tvoid println(String s){\n\t\tSystem.out.println(s);\n\t}\n\n\tpublic static void main(String[] args){\n\t\t// System.setOut(new PrintStream(new BufferedOutputStream(System.out)));\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\npublic class Main {\n    final int INF = (int)1e9 + 7;\n    int N,M;\n    int[] a,b,d;\n    ArrayList<Integer>[] graph;\n    int[][] cost;\n    private class P implements Comparable<P>{\n        int first,second;\n        public P(int first,int second){\n            this.first = first;\n            this.second = second;\n        }\n        public int compareTo(P p){\n            if(this.first == p.first){\n                return this.second - p.second;\n            }\n            return this.first - p.first;\n        }\n    }\n \n    public int dijkstra(int s){\n        boolean[] used = new boolean[N];\n        int ret = 0;\n        PriorityQueue<P> pq = new PriorityQueue<P>();\n        pq.add(new P(0,s));\n        while(pq.size() > 0){\n            P p = pq.poll();\n            if(used[p.second])continue;\n            used[p.second] = true;\n            ret+=p.first;\n            for(int next : graph[p.second]){\n                pq.add(new P(cost[p.second][next],next));\n            }\n        }\n        return ret;\n    }\n \n    @SuppressWarnings(\"unchecked\")\n    public void solve() {\n        while(true){\n            N = nextInt();\n \n            if(N == 0)break;\n \n            M = nextInt();\n            a = new int[M];\n            b = new int[M];\n            d = new int[M];\n            graph = new ArrayList[N];\n            cost = new int[N][N];\n            for(int i = 0;i < N;i++){\n                graph[i] = new ArrayList<Integer>();\n            }\n            for(int i = 0;i < M;i++){\n                String[] line = next().split(\",\");\n                a[i] = Integer.parseInt(line[0]);\n                b[i] = Integer.parseInt(line[1]);\n                d[i] = (Integer.parseInt(line[2]) / 100) - 1;\n                cost[a[i]][b[i]] = d[i];\n                cost[b[i]][a[i]] = d[i];\n                graph[a[i]].add(b[i]);\n                graph[b[i]].add(a[i]);\n            }\n            out.println(dijkstra(0));\n        }\n    }\n \n    public static void main(String[] args) {\n        out.flush();\n        new Main().solve();\n        out.close();\n    }\n \n    /* Input */\n    private static final InputStream in = System.in;\n    private static final PrintWriter out = new PrintWriter(System.out);\n    private final byte[] buffer = new byte[2048];\n    private int p = 0;\n    private int buflen = 0;\n \n    private boolean hasNextByte() {\n        if (p < buflen)\n            return true;\n        p = 0;\n        try {\n            buflen = in.read(buffer);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        if (buflen <= 0)\n            return false;\n        return true;\n    }\n \n    public boolean hasNext() {\n        while (hasNextByte() && !isPrint(buffer[p])) {\n            p++;\n        }\n        return hasNextByte();\n    }\n \n    private boolean isPrint(int ch) {\n        if (ch >= '!' && ch <= '~')\n            return true;\n        return false;\n    }\n \n    private int nextByte() {\n        if (!hasNextByte())\n            return -1;\n        return buffer[p++];\n    }\n \n    public String next() {\n        if (!hasNext())\n            throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = -1;\n        while (isPrint((b = nextByte()))) {\n            sb.appendCodePoint(b);\n        }\n        return sb.toString();\n    }\n \n    public int nextInt() {\n        return Integer.parseInt(next());\n    }\n \n    public long nextLong() {\n        return Long.parseLong(next());\n    }\n \n    public double nextDouble() {\n        return Double.parseDouble(next());\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\twhile(true){\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint m = Integer.parseInt(br.readLine());\n\t\t\tint[][] matrix = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(matrix[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString[] tmpArray = br.readLine().split(\",\");\n\t\t\t\tint a = Integer.parseInt(tmpArray[0]);\n\t\t\t\tint b = Integer.parseInt(tmpArray[1]);\n\t\t\t\tint d = Integer.parseInt(tmpArray[2]) - 100;\n\t\t\t\t\n\t\t\t\tmatrix[a][b] = d;\n\t\t\t\tmatrix[b][a] = d;\n\t\t\t}\n\t\t\t\n\t\t\tint sum = MyPlim(matrix);\n\t\t\tSystem.out.println(sum/100);\n\t\t}\n\t}\n\n\tstatic int MyPlim(int[][] matrix){\n        int result = 0;\n        int n = matrix[0].length;\n         \n        int[] visited = new int[n];\n        Arrays.fill(visited, 0);\n         \n        visited[0] = 1;\n        int checked = 1;\n         \n        while(true){\n            int min = Integer.MAX_VALUE;\n            int minI = -1;\n            int minJ = -1;\n            for(int i = 0; i < n; i++){\n                if(visited[i] == 0){\n                    continue;\n                }\n                for(int j = 0; j < n; j++){\n                    if(min > matrix[i][j] && matrix[i][j] >= 0 && visited[j] == 0){\n                        min = matrix[i][j];\n                        minI = i;\n                        minJ = j;\n                    }\n                }\n            }\n             \n            result += min;\n//            System.out.println(\"(\"+minI+\",\"+minJ+\") added distance\"+min);\n            checked++;\n            visited[minI] = 1;\n            visited[minJ] = 1;\n            matrix[minI][minJ] = -1;\n            matrix[minJ][minI] = -1;\n             \n            if(checked == n){\n                break;\n            }\n        }\n         \n        return result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.*;\nimport java.io.*;\nimport static java.util.Arrays.*;\nimport static java.util.Collections.*;\nimport static java.lang.Math.*;\n\npublic class Main {\n\n\tint INF = 1 << 28;\n\t//long INF = 1L << 62;\n\tdouble EPS = 1e-10;\n\n\tvoid run() {\n\t\tScanner sc = new Scanner(System.in);\n\t\tfor(;;) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint m = sc.nextInt();\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tP[] ps = new P[m];\n\t\t\tint ans = 0;\n\t\t\tfor(int i=0;i<m;i++) {\n\t\t\t\tString[] sp = sc.next().split(\",\");\n\t\t\t\tps[i] = new P(Integer.parseInt(sp[0]), Integer.parseInt(sp[1]), Integer.parseInt(sp[2])/100 - 1);\n\t\t\t}\n\t\t\tsort(ps);\n\t\t\tfor(P p: ps) if(!uf.same(p.f, p.t)){\n\t\t\t\tuf.unite(p.f, p.t);\n\t\t\t\tans += p.v;\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\t\n\tpublic class UnionFind {\n\t\tint[] par, rank;\n\t\t\n\t\tpublic UnionFind(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i=0;i<n;i++) par[i] = i;\n\t\t}\n\t\t\n\t\t//代表元を求める\n\t\tint find(int x) {\n\t\t\tif( par[x] == x ) return x;\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t\t\n\t\t//要素xとyを併合する\n\t\tvoid unite(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif( x == y ) return;\n\t\t\t\n\t\t\tif( rank[x] < rank[y]  ) par[x] = y;\n\t\t\telse {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif( rank[x] == rank[y] ) rank[x]++;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//同一の集合に含まれるか調べる．trueならxとyは同じ集合，falseなら異なる\n\t\tboolean same(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\t\n\tclass P implements Comparable<P>{\n\t\tint f, t, v;\n\t\t\n\t\tP(int f, int t, int v) {\n\t\t\tthis.f = f;\n\t\t\tthis.t = t;\n\t\t\tthis.v = v;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(P o) {\n\t\t\t// TODO 自動生成されたメソッド・スタブ\n\t\t\treturn v-o.v;\n\t\t}\n\t}\n\n\tvoid debug(Object... os) {\n\t\tSystem.err.println(Arrays.deepToString(os));\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\n\tfinal int INF=1<<30;\n\tint adjacent[][];\n\tScanner sc;\n\tint n;\n\t\n\tint solve(){\n\t\tint cost=0;\n\t\tSet<Integer> vertex=new HashSet<Integer>();\n\t\tvertex.add(0);\n\t\t\n\t\tfor(int h=0;h<n;++h){\n\t\t\tint min=INF,e=0;\n\t\t\tfor(int v:vertex){\n\t\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\t\tif(vertex.contains(i))continue;\n\t\t\t\t\tif(adjacent[v][i]<min){\n\t\t\t\t\t\tmin=adjacent[v][i];\n\t\t\t\t\t\te=i;\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min<INF){\n\t\t\t\tvertex.add(e);\n\t\t\t\tcost+=min/100-1;\t\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\"\\\\s*,\\\\s*|\\r\\n\");\n\t\t\n\t\twhile((n=ni())!=0){\n\t\t\tadjacent=new int[n][n];\n\t\t\tfor(int i=0;i<n;++i){Arrays.fill(adjacent[i],INF);}\n\t\t\tint m=ni();\n\t\t\tfor(int i=0;i<m;++i){\n\t\t\t\tint a=ni(),b=ni(),d=ni();\n\t\t\t\tadjacent[a][b]=adjacent[b][a]=d;\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\n\tpublic void run() {\n\t\twhile(true){\n\t\t\tint n=sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m=sc.nextInt();\n\n\t\t\tNode[] nodes=new Node[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString[] str=sc.next().split(\",\");\n\t\t\t\tnodes[i]=new Node(Integer.parseInt(str[0]),Integer.parseInt(str[1]),Integer.parseInt(str[2]));\n\t\t\t}\n\t\t\tUnionFind uf=new UnionFind(n);\n\t\t\tArrays.sort(nodes);\n\t\t\tint res=0;int node=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tif(!uf.find(nodes[i].p1,nodes[i].p2)){\n\t\t\t\t\tuf.unite(nodes[i].p1,nodes[i].p2);\n\t\t\t\t\tres+= nodes[i].dist;\n\t\t\t\t\tnode++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(res/100-node);\n\t\t}\n\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint p1,p2,dist;\n\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn dist-o.dist;\n\t\t}\n\t\tNode(int a,int b,int c){\n\t\t\tp1=a;p2=b;dist=c;\n\t\t}\n\t}\n\tpublic class UnionFind {\n\t    private int[] id;\n\t    private int[] sz;\n\t    private int components;\n\n\t    public UnionFind(int N) {\n\t        id = new int[N];\n\t        sz = new int[N];\n\t        components = N;\n\t        for (int i = 0; i < N; i++) {\n\t            id[i] = i;\n\t            sz[i] = 1;\n\t        }\n\t    }\n\t    public int find(int x) {\n\t        while (x != id[x])\n\t            x = id[x];\n\t        return x;\n\t    }\n\t    public int components() {\n\t        return components;\n\t    }\n\t    public boolean find(int p, int q) {\n\t        return find(p) == find(q);\n\t    }\n\t    public void unite(int p, int q) {\n\t        int i = find(p);\n\t        int j = find(q);\n\t        if (i == j) return;\n\t        if   (sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i]; }\n\t        else                 { id[j] = i; sz[i] += sz[j]; }\n\t        components--;\n\t    }\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,x,y,i,r,b;(n=s.nextInt())>0;System.out.println(r+1>0?r+1:0)){int[][]a=new int[n+1][n];for(i=s.nextInt();i-->0;a[x=new Integer(z[0])][y=new Integer(z[1])]=a[y][x]=new Integer(z[2]))z=s.next().split(\",\");Queue<int[]>l=new PriorityQueue<int[]>(n,new Comparator<int[]>(){public int compare(int[]a,int[]b){return a[1]-b[1];}});int[]w={0,0};for(r=0,b=1,l.add(w);b>0;){w=l.poll();a[n][w[0]]=1;r+=w[1]/100-1;for(i=b=0;i<n;++i)if(a[n][i]<1&&a[w[0]][i]>0)l.add(new int[]{i,a[w[0]][i]});for(int m:a[n])if(m<1)b=1;}}}}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        while (true) {\n            int V = sc.nextInt();\n            if (V == 0) {\n                break;\n            }\n            int E = sc.nextInt();\n            Prim prim = new Prim(V, E);\n\n            for (int i = 0; i < E; i++) {\n                String line = sc.next();\n                String[] data = line.split(\",\");\n                int s = Integer.valueOf(data[0]);\n                int t = Integer.valueOf(data[1]);\n                int w = Integer.valueOf(data[2]) / 100 - 1;\n                prim.set(s, t, w);\n                prim.set(t, s, w);\n            }\n\n            int res = prim.run();\n            System.out.println(res);\n        }\n    }\n\n    private static class Prim {\n        int V, E;\n        ArrayList<ArrayList<Edge>> edges;\n\n        Prim(int V, int E) {\n            this.V = V;\n            this.E = E;\n            edges = new ArrayList<>();\n            for (int i = 0; i < V; i++) {\n                edges.add(new ArrayList<>());\n            }\n        }\n\n        void set(int from, int to, int cost) {\n            edges.get(from).add(new Edge(to, cost));\n        }\n\n        int run() {\n            boolean[] done = new boolean[V];\n            Arrays.fill(done, false);\n            Queue<Edge> q = new PriorityQueue<>();\n            q.add(new Edge(0, 0));\n            int costSum = 0;\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                if (done[e.t]) {\n                    continue;\n                }\n                done[e.t] = true;\n                costSum += e.w;\n                q.addAll(edges.get(e.t));\n            }\n            return costSum;\n        }\n\n    }\n\n    public static class Edge implements Comparable<Edge> {\n        public int t, w;\n\n        Edge(int t, int w) {\n            this.t = t;\n            this.w = w;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return this.w - o.w;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint m = sc.nextInt();\n\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0;i<n;i++) graph.add(new ArrayList<Edge>());\n\n\t\t\twhile(m-- > 0){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(s[0]);\n\t\t\t\tint b = Integer.parseInt(s[1]);\n\t\t\t\tint cost = Integer.parseInt(s[2]) / 100 - 1;\n\n\t\t\t\tgraph.get(a).add(new Edge(b,cost));\n\t\t\t\tgraph.get(b).add(new Edge(a,cost));\n\t\t\t}\n\n\t\t\tSystem.out.println(prim(graph));\n\t\t}\n\t}\n\n\tprivate static int prim(ArrayList<ArrayList<Edge>> graph){\n\t\tPriorityQueue<Edge> open = new PriorityQueue<Edge>();\n\t\tHashSet<Integer> closed = new HashSet<Integer>();\n\t\tint total = 0;\n\n\t\topen.add(new Edge(0,0));\n\t\twhile(closed.size() != graph.size()){\n\t\t\tEdge st = open.poll();\n\t\t\tif(closed.contains(st.to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclosed.add(st.to);\n\t\t\ttotal += st.cost;\n\t\t\tfor(Edge e : graph.get(st.to)){\n\t\t\t\tif(!closed.contains(e.to)){\n\t\t\t\t\topen.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn total;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, cost;\n\n\tEdge(int to,int cost){\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(Edge e){\n\t\treturn this.cost - e.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tprivate int[][] pathv;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine()) {\n\t\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint m = Integer.parseInt(sc.nextLine());\n\n\t\t\tint[][] path = new int[m][4];\n\n\t\t\tpathv = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tpathv[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tpath[i][j] = Integer.parseInt(nico[j]);\n\t\t\t\t}\n\t\t\t\tpath[i][2] = path[i][2] / 100 - 1;\n\t\t\t\tpath[i][3] = 0;\n\t\t\t\t\n\t\t\t\tpathv[path[i][0]][path[i][1]] = path[i][2];\t\t\t\t\n\t\t\t\tpathv[path[i][1]][path[i][0]] = path[i][2];\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tboolean[] flag = new boolean[n];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tflag[path[0][0]] = true;\n\t\t\tflag[path[0][1]] = true;\n\n\t\t\tint total = path[0][2];\n\t\t\t\n\t\t\tint marked = 2;\n\t\t\twhile (marked != n) {\n\t\t\t\tfor (int i = 1; i < path.length; i++) {\n\t\t\t\t\tif (flag[path[i][0]] != flag[path[i][1]]) {\n\t\t\t\t\t\tflag[path[i][0]] = true;\n\t\t\t\t\t\tflag[path[i][1]] = true;\n\t\t\t\t\t\ttotal = total + path[i][2];\n\t\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i < path.length; i++) {\n\t\t\t\tif (path[i][3] == 0) {\n\t\t\t\t\tint max = path[i][2];\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((max < pathv[path[i][0]][j]) && (check(j) >= 2)) max = pathv[path[i][0]][j];\n\t\t\t\t\t\tif ((max < pathv[path[i][1]][j]) && (check(j) >= 2)) max = pathv[path[i][1]][j];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttotal = total + path[i][2] - max;\n\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n\t\n\tprivate int check(int index) {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < pathv.length; i++) {\n\t\t\tif (pathv[index][i] != 0) ans++;\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintStream;\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Main {\n\n    public static void main(String[] args) throws IOException {\n        doit(args, System.in, System.out);\n    }\n\n    static void doit(String[] args, InputStream in, PrintStream out)\n            throws IOException {\n        BufferedReader reader = new BufferedReader(new InputStreamReader(in));\n        String line = null;\n        while ((line = reader.readLine()) != null) {\n            if (line.isEmpty()) {\n                continue;\n            }\n            int n = Integer.parseInt(line);\n            if (n == 0) {\n                break;\n            }\n            int m = Integer.parseInt(reader.readLine());\n            int[][] graph = new int[m][m];\n            for (int i = 0; i < m; i++) {\n                String[] values = reader.readLine().split(\",\");\n                int a = Integer.parseInt(values[0]);\n                int b = Integer.parseInt(values[1]);\n                int d = Integer.parseInt(values[2]);\n                List<Integer> path = new ArrayList<Integer>();\n                path.add(a);\n                if (findPath(graph, a, b, path)) {\n                    int maxIndex = findMaxEdge(graph, path);\n                    if (maxIndex < 0) {\n                        continue;\n                    }\n                    int maxFrom = path.get(maxIndex - 1);\n                    int maxTo = path.get(maxIndex);\n                    graph[maxFrom][maxTo] = 0;\n                    graph[maxTo][maxFrom] = 0;\n                }\n                graph[a][b] = d;\n                graph[b][a] = d;\n            }\n\n            int result = 0;\n            for (int i = 0; i < m - 1; i++) {\n                for (int j = i + 1; j < m; j++) {\n                    if (graph[i][j] > 0) {\n                        result += graph[i][j] / 100 - 1;\n                    }\n                }\n            }\n            out.println(result);\n        }\n    }\n\n    private static boolean findPath(int[][] graph, int a, int b,\n            List<Integer> path) {\n        if (graph[a][b] > 0) {\n            path.add(b);\n            return true;\n        }\n        for (int i = 0; i < graph.length; i++) {\n            if (path.contains(i)) {\n                continue;\n            }\n            if (graph[a][i] > 0) {\n                path.add(i);\n                if (findPath(graph, i, b, path)) {\n                    return true;\n                }\n                path.remove(path.size() - 1);\n            }\n        }\n        return false;\n    }\n\n    private static int findMaxEdge(int[][] graph, List<Integer> path) {\n        int maxIndex = 0;\n        int maxDistance = 0;\n        int from = path.get(0);\n        for (int i = 1; i < path.size(); i++) {\n            int to = path.get(i);\n            int d = graph[from][to];\n            if (d > maxDistance) {\n                maxDistance = d;\n                maxIndex = i;\n            }\n\n            from = to;\n        }\n        return maxIndex;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic Edge[] es;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tV = n;\n\t\t\tint m = sc.nextInt();\n\t\t\tE = m;\n\t\t\tes = new Edge[E];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tString[] tmp = sc.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(tmp[0]);\n\t\t\t\tint b = Integer.parseInt(tmp[1]);\n\t\t\t\tint c = Integer.parseInt(tmp[2]);\n\t\t\t\t\n\t\t\t\tes[i] = new Edge(a,b,c);\n\t\t\t}\n\t\t\t\n\t\t\tint ret = kruskal();\n\t\t\t\n\t\t\tret -=  (n-1)*100;\n\t\t\tout.println(ret / 100);\n\t\t}\n\t\tout.flush();\n\t}\n\t\n\tpublic static int kruskal() {\n\t\tArrays.sort(es,new Comp());\n\t\tinit(V);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tEdge e = es[i];\n\t\t\tif(!same(e.u,e.v)) {\n\t\t\t\tunite(e.u,e.v);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int[] par ;\n\tstatic int[] rank ;\n\t\n\tstatic void init(int n) {\n\t\tpar = new int[V];\n\t\trank = new int[V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tstatic int find(int x) {\n\t\tif(par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tstatic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\t\n\n}\n\n\nclass Edge {\n\tint u;\n\tint v;\n\tint cost;\n\tEdge(int a, int b, int c) {\n\t\tu = a;\n\t\tv = b;\n\t\tcost = c;\n\t}\n}\n\nclass Comp implements Comparator<Edge> {\n\n\tpublic int compare(Edge o1, Edge o2) {\n\t\treturn o1.cost - o2.cost;\n\t}\n\t\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \treturn (int)nextLong();\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\npublic class Main {\n\tfinal int INF = (int)1e9 + 7;\n\tint N,M;\n\tint[] a,b,d;\n\tArrayList<Integer>[] graph;\n\tint[][] cost;\n\tprivate class P implements Comparable<P>{\n\t\tint first,second;\n\t\tpublic P(int first,int second){\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\t\tpublic int compareTo(P p){\n\t\t\tif(this.first == p.first){\n\t\t\t\treturn this.second - p.second;\n\t\t\t}\n\t\t\treturn this.first - p.first;\n\t\t}\n\t}\n\n\tpublic int dijkstra(int s){\n\t\tboolean[] used = new boolean[N];\n\t\tint ret = 0;\n\t\tPriorityQueue<P> pq = new PriorityQueue<P>();\n\t\tpq.add(new P(0,s));\n\t\twhile(pq.size() > 0){\n\t\t\tP p = pq.poll();\n\t\t\tif(used[p.second])continue;\n\t\t\tused[p.second] = true;\n\t\t\tret+=p.first;\n\t\t\tfor(int next : graph[p.second]){\n\t\t\t\tpq.add(new P(cost[p.second][next],next));\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void solve() {\n\t\twhile(true){\n\t\t\tN = nextInt();\n\n\t\t\tif(N == 0)break;\n\n\t\t\tM = nextInt();\n\t\t\ta = new int[M];\n\t\t\tb = new int[M];\n\t\t\td = new int[M];\n\t\t\tgraph = new ArrayList[N];\n\t\t\tcost = new int[N][N];\n\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\tgraph[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor(int i = 0;i < M;i++){\n\t\t\t\tString[] line = next().split(\",\");\n\t\t\t\ta[i] = Integer.parseInt(line[0]);\n\t\t\t\tb[i] = Integer.parseInt(line[1]);\n\t\t\t\td[i] = (Integer.parseInt(line[2]) / 100) - 1;\n\t\t\t\tcost[a[i]][b[i]] = d[i];\n\t\t\t\tcost[b[i]][a[i]] = d[i];\n\t\t\t\tgraph[a[i]].add(b[i]);\n\t\t\t\tgraph[b[i]].add(a[i]);\n\t\t\t}\n\n\t\t\tint ans = INF;\n\n\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\tans = Math.min(ans, dijkstra(i));\n\t\t\t}\n\n\t\t\tout.println(ans);\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tint[][] path;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine()) {\n\t\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint m = Integer.parseInt(sc.nextLine());\n\n\t\t\tpath = new int[m][4];\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tpath[i][j] = Integer.parseInt(nico[j]);\n\t\t\t\t}\n\t\t\t\tpath[i][2] = path[i][2] / 100 - 1;\n\t\t\t\tpath[i][3] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tboolean[] flag = new boolean[n];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tflag[path[0][0]] = true;\n\t\t\tflag[path[0][1]] = true;\n\t\t\tpath[0][3] = 1;\n\t\t\t\n\t\t\tint total = path[0][2];\n\t\t\t\n\t\t\tint marked = 2;\n\t\t\twhile (marked != n) {\n\t\t\t\tfor (int i = 1; i < path.length; i++) {\n\t\t\t\t\tif (flag[path[i][0]] != flag[path[i][1]]) {\n\t\t\t\t\t\tflag[path[i][0]] = true;\n\t\t\t\t\t\tflag[path[i][1]] = true;\n\t\t\t\t\t\ttotal = total + path[i][2];\n\t\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tif (path[i][3] == 0) {\n\t\t\t\t\tint max = i;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < path.length; j++) {\n\t\t\t\t\t\tif ((path[j][3] == 0) || (i == j)) continue;\n\t\t\t\t\t\tif ((path[j][0] != path[i][0]) && (path[j][0] != path[i][1])\n\t\t\t\t\t\t\t\t&& (path[j][1] != path[i][0]) && (path[j][1] != path[i][1])) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint checknode = -1;\n\t\t\t\t\t\tif ((path[j][0] == path[i][0]) || (path[j][0] == path[i][1])) checknode = path[j][1];\n\t\t\t\t\t\telse checknode = path[j][0];\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((path[max][2] < path[j][2]) && (check(checknode) >= 2)) max = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttotal = total + path[i][2] - path[max][2];\n\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\tpath[max][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n\t\n\tprivate int check(int index) {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (path[i][j] == index) ans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Iterator;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static final int FROM = 0;\n\tpublic static final int TO = 1;\n\tpublic static final int DIS = 2;\n\n\tpublic static void main(String[] args) {\n\t\tdoIt();\n\t}\n\n\tpublic static void printQueue(PriorityQueue<E> pq){\n\t\tIterator<E> it = pq.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tE t = it.next();\n\t\t\tSystem.out.println(\"from \" + t.from + \" , to \" + t.to + \" , distance \" + t.distance);\n\t\t}\n\t}\n\t\n\tpublic static void print(int[] a){\n\t\tfor(int n : a){\n\t\t\tSystem.out.print(n + \" \");\n\t\t}\n\t\tSystem.out.println();\n\t}\n\n\tpublic static void doIt(){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n = sc.nextInt();\n\t\tPriorityQueue<E> pq = new PriorityQueue<E>();\n\t\twhile(n != 0){\n\t\t\tint m = sc.nextInt();\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString s = sc.next();\n\t\t\t\t//System.out.println(s);\n\t\t\t\tString[] ss = s.split(\",\");\n\t\t\t\tpq.add(new E(Integer.parseInt(ss[FROM]),Integer.parseInt(ss[TO]),Integer.parseInt(ss[DIS])));\n\t\t\t}\n\t\t\t//printQueue(pq);\n\t\t\t//連結関係を表す。同じ数字なら連結している\n\t\t\tint[] con = new int[n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tcon[i] = i;\n\t\t\t}\n\n\t\t\t//pqを初めから見ていき、頂点を連結させていく\n\t\t\tint len = pq.size();\n\t\t\tint ans = 0;\n\t\t\tint len2 = con.length;\n\t\t\tfor(int i = 0; i < len; i++){\n\t\t\t\tE edge = pq.poll();\n\t\t\t\t//まだ連結されていなかったら\n\t\t\t\tif(con[edge.from] != con[edge.to]){\n\t\t\t\t\t//連結する\n\t\t\t\t\t//con[edge.to] = con[edge.from];\n\t\t\t\t\tans += edge.distance / 100 - 1;\n\t\t\t\t\tif(connectAndCheck(con, len2, con[edge.to], con[edge.from])){\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t//print(con);\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static boolean connectAndCheck(int[] con, int len, int bef, int aft){\n\t\tboolean bRet = true;\n\t\tint e = con[0];\n\t\tfor(int i = 0; i < len; i++){\n\t\t\tif(con[i] == bef){\n\t\t\t\tcon[i] = aft;\n\t\t\t}\n\t\t\tif(e != con[i]){\n\t\t\t\tbRet = false;\n\t\t\t}\n\t\t}\n\t\treturn bRet;\n\t}\n\n\n}\n\nclass E implements Comparable<E>{\n\tpublic int from,to,distance;\n\tpublic E(int f, int t, int d){\n\t\tfrom = f;\n\t\tto = t;\n\t\tdistance = d;\n\t}\n\tpublic int compareTo(E arg0) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\treturn distance - arg0.distance;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tstatic int N,M;\n\tpublic static void main(String[] args) {\n\t\tScanner cin = new Scanner(System.in);\n\t\tfor(;;){\n\t\t\tN=Integer.parseInt(cin.nextLine());\n\t\t\tif(N==0)break;\n\t\t\tM=Integer.parseInt(cin.nextLine());\n\t\t\tEdge[] e=new Edge[M];\n\t\t\tfor(int i=0;i<M;i++){\n\t\t\t\tString[] s = cin.nextLine().split(\",\");\n\t\t\t\tint a=Integer.parseInt(s[0]);\n\t\t\t\tint b=Integer.parseInt(s[1]);\n\t\t\t\tint c=Integer.parseInt(s[2]);\n\t\t\t\te[i]=new Edge(a,b,c);\n\t\t\t}\n\t\t\tArrays.sort(e);\n\t\t\tUnionFind union=new UnionFind(N);\n\t\t\tint ans=0;\n\t\t\tfor(int i=0;i<e.length;i++){\n\t\t\t\tif(!union.find(e[i].a, e[i].b)){\n\t\t\t\t\tunion.union(e[i].a, e[i].b);\n\t\t\t\t\tans+=(e[i].cost/100) - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint a,b;\n\t\tint cost;\n\t\tEdge(int x,int y,int z){\n\t\t\ta=x;b=y;cost=z;\n\t\t}\n\t\tpublic int compareTo(Edge e){\n\t\t\treturn cost-e.cost;\n\t\t}\n\t}\n\tstatic class UnionFind{\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n){\n\t\t\tthis.tree=new int[n];\n\t\t\tArrays.fill(tree,-1);\n\t\t\tnum=n;\n\t\t}\n\t\t\n\t\tvoid union(int x,int y){\n\t\t\tx=root(x);\n\t\t\ty=root(y);\n\t\t\tif(x!=y){\n\t\t\t\tif(tree[x]<tree[y]){\n\t\t\t\t\tx ^= y;\n\t\t\t\t\ty ^= x;\n\t\t\t\t\tx ^= y;\n\t\t\t\t}\n\t\t\t\ttree[x]+=tree[y];\n\t\t\t\ttree[y]=x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\tboolean find(int x,int y){\n\t\t\treturn root(x)==root(y);\n\t\t}\n\t\tint root(int x){\n\t\t\treturn tree[x]<0?x:(tree[x]=root(tree[x]));\n\t\t}\n\t\tint size(int x){\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\tint getNum(){\n\t\t\treturn num;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static int[][][] getAdjecentListWithCounter(int n, int[] from, int[] to, int[] w) {\n\t\tint[][][] e = new int[n][][];\n\t\tint[] d = new int[n];\n\t\tfor (int f : from)\n\t\t\td[f]++;\n\t\tfor (int t : to)\n\t\t\td[t]++;\n\t\tfor (int i = 0; i < n; i++)\n\t\t\te[i] = new int[d[i]][2];\n\t\tfor (int i = 0; i < from.length; i++) {\n\t\t\t--d[from[i]];\n\t\t\te[from[i]][d[from[i]]][0] = to[i];\n\t\t\te[from[i]][d[from[i]]][1] = w[i];\n\t\t\t--d[to[i]];\n\t\t\te[to[i]][d[to[i]]][0] = from[i];\n\t\t\te[to[i]][d[to[i]]][1] = w[i];\n\t\t}\n\t\treturn e;\n\t}\n\n\tpublic static int prim(int[][][] adj, int nodes, int s) {\n\t\tfinal int[] d = new int[nodes];\n\t\tArrays.fill(d, 0);\n\t\tTreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn (d[a[0]] != d[b[0]]) ? (d[a[0]] - d[b[0]]) : (a[1] - b[1]);\n\t\t\t}\n\t\t});\n\t\td[s] = 1;\n\t\tfor (int[] e : adj[s]) {\n\t\t\tts.add(e);\n\t\t}\n\t\tint w = 0;\n\t\twhile (!ts.isEmpty()) {\n\t\t\tint[] ne = ts.pollFirst();\n\t\t\tif (d[ne[0]] == 1)\n\t\t\t\tcontinue;\n\t\t\td[ne[0]] = 1;\n\t\t\tw += ne[1];\n\t\t\tfor (int[] e : adj[ne[0]]) {\n\t\t\t\tts.add(e);\n\t\t\t}\n\t\t}\n\t\treturn w;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = sc.nextInt();\n\t\t\tint[] f = new int[m];\n\t\t\tint[] t = new int[m];\n\t\t\tint[] w = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tf[i] = sc.nextInt();\n\t\t\t\tt[i] = sc.nextInt();\n\t\t\t\tw[i] = sc.nextInt() / 100 - 1;\n\t\t\t}\n\t\t\tint[][][] g = getAdjecentListWithCounter(n, f, t, w);\n\t\t\tSystem.out.println(prim(g, n, 0));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint v1, v2;\n\t\tint weight;\n\n\t\tEdge (int v1, int v2, int weight) {\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.weight = weight / 100 - 1;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn this.weight - o.weight;\n\t\t}\n\t}\n\n\tstatic class Vertex {\n\t\tVertex parent;\n\t\t\n\t\tVertex () {\n\t\t\tthis.parent = this;\n\t\t}\n\t}\n\t\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tVertex vertex[];\n\t\tEdge edge[];\n\t\tint sumWeight;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\tm = sc.nextInt();\n\t\t\tvertex = new Vertex[n];\n\t\t\tedge = new Edge[m];\n\t\t\tsumWeight = 0;\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tvertex[i] = new Vertex();\n\t\t\t}\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tedge[i] = new Edge(Integer.parseInt(s[0]), Integer.parseInt(s[1]), Integer.parseInt(s[2]));\n\t\t\t}\n\t\t\tArrays.sort(edge);\n\t\t\t\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (find(vertex[edge[i].v1]) != (find(vertex[edge[i].v2]))) {\n\t\t\t\t\tsumWeight += edge[i].weight;\n\t\t\t\t\tvertex[edge[i].v2].parent = find(vertex[edge[i].v1]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sumWeight);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\t\n\tpublic static Vertex find(Vertex vertex) {\n\t\tif (vertex.parent == vertex) {\n\t\t\treturn vertex;\n\t\t} else {\n\t\t\treturn find(vertex.parent);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        Prim prim = new Prim(V, E);\n\n        for (int i = 0; i < E; i++) {\n            String line = sc.next();\n            String[] data = line.split(\",\");\n            int s = Integer.valueOf(data[0]);\n            int t = Integer.valueOf(data[1]);\n            int w = Integer.valueOf(data[2]) / 100 - 1;\n            prim.set(s, t, w);\n            prim.set(t, s, w);\n        }\n\n        int res = prim.run();\n        System.out.println(res);\n    }\n\n    public static class Prim {\n        int V, E;\n        ArrayList<Edge>[] edges;\n\n        @SuppressWarnings(\"unchecked\")\n        Prim(int V, int E) {\n            this.V = V;\n            this.E = E;\n            edges = new ArrayList[V];\n            for (int i = 0; i < V; i++) {\n                edges[i] = new ArrayList<>();\n            }\n        }\n\n        void set(int from, int to, int cost) {\n            edges[from].add(new Edge(to, cost));\n        }\n\n        int run() {\n            boolean[] done = new boolean[V];\n            Arrays.fill(done, false);\n            Queue<Edge> q = new PriorityQueue<>();\n            q.add(new Edge(0, 0));\n            int costSum = 0;\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                if (done[e.t]) {\n                    continue;\n                }\n                done[e.t] = true;\n                costSum += e.w;\n                q.addAll(edges[e.t]);\n            }\n            return costSum;\n        }\n\n    }\n\n    public static class Edge implements Comparable<Edge> {\n        public int t, w;\n\n        Edge(int t, int w) {\n            this.t = t;\n            this.w = w;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return this.w - o.w;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] makeadj(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj) {\n        final int[] d = new int[adj.length];\n        Arrays.fill(d, 0);\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if (d[a[1]] != d[b[1]]) {\n                    return (d[a[1]] - d[b[1]]);\n                } else if (a[2] != b[2]) {\n                    return a[2] - b[2];\n                }\n                return 1;\n            }\n        });\n\n        d[0] = 1;\n        for (int[] e : adj[0]) {\n            ts.add(new int[]{0, e[0], e[1]});\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[1]] == 1)\n                break;\n            d[ne[1]] = 1;\n            w += ne[2];\n            for (int[] e : adj[ne[1]]) {\n                ts.add(new int[]{ne[1], e[0], e[1]});\n            }\n        }\n        return w;\n    }\n\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = sc.nextInt()-100;// / 100;\n            }\n            int[][][] g = makeadj(n, f, t, w);\n            System.out.println(prim(g)/100);\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = 0, m = 0, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(sb.append(reader.readLine())).equals(\"0\")){\n\t\t\tn = Integer.valueOf(sb.toString());\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tsb.setLength(0);\n\t\t\t\tsb.append(reader.readLine());\n\t\t\t\ta = Integer.valueOf(sb.toString().split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(sb.toString().split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(sb.toString().split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t\tsb.setLength(0);\n\t\t}\n\t\treader.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tint[][] map = new int[n][n];\n\t\t\tfor(int i=0;i<n;i++) Arrays.fill(map[i], Integer.MAX_VALUE);\n\t\t\t\n\t\t\tint m = sc.nextInt();\n\t\t\tint p, q;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tp = Integer.valueOf(s[0]);\n\t\t\t\tq = Integer.valueOf(s[1]);\n\t\t\t\tmap[p][q] = Integer.valueOf(s[2])/100 - 1;\n\t\t\t\tmap[q][p] = map[p][q];\n\t\t\t}\n\t\t\t\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tlist.add(0);\n\t\t\tint sum = 0;\n\t\t\tint r = 0;\n\t\t\tfor(int i=1;i<n;i++){\n\t\t\t\tq = Integer.MAX_VALUE;\n\t\t\t\tfor(int j=0;j<i;j++){\n\t\t\t\t\tp = list.get(j);\n\t\t\t\t\tfor(int k=0;k<n;k++){\n\t\t\t\t\t\tif(list.contains(k)==false && q>map[p][k]){\n\t\t\t\t\t\t\tq = map[p][k];\n\t\t\t\t\t\t\tr = k;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tlist.add(r);\n\t\t\t\tsum += q;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = sc.nextInt();\n\t\t\tint[][] e = new int[m][3];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\te[i][0] = sc.nextInt();\n\t\t\t\te[i][1] = sc.nextInt();\n\t\t\t\te[i][2] = sc.nextInt() / 100 - 1;\n\t\t\t}\n\t\t\tArrays.sort(e, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\t\treturn a[2] - b[2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tboolean[] b = new boolean[n];\n\t\t\tArrays.fill(b, false);\n\t\t\tint w = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (b[e[i][0]] && b[e[i][1]])\n\t\t\t\t\tcontinue;\n\t\t\t\tb[e[i][0]] = b[e[i][1]] = true;\n\t\t\t\tw += e[i][2];\n\t\t\t}\n\t\t\tSystem.out.println(w);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = sc.nextInt();\n\t\t\tint[][] e = new int[m][3];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\te[i][0] = sc.nextInt();\n\t\t\t\te[i][1] = sc.nextInt();\n\t\t\t\te[i][2] = (sc.nextInt() - 1) / 100;\n\t\t\t}\n\t\t\tArrays.sort(e, new Comparator<int[]>() {\n\t\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\t\treturn a[2] - b[2];\n\t\t\t\t}\n\t\t\t});\n\t\t\tboolean[] b = new boolean[n];\n\t\t\tArrays.fill(b, false);\n\t\t\tint w = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (b[e[i][0]] && b[e[i][1]])\n\t\t\t\t\tcontinue;\n\t\t\t\tb[e[i][0]] = b[e[i][1]] = true;\n\t\t\t\tw += e[i][2];\n\t\t\t}\n\t\t\tSystem.out.println(w);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\n//Carden Lantern\npublic class Main{\n\n\tstatic class E implements Comparable<E>{\n\t\tpublic int s;\n\t\tpublic int t;\n\t\tpublic int x;\n\t\tpublic E(int s, int t, int x) {\n\t\t\tthis.s = s;\n\t\t\tthis.t = t;\n\t\t\tthis.x = x;\n\t\t}\n\t\tpublic int compareTo(E o) {\n\t\t\treturn x-o.x;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt();\n\t\t\tPriorityQueue<E> q = new PriorityQueue<E>();\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tq.add(new E(Integer.parseInt(s[0]), Integer.parseInt(s[1]), Integer.parseInt(s[2])/100-1));\n\t\t\t}\n\t\t\tUnionFind union = new UnionFind(n);\n\t\t\tint c = 0;\n\t\t\twhile(union.num>1){\n\t\t\t\tE e = q.poll();\n\t\t\t\tif(!union.find(e.s, e.t)){\n\t\t\t\t\tunion.union(e.s, e.t);\n\t\t\t\t\tc+=e.x;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t}\n\t\n\tstatic class UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum=n;\n\t\t}\n\n\t\t// merge the set contains x and the set contains y\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif(x != y) {\n\t\t\t\tif(tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y; y ^= x; x^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\t\t// decide if x and y belong to the same set\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\t\t// return size of the set contains x\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\t\t// return the number of sets\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in).useDelimiter(\"[\\\\s,]+\");\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tm = scanner.nextInt();\n\t\t\te = new Edge[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint from = scanner.nextInt();\n\t\t\t\tint to = scanner.nextInt();\n\t\t\t\tint cost = scanner.nextInt() / 100 - 1;\n\t\t\t\te[i] = new Edge(from, to, cost);\n\t\t\t}\n\t\t\tSystem.out.println(kruskal());\n\t\t}\n\t}\n\n\tprivate int kruskal() {\n\t\tArrays.sort(e);\n\t\tint ans = 0;\n\t\tUnion union = new Union(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tEdge edge = e[i];\n\t\t\tif (union.isSame(edge.from, edge.to))\n\t\t\t\tcontinue;\n\t\t\tans += edge.cost;\n\t\t\tunion.unit(edge.from, edge.to);\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tint n, m;\n\tEdge[] e;\n\n\tclass Union {\n\t\tint[] par, rank;\n\n\t\tpublic Union(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tpar[i] = i;\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] == x)\n\t\t\t\treturn x;\n\t\t\treturn par[x] = find(par[x]);\n\n\t\t}\n\n\t\tboolean isSame(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tvoid unit(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (rank[x] < rank[y])\n\t\t\t\tpar[x] = y;\n\t\t\telse {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[x]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tsuper();\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [from=\" + from + \", to=\" + to + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn cost - o.cost;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tm = scanner.nextInt();\n\t\t\te = new Edge[n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tStringTokenizer t = new StringTokenizer(scanner.next(), \",\");\n\t\t\t\tint from = Integer.parseInt(t.nextToken());\n\t\t\t\tint to = Integer.parseInt(t.nextToken());\n\t\t\t\tint cost = Integer.parseInt(t.nextToken()) / 100 - 1;\n\t\t\t\te[i] = new Edge(from, to, cost);\n\t\t\t}\n\t\t\tSystem.out.println(kruskal());\n\t\t}\n\t}\n\n\tprivate int kruskal() {\n\t\tArrays.sort(e);\n\t\tint ans = 0;\n\t\tUnion union = new Union(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tEdge edge = e[i];\n\t\t\tif (union.isSame(edge.from, edge.to))\n\t\t\t\tcontinue;\n\t\t\tans += edge.cost;\n\t\t\tunion.unit(edge.from, edge.to);\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tint n, m;\n\tEdge[] e;\n\n\tclass Union {\n\t\tint[] par, rank;\n\n\t\tpublic Union(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tpar[i] = i;\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] == x)\n\t\t\t\treturn x;\n\t\t\treturn par[x] = find(par[x]);\n\n\t\t}\n\n\t\tboolean isSame(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tvoid unit(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (rank[x] < rank[y])\n\t\t\t\tpar[x] = y;\n\t\t\telse {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tsuper();\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [from=\" + from + \", to=\" + to + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn cost - o.cost;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=1000000;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt(),m=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n][n];\n\t\t\tint mincost[]=new int[n];//頂点iへの辺の最小コスト\n\t\t\tboolean use[]=new boolean[n];//頂点iが部分全域木に含まれているか\n\t\t\tint total=0;//answer\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tArrays.fill(mincost, M);\n\t\t\tArrays.fill(use, false);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString str[]=in.next().split(\",\");\n\t\t\t\tint s=Integer.valueOf(str[0]);\n\t\t\t\tint t=Integer.valueOf(str[1]);\n\t\t\t\tint c=Integer.valueOf(str[2]);\n\t\t\t\tcost[s][t]=c;\n\t\t\t\tcost[t][s]=c;\n\t\t\t}\n\t\t\tmincost[0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint v=-1;//追加する頂点\t\t\t\t\n\t\t\t\tfor(int j=0;j<n;j++)//追加する頂点を探す\n\t\t\t\t\tif(!use[j]&&(v==-1||mincost[v]>mincost[j]))\n\t\t\t\t\t\tv=j;\n\t\t\t\tif(v==-1) //全ての頂点を選んだ\n\t\t\t\t\tbreak;\n\t\t\t\tif(mincost[v]!=0)\n\t\t\t\ttotal+=((mincost[v]/100)-1);\n\t\t\t\tuse[v]=true;\n\n\t\t\t\tfor(int j=0;j<n;j++)//追加した頂点と繋がっている辺を調べ最小コストを更新\n\t\t\t\t{\n\t\t\t\t\tif(!use[j]&&mincost[j]>cost[v][j])\n\t\t\t\t\t\tmincost[j]=cost[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m, a, b;\n\t\tString[] str;\n\t\tint[][] map;\n\t\tint[] prim;\n\t\tPriorityQueue<int[]> que;\n\t\twhile((n = sc.nextInt()) != 0){\n\t\t\tm = sc.nextInt();\n\t\t\tmap = new int[n][n];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tstr = sc.next().split(\",\");\n\t\t\t\ta = Integer.parseInt(str[0]);\n\t\t\t\tb = Integer.parseInt(str[1]);\n\t\t\t\tmap[a][b] = map[b][a] = Integer.parseInt(str[2]);\n\t\t\t}\n\t\t\tprim = new int[n];\n\t\t\tArrays.fill(prim, -1);\n\t\t\tque = new PriorityQueue<int[]>(m, new Comparator<int[]>(){\n\t\t\t\tpublic int compare(int[] a, int[] b){\n\t\t\t\t\treturn a[0] - b[0];\n\t\t\t\t}\n\t\t\t});\n\t\t\tfor(int i = 1; i < n; i++){\n\t\t\t\tif(map[0][i] != 0){\n\t\t\t\t\tque.add(new int[]{map[0][i], i});\n\t\t\t\t}\n\t\t\t}\n\t\t\tint[] now;\n\t\t\tint sum = 0;\n\t\t\tprim[0] = 0;\n\t\t\twhile(!que.isEmpty()){\n\t\t\t\tnow = que.poll();\n\t\t\t\tif(prim[now[1]] == -1){\n\t\t\t\t\tsum += (now[0] / 100) - 1;\n\t\t\t\t\tprim[now[1]] = 0;\n\t\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\t\tif(map[now[1]][i] != 0){\n\t\t\t\t\t\t\tque.add(new int[]{map[now[1]][i], i});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.awt.geom.Point2D;\nimport java.util.*;\n\n\npublic class Main {\n\tScanner in = new Scanner(System.in);\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\tpublic Main() {\n\t\tnew AOJ_GRL_2();\n\t}\n\n\tclass AOJ_GRL_2{\n\t\tint cost[][]; //コスト\n\t\tint d[];//使用済み頂点群からの最短距離\n\t\tboolean used[];//既に使用されたかのフラグ\n\t\tint V;//頂点数\n\t\tint INF;\n\t\tint cnt;//答え\n\t\tvoid Prim(int s){//任意の頂点\n\t\t\td = new int[V];\n\t\t\tused = new boolean[V];\n\t\t\tINF = Integer.MAX_VALUE;\n\t\t\tArrays.fill(used, false);\n\t\t\tArrays.fill(d,INF);\n\t\t\td[s] = 0;\n\t\t\tcnt = 0;\n\t\t\twhile(true){\n\t\t\t\tint v=-1;\n\t\t\t\tfor(int u=0;u<V;u++){//まだ使われていない頂点のうち最小のものを探す\n\t\t\t\t\tif(!used[u]&&(v==-1||d[u]<d[v]))v=u;\n\t\t\t\t}\n\t\t\t\tif(v==-1)break;\n\t\t\t\tused[v]=true;\n\t\t\t\t\n\t\t\t\tint a = d[v]/100;\n\t\t\t\tif(a>0)a--;\n\t\t\t\tcnt+=a;\n\t\t\t\t\n\t\t\t\tfor(int k=0;k<V;k++)if(!used[k]&&cost[v][k]!=0){\n\t\t\t\t\td[k] = Math.min(cost[v][k], d[k]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tpublic AOJ_GRL_2() {\n\t\t\twhile(true){\n\t\t\t\tV = in.nextInt();\n\t\t\t\tcost = new int[V][V];\n\t\t\t\tif(V==0)break;\n\t\t\t\tint n = in.nextInt();\n\t\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\t\tString input[] = in.next().split(\",\");\n\t\t\t\t\tint a = Integer.parseInt(input[0]);\n\t\t\t\t\tint b = Integer.parseInt(input[1]);\n\t\t\t\t\tint c = Integer.parseInt(input[2]);\n\t\t\t\t\tcost[a][b] = c;\n\t\t\t\t\tcost[b][a] = c;\n\t\t\t\t}\n\t\t\t\tPrim(0);\n\t\t\t\tSystem.out.println(cnt);\n\t\t\t}\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static Set<int[]> edges(int n, int[] f, int[] t, int[] w,\n\t\t\tboolean ce, boolean cw) {\n\t\tSet<int[]> e = new HashSet<int[]>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te.add(new int[] { f[i], t[i], w[i] });\n\t\t\tif (ce)\n\t\t\t\te.add(new int[] { f[i], t[i], cw ? -w[i] : w[i] });\n\t\t}\n\t\treturn e;\n\t}\n\n\tpublic static int prim(Set<int[]> e, int nodes, int s) {\n\t\tfinal int[] d = new int[nodes];\n\t\tArrays.fill(d, 0);// 到達フラグ\n\t\t// 距離優先\n\t\tTreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn (d[a[1]]-d[a[0]])!=(d[b[1]]-b[a[0]])?((d[a[1]]-d[a[0]])-(d[b[1]]-b[a[0]])):(a[2] - b[2]);\n\t\t\t}\n\t\t});\n\t\tts.addAll(e);\n\t\tint[] ne = ts.pollFirst();\n\t\td[ne[0]] = d[ne[1]] = 1;\n\t\tint w = ne[2];\n\t\twhile (!ts.isEmpty()) {\n\t\t\tne = ts.pollFirst();\n\t\t\tif (d[ne[1]] == 1) continue;\n\t\t\td[ne[1]] = 1;\n\t\t\tw += ne[2];\n\t\t}\n\t\treturn w;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = sc.nextInt();\n\t\t\tint[] f = new int[m];\n\t\t\tint[] t = new int[m];\n\t\t\tint[] w = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tf[i] = sc.nextInt();\n\t\t\t\tt[i] = sc.nextInt();\n\t\t\t\tw[i] = (sc.nextInt() - 1) / 100;\n\t\t\t}\n\t\t\tSet<int[]> e = edges(n, f, t, w, true, false);\n\t\t\tSystem.out.println(prim(e, n, 0));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\tint n, m, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tn = Integer.valueOf(string);\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\ta = Integer.valueOf(string.split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(string.split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(string.split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t};\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\treader.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tpublic static void main(String[] args){\n\t\tnew Main().calc();\n\t}\n\n\tvoid calc(){\n\t\tScanner cin = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = cin.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tuni = new int[n];\n\t\t\tint i;\n\t\t\tfor(i=0;i<n;i++) uni[i] = -1;\n\t\t\tint m = cin.nextInt();\n\t\t\tint[] a = new int[m];\n\t\t\tint[] b = new int[m];\n\t\t\tint[] d = new int[m];\n\t\t\tlong[] sum = new long[m];\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\tString[] st = cin.next().split(\",\");\n\t\t\t\ta[i] = Integer.parseInt(st[0]);\n\t\t\t\tb[i] = Integer.parseInt(st[1]);\n\t\t\t\td[i] = Integer.parseInt(st[2])/100 - 1;\n\t\t\t\tsum[i] = d[i] * (long)10000 + a[i] * 100 + b[i];\n\t\t\t}\n\t\t\tArrays.sort(sum);\n\t\t\tint ret = 0;\n\t\t\tfor(i=0;i<m;i++){\n\t\t\t\ta[i] = (int)(sum[i] %100);\n\t\t\t\tb[i] = (int)((sum[i]/100)%100);\n\t\t\t\td[i] = (int)(sum[i]/10000);\n\t\t\t\tif(getuni(a[i])!=getuni(b[i])){\n\t\t\t\t\tret += d[i];\n\t\t\t\t\tconnect(a[i],b[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ret);\n\t\t}\n\t}\n\n\tint[] uni;\n\n\tint getuni(int a){\n\t\tif(uni[a]<0) return a;\n\t\treturn uni[a] = getuni(uni[a]);\n\t}\n\t\n\tvoid connect(int a, int b){\n\t\ta = getuni(a);\n\t\tb = getuni(b);\n\t\tuni[a] = b;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Main {\n\tpublic static Set<int[]> edges(int n, int[] f, int[] t, int[] w,\n\t\t\tboolean ce, boolean cw) {\n\t\tSet<int[]> e = new HashSet<int[]>();\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\te.add(new int[] { f[i], t[i], w[i] });\n\t\t\tif (ce)\n\t\t\t\te.add(new int[] { f[i], t[i], cw ? -w[i] : w[i] });\n\t\t}\n\t\treturn e;\n\t}\n\n\tpublic static int prim(Set<int[]> e, int nodes, int s) {\n\t\tfinal int[] d = new int[nodes];\n\t\tArrays.fill(d, 0);// 到達フラグ\n\t\t// 距離優先\n\t\tTreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n\t\t\tpublic int compare(int[] a, int[] b) {\n\t\t\t\treturn (d[a[1]] - d[a[0]]) != (d[b[1]] - b[a[0]]) ? ((d[a[1]] - d[a[0]]) - (d[b[1]] - b[a[0]]))\n\t\t\t\t\t\t: (a[2] - b[2]);\n\t\t\t}\n\t\t});\n\t\tts.addAll(e);\n\t\tint[] ne = ts.pollFirst();\n\t\td[ne[0]] = d[ne[1]] = 1;\n\t\tint w = ne[2];\n\t\twhile (!ts.isEmpty()) {\n\t\t\tne = ts.pollFirst();\n\t\t\tif (d[ne[0]] == 0 || d[ne[1]] == 1)\n\t\t\t\tbreak;\n\t\t\td[ne[1]] = 1;\n\t\t\tw += ne[2];\n\t\t}\n\t\treturn w;\n\t}\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tint m = sc.nextInt();\n\t\t\tint[] f = new int[m];\n\t\t\tint[] t = new int[m];\n\t\t\tint[] w = new int[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tf[i] = sc.nextInt();\n\t\t\t\tt[i] = sc.nextInt();\n\t\t\t\tw[i] = (sc.nextInt() - 100) / 100;\n\t\t\t}\n\t\t\tsc.nextInt();\n\t\t\tSet<int[]> e = edges(n, f, t, w, true, false);\n\t\t\tSystem.out.println(prim(e, n, 0));\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scan.nextInt();\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tedge[] e = new edge[m];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\te[i] = new edge(Integer.parseInt(str[0]),Integer.parseInt(str[1]),Integer.parseInt(str[2]));\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = n-1;j > i;j--){\n\t\t\t\t\tif(e[j].cost < e[j-1].cost){\n\t\t\t\t\t\tswap(e,j,j-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = 0;\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tif(!uf.same(e[i].u,e[i].v)){\n\t\t\t\t\tuf.unite(e[i].u,e[i].v);\n\t\t\t\t\tmin += e[i].cost/100 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tpublic void swap(edge[] e,int i,int j){\n\t\tedge t = e[j];e[j] = e[i];e[i] = t;\n\t}\n\tpublic class UnionFind{\n\t\tint[] par;\n\t\tint[] rank;\n\t\tpublic UnionFind(int n){\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tpar[i] = i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else{\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic boolean same(int x,int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\tpublic class edge{\n\t\tint u;\n\t\tint v;\n\t\tint cost;\n\t\tpublic edge(int u,int v,int cost){\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tstatic class Edge {\n\t\tint v1, v2;\n\t\tint weight;\n\t\tboolean mark;\n\n\t\tEdge (int v1, int v2, int weight) {\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.weight = weight;\n\t\t\tthis.mark = false;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, k;\n\t\tEdge edge[];\n\t\tint vertex[];\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\tk = sc.nextInt();\n\t\t\tvertex = new int[n];\n\t\t\tedge = new Edge[k];\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tedge[i] = new Edge(Integer.valueOf(s[0]), Integer.valueOf(s[1]), Integer.valueOf(s[2]));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tvertex[i] = i;\n\t\t\t}\n\t\t\tsort(edge, 0, k - 1);\n\t\t\t\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (vertex[edge[i].v1] != vertex[edge[i].v2]) {\n\t\t\t\t\tedge[i].mark = true;\n\t\t\t\t\tint num = vertex[edge[i].v2];\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif (vertex[j] == num) {\n\t\t\t\t\t\t\tvertex[j] = vertex[edge[i].v1];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < k; i++) {\n\t\t\t\tif (edge[i].mark) {\n\t\t\t\t\tsum += ((edge[i].weight - 100) / 100);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\t\n\tpublic static void sort(Edge edge[], int low, int high) {\n\t\tif (high <= low) {\n\t\t\treturn ;\n\t\t}\n\t\tint i = low;\n\t\tint j = high;\n\t\tint x = edge[(low + high) / 2].weight;\n\t\twhile (i <= j) {\n\t\t\twhile (edge[i].weight < x) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (x < edge[j].weight) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (i <= j) {\n\t\t\t\tEdge swap = new Edge(edge[i].v1, edge[i].v2, edge[i].weight);\n\t\t\t\tedge[i] = edge[j];\n\t\t\t\tedge[j] = swap;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tsort(edge, low, j);\n\t\t\tsort(edge, i, high);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Edge {\n\t\tint v1, v2;\n\t\tint weight;\n\t\tboolean mark;\n\n\t\tEdge (int v1, int v2, int weight) {\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.weight = weight;\n\t\t\tthis.mark = false;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tInputStreamReader is = new InputStreamReader(System.in);\n\t\tBufferedReader br = new BufferedReader(is);\n\t\tint n, m;\n\t\tEdge edge[];\n\t\tint vertex[];\n\n\t\ttry {\n\t\t\tn = Integer.valueOf(br.readLine());\n\t\t\twhile (n != 0) {\n\t\t\t\tm = Integer.valueOf(br.readLine());\n\t\t\t\tvertex = new int[n];\n\t\t\t\tedge = new Edge[m];\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tString s[] = br.readLine().split(\",\");\n\t\t\t\t\tedge[i] = new Edge(Integer.valueOf(s[0]), Integer.valueOf(s[1]), Integer.valueOf(s[2]));\n\t\t\t\t}\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tvertex[i] = i;\n\t\t\t\t}\n\t\t\t\tsort(edge, 0, m - 1);\n\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tif (vertex[edge[i].v1] != vertex[edge[i].v2]) {\n\t\t\t\t\t\tedge[i].mark = true;\n\t\t\t\t\t\tint num = vertex[edge[i].v2];\n\t\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\t\tif (vertex[j] == num) {\n\t\t\t\t\t\t\t\tvertex[j] = vertex[edge[i].v1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tint sum = 0;\n\t\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\t\tif (edge[i].mark) {\n\t\t\t\t\t\tsum += ((edge[i].weight - 100) / 100);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(sum);\n\n\t\t\t\tn = Integer.valueOf(br.readLine());\n\t\t\t}\n\t\t} catch (NumberFormatException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\n\tpublic static void sort(Edge edge[], int low, int high) {\n\t\tif (high <= low) {\n\t\t\treturn ;\n\t\t}\n\t\tint i = low;\n\t\tint j = high;\n\t\tint x = edge[(low + high) / 2].weight;\n\t\twhile (i <= j) {\n\t\t\twhile (edge[i].weight < x) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (x < edge[j].weight) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (i <= j) {\n\t\t\t\tEdge swap = new Edge(edge[i].v1, edge[i].v2, edge[i].weight);\n\t\t\t\tedge[i] = edge[j];\n\t\t\t\tedge[j] = swap;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tsort(edge, low, j);\n\t\t\tsort(edge, i, high);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tint[][] path;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine()) {\n\t\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint m = Integer.parseInt(sc.nextLine());\n\n\t\t\tpath = new int[m][4];\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tpath[i][j] = Integer.parseInt(nico[j]);\n\t\t\t\t}\n\t\t\t\tpath[i][2] = path[i][2] / 100 - 1;\n\t\t\t\tpath[i][3] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tboolean[] flag = new boolean[n];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tflag[path[0][0]] = true;\n\t\t\tflag[path[0][1]] = true;\n\t\t\tpath[0][3] = 1;\n\t\t\t\n\t\t\tint total = path[0][2];\n\t\t\t\n\t\t\tint marked = 2;\n\t\t\twhile (marked != n) {\n\t\t\t\tfor (int i = 1; i < path.length; i++) {\n\t\t\t\t\tif (flag[path[i][0]] != flag[path[i][1]]) {\n\t\t\t\t\t\tflag[path[i][0]] = true;\n\t\t\t\t\t\tflag[path[i][1]] = true;\n\t\t\t\t\t\ttotal = total + path[i][2];\n\t\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tif (path[i][3] == 0) {\n\t\t\t\t\tint max = i;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < path.length; j++) {\n\t\t\t\t\t\tif ((path[j][3] == 0) || (i == j)) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tint checknode = -1;\n\t\t\t\t\t\tif ((path[j][0] == path[i][0]) || (path[j][0] == path[i][1])) checknode = path[j][1];\n\t\t\t\t\t\telse if ((path[j][1] == path[i][0]) || (path[j][1] == path[i][1])) checknode = path[j][0];\n\t\t\t\t\t\tif (checknode == -1) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((path[max][2] < path[j][2]) && (check(checknode) >= 2)) max = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttotal = total + path[i][2] - path[max][2];\n\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\tpath[max][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n\t\n\tprivate int check(int index) {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (path[i][j] == index) ans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tint m = sc.nextInt();\n\t\t\tint[][] map = new int[m][3];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tmap[i][0] = Integer.valueOf(s[0]);\n\t\t\t\tmap[i][1] = Integer.valueOf(s[1]);\n\t\t\t\tmap[i][2] = Integer.valueOf(s[2]) - 100;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(map, new Comparator<int[]>(){\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn o1[2] - o2[2];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tboolean[][] f = new boolean[100][100];\n\t\t\tint sum = 0;\n\t\t\tArrayList<Integer> list = new ArrayList<Integer>();\n\t\t\tfor(int i=0;i<n;i++){\n\t\t\t\tlist.add(i);\n\t\t\t\tf[i][i] = true;\n\t\t\t}\n\t\t\t\n\t\t\tint p, q;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp = map[i][0];\n\t\t\t\tq = map[i][1];\n\t\t\t\tif(f[p][q]==false){\n\t\t\t\t\tsum += map[i][2];\n\t\t\t\t\tif(list.contains(p)==true) list.remove(list.indexOf(p));\n\t\t\t\t\tif(list.contains(q)==true) list.remove(list.indexOf(q));\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(f[j][p]==true) f[j][q] = true;\n\t\t\t\t\t\tif(f[j][q]==true) f[j][p] = true;\n\t\t\t\t\t\tif(f[p][j]==true) f[q][j] = true;\n\t\t\t\t\t\tif(f[q][j]==true) f[p][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(list.size()==0) break;\n\t\t\t}\n\t\t\tSystem.out.println(sum/100);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main {\n\t\n\tstatic class Lan implements Comparable<Lan>{\n\t\tint a, dis;\n\t\tLan(int a,int dis){\n\t\t\tthis.a=a;\n\t\t\tthis.dis=dis;\n\t\t}\n\t\tpublic int compareTo(Lan l) {\n\t\t\treturn this.dis-l.dis;\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\ttry(Scanner sc = new Scanner(System.in)){\n\t\t\twhile(sc.hasNext()) {\n\t\t\t\tint n=sc.nextInt();\n\t\t\t\tif(n==0) break;\n\t\t\t\tint m=sc.nextInt();\n\t\t\t\tPriorityQueue<Lan> pq=new PriorityQueue<Lan>();\n\t\t\t\tboolean [] visit=new boolean[n];\n\t\t\t\tint[][] lon=new int[n][n];\n\t\t\t\tint[] distance = new int[n];\n\t\t\t\tint INF=10000000;\n\t\t\t\tArrays.fill(distance, INF);\n\t\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\t\tString s=sc.next();\n\t\t\t\t\tString[] tokens=s.split(\",\");\n\t\t\t\t\tint a=Integer.parseInt(tokens[0]);\n\t\t\t\t\tint b=Integer.parseInt(tokens[1]);\n\t\t\t\t\tint d=Integer.parseInt(tokens[2]);\n\t\t\t\t\tlon[a][b]=lon[b][a]=d;\n\t\t\t\t}\n\t\t\t\tpq.add(new Lan(0, 0));\n\t\t\t\tint ans=0;\n\t\t\t\twhile(!pq.isEmpty()) {\n\t\t\t\t\tLan lan=pq.poll();\n\t\t\t\t\tif(visit[lan.a]) continue;\n\t\t\t\t\t//System.out.println(lan.a+\" \"+lan.dis);\n\t\t\t\t\tvisit[lan.a]=true;\n\t\t\t\t\tif(lan.dis>0)ans+=lan.dis/100-1;\n\t\t\t\t\tboolean tf=true;\n\t\t\t\t\tfor(int i=0; i<n; i++) {\n\t\t\t\t\t\tif(lon[lan.a][i]>0) {\n\t\t\t\t\t\t\tpq.add(new Lan(i, lon[lan.a][i]));\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tSystem.out.println(ans);\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int[][] edge;\n\tstatic int[] mincost;\n\tstatic boolean[] used;\n\tstatic int n, m;\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\t\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tif(n == 0)return false;\n\t\t\n\t\tm = sc.nextInt();\n\t\tedge = new int[n][n];\n\t\tmincost = new int[n];\n\t\tused = new boolean[n];\n\t\tfor(int[] format : edge)Arrays.fill(format, Integer.MAX_VALUE);\n\t\tArrays.fill(mincost, Integer.MAX_VALUE);\n\t\tArrays.fill(used, false);\n\t\t\n\t\tfor(int i = 0; i < m; i++){\n\t\t\tString[] input = sc.next().split(\",\");\n\t\t\tedge[Integer.parseInt(input[0])][Integer.parseInt(input[1])] = (Integer.parseInt(input[2])-1)/100;\n\t\t\tedge[Integer.parseInt(input[1])][Integer.parseInt(input[0])] = (Integer.parseInt(input[2])-1)/100;\n\t\t}\n\t\t\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\t\t\n\t\twhile(true){\n\t\t\tint v = -1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(!used[i] && (v == -1 || mincost[i] < mincost[v]))v = i;\n\t\t\t}\n\t\t\t\n\t\t\tif(v == -1)break;\n\t\t\tused[v] = true;\n\t\t\tres += mincost[v];\n\t\t\t\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmincost[i] = Math.min(mincost[i], edge[v][i]);\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic Edge[] es;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tV = n;\n\t\t\tint m = sc.nextInt();\n\t\t\tE = m;\n\t\t\tes = new Edge[E];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tString[] tmp = sc.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(tmp[0]);\n\t\t\t\tint b = Integer.parseInt(tmp[1]);\n\t\t\t\tint c = Integer.parseInt(tmp[2]);\n\t\t\t\t\n\t\t\t\tes[i] = new Edge(a,b,c);\n\t\t\t}\n\t\t\t\n\t\t\tint ret = kruskal();\n\t\t\t\n\t\t\tret -=  (n-1)*100;\n\t\t\tSystem.out.println(ret / 100);\n\t\t}\n\t}\n\t\n\tpublic static int kruskal() {\n\t\tArrays.sort(es,new Comp());\n\t\tinit(V);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tEdge e = es[i];\n\t\t\tif(!same(e.u,e.v)) {\n\t\t\t\tunite(e.u,e.v);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int[] par ;\n\tstatic int[] rank ;\n\t\n\tstatic void init(int n) {\n\t\tpar = new int[V];\n\t\trank = new int[V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tstatic int find(int x) {\n\t\tif(par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tstatic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\t\n\n}\n\n\nclass Edge {\n\tint u;\n\tint v;\n\tint cost;\n\tEdge(int a, int b, int c) {\n\t\tu = a;\n\t\tv = b;\n\t\tcost = c;\n\t}\n}\n\nclass Comp implements Comparator<Edge> {\n\n\tpublic int compare(Edge o1, Edge o2) {\n\t\treturn o1.cost - o2.cost;\n\t}\n\t\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \treturn (int)nextLong();\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main{\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint m = sc.nextInt();\n\n\t\t\tArrayList<ArrayList<Edge>> graph = new ArrayList<ArrayList<Edge>>();\n\t\t\tfor(int i=0;i<n;i++) graph.add(new ArrayList<Edge>());\n\n\t\t\twhile(n-- > 0){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(s[0]);\n\t\t\t\tint b = Integer.parseInt(s[1]);\n\t\t\t\tint cost = Integer.parseInt(s[2]) / 100 - 1;\n\n\t\t\t\tgraph.get(a).add(new Edge(b,cost));\n\t\t\t\tgraph.get(b).add(new Edge(a,cost));\n\t\t\t}\n\n\t\t\tSystem.out.println(prim(graph));\n\t\t}\n\t}\n\n\tprivate static int prim(ArrayList<ArrayList<Edge>> graph){\n\t\tPriorityQueue<Edge> open = new PriorityQueue<Edge>();\n\t\tHashSet<Integer> closed = new HashSet<Integer>();\n\t\tint total = 0;\n\n\t\topen.add(new Edge(0,0));\n\t\twhile(closed.size() != graph.size()){\n\t\t\tEdge st = open.poll();\n\t\t\tif(closed.contains(st.to)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tclosed.add(st.to);\n\t\t\ttotal += st.cost;\n\t\t\tfor(Edge e : graph.get(st.to)){\n\t\t\t\tif(!closed.contains(e.to)){\n\t\t\t\t\topen.add(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn total;\n\t}\n}\n\nclass Edge implements Comparable<Edge>{\n\tint to, cost;\n\n\tEdge(int to,int cost){\n\t\tthis.to = to;\n\t\tthis.cost = cost;\n\t}\n\n\tpublic int compareTo(Edge e){\n\t\treturn this.cost - e.cost;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] getAdjecentListWithCounter(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj, int nodes, int s) {\n        final int[] d = new int[nodes];\n        Arrays.fill(d, 0);//到達フラグ\n        // 未到達な行き先->距離優先\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return (d[a[0]] != d[b[0]]) ? (d[a[0]] - d[b[0]]) : (a[1] - b[1]);\n            }\n        });\n        // 適当に始点を決める\n        d[s] = 1;\n        // 枝集合追加\n        for (int[] e : adj[s]) {\n            ts.add(e);\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[0]] == 1)break;\n            d[ne[0]] = 1;\n            w += ne[1];\n            // 枝集合追加\n            for (int[] e : adj[ne[0]]) {\n                ts.add(e);\n            }\n        }\n        return w;\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = Math.max(sc.nextInt() / 100 - 1,0);\n            }\n            int[][][] g = getAdjecentListWithCounter(n, f, t, w);\n            System.out.println(prim(g, n, 0));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Edge implements Comparable<Edge> {\n\t\n\tpublic int u, v, w;\n\tEdge(int u, int v, int w) {\n\t\tthis.u = u;\n\t\tthis.v = v;\n\t\tthis.w = w;\n\t}\n\t\n\t@Override\n\tpublic int compareTo(Edge e) {\n\t\treturn this.w - e.w;\n\t}\n\t\n\tpublic String toString() {\n\t\treturn this.u + \" \" + this.v + \" \" + this.w;\n\t}\n}\n\npublic class Main {\n\tstatic Scanner sc = new Scanner(System.in);\n\tstatic int n, m;\n\tstatic int[] parent, rank;\n\tstatic Edge[] es;\n\t\n\tpublic static void main(String[] args) {\n\t\twhile(read()){\n\t\t\tsolve();\n\t\t}\n\t}\n\n\tstatic boolean read(){\n\t\tn = sc.nextInt();\n\t\tif(n == 0)return false;\n\t\tm = sc.nextInt();\n\t\tes = new Edge[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString[] ps = sc.next().split(\",\");\n\t\t\tes[i] = new Edge(Integer.parseInt(ps[0]), Integer.parseInt(ps[1]), Integer.parseInt(ps[2]));\n\t\t}\n\t\tparent = new int[n];\n\t\trank = new int[n];\n\t\treturn true;\n\t}\n\t\n\tstatic void solve(){\n\t\tArrays.sort(es);\n\t\tint res = 0;\n\t\tinit(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tEdge e = es[i];\n\t\t\tif (!same(e.u, e.v)) {\n\t\t\t\tunite(e.u, e.v);\n\t\t\t\tres += (e.w / 100) - 1;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(res);\n\t}\n\n\tstatic void init(int n){\n\t\tfor(int i = 0; i < n; i++){\n\t\t\tparent[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tstatic int find(int x){\n\t\tif(parent[x] == x){\n\t\t\treturn x;\n\t\t}else{\n\t\t\treturn parent[x] = find(parent[x]);\n\t\t}\n\t}\n\t\n\tstatic void unite(int x, int y){\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y)return;\n\t\t\n\t\tif(rank[x] < rank[y]){\n\t\t\tparent[x] = y;\n\t\t}else{\n\t\t\tparent[y] = x;\n\t\t\tif(rank[x] == rank[y])rank[x]++;\n\t\t}\n\t}\n\t\n\tstatic boolean same(int x, int y){\n\t\treturn find(x) == find(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        Prim prim = new Prim(V, E);\n\n        for (int i = 0; i < E; i++) {\n            String line = sc.next();\n            String[] data = line.split(\",\");\n            int s = Integer.valueOf(data[0]);\n            int t = Integer.valueOf(data[1]);\n            int w = Integer.valueOf(data[2]) / 100 - 1;\n            prim.set(s, t, w);\n            prim.set(t, s, w);\n        }\n\n        int res = prim.run();\n        System.out.println(res);\n    }\n\n    private static class Prim {\n        int V, E;\n        ArrayList<ArrayList<Edge>> edges;\n\n        Prim(int V, int E) {\n            this.V = V;\n            this.E = E;\n            edges = new ArrayList<>();\n            for (int i = 0; i < V; i++) {\n                edges.add(new ArrayList<>());\n            }\n        }\n\n        void set(int from, int to, int cost) {\n            edges.get(from).add(new Edge(to, cost));\n        }\n\n        int run() {\n            boolean[] done = new boolean[V];\n            Arrays.fill(done, false);\n            Queue<Edge> q = new PriorityQueue<>();\n            q.add(new Edge(0, 0));\n            int costSum = 0;\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                if (done[e.t]) {\n                    continue;\n                }\n                done[e.t] = true;\n                costSum += e.w;\n                q.addAll(edges.get(e.t));\n            }\n            return costSum;\n        }\n\n    }\n\n    public static class Edge implements Comparable<Edge> {\n        public int t, w;\n\n        Edge(int t, int w) {\n            this.t = t;\n            this.w = w;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return this.w - o.w;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\tint n, m, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tn = Integer.valueOf(string);\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\ta = Integer.valueOf(string.split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(string.split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(string.split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t};\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\treader.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] getAdjecentListWithCounter(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj, int nodes, int s) {\n        final int[] d = new int[nodes]; Arrays.fill(d, 0);//到達フラグ\n        // 未到達な行き先->距離優先\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return (d[a[0]] != d[b[0]]) ? (d[a[0]] - d[b[0]]) : (a[1] - b[1]);\n            }\n        });\n        // 適当に始点を決める\n        d[s] = 1;\n        // 枝集合追加\n        for (int[] e : adj[s]) {\n            ts.add(e);\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[0]] == 1)break;\n            d[ne[0]] = 1;\n            w += ne[1];\n            // 枝集合追加\n            for (int[] e : adj[ne[0]]) {\n                ts.add(e);\n            }\n        }\n        return w;\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = (sc.nextInt() - 1) / 100;\n            }\n            sc.nextInt();\n            int[][][] g = getAdjecentListWithCounter(n, f, t, w);\n            System.out.println(prim(g, n, 0));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic Edge[] es;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tV = n;\n\t\t\tint m = sc.nextInt();\n\t\t\tE = m;\n\t\t\tes = new Edge[E];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tString[] tmp = sc.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(tmp[0]);\n\t\t\t\tint b = Integer.parseInt(tmp[1]);\n\t\t\t\tint c = Integer.parseInt(tmp[2]);\n\t\t\t\t\n\t\t\t\tes[i] = new Edge(a,b,c);\n\t\t\t}\n\t\t\t\n\t\t\tint ret = kruskal();\n\t\t\t\n\t\t\tret -=  (n-1)*100;\n\t\t\tout.println(ret / 100);\n\t\t}\n\t}\n\t\n\tpublic static int kruskal() {\n\t\tArrays.sort(es,new Comp());\n\t\tinit(V);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tEdge e = es[i];\n\t\t\tif(!same(e.u,e.v)) {\n\t\t\t\tunite(e.u,e.v);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int[] par ;\n\tstatic int[] rank ;\n\t\n\tstatic void init(int n) {\n\t\tpar = new int[V];\n\t\trank = new int[V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tstatic int find(int x) {\n\t\tif(par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tstatic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\t\n\n}\n\n\nclass Edge {\n\tint u;\n\tint v;\n\tint cost;\n\tEdge(int a, int b, int c) {\n\t\tu = a;\n\t\tv = b;\n\t\tcost = c;\n\t}\n}\n\nclass Comp implements Comparator<Edge> {\n\n\tpublic int compare(Edge o1, Edge o2) {\n\t\treturn o1.cost - o2.cost;\n\t}\n\t\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \treturn (int)nextLong();\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=Integer.MAX_VALUE;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt(),m=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n][n];\n\t\t\tint mincost[]=new int[n];//頂点iへの辺の最小コスト\n\t\t\tboolean use[]=new boolean[n];//頂点iが部分全域木に含まれているか\n\t\t\tint total=0;//answer\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tArrays.fill(mincost, M);\n\t\t\tArrays.fill(use, false);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString str[]=in.next().split(\",\");\n\t\t\t\tint s=Integer.valueOf(str[0]);\n\t\t\t\tint t=Integer.valueOf(str[1]);\n\t\t\t\tint c=Integer.valueOf(str[2]);\n\t\t\t\tcost[s][t]=c;\n\t\t\t\tcost[t][s]=c;\n\t\t\t}\n\t\t\tmincost[0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint v=-1;//追加する頂点\t\t\t\t\n\t\t\t\tfor(int j=0;j<n;j++)//追加する頂点を探す\n\t\t\t\t\tif(!use[j]&&(v==-1||mincost[v]>mincost[j]))\n\t\t\t\t\t\tv=j;\n\t\t\t\tif(v==-1) //全ての頂点を選んだ\n\t\t\t\t\tbreak;\n\t\t\t\tif(mincost[v]!=0)\n\t\t\t\ttotal+=((mincost[v]/100)-1);\n\t\t\t\tuse[v]=true;\n\n\t\t\t\tfor(int j=0;j<n;j++)//追加した頂点と繋がっている辺を調べ最小コストを更新\n\t\t\t\t{\n\t\t\t\t\tif(!use[j]&&mincost[j]>cost[v][j])\n\t\t\t\t\t\tmincost[j]=cost[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scan.nextInt();\n\t\t\tint[][] cost = new int[n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(str[0]);\n\t\t\t\tint b = Integer.parseInt(str[1]);\n\t\t\t\tint c = Integer.parseInt(str[2]);\n\t\t\t\tcost[a][b] = c;\n\t\t\t\tcost[b][a] = c;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tint min = 0;\n\t\t\tfor(int i = 1;i < n;i++){\n\t\t\t\tmin = cost[0][i];\n\t\t\t\tfor(int j = 0;j < i;j++){\n\t\t\t\t\tmin = (min > cost[j][i])?cost[j][i]:min;\n\t\t\t\t}\n\t\t\t\tcount += min/100 - 1;\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt();\n\t\t\tsc.useDelimiter(\",|\\r\\n\");\n\t\t\tEdge[] es = new Edge[m];\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tes[i] = new Edge(s, e, d);\n\t\t\t}\n\t\t\tArrays.sort(es, new Comparator<Edge>() {\n\t\t\t\tpublic int compare(Edge a, Edge b) {\n\t\t\t\t\treturn a.d - b.d;\n\t\t\t\t}\n\t\t\t});\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint a = es[i].s;\n\t\t\t\tint b = es[i].e;\n\t\t\t\tint d = es[i].d;\n\t\t\t\tif(!uf.same(a,b)){\n\t\t\t\t\tuf.unite(a,b);\n\t\t\t\t\tsum+=d/100-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\nclass Edge {\n\tpublic int s;\n\tpublic int e;\n\tpublic int d;\n\n\tEdge(int s, int e, int d) {\n\t\tthis.s = s;\n\t\tthis.e = e;\n\t\tthis.d = d;\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic int rank[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\n\tpublic int find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x] = find(par[x]);\n\t}\n\n\tpublic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn;\n\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\n\tpublic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\nimport java.util.regex.Pattern;\n\n// Java8\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tvoid run() throws Exception {\n\t\tsc.useDelimiter(Pattern.compile(\"(\\\\s|,)+\"));\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\tint m = sc.nextInt();\n\t\t\tEdge[] es = new Edge[m];\n\t\t\tfor(int i=0; i<m; i++) {\n\t\t\t\tint a = sc.nextInt();\n\t\t\t\tint b = sc.nextInt();\n\t\t\t\tint d = sc.nextInt() / 100 - 1;\n\t\t\t\tes[i] = new Edge(a, b, d);\n\t\t\t}\n\t\t\tArrays.sort(es);\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tint cost = 0;\n\t\t\tfor(Edge e : es) {\n\t\t\t\tif(!uf.same(e.a, e.b)) {\n\t\t\t\t\tuf.unite(e.a, e.b);\n\t\t\t\t\tcost += e.d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(cost);\n\t\t}\n\t}\n}\nclass Edge implements Comparable<Edge> {\n\tint a;\n\tint b;\n\tint d;\n\tEdge(int _a, int _b, int _d) {\n\t\ta = _a;\n\t\tb = _b;\n\t\td = _d;\n\t}\n\n\t@Override\n\tpublic int compareTo(Edge o)\n\t{\n\t\treturn Integer.compare(this.d, o.d);\n\t}\n}\nclass UnionFind {\n\tint size;\n\tint[] pars;\n\n\tUnionFind(int n) {\n\t\tsize = n;\n\t\tpars = new int[n];\n\t\tArrays.fill(pars, -1);\n\t}\n\n\tint root(int x) {\n\t\treturn pars[x]<0 ? x : (pars[x] = root(pars[x]));\n\t}\n\n\tboolean same(int x, int y) {\n\t\treturn root(x) == root(y);\n\t}\n\n\tvoid unite(int x, int y) {\n\t\tpars[root(x)] = root(y);\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\n\npublic class Main {\n\n\t/**\n\t * @param args\n\t * @throws IOException \n\t * @throws NumberFormatException \n\t */\n\tpublic static void main(String[] args) throws NumberFormatException, IOException {\n\t\t// TODO Auto-generated method stub\n\t\tBufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n\t\t\n\t\twhile(true){\n\t\t\tint n = Integer.parseInt(br.readLine());\n\t\t\t\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint m = Integer.parseInt(br.readLine());\n\t\t\tint[][] matrix = new int[m][m];\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tArrays.fill(matrix[i], -1);\n\t\t\t}\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString[] tmpArray = br.readLine().split(\",\");\n\t\t\t\tint a = Integer.parseInt(tmpArray[0]);\n\t\t\t\tint b = Integer.parseInt(tmpArray[1]);\n\t\t\t\tint d = Integer.parseInt(tmpArray[2]) - 100;\n\t\t\t\t\n\t\t\t\tmatrix[a][b] = d;\n\t\t\t\tmatrix[b][a] = d;\n\t\t\t}\n\t\t\t\n\t\t\tint sum = MyPlim(matrix);\n\t\t\tSystem.out.println(sum/100);\n\t\t}\n\t}\n\n\tstatic int MyPlim(int[][] matrix){\n        int result = 0;\n        int n = matrix[0].length;\n         \n        int[] visited = new int[n];\n        Arrays.fill(visited, 0);\n         \n        visited[0] = 1;\n        int checked = 1;\n         \n        while(true){\n            int min = Integer.MAX_VALUE;\n            int minI = -1;\n            int minJ = -1;\n            for(int i = 0; i < n; i++){\n                if(visited[i] == 0){\n                    continue;\n                }\n                for(int j = 0; j < n; j++){\n                    if(min > matrix[i][j] && matrix[i][j] >= 0 && visited[j] == 0){\n                        min = matrix[i][j];\n                        minI = i;\n                        minJ = j;\n                    }\n                }\n            }\n             \n            result += min;\n//            System.out.println(\"(\"+minI+\",\"+minJ+\") added distance\"+min);\n            checked++;\n            visited[minI] = 1;\n            visited[minJ] = 1;\n            matrix[minI][minJ] = -1;\n            matrix[minJ][minI] = -1;\n             \n            if(checked == n){\n                break;\n            }\n        }\n         \n        return result;\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.NoSuchElementException;\nimport java.util.PriorityQueue;\npublic class Main {\n\tfinal int INF = (int)1e9 + 7;\n\tint N,M;\n\tint[] a,b,d;\n\tArrayList<Integer>[] graph;\n\tint[][] cost;\n\tprivate class P implements Comparable<P>{\n\t\tint first,second;\n\t\tpublic P(int first,int second){\n\t\t\tthis.first = first;\n\t\t\tthis.second = second;\n\t\t}\n\t\tpublic int compareTo(P p){\n\t\t\tif(this.first == p.first){\n\t\t\t\treturn this.second - p.second;\n\t\t\t}\n\t\t\treturn this.first - p.first;\n\t\t}\n\t}\n\n\tpublic int dijkstra(int s){\n\t\tboolean[] used = new boolean[N];\n\t\tint ret = 0;\n\t\tPriorityQueue<P> pq = new PriorityQueue<P>();\n\t\tpq.add(new P(0,s));\n\t\twhile(pq.size() > 0){\n\t\t\tP p = pq.poll();\n\t\t\tif(used[p.second])continue;\n\t\t\tused[p.second] = true;\n\t\t\tret+=p.first;\n\t\t\tfor(int next : graph[p.second]){\n\t\t\t\tpq.add(new P(cost[p.second][next],next));\n\t\t\t}\n\t\t}\n\t\treturn ret;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic void solve() {\n\t\twhile(true){\n\t\t\tN = nextInt();\n\n\t\t\tif(N == 0)break;\n\n\t\t\tM = nextInt();\n\t\t\ta = new int[M];\n\t\t\tb = new int[M];\n\t\t\td = new int[M];\n\t\t\tgraph = new ArrayList[N];\n\t\t\tcost = new int[N][N];\n\t\t\tfor(int i = 0;i < N;i++){\n\t\t\t\tgraph[i] = new ArrayList<Integer>();\n\t\t\t}\n\t\t\tfor(int i = 0;i < M;i++){\n\t\t\t\tString[] line = next().split(\",\");\n\t\t\t\ta[i] = Integer.parseInt(line[0]);\n\t\t\t\tb[i] = Integer.parseInt(line[1]);\n\t\t\t\td[i] = (Integer.parseInt(line[2]) / 100) - 1;\n\t\t\t\tcost[a[i]][b[i]] = d[i];\n\t\t\t\tcost[b[i]][a[i]] = d[i];\n\t\t\t\tgraph[a[i]].add(b[i]);\n\t\t\t\tgraph[b[i]].add(a[i]);\n\t\t\t}\n\t\t\tout.println(dijkstra(0));\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tout.flush();\n\t\tnew Main().solve();\n\t\tout.close();\n\t}\n\n\t/* Input */\n\tprivate static final InputStream in = System.in;\n\tprivate static final PrintWriter out = new PrintWriter(System.out);\n\tprivate final byte[] buffer = new byte[2048];\n\tprivate int p = 0;\n\tprivate int buflen = 0;\n\n\tprivate boolean hasNextByte() {\n\t\tif (p < buflen)\n\t\t\treturn true;\n\t\tp = 0;\n\t\ttry {\n\t\t\tbuflen = in.read(buffer);\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tif (buflen <= 0)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\tpublic boolean hasNext() {\n\t\twhile (hasNextByte() && !isPrint(buffer[p])) {\n\t\t\tp++;\n\t\t}\n\t\treturn hasNextByte();\n\t}\n\n\tprivate boolean isPrint(int ch) {\n\t\tif (ch >= '!' && ch <= '~')\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\n\tprivate int nextByte() {\n\t\tif (!hasNextByte())\n\t\t\treturn -1;\n\t\treturn buffer[p++];\n\t}\n\n\tpublic String next() {\n\t\tif (!hasNext())\n\t\t\tthrow new NoSuchElementException();\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint b = -1;\n\t\twhile (isPrint((b = nextByte()))) {\n\t\t\tsb.appendCodePoint(b);\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tpublic int nextInt() {\n\t\treturn Integer.parseInt(next());\n\t}\n\n\tpublic long nextLong() {\n\t\treturn Long.parseLong(next());\n\t}\n\n\tpublic double nextDouble() {\n\t\treturn Double.parseDouble(next());\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\tint n, m, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tn = Integer.valueOf(string);\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\ta = Integer.valueOf(string.split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(string.split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(string.split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\treader.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader br = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tpoint = 0;\n\n\t\twhile ((point = parseNum()) != 0) {\n\t\t\tint[][]\tmap     = new int[point][point];\n\t\t\tint\t\troute   = parseNum();\n\t\t\tint\t\tlantern = 0;\n\t\t\tfor (int i = 0; i < point; i++) {\n\t\t\t\tfor (int j = 0; j < point; j++) {\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < route; n++) {\n\t\t\t\tint[]\tdist = parseDist();\n\t\t\t\tmap[dist[0]][dist[1]] = dist[2];\n\t\t\t\tmap[dist[1]][dist[0]] = dist[2];\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < point; n++) {\n\t\t\t\tint\ttmp = solve(1 << n, n, map);\n\t\t\t\tlantern = (lantern == 0) ? tmp : Math.min(tmp, lantern);\n\t\t\t}\n\t\t\tSystem.out.println(lantern);\n\t\t}\n\t}\n\n\tprivate static int solve(int cbit, int start, int[][] map) {\n\t\tint\t\tfbit    = 0;\n\t\tint\t\tlantern = 0;\n\t\tint\t\trest    = 0;\n\t\tboolean\tcomp    = true;\n\n\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\tif ((cbit & 1 << n) == 0) {\n\t\t\t\tif (map[start][n] != -1) {\n\t\t\t\t\tfbit |= 1 << n;\n\t\t\t\t\tlantern += map[start][n];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcomp = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!comp) {\n\t\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\t\tif (map[start][n] != -1 && (fbit & 1 << n) != 0) {\n\t\t\t\t\tint\ttmp = solve(cbit | fbit, n, map);\n\t\t\t\t\tif (tmp != 0) {\n\t\t\t\t\t\trest = (rest == 0) ? tmp : Math.min(tmp, rest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn lantern + rest;\n\t}\n\n\tprivate static int[] parseDist() {\n\t\tint[]\tdist  = null;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tString[]\tsplit = strIn.split(\",\");\n\t\t\tdist    = new int[3];\n\t\t\tdist[0] = Integer.parseInt(split[0]); \n\t\t\tdist[1] = Integer.parseInt(split[1]); \n\t\t\tdist[2] = Integer.parseInt(split[2]) / 100 - 1; \n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tnum   = 0;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(strIn); \n\t\t}\n\t\t\n\t\treturn num;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstrNum = null;\n\n\t\ttry {\n\t\t\tString line = br.readLine();\n\t\t\tif (line != null) {\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tstrNum = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn strNum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Scanner;\n\npublic class Main{\n\n    static class Edge implements Comparable<Edge>{\n        public int s;\n        public int t;\n        public int x;\n        public Edge(int s, int t, int x) {\n            this.s = s;\n            this.t = t;\n            this.x = x;\n        }\n        public int compareTo(Edge o) {\n            return x-o.x;\n        }\n    }\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        while(true){\n            int n = sc.nextInt();\n            if(n==0)break;\n            int m = sc.nextInt();\n            PriorityQueue<Edge> q = new PriorityQueue<Edge>();\n            for(int i=0;i<m;i++){\n                String[] s = sc.next().split(\",\");\n                q.add(new Edge(Integer.parseInt(s[0]), Integer.parseInt(s[1]), Integer.parseInt(s[2])/100-1));\n            }\n            UnionFind union = new UnionFind(n);\n            int c = 0;\n            while(union.num>1){\n                Edge e = q.poll();\n                if(!union.find(e.s, e.t)){\n                    union.union(e.s, e.t);\n                    c+=e.x;\n                }\n            }\n            System.out.println(c);\n        }\n    }\n\n    static class UnionFind {\n        final int[] tree;\n        int num;\n        public UnionFind(int n) {\n            this.tree = new int[n];\n            Arrays.fill(tree, -1);\n            num=n;\n        }\n\n        // merge the set contains x and the set contains y\n        void union(int x, int y) {\n            x = root(x);\n            y = root(y);\n            if(x != y) {\n                if(tree[x] < tree[y]) {\n                    x ^= y; y ^= x; x^= y;\n                }\n                tree[x] += tree[y];\n                tree[y] = x;\n                num--;\n            }\n        }\n        // decide if x and y belong to the same set\n        boolean find(int x, int y) {\n            return root(x) == root(y);\n        }\n        int root(int x) {\n            return tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n        }\n        // return size of the set contains x\n        int size(int x) {\n            return -tree[root(x)];\n        }\n        // return the number of sets\n        int getNum() {\n            return num;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint ans = 0;\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tint V = sc.nextInt();\n\t\t\tif (V==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint E = sc.nextInt();\n\t\t\tEdge[] G = new Edge[E];\n\t\t\tfor(int i=0;i<E;i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tint u = Integer.parseInt(s[0]);\n\t\t\t\tint v = Integer.parseInt(s[1]);\n\t\t\t\tint c = Integer.parseInt(s[2])/100-1;\n\t\t\t\tG[i] = new Edge(u,v,c);\n\t\t\t}\n\t\t\tArrays.sort(G);\n\t\t\tUnionFind unionfind = new UnionFind(E);\n\t\t\tfor(int i=0;i<E;i++) {\n\t\t\t\tif (!unionfind.isConnected(G[i].u, G[i].v)) {\n\t\t\t\t\t//System.out.println(unionfind);\n\t\t\t\t\tunionfind.union(G[i].u, G[i].v);\n\t\t\t\t\t//System.out.println(unionfind);\n\t\t\t\t\tans += G[i].cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\nclass Edge implements Comparable<Edge>{\n\tint u;\n\tint v;\n\tint cost;\n\tpublic Edge(int u,int v,int cost) {\n\t\tthis.u = u;\n\t\tthis.v = v;\n\t\tthis.cost = cost;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn this.cost-o.cost;\n\t}\n}\nclass UnionFind {\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tpublic void union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tprivate int root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(data);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.BufferedReader;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\n \n\npublic class Main{\n          \n     \n     public static void main(String args[]){\n         BufferedReader br = new BufferedReader(new InputStreamReader(System.in));\n         \n         try{\n             String line;\n             \n            while((line=br.readLine())!= null){if(line.isEmpty())break;\n               int siseki = Integer.parseInt(line);if(siseki==0)break;\n               line=br.readLine();\n               int mitikazu = Integer.parseInt(line);\n               ArrayList<miti> mitiLis=new ArrayList<miti>();\n               for(int i=0; i<mitikazu; i++){\n                   line=br.readLine();String[] spl=line.split(\",\");\n                   int a=Integer.parseInt(spl[0]),b=Integer.parseInt(spl[1]),\n                           kyori=Integer.parseInt(spl[2]);\n                   mitiLis.add(new miti(a,b,kyori/100-1));\n               }\n                System.out.println(chochin(mitiLis,mitikazu,siseki));\n            }br.close();\n         }catch(Exception e){e.printStackTrace();}         \n     }  \n     static int chochin(ArrayList<miti> mitiL, int mitiN, int kyotenN){\n         int min = 3000000;\n         boolean cover[] = new boolean[kyotenN];\n         for(int i=0; i<Math.pow(2, mitiN);i++){\n             cover= new boolean[kyotenN];\n             int i_copy=i;\n             int choN=0;\n             for(int mitiC=0; mitiC < mitiN; mitiC++){\n                 if(i_copy%2==1){//selected\n                     cover[mitiL.get(mitiC).start]=true;\n                     cover[mitiL.get(mitiC).end]=true;\n                     choN+=mitiL.get(mitiC).tyotinN;\n                 }\n                 i_copy /=2;\n             }\n             if(allCover(cover)){if(min>choN)min=choN;}\n             \n         } \n         return min;\n     }\n     static boolean allCover(boolean[] bools){\n         boolean bool = true;\n         for(int i=0; i<bools.length; i++){\n             bool = bool&&bools[i];\n         }return bool;\n     }\n}\n  class miti{\n      int start;\n      int end;\n      int tyotinN;\n      miti(int s, int e, int tyotin){\n          this.start=s; this.end=e; this.tyotinN=tyotin;\n      }\n  }"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nimport java.lang.*;\n\nimport java.math.*;\n\n\n\npublic class Main {\n\n\tScanner sc = new Scanner(System.in);\n\n\n\n\tvoid run() {\n\n\t\tfor (;;) {\n\n\t\t\tint n = sc.nextInt();\n\n\t\t\tif (n == 0)\n\n\t\t\t\tbreak;\n\n\t\t\tint m = sc.nextInt();\n\n\t\t\tint[][] cost = new int[n][n];\n\n\t\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\t\tArrays.fill(cost[i], Integer.MAX_VALUE);\n\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\n\t\t\t\tString buffer;\n\n\t\t\t\tfor (buffer = sc.nextLine(); buffer.length() == 0; buffer = sc\n\n\t\t\t\t\t\t.nextLine())\n\n\t\t\t\t\t;\n\n\t\t\t\tScanner in = new Scanner(buffer.replace(',', ' '));\n\n\t\t\t\tint from = in.nextInt();\n\n\t\t\t\tint to = in.nextInt();\n\n\t\t\t\tint c = in.nextInt() / 100 - 1;\n\n\t\t\t\tcost[from][to] = cost[to][from] = Math.min(c, cost[from][to]);\n\n\t\t\t}\n\n\t\t\tboolean[] end = new boolean[n];\n\n\t\t\tend[0] = true;\n\n\t\t\tint sum =0;\n\n\t\t\tfor (;;) {\n\n\t\t\t\tint un = 0;\n\n\t\t\t\tint min = Integer.MAX_VALUE;\n\n\t\t\t\tint mini = 0;\n\n\t\t\t\tint minj = 0;\n\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\n\t\t\t\t\tif (end[i])\n\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\tun++;\n\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\n\t\t\t\t\t\tif (!end[j])\n\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\tif(min > cost[i][j]){\n\n\t\t\t\t\t\t\tmini=i;\n\n\t\t\t\t\t\t\tminj=j;\n\n\t\t\t\t\t\t\tmin = cost[i][j];\n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (un == 0)\n\n\t\t\t\t\tbreak;\n\n\t\t\t\tsum += min;\n\n\t\t\t\tend[mini] = true;\n\n\t\t\t}\n\n\t\t\tSystem.out.println(sum);\n\n\t\t}\n\n\n\n\t}\n\n\n\n\tpublic static void main(String[] args) {\n\n\t\tMain m = new Main();\n\n\t\tm.run();\n\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "/**\n * \n */\nimport java.util.*;\n/**\n * @author akira\n *\n */\nclass Main {\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO 自動生成されたメソッド・スタブ\n\t\tScanner scan = new Scanner(System.in);\n\t\tHashSet<Integer> set = new HashSet<Integer>();\n\t\tint n, m;\n\t\twhile(true){\n\t\t\tn = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint[][] edge = new int[n][n];\n\t\t\tm = scan.nextInt();\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tedge[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tscan.nextLine();\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString str = scan.nextLine();\n\t\t\t\tint a, b, d;\n\t\t\t\ta = Integer.parseInt(str.substring(0,str.indexOf(\",\")));\n\t\t\t\tstr = str.substring(str.indexOf(\",\") + 1,str.length());\n\t\t\t\tb = Integer.parseInt(str.substring(0,str.indexOf(\",\")));\n\t\t\t\tstr = str.substring(str.indexOf(\",\") + 1,str.length());\n\t\t\t\td = Integer.parseInt(str);\n\t\t\t\tedge[a][b] = d;\n\t\t\t\tedge[b][a] = d;\n\t\t\t}\n\t\t\tset.clear();\n\t\t\tint[] mindis = new int[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tmindis[i] = edge[0][i];\n\t\t\t}\n\t\t\tset.add(0);\n\t\t\tint ans = 0;\n\t\t\twhile(set.size() < n){\n\t\t\t\tint id = -1;\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tif(!set.contains(i) && mindis[i] != -1 && (id == -1 || mindis[i] < mindis[id])){\n\t\t\t\t\t\tid = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tset.add(id);\n\t\t\t\tans += mindis[id] / 100 - 1;\n\t\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\t\tif(mindis[i] == -1 || edge[id][i] == -1){\n\t\t\t\t\t\tmindis[i] = Math.max(edge[id][i],mindis[i]);\n\t\t\t\t\t}else if(edge[id][i] != -1){\n\t\t\t\t\t\tmindis[i] = Math.min(edge[id][i],mindis[i]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(\"\" + ans);\n\t\t}\n\t}\n\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\tint n, m, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tn = Integer.valueOf(string);\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\ta = Integer.valueOf(string.split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(string.split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(string.split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t};\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\treader.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tstatic class Edge {\n\t\tint v1, v2;\n\t\tint weight;\n\t\tboolean mark;\n\n\t\tEdge (int v1, int v2, int weight) {\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.weight = weight;\n\t\t\tthis.mark = false;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint vertex[];\n\t\tEdge edge[];\n\t\tTreeSet<Integer> set[];\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\tm = sc.nextInt();\n\t\t\tset = new TreeSet[n];\n\t\t\tvertex = new int[n];\n\t\t\tedge = new Edge[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tedge[i] = new Edge(Integer.valueOf(s[0]), Integer.valueOf(s[1]), Integer.valueOf(s[2]));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tset[i] = new TreeSet();\n\t\t\t\tset[i].add(i);\n\t\t\t\tvertex[i] = i;\n\t\t\t}\n\t\t\tsort(edge, 0, m - 1);\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (vertex[edge[i].v1] != vertex[edge[i].v2]) {\n\t\t\t\t\tedge[i].mark = true;\n\t\t\t\t\tint num1 = vertex[edge[i].v1];\n\t\t\t\t\tint num2 = vertex[edge[i].v2];\n\t\t\t\t\tset[num1].addAll(set[num2]);\n\t\t\t\t\twhile (!set[num2].isEmpty()) {\n\t\t\t\t\t\tvertex[set[num2].first()] = num1;\n\t\t\t\t\t\tset[num2].remove(set[num2].first());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (edge[i].mark) {\n\t\t\t\t\tsum += ((edge[i].weight - 100) / 100);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static void sort(Edge edge[], int low, int high) {\n\t\tif (high <= low) {\n\t\t\treturn ;\n\t\t}\n\t\tint i = low;\n\t\tint j = high;\n\t\tint x = edge[(low + high) / 2].weight;\n\t\twhile (i <= j) {\n\t\t\twhile (edge[i].weight < x) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (x < edge[j].weight) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (i <= j) {\n\t\t\t\tEdge swap = new Edge(edge[i].v1, edge[i].v2, edge[i].weight);\n\t\t\t\tedge[i] = edge[j];\n\t\t\t\tedge[j] = swap;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tsort(edge, low, j);\n\t\t\tsort(edge, i, high);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        int V = sc.nextInt();\n        int E = sc.nextInt();\n        Prim prim = new Prim(V, E);\n\n        for (int i = 0; i < E; i++) {\n            String line = sc.next();\n            String[] data = line.split(\",\");\n            int s = Integer.valueOf(data[0]);\n            int t = Integer.valueOf(data[1]);\n            int w = Integer.valueOf(data[2]) / 100 - 1;\n            prim.set(s, t, w);\n            prim.set(t, s, w);\n        }\n\n        int res = prim.run();\n        System.out.println(res);\n    }\n\n    public static class Prim {\n        int V, E;\n        @SuppressWarnings(\"unchecked\")\n        ArrayList<Edge>[] edges;\n\n        Prim(int V, int E) {\n            this.V = V;\n            this.E = E;\n            edges = new ArrayList[V];\n            for (int i = 0; i < V; i++) {\n                edges[i] = new ArrayList<>();\n            }\n        }\n\n        void set(int from, int to, int cost) {\n            edges[from].add(new Edge(to, cost));\n        }\n\n        int run() {\n            boolean[] done = new boolean[V];\n            Arrays.fill(done, false);\n            Queue<Edge> q = new PriorityQueue<>();\n            q.add(new Edge(0, 0));\n            int costSum = 0;\n            while (!q.isEmpty()) {\n                Edge e = q.poll();\n                if (done[e.t]) {\n                    continue;\n                }\n                done[e.t] = true;\n                costSum += e.w;\n                q.addAll(edges[e.t]);\n            }\n            return costSum;\n        }\n\n    }\n\n    public static class Edge implements Comparable<Edge> {\n        public int t, w;\n\n        Edge(int t, int w) {\n            this.t = t;\n            this.w = w;\n        }\n\n        @Override\n        public int compareTo(Edge o) {\n            return this.w - o.w;\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\n\n\npublic class Main {\n\t\n\tpublic static class Path implements Comparable<Path>{\n\t\tprivate int to,from,len;\n\t\t\n\t\tpublic Path(int f,int t,int l){\n\t\t\tfrom = f;\n\t\t\tto = t;\n\t\t\tlen = l;\n\t\t}\n\t\t\n\t\tpublic int get_from(){\n\t\t\treturn from;\n\t\t}\n\t\t\n\t\tpublic int get_to(){\n\t\t\treturn to;\n\t\t}\n\t\t\n\t\tpublic int get_len(){\n\t\t\treturn len;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Path p){\n\t\t\treturn this.get_len() - p.get_len(); \t\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"From \" + from + \". To \" + to + \". len \" + len +\".\";\n\t\t}\n\t}\n\n\tstatic class UnionFind {\n\t\tfinal int[] tree;\n\t\tint num;\n\n\t\tpublic UnionFind(int n) {\n\t\t\tthis.tree = new int[n];\n\t\t\tArrays.fill(tree, -1);\n\t\t\tnum = n;\n\t\t}\n\n\t\t// merge the set contains x and the set contains y\n\t\tvoid union(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (tree[x] < tree[y]) {\n\t\t\t\t\tx ^= y;\n\t\t\t\t\ty ^= x;\n\t\t\t\t\tx ^= y;\n\t\t\t\t}\n\t\t\t\ttree[x] += tree[y];\n\t\t\t\ttree[y] = x;\n\t\t\t\tnum--;\n\t\t\t}\n\t\t}\n\n\t\t// decide if x and y belong to the same set\n\t\tboolean find(int x, int y) {\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn tree[x] < 0 ? x : (tree[x] = root(tree[x]));\n\t\t}\n\n\t\t// return size of the set contains x\n\t\tint size(int x) {\n\t\t\treturn -tree[root(x)];\n\t\t}\n\n\t\t// return the number of sets\n\t\tint getNum() {\n\t\t\treturn num;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0){break;}\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tQueue<Path> queue = new PriorityQueue<Path>();\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString strs[] = sc.next().split(\",\");\n\t\t\t\tqueue.add(new Path(Integer.parseInt(strs[0]),Integer.parseInt(strs[1]),Integer.parseInt(strs[2])));\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\tUnionFind union = new UnionFind(n);\n\t\t\t\n\t\t\twhile(union.num > 1){\n\t\t\t\tPath p = queue.poll();\n\t\t\t\tif(!union.find(p.get_from(), p.get_to())){\n\t\t\t\t\tunion.union(p.get_to(), p.get_from());\n\t\t\t\t\tsum += p.get_len()/100-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\tint ans = 0;\n\t\tScanner sc = new Scanner(System.in);\n\t\tint V = sc.nextInt();\n\t\tint E = sc.nextInt();\n\t\tEdge[] G = new Edge[E];\n\t\tfor(int i=0;i<E;i++) {\n\t\t\tString s[] = sc.next().split(\",\");\n\t\t\tint u = Integer.parseInt(s[0]);\n\t\t\tint v = Integer.parseInt(s[1]);\n\t\t\tint c = Integer.parseInt(s[2])/100-1;\n\t\t\tG[i] = new Edge(u,v,c);\n\t\t}\n\t\tArrays.sort(G);\n\t\tUnionFind unionfind = new UnionFind(E);\n\t\tfor(int i=0;i<E;i++) {\n\t\t\tif (!unionfind.isConnected(G[i].u, G[i].v)) {\n\t\t\t\t//System.out.println(unionfind);\n\t\t\t\tunionfind.union(G[i].u, G[i].v);\n\t\t\t\t//System.out.println(unionfind);\n\t\t\t\tans += G[i].cost;\n\t\t\t}\n\t\t}\n\t\tSystem.out.println(ans);\n\t}\n}\nclass Edge implements Comparable<Edge>{\n\tint u;\n\tint v;\n\tint cost;\n\tpublic Edge(int u,int v,int cost) {\n\t\tthis.u = u;\n\t\tthis.v = v;\n\t\tthis.cost = cost;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn this.cost-o.cost;\n\t}\n}\nclass UnionFind {\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tpublic void union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tprivate int root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(data);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tint INF = 1 << 24;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint m = sc.nextInt();\n\t\t\tint [][] pass = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tpass[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString [] s = sc.next().split(\",\");\n\t\t\t\tint from = Integer.parseInt(s[0]);\n\t\t\t\tint to = Integer.parseInt(s[1]);\n\t\t\t\tint cost = Integer.parseInt(s[2]) / 100 - 1;\n\t\t\t\tpass[from][to] = cost;\n\t\t\t\tpass[to][from] = cost;\n\t\t\t}\n\n\t\t\tint [] mincost = new int[n];\n\t\t\tboolean [] isused = new boolean[n];\n\t\t\tArrays.fill(mincost, INF);\n\t\t\tmincost[0] = 0;\n\t\t\tint res = 0;\n\t\t\twhile(true){\n\t\t\t\tint v = -1;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(! isused[i] && (v == -1 || mincost[i] < mincost[v])){\n\t\t\t\t\t\tv = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(v == -1){\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tres += mincost[v];\n\t\t\t\tisused[v] = true;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmincost[i] = Math.min(mincost[i], pass[v][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] getAdjecentListWithCounter(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj, int nodes, int s) {\n        final int[] d = new int[nodes];\n        Arrays.fill(d, 0);//到達フラグ\n        // 未到達な行き先->距離優先\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return (d[a[0]] != d[b[0]]) ? (d[a[0]] - d[b[0]]) : (a[1] - b[1]);\n            }\n        });\n        // 適当に始点を決める\n        d[s] = 1;\n        // 枝集合追加\n        for (int[] e : adj[s]) {\n            ts.add(e);\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[0]] == 1)break;\n            d[ne[0]] = 1;\n            w += ne[1];\n            // 枝集合追加\n            for (int[] e : adj[ne[0]]) {\n                ts.add(e);\n            }\n        }\n        return w;\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = sc.nextInt() / 100 - 1;\n            }\n            int[][][] g = getAdjecentListWithCounter(n, f, t, w);\n            System.out.println(prim(g, n, 0));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\n\tfinal int INF=1<<30;\n\tint adjacent[][];\n\tScanner sc;\n\tint n;\n\t\n\tint solve(){\n\t\tint cost=0;\n\t\tSet<Integer> vertex=new HashSet<Integer>();\n\t\tvertex.add(0);\n\t\t\n\t\tfor(int h=0;h<n;++h){\n\t\t\tint min=INF,e=0;\n\t\t\tfor(int v:vertex){\n\t\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\t\tif(vertex.contains(i))continue;\n\t\t\t\t\tif(adjacent[v][i]<min){\n\t\t\t\t\t\tmin=adjacent[v][i];\n\t\t\t\t\t\te=i;\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min<INF){\n\t\t\t\tvertex.add(e);\n\t\t\t\tcost+=min/100-1;\t\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\"\\\\s*,\\\\s*|\\n\");\n\t\t\n\t\twhile((n=ni())!=0){\n\t\t\tadjacent=new int[n][n];\n\t\t\tfor(int i=0;i<n;++i){Arrays.fill(adjacent[i],INF);}\n\t\t\tint m=ni();\n\t\t\tfor(int i=0;i<m;++i){\n\t\t\t\tint a=ni(),b=ni(),d=ni();\n\t\t\t\tadjacent[a][b]=adjacent[b][a]=d;\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tint[][] path;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine()) {\n\t\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint m = Integer.parseInt(sc.nextLine());\n\n\t\t\tpath = new int[m][4];\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tpath[i][j] = Integer.parseInt(nico[j]);\n\t\t\t\t}\n\t\t\t\tpath[i][2] = path[i][2] / 100 - 1;\n\t\t\t\tpath[i][3] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tboolean[] flag = new boolean[n];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tflag[path[0][0]] = true;\n\t\t\tflag[path[0][1]] = true;\n\t\t\tpath[0][3] = 1;\n\t\t\t\n\t\t\tint total = path[0][2];\n\t\t\t\n\t\t\tint marked = 2;\n\t\t\twhile (marked != n) {\n\t\t\t\tfor (int i = 1; i < path.length; i++) {\n\t\t\t\t\tif (flag[path[i][0]] != flag[path[i][1]]) {\n\t\t\t\t\t\tflag[path[i][0]] = true;\n\t\t\t\t\t\tflag[path[i][1]] = true;\n\t\t\t\t\t\ttotal = total + path[i][2];\n\t\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tif (path[i][3] == 0) {\n\t\t\t\t\tint max = i;\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < path.length; j++) {\n\t\t\t\t\t\tint checknode = -1;\n\t\t\t\t\t\tif ((path[j][0] == path[i][0]) || (path[j][0] == path[i][1])) checknode = path[j][1];\n\t\t\t\t\t\telse if ((path[j][1] == path[i][0]) || (path[j][1] == path[i][1])) checknode = path[j][0];\n\t\t\t\t\t\tif (checknode == -1) continue;\n\t\t\t\t\t\t\n\t\t\t\t\t\tif ((path[max][2] < path[j][2]) && (check(checknode) >= 2)) max = j;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttotal = total + path[i][2] - path[max][2];\n\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\tpath[max][3] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n\t\n\tprivate int check(int index) {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (path[i][j] == index) ans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main{\n\tstatic final int MAX = 100;\n\tstatic final int INF = 1 << 21;\n\tstatic final int WHITE = 0;\n\tstatic final int GRAY = 1;\n\tstatic final int BLACK = 2;\n\tstatic int n;\n\tstatic int[][]M;\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(sc.hasNext()) {\n\t\t\tn = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tM = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tfor(int j = 0; j < n; j++) {\n\t\t\t\t\tM[i][j] = INF;\n\t\t\t\t}\n\t\t\t}\n\t\t\tint m = sc.nextInt();\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(s[0]);\n\t\t\t\tint b = Integer.parseInt(s[1]);\n\t\t\t\tint c = Integer.parseInt(s[2]);\n\t\t\t\tM[a][b] = c;\n\t\t\t\tM[b][a] = c;\n\t\t\t}\n\t\t\tint t = prim();\n\t\t\tSystem.out.println(t / 100 - n + 1);\n\t\t}\n\t\tsc.close();\n\t}\n\tstatic int prim() {\n\t\tint u, minV;\n\t\tint[]d = new int[MAX];\n\t\tint[]p = new int[MAX];\n\t\tint[]color = new int[MAX];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\td[i] = INF;\n\t\t\tp[i] = -1;\n\t\t\tcolor[i] = WHITE;\n\t\t}\n\t\td[0] = 0;\n\t\twhile(true) {\n\t\t\tminV = INF;\n\t\t\tu = -1;\n\t\t\tfor(int i = 0; i < n; i++) {\n\t\t\t\tif(minV > d[i] && color[i] != BLACK) {\n\t\t\t\t\tu = i;\n\t\t\t\t\tminV = d[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(u == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcolor[u] = BLACK;\n\t\t\tfor(int v = 0; v < n; v++) {\n\t\t\t\tif(color[v] != BLACK && M[u][v] != INF) {\n\t\t\t\t\tif(d[v] > M[u][v]) {\n\t\t\t\t\t\td[v] = M[u][v];\n\t\t\t\t\t\tp[v] = u;\n\t\t\t\t\t\tcolor[v] = GRAY;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tint sum = 0;\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tif(p[i] != -1) {\n\t\t\t\tsum += M[i][p[i]];\n\t\t\t}\n\t\t}\n\t\treturn sum;\n\t}\n}\n"
  },
  {
    "language": "Java",
    "code": "import java.util.*;class Main{public static void main(String[]z){Scanner s=new Scanner(System.in);for(int n,x,y,i,r,b;(n=s.nextInt())>0;System.out.println(r+1)){int[][]a=new int[n+1][n];for(i=s.nextInt();i-->0;a[x=new Integer(z[0])][y=new Integer(z[1])]=a[y][x]=new Integer(z[2]))z=s.next().split(\",\");Queue<int[]>l=new PriorityQueue<int[]>(n,new Comparator<int[]>(){public int compare(int[]a,int[]b){return a[1]-b[1];}});int[]w={0,0};for(r=0,b=1,l.add(w);b>0;){w=l.poll();a[n][w[0]]=1;r+=w[1]/100-1;for(i=b=0;i<n;++i)if(a[n][i]<1&&a[w[0]][i]>0)l.add(new int[]{i,a[w[0]][i]});for(int m:a[n])if(m<1)b=1;}}}}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] getAdjecentListWithCounter(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj, int nodes, int s) {\n        final int[] d = new int[nodes]; Arrays.fill(d, 0);//到達フラグ\n        // 未到達な行き先->距離優先\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                return (d[a[0]] != d[b[0]]) ? (d[a[0]] - d[b[0]]) : (a[1] - b[1]);\n            }\n        });\n        // 適当に始点を決める\n        d[s] = 1;\n        // 枝集合追加\n        for (int[] e : adj[s]) {\n            ts.add(e);\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[0]] == 1)break;\n            d[ne[0]] = 1;\n            w += ne[1];\n            // 枝集合追加\n            for (int[] e : adj[ne[0]]) {\n                ts.add(e);\n            }\n        }\n        return w;\n    }\n\n    public static void main(String[] args) throws Exception {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = (sc.nextInt() - 1) / 100;\n            }\n            int[][][] g = getAdjecentListWithCounter(n, f, t, w);\n            System.out.println(prim(g, n, 0));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.io.*;\nimport java.awt.geom.*;\nimport java.math.*;\n\npublic class Main {\n\n\tstatic final Scanner in = new Scanner(System.in);\n\tstatic final PrintWriter out = new PrintWriter(System.out,false);\n\n\tstatic boolean solve() {\n\t\tint n = in.nextInt();\n\t\tif (n == 0) return false;\n\t\tint m = in.nextInt();\n\t\tint[] s = new int[m];\n\t\tint[] t = new int[m];\n\t\tint[] c = new int[m];\n\n\t\tfor (int i=0; i<m; i++) {\n\t\t\tString[] str = in.next().split(\",\");\n\t\t\ts[i] = Integer.parseInt(str[0]);\n\t\t\tt[i] = Integer.parseInt(str[1]);\n\t\t\tc[i] = Integer.parseInt(str[2])/100-1;\n\t\t}\n\n\t\tout.println(kruskal(s,t,c,n));\n\t\treturn true;\n\t}\n\n\tpublic static int kruskal(int[] s, int[] t, int[] cost, int n) {\n\t\tDisjointSet ds = new DisjointSet(n);\n\t\tint e = s.length;\n\t\tlong[] link = new long[e];\n\t\tfor (int i=0; i<e; i++)\n\t\t\tlink[i] = (long)cost[i]<<32 | i;\n\n\t\tint res = 0;\n\n\t\tArrays.sort(link);\n\t\tfor (int i=0; i<e; i++) {\n\t\t\tint cur = (int)link[i];\n\t\t\tif (!ds.same(s[cur],t[cur])) {\n\t\t\t\tds.unite(s[cur],t[cur]);\n\t\t\t\tres += cost[cur];\n\t\t\t}\n\t\t}\n\n\t\treturn res;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tlong start = System.currentTimeMillis();\n\n\t\twhile(solve());\n\t\tout.flush();\n\n\t\tlong end = System.currentTimeMillis();\n\t\t//trace(end-start + \"ms\");\n\t\tin.close();\n\t\tout.close();\n\t}\n\n\tstatic void trace(Object... o) { System.out.println(Arrays.deepToString(o));}\n}\n\nclass DisjointSet {\n\tint[] data;\n\n\tpublic DisjointSet(int n){\n\t\tdata = new int[n];\n\t\tfor (int i=0; i<n; i++) data[i] = i;\n\t}\n\n\tpublic int find(int x){\n\t\tif(data[x] == x) return x;\n\t\treturn data[x] = find(data[x]);\n\t}\n\n\tpublic boolean same(int x,int y){\n\t\treturn find(x) == find(y);\n\t}\n\n\tpublic void unite(int x,int y){\n\t\tif (find(x) == find(y)) return;\n\t\tdata[find(x)] = find(y);\n\t}\n\n\tpublic String toString() {\n\t\treturn Arrays.toString(data);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import static java.util.Arrays.*;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.StringTokenizer;\n\npublic class Main {\n\n\tstatic void tr(Object... os) {\n\t\tSystem.err.println(deepToString(os));\n\t}\n\n\tvoid solve() {\n\t\tint n = sc.nextInt();\n\t\tif (n == 0) return;\n\t\tint m = sc.nextInt();\n\t\tint ans = 0;\n\t\tE[] es = new E[m];\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tString[] ss = sc.next().split(\",\");\n\t\t\tint a = Integer.parseInt(ss[0]);\n\t\t\tint b = Integer.parseInt(ss[1]);\n\t\t\tint d = Integer.parseInt(ss[2]);\n\t\t\tes[i] = new E(a, b, d / 100 - 1);\n\t\t}\n\t\tsort(es);\n\t\tUnionFind uf = new UnionFind(n);\n\t\tfor (E e : es) {\n\t\t\tif (uf.same(e.a, e.b)) {\n\n\t\t\t} else {\n\t\t\t\tuf.link(e.a,  e.b);\n\t\t\t\tans += e.w;\n\t\t\t}\n\t\t}\n\t\tout.println(ans);\n\t}\n\n\tstatic class E implements Comparable<E> {\n\t\tint a;\n\t\tint b;\n\t\tint w;\n\t\tpublic E(int a, int b, int w) {\n\t\t\tthis.a = a;\n\t\t\tthis.b = b;\n\t\t\tthis.w = w;\n\t\t}\n\t\t@Override\n\t\tpublic int compareTo(E o) {\n\t\t\treturn w - o.w;\n\t\t}\n\t}\n\n\tpublic class UnionFind {\n\t\tint[] data;\n\n\t\tpublic UnionFind(int n) {\n\t\t\tdata = new int[n];\n\t\t\tfill(data, -1);\n\t\t}\n\n\t\tboolean link(int x, int y) {\n\t\t\tx = root(x);\n\t\t\ty = root(y);\n\t\t\tif (x != y) {\n\t\t\t\tif (data[y] < data[x]) {\n\t\t\t\t\tdata[y] += data[x];\n\t\t\t\t\tdata[x] = y;\n\t\t\t\t} else {\n\t\t\t\t\tdata[x] += data[y];\n\t\t\t\t\tdata[y] = x;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn x != y;\n\t\t}\n\n\t\tint root(int x) {\n\t\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t\t}\n\n\t\tint size(int x) { // 要素xが含まれる集合の大きさ\n\t\t\treturn -data[root(x)];\n\t\t}\n\n\t\tboolean same(int x, int y) { // 同じ集合ならtrue\n\t\t\treturn root(x) == root(y);\n\t\t}\n\n\t\tint num() { // 異なる集合の数\n\t\t\tint res = 0;\n\t\t\tfor (int i = 0; i < data.length; i++)\n\t\t\t\tres += (root(i) == i) ? 1 : 0;\n\t\t\treturn res;\n\t\t}\n\t}\n\n\n\n\n\tpublic static void main(String[] args) throws Exception {\n\t\tnew Main().run();\n\t}\n\n\tMyScanner sc = null;\n\tPrintWriter out = null;\n\tpublic void run() throws Exception {\n\t\tsc = new MyScanner(System.in);\n\t\tout = new PrintWriter(System.out);\n\t\tfor (;sc.hasNext();) {\n\t\t\tsolve();\n\t\t\tout.flush();\n\t\t}\n\t\tout.close();\n\t}\n\n\tclass MyScanner {\n\t\tString line;\n\t\tBufferedReader reader;\n\t\tStringTokenizer tokenizer;\n\n\t\tpublic MyScanner(InputStream stream) {\n\t\t\treader = new BufferedReader(new InputStreamReader(stream));\n\t\t\ttokenizer = null;\n\t\t}\n\t\tpublic void eat() {\n\t\t\twhile (tokenizer == null || !tokenizer.hasMoreTokens()) {\n\t\t\t\ttry {\n\t\t\t\t\tline = reader.readLine();\n\t\t\t\t\tif (line == null) {\n\t\t\t\t\t\ttokenizer = null;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\ttokenizer = new StringTokenizer(line);\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\tthrow new RuntimeException(e);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic String next() {\n\t\t\teat();\n\t\t\treturn tokenizer.nextToken();\n\t\t}\n\t\tpublic String nextLine() {\n\t\t\ttry {\n\t\t\t\treturn reader.readLine();\n\t\t\t} catch (IOException e) {\n\t\t\t\tthrow new RuntimeException(e);\n\t\t\t}\n\t\t}\n\t\tpublic boolean hasNext() {\n\t\t\teat();\n\t\t\treturn (tokenizer != null && tokenizer.hasMoreElements());\n\t\t}\n\t\tpublic int nextInt() {\n\t\t\treturn Integer.parseInt(next());\n\t\t}\n\t\tpublic long nextLong() {\n\t\t\treturn Long.parseLong(next());\n\t\t}\n\t\tpublic double nextDouble() {\n\t\t\treturn Double.parseDouble(next());\n\t\t}\n\t\tpublic int[] nextIntArray(int n) {\n\t\t\tint[] a = new int[n];\n\t\t\tfor (int i = 0; i < n; i++) a[i] = nextInt();\n\t\t\treturn a;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.io.*;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\npublic class Main {\n\tstatic int V;\n\tstatic int E;\n\tstatic Edge[] es;\n\tpublic static void main(String[] args) {\n\t\tFastScanner sc = new FastScanner();\n\t\tPrintWriter out = new PrintWriter(System.out);\n\t\t\n\t\twhile(true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tV = n;\n\t\t\tint m = sc.nextInt();\n\t\t\tE = m;\n\t\t\tes = new Edge[E];\n\t\t\tfor(int i = 0; i < m; i++) {\n\t\t\t\tString[] tmp = sc.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(tmp[0]);\n\t\t\t\tint b = Integer.parseInt(tmp[1]);\n\t\t\t\tint c = Integer.parseInt(tmp[2]);\n\t\t\t\t\n\t\t\t\tes[i] = new Edge(a,b,c);\n\t\t\t}\n\t\t\t\n\t\t\tint ret = kruskal();\n\t\t\t\n\t\t\tret -=  (n-1)*100;\n\t\t\tSystem.out.println(ret / 100);\n\t\t}\n\t}\n\t\n\tpublic static int kruskal() {\n\t\tArrays.sort(es,new Comp());\n\t\tinit(V);\n\t\tint res = 0;\n\t\tfor (int i = 0; i < E; i++) {\n\t\t\tEdge e = es[i];\n\t\t\tif(!same(e.u,e.v)) {\n\t\t\t\tunite(e.u,e.v);\n\t\t\t\tres += e.cost;\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\t\n\tstatic int[] par ;\n\tstatic int[] rank ;\n\t\n\tstatic void init(int n) {\n\t\tpar = new int[V];\n\t\trank = new int[V];\n\t\tfor(int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t\trank[i] = 0;\n\t\t}\n\t}\n\t\n\tstatic int find(int x) {\n\t\tif(par[x] == x) {\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\treturn par[x] = find(par[x]);\n\t\t}\n\t}\n\t\n\tstatic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif(x == y) return;\n\t\t\n\t\tif(rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t}\n\t\telse {\n\t\t\tpar[y] = x;\n\t\t\tif(rank[x] == rank[y]) rank[x]++;\n\t\t}\n\t\t\n\t}\n\t\n\tstatic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n\t\n\n}\n\n\nclass Edge {\n\tint u;\n\tint v;\n\tint cost;\n\tEdge(int a, int b, int c) {\n\t\tu = a;\n\t\tv = b;\n\t\tcost = c;\n\t}\n}\n\nclass Comp implements Comparator<Edge> {\n\n\tpublic int compare(Edge o1, Edge o2) {\n\t\treturn o1.cost - o2.cost;\n\t}\n\t\n}\n//------------------------------//\n//-----------//\nclass FastScanner {\n    private final InputStream in = System.in;\n    private final byte[] buffer = new byte[1024];\n    private int ptr = 0;\n    private int buflen = 0;\n    private boolean hasNextByte() {\n        if (ptr < buflen) {\n            return true;\n        }else{\n            ptr = 0;\n            try {\n                buflen = in.read(buffer);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n            if (buflen <= 0) {\n                return false;\n            }\n        }\n        return true;\n    }\n    private int readByte() { if (hasNextByte()) return buffer[ptr++]; else return -1;}\n    private static boolean isPrintableChar(int c) { return 33 <= c && c <= 126;}\n    private void skipUnprintable() { while(hasNextByte() && !isPrintableChar(buffer[ptr])) ptr++;}\n    public boolean hasNext() { skipUnprintable(); return hasNextByte();}\n    public String next() {\n        if (!hasNext()) throw new NoSuchElementException();\n        StringBuilder sb = new StringBuilder();\n        int b = readByte();\n        while(isPrintableChar(b)) {\n            sb.appendCodePoint(b);\n            b = readByte();\n        }\n        return sb.toString();\n    }\n    public long nextLong() {\n        if (!hasNext()) throw new NoSuchElementException();\n        long n = 0;\n        boolean minus = false;\n        int b = readByte();\n        if (b == '-') {\n            minus = true;\n            b = readByte();\n        }\n        if (b < '0' || '9' < b) {\n            throw new NumberFormatException();\n        }\n        while(true){\n            if ('0' <= b && b <= '9') {\n                n *= 10;\n                n += b - '0';\n            }else if(b == -1 || !isPrintableChar(b)){\n                return minus ? -n : n;\n            }else{\n                throw new NumberFormatException();\n            }\n            b = readByte();\n        }\n    }\n    \n    public int nextInt() {\n    \treturn (int)nextLong();\n    }\n    \n\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=1000000;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tint m=in.nextInt();\n\t\t\tint cost[][]=new int[n][n];\n\t\t\tint mincost[]=new int[n];//頂点iへの辺の最小コスト\n\t\t\tboolean use[]=new boolean[n];//頂点iが部分全域木に含まれているか\n\t\t\tint total=0;//answer\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tArrays.fill(mincost, M);\n\t\t\tArrays.fill(use, false);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString str[]=in.next().split(\",\");\n\t\t\t\tint s=Integer.valueOf(str[0]);\n\t\t\t\tint t=Integer.valueOf(str[1]);\n\t\t\t\tint c=Integer.valueOf(str[2]);\n\t\t\t\tcost[s][t]=c;\n\t\t\t\tcost[t][s]=c;\n\t\t\t}\n\t\t\tmincost[0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint v=-1;//追加する頂点\t\t\t\t\n\t\t\t\tfor(int j=0;j<n;j++)//追加する頂点を探す\n\t\t\t\t\tif(!use[j]&&(v==-1||mincost[v]>mincost[j]))\n\t\t\t\t\t\tv=j;\n\t\t\t\tif(v==-1) //全ての頂点を選んだ\n\t\t\t\t\tbreak;\n\t\t\t\tif(mincost[v]!=0)\n\t\t\t\t\ttotal+=((mincost[v]/100)-1);\n\t\t\t\tuse[v]=true;\n\t\t\t\tfor(int j=0;j<n;j++)//追加した頂点と繋がっている辺を調べ最小コストを更新\n\t\t\t\t{\n\t\t\t\t\tif(!use[j]&&mincost[j]>cost[v][j])\n\t\t\t\t\t\tmincost[j]=cost[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\n\n\npublic class Main {\n\tprivate\tstatic\tBufferedReader br = null;\n\n\tstatic {\n\t\tbr = new BufferedReader(new InputStreamReader(System.in));\n\t}\n\n\t/**\n\t * @param args\n\t */\n\tpublic static void main(String[] args) {\n\t\t// TODO Auto-generated method stub\n\t\tint\tpoint = 0;\n\n\t\twhile ((point = parseNum()) != 0) {\n\t\t\tint[][]\tmap     = new int[point][point];\n\t\t\tint\t\troute   = parseNum();\n\t\t\tint\t\tlantern = 0;\n\t\t\tfor (int i = 0; i < point; i++) {\n\t\t\t\tfor (int j = 0; j < point; j++) {\n\t\t\t\t\tmap[i][j] = -1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < route; n++) {\n\t\t\t\tint[]\tdist = parseDist();\n\t\t\t\tmap[dist[0]][dist[1]] = dist[2];\n\t\t\t\tmap[dist[1]][dist[0]] = dist[2];\n\t\t\t}\n\n\t\t\tfor (int n = 0; n < route; n++) {\n\t\t\t\tint\ttmp = solve(1 << n, n, map);\n\t\t\t\tlantern = (lantern == 0) ? tmp : Math.min(tmp, lantern);\n\t\t\t}\n\t\t\tSystem.out.println(lantern);\n\t\t}\n\t}\n\n\tprivate static int solve(int cbit, int start, int[][] map) {\n\t\tint\t\tfbit    = 0;\n\t\tint\t\tlantern = 0;\n\t\tint\t\trest    = 0;\n\t\tboolean\tcomp    = true;\n\n\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\tif ((cbit & 1 << n) == 0) {\n\t\t\t\tif (map[start][n] != -1) {\n\t\t\t\t\tfbit |= 1 << n;\n\t\t\t\t\tlantern += map[start][n];\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tcomp = false;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (!comp) {\n\t\t\tfor (int n = 0; n < map.length; n++) {\n\t\t\t\tif (map[start][n] != -1 && (fbit & 1 << n) != 0) {\n\t\t\t\t\tint\ttmp = solve(cbit | fbit, n, map);\n\t\t\t\t\tif (tmp != 0) {\n\t\t\t\t\t\trest = (rest == 0) ? tmp : Math.min(tmp, rest);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn lantern + rest;\n\t}\n\n\tprivate static int[] parseDist() {\n\t\tint[]\tdist  = null;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tString[]\tsplit = strIn.split(\",\");\n\t\t\tdist    = new int[3];\n\t\t\tdist[0] = Integer.parseInt(split[0]); \n\t\t\tdist[1] = Integer.parseInt(split[1]); \n\t\t\tdist[2] = Integer.parseInt(split[2]) / 100 - 1; \n\t\t}\n\t\t\n\t\treturn dist;\n\t}\n\n\tprivate static int parseNum() {\n\t\tint\t\tnum   = 0;\n\t\tString\tstrIn = null;\n\n\t\tif ((strIn = parseStdin()) != null) {\n\t\t\tnum = Integer.parseInt(strIn); \n\t\t}\n\t\t\n\t\treturn num;\n\t}\n\n\tprivate static String parseStdin() {\n\t\tString\tstrNum = null;\n\n\t\ttry {\n\t\t\tString line = br.readLine();\n\t\t\tif (line != null) {\n\t\t\t\tif (!line.isEmpty()) {\n\t\t\t\t\tstrNum = line;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tcatch (IOException e) {}\n\n\t\treturn strNum;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n    public static int[][][] makeadj(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj) {\n        int[] c = new int[adj.length];\n        Arrays.fill(c, Integer.MAX_VALUE);\n        c[0] = 0;\n        boolean[] vis = new boolean[adj.length];\n        int w = 0;\n        while (true) {\n            int v = -1;\n            for (int u = 0; u < adj.length; u++) {\n                if (!vis[u] && (v == -1 || c[v] > c[u])) {\n                    v = u;\n                }\n            }\n            if (v == -1)\n                break;\n            w += c[v];\n            vis[v] = true;\n            for (int[] e : adj[v]) {\n                if (!vis[e[0]] && c[e[0]] > e[1]) {\n                    c[e[0]] = e[1];\n                }\n            }\n        }\n        return w;\n    }\n\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = (sc.nextInt() / 100) - 1;// / 100;\n            }\n            int[][][] g = makeadj(n, f, t, w);\n            System.out.println(prim(g));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) throws Exception {\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile (true) {\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0)break;\n\t\t\tint m = sc.nextInt();\n\t\t\tsc.useDelimiter(\",|\\n\");\n\t\t\tEdge[] es = new Edge[m];\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint s = sc.nextInt();\n\t\t\t\tint e = sc.nextInt();\n\t\t\t\tint d = sc.nextInt();\n\t\t\t\tes[i] = new Edge(s, e, d);\n\t\t\t}\n\t\t\tArrays.sort(es, new Comparator<Edge>() {\n\t\t\t\tpublic int compare(Edge a, Edge b) {\n\t\t\t\t\treturn a.d - b.d;\n\t\t\t\t}\n\t\t\t});\n\t\t\tint sum=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tint a = es[i].s;\n\t\t\t\tint b = es[i].e;\n\t\t\t\tint d = es[i].d;\n\t\t\t\tif(!uf.same(a,b)){\n\t\t\t\t\tuf.unite(a,b);\n\t\t\t\t\tsum+=d/100-1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\t\t}\n\t}\n}\n\nclass Edge {\n\tpublic int s;\n\tpublic int e;\n\tpublic int d;\n\n\tEdge(int s, int e, int d) {\n\t\tthis.s = s;\n\t\tthis.e = e;\n\t\tthis.d = d;\n\t}\n}\n\nclass UnionFind {\n\tpublic int par[];\n\tpublic int rank[];\n\n\tUnionFind(int n) {\n\t\tpar = new int[n];\n\t\trank = new int[n];\n\t\tfor (int i = 0; i < n; i++) {\n\t\t\tpar[i] = i;\n\t\t}\n\t}\n\n\tpublic int find(int x) {\n\t\tif (par[x] == x)\n\t\t\treturn x;\n\t\telse\n\t\t\treturn par[x] = find(par[x]);\n\t}\n\n\tpublic void unite(int x, int y) {\n\t\tx = find(x);\n\t\ty = find(y);\n\t\tif (x == y)\n\t\t\treturn;\n\n\t\tif (rank[x] < rank[y]) {\n\t\t\tpar[x] = y;\n\t\t} else {\n\t\t\tpar[y] = x;\n\t\t\tif (rank[x] == rank[y])\n\t\t\t\trank[x]++;\n\t\t}\n\t}\n\n\tpublic boolean same(int x, int y) {\n\t\treturn find(x) == find(y);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] makeadj(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj) {\n        final int[] d = new int[adj.length];\n        Arrays.fill(d, 0);\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if (d[a[1]] != d[b[1]]) {\n                    return (d[a[1]] - d[b[1]]);\n                } else if (a[2] != b[2]) {\n                    return a[2] - b[2];\n                }\n                return 1;\n            }\n        });\n\n        d[0] = 1;\n        for (int[] e : adj[0]) {\n            ts.add(new int[]{0, e[0], e[1]});\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[1]] == 1)\n                break;\n            d[ne[1]] = 1;\n            w += ne[2];\n            for (int[] e : adj[ne[1]]) {\n                ts.add(new int[]{ne[1], e[0], e[1]});\n            }\n        }\n        return w;\n    }\n\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = (sc.nextInt() / 100) - 1;// / 100;\n            }\n            int[][][] g = makeadj(n, f, t, w);\n            System.out.println(prim(g));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Comparator;\nimport java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n    public static int[][][] makeadj(int n, int[] from, int[] to, int[] w) {\n        int[][][] e = new int[n][][];\n        int[] d = new int[n];\n        for (int f : from)\n            d[f]++;\n        for (int t : to)\n            d[t]++;\n        for (int i = 0; i < n; i++)\n            e[i] = new int[d[i]][2];\n        for (int i = 0; i < from.length; i++) {\n            --d[from[i]];\n            e[from[i]][d[from[i]]][0] = to[i];\n            e[from[i]][d[from[i]]][1] = w[i];\n            --d[to[i]];\n            e[to[i]][d[to[i]]][0] = from[i];\n            e[to[i]][d[to[i]]][1] = w[i];\n        }\n        return e;\n    }\n\n    public static int prim(int[][][] adj) {\n        final int[] d = new int[adj.length];\n        Arrays.fill(d, 0);\n        TreeSet<int[]> ts = new TreeSet<int[]>(new Comparator<int[]>() {\n            public int compare(int[] a, int[] b) {\n                if (d[a[1]] != d[b[1]]) {\n                    return (d[a[1]] - d[b[1]]);\n                } else if (a[2] != b[2]) {\n                    return a[2] - b[2];\n                }\n                return 1;\n            }\n        });\n\n        d[0] = 1;\n        for (int[] e : adj[0]) {\n            ts.add(new int[]{0, e[0], e[1]});\n        }\n        int w = 0;\n        while (!ts.isEmpty()) {\n            int[] ne = ts.pollFirst();\n            if (d[ne[1]] == 1)\n                break;\n            d[ne[1]] = 1;\n            w += ne[2];\n            for (int[] e : adj[ne[1]]) {\n                ts.add(new int[]{ne[1], e[0], e[1]});\n            }\n        }\n        return w;\n    }\n\n    public static void main(String... args) {\n        Scanner sc = new Scanner(System.in).useDelimiter(\"[^0-9]+\");\n        while (true) {\n            int n = sc.nextInt();\n            if (n == 0)\n                break;\n            int m = sc.nextInt();\n            int[] f = new int[m];\n            int[] t = new int[m];\n            int[] w = new int[m];\n            for (int i = 0; i < m; i++) {\n                f[i] = sc.nextInt();\n                t[i] = sc.nextInt();\n                w[i] = (sc.nextInt() - 1) / 100;\n            }\n            int[][][] g = makeadj(n, f, t, w);\n            System.out.println(prim(g));\n        }\n    }\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tint[][] path;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine()) {\n\t\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint m = Integer.parseInt(sc.nextLine());\n\n\t\t\tpath = new int[m][4];\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tpath[i][j] = Integer.parseInt(nico[j]);\n\t\t\t\t}\n\t\t\t\tpath[i][2] = path[i][2] / 100 - 1;\n\t\t\t\tpath[i][3] = 0;\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tboolean[] flag = new boolean[n];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tflag[path[0][0]] = true;\n\t\t\tflag[path[0][1]] = true;\n\t\t\tpath[0][3] = 1;\n\t\t\t\n\t\t\tint total = path[0][2];\n\t\t\t\n\t\t\tint marked = 2;\n\t\t\twhile (marked != n) {\n\t\t\t\tfor (int i = 1; i < path.length; i++) {\n\t\t\t\t\tif (flag[path[i][0]] != flag[path[i][1]]) {\n\t\t\t\t\t\tflag[path[i][0]] = true;\n\t\t\t\t\t\tflag[path[i][1]] = true;\n\t\t\t\t\t\ttotal = total + path[i][2];\n\t\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tboolean changed = true;\n\t\t\twhile (changed == true) {\n\t\t\t\tchanged = false;\n\t\t\t\t\n\t\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\t\tif (path[i][3] == 0) {\n\t\t\t\t\t\tint max = i;\n\t\t\t\t\t\t\n\t\t\t\t\t\tfor (int j = 0; j < path.length; j++) {\n\t\t\t\t\t\t\tif ((path[j][3] == 0) || (i == j)) continue;\n\t\t\t\t\t\t\tif ((path[j][0] != path[i][0]) && (path[j][0] != path[i][1])\n\t\t\t\t\t\t\t\t\t&& (path[j][1] != path[i][0]) && (path[j][1] != path[i][1])) continue;\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tint checknode = -1;\n\t\t\t\t\t\t\tif ((path[j][0] == path[i][0]) || (path[j][0] == path[i][1])) checknode = path[j][1];\n\t\t\t\t\t\t\telse checknode = path[j][0];\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tif ((path[max][2] < path[j][2]) && (check(checknode) >= 2)) {\n\t\t\t\t\t\t\t\tchanged = true;\n\t\t\t\t\t\t\t\tmax = j;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\ttotal = total + path[i][2] - path[max][2];\n\t\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\t\tpath[max][3] = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n\t\n\tprivate int check(int index) {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\tfor (int j = 0; j < 2; j++) {\n\t\t\t\tif (path[i][j] == index) ans++;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\nclass Main {\n\tScanner sc = new Scanner(System.in);\n\n\n\tpublic void run() {\n\t\twhile(true){\n\t\t\tint n=sc.nextInt(),m=sc.nextInt();\n\t\t\tNode[] nodes=new Node[m];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString[] str=sc.next().split(\",\");\n\t\t\t\tnodes[i]=new Node(Integer.parseInt(str[0]),Integer.parseInt(str[1]),Integer.parseInt(str[2]));\n\t\t\t}\n\t\t\tUnionFind uf=new UnionFind(n);\n\t\t\tArrays.sort(nodes);\n\t\t\tint res=0;int node=0;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tif(!uf.find(nodes[i].p1,nodes[i].p2)){\n\t\t\t\t\tuf.unite(nodes[i].p1,nodes[i].p2);\n\t\t\t\t\tres+= nodes[i].dist;\n\t\t\t\t\tnode++;\n\t\t\t\t}\n\t\t\t}\n\t\t\tln(res/100-node);\n\t\t}\n\n\t}\n\tclass Node implements Comparable<Node>{\n\t\tint p1,p2,dist;\n\n\t\t@Override\n\t\tpublic int compareTo(Node o) {\n\t\t\treturn dist-o.dist;\n\t\t}\n\t\tNode(int a,int b,int c){\n\t\t\tp1=a;p2=b;dist=c;\n\t\t}\n\t}\n\tpublic class UnionFind {\n\t    private int[] id;\n\t    private int[] sz;\n\t    private int components;\n\n\t    public UnionFind(int N) {\n\t        id = new int[N];\n\t        sz = new int[N];\n\t        components = N;\n\t        for (int i = 0; i < N; i++) {\n\t            id[i] = i;\n\t            sz[i] = 1;\n\t        }\n\t    }\n\t    public int find(int x) {\n\t        while (x != id[x])\n\t            x = id[x];\n\t        return x;\n\t    }\n\t    public int components() {\n\t        return components;\n\t    }\n\t    public boolean find(int p, int q) {\n\t        return find(p) == find(q);\n\t    }\n\t    public void unite(int p, int q) {\n\t        int i = find(p);\n\t        int j = find(q);\n\t        if (i == j) return;\n\t        if   (sz[i] < sz[j]) { id[i] = j; sz[j] += sz[i]; }\n\t        else                 { id[j] = i; sz[i] += sz[j]; }\n\t        components--;\n\t    }\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tnew Main().run();\n\t}\n\n\tpublic static void pr(Object o) {\n\t\tSystem.out.print(o);\n\t}\n\n\tpublic static void ln(Object o) {\n\t\tSystem.out.println(o);\n\t}\n\n\tpublic static void ln() {\n\t\tSystem.out.println();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\tScanner sc = new Scanner(System.in);\n\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\n\tpublic Main() {\n\t\tnew aoj0072().doIt();\n\t}\n\n\tclass aoj0072 {\n\t\tint cost[][];\n\t\tint mincost[];\n\t\tboolean used[];\n\t\tint V;\n\n\t\tint prim() {\n\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\tmincost[i] = Integer.MAX_VALUE;\n\t\t\t\tused[i] = false;\n\t\t\t}\n\t\t\tmincost[0] = 0;\n\t\t\tint res = 0;\n\t\t\twhile (true) {\n\t\t\t\tint v = -1;\n\t\t\t\tfor (int u = 0; u < V; u++) {\n\t\t\t\t\tif (!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t\t\t\tv = u;\n\t\t\t\t}\n\t\t\t\tif (v == -1)\n\t\t\t\t\tbreak;\n\t\t\t\tused[v] = true;\n\t\t\t\tres += mincost[v];\n\n\t\t\t\tfor (int u = 0; u < V; u++) {\n\t\t\t\t\tmincost[u] = Math.min(mincost[u], cost[v][u]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\n\t\tvoid doIt() {\n\t\t\twhile (true) {\n\t\t\t\tV = sc.nextInt();\n\t\t\t\tif (V == 0)\n\t\t\t\t\tbreak;\n\t\t\t\tcost = new int[V][V];\n\t\t\t\tmincost = new int[V];\n\t\t\t\tused = new boolean[V];\n\t\t\t\tfor (int i = 0; i < V; i++) {\n\t\t\t\t\tfor (int j = 0; j < V; j++) {\n\t\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tint n = sc.nextInt();\n\t\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\t\tString[] node = sc.next().split(\",\");\n\t\t\t\t\tint nodea = Integer.valueOf(node[0]);\n\t\t\t\t\tint nodeb = Integer.parseInt(node[1]);\n\t\t\t\t\tint abcost = Integer.parseInt(node[2]);\n\t\t\t\t\tcost[nodea][nodeb] = abcost;\n\t\t\t\t\tcost[nodeb][nodea] = abcost;\n\t\t\t\t}\n\t\t\t\tint ans = prim();\n\t\t\t\tans = (ans / 100) - V + 1;\n\t\t\t\tSystem.out.println(ans);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\n\npublic class Main {\n\t\n\tpublic static void main(String[] args) {\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n==0) break;\n\t\t\t\n\t\t\tint m = sc.nextInt();\n\t\t\tint[][] map = new int[m][3];\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tString[] s = sc.next().split(\",\");\n\t\t\t\tmap[i][0] = Integer.valueOf(s[0]);\n\t\t\t\tmap[i][1] = Integer.valueOf(s[1]);\n\t\t\t\tmap[i][2] = Integer.valueOf(s[2]) - 100;\n\t\t\t}\n\t\t\t\n\t\t\tArrays.sort(map, new Comparator<int[]>(){\n\t\t\t\tpublic int compare(int[] o1, int[] o2) {\n\t\t\t\t\treturn o1[2] - o2[2];\n\t\t\t\t}\n\t\t\t});\n\n\t\t\tboolean[][] f = new boolean[100][100];\n\t\t\tint sum = 0;\n\t\t\tfor(int i=0;i<n;i++) f[i][i] = true;\n\t\t\t\n\t\t\tint p, q;\n\t\t\tfor(int i=0;i<m;i++){\n\t\t\t\tp = map[i][0];\n\t\t\t\tq = map[i][1];\n\t\t\t\tif(f[p][q]==false){\n\t\t\t\t\tsum += map[i][2];\n\t\t\t\t\tfor(int j=0;j<n;j++){\n\t\t\t\t\t\tif(f[j][p]==true) f[j][q] = true;\n\t\t\t\t\t\tif(f[j][q]==true) f[j][p] = true;\n\t\t\t\t\t\tif(f[p][j]==true) f[q][j] = true;\n\t\t\t\t\t\tif(f[q][j]==true) f[p][j] = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum/100);\n\t\t}\t\n\t}\t\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tpublic static void main(String[] args) {\n\t\twhile(true) {\n\t\t\tint ans = 0;\n\t\t\tScanner sc = new Scanner(System.in);\n\t\t\tint V = sc.nextInt();\n\t\t\tif (V==0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint E = sc.nextInt();\n\t\t\tEdge[] G = new Edge[E];\n\t\t\tfor(int i=0;i<E;i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tint u = Integer.parseInt(s[0]);\n\t\t\t\tint v = Integer.parseInt(s[1]);\n\t\t\t\tint c = Integer.parseInt(s[2])/100-1;\n\t\t\t\tG[i] = new Edge(u,v,c);\n\t\t\t}\n\t\t\tArrays.sort(G);\n\t\t\tUnionFind unionfind = new UnionFind(V);\n\t\t\tfor(int i=0;i<E;i++) {\n\t\t\t\tif (!unionfind.isConnected(G[i].u, G[i].v)) {\n\t\t\t\t\t//System.out.println(unionfind);\n\t\t\t\t\tunionfind.union(G[i].u, G[i].v);\n\t\t\t\t\t//System.out.println(unionfind);\n\t\t\t\t\tans += G[i].cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(ans);\n\t\t}\n\t}\n}\nclass Edge implements Comparable<Edge>{\n\tint u;\n\tint v;\n\tint cost;\n\tpublic Edge(int u,int v,int cost) {\n\t\tthis.u = u;\n\t\tthis.v = v;\n\t\tthis.cost = cost;\n\t}\n\t@Override\n\tpublic int compareTo(Edge o) {\n\t\treturn this.cost-o.cost;\n\t}\n}\nclass UnionFind {\n\tprivate int[] data;\n\tpublic UnionFind(int size) {\n\t\tdata = new int[size];\n\t\tArrays.fill(data, -1);\n\t}\n\tpublic void union(int x,int y) {\n\t\tx = root(x);\n\t\ty = root(y);\n\t\tif (x!=y) {\n\t\t\tif (data[y] < data[x]) {\n\t\t\t\tint tmp = y;\n\t\t\t\ty = x;\n\t\t\t\tx = tmp;\n\t\t\t}\n\t\t\tdata[x] += data[y];\n\t\t\tdata[y] = x;\n\t\t}\n\t}\n\tpublic boolean isConnected(int x,int y) {\n\t\treturn root(x)==root(y);\n\t}\n\tprivate int root(int x) {\n\t\treturn data[x] < 0 ? x : (data[x] = root(data[x]));\n\t}\n\tpublic int size(int x) {\n\t\treturn -data[root(x)];\n\t}\n\tpublic String toString() {\n\t\treturn Arrays.toString(data);\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tString string;\n\t\tint n, m, a, b = 0, c;\n\t\t\n\t\twhile(!(string = reader.readLine()).equals(\"0\")){\n\t\t\tn = Integer.valueOf(string);\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tstring = reader.readLine();\n\t\t\t\ta = Integer.valueOf(string.split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(string.split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(string.split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t};\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\treader.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.Arrays;\n\npublic class Main{\n\tpublic static void main(String[] args)throws IOException{\n\t\tInputStreamReader isr = new InputStreamReader(System.in);\n\t\tBufferedReader reader = new BufferedReader(isr);\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = 0, m = 0, a = 0, b = 0, c = 0;\n\t\t\n\t\twhile(!(sb.append(reader.readLine())).equals(\"0\")){\n\t\t\tn = Integer.valueOf(sb.toString());\n\t\t\tm = Integer.valueOf(reader.readLine());\n\t\t\t\n\t\t\tint map[][] = new int[n][n];\n\t\t\tboolean visit[] = new boolean[n];\n\t\t\tfor(int i = 0;i < n; i++) Arrays.fill(map[i], 1 << 29);\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tsb.setLength(0);\n\t\t\t\tsb.append(reader.readLine());\n\t\t\t\ta = Integer.valueOf(sb.toString().split(\",\")[0]);\n\t\t\t\tb = Integer.valueOf(sb.toString().split(\",\")[1]);\n\t\t\t\tc = (Integer.valueOf(sb.toString().split(\",\")[2]) - 100) / 100;\n\t\t\t\tmap[a][b] = map[b][a] = c;\n\t\t\t}\n\t\t\tc = 0;\n\t\t\tvisit[0] = true;\n\t\t\tfor(int x = 0; x < n - 1; x++){\n\t\t\t\tm = 1 << 29;\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tif(map[0][i] < m && !visit[i]){\n\t\t\t\t\t\tm = map[0][i];\n\t\t\t\t\t\tb = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvisit[b] = true;\n\t\t\t\tc += map[0][b];\n\t\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\t\tmap[0][i] = Math.min(map[0][i], map[b][i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(c);\n\t\t}\n\t\treader.close();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\npublic class Main\n{\n\tpublic static void main(String[] args) \n\t{\n\t\tScanner in=new Scanner(System.in);\n\t\tint M=10000;\n\t\tfor(;;)\n\t\t{\n\t\t\tint n=in.nextInt(),m=in.nextInt();\n\t\t\tif(n==0)\n\t\t\t\treturn;\n\t\t\tint cost[][]=new int[n][n];\n\t\t\tint mincost[]=new int[n];//頂点iへの辺の最小コスト\n\t\t\tboolean use[]=new boolean[n];//頂点iが部分全域木に含まれているか\n\t\t\tint total=0;//answer\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tArrays.fill(cost[i], M);\n\t\t\tArrays.fill(mincost, M);\n\t\t\tArrays.fill(use, false);\n\t\t\tfor(int i=0;i<n;i++)\n\t\t\t\tcost[i][i]=0;\n\t\t\tfor(int i=0;i<m;i++)\n\t\t\t{\n\t\t\t\tString str[]=in.next().split(\",\");\n\t\t\t\tint s=Integer.valueOf(str[0]);\n\t\t\t\tint t=Integer.valueOf(str[1]);\n\t\t\t\tint c=Integer.valueOf(str[2]);\n\t\t\t\tcost[s][t]=c;\n\t\t\t\tcost[t][s]=c;\n\t\t\t}\n\t\t\tmincost[0]=0;\n\t\t\tfor(;;)\n\t\t\t{\n\t\t\t\tint v=-1;//追加する頂点\t\t\t\t\n\t\t\t\tfor(int j=0;j<n;j++)//追加する頂点を探す\n\t\t\t\t\tif(!use[j]&&(v==-1||mincost[v]>mincost[j]))\n\t\t\t\t\t\tv=j;\n\t\t\t\tif(v==-1) //全ての頂点を選んだ\n\t\t\t\t\tbreak;\n\t\t\t\tif(mincost[v]!=0)\n\t\t\t\ttotal+=((mincost[v]/100)-1);\n\t\t\t\tuse[v]=true;\n\n\t\t\t\tfor(int j=0;j<n;j++)//追加した頂点と繋がっている辺を調べ最小コストを更新\n\t\t\t\t{\n\t\t\t\t\tif(!use[j]&&mincost[j]>cost[v][j])\n\t\t\t\t\t\tmincost[j]=cost[v][j];\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.*;\nimport java.awt.geom.*;\npublic class Main {\n\tint INF = 1 << 24;\n\n\tprivate void doit(){\n\t\tScanner sc = new Scanner(System.in);\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0) break;\n\t\t\tint m = sc.nextInt();\n\t\t\tint [][] pass = new int[n][n];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tArrays.fill(pass[i], INF);\n\t\t\t\tpass[i][i] = 0;\n\t\t\t}\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString [] s = sc.next().split(\",\");\n\t\t\t\tint from = Integer.parseInt(s[0]);\n\t\t\t\tint to = Integer.parseInt(s[1]);\n\t\t\t\tint cost = Integer.parseInt(s[2]) / 100 - 1;\n\t\t\t\tpass[from][to] = cost;\n\t\t\t\tpass[to][from] = cost;\n\t\t\t}\n\t\t\tint res = mst(pass);\n\t\t\tSystem.out.println(res);\n\t\t}\n\t}\n\n\tprivate int mst(int[][] pass) {\n\t\tint INF = 1 << 24;\n\t\tint n = pass.length;\n\t\tint [] mincost = new int[n];\n\t\tboolean [] isused = new boolean[n];\n\t\tArrays.fill(mincost, INF);\n\n\t\tmincost[0] = 0;\n\t\tint res = 0;\n\t\twhile(true){\n\t\t\tint v = -1;\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tif(! isused[i] &&( v == -1 || mincost[i] < mincost[v])){\n\t\t\t\t\tv = i;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(v == -1) break;\n\t\t\tisused[v] = true;\n\t\t\tres += mincost[v];\n\t\t\tfor(int i = 0; i < n; i++){\n\t\t\t\tmincost[i] = Math.min(mincost[i], pass[v][i]);\n\t\t\t}\n\t\t}\n\t\treturn res;\n\t}\n\n\tpublic static void main(String [] args){\n\t\tnew Main().doit();\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "\nimport java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\n\tpublic static void main(String[] args) {\n\n\t\tnew Main().run();\n\t}\n\n\tprivate void run() {\n\t\tScanner scanner = new Scanner(System.in).useDelimiter(\"[\\\\s,]+\");\n\t\twhile (true) {\n\t\t\tn = scanner.nextInt();\n\t\t\tif (n == 0)\n\t\t\t\tbreak;\n\t\t\tm = scanner.nextInt();\n\t\t\te = new Edge[n];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tint from = scanner.nextInt();\n\t\t\t\tint to = scanner.nextInt();\n\t\t\t\tint cost = scanner.nextInt() / 100 - 1;\n\t\t\t\te[i] = new Edge(from, to, cost);\n\t\t\t}\n\t\t\tSystem.out.println(kruskal());\n\t\t}\n\t}\n\n\tprivate int kruskal() {\n\t\tArrays.sort(e);\n\t\tint ans = 0;\n\t\tUnion union = new Union(n);\n\t\tfor (int i = 0; i < m; i++) {\n\t\t\tEdge edge = e[i];\n\t\t\tif (union.isSame(edge.from, edge.to))\n\t\t\t\tcontinue;\n\t\t\tans += edge.cost;\n\t\t\tunion.unit(edge.from, edge.to);\n\t\t}\n\n\t\treturn ans;\n\t}\n\n\tint n, m;\n\tEdge[] e;\n\n\tclass Union {\n\t\tint[] par, rank;\n\n\t\tpublic Union(int n) {\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tpar[i] = i;\n\t\t}\n\n\t\tint find(int x) {\n\t\t\tif (par[x] == x)\n\t\t\t\treturn x;\n\t\t\treturn par[x] = find(par[x]);\n\n\t\t}\n\n\t\tboolean isSame(int x, int y) {\n\t\t\treturn find(x) == find(y);\n\t\t}\n\n\t\tvoid unit(int x, int y) {\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif (x == y)\n\t\t\t\treturn;\n\t\t\tif (rank[x] < rank[y])\n\t\t\t\tpar[x] = y;\n\t\t\telse {\n\t\t\t\tpar[y] = x;\n\t\t\t\tif (rank[x] == rank[y])\n\t\t\t\t\trank[y]++;\n\t\t\t}\n\t\t}\n\t}\n\n\tclass Edge implements Comparable<Edge> {\n\t\tint from, to, cost;\n\n\t\tpublic Edge(int from, int to, int cost) {\n\t\t\tsuper();\n\t\t\tthis.from = from;\n\t\t\tthis.to = to;\n\t\t\tthis.cost = cost;\n\t\t}\n\n\t\t@Override\n\t\tpublic String toString() {\n\t\t\treturn \"Edge [from=\" + from + \", to=\" + to + \", cost=\" + cost + \"]\";\n\t\t}\n\n\t\t@Override\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn cost - o.cost;\n\t\t}\n\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\n\npublic class Main {\n\tprivate Scanner sc;\n\n\tprivate int[][] pathv;\n\tpublic static void main(String[] args) {\n\t\tnew Main();\n\t}\n\t\n\tpublic Main() {\n\t\tsc = new Scanner(System.in);\n\t\t\n\t\twhile (sc.hasNextLine()) {\n\t\t\tint n = Integer.parseInt(sc.nextLine());\n\t\t\tif (n == 0) break;\n\t\t\t\n\t\t\tint m = Integer.parseInt(sc.nextLine());\n\n\t\t\tint[][] path = new int[m][4];\n\n\t\t\tpathv = new int[n][n];\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\tpathv[i][j] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 0; i < path.length; i++) {\n\t\t\t\tString[] nico = sc.nextLine().split(\",\");\n\n\t\t\t\tfor (int j = 0; j < 3; j++) {\n\t\t\t\t\tpath[i][j] = Integer.parseInt(nico[j]);\n\t\t\t\t}\n\t\t\t\tpath[i][2] = path[i][2] / 100 - 1;\n\t\t\t\tpath[i][3] = 0;\n\t\t\t\t\n\t\t\t\tpathv[path[i][0]][path[i][1]] = path[i][2];\t\t\t\t\n\t\t\t\tpathv[path[i][1]][path[i][0]] = path[i][2];\n\t\t\t\tSystem.out.println(path[i][2]);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tboolean[] flag = new boolean[n];\n\t\t\tfor (int i = 0; i < flag.length; i++) {\n\t\t\t\tflag[i] = false;\n\t\t\t}\n\t\t\tflag[path[0][0]] = true;\n\t\t\tflag[path[0][1]] = true;\n\n\t\t\tint total = path[0][2];\n\t\t\t\n\t\t\tint marked = 2;\n\t\t\twhile (marked != n) {\n\t\t\t\tfor (int i = 1; i < path.length; i++) {\n\t\t\t\t\tif (flag[path[i][0]] != flag[path[i][1]]) {\n\t\t\t\t\t\tflag[path[i][0]] = true;\n\t\t\t\t\t\tflag[path[i][1]] = true;\n\t\t\t\t\t\ttotal = total + path[i][2];\n\t\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t\t\t\n\t\t\t\t\t\tmarked++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tfor (int i = 1; i < path.length; i++) {\n\t\t\t\tif (path[i][3] == 0) {\n\t\t\t\t\tint max = path[i][2];\n\t\t\t\t\t\n\t\t\t\t\tfor (int j = 0; j < n; j++) {\n\t\t\t\t\t\tif ((max < pathv[path[i][0]][j]) && (check(j) >= 2)) max = pathv[path[i][0]][j];\n\t\t\t\t\t\tif ((max < pathv[path[i][1]][j]) && (check(j) >= 2)) max = pathv[path[i][1]][j];\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\ttotal = total + path[i][2] - max;\n\t\t\t\t\tpath[i][3] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(total);\n\t\t}\n\t}\n\t\n\tprivate int check(int index) {\n\t\tint ans = 0;\n\t\tfor (int i = 0; i < pathv.length; i++) {\n\t\t\tif (pathv[index][i] != 0) ans++;\n\t\t}\n\t\t\n\t\treturn ans;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.HashSet;\nimport java.util.PriorityQueue;\nimport java.util.Queue;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\t\n\tpublic static class Path implements Comparable<Path>{\n\t\tprivate int to,from,len;\n\t\t\n\t\tpublic Path(int f,int t,int l){\n\t\t\tfrom = f;\n\t\t\tto = t;\n\t\t\tlen = l;\n\t\t}\n\t\t\n\t\tpublic int get_from(){\n\t\t\treturn from;\n\t\t}\n\t\t\n\t\tpublic int get_to(){\n\t\t\treturn to;\n\t\t}\n\t\t\n\t\tpublic int get_len(){\n\t\t\treturn len;\n\t\t}\n\t\t\n\t\tpublic int compareTo(Path p){\n\t\t\treturn this.get_len() - p.get_len(); \t\n\t\t}\n\t\t\n\t\tpublic String toString(){\n\t\t\treturn \"From \" + from + \". To \" + to + \". len \" + len +\".\";\n\t\t}\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tScanner sc = new Scanner(System.in);\n\t\t\n\t\twhile(true){\n\t\t\tint n = sc.nextInt();\n\t\t\tif(n == 0){break;}\n\t\t\tint m = sc.nextInt();\n\t\t\t\n\t\t\tQueue<Path> queue = new PriorityQueue<Path>();\n\t\t\tSet<Integer> visited_place = new HashSet<Integer>(n);\n\t\t\t\n\t\t\tfor(int i = 0; i < m; i++){\n\t\t\t\tString strs[] = sc.next().split(\",\");\n\t\t\t\tqueue.add(new Path(Integer.parseInt(strs[0]),Integer.parseInt(strs[1]),Integer.parseInt(strs[2])));\n\t\t\t}\n\t\t\t\n\t\t\tint sum = 0;\n\t\t\t\n\t\t\twhile(visited_place.size() != n){\n\t\t\t\tPath p = queue.poll();\n\t\t\t\tif(visited_place.contains(p.get_from()) && visited_place.contains(p.get_to())){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvisited_place.add(p.get_from());\n\t\t\t\tvisited_place.add(p.get_to());\n\t\t\t\tsum += p.get_len()/100 - 1;\n\t\t\t}\n\t\t\t\n\t\t\tSystem.out.println(sum);\n\t\t\t\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.Scanner;\n\npublic class Main {\n\tstatic class Edge implements Comparable<Edge>{\n\t\tint v1, v2;\n\t\tint weight;\n\n\t\tEdge (int v1, int v2, int weight) {\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.weight = weight / 100 - 1;\n\t\t}\n\n\t\tpublic int compareTo(Edge o) {\n\t\t\treturn this.weight - o.weight;\n\t\t}\n\t}\n\n\tstatic class Vertex {\n\t\tVertex parent;\n\n\t\tVertex () {\n\t\t\tthis.parent = this;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tVertex vertex[];\n\t\tEdge edge[];\n\t\tint sumWeight;\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\tm = sc.nextInt();\n\t\t\tvertex = new Vertex[n];\n\t\t\tedge = new Edge[m];\n\t\t\tsumWeight = 0;\n\t\t\t\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tvertex[i] = new Vertex();\n\t\t\t}\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tedge[i] = new Edge(Integer.parseInt(s[0]), Integer.parseInt(s[1]), Integer.parseInt(s[2]));\n\t\t\t}\n\t\t\tArrays.sort(edge);\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (find(vertex[edge[i].v1]) != (find(vertex[edge[i].v2]))) {\n\t\t\t\t\tsumWeight += edge[i].weight;\n\t\t\t\t\tunion(vertex[edge[i].v1], vertex[edge[i].v2]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sumWeight);\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static Vertex find(Vertex vertex) {\n\t\tif (vertex.parent == vertex) {\n\t\t\treturn vertex;\n\t\t} else {\n\t\t\treturn find(vertex.parent);\n\t\t}\n\t}\n\t\n\tpublic static void union (Vertex v1, Vertex v2) {\n\t\tVertex vertex1 = find(v1);\n\t\tVertex vertex2 = find(v2);\n\t\tvertex1.parent = vertex2;\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scan.nextInt();\n\t\t\tint[][] cost = new int[n][n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tfor(int j = 0;j < n;j++){\n\t\t\t\t\tcost[i][j] = Integer.MAX_VALUE;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\tint a = Integer.parseInt(str[0]);\n\t\t\t\tint b = Integer.parseInt(str[1]);\n\t\t\t\tint c = Integer.parseInt(str[2]);\n\t\t\t\tcost[a][b] = c;\n\t\t\t\tcost[b][a] = c;\n\t\t\t}\n\t\t\tint count = 0;\n\t\t\tint min = 0;\n\t\t\tint ti = 0;\n\t\t\tint tj = 0;\n\t\t\tboolean[] fl = new boolean[n];\n\t\t\tfor(int i = 0;i < n-1;i++){\n\t\t\t\tmin = 0;\n\t\t\t\tfor(int j = i+1;j < n;j++){\n\t\t\t\t\tif(cost[i][j] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(min == 0 || min > cost[i][j]){\n\t\t\t\t\t\tmin = cost[i][j];\n\t\t\t\t\t\tti = i;\n\t\t\t\t\t\ttj = j;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(min != 0){\n\t\t\t\t\tcount += min/100 - 1;\n\t\t\t\t\tfl[ti] = true;\n\t\t\t\t\tfl[tj] = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tif(fl[i]){\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tmin = 0;\n\t\t\t\tfor(int j = 0;j < i;j++){\n\t\t\t\t\tif(cost[j][i] == Integer.MAX_VALUE){\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif(min == 0 || min > cost[j][i]){\n\t\t\t\t\t\tmin = cost[j][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(min != 0){\n\t\t\t\t\tcount += min/100 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(count);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\nimport java.util.TreeSet;\n\npublic class Main {\n\tstatic class Edge {\n\t\tint v1, v2;\n\t\tint weight;\n\t\tboolean mark;\n\n\t\tEdge (int v1, int v2, int weight) {\n\t\t\tthis.v1 = v1;\n\t\t\tthis.v2 = v2;\n\t\t\tthis.weight = weight;\n\t\t\tthis.mark = false;\n\t\t}\n\t}\n\n\tpublic static void main(String args[]) {\n\t\tScanner sc = new Scanner(System.in);\n\t\tint n, m;\n\t\tint vertex[];\n\t\tEdge edge[];\n\t\tTreeSet<Integer> set[];\n\n\t\tn = sc.nextInt();\n\t\twhile (n != 0) {\n\t\t\tm = sc.nextInt();\n\t\t\tset = new TreeSet[n];\n\t\t\tvertex = new int[n];\n\t\t\tedge = new Edge[m];\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tString s[] = sc.next().split(\",\");\n\t\t\t\tedge[i] = new Edge(Integer.valueOf(s[0]), Integer.valueOf(s[1]), Integer.valueOf(s[2]));\n\t\t\t}\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tset[i] = new TreeSet<Integer>();\n\t\t\t\tset[i].add(i);\n\t\t\t\tvertex[i] = i;\n\t\t\t}\n\t\t\tsort(edge, 0, m - 1);\n\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (vertex[edge[i].v1] != vertex[edge[i].v2]) {\n\t\t\t\t\tedge[i].mark = true;\n\t\t\t\t\tint num1 = vertex[edge[i].v1];\n\t\t\t\t\tint num2 = vertex[edge[i].v2];\n\t\t\t\t\tset[num1].addAll(set[num2]);\n\t\t\t\t\twhile (!set[num2].isEmpty()) {\n\t\t\t\t\t\tvertex[set[num2].first()] = num1;\n\t\t\t\t\t\tset[num2].remove(set[num2].first());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tint sum = 0;\n\t\t\tfor (int i = 0; i < m; i++) {\n\t\t\t\tif (edge[i].mark) {\n\t\t\t\t\tsum += ((edge[i].weight - 100) / 100);\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(sum);\n\n\t\t\tn = sc.nextInt();\n\t\t}\n\t}\n\n\tpublic static void sort(Edge edge[], int low, int high) {\n\t\tif (high <= low) {\n\t\t\treturn ;\n\t\t}\n\t\tint i = low;\n\t\tint j = high;\n\t\tint x = edge[(low + high) / 2].weight;\n\t\twhile (i <= j) {\n\t\t\twhile (edge[i].weight < x) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t\twhile (x < edge[j].weight) {\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tif (i <= j) {\n\t\t\t\tEdge swap = new Edge(edge[i].v1, edge[i].v2, edge[i].weight);\n\t\t\t\tedge[i] = edge[j];\n\t\t\t\tedge[j] = swap;\n\t\t\t\ti++;\n\t\t\t\tj--;\n\t\t\t}\n\t\t\tsort(edge, low, j);\n\t\t\tsort(edge, i, high);\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Scanner;\npublic class Main{\n\tpublic static void main(String[] args){\n        new Main().run();\n    }\n\tpublic void run(){\n\t\tScanner scan = new Scanner(System.in);\n\t\twhile(scan.hasNext()){\n\t\t\tint n = scan.nextInt();\n\t\t\tif(n == 0){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tint m = scan.nextInt();\n\t\t\tUnionFind uf = new UnionFind(n);\n\t\t\tedge[] e = new edge[m];\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tString[] str = scan.next().split(\",\");\n\t\t\t\te[i] = new edge(Integer.parseInt(str[0]),Integer.parseInt(str[1]),Integer.parseInt(str[2])/100-1);\n\t\t\t}\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tfor(int j = m-1;j > i;j--){\n\t\t\t\t\tif(e[j-1].cost > e[j].cost){\n\t\t\t\t\t\tswap(e,j,j-1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tint min = 0;\n\t\t\tfor(int i = 0;i < m;i++){\n\t\t\t\tif(!uf.same(e[i].u,e[i].v)){\n\t\t\t\t\tuf.unite(e[i].u,e[i].v);\n\t\t\t\t\tmin += e[i].cost;\n\t\t\t\t}\n\t\t\t}\n\t\t\tSystem.out.println(min);\n\t\t}\n\t}\n\tpublic void swap(edge[] e,int i,int j){\n\t\tedge t = e[j];e[j] = e[i];e[i] = t;\n\t}\n\tpublic class UnionFind{\n\t\tint[] par;\n\t\tint[] rank;\n\t\tpublic UnionFind(int n){\n\t\t\tpar = new int[n];\n\t\t\trank = new int[n];\n\t\t\tfor(int i = 0;i < n;i++){\n\t\t\t\tpar[i] = i;\n\t\t\t\trank[i] = 0;\n\t\t\t}\n\t\t}\n\t\tpublic int find(int x){\n\t\t\tif(par[x] == x){\n\t\t\t\treturn x;\n\t\t\t}else{\n\t\t\t\treturn par[x] = find(par[x]);\n\t\t\t}\n\t\t}\n\t\tpublic void unite(int x,int y){\n\t\t\tx = find(x);\n\t\t\ty = find(y);\n\t\t\tif(x == y){\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif(rank[x] < rank[y]){\n\t\t\t\tpar[x] = y;\n\t\t\t}else{\n\t\t\t\tpar[y] = x;\n\t\t\t\tif(rank[x] == rank[y]){\n\t\t\t\t\trank[x]++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tpublic boolean same(int x,int y){\n\t\t\treturn find(x) == find(y);\n\t\t}\n\t}\n\tpublic class edge{\n\t\tint u;\n\t\tint v;\n\t\tint cost;\n\t\tpublic edge(int u,int v,int cost){\n\t\t\tthis.u = u;\n\t\t\tthis.v = v;\n\t\t\tthis.cost = cost;\n\t\t}\n\t}\n}"
  },
  {
    "language": "Java",
    "code": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Scanner;\nimport java.util.Set;\n\n\npublic class Main {\n\n\tfinal int INF=1<<30;\n\tint adjacent[][];\n\tScanner sc;\n\tint n;\n\t\n\tint solve(){\n\t\tint cost=0;\n\t\tSet<Integer> vertex=new HashSet<Integer>();\n\t\tvertex.add(0);\n\t\t\n\t\tfor(int h=0;h<n;++h){\n\t\t\tint min=INF,e=0;\n\t\t\tfor(int v:vertex){\n\t\t\t\tfor(int i=0;i<n;++i){\n\t\t\t\t\tif(vertex.contains(i))continue;\n\t\t\t\t\tif(adjacent[v][i]<min){\n\t\t\t\t\t\tmin=adjacent[v][i];\n\t\t\t\t\t\te=i;\n\t\t\t\t\t\tSystem.out.println(cost+\" \"+v+\" \"+i+\" \"+min);\n\t\t\t\t\t}\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min<INF){\n\t\t\t\tvertex.add(e);\n\t\t\t\tcost+=min/100-1;\t\n\t\t\t}\n\t\t}\n\t\treturn cost;\n\t}\n\t\n\tint ni(){\n\t\treturn sc.nextInt();\n\t}\n\t\n\tvoid io(){\n\t\tsc=new Scanner(System.in).useDelimiter(\"\\\\s*,\\\\s*|\\r\\n\");\n\t\t\n\t\twhile((n=ni())!=0){\n\t\t\tadjacent=new int[n][n];\n\t\t\tfor(int i=0;i<n;++i){Arrays.fill(adjacent[i],INF);}\n\t\t\tint m=ni();\n\t\t\tfor(int i=0;i<m;++i){\n\t\t\t\tint a=ni(),b=ni(),d=ni();\n\t\t\t\tadjacent[a][b]=adjacent[b][a]=d;\n\t\t\t}\n\t\t\tSystem.out.println(solve());\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\t\tnew Main().io();\n\t}\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace _0072\n{\n    public class Program\n\n    {\n        static public Dictionary<int, Info> Adj { get; set; }\n        public class Info\n        {\n            public bool IsVisited { get; internal set; }\n            public List<KeyValuePair<int, int>> Vertex { get; internal set; }\n            public Info() { Vertex = new List<KeyValuePair<int, int>>(); }\n        }\n\n        public static void Main(string[] args)\n        {\n            while (true)\n            {\n                int n = RInt();\n                if (n == 0) break;\n\n                int m = RInt();\n                Adj = new Dictionary<int, Info>(m);\n                for (int i = 0 ; i < m ; i++)\n                {\n                    int[] items = RIntAr(',');\n\n                    if (!Adj.ContainsKey(items[0])) { Adj.Add(items[0], new Info()); }\n                    Adj[items[0]].Vertex.Add(new KeyValuePair<int, int>(items[1], items[2] / 100 -1));\n\n                    if (!Adj.ContainsKey(items[1])) { Adj.Add(items[1], new Info()); }\n                    Adj[items[1]].Vertex.Add(new KeyValuePair<int, int>(items[0], items[2] / 100 -1));\n\n                }\n\n                Console.WriteLine(Prim());\n            }\n\n        }\n\n        /// <summary>\n        /// 最小全域木のコストを求める（プリム法）\n        /// </summary>\n        /// <returns></returns>\n        class Edge : IComparable<Edge>\n        {\n            public int NextV { get; set; }\n            public int Cost { get; set; }\n\n            public Edge(int nextV, int cost)\n            {\n                NextV = nextV;\n                Cost = cost;\n            }\n\n            public int CompareTo(Edge other)\n            {\n                return -1 * Cost.CompareTo(other.Cost);\n            }\n        }\n        public static int Prim()\n        {\n            PriorityQueue<Edge> pq = new PriorityQueue<Edge>();\n            int totalCost = 0;\n            pq.Enqueue(new Edge(Adj.First().Key, 0));\n\n            while (pq.Count > 0)\n            {\n                Edge e = pq.Dequeue();\n                if (!Adj[e.NextV].IsVisited)\n                {\n                    Adj[e.NextV].IsVisited = true;\n                    totalCost += e.Cost;\n                    foreach (KeyValuePair<int, int> vertex in Adj[e.NextV].Vertex)\n                    {\n                        pq.Enqueue(new Edge(vertex.Key, vertex.Value));\n                    }\n                }\n            }\n            return totalCost;\n        }\n\n        static string RSt() { return Console.ReadLine(); }\n        static int RInt() { return int.Parse(Console.ReadLine().Trim()); }\n        static long RLong() { return long.Parse(Console.ReadLine().Trim()); }\n        static double RDouble() { return double.Parse(Console.ReadLine()); }\n        static string[] RStAr(char sep = ' ') { return Console.ReadLine().Trim().Split(sep); }\n        static int[] RIntAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => int.Parse(e)); }\n        static long[] RLongAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => long.Parse(e)); }\n        static double[] RDoubleAr(char sep = ' ') { return Array.ConvertAll(Console.ReadLine().Trim().Split(sep), e => double.Parse(e)); }\n        static string WAr<T>(IEnumerable<T> array, string sep = \" \") { return string.Join(sep, array.Select(x => x.ToString()).ToArray()); }\n    }\n\n    public class PriorityQueue<T> where T : IComparable<T>\n\n    {\n\n        private List<T> Buffer { get; set; }\n\n        public int Count { get { return Buffer.Count; } }\n\n        public PriorityQueue() { Buffer = new List<T>(); }\n        public PriorityQueue(int capacity) { Buffer = new List<T>(capacity); }\n\n\n        /// <summary>\n        /// ヒープ化されている配列リストに新しい要素を追加する。\n        /// </summary>\n        public void Enqueue(T item)\n        {\n            int n = Buffer.Count;\n            Buffer.Add(item);\n\n            while (n != 0)\n            {\n                int i = (n - 1) / 2;\n                if (Buffer[n].CompareTo(Buffer[i]) > 0)\n                {\n                    T tmp = Buffer[n]; Buffer[n] = Buffer[i]; Buffer[i] = tmp;\n                }\n                n = i;\n            }\n        }\n\n        /// <summary>\n        /// ヒープから最大値を取り出し、削除する。\n        /// </summary>\n        public T Dequeue()\n        {\n            T ret = Buffer[0];\n            int n = Buffer.Count - 1;\n            Buffer[0] = Buffer[n];\n            Buffer.RemoveAt(n);\n\n            for (int i = 0, j ; (j = 2 * i + 1) < n ;)\n            {\n                if ((j != n - 1) && (Buffer[j].CompareTo(Buffer[j + 1]) < 0))\n                    j++;\n                if (Buffer[i].CompareTo(Buffer[j]) < 0)\n                {\n                    T tmp = Buffer[j]; Buffer[j] = Buffer[i]; Buffer[i] = tmp;\n                }\n                i = j;\n            }\n            return ret;\n        }\n\n        /// <summary>\n        /// ヒープから最大値を参照する。\n        /// </summary>\n        public T Peek()\n        {\n            if (Count == 0) throw new InvalidOperationException();\n            return this.Buffer[0];\n        }\n    }\n\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\n\npublic class Edge : IComparable\n{\n    public int to { get; set; }\n    public int d { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (Edge)obj;\n        return this.d - x.d;\n    }\n}\n\npublic class C\n{\n    public const int INF = 999999999;\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var m = int.Parse(Console.ReadLine().Trim());\n            var r = new List<Edge>[n];\n            var minc = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                r[i] = new List<Edge>();\n                minc[i] = C.INF;\n            }\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(',');\n                var a = int.Parse(line2[0]);\n                var b = int.Parse(line2[1]);\n                var d = int.Parse(line2[2]) / 100;\n                r[a].Add(new Edge { to = b, d = d });\n                r[b].Add(new Edge { to = a, d = d });\n            }\n            goPrim(r, minc, 0, m);\n            Console.WriteLine(minc.Sum() - n + 1);\n        }\n    }\n    public static void goPrim(List<Edge>[] r, int[] minc, int targ, int m)\n    {\n        var pq = new PriorityQueue<Edge>(m * 2 + 1000);\n        var n = minc.Length;\n        var xL = new List<int>();\n        xL.Add(targ); minc[targ] = 0;\n        foreach (var x in r[targ]) pq.Push(x);\n        while (xL.Count() < n)\n        {\n            var e = pq.Pop();\n            if (!xL.Contains(e.to))\n            {\n                xL.Add(e.to);\n                minc[e.to] = e.d;\n                foreach (var x in r[e.to])\n                    if (!xL.Contains(x.to)) pq.Push(x);\n            }\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class C\n{\n    public const int INF = 999999999;\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var r = new int[n, n];\n            var minc = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                minc[i] = C.INF;\n                for (int j = 0; j < n; j++) r[i, j] = C.INF;\n            }\n            var m = int.Parse(Console.ReadLine().Trim());\n            for (int i = 0; i < m; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(',');\n                var a = int.Parse(line[0]);\n                var b = int.Parse(line[1]);\n                var d = int.Parse(line[2]) / 100;\n                r[a, b] = d; r[b, a] = d;\n            }\n            goPrim(r, minc, 0);\n            Console.WriteLine(minc.Sum() - n + 1);\n        }\n    }\n    public static void goPrim(int[,] r, int[] minc, int targ)\n    {\n        var n = r.GetLength(0);\n        var xL = new List<int>();\n        xL.Add(targ);  minc[targ] = 0;\n        var count = 0;\n        while (count++ < n)\n        {\n            for (int i = 0; i < n; i++)\n                if (!xL.Contains(i) && r[targ, i] != C.INF && r[targ, i] < minc[i]) minc[i] = r[targ, i];\n            var mint = C.INF; var minb = -1;\n            for (int i = 0; i < n; i++)\n                if (!xL.Contains(i) && minc[i] < mint) {  mint =  minc[i] ; minb = i; }\n            xL.Add(minb);\n            targ = minb;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Text.RegularExpressions;\nusing static System.Math;\n\nnamespace CSharpSpiral {\n    class Program {\n        static void Main(string[] args) {\n            var sw = new StreamWriter(Console.OpenStandardOutput()) { AutoFlush = false };\n            Console.SetOut(sw);\n            new Program().Solve(new ConsoleInput(Console.In, ' '));\n            Console.Out.Flush();\n        }\n\t\tpublic void Solve(ConsoleInput cin) {\n\t\t\twhile(true){\n\t\t\t\tvar vert = cin.ReadInt;\n\t\t\t\tif(vert == 0) break;\n\t\t\t\tvar G = new Graph(vert);\n\t\t\t\tvar roadC = cin.ReadInt;\n\t\t\t\tfor(int i = 0; i < roadC; i++) {\n\t\t\t\t\tvar line = cin.ReadLine.Split(',').Select(int.Parse).ToArray();\n\t\t\t\t\tvar cost = line[2] / 100 - 1;\n\t\t\t\t\tG.AddEdge(line[0], line[1], cost);\n\t\t\t\t\tG.AddEdge(line[1], line[0], cost);\n\t\t\t\t}\n\t\t\t\tGraph T;\n\t\t\t\tConsole.WriteLine(G.Prim(out T));\n\t\t\t}\n\t\t}\n\n\t}\n\tstatic class ExtendClass {\n\t\tpublic static string Join<T>(this IEnumerable<T> X, string separator = \" \") => string.Join(separator, X);\n\t}\n\tclass ConsoleInput {\n\t\tprivate readonly TextReader _stream;\n\t\tprivate readonly char _separator = ' ';\n\t\tprivate readonly Queue<string> inputStream;\n\t\tpublic ConsoleInput(TextReader stream, char separator = ' ') {\n\t\t\tthis._separator = separator;\n\t\t\tthis._stream = stream;\n\t\t\tinputStream = new Queue<string>();\n\t\t}\n\t\tpublic string Read {\n\t\t\tget {\n\t\t\t\tif(inputStream.Count != 0) return inputStream.Dequeue();\n\t\t\t\tstring[] tmp = _stream.ReadLine().Split(_separator);\n\t\t\t\tfor(int i = 0; i < tmp.Length; ++i)\n\t\t\t\t\tinputStream.Enqueue(tmp[i]);\n\t\t\t\treturn inputStream.Dequeue();\n\t\t\t}\n\t\t}\n\t\tpublic string ReadLine { get { return _stream.ReadLine(); } }\n\t\tpublic int ReadInt { get { return int.Parse(Read); } }\n\t\tpublic long ReadLong { get { return long.Parse(Read); } }\n\t\tpublic double ReadDouble { get { return double.Parse(Read); } }\n\t\tpublic string[] ReadStrArray(long N) {\n\t\t\tvar ret = new string[N];\n\t\t\tfor(long i = 0; i < N; ++i)\n\t\t\t\tret[i] = Read;\n\t\t\treturn ret;\n\t\t}\n\t\tpublic int[] ReadIntArray(long N) { var ret = new int[N]; for(long i = 0; i < N; ++i) ret[i] = ReadInt; return ret; }\n\t\tpublic long[] ReadLongArray(long N) { var ret = new long[N]; for(long i = 0; i < N; ++i) ret[i] = ReadLong; return ret; }\n\t\tpublic double[] ReadDoubleArray(long N) { var ret = new double[N]; for(long i = 0; i < N; ++i) ret[i] = ReadDouble; return ret; }\n\t}\n\n\tclass PriorityQueue<T> where T : IComparable<T> {\n\t\tprotected readonly List<T> body = new List<T>();\n\t\tprotected Comparer<T> comparer { get; set; }\n\t\tpublic PriorityQueue(bool maxTop = true) {\n\t\t\tcomparer\n\t\t\t= maxTop ? Comparer<T>.Create((T i, T j) => i.CompareTo(j))\n\t\t\t: Comparer<T>.Create((T i, T j) => j.CompareTo(i));\n\t\t}\n\t\tpublic PriorityQueue(Comparer<T> mComparer) { comparer = mComparer; }\n\t\t//suppose Me>Her if isRootMaximum\n\t\tprotected int Compare(T Me, T Her) => comparer.Compare(Me, Her);\n\t\tprotected int Compare(int x, int y) => Compare(body[x], body[y]);\n\t\tprotected virtual void Swap(int x, int y) { T tmp = body[x]; body[x] = body[y]; body[y] = tmp; }\n\t\tpublic virtual void Push(T elem) {\n\t\t\tbody.Add(elem);\n\t\t\t//the parent of n-th element is the ((n+1)>>1)-1-th\n\t\t\tUpHeap(lastIndex);\n\t\t}\n\t\tpublic void Push(IEnumerable<T> seq) {\n\t\t\tforeach(var item in seq) {\n\t\t\t\tPush(item);\n\t\t\t}\n\t\t}\n\t\tprotected int UpHeap(int j) {\n\t\t\twhile(j > 0) {\n\t\t\t\tint parent = ((j + 1) >> 1) - 1;\n\t\t\t\tif(Compare(parent, j) < 0) {\n\t\t\t\t\tSwap(parent, j);\n\t\t\t\t} else break;\n\t\t\t\tj = parent;\n\t\t\t}\n\t\t\treturn j;\n\t\t}\n\t\tpublic virtual T Pop() {\n\t\t\tT top = body[0];\n\t\t\tSwap(0, lastIndex);\n\t\t\tbody.RemoveAt(lastIndex);\n\t\t\tDownHeap(0);\n\t\t\treturn top;\n\t\t}\n\t\tprotected int DownHeap(int j) {\n\t\t\twhile(j < length) {\n\t\t\t\tvar leftChild = ((j + 1) << 1) - 1;\n\t\t\t\tif(leftChild >= length) break;\n\t\t\t\tvar toSwap = leftChild;\n\t\t\t\tvar rightChild = leftChild + 1;\n\t\t\t\tif(rightChild < length && Compare(leftChild, rightChild) < 0)\n\t\t\t\t\ttoSwap = rightChild;\n\t\t\t\tif(Compare(j, toSwap) < 0) {\n\t\t\t\t\tSwap(toSwap, j);\n\t\t\t\t} else break;\n\t\t\t\tj = toSwap;\n\t\t\t}\n\t\t\treturn j;\n\t\t}\n\t\tpublic T Top { get { return body[0]; } }\n\t\tpublic int length { get { return body.Count(); } }\n\t\tprotected int lastIndex { get { return body.Count() - 1; } }\n\t\tpublic bool Any() => body.Any();\n\t\tpublic string Emit() { return body.ToArray().Join(\",\"); }\n\t}\n\tclass Graph: Graph<long> {\n\t\tpublic Graph(int count) : base(count) { }\n\t\tpublic long Prim(out Graph tree, int start = 0) {\n\t\t\ttree = new Graph(N);\n\t\t\tvar res = 0L;\n\t\t\tvar PQ = new PriorityQueue<Edge<long>>(false);\n\t\t\tvar O = Outs;\n\t\t\tPQ.Push(O[start]);\n\t\t\tvar picked = new bool[N];\n\t\t\tpicked[start] = true;\n\t\t\twhile(PQ.Any()) {\n\t\t\t\tvar e = PQ.Pop();\n\t\t\t\tvar w = e.Out;\n\t\t\t\tif(picked[w]) continue;\n\t\t\t\telse picked[w] = true;\n\t\t\t\tres += e.cost;\n\t\t\t\ttree.Edges.Add(e);\n\t\t\t\tPQ.Push(O[w]);\n\t\t\t}\n\t\t\treturn res;\n\t\t}\n\t}\n\tclass Graph<V> where V : IComparable<V> {\n\t\tpublic int N { get; }\n\t\tpublic Graph(int count) {\n\t\t\tN = count;\n\t\t\tEdges = new List<Edge<V>>();\n\t\t}\n\t\tpublic List<Edge<V>> Edges { get; }\n\t\tpublic void AddEdge(int In, int Out, V Value) {\n\t\t\tvar e = new Edge<V> { In = In, Out = Out, cost = Value };\n\t\t\tEdges.Add(e);\n\t\t}\n\t\tprotected List<Edge<V>>[] Outs {\n\t\t\tget {\n\t\t\t\tvar Res = new List<Edge<V>>[N];\n\t\t\t\tfor(int i = 0; i < N; i++)\n\t\t\t\t\tRes[i] = new List<Edge<V>>();\n\t\t\t\tforeach(var e in Edges)\n\t\t\t\t\tRes[e.In].Add(e);\n\t\t\t\treturn Res;\n\t\t\t}\n\t\t}\n\t}\n\tclass Edge<V>: IComparable<Edge<V>> where V : IComparable<V> {\n\t\tpublic int In { get; set; }\n\t\tpublic int Out { get; set; }\n\t\tpublic V cost { get; set; }\n\t\tpublic int CompareTo(Edge<V> y) => cost.CompareTo(y.cost);\n\t}\n}\n\n"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic struct Edge\n{\n    public int to { get; set; }\n    public int d { get; set; }\n}\n\npublic class C\n{\n    public const int INF = 999999999;\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var m = int.Parse(Console.ReadLine().Trim());\n            var r = new List<Edge>[n];\n            var minc = new int[n];\n            for (int i = 0; i < n; i++)\n            {\n                r[i] = new List<Edge>();\n                minc[i] = C.INF;\n            }\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(',');\n                var a = int.Parse(line2[0]);\n                var b = int.Parse(line2[1]);\n                var d = int.Parse(line2[2]) / 100;\n                r[a].Add(new Edge { to = b, d = d });\n                r[b].Add(new Edge { to = a, d = d });\n            }\n            goPrim(r, minc, 0);\n            Console.WriteLine(minc.Sum() - n + 1);\n        }\n    }\n    public static void goPrim(List<Edge>[] r, int[] minc, int targ)\n    {\n        var n = minc.Length;\n        var xL = new List<int>();\n        xL.Add(targ); minc[targ] = 0;\n        while (xL.Count() <= n)\n        {\n            foreach (var x in r[targ])\n                if (!xL.Contains(x.to) && x.d < minc[x.to]) minc[x.to] = x.d;\n            var mint = C.INF; var minb = -1;\n            for (int i = 0; i < n; i++)\n                if (!xL.Contains(i) && minc[i] < mint) { mint = minc[i]; minb = i; }\n            xL.Add(minb);\n            targ = minb;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Edge\n    {\n        internal int from, to, cost;\n\n        public Edge(int from, int to, int cost)\n        {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    class Union_Find\n    {\n        internal int[] parents, rank;\n\n        public Union_Find(int n)\n        {\n            parents = Enumerable.Range(0, n).ToArray();\n            rank = new int[n];\n        }\n\n        public int Find(int x)\n        {\n            if (parents[x] == x) return x;\n            else return parents[x] = Find(parents[x]);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Find(x);\n            y = Find(y);\n\n            if (x == y) return;\n\n            if (rank[x] < rank[y])\n            {\n                parents[x] = y;\n            }\n            else\n            {\n                parents[y] = x;\n                if (rank[x] == rank[y]) rank[x]++;\n            }\n        }\n\n        public bool Same(int x, int y)\n        {\n            return Find(x) == Find(y);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            StringBuilder sb = new StringBuilder();\n\n            while (true)\n            {\n                int V = int.Parse(Console.ReadLine());\n\n                if (V == 0) break;\n\n                int E = int.Parse(Console.ReadLine());\n\n                Edge[] edges = new Edge[E];\n\n                for (int i = 0; i < E; i++)\n                {\n                    string[] input = Console.ReadLine().Split(',');\n                    int s = int.Parse(input[0]);\n                    int t = int.Parse(input[1]);\n                    int w = int.Parse(input[2]) / 100 - 1;\n\n                    edges[i] = new Edge(s, t, w);\n                }\n                sb.AppendLine(Kruskal(edges, V).ToString());\n            }\n            Console.Write(sb);\n        }\n\n        static int Kruskal(Edge[] edges, int V)\n        {\n            Array.Sort(edges, (a, b) => a.cost - b.cost);\n\n            Union_Find UF = new Union_Find(V);\n\n            int totalCost = 0;\n\n            for (int i = 0; i < edges.Length; i++)\n            {\n                Edge e = edges[i];\n\n                if (!UF.Same(e.from, e.to))\n                {\n                    UF.Unite(e.from, e.to);\n                    totalCost += e.cost;\n                }\n            }\n            return totalCost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class C\n{\n    public const int INF = 999999999;\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var r = new int[n, n];\n            for (int i = 0; i < n; i++)\n                for (int j = 0; j < n; j++)\n                    if (i != j) r[i, j] = C.INF;\n            var m = int.Parse(Console.ReadLine().Trim());\n            for (int i = 0; i < m; i++)\n            {\n                string[] line = Console.ReadLine().Trim().Split(',');\n                var a = int.Parse(line[0]);\n                var b = int.Parse(line[1]);\n                var d = int.Parse(line[2]) / 100;\n                r[a, b] = d; r[b, a] = d;\n            }\n            var minc = new int[n];\n            for (int i = 0; i < n; i++) minc[i] = C.INF;\n            goPrim(r, minc, 0);\n            Console.WriteLine(minc.Sum() - n + 1);\n        }\n    }\n    public static void goPrim(int[,] r, int[] minc, int targ)\n    {\n        var n = r.GetLength(0);\n        var xL = new List<int>();\n        xL.Add(targ);  minc[targ] = 0;\n        var count = 0;\n        while (count < n)\n        {\n            for (int i = 0; i < n; i++)\n                if (!xL.Contains(i) && r[targ, i] != C.INF && r[targ, i] < minc[i]) minc[i] = r[targ, i];\n            var mint = C.INF; var minb = -1;\n            for (int i = 0; i < n; i++)\n                if (!xL.Contains(i) && minc[i] < mint) {  mint =  minc[i] ; minb = i; }\n            xL.Add(minb);\n            targ = minb;\n            count++;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace ConsoleApplication1\n{\n    class Edge\n    {\n        internal int from, to, cost;\n\n        public Edge(int from, int to, int cost)\n        {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    class Union_Find\n    {\n        internal int[] parents, rank;\n\n        public Union_Find(int n)\n        {\n            parents = Enumerable.Range(0, n).ToArray();\n            rank = new int[n];\n        }\n\n        public int Find(int x)\n        {\n            if (parents[x] == x) return x;\n            else return parents[x] = Find(parents[x]);\n        }\n\n        public void Unite(int x, int y)\n        {\n            x = Find(x);\n            y = Find(y);\n\n            if (x == y) return;\n\n            if (rank[x] < rank[y])\n            {\n                parents[x] = y;\n            }\n            else\n            {\n                parents[y] = x;\n                if (rank[x] == rank[y]) rank[x]++;\n            }\n        }\n\n        public bool Same(int x, int y)\n        {\n            return Find(x) == Find(y);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            while (true)\n            {\n                int V = int.Parse(Console.ReadLine());\n\n                if (V == 0) break;\n\n                int E = int.Parse(Console.ReadLine());\n\n                Edge[] edges = new Edge[E];\n\n                for (int i = 0; i < E; i++)\n                {\n                    string[] input = Console.ReadLine().Split(',');\n                    int s = int.Parse(input[0]);\n                    int t = int.Parse(input[1]);\n                    int w = int.Parse(input[2]) / 100 - 1;\n\n                    edges[i] = new Edge(s, t, w);\n                }\n                Console.WriteLine(Kruskal(edges, V));\n            }\n        }\n\n        static int Kruskal(Edge[] edges, int V)\n        {\n            Array.Sort(edges, (a, b) => a.cost - b.cost);\n\n            Union_Find UF = new Union_Find(V);\n\n            int totalCost = 0;\n\n            for (int i = 0; i < edges.Length; i++)\n            {\n                Edge e = edges[i];\n\n                if (!UF.Same(e.from, e.to))\n                {\n                    UF.Unite(e.from, e.to);\n                    totalCost += e.cost;\n                }\n            }\n            return totalCost;\n        }\n    }\n}"
  },
  {
    "language": "C#",
    "code": "using System.Collections.Generic;\nusing System.Linq;\nusing System;\n\npublic class PriorityQueue<T> where T : IComparable\n{\n    private IComparer<T> _comparer = null;\n    private int _type = 0;\n    private T[] _heap;\n    private int _sz = 0;\n    private int _count = 0;\n    /// <summary>\n    /// Priority Queue with custom comparer\n    /// </summary>\n    public PriorityQueue(int maxSize, IComparer<T> comparer)\n    {\n        _heap = new T[maxSize];\n        _comparer = comparer;\n    }\n\n    /// <summary>\n    /// Priority queue\n    /// </summary>\n    /// <param name=\"maxSize\">max size</param>\n    /// <param name=\"type\">0: asc, 1:desc</param>\n    public PriorityQueue(int maxSize, int type = 0)\n    {\n        _heap = new T[maxSize];\n        _type = type;\n    }\n\n    private int Compare(T x, T y)\n    {\n        if (_comparer != null) return _comparer.Compare(x, y);\n        return _type == 0 ? x.CompareTo(y) : y.CompareTo(x);\n    }\n    public void Push(T x)\n    {\n        _count++;\n        //node number\n        var i = _sz++;\n        while (i > 0)\n        {\n            //parent node number\n            var p = (i - 1) / 2;\n\n            if (Compare(_heap[p], x) <= 0) break;\n\n            _heap[i] = _heap[p];\n            i = p;\n        }\n        _heap[i] = x;\n    }\n    public T Pop()\n    {\n        _count--;\n        T ret = _heap[0];\n        T x = _heap[--_sz];\n\n        int i = 0;\n        while (i * 2 + 1 < _sz)\n        {\n            //children\n            int a = i * 2 + 1;\n            int b = i * 2 + 2;\n\n            if (b < _sz && Compare(_heap[b], _heap[a]) < 0) a = b;\n\n            if (Compare(_heap[a], x) >= 0) break;\n\n            _heap[i] = _heap[a];\n            i = a;\n        }\n        _heap[i] = x;\n        return ret;\n    }\n    public int Count()\n    {\n        return _count;\n    }\n    public T Peek()\n    {\n        return _heap[0];\n    }\n    public bool Contains(T x)\n    {\n        for (int i = 0; i < _sz; i++) if (x.Equals(_heap[i])) return true;\n        return false;\n    }\n    public void Clear()\n    {\n        while (this.Count() > 0) this.Pop();\n    }\n    public IEnumerator<T> GetEnumerator()\n    {\n        var ret = new List<T>();\n        while (this.Count() > 0)\n        {\n            ret.Add(this.Pop());\n        }\n        foreach (var r in ret)\n        {\n            this.Push(r);\n            yield return r;\n        }\n    }\n    public T[] ToArray()\n    {\n        T[] array = new T[_sz];\n        int i = 0;\n        foreach (var r in this)\n        {\n            array[i++] = r;\n        }\n        return array;\n    }\n}\n\npublic class Edge : IComparable\n{\n    public int to { get; set; }\n    public int d { get; set; }\n    public int CompareTo(object obj)\n    {\n        var x = (Edge)obj;\n        return this.d - x.d;\n    }\n}\n\npublic class Hello\n{\n    public static void Main()\n    {\n        while (true)\n        {\n            var n = int.Parse(Console.ReadLine().Trim());\n            if (n == 0) break;\n            var m = int.Parse(Console.ReadLine().Trim());\n            var r = new List<Edge>[n];\n            var minc = new int[n];\n            for (int i = 0; i < n; i++) minc[i] = -1;\n            for (int i = 0; i < n; i++)  r[i] = new List<Edge>();\n            for (int i = 0; i < m; i++)\n            {\n                string[] line2 = Console.ReadLine().Trim().Split(',');\n                var a = int.Parse(line2[0]);\n                var b = int.Parse(line2[1]);\n                var d = int.Parse(line2[2]) / 100;\n                r[a].Add(new Edge { to = b, d = d });\n                r[b].Add(new Edge { to = a, d = d });\n            }\n            goPrim(r, minc, 0, m);\n            Console.WriteLine(minc.Sum() - n + 1);\n        }\n    }\n    public static void goPrim(List<Edge>[] r, int[] minc, int targ, int m)\n    {\n        var pq = new PriorityQueue<Edge>(m * 2 + 1000);\n        var n = minc.Length;\n        var xL = new List<int>();\n        xL.Add(targ);  minc[targ] = 0;\n        foreach (var x in r[targ]) pq.Push(x);\n        while (xL.Count() < n)\n        {\n            var e = pq.Pop();\n            if (minc[e.to] == -1)\n            {\n                xL.Add(e.to);\n                minc[e.to] = e.d;\n                foreach (var x in r[e.to])\n                    if (minc[x.to] == -1) pq.Push(x);\n            }\n        }\n    }\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\nvar n=Arr.shift()-0;\nif(n==0)break;\nvar m=Arr.shift()-0;\nvar N=[];\nfor(var i=0;i<n;i++){\n   N[i]=[];\n   for(var j=0;j<n;j++){\n      N[i][j]=Infinity;\n      if(i==j)N[i][j]=0;\n   }\n}\nvar arr=[];\nfor(var i=0;i<m;i++){\n   var abc=Arr.shift().split(\",\").map(Number);\n   var a=abc[0];\n   var b=abc[1];\n   var c=(abc[2]/100)-1;\n   N[a][b]=c;\n   N[b][a]=c;\n}\nvar city=[0];\nvar cost=0;\nwhile(true){\n   if(city.length==n)break;\n   var min=Infinity;\n   var select=-1;\n   for(var i=0;i<city.length;i++){\n      for(var j=0;j<n;j++){\n         if(city.indexOf(j)!=-1)continue;\n         if(N[city[i]][j]<min){\n            select=j;\n            min=N[city[i]][j];\n         }\n      }\n   }\n   if(select!=-1){\n      cost+=min;\n      city.push(select);\n   }\n}\nconsole.log(cost);\n}"
  },
  {
    "language": "JavaScript",
    "code": "var input = require('fs').readFileSync('/dev/stdin', 'utf8');\nvar Arr=(input.trim()).split(\"\\n\");\nwhile(true){\nvar n=Arr.shift()-0;\nif(n==0)break;\nvar m=Arr.shift()-0;\nvar N=[];\nfor(var i=0;i<n;i++){\n   N[i]=[];\n   for(var j=0;j<n;j++){\n      N[i][j]=Infinity;\n      if(i==j)N[i][j]=0;\n   }\n}\nvar arr=[];\nfor(var i=0;i<m;i++){\n   var abc=Arr.shift().split(\",\").map(Number);\n   var a=abc[0];\n   var b=abc[1];\n   var c=abc[2]/100;\n   N[a][b]=c;\n   N[b][a]=c;\n}\nvar city=[0];\nvar cost=0;\nwhile(true){\n   if(city.length==n)break;\n   var min=Infinity;\n   var select=-1;\n   for(var i=0;i<city.length;i++){\n      for(var j=0;j<n;j++){\n         if(city.indexOf(j)!=-1)continue;\n         if(N[city[i]][j]<min){\n            select=j;\n            min=N[city[i]][j]-1;\n         }\n      }\n   }\n   if(select!=-1){\n      cost+=min;\n      city.push(select);\n   }\n}\nconsole.log(cost);\n}"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nl=(1..gets.to_i).map{eval\"[#{gets}]\"}\ns=0\nl.group_by{|a,b,c|b}.map{|k,v|s+=v.map{|a,b,c|c}.min}\np s/100-n+1\nend"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  table = Array.new(m) {$<.gets.split(\",\").map(&:to_i)}\n  table.map! {|a, b, d| [a, b, d / 100 - 1]}\n  \n  min = Float::INFINITY\n  (1..m).each do |i|\n    table.combination(i) do |paths|\n      next unless paths.inject([]) {|a, path| a + path[0, 2]}.uniq.sort == [*0...n]\n      n = paths.map{|path| path.last}.sum\n      min = n if n < min\n    end\n  end\n  puts min\nend\n"
  },
  {
    "language": "Ruby",
    "code": "until 0 == n = gets.to_i\n\tm = gets.to_i\n\troot = Array.new(n+1){Array.new(n+1)}\n\tnear = Hash.new() {|h,k|h[k]=[]}\n\tchecked = [0]\n\tm.times do\n\t\ta,b,c = gets.split(\",\").map(&:to_i)\n\t\troot[a][b] = c\n\t\troot[b][a] = c\n\tend\n\troot[0].each_with_index do |val,idx|\n\t\tunless val==nil\n\t\t\tnear[val].push idx\n\t\tend\n\tend\n\ti = 0\n\tsum = 0\n\tuntil near.empty?\n\t\tmin = near.min\n\t\tchecked << min[1][0]\n\t\troot[min[1][0]].each_with_index do |val,idx|\n\t\t\tunless val==nil\n\t\t\t\tnear[val].push idx\n\t\t\tend\n\t\tend\n\t\tsum += (min[0]/100)-1\n\t\tnear = near.map { |k,v| [k,v-checked] }.to_h.select {|k,v| ! v.empty?}\n\t\ti+=1\n\tend\n\tputs sum\nend"
  },
  {
    "language": "Ruby",
    "code": "class Node\n  attr_reader :id\n  @@i = 0\n  def self.clear\n    @@i = 0\n  end\n  def initialize\n    @u = nil\n    @id = @@i\n    @@i += 1\n  end\n\n  def ==(other)\n    return find().id == other.find.id\n  end\n  def find()\n    if @u\n      return @u = @u.find()\n    else\n      return self\n    end\n  end\n\n  def join(other)\n    if @u\n      @u.find.join(other)\n    else\n      @u = (other.find == (self)) ? nil : other.find\n    end\n  end\nend\n\ndef main\n  while (n = gets.to_i) != 0\n    m = gets.to_i\n    nodes = Array.new(n){Node.new}\n    path = Array.new(m){gets.chomp.split(\",\").map(&:to_i)}.sort_by{|(a, b, c)|c}\n    puts path.map{|r|\n      unless nodes[r[0]] == nodes[r[1]]\n        nodes[r[0]].join(nodes[r[1]])\n        r[2] - 100\n      else\n        0\n      end}.reduce(0){|a, i|a + i / 100}\n    Node.clear\n  end\nend\nmain"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nl=(1..n).map{{}}\ngets.to_i.times{a,b,c=eval\"[#{gets}]\";;l[a][b]=l[b][a]=c/100-1}\nm=(1..n-1).to_a\ns=0\no=[0]\n(n-1).times{\na,b=o.product(m).min_by{|i,j|l[i][j]||1e9}\ns+=l[a][b]\nm-=[b]\no+=[b]\n}\np s\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nm = gets.to_i\nroot = Array.new(n){Array.new(n)}\nnear = Hash.new() {|h,k|h[k]=[]}\nchecked = [0]\nm.times do\n    a,b,c = gets.split(\",\").map(&:to_i)\n    root[a][b] = c\n    root[b][a] = c\nend\nroot[0].each_with_index do |val,idx|\n    unless val==nil\n        near[val].push idx\n    end\nend\ni = 0\nsum = 0\nwhile i < n-1\n    min = near.min\n    checked << min[1][0]\n    root[min[1][0]].each_with_index do |val,idx|\n        unless val==nil\n            near[val].push idx\n        end\n    end\n    sum += (min[0]/100)-1\n    near[min[0]] -= checked\n    if near[min[0]].empty?\n        near.delete(min[0])\n    end\n    i+=1\nend\nputs sum"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  field = []\n  Array.new(m) {$<.gets.split(\",\").map(&:to_i)}.each do |a, b, d|\n    n = d / 100 - 1\n    field += field.map {|spots, num| [(spots + [a, b]).uniq, num + n]}\n    field << [[a, b], n]\n  end\n  puts field.select {|x| x.first.size == n}.sort_by {|x| x.last}.first.last\nend\n"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  cpd = Hash.new([])\n  table = Array.new(m) {$<.gets.split(\",\").map(&:to_i)}\n  table.map! {|a, b, d| [a, b, d / 100 - 1]}\n  table.each_with_index do |x, i|\n    cpd[x[0]] += [i]\n    cpd[x[1]] += [i]\n  end\n  result = []\n  stack = [[0, 1, 0, 0, 0]]\n  while (nxt = stack.shift)\n    if nxt[1] == 2 ** n - 1\n      result << nxt[2]\n    else\n      cpd[nxt[0]]\n      .map {|path| [path, (table[path][0, 2] - [nxt[0]]).first, table[path].last]}\n      .each do |path, spot, n|\n        next if (nxt[4] & 2 ** path).nonzero?\n        next if (2 ** spot & nxt[1]).nonzero? and (2 ** path & nxt[3]).zero?\n        nxt_lnt = nxt[2]\n        nxt_lnt += n if (2 ** spot & nxt[1]).zero?\n        f = nxt[4]\n        f |= 2 ** path if (2 ** path & nxt[3]).nonzero?\n        stack << [spot, 2 ** spot | nxt[1], nxt_lnt, 2 ** path | nxt[3], f]\n      end\n    end\n  end\n  puts result.min\nend\n"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  field = [[0, 0]]\n  Array.new(m) {$<.gets.split(\",\").map(&:to_i)}.each do |a, b, d|\n    n = d / 100 - 1\n    field += field.map do |spots, num|\n      spots |= 2 ** a\n      spots |= 2 ** b\n      [spots, num + n]\n    end\n  end\n  puts field.select {|x| x.first == 2 ** n - 1}.sort_by {|x| x.last}.first.last\nend\n"
  },
  {
    "language": "Ruby",
    "code": "loop do\n  n = gets.to_i\n  break if n==0\n  m = gets.to_i\n  table = Array.new(n){ Array.new(n){Float::INFINITY} }\n  m.times do\n    a,b,l = gets.split(\",\").map(&:to_i)\n    table[a][b] = table[b][a] = l\n  end\n  length = table[0]\n  cnt = 0\n  a = [0]\n  (n-1).times do\n    l = length.min\n    cnt += l/100 - 1\n    i = length.index(l)\n    a << i\n    (1..(n-1)).each do |j|\n      next if a.include?(j)\n      length[j] = [length[j], table[i][j]].min\n    end\n    length[i] = Float::INFINITY\n  end\n  puts cnt\nend"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nm = gets.to_i\nroot = Array.new(n){Array.new(n)}\nnear = Hash.new() {|h,k|h[k]=[]}\nchecked = [0]\nm.times do\n\ta,b,c = gets.split(\",\").map(&:to_i)\n\troot[a][b] = c\n\troot[b][a] = c\nend\nroot[0].each_with_index do |val,idx|\n\tunless val==nil\n\t\tnear[val].push idx\n\tend\nend\ni = 0\nsum = 0\nuntil near.empty?\n\tmin = near.min\n\tchecked << min[1][0]\n\troot[min[1][0]].each_with_index do |val,idx|\n\t\tunless val==nil\n\t\t\tnear[val].push idx\n\t\tend\n\tend\n\tsum += (min[0]/100)-1\n\tnear = near.map { |k,v| [k,v-checked] }.to_h.select {|k,v| ! v.empty?}\n\ti+=1\nend\nputs sum"
  },
  {
    "language": "Ruby",
    "code": "n = gets.to_i\nm = gets.to_i\nroot = Array.new(n){Array.new(n)}\nnear = Hash.new() {|h,k|h[k]=[]}\nchecked = [0]\nm.times do\n\ta,b,c = gets.split(\",\").map(&:to_i)\n\troot[a][b] = c\n\troot[b][a] = c\nend\nroot[0].each_with_index do |val,idx|\n\tunless val==nil\n\t\tnear[val].push idx\n\tend\nend\ni = 0\nsum = 0\nwhile i < n-1\n\tmin = near.min\n\tchecked << min[1][0]\n\troot[min[1][0]].each_with_index do |val,idx|\n\t\tunless val==nil\n\t\t\tnear[val].push idx\n\t\tend\n\tend\n\tsum += (min[0]/100)-1\n\tnear[min[0]] -= checked\n\tif near[min[0]].empty?\n\t\tnear.delete(min[0])\n\tend\n\ti+=1\nend\np sum"
  },
  {
    "language": "Ruby",
    "code": "while n = gets.to_i\n  break if n == 0\n  root = Array.new(n){|i| i}\n  node = {}\n  n.times{|i|\n    node[i] = [i]\n  }\n  m = gets.to_i\n  edge = []\n  m.times{|i|\n    a, b, d = gets.chomp.split(\",\").map(&:to_i)\n    a, b = b, a if a > b\n    edge[i] = [d/100 - 1, a, b]\n  }\n  edge.sort!\n  sum = 0\n  while edge.size > 0\n    d, a, b = edge.shift\n    ra = root[a]\n    rb = root[b]\n    if ra != rb\n      node[ra] += node[rb]\n      node[rb].each{|i|\n        root[i] = ra\n      }\n      sum += d\n    end\n  end\n  p sum\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nr=0..u=n-1\nl=r.map{{}}\ngets.to_i.times{a,b,c=eval\"[#{gets}]\";l[a][b]=l[b][a]=c/100-1}\nm=r.to_a-o=[s=0]\nu.times{a,b=o.product(m).min_by{|i,j|l[i][j]||1e9};s+=l[a][b];m-=o+=[b]}\np s\nend"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nl=(1..n).map{{}}\ngets.to_i.times{a,b,c=eval\"[#{gets}]\";;l[a][b]=l[b][a]=c/100-1}\no=[0]\nm=(1..n-1).to_a\nd=[0]*n\nwhile m!=[]\na=m.shift\n(b=l[a].values_at(*o).compact.min)?\n((o-[l[a].key(b)]).map{|i|l[a][i]&&d[i]>l[a][i]&&d[i]=l[a][i]};d[a]=b;o<<a):\nm<<a\nend\np d.inject:+\nend"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  table = Array.new(m) {$<.gets.split(\",\").map(&:to_i)}\n  table.map! {|a, b, d| [a, b, d / 100 - 1]}\n  \n  min = Float::INFINITY\n  (n - 2..m).each do |i|\n    table.combination(i) do |paths|\n      next unless paths.inject([]) {|a, path| a + path[0, 2]}.uniq.sort == [*0...n]\n      n = paths.map{|path| path.last}.sum\n      min = n if n < min\n    end\n  end\n  puts min\nend\n"
  },
  {
    "language": "Ruby",
    "code": "while(n=gets.to_i)>0\nl=(1..n).map{[]}\ngets.to_i.times{a,b,c=eval\"[#{gets}]\";l[a<b ?b:a]<<c/100-1}\np l[1..-1].map(&:min).inject:+\nend"
  },
  {
    "language": "Ruby",
    "code": "until 0 == n = gets.to_i\n\tm = gets.to_i\n\troot = Array.new(n+1){Array.new(n+1)}\n\tnear = Hash.new() {|h,k|h[k]=[]}\n\tchecked = [0]\n\tm.times do\n\t\ta,b,c = gets.split(\",\").map(&:to_i)\n\t\troot[a][b] = c\n\t\troot[b][a] = c\n\tend\n\troot[0].each_with_index do |val,idx|\n\t\tunless val==nil\n\t\t\tnear[val].push idx\n\t\tend\n\tend\n\tsum = 0\n\tuntil near.empty?\n\t\tmin = near.min\n\t\tchecked << min[1][0]\n\t\troot[min[1][0]].each_with_index do |val,idx|\n\t\t\tunless val==nil\n\t\t\t\tnear[val].push idx\n\t\t\tend\n\t\tend\n\t\tsum += min[0]/100 - 1\n\t\tnear = near.map { |k,v| [k,v-checked] }.to_h.select {|k,v| ! v.empty?}\n\tend\n\tputs sum\nend"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  field = {0=>0}\n  Array.new(m) {$<.gets.split(\",\").map(&:to_i)}.each do |a, b, d|\n    n = d / 100 - 1\n    added = {}\n    field.each do |spots, num|\n      spots |= 2 ** a\n      spots |= 2 ** b\n      added[spots] = num + n if !added[spots] or num + n < added[spots]\n    end\n    field.merge!(added) {|spots, b, f| [b, f].min}\n  end\n  puts field[2 ** n - 1]\nend\n"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  cpd = Hash.new([])\n  table = Array.new(m) {$<.gets.split(\",\").map(&:to_i)}\n  table.map! {|a, b, d| [a, b, d / 100 - 1]}\n  table.each_with_index do |x, i|\n    cpd[x[0]] += [i]\n    cpd[x[1]] += [i]\n  end\n  stack = [[0, 1, 0, 0]]    # 現在位置、行った場所、灯籠の数、使った道\n  result = loop do\n    nxt = stack.shift\n    cpd[nxt[0]]\n    .map {|tn| [tn, (table[tn][0, 2] - [nxt[0]]).first, table[tn].last]}\n    .each do |tn, spot, n|\n      nxt_lnt = nxt[2]\n      nxt_lnt += n if (2 ** spot & nxt[1]).zero?\n      stack << [spot, 2 ** spot | nxt[1], nxt_lnt, 2 ** tn | nxt[3]]\n    end\n    tmp1 = stack.select {|x| x[1] == 2 ** n - 1}\n    tmp2 = tmp1 .select {|x| x[3] == 2 ** m - 1}\n    break tmp1 unless tmp2.empty?\n  end\n  puts result.map {|x| x[2]}.min\nend\n"
  },
  {
    "language": "Ruby",
    "code": "# Node\nclass Node\n  attr_accessor :id, :edges, :done\n\n  def initialize(id, edges = [], done = false)\n    @id, @edges, @done = id, edges, done\n  end\nend\n\n# Edge\nclass Edge\n  attr_accessor :to, :cost\n\n  def initialize(to, cost)\n    @to, @cost = to, cost\n  end\nend\n\n# Prim\nclass Prim\n  attr_accessor :nodes\n\n  def initialize(data)\n    @nodes = {}\n    data.each do |id, edges|\n      edges.map! { |edge| Edge.new(*edge) }\n      @nodes[id] = Node.new(id, edges)\n    end\n  end\n\n  def start(id)\n    cost = 0\n    edges = []\n\n    @nodes.each do |id, node|\n      node.done = false\n    end\n\n    node = @nodes[id]\n    node.done = true\n    queue = node.edges\n\n    until queue.empty?\n      queue.sort! { |l, r| r.cost <=> l.cost }\n      edge = queue.pop\n      done_node = @nodes[edge.to]\n      next if done_node.done\n      done_node.done = true\n      cost += edge.cost\n      queue += done_node.edges\n      edges << edge\n    end\n\n    [cost, edges]\n  end\nend\n\nloop do\n  n = gets.chomp.to_i\n  break if n == 0\n\n  data = {}\n\n  m = gets.chomp.to_i\n  m.times do\n    a, b, d = gets.chomp.split(',').map(&:to_i)\n\n    data[a] ||= []\n    data[b] ||= []\n    data[a] << [b, d]\n    data[b] << [a, d]\n  end\n\n  prim = Prim.new(data)\n  res = prim.start 0  \n\n  puts res[0] / 100 - res[1].size\nend"
  },
  {
    "language": "Ruby",
    "code": "until 0 == n = gets.to_i\nm = gets.to_i\nroot = Array.new(n){Array.new(n)}\nnear = Hash.new() {|h,k|h[k]=[]}\nchecked = [0]\nm.times do\n    a,b,c = gets.split(\",\").map(&:to_i)\n    root[a][b] = c\n    root[b][a] = c\nend\nroot[0].each_with_index do |val,idx|\n    unless val==nil\n        near[val].push idx\n    end\nend\ni = 0\nsum = 0\nwhile i < n-1\n    min = near.min\n    checked << min[1][0]\n    root[min[1][0]].each_with_index do |val,idx|\n        unless val==nil\n            near[val].push idx\n        end\n    end\n    sum += (min[0]/100)-1\n    near[min[0]] -= checked\n    if near[min[0]].empty?\n        near.delete(min[0])\n    end\n    i+=1\nend\nputs sum\nend"
  },
  {
    "language": "Ruby",
    "code": "until 0 == n = gets.to_i\n\tm = gets.to_i\n\troot = Array.new(n+1){Array.new(n+1){Float::INFINITY}}\n\tnear = Hash.new() {|h,k|h[k]=[]}\n\tchecked = [0]\n\tm.times do\n\t\ta,b,c = gets.split(\",\").map(&:to_i)\n\t\troot[a][b] = c\n\t\troot[b][a] = c\n\tend\n\troot[0].each_with_index do |val,idx|\n\t\tunless val==nil\n\t\t\tnear[val].push idx\n\t\tend\n\tend\n\tsum = 0\n\tuntil near.empty?\n\t\tmin = near.min\n\t\tchecked << min[1][0]\n\t\troot[min[1][0]].each_with_index do |val,idx|\n\t\t\tunless val==nil\n\t\t\t\tnear[val].push idx\n\t\t\tend\n\t\tend\n\t\tsum += min[0]/100 - 1\n\t\tnear = near.map { |k,v| [k,v-checked] }.to_h.select {|k,v| ! v.empty?}\n\tend\n\tputs sum\nend"
  },
  {
    "language": "Ruby",
    "code": "class Heap\n\trequire 'forwardable'\n\textend Forwardable\n\n\tdef initialize\n\t\t@array = []\n\t\t@index = {}\n\tend\n\n\tdef add(obj, key)\n\t\t@array << [obj, key]\n\t\t@index[obj] = @array.size - 1\n\t\tlift_up(@array.size - 1)\n\tend\n\n\tdef swap(i, j)\n\t\tu = @array[i]\n\t\tv = @array[j]\n\t\t@index[u[0]], @index[v[0]] = j, i\n\t\t@array[i], @array[j] = v, u\n\tend\n\n\tdef lift_up(i)\n\t\treturn if i == 0\n\t\tj = (i - 1) / 2\n\t\tif (@array[i][1] <=> @array[j][1]) < 0\n\t\t\tswap(i, j)\n\t\t\tlift_up(j)\n\t\tend\n\tend\n\n\tdef del_min\n\t\traise \"heap is empty!\" if empty?\n\t\tmin = @array[0]\n\t\tif size > 1\n\t\t\tswap(0, @array.size-1)\n\t\t\t@array.pop\n\t\t\tlift_down(0)\n\t\telse\n\t\t\t@array.pop\n\t\tend\n\t\t@index.delete(min[0])\n\t\tmin\n\tend\n\n\tdef inc_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] += diff\n\t\tlift_down(i)\n\tend\n\n\tdef dec_key(obj, diff)\n\t\ti = @index[obj]\n\t\t@array[i][1] -= diff\n\t\tlift_up(i)\n\tend\n\n\tdef update_key(obj, new_key)\n\t\ti = @index[obj]\n\t\treturn unless i\n\t\treturn if (new_key <=> @array[i][1]) >= 0\n\t\t@array[i][1] = new_key\n\t\tlift_up(i)\n\tend\n\n\tdef min_obj\n\t\t@array[0][0]\n\tend\n\n\tdef min_key\n\t\t@array[0][1]\n\tend\n\n\tdef lift_down(i)\n\t\tj = 2 * i + 1\n\t\tk = j + 1\n\t\tif k >= size\n\t\t\treturn if j >= size\n\t\t\tif (@array[i][1] <=> @array[j][1]) > 0\n\t\t\t\tswap(i, j)\n\t\t\t\tlift_down(j)\n\t\t\tend\n\t\telse\n\t\t\tl = ((@array[j][1] <=> @array[k][1]) < 0 ? j : k)\n\t\t\tif (@array[i][1] <=> @array[l][1]) > 0\n\t\t\t\tswap(i, l)\n\t\t\t\tlift_down(l)\n\t\t\tend\n\t\tend\n\tend\n\n\tdef_delegators :@array, :empty?, :size\nend\n\nmodule Graphical\n\trequire 'set'\n\tdef prim(start)\n\t\th = Heap.new\n\t\th.add(start, 0)\n\t\treached = Set[start]\n\t\ttree_len = 0\n\n\t\tuntil h.empty?\n\t\t\tu, key = h.del_min\n\t\t\ttree_len += key\n\n\t\t\teach_out_connection_of(u){|v, d|\n\t\t\t\tif reached.include?(v)\n\t\t\t\t\th.update_key(v, d)\n\t\t\t\telse\n\t\t\t\t\th.add(v, d)\n\t\t\t\t\treached << v\n\t\t\t\tend\n\t\t\t}\n\t\tend\n\t\ttree_len\n\tend\nend\n\nclass Graph\n\tinclude Graphical\n\n\tdef initialize(*options)\n\t\t@options = Set[*options]\n\tend\n\n\tdef add_node(property = {})\n\t\tNode.new(property)\n\tend\n\n\tdef add_edge(u, v, property = {})\n\t\te = Edge.new(u, v, property)\n\t\tu.add_edge(e)\n\t\tv.add_edge(e)\n\t\te\n\tend\n\t\n\tdef del_edge(e)\n\t\tu, v = e.opposite.keys\n\t\tu.del_edge(e)\n\t\tv.del_edge(e)\n\t\te\n\tend\n\n\tclass Node\n\t\tdef initialize(property)\n\t\t\t@property = property\n\t\t\t@edges = Set.new\n\t\tend\n\n\t\tdef add_edge(e)\n\t\t\t@edges << e\n\t\tend\n\n\t\tdef del_edge(e)\n\t\t\t@edges.delete(e)\n\t\tend\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef each_edge\n\t\t\t@edges.each{|e| \n\t\t\t\tyield e\n\t\t\t}\n\t\tend\n\n\t\tattr_reader :property\n\tend\n\n\tclass Edge\n\t\tdef initialize(u, v, property)\n\t\t\t@opposite = {u => v, v => u}\n\t\t\t@property = property\n\t\tend\n\t\tattr_reader :opposite, :property\n\n\t\tdef to_s\n\t\t\t@property[:name] || super\n\t\tend\n\n\t\tdef length\n\t\t\t@property[:length] || 1\n\t\tend\n\tend\n\n\tdef each_out_connection_of(u)\n\t\tu.each_edge{|e|\n\t\t\tyield(e.opposite[u], e.length)\n\t\t}\n\tend\n\n\talias :each_in_connection_of :each_out_connection_of\nend\n\nloop do\n    n = gets.to_i\n    break if n == 0\n    m = gets.to_i\n    \n    g = Graph.new\n    nodes = (1..n).map {|i| g.add_node}\n    m.times do\n        i, j, d = gets.split(?,).map(&:to_i)\n        g.add_edge(nodes[i], nodes[j], {:length => d / 100 - 1})\n    end\n\n    p g.prim(nodes[0])\nend"
  },
  {
    "language": "Ruby",
    "code": "while true\n  n = gets.chomp.to_i\n  break if n == 0\n\n  m = gets.chomp.to_i\n\n  edges = []\n  m.times do\n    e = gets.chomp.split(\",\").map{|s| s.to_i}\n    e[2] = e[2] / 100 - 1\n    edges.push e\n  end\n  #p [n, m, edges]\n\n  edges.sort!{|a, b| a[2] <=> b[2]}\n\n  nodes = n.times.map{false}\n\n  connected = [0]\n  nodes[0] = true\n\n  sumw = 0\n\n  while connected.length < n\n    for i in (0...edges.length)\n      n0, n1, w = edges[i]\n\n      if nodes[n0] || nodes[n1]\n        if ! nodes[n0]\n          nodes[n0] = true\n          connected.push n0\n          sumw += w\n        elsif ! nodes[n1]\n          nodes[n1] = true\n          connected.push n1\n          sumw += w\n        end\n\n        edges.delete_at(i)\n        break\n      end\n    end\n  end\n\n  puts sumw\nend"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  init_spots = Array.new(m, 0)\n  tourou = 0\n  table = Array.new(m) {$<.gets.split(\",\").map(&:to_i)}.map do |a, b, d|\n    init_spots[a] += 1\n    init_spots[b] += 1\n    n = d / 100 - 1\n    tourou += n\n    [a, b, n]\n  end\n  min = tourou\n  solve = ->(i, spots, t) {\n    min = t if t < min\n    return if i == m\n    solve.(i + 1, spots, t)\n    now = table[i]\n    return if spots[now[0]] == 1 or spots[now[1]] == 1\n    spots[now[0]] -= 1\n    spots[now[1]] -= 1\n    solve.(i + 1, spots, t - now[2])\n    spots[now[0]] += 1\n    spots[now[1]] += 1\n  }\n  solve.(0, init_spots, tourou)\n  puts min\nend\n"
  },
  {
    "language": "Ruby",
    "code": "until (n = $<.gets.to_i).zero?\n  m = $<.gets.to_i\n  visited = []\n  tourou = 0\n  Array.new(m) {$<.gets.split(\",\").map(&:to_i)}.sort_by {|a| a.last}.each do |a, b, d|\n    next if visited.include?(a) and visited.include?(b)\n    visited = (visited + [a, b]).uniq\n    tourou += d / 100 - 1\n    break if visited.size == n\n  end\n  puts tourou\nend\n"
  },
  {
    "language": "Ruby",
    "code": "INF = 1.0 / 0.0\n\nclass Node\n  attr_accessor :edge, :visited\n  def initialize\n    @edge = {}\n    @visited = false\n  end\nend\n\ndef dfs(s, g)\n  q = [s]\n  g[s].visited = true\n  ans = 0\n  while q.size > 0\n    s = q[-1]\n    min = INF\n    u = s\n    g[s].edge.each{|t, d|\n      next if g[t].visited\n      if min > d\n        min = d\n        u = t\n      end\n    }\n    if u != s\n      q << u\n      g[u].visited = true\n      ans += min\n    else\n      q.pop\n    end\n  end\n  return ans\nend\n\nwhile n = gets.to_i\n  break if n == 0\n  g = Array.new(n){Node.new}\n  m = gets.to_i\n  m.times{|i|\n    a, b, d = gets.chomp.split(\",\").map(&:to_i)\n    g[a].edge[b] = d / 100 - 1\n    g[b].edge[a] = d / 100 - 1\n  }\n  p dfs(0,g)\nend"
  },
  {
    "language": "PHP",
    "code": "<?php\nwhile(true) {\n\tfscanf(STDIN, \"%d\", $n);\n\tif($n == 0)\n\t\tbreak;\n// \techo $n;\n\tfscanf(STDIN, \"%d\", $m);\n// \techo $m;\n\t$input = array(array(), array(), array(), array(),);\n\tfor($i=0 ; $m>$i ; $i++) {\n\t\tfscanf(STDIN, \"%d,%d,%d\", $a, $b, $d);\n\t\t$input[$a][$b] = $d;\n\t\t$input[$b][$a] = $d;\n\t}\n\n\t$already = array_pad(array(), $n, false);\n\t$already[0] = true;\n\n\t$result = 0;\n\twhile(true) {\n\t\t$f = false;\n\t\tforeach ($already as $k => $flg) {\n\t\t\tif(! $flg){\n\t\t\t\t$f = true;\n\t\t\t}\n\t\t}\n\t\tif(! $f)\n\t\t\tbreak;\n\n\t\t$index = 0;\n\t\t$tmp = PHP_INT_MAX;\n\t\tfor($i = 0 ; $i < $n ; $i++) {\n\t\t\tif(! $already[$i])\n\t\t\t\tcontinue;\n\n\t\t\tforeach ($input[$i] as $key => $val) {\n\t\t\t\tif($tmp > $val && ! $already[$key]) {\n\t\t\t\t\t$index = $key;\n\t\t\t\t\t$tmp = $val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$already[$index] = true;\n\t\t$result += $tmp;\n\t}\n\techo (($result - (($n-1) * 100)) / 100).\"\\n\";\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\nwhile(true) {\n\tfscanf(STDIN, \"%d\", $n);\n\tif($n == 0)\n\t\tbreak;\n// \techo $n;\n\tfscanf(STDIN, \"%d\", $m);\n// \techo $m;\n\t$input = array(array(), array(), array(), array(),);\n\tfor($i=0 ; $m>$i ; $i++) {\n\t\tfscanf(STDIN, \"%d,%d,%d\", $a, $b, $d);\n\t\t$input[$a][$b] = $d;\n\t\t$input[$b][$a] = $d;\n\t}\n\n\t$already = array_pad(array(), $n, false);\n\t$already[0] = true;\n\n\t$result = 0;\n\twhile(true) {\n\t\t$f = false;\n\t\tforeach ($already as $k => $flg) {\n\t\t\tif(! $flg){\n\t\t\t\t$f = true;\n\t\t\t}\n\t\t}\n\t\tif(! $f)\n\t\t\tbreak;\n\n\t\t$index = 0;\n\t\t$tmp = PHP_INT_MAX;\n\t\tfor($i = 0 ; $i < $n ; $i++) {\n\t\t\tif(! $already[$i])\n\t\t\t\tcontinue;\n\n\t\t\tforeach ($input[$i] as $key => $val) {\n\t\t\t\tif($tmp > $val && ! $already[$key]) {\n\t\t\t\t\t$index = $key;\n\t\t\t\t\t$tmp = $val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$already[$index] = true;\n\t\t$result += $tmp;\n\t}\n\techo ($result - (($n-1) * 100)) / 100;\n}"
  },
  {
    "language": "PHP",
    "code": "<?php\nwhile(true) {\n\tfscanf(STDIN, \"%d\", $n);\n\tif($n == 0)\n\t\tbreak;\n// \techo $n;\n\tfscanf(STDIN, \"%d\", $m);\n// \techo $m;\n\t$input = array(array(), array(), array(), array(),);\n\tfor($i=0 ; $m>$i ; $i++) {\n\t\tfscanf(STDIN, \"%d,%d,%d\", $a, $b, $d);\n\t\t$input[$a][$b] = $d;\n\t\t$input[$b][$a] = $d;\n\t}\n\n\t$already = array_pad(array(), $n, false);\n\t$already[0] = true;\n\n\t$result = 0;\n\twhile(true) {\n\t\t$f = false;\n\t\tforeach ($already as $k => $flg) {\n\t\t\tif(! $flg){\n\t\t\t\t$f = true;\n\t\t\t}\n\t\t}\n\t\tif(! $f)\n\t\t\tbreak;\n\n\t\t$index = 0;\n\t\t$tmp = PHP_INT_MAX;\n\t\tfor($i = 0 ; $i < $n ; $i++) {\n\t\t\tif(! $already[$i])\n\t\t\t\tcontinue;\n\n\t\t\tforeach ($input[$i] as $key => $val) {\n\t\t\t\tif($tmp > $val && ! $already[$key]) {\n\t\t\t\t\t$index = $key;\n\t\t\t\t\t$tmp = $val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$already[$index] = true;\n\t\t$result += $tmp;\n\t}\n}\n\techo ($result - (($n-1) * 100)) / 100;"
  },
  {
    "language": "PHP",
    "code": "<?php\n\tfscanf(STDIN, \"%d\", $n);\n\tif($n == 0)\n\t\treturn;\n// \techo $n;\n\tfscanf(STDIN, \"%d\", $m);\n// \techo $m;\n\t$input = array(array(), array(), array(), array(),);\n\tfor($i=0 ; $m>$i ; $i++) {\n\t\tfscanf(STDIN, \"%d,%d,%d\", $a, $b, $d);\n\t\t$input[$a][$b] = $d;\n\t\t$input[$b][$a] = $d;\n\t}\n\n\t$already = array_pad(array(), $n, false);\n\t$already[0] = true;\n\n\t$result = 0;\n\twhile(true) {\n\t\t$f = false;\n\t\tforeach ($already as $k => $flg) {\n\t\t\tif(! $flg){\n\t\t\t\t$f = true;\n\t\t\t}\n\t\t}\n\t\tif(! $f)\n\t\t\tbreak;\n\n\t\t$index = 0;\n\t\t$tmp = PHP_INT_MAX;\n\t\tfor($i = 0 ; $i < $n ; $i++) {\n\t\t\tif(! $already[$i])\n\t\t\t\tcontinue;\n\n\t\t\tforeach ($input[$i] as $key => $val) {\n\t\t\t\tif($tmp > $val && ! $already[$key]) {\n\t\t\t\t\t$index = $key;\n\t\t\t\t\t$tmp = $val;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t$already[$index] = true;\n\t\t$result += $tmp;\n\t}\n\techo ($result - (($n-1) * 100)) / 100;"
  },
  {
    "language": "D",
    "code": "import std.stdio : writeln, write, stdin;\nimport std.array;\nimport std.range;\nimport std.algorithm : filter, min;\n\nint INF = 1<<28;\n\nint solve(int idx, int[][] map, int n){\n\tint ptr = idx;\n\tbool[] done = new bool[n];\n\tint[] last = new int[n];\n\tint[] list = repeat(INF).take(n).array;\n\tlist[ptr] = 0;\n\tlast[ptr] = 0;\n\twhile(true){\n\t\tint min_ = INF;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(!done[i]){\n\t\t\t\tif(list[i] < min_){\n\t\t\t\t\tmin_ = list[i];\n\t\t\t\t\tptr = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(min_==INF){ break; }\n\t\t\n\t\tdone[ptr] = true;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(!done[i]){\n\t\t\t\tif(map[ptr][i] < INF){\n\t\t\t\t\tif(map[ptr][i] < list[i]){\n\t\t\t\t\t\tlist[i] = map[ptr][i] + list[ptr];\n\t\t\t\t\t\tlast[i] = map[ptr][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(filter!(a => a==INF)(list).array.length==0);\n\t\n\tint count = 0;\n\tforeach(ite; filter!(a => a!=0)(last).array){\n\t\tcount += ite -1;\n\t}\n\t\n\treturn count;\n}\n\nvoid main(){\n\twhile(true){\n\t\tdelim = \"\\n\";\n\t\tint n = next!int();\n\t\t\n\t\tif(n==0){ break; }\n\t\t\n\t\tint m = next!int();\n\n\t\tint[][] map;\n\t\tforeach(i; n.iota){\n\t\t\tmap ~= repeat(INF).take(n).array;\n\t\t}\n\t\tdelim = \",\";\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint a = next!int();\n\t\t\tint b = next!int();\n\t\t\tint d = next!int()/100;\n\t\t\t\n\t\t\tmap[a][b] = d;\n\t\t\tmap[b][a] = d;\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tans = min(solve(i, map, n), ans);\n\t\t}\n\t\t\n\t\tans.writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.string,std.conv,std.algorithm;\n\n\nint cost[101][101];\nint mincost[101];\nint used[101] = [];\n\nint prim(int n)\n{\n\tint res = 0;\n\tforeach(i;0..n)\n\t{\n\t\tmincost[i] = 1000000;\n\t\tforeach(j;0..n)\n\t\t{\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tint m = readln.chomp.to!int;\n\n\tforeach(i;0..m)\n\t{\n\t\tstring s = readln.chomp;\n\t\tstring[] _s = s.split(\",\");\n\t\tint a = _s[0].to!int;\n\t\tint b = _s[1].to!int;\n\t\tint d = _s[2].to!int;\n\t\tcost[b][a] = cost[a][b] = d/100 - 1;\n\t}\n\n\tmincost[0] = 0;\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\tforeach(u;0..n)\n\t\t{\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t{\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\n\t\tif(v == -1) break;\n\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\tforeach(i;0..n)\n\t\t{\n\t\t\tmincost[i] = min(mincost[i],cost[v\n\t\t\t][i]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile((n = readln.chomp.to!int) != 0)\n\t{\n\t\tprim(n).writeln;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : writeln, write, stdin;\nimport std.array;\nimport std.range;\nimport std.algorithm : filter, min;\n\nint INF = 1<<28;\n\nint solve(int[][] map, int n){\n\tint ptr = 0;\n\tbool[] done = new bool[n];\n\tint[] last = new int[n];\n\tint[] list = repeat(INF).take(n).array;\n\tlist[ptr] = 0;\n\twhile(true){\n\t\tint min_ = INF;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(!done[i]){\n\t\t\t\tif(list[i] < min_){\n\t\t\t\t\tmin_ = list[i];\n\t\t\t\t\tptr = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(min_==INF){ break; }\n\t\t\n\t\tdone[ptr] = true;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(!done[i]){\n\t\t\t\tif(map[ptr][i] < INF){\n\t\t\t\t\tif(map[ptr][i] < list[i]){\n\t\t\t\t\t\tlist[i] = map[ptr][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(filter!(a => a==INF)(list).array.length==0);\n\t\n\tint count = 0;\n\tforeach(ite; filter!(a => a!=0)(list).array){\n\t\tcount += ite -1;\n\t}\n\t\n\treturn count;\n}\n\nvoid main(){\n\twhile(true){\n\t\tdelim = \"\\n\";\n\t\tint n = next!int();\n\t\t\n\t\tif(n==0){ break; }\n\t\t\n\t\tint m = next!int();\n\n\t\tint[][] map;\n\t\tforeach(i; n.iota){\n\t\t\tmap ~= repeat(INF).take(n).array;\n\t\t}\n\t\tdelim = \",\";\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint a = next!int();\n\t\t\tint b = next!int();\n\t\t\tint d = next!int()/100;\n\t\t\t\n\t\t\tmap[a][b] = d;\n\t\t\tmap[b][a] = d;\n\t\t}\n\t\t\n\t\tsolve(map, n).writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : writeln, write, stdin;\nimport std.array;\nimport std.range;\nimport std.algorithm : filter;\n\nint INF = 1<<28;\n\nvoid main(){\n\twhile(true){\n\t\tdelim = \"\\n\";\n\t\tint n = next!int();\n\t\t\n\t\tif(n==0){ break; }\n\t\t\n\t\tint m = next!int();\n\n\t\tint[][] map;\n\t\tforeach(i; n.iota){\n\t\t\tmap ~= repeat(INF).take(n).array;\n\t\t}\n\t\tdelim = \",\";\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tmap[i][i] = 0;\n\t\t\tint a = next!int();\n\t\t\tint b = next!int();\n\t\t\tint d = next!int()/100;\n\t\t\t\n\t\t\tmap[a][b] = d;\n\t\t\tmap[b][a] = d;\n\t\t}\n\t\t\n\t\tint ptr = 0;\n\t\tbool[] done = new bool[n];\n\t\tint[] last = new int[n];\n\t\tint[] list = repeat(INF).take(n).array;\n\t\tlist[0] = 0;\n\t\tlast[0] = 0;\n\t\twhile(true){\n\t\t\tint min = INF;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tif(!done[i]){\n\t\t\t\t\tif(list[i] < min){\n\t\t\t\t\t\tmin = list[i];\n\t\t\t\t\t\tptr = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min==INF){ break; }\n\t\t\t\n\t\t\tdone[ptr] = true;\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tif(!done[i]){\n\t\t\t\t\tif(map[ptr][i] < INF){\n\t\t\t\t\t\tif(map[ptr][i] < list[i]){\n\t\t\t\t\t\t\tlist[i] = map[ptr][i] + list[ptr];\n\t\t\t\t\t\t\tlast[i] = map[ptr][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(filter!(a => a==INF)(list).array.length==0);\n\t\t\n\t\tdebug(1){ last.dbg; }\n\t\t\n\t\tint count = 0;\n\t\tforeach(ite; filter!(a => a!=0)(last).array){\n\t\t\tcount += ite -1;\n\t\t}\n\t\t\n\t\tcount.writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.string,std.conv,std.algorithm;\n\n\nint cost[101][101];\nint mincost[101];\nint used[101] = [];\n\nint prim(int n)\n{\n\tint res = 0;\n\tforeach(i;0..n)\n\t{\n\t\tmincost[i] = 1000000;\n\t\tforeach(j;0..n)\n\t\t{\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tint m = readln.chomp.to!int;\n\n\tforeach(i;0..m)\n\t{\n\t\tstring s = readln.chomp;\n\t\tstring[] _s = s.split(',');\n\t\tint a = _s[0].to!int;\n\t\tint b = _s[1].to!int;\n\t\tint d = _s[2].to!int;\n\t\tcost[b][a] = cost[a][b] = d/100 - 1;\n\t}\n\n\tmincost[0] = 0;\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\tforeach(u;0..n)\n\t\t{\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t{\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\n\t\tif(v == -1) break;\n\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\tforeach(i;0..n)\n\t\t{\n\t\t\tmincost[i] = min(mincost[i],cost[v\n\t\t\t][i]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile((n = readln.chomp.to!int) != 0)\n\t{\n\t\tprim(n).writeln;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.string,std.conv,std.algorithm;\n\n\nint cost[101][101];\nint mincost[101];\nint used[101] = [];\n\nint prim(int n)\n{\n\tint res = 0;\n\n\tforeach(i;0..n)\n\t{\n\t\tmincost[i] = 1000000;\n\t\tforeach(j;0..n)\n\t\t{\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\t\n\tint m = readln.chomp.to!int;\n\tforeach(i;0..m)\n\t{\n\t\tstring[] s = readln.chomp.split(\",\");\n\t\tint a = s[0].to!int;\n\t\tint b = s[1].to!int;\n\t\tint d = s[2].to!int;\n\t\tcost[b][a] = cost[a][b] = d/100 -1;\n\t}\n\t\n\tmincost[0] = 0;\n\twhile(true)\n\t{\n\t\tint  v = -1;\n\t\tforeach(u;0..n)\n\t\t{\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t{\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(v == -1) break;\n\t\t\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\tforeach(i;0..n)\n\t\t{\n\t\t\tmincost[i] = min(mincost[i],cost[v][i]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile((n = readln.chomp.to!int) != 0)\n\t{\n\t\tprim(n).writeln;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : writeln, write, stdin;\nimport std.array;\nimport std.range;\nimport std.algorithm : filter;\n\nint INF = 1<<28;\n\nvoid main(){\n\twhile(true){\n\t\tdelim = \"\\n\";\n\t\tint n = next!int();\n\t\t\n\t\tif(n==0){ break; }\n\t\t\n\t\tint m = next!int();\n\n\t\tint[][] map;\n\t\tforeach(i; n.iota){\n\t\t\tmap ~= repeat(INF).take(n).array;\n\t\t}\n\t\tdelim = \",\";\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint a = next!int();\n\t\t\tint b = next!int();\n\t\t\tint d = next!int()/100;\n\t\t\t\n\t\t\tmap[a][b] = d;\n\t\t\tmap[b][a] = d;\n\t\t}\n\t\t\n\t\tint ptr = 0;\n\t\tbool[] done = new bool[n];\n\t\tint[] last = new int[n];\n\t\tint[] list = repeat(INF).take(n).array;\n\t\tlist[0] = 0;\n\t\tlast[0] = 0;\n\t\twhile(true){\n\t\t\tint min = INF;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tif(!done[i]){\n\t\t\t\t\tif(list[i] < min){\n\t\t\t\t\t\tmin = list[i];\n\t\t\t\t\t\tptr = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min==INF){ break; }\n\t\t\t\n\t\t\tdone[ptr] = true;\n\t\t\tfor(int i=0; i<m; ++i){\n\t\t\t\tif(!done[i]){\n\t\t\t\t\tif(map[ptr][i] < INF){\n\t\t\t\t\t\tif(map[ptr][i] < list[i]){\n\t\t\t\t\t\t\tlist[i] = map[ptr][i] + list[ptr];\n\t\t\t\t\t\t\tlast[i] = map[ptr][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(filter!(a => a==INF)(list).array.length==0);\n\t\t\n\t\tdebug(1){ last.dbg; }\n\t\t\n\t\tint count = 0;\n\t\tforeach(ite; filter!(a => a!=0)(last).array){\n\t\t\tcount += ite -1;\n\t\t}\n\t\t\n\t\tcount.writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio,std.string,std.conv,std.algorithm;\n\n\nint cost[101][101];\nint mincost[101];\nint used[101] = [];\n\nint prim(int n)\n{\n\tint res = 0;\n\tforeach(i;0..n)\n\t{\n\t\tmincost[i] = 1000000;\n\t\tforeach(j;0..n)\n\t\t{\n\t\t\tcost[i][j] = 1000000;\n\t\t}\n\t}\n\n\tint m = readln.chomp.to!int;\n\n\tforeach(i;0..m)\n\t{\n\t\tstring[] s = readln.chomp.split(',');\n\t\tint a = s[0].to!int;\n\t\tint b = s[1].to!int;\n\t\tint d = s[2].to!int;\n\t\tcost[b][a] = cost[a][b] = d/100 - 1;\n\t}\n\n\tmincost[0] = 0;\n\twhile(true)\n\t{\n\t\tint v = -1;\n\t\tforeach(u;0..n)\n\t\t{\n\t\t\tif(!used[u] && (v == -1 || mincost[u] < mincost[v]))\n\t\t\t{\n\t\t\t\tv = u;\n\t\t\t}\n\t\t}\n\n\t\tif(v == -1) break;\n\n\t\tused[v] = 1;\n\t\tres += mincost[v];\n\t\tforeach(i;0..n)\n\t\t{\n\t\t\tmincost[i] = min(mincost[i],cost[v\n\t\t\t][i]);\n\t\t}\n\t}\n\treturn res;\n}\n\nint main()\n{\n\tint n;\n\twhile((n = readln.chomp.to!int) != 0)\n\t{\n\t\tprim(n).writeln;\n\t}\n\treturn 0;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : writeln, write, stdin;\nimport std.array;\nimport std.range;\nimport std.algorithm : filter;\n\nint INF = 1<<28;\n\nvoid main(){\n\twhile(true){\n\t\tdelim = \"\\n\";\n\t\tint n = next!int();\n\t\t\n\t\tif(n==0){ break; }\n\t\t\n\t\tint m = next!int();\n\n\t\tint[][] map;\n\t\tforeach(i; n.iota){\n\t\t\tmap ~= repeat(INF).take(n).array;\n\t\t}\n\t\tdelim = \",\";\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint a = next!int();\n\t\t\tint b = next!int();\n\t\t\tint d = next!int()/100;\n\t\t\t\n\t\t\tmap[a][b] = d;\n\t\t\tmap[b][a] = d;\n\t\t}\n\t\t\n\t\tint ptr = 0;\n\t\tbool[] done = new bool[n];\n\t\tint[] last = new int[n];\n\t\tint[] list = repeat(INF).take(n).array;\n\t\tlist[0] = 0;\n\t\tlast[0] = 0;\n\t\twhile(true){\n\t\t\tint min = INF;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tif(!done[i]){\n\t\t\t\t\tif(list[i] < min){\n\t\t\t\t\t\tmin = list[i];\n\t\t\t\t\t\tptr = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(min==INF){ break; }\n\t\t\t\n\t\t\tdone[ptr] = true;\n\t\t\tfor(int i=0; i<n; ++i){\n\t\t\t\tif(!done[i]){\n\t\t\t\t\tif(map[ptr][i] < INF){\n\t\t\t\t\t\tif(map[ptr][i] < list[i]){\n\t\t\t\t\t\t\tlist[i] = map[ptr][i] + list[ptr];\n\t\t\t\t\t\t\tlast[i] = map[ptr][i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tassert(filter!(a => a==INF)(list).array.length==0);\n\t\t\n\t\tdebug(1){ last.dbg; }\n\t\t\n\t\tint count = 0;\n\t\tforeach(ite; filter!(a => a!=0)(last).array){\n\t\t\tcount += ite -1;\n\t\t}\n\t\t\n\t\tcount.writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio, std.string, std.conv;\nimport std.array, std.algorithm, std.range;\n\nclass UnionFind\n{\n    private int[] p;\n    private int[] r;\n    this(int n){ p = iota(n).array(); r = new int[n]; }\n    int find(int x)\n    {\n        if(x==p[x]) return x;\n        return p[x]=find(p[x]);\n    }\n    void unite(int x, int y)\n    {\n        x=find(x);\n        y=find(y);\n        if(r[x]>r[y]) swap(x,y);\n        p[y]=x;\n        if(r[x]==r[y]) ++r[y]; \n    }\n    bool same(int x, int y){ return find(x)==find(y); }\n}\n\nvoid main()\n{\n    for(int n; 0!=(n=readln().chomp().to!int()); )\n    {\n        immutable m = readln().chomp().to!int();\n        auto g = iota(m).map!(_=>readln().chomp().split(\",\").map!(to!int).array()).array()\n            .map!(a=>[a[2]/100-1,a[0],a[1]]).array().sort();\n        auto uf = new UnionFind(n);\n        int c=0;\n        foreach(e;g)\n        {\n            if(uf.same(e[1],e[2])) continue;\n            uf.unite(e[1],e[2]);\n            c+=e[0];\n        }\n        writeln(c);\n    }\n}"
  },
  {
    "language": "D",
    "code": "import std.stdio : writeln, write, stdin;\nimport std.array;\nimport std.range;\nimport std.algorithm : filter, min;\n\nint INF = 1<<28;\n\nint solve(int idx, int[][] map, int n){\n\tint ptr = 0;\n\tbool[] done = new bool[n];\n\tint[] last = new int[n];\n\tint[] list = repeat(INF).take(n).array;\n\tlist[0] = 0;\n\tlast[0] = 0;\n\twhile(true){\n\t\tint min_ = INF;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(!done[i]){\n\t\t\t\tif(list[i] < min_){\n\t\t\t\t\tmin_ = list[i];\n\t\t\t\t\tptr = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(min_==INF){ break; }\n\t\t\n\t\tdone[ptr] = true;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tif(!done[i]){\n\t\t\t\tif(map[ptr][i] < INF){\n\t\t\t\t\tif(map[ptr][i] < list[i]){\n\t\t\t\t\t\tlist[i] = map[ptr][i] + list[ptr];\n\t\t\t\t\t\tlast[i] = map[ptr][i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tassert(filter!(a => a==INF)(list).array.length==0);\n\t\n\tint count = 0;\n\tforeach(ite; filter!(a => a!=0)(last).array){\n\t\tcount += ite -1;\n\t}\n\t\n\treturn count;\n}\n\nvoid main(){\n\twhile(true){\n\t\tdelim = \"\\n\";\n\t\tint n = next!int();\n\t\t\n\t\tif(n==0){ break; }\n\t\t\n\t\tint m = next!int();\n\n\t\tint[][] map;\n\t\tforeach(i; n.iota){\n\t\t\tmap ~= repeat(INF).take(n).array;\n\t\t}\n\t\tdelim = \",\";\n\t\tfor(int i=0; i<m; ++i){\n\t\t\tint a = next!int();\n\t\t\tint b = next!int();\n\t\t\tint d = next!int()/100;\n\t\t\t\n\t\t\tmap[a][b] = d;\n\t\t\tmap[b][a] = d;\n\t\t}\n\t\t\n\t\tint ans = INF;\n\t\tfor(int i=0; i<n; ++i){\n\t\t\tans = min(solve(i, map, n), ans);\n\t\t}\n\t\t\n\t\tans.writeln;\n\t}\n}\n\n\nimport std.stdio : readln, chomp;\nimport std.conv : to;\nimport std.string : split;\nshared string[] input;\nshared string delim = \" \";\nT next(T)()\nin\n{\n\tassert(hasNext());\n}\nout\n{\n\tinput.popFront;\n}\nbody\n{\n\treturn input.front.to!T;\n}\n\nvoid next(T)(ref T v){\n\tv = next!T();\n}\n\nbool hasNext(){\n\tif(input.length > 0){\n\t\treturn true;\n\t}\n\t\n\tstring str = readln;\n\tif(str.length > 0){\n\t\tinput ~= str.chomp.split(delim);\n\t\treturn true;\n\t}else{\n\t\treturn false;\n\t}\n}\n\n\nvoid dbg(T...)(T vs)\n{\n\timport std.stdio : stderr;\n\tforeach(v; vs)\n\t\tstderr.write(v.to!string ~ \" \");\n\tstderr.write(\"\\n\");\n}\n\nT clone(T)(T v){\n\tT v_;\n\tstatic if(isInputRange!(T)){\n\t\tforeach(ite; v){\n\t\t\tv_ ~= ite.clone;\n\t\t}\n\t}else{\n\t\tv_ = v;\n\t}\n\t\n\treturn v_;\n}"
  },
  {
    "language": "Python",
    "code": "while True:\n    n = int(input())\n    if n == 0:\n        break\n    m = int(input())\n    a = [[10000 for i in range(n)] for j in range(n)]\n\n    for i in range(m):\n        a_i, b_i, d_i = map(int, input().split(\",\"))\n        a[a_i][b_i] = d_i//100 - 1\n        a[b_i][a_i] = d_i//100 - 1\n\n    w = 0\n    v = set()\n    v.add(0)\n\n    while len(v) < n:\n        min_w   = 10000\n        min_idx = 0\n        i = 0\n        for node in v:\n            if min_w > min(a[node]):\n                min_w = min(a[node])\n                i = node\n                min_idx = a[i].index(min_w)\n        if min_idx in v:\n            a[i][min_idx] = 10000\n            continue\n        else:\n            w += min_w\n            v.add(min_idx)\n\n    print(w)\n\n"
  },
  {
    "language": "Python",
    "code": "while 1:\n  n=int(input())\n  if not n:break\n  X={0}\n  Y=set(range(n))-X\n  s=0\n  l=[tuple(map(int,input().split(\",\"))) for _ in range(int(input()))]\n\n  while Y:\n    cd=[i for i in l if (i[0] in X and i[1] in Y) or (i[0] in Y and i[1] in X)]\n    cd=sorted(cd,key=lambda x:x[2])[0]\n    if cd[0] in X and cd[1] in Y:\n      X.add(cd[1])\n      Y=Y-X\n    elif cd[0] in Y and cd[1] in X:\n      X.add(cd[0])\n      Y=Y-X\n    s+=int(cd[2]/100-1)\n  print(s)\n"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\"\"\"参考文献\nhttp://ja.wikipedia.org/wiki/クラスカル法\n\"\"\"\nfrom __future__ import (division, absolute_import, print_function,\n                        unicode_literals)\nfrom sys import stdin\n\nwhile True:\n    num_node = int(stdin.readline())\n    if not num_node:\n        break\n\n    S = []\n    for _ in range(int(stdin.readline())):\n        S.append([int(s) for s in stdin.readline().split(',')])\n    S.sort(key=lambda (n1, n2, d): d, reverse=True)\n\n    forest = {frozenset([i]) for i in range(num_node)}\n    spanning = []\n    while S:\n        node1, node2, distance = S.pop()\n        a, b = None, None\n        for tree in forest:\n            if node1 in tree:\n                a = tree\n            if node2 in tree:\n                b = tree\n            if a and b:\n                break\n        if a != b:\n            forest.add(a | b)\n            forest.remove(a)\n            forest.remove(b)\n            spanning.append(distance)\n    print(sum((distance // 100) - 1 for distance in spanning))"
  },
  {
    "language": "Python",
    "code": "\"\"\"\n最小全域木\nクラスカル法\n\"\"\"\n\n#自分の木の根を探し返す、根を直接の親にする\ndef find(x, par_lst):\n  if par_lst[x] == x:\n    return x\n\n  root = find(par_lst[x], par_lst)\n  par_lst[x] = root\n  return root\n\nwhile True:\n  n = int(input())\n  if not n:\n    break\n  m = int(input())\n\n  edges = []\n  for _ in range(m):\n    a, b, d = map(int, input().split(\",\"))\n    edges.append((d // 100 - 1, a, b))\n\n  #コストでソート済みの辺リスト\n  edges.sort()\n  \n  #各ノードの親のリスト\n  par_lst = [i for i in range(n)]\n  ans = 0\n  \n  #コストの低い辺からチェック\n  for d, a, b in edges:\n    par_a = find(a, par_lst)\n    par_b = find(b, par_lst)\n\n    #親が違うなら併合\n    if par_a != par_b:\n      par_lst[par_a] = par_b\n      ans += d\n\n  print(ans)\n"
  },
  {
    "language": "Python",
    "code": "# http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%A0%E6%B3%95\n\nclass vertex:\n    def __init__(self):\n        self.is_in_V = False\n\ndef is_single_in_V(v,p):\n    a = v[p[0]].is_in_V\n    b = v[p[1]].is_in_V\n    return ( a and not b ) or ( not a and b )\n\ndef all_in_V(v):\n    for e in v:\n        if not e.is_in_V:\n            return False\n    return True\n\ndef add_in_V(v,d):\n    v[d[0]].is_in_V = True\n    v[d[1]].is_in_V = True\n\ndef remove_all_in_V_pass(v,d):\n    for i in xrange(len(d)):\n        try:\n            if v[d[i][0]].is_in_V and v[d[i][1]].is_in_V:\n                d.pop(i)\n        except:\n            pass\n\ndef solve(nu,mu,du):\n    E = []\n    vertexes = [vertex() for i in xrange(nu)]\n    vertexes[0].is_in_V = True\n\n    while True:\n        if all_in_V(vertexes):\n            break\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            if is_single_in_V(vertexes,du[i][0:2]):\n                if min_dist > du[i][2]:\n                    min_dist = du[i][2]\n                    ind = i\n        E.append(min_dist)\n        add_in_V(vertexes,du[ind])\n        du.pop(ind)\n        remove_all_in_V_pass(vertexes,du)\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(n):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "class Wood:\n  def __init__(self,noods,edges):\n    self.noods = noods\n    self.edges = edges\n  def cons(self,other):\n    self.noods.extend(other.noods)\n    self.edges.extend(other.edges)\n\nclass Edge:\n  def __init__(self,n1,n2,length):\n    self.n1 = n1\n    self.n2 = n2\n    self.length = length\n\ndef check(woods,edge):\n  w1 = woods[edge.n1]\n  w2 = woods[edge.n2]\n  if w1.noods!= w2.noods:\n    w1.cons(w2)\n    w1.edges.append(edge)\n    for i in w1.noods:\n      woods[i] = w1\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  m = int(input())\n  e = []\n  woods = []\n  for i in range(m):\n    n1,n2,length = map(int,input().split(\",\"))\n    edge = Edge(n1,n2,length)\n    e.append(edge)\n  e = sorted(e,key=lambda x:x.length)\n\n  for i in range(n):\n    wood = Wood([i],[])\n    woods.append(wood)\n\n  for edge in e:\n    check(woods,edge)\n\n  s = 0\n  for edge in woods[0].edges:\n    s += edge.length//100-1\n  print(s)"
  },
  {
    "language": "Python",
    "code": "def get_input():\n    while True:\n        try:\n            yield ''.join(input())\n        except EOFError:\n            break\n\ndef fmin(a, b):\n    if a < 0:\n        return b\n    if b < 0:\n        return a\n    return min(a,b)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    m = int(input())\n\n    table = [[-1 for i in range(m)] for j in range(m)]\n    X = [i for i in range(m)]\n    for i in range(m):\n        a,b,c = [int(i) for i in input().split(\",\")]\n        table[a][b] = c // 100 - 1\n        table[b][a] = c // 100 - 1\n\n    X.remove(0)\n    costs = [-1 for i in range(m)]\n    for i in range(m):\n        costs[i] = table[0][i]\n    cost = 0\n\n    for l in range(m+m):\n        post = -1\n        mm = -1\n        #print(\"X:\",X)\n        #print(\"costs:\",costs)\n        for i in range(len(X)):\n            if mm == -1:\n                mm = costs[X[i]]\n                post = X[i]\n            elif costs[X[i]] < mm and costs[X[i]] != -1:\n                mm = costs[X[i]]\n                post = X[i]\n            #print(\"i:\",i,\"mcost:\",mm)\n        cost += mm\n\n        for i in range(len(X)):\n            costs[X[i]] = fmin(costs[X[i]], table[post][X[i]])\n\n        #print(\"mcost:\", mm, \"post:\", post)\n        X.remove(post)\n        if len(X) == 0:\n            break\n\n    print(cost)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n\tn = int(raw_input())\n\tif n == 0: break\n\tm = int(raw_input())\n\ts = [map(int, raw_input().split(\",\")) for i in range(m)]\n\ts = sorted(s, key=lambda x:x[2])\n\tls = range(n)\n\tref = ls[:]\n\tans = 0\n\twhile s:\n\t    x,y,d = s.pop(0)\n\t    a,b = ref[x],ref[y]\n\t    if a != b:\n\t        for j in ls:\n\t            if ref[j] == a: ref[j] = b\n\t        ans += d/100 - 1\n\tprint ans "
  },
  {
    "language": "Python",
    "code": "# http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%A0%E6%B3%95\n\nclass vertex:\n    def __init__(self):\n        self.min_distance = float(\"inf\")\n        self.distance = float(\"inf\")\n        self.parent = None\n        self.minimum_adjacency_list = []\n        self.is_in_Q = True\n        self.is_in_V = False\n\ndef is_single_in_V(v,p):\n    a = v[p[0]].is_in_V\n    b = v[p[1]].is_in_V\n    return ( a and not b ) or ( not a and b )\ndef all_in_V(v):\n    for e in v:\n        if not e.is_in_V:\n            return False\n    return True\ndef add_in_V(v,pa):\n    v[pa[0]].is_in_V = True\n    v[pa[1]].is_in_V = True\n\ndef solve(nu,mu,du):\n    V= []\n    E = []\n    vertexes = [vertex() for i in xrange(nu)]\n    vertexes[0].distance = 0\n    V.append(vertexes[0])\n    vertexes[0].is_in_V = True\n    distances = [ e[2] for e in du ]\n    passess = [ e[0:2] for e in du]\n\n    while True:\n        if all_in_V(vertexes):\n            break\n        min_dist = float(\"inf\")\n        for i in xrange(len(du)):\n            pas = passess[i]\n            if is_single_in_V(vertexes,pas):\n                min_dist = min( min_dist, distances[i] )\n        ind = distances.index(min_dist)\n        E.append(min_dist)\n        add_in_V(vertexes,passess[ind])\n    print sum(E)/100 - len(E)\n\n\n\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(n):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "# http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%A0%E6%B3%95\n\nclass vertex:\n    def __init__(self):\n        self.min_distance = float(\"inf\")\n        self.distance = float(\"inf\")\n        self.parent = None\n        self.minimum_adjacency_list = []\n        self.is_in_Q = True\n        self.is_in_V = False\n\ndef is_single_in_V(v,p):\n    a = v[p[0]].is_in_V\n    b = v[p[1]].is_in_V\n    return ( a and not b ) or ( not a and b )\ndef all_in_V(v):\n    for e in v:\n        if not e.is_in_V:\n            return False\n    return True\ndef add_in_V(v,d):\n    v[d[0]].is_in_V = True\n    v[d[1]].is_in_V = True\n\ndef remove_all_in_V_pass(v,d):\n    for i in xrange(len(d)):\n        try:\n            if v[d[i][0]].is_in_V and v[d[i][1]].is_in_V:\n                d.pop(i)\n        except:\n            pass\ndef solve(nu,mu,du):\n    V= []\n    E = []\n    vertexes = [vertex() for i in xrange(nu)]\n    vertexes[0].distance = 0\n    V.append(vertexes[0])\n    vertexes[0].is_in_V = True\n    distances = [ e[2] for e in du ]\n    passess = [ e[0:2] for e in du]\n\n    while True:\n        if all_in_V(vertexes):\n            break\n        min_dist = float(\"inf\")\n        ind = float(\"inf\")\n        for i in xrange(len(du)):\n            pas = passess[i]\n            if is_single_in_V(vertexes,pas):\n                if min_dist > du[i][2]:\n                    min_dist = du[i][2]\n                    ind = i\n\n        E.append(min_dist)\n        add_in_V(vertexes,du[ind])\n        du.pop(ind)\n        remove_all_in_V_pass(vertexes,du)\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(n):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "INF = 10 ** 7\nwhile 1:\n    n = int(input())\n    if n == 0:\n        break\n    m = int(input())\n    M = [[INF] * n for i in range(n)]\n\n    for i in range(m):\n        a, b, c = map(int, input().split(','))\n        M[a][b] = c\n        M[b][a] = c\n\n    d = [INF] * n\n    used = [0] * n\n    d[0] = 0\n\n    while 1:\n        minv = INF\n        for i in range(n):\n            if (not used[i]) and (d[i] < minv):\n                minv = d[i]\n                u = i\n        if minv == INF:\n            break\n        used[u] = 1\n        for i in range(n):\n            if (not used[i]) and M[u][i] != INF and d[i] > M[u][i]:\n                d[i] = M[u][i]\n\n    print(int(sum(d)/100)-(n-1))\n\n"
  },
  {
    "language": "Python",
    "code": "def root(x):\n    if x == p[x]:\n        return x\n    p[x] = y = root(p[x])\n    return y\ndef unite(x, y):\n    px = root(x); py = root(y)\n    if px == py:\n        return 0\n    if px < py:\n        p[py] = px\n    else:\n        p[px] = py\n    return 1\n\n\nwhile 1:\n    N = int(input())\n    if N == 0:\n        break\n    *p, = range(N)\n    M = int(input())\n    E = []\n    for i in range(M):\n        a, b, d = map(int, input().split(','))\n        E.append((d, a, b))\n    E.sort()\n    ans = 0\n    for c, a, b in E:\n        if unite(a, b):\n            ans += (c - 100) // 100\n    print(ans)\n\n"
  },
  {
    "language": "Python",
    "code": "while True:\n\tn = int(raw_input())\n\tif n == 0: break\n\tm = int(raw_input())\n\ts = [map(int, raw_input().split(\",\")) for i in range(m)]\n\ts = sorted(s, key=lambda x:x[2])\n\tls = range(n)\n\tref = ls[:]\n\tans = 0\n\twhile s:\n\t    x,y,d = s.pop(0)\n\t    a,b = ref[x],ref[y]\n\t    if a != b:\n\t        for j in ls:\n\t            if ref[j] == a: ref[j] = b\n\t        ans += d/100 - 1\n\tprint ans "
  },
  {
    "language": "Python",
    "code": "def solve(nu,mu,du):\n    E = []\n    vs = [False]*nu\n    vs[0] = True\n\n    while True:\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            p_from = du[i][0]\n            p_to = du[i][1]\n            if vs[p_from] and vs[p_to]:\n                du.pop(i)\n                break\n            if ( vs[p_from] and not vs[p_to] ) or ( not vs[p_from] and vs[p_to]):\n                if min_dist > du[i][2]:\n                    min_dist,ind,pf,pt = du[i][2],i,p_from,p_to\n        E.append(min_dist)\n        vs[pf] = vs[pt] = True\n        du.pop(ind)\n        if all(vs):\n            break\n\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(m):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n=input()\n    if n==0:break\n    N=range(n)\n    T=N[:]\n    m=input()\n    M=range(m)\n    S=[map(int,raw_input().split(\",\"))for i in M]\n    S=sorted(S,key=lambda x:x[2])        \n    a=0\n    while S:\n        x,y,w=S.pop(0)\n        if T[x]==T[y]:continue\n        for i in N:\n            if T[i]==T[x]:T[i]=T[y]\n        a+=w/100-1\n    print a"
  },
  {
    "language": "Python",
    "code": "n,m = int(raw_input()),int(raw_input())\ns = [map(int, raw_input().split(\",\")) for i in range(m)]\ns = sorted(s, key=lambda x:x[2])\nls = range(n)\nref = ls[:]\nans = 0\nfor i in s:\n    x,y,d = s.pop(0)\n    a,b = ref[x],ref[y]\n    if a != b\n        for j in ls:\n            if ref[j] == a: ref[j] = b\n        ans += d/100 - 1\nprint ans "
  },
  {
    "language": "Python",
    "code": "import sys\n\nwhile True:\n    n = int(raw_input())\n    if n == 0:\n        break\n    m = int(raw_input())\n    M = [[sys.maxint for j in range(n)] for i in range(n)]\n    for i in range(n):\n        M[i][i] = 0\n    for i in range(m):\n        a, b, d = map(int, raw_input().split(','))\n        M[a][b] = d/100 - 1\n        M[b][a] = M[a][b]\n    X = set([0])\n    Y = set(range(n)[0:])\n    cost = 0\n    while len(Y) > 0:\n        mcost = sys.maxint\n        for ex in X:\n            for ey in Y:\n                if mcost > M[ex][ey]:\n                    mcost = M[ex][ey]\n                    et = ey\n        X.add(et)\n        Y.remove(et)\n        cost += mcost\n    print cost"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nn = int(input())\nm = int(input())\n\n# adjacency matrix\nM = [[float('inf') for i in range(n)] for j in range(n)]\n\nfor i in range(m):\n    a, b, d = map(int, input().split(','))\n    M[a][b] = d\n    M[b][a] = d\n\nfor i in range(m):\n    M[i][i] = 0\n\nX = []\nY = [i for i in range(n)]\n\nX.append(0)\nY.remove(0)\n\nlight_num = 0\nwhile len(X) != n:\n    lst = []\n    for x in X:\n        for y in Y:\n            dist = M[x][y]\n            lst.append((dist, x, y))\n    lst.sort()\n\n    # selected node\n    dist, x, y = lst[0]\n    light_num += (dist // 100) - 1\n\n    if x not in X:\n        X.append(x)\n        Y.remove(x)\n    else:\n        X.append(y)\n        Y.remove(y)\nprint(light_num)"
  },
  {
    "language": "Python",
    "code": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport array\nimport collections\nimport heapq\n\n\nAdjacentVertex = collections.namedtuple(\"AdjacentVertex\", \"vertex cost\")\nDIV = 100\nINF = 2 ** 31 - 1\n\n\ndef compute_mst_prim(max_v, adj_list):\n    key = collections.defaultdict(lambda: INF)\n    key[0] = 0\n    pq = [(key[v], v) for v in range(max_v)]\n    heapq.heapify(pq)\n    in_pq = array.array(\"B\", (True for _ in range(max_v)))\n    while pq:\n        _, u = heapq.heappop(pq)\n        in_pq[u] = False\n        for v, v_cost in adj_list[u]:\n            if in_pq[v]:\n                w = v_cost\n                if w < key[v]:\n                    key[v] = w\n                    heapq.heappush(pq, (w, v))\n                    in_pq[v] = True\n    return key\n\n\ndef compute_number_of_lanterns(max_v, adj_list):\n    key = compute_mst_prim(max_v, adj_list)\n    return sum(x - 1 for x in key.values() if x > 0)\n\n\ndef main():\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        m = int(input())\n        adj_list = collections.defaultdict(set)\n        for _ in range(m):\n            a, b, w = map(int, input().split(\",\"))\n            adj_list[a].add((b, w // DIV))\n            adj_list[b].add((a, w // DIV))\n        print(compute_number_of_lanterns(n, adj_list))\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "language": "Python",
    "code": "def solve(nu,mu,du):\n    E = []\n    vs = [False]*nu\n    vs[0] = True\n\n    while True:\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            p_from = du[i][0]\n            p_to = du[i][1]\n            if ( vs[p_from] and not vs[p_to] ) or ( not vs[p_from] and vs[p_to]):\n                if min_dist > du[i][2]:\n                    min_dist,ind,pf,pt = du[i][2],i,p_from,p_to\n        E.append(min_dist)\n        vs[pf] = vs[pt] = True\n        du.pop(ind)\n        if all(vs):\n            break\n        for i in xrange(len(du)):\n            try:\n                if vs[du[i][0]] and vs[du[i][1]]:\n                    du.pop(i)\n            except:\n                pass\n\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(m):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072\n\"\"\"\nimport sys\nfrom enum import Enum\n\n\nclass Mst(object):\n    \"\"\" minimum spanning tree \"\"\"\n    INFINITY = 999999999\n    class Status(Enum):\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n        white = 1  # ????¨????\n        gray = 2  # ?¨???????\n        black = 3  #?¨???????\n\n    def __init__(self, nodes, data):\n        self.num_of_pathes = len(data)\n\n        self.color = [Mst.Status.white] * nodes  # ????????????????¨??????¶???\n        self.M = self._make_matrix(nodes, data)\n        self.d = [Mst.INFINITY] * nodes  #\n        self.p = [-1] * nodes  # ????????????????????????????¨??????????\n\n    def _make_matrix(self, nodes, data):\n        \"\"\" ??£??\\???????????????????????\\?¶?(-1)????????????????????§(Mst.INFINITY)????????´?????? \"\"\"\n        m = [[Mst.INFINITY] * nodes for _ in range(nodes)]\n        for d in data:\n            m[d[0]][d[1]] = d[2]\n            m[d[1]][d[0]] = d[2]\n        return m\n\n    def inf_or_num(self, n):\n        if n == -1:\n            return Mst.INFINITY\n        else:\n            return n\n\n    def prim(self):\n        \"\"\" ??????????????¢?????´?????????????????¨??????????°???¨?????¨????§?????????? \"\"\"\n        self.d[0] = 0  # ??????????????§d[i]???INFINITY??\\???????????£???????????????d[0]??????????????§???d[0]??????????´¢???????§????????????¨?????????\n        self.p[0] = -1  # d[0]?????????????????§????????????????????????\n\n        while True:\n            mincost = Mst.INFINITY\n            for i in range(len(self.d)-1):  # V-T????±??????????????????????????????§????????????????°???????????????????\n                if self.color[i] != Mst.Status.black and self.d[i] < mincost:\n                    mincost = self.d[i]\n                    u = i  # ?????????????????????????????????????????\\???u??§??¢???????????????\n\n            if mincost == Mst.INFINITY:  # ??¨??????V-T??????????????????????????¨????????§while???????????????\n                break\n\n            self.color[u] = Mst.Status.black  # ?????????u???T????±?????????´?????¶?????´??°\n            for v in range(len(self.d)):  # v????????????????????????\n                if self.color[v] != Mst.Status.black and self.M[u][v] != Mst.INFINITY:  # v???V-T??´ ?????? u??¨v?????????????????????\n                    if self.M[u][v] < self.d[v]:  # ????????? u-v?????\\?¶?????????????????????????????????´???\n                        self.d[v] = self.M[u][v]  # v??????????°???????????????±?????´??°\n                        self.p[v] = u  # u???v??????????????¨????????????\n                        self.color[v] = Mst.Status.gray\n\n        # ????°???¨?????¨????????????????????????????¨????\n        results = []\n        for i in range(len(self.p)):\n            if self.p[i] != -1:\n                results.append(self.M[i][self.p[i]]/100 - 1)\n        return int(sum(results))\n\n\n\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        m = int(input())\n        pathes = []\n        for _ in range(m):\n            pathes.append([int(x) for x in input().split(',')])\n        s = Mst(n, pathes)\n        result = s.prim()\n        print(result)\n\n\n\n    # n = 4\n    # pathes = [[0, 1, 1500], [0, 2, 2000], [1, 2, 600], [1, 3, 500]]\n    # s = Mst(n, pathes)\n    # result = s.prim()\n    # print(result)\n\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import sys\nwhile 1:\n    n=input()\n    if n==0:break\n    m=input()\n    M=range(m)\n    A=[0]*n\n    B=[map(int,raw_input().split(\",\"))for i in M]\n    B=sorted(B,key=lambda x:x[2])\n    s=0\n    c=0\n    for i,j,w in B:\n        f=[0,2][A[i]]+[0,1][A[j]]\n        if f==0:\n            A[i],A[j]=1,1\n            s+=w/100-1\n            c+=2\n        elif f==1:\n            A[i]=1\n            s+=w/100-1\n            c+=1\n        elif f==2:\n            A[j]=1\n            s+=w/100-1\n            c+=1\n        if c==n:break\n    print s"
  },
  {
    "language": "Python",
    "code": "def solve(nu,mu,du):\n    E = []\n    vs = [False]*nu\n    vs[0] = True\n\n    while True:\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            p_from = du[i][0]\n            p_to = du[i][1]\n            dist = du[i][2]\n            if ( vs[p_from] and not vs[p_to] ) or ( not vs[p_from] and vs[p_to]):\n                if min_dist > dist:\n                    min_dist,ind,pf,pt = dist,i,p_from,p_to\n        E.append(min_dist)\n        vs[pf] = vs[pt] = True\n        du.pop(ind)\n        if all(vs):\n            break\n        for i in xrange(len(du)):\n            try:\n                if vs[du[i][0]] and vs[du[i][1]]:\n                    du.pop(i)\n            except:\n                pass\n\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(m):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "def get_input():\n    while True:\n        try:\n            yield ''.join(input())\n        except EOFError:\n            break\n\ndef fmin(a, b):\n    if a < 0:\n        return b\n    if b < 0:\n        return a\n    return min(a,b)\n\nwhile True:\n    n = int(input())\n    if n == 0:\n        break\n    m = int(input())\n\n    table = [[-1 for i in range(m)] for j in range(m)]\n    X = [i for i in range(m)]\n    for i in range(m):\n        a,b,c = [int(i) for i in input().split(\",\")]\n        table[a][b] = c // 100 - 1\n        table[b][a] = c // 100 - 1\n\n    X.remove(0)\n    costs = [-1 for i in range(m)]\n    for i in range(m):\n        costs[i] = table[0][i]\n    cost = 0\n\n    while True:\n        post = -1\n        mm = -1\n        #print(\"X:\",X)\n        #print(\"costs:\",costs)\n        for i in range(len(X)):\n            if mm == -1:\n                mm = costs[X[i]]\n                post = X[i]\n            elif costs[X[i]] < mm and costs[X[i]] != -1:\n                mm = costs[X[i]]\n                post = X[i]\n            #print(\"i:\",i,\"mcost:\",mm)\n        cost += mm\n\n        for i in range(len(X)):\n            costs[X[i]] = fmin(costs[X[i]], table[post][X[i]])\n\n        #print(\"mcost:\", mm, \"post:\", post)\n        X.remove(post)\n        if len(X) == 0:\n            break\n\n    print(cost)\n\n\n\n"
  },
  {
    "language": "Python",
    "code": "class Wood:\n  def __init__(self,num,noods,edges):\n    self.num = num\n    self.noods = noods\n    self.edges = edges\n  def cons(self,other):\n    self.noods.extend(other.noods)\n    self.edges.extend(other.edges)\n\nclass Edge:\n  def __init__(self,n1,n2,length):\n    self.n1 = n1\n    self.n2 = n2\n    self.length = length\n\ndef check(woods,edge):\n  if woods[edge.n1].num != woods[edge.n2].num:\n    woods[edge.n1].cons(woods[edge.n2])\n    woods[edge.n1].edges.append(edge)\n    for i in woods[edge.n1].noods:\n      woods[i] = woods[edge.n1]\nwhile True:\n  n = int(input())\n  if n == 0:\n    break\n  m = int(input())\n  e = []\n  woods = []\n  for i in range(m):\n    n1,n2,length = map(int,input().split(\",\"))\n    edge = Edge(n1,n2,length)\n    e.append(edge)\n  e = sorted(e,key=lambda x:x.length)\n  for i in range(n):\n    wood = Wood(i,[i],[])\n    woods.append(wood)\n  for edge in e:\n    check(woods,edge)\n  s = 0\n  for edge in woods[0].edges:\n    s += edge.length//100-1\n  print(s)"
  },
  {
    "language": "Python",
    "code": "def solve(nu,mu,du):\n    E = []\n    vs = [False]*nu\n    vs[0] = True\n\n    while True:\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            if ( ( vs[du[i][0]] and not vs[du[i][1]] ) or ( not vs[du[i][0]] and vs[du[i][1]]) ) and min_dist > du[i][2]:\n                min_dist,ind,pf,pt = du[i][2],i,du[i][0],du[i][1]\n        E.append(min_dist)\n        vs[pf] = vs[pt] = True\n        du.pop(ind)\n        if all(vs):\n            break\n\n        for i in xrange(len(du)):\n            try:\n                if vs[du[i][0]] and vs[du[i][1]]:\n                    du.pop(i)\n            except:\n                pass\n\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(m):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "N=int(input())\nadress={}\ncounter={}\nans={}\nAns=0\nfor i in range(int(input())):\n    a,b,d=map(int,input().split(\",\"))\n    adress[(a,b)]=d\n    adress[(b,a)]=d\nadress=sorted(adress.items(),key=lambda x:x[0])\nfor j in adress:\n    if j[0][0] in counter:counter[j[0][0]] +=1\n    else:counter[j[0][0]]=1\nfor v in adress:\n    if v[0][0] in ans:ans[v[0][0]]=min(v[1],ans[v[0][0]])\n    else:ans[v[0][0]]=v[1]\nfor n,m in counter.items():\n    if m==1:del ans[n]\nfor x,y in ans.items():\n    Ans +=y\nprint(int((Ans/100)-len(ans)))\n"
  },
  {
    "language": "Python",
    "code": "import sys\nn=input()\nN=range(n)\nm=input()\nA=[sys.maxint]*n\nB=[A[:] for i in N]\nA=[0]*n\nC=[A[:] for i in N]\nwhile 1:\n    s=raw_input()\n    if s==\"0\": break\n    a,b,w=map(int,s.split(\",\"))\n    B[a][b],B[b][a]=w,w\n\ns=0\nfor i in N:\n    x=min(B[i])\n    y=B[i].index(x)\n    if C[i][y]==0:\n        C[i][y],C[y][i]=1,1\n        s+=x/100-1\nprint s"
  },
  {
    "language": "Python",
    "code": "def solve(nu,mu,du):\n    E = []\n    vs = [False]*nu\n    vs[0] = True\n\n    while True:\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            if ( ( vs[du[i][0]] and not vs[du[i][1]] ) or ( not vs[du[i][0]] and vs[du[i][1]]) ) and min_dist > du[i][2]:\n                min_dist,ind,pf,pt = du[i][2],i,du[i][0],du[i][1]\n        E.append(min_dist)\n        vs[pf] = vs[pt] = True\n        du.pop(ind)\n        if all(vs):\n            break\n        for i in xrange(len(du)):\n            try:\n                if vs[du[i][0]] and vs[du[i][1]]:\n                    du.pop(i)\n            except:\n                pass\n\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(m):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n=input()\n    if n==0:break\n    N=range(n)\n    T=N[:]\n    M=range(input())\n    S=[map(int,raw_input().split(\",\"))for i in M]\n    S=sorted(S,key=lambda x:x[2])        \n    a=0\n    while S:\n        x,y,w=S.pop(0)\n        b,c=T[x],T[y]\n        if b==c:continue\n        for i in N:\n            if T[i]==b:T[i]=c\n        a+=w/100-1\n    print a"
  },
  {
    "language": "Python",
    "code": "def solve(nu,mu,du):\n    E = []\n    vs = [False]*nu\n    vs[0] = True\n\n    while True:\n        if all(vs):\n            break\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            p_from = du[i][0]\n            p_to = du[i][1]\n            if vs[p_from] and vs[p_to]:\n                du.pop(i)\n                continue\n            if ( vs[p_from] and not vs[p_to] ) or ( not vs[p_from] and vs[p_to]):\n                if min_dist > du[i][2]:\n                    min_dist,ind,pf,pt = du[i][2],i,p_from,p_to\n        E.append(min_dist)\n        vs[pf] = vs[pt] = True\n        du.pop(ind)\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(m):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "def solve(nu,mu,du):\n    E = []\n    vs = [False]*nu\n    vs[0] = True\n\n    while True:\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            if ( ( vs[du[i][0]] and not vs[du[i][1]] ) or ( not vs[du[i][0]] and vs[du[i][1]]) ) and min_dist > du[i][2]:\n                min_dist,ind,pf,pt = du[i][2],i,du[i][0],du[i][1]\n        E.append(min_dist)\n        vs[pf] = vs[pt] = True\n        du.pop(ind)\n        if all(vs):\n            break\n        for e in du:\n            if vs[e[0]] and vs[e[1]]:\n                du.remove(e)\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(m):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "while True:\n    n=input()\n    if n==0:\n        break\n    graph=[[1<<30]*n for i in xrange(n)]\n    for i in xrange(input()):\n        a,b,c=map(int,raw_input().strip().split(\",\"))\n        graph[a][b]=graph[b][a]=c\n    visited=[False]*n\n    visited[0],ans=True,0\n    while not all(visited):\n        t=min( [(i,j,graph[i][j])for j in xrange(n) if not visited[j] for i in xrange(n) if visited[i]],key= lambda x:x[2])\n        ans+=t[2]/100-1\n        visited[t[1]]=True\n    print ans"
  },
  {
    "language": "Python",
    "code": "def warshall_floyd(n, vertices):\n    for i in range(n):\n        for j in range(n):\n            c2 = vertices[j][i]\n            for k, (c1, c3) in enumerate(zip(vertices[j], vertices[i])):\n                if c1 > c2+c3:\n                    vertices[j][k] = c2+c3\n    return vertices\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    m = int(input())\n    inf = float(\"inf\")\n    vertices = [[inf if i!=j else 0 for j in range(n)] for i in range(n)]\n\n    for _ in [None]*m:\n        s, t, d = map(int, input().split(\",\"))\n        vertices[s][t] = d//100-1\n        vertices[t][s] = d//100-1\n\n    vertices = warshall_floyd(n, vertices)\n    print(min(sum(costs) for costs in vertices))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\"\"\"\nhttp://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0072\n\"\"\"\nimport sys\nfrom enum import Enum\n\n\nclass Mst(object):\n    \"\"\" minimum spanning tree \"\"\"\n    INFINITY = 999999999\n    class Status(Enum):\n        \"\"\" ?????????????¨??????¶??? \"\"\"\n        white = 1  # ????¨????\n        gray = 2  # ?¨???????\n        black = 3  #?¨???????\n\n    def __init__(self, nodes, data):\n        self.num_of_pathes = len(data)\n        self.color = [Mst.Status.white] * nodes  # ????????????????¨??????¶???\n        self.M = self._make_matrix(nodes, data)\n        self.d = [Mst.INFINITY] * nodes  #\n        self.p = [-1] * nodes  # ????????????????????????????¨??????????\n\n    def _make_matrix(self, nodes, data):\n        \"\"\" ??£??\\???????????????????????\\?¶?(-1)????????????????????§(Mst.INFINITY)????????´?????? \"\"\"\n        m = [[Mst.INFINITY] * nodes for _ in range(nodes)]\n        for d in data:\n            m[d[0]][d[1]] = d[2]\n            m[d[1]][d[0]] = d[2]\n        return m\n\n\n    def prim(self):\n        \"\"\" ??????????????¢?????´?????????????????¨??????????°???¨?????¨????§?????????? \"\"\"\n        self.d[0] = 0  # ??????????????§d[i]???INFINITY??\\???????????£???????????????d[0]??????????????§???d[0]??????????´¢???????§????????????¨?????????\n        self.p[0] = -1  # d[0]?????????????????§????????????????????????\n\n        while True:\n            mincost = Mst.INFINITY\n            for i in range(len(self.d)):  # V-T????±??????????????????????????????§????????????????°???????????????????\n                if self.color[i] != Mst.Status.black and self.d[i] < mincost:\n                    mincost = self.d[i]\n                    u = i  # ?????????????????????????????????????????\\???u??§??¢???????????????\n\n            if mincost == Mst.INFINITY:  # ??¨??????V-T??????????????????????????¨????????§while???????????????\n                break\n\n            self.color[u] = Mst.Status.black  # ?????????u???T????±?????????´?????¶?????´??°\n            for v in range(len(self.d)):  # v????????????????????????\n                if self.color[v] != Mst.Status.black and self.M[u][v] != Mst.INFINITY:  # v???V-T??´ ?????? u??¨v?????????????????????\n                    if self.M[u][v] < self.d[v]:  # ????????? u-v?????\\?¶?????????????????????????????????´???\n                        self.d[v] = self.M[u][v]  # v??????????°???????????????±?????´??°\n                        self.p[v] = u  # u???v??????????????¨????????????\n                        self.color[v] = Mst.Status.gray\n\n        # ????°???¨?????¨????????????????????????????¨????\n        results = []\n        for i in range(len(self.p)):\n            if self.p[i] != -1:\n                results.append(self.M[i][self.p[i]]/100 - 1)\n        return int(sum(results))\n\n\n\ndef main(args):\n    while True:\n        n = int(input())\n        if n == 0:\n            break\n        m = int(input())\n        pathes = []\n        for _ in range(m):\n            pathes.append([int(x) for x in input().split(',')])\n        s = Mst(n, pathes)\n        result = s.prim()\n        print(result)\n\n\n\n    # n = 4\n    # pathes = [[0, 1, 1500], [0, 2, 2000], [1, 2, 600], [1, 3, 500]]\n    # s = Mst(n, pathes)\n    # result = s.prim()\n    # print(result)\n\n\n\n\nif __name__ == '__main__':\n    main(sys.argv[1:])"
  },
  {
    "language": "Python",
    "code": "import sys\nwhile 1:\n    n=input()\n    if n==0:break\n    N=range(n)\n    m=input()\n    M=range(m)\n    A=[sys.maxint]*n\n    B=[A[:] for i in N]\n    A=[0]*n\n    C=[A[:] for i in N]\n    for i in M:\n        a,b,w=map(int,raw_input().split(\",\"))\n        B[a][b],B[b][a]=w,w\n\n    s=0\n    for i in N:\n        x=min(B[i])\n        y=B[i].index(x)\n        if C[i][y]==0:\n            C[i][y],C[y][i]=1,1\n            s+=x/100-1\n    print s"
  },
  {
    "language": "Python",
    "code": "# AOJ 0072: Carden Lanternl\n# Python3 2018.6.28 bal4u\n\n# UNION-FIND library\nclass UnionSet:\n\tdef __init__(self, nmax):\n\t\tself.size = [1]*nmax\n\t\tself.id = [i for i in range(nmax+1)]\n\tdef root(self, i):\n\t\twhile i != self.id[i]:\n\t\t\tself.id[i] = self.id[self.id[i]]\n\t\t\ti = self.id[i]\n\t\treturn i\n\tdef connected(self, p, q): return self.root(p) == self.root(q)\n\tdef unite(self, p, q):\n\t\ti, j = self.root(p), self.root(q)\n\t\tif i == j: return\n\t\tif self.size[i] < self.size[j]:\n\t\t\tself.id[i] = j\n\t\t\tself.size[j] += self.size[i]\n\t\telse:\n\t\t\tself.id[j] = i\n\t\t\tself.size[i] += self.size[j]\n# UNION-FIND library\n\nwhile True:\n\tn = int(input())\n\tif n == 0: break\n\tu = UnionSet(n)\n\tm = int(input())\n\ttbl = []\n\tfor i in range(m):\n\t\ta, b, d = map(int, input().split(','))\n\t\ttbl.append((d//100-1, a, b))\n\ttbl.sort()\n\tans = 0;\n\tfor x in tbl:\n\t\td, a, b = x\n\t\tif not u.connected(a, b):\n\t\t\tu.unite(a, b)\n\t\t\tans += d\n\tprint(ans)\n"
  },
  {
    "language": "Python",
    "code": "def kruskal(n: int, edges: list) -> int:\n    tree = [-1]*n\n\n    def get_root(x):\n        if tree[x] < 0:\n            return x\n        else:\n            tree[x] = get_root(tree[x])\n            return tree[x]\n\n    def unite(x, y):\n        x, y = get_root(x), get_root(y)\n        if x != y:\n            big, small = (x, y) if tree[x] < tree[y] else (y, x)\n            tree[big] += tree[small]\n            tree[small] = big\n        return x != y\n\n    edges.sort()\n    total = 0\n    cnt = 0\n    for w, s, t in edges:\n        if unite(s, t):\n            cnt += 1\n            total += w\n            if cnt == n - 1:\n                break\n\n    return total\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    m = int(input())\n    inf = float(\"inf\")\n\n    edges = []\n    for _ in [None]*m:\n        s, t, d = map(int, input().split(\",\"))\n        edges.append((d//100-1, s, t))\n\n    print(kruskal(n, edges))\n"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nfor s in sys.stdin:\n    n = int(s)\n    if n == 0:\n        break\n\n    m = int(input())\n\n    # adjacency matrix\n    M = [[float('inf') for i in range(n)] for j in range(n)]\n\n    for i in range(m):\n        a, b, d = map(int, input().split(','))\n        M[a][b] = d\n        M[b][a] = d\n\n    for i in range(m):\n        M[i][i] = 0\n\n    X = []\n    Y = [i for i in range(n)]\n\n    X.append(0)\n    Y.remove(0)\n\n    light_num = 0\n    while len(X) != n:\n        lst = []\n        for x in X:\n            for y in Y:\n                dist = M[x][y]\n                lst.append((dist, x, y))\n        lst.sort()\n\n        # selected node\n        dist, x, y = lst[0]\n        light_num += (dist // 100) - 1\n\n        if x not in X:\n            X.append(x)\n            Y.remove(x)\n        else:\n            X.append(y)\n            Y.remove(y)\n    print(light_num)"
  },
  {
    "language": "Python",
    "code": "while(1):\n    n=int(raw_input())\n    if n==0:\n        break\n    m=int(raw_input())\n    distlist=[[] for x in range(n)]\n    for i in range(m):\n        [a,b,d]=[int(x) for x in raw_input().split(',')]\n        distlist[a].append((b,d))\n        distlist[b].append((a,d))\n        \n    visited=[0]\n    notyet={}\n    for i in range(1,n):\n        notyet[i]=float('inf')\n    toro=0\n    for pk in distlist[0]:\n        dest=pk[0]\n        dd=pk[1]\n        notyet[dest]=dd\n        \n    while len(notyet)!=0:\n        #search for smallest dist\n        smallest=float('inf')\n        K=0\n        for k in notyet:\n            if notyet[k]<smallest:\n                smallest=notyet[k]\n                K=k\n        #print smallest,K,notyet\n        toro=toro+smallest/100-1\n        for pk in distlist[K]:\n            dest=pk[0]\n            dd=pk[1]\n            if dest in notyet:\n                notyet[dest]=min(notyet[dest],dd)\n        del notyet[K]\n    print toro"
  },
  {
    "language": "Python",
    "code": "INF=1e10\n\ndef prim():\n    mincost=[INF]*n\n    used=[False]*n\n    mincost[0]=0\n    res=0\n    while True:\n        v=-1\n        for u in range(n):\n            if  not used[u] and (v==-1 or mincost[u]<mincost[v]):\n                v=u\n        if v==-1:\n            break\n        used[v]=True\n        res+=mincost[v]\n        for u in range(n):\n            mincost[u]=min(mincost[u],cost[v][u])\n    return res\n\nwhile True:\n    n=input()\n    if n==0:break\n    m=input()\n\n    cost=[[INF]*n for i in range(n)]\n    for i in range(m):\n        a,b,d=map(int,raw_input().split(\",\"))\n        cost[a-1][b-1]=(d-100)/100\n        cost[b-1][a-1]=(d-100)/100\n    print prim()"
  },
  {
    "language": "Python",
    "code": "# http://ja.wikipedia.org/wiki/%E3%83%97%E3%83%AA%E3%83%A0%E6%B3%95\n\nclass vertex:\n    def __init__(self):\n        self.is_in_V = False\n\ndef is_single_in_V(v,p):\n    a = v[p[0]].is_in_V\n    b = v[p[1]].is_in_V\n    return ( a and not b ) or ( not a and b )\n\ndef all_in_V(v):\n    for e in v:\n        if not e.is_in_V:\n            return False\n    return True\n\ndef add_in_V(v,d):\n    v[d[0]].is_in_V = True\n    v[d[1]].is_in_V = True\n\ndef remove_all_in_V_pass(v,d):\n    for i in xrange(len(d)):\n        try:\n            if v[d[i][0]].is_in_V and v[d[i][1]].is_in_V:\n                d.pop(i)\n        except:\n            pass\n\ndef solve(nu,mu,du):\n    E = []\n    vertexes = [vertex() for i in xrange(nu)]\n    vertexes[0].is_in_V = True\n\n    while True:\n        if all_in_V(vertexes):\n            break\n        min_dist,ind = float(\"inf\"),float(\"inf\")\n        for i in xrange(len(du)):\n            if is_single_in_V(vertexes,du[i][0:2]):\n                if min_dist > du[i][2]:\n                    min_dist,ind = du[i][2],i\n        E.append(min_dist)\n        add_in_V(vertexes,du[ind])\n        du.pop(ind)\n        remove_all_in_V_pass(vertexes,du)\n    print sum(E)/100 - len(E)\n\nwhile True:\n    n = input()\n    if n == 0:\n        exit()\n    m = input()\n    data = []\n    for i in xrange(m):\n        data.append( map(int,raw_input().split(\",\")) )\n    solve(n,m,data)"
  },
  {
    "language": "Python",
    "code": "class UnionFind:\n  def __init__(self, size):\n    self.table = [-1 for _ in xrange(size)]\n\n  def find(self, x):\n    while self.table[x] >= 0: x = self.table[x]\n    return x\n\n  def union(self, x, y):\n    s1 = self.find(x)\n    s2 = self.find(y)\n    if s1 != s2:\n      if self.table[s1] >= self.table[s2]:\n        self.table[s1] += self.table[s2]\n        self.table[s2] = s1\n      else:\n        self.table[s2] += self.table[s1]\n        self.table[s1] = s2\n      return True\n    return False\n\ndef hash(n, s, g):\n  return n*s+g\n\ndef dehash(n, hs):\n  return [(hs-hs%n)/n, hs%n]\n\ndef kruskal(n, path):\n  path = sorted(path.items(), key=lambda x:x[1])\n  selected = {}\n  union = UnionFind(n)\n  for i in xrange(len(path)):\n    k,v = path[i]\n    s,g = dehash(n, k)\n    if union.union(s, g):\n      selected[k] = v\n  return selected\n\n# main\nwhile True:\n  n = int(raw_input())\n  if n==0:\n    break\n  m = int(raw_input())\n  path = {}\n  for _ in xrange(m):\n    a,b,d = map(int, raw_input().split(\",\"))\n    path[hash(n, a, b)] = d/100-1\n  result = kruskal(n, path)\n  sumdist = 0\n  for v in result.values():\n    sumdist += v\n  print sumdist"
  },
  {
    "language": "Python",
    "code": "while 1:\n    n=int(raw_input())\n    if n==0:\n        break\n    m=int(raw_input())\n    s=[map(int ,raw_input().split(',')) for i in range(m)]\n    s=sorted(s, key=lambda x:x[2])\n    ls=range(n)\n    ref=ls[:]\n    ans=0\n    while s:\n        x,y,d=s.pop(0)\n        a,b=ref[x],ref[y]\n        if a!=b:\n            for j in ls:\n                if ref[j]==a:\n                    ref[j]=b\n            ans+=d/100-1\n    print ans"
  },
  {
    "language": "Python",
    "code": "def prim(n):\n    min_cost = [1 << 31] * n\n    used = [False] * n\n    min_cost[0] = 0\n    ret = 0\n    while 1:\n        v = -1\n        for u in range(n):\n            if not used[u] and (v == -1 or min_cost[u] < min_cost[v]):\n                v = u\n        if v == -1:\n            break\n        used[v] = True\n        ret += min_cost[v] - 100\n\n        for u in range(n):\n            min_cost[u] = min(min_cost[u], edges[v][u])\n    return ret\n\nif __name__ == '__main__':\n    while 1:\n        n = input()\n        if n == 0:\n            break\n        m = input()\n\n        edges = [[1 << 30] * n for _ in xrange(n)]\n        for i in xrange(m):\n            a, b, cost = map(int, raw_input().split(','))\n            edges[a][b] = cost\n            edges[b][a] = cost\n        print (prim(n) + 100) / 100"
  },
  {
    "language": "Python",
    "code": "# -*- coding: utf-8 -*-\n\nimport sys\nimport os\n\nfor s in sys.stdin:\n    n = int(s) # node num\n    if n == 0:\n        break\n\n    m = int(input()) # edge num\n\n    # adjacency matrix\n    M = [[float('inf') for i in range(n)] for j in range(n)]\n\n    for i in range(m):\n        a, b, d = map(int, input().split(','))\n        M[a][b] = d\n        M[b][a] = d\n\n    for i in range(n):\n        M[i][i] = 0\n\n    X = [] # selected\n    Y = [i for i in range(n)] # not selected\n\n    X.append(0)\n    Y.remove(0)\n\n    light_num = 0\n    while len(X) != n:\n        lst = []\n        for x in X:\n            for y in Y:\n                dist = M[x][y]\n                lst.append((dist, x, y))\n        lst.sort()\n\n        # selected node\n        dist, x, y = lst[0]\n        light_num += (dist // 100) - 1\n\n        if x not in X:\n            X.append(x)\n            Y.remove(x)\n        else:\n            X.append(y)\n            Y.remove(y)\n    print(light_num)"
  },
  {
    "language": "Python",
    "code": "while True:\n\tn = int(raw_input())\n\tif n == 0: break\n\tm = int(raw_input())\n\ts = [map(int, raw_input().split(\",\")) for i in range(m)]\n\ts = sorted(s, key=lambda x:x[2])\n\tls = range(n)\n\tref = ls[:]\n\tans = 0\n\twhile s:\n\t    x,y,d = s.pop(0)\n\t    a,b = ref[x],ref[y]\n\t    if a != b:\n\t        for j in ls:\n\t            if ref[j] == a: ref[j] = b\n\t        ans += d/100 - 1\n\tprint ans "
  },
  {
    "language": "Python",
    "code": "def prim(n):\n    min_cost = [1 << 31] * n\n    used = [False] * n\n    min_cost[0] = 0\n    ret = 0\n    while 1:\n        v = -1\n        for u in range(n):\n            if not used[u] and (v == -1 or min_cost[u] < min_cost[v]):\n                v = u\n        if v == -1:\n            break\n        used[v] = True\n        ret += min_cost[v] - 100\n\n        for u in range(n):\n            min_cost[u] = min(min_cost[u], edges[v][u])\n    return ret\n\nif __name__ == '__main__':\n    n, m = input(), input()\n    edges = [[1 << 30] * n for _ in xrange(n)]\n    for i in xrange(m):\n        a, b, cost = map(int, raw_input().split(','))\n        edges[a][b] = cost\n        edges[b][a] = cost\n    print (prim(n) + 100) / 100"
  },
  {
    "language": "Python",
    "code": "def kruskal(n: int, edges: list) -> int:\n    tree = [-1]*n\n\n    def get_root(x):\n        if tree[x] < 0:\n            return x\n        tree[x] = get_root(tree[x])\n        return tree[x]\n\n    def unite(x, y):\n        x, y = get_root(x), get_root(y)\n        if x != y:\n            big, small = (x, y) if tree[x] < tree[y] else (y, x)\n            tree[big] += tree[small]\n            tree[small] = big\n        return x != y\n\n    return sum(w for (w, _, _), _ in zip(filter(lambda p: unite(p[1], p[2]), sorted(edges)), range(n)))\n\nwhile True:\n    n = int(input())\n    if not n:\n        break\n    m = int(input())\n    inf = float(\"inf\")\n\n    edges = []\n    for _ in [None]*m:\n        s, t, d = map(int, input().split(\",\"))\n        edges.append((d//100-1, s, t))\n\n    print(kruskal(n, edges))\n"
  }
]